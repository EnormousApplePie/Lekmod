; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTeam.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?m_aTeams@CvTeam@@1PAV1@A			; CvTeam::m_aTeams
_BSS	SEGMENT
?m_aTeams@CvTeam@@1PAV1@A DD 01H DUP (?)		; CvTeam::m_aTeams
_BSS	ENDS
CONST	SEGMENT
$SG223545 DB	'TXT_KEY_MISC_PLAYER_PERMANENT_ALLIANCE', 00H
	ORG $+1
$SG223552 DB	'TXT_KEY_MISC_PLAYER_PERMANENT_ALLIANCE', 00H
	ORG $+1
$SG223897 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG223912 DB	'CanDeclareWar', 00H
	ORG $+2
$SG223954 DB	'DeclareWar', 00H
	ORG $+1
$SG223981 DB	'TXT_KEY_MISC_YOU_DECLARED_WAR_ON', 00H
	ORG $+3
$SG223992 DB	'TXT_KEY_MISC_DECLARED_WAR_ON_YOU', 00H
	ORG $+3
$SG223998 DB	'TXT_KEY_MISC_SOMEONE_DECLARED_WAR', 00H
	ORG $+2
$SG224004 DB	'TXT_KEY_MISC_SOMEONE_DECLARES_WAR', 00H
	ORG $+2
$SG224243 DB	'TXT_KEY_MISC_YOUR_MINOR_ALLIES_DECLARED_WAR_SUMMARY', 00H
$SG224245 DB	'TXT_KEY_MISC_YOUR_MINOR_ALLIES_DECLARED_WAR', 00H
$SG224251 DB	'TXT_KEY_MISC_MINOR_ALLIES_DECLARED_WAR_ON_YOU_SUMMARY', 00H
	ORG $+2
$SG224253 DB	'TXT_KEY_MISC_MINOR_ALLIES_DECLARED_WAR_ON_YOU', 00H
	ORG $+2
$SG224265 DB	'[NEWLINE]', 00H
	ORG $+2
$SG224268 DB	'[NEWLINE]', 00H
	ORG $+2
$SG224296 DB	'MakePeace', 00H
	ORG $+2
$SG224341 DB	'TXT_KEY_MISC_YOUR_MINOR_ALLIES_MADE_PEACE', 00H
	ORG $+2
$SG224344 DB	'TXT_KEY_MISC_YOUR_MINOR_ALLIES_MADE_PEACE_SUMMARY', 00H
	ORG $+2
$SG224357 DB	'[NEWLINE]', 00H
	ORG $+2
$SG224383 DB	'TXT_KEY_MISC_YOU_MADE_PEACE_WITH', 00H
	ORG $+3
$SG224390 DB	'TXT_KEY_MISC_YOU_MADE_PEACE_WITH', 00H
	ORG $+3
$SG224397 DB	'TXT_KEY_MISC_SOMEONE_MADE_PEACE', 00H
$SG224407 DB	'TXT_KEY_MISC_SOMEONE_MADE_PEACE', 00H
$SG224418 DB	'TeamMeet', 00H
	ORG $+3
$SG224877 DB	'Tie for most favored other team to vote for. Rolling to '
	DB	'choose.', 00H
$SG225254 DB	'/', 00H
	ORG $+2
$SG225273 DB	'/', 00H
	ORG $+2
$SG225796 DB	'TXT_KEY_NOTIFICATION_MET_MINOR_CIV', 00H
	ORG $+1
$SG225799 DB	'TXT_KEY_NOTIFICATION_SUMMARY_MET_MINOR_CIV', 00H
	ORG $+1
$SG226008 DB	'TXT_KEY_NOTIFICATION_DIPLOMAT_EJECTED', 00H
	ORG $+2
$SG226011 DB	'TXT_KEY_NOTIFICATION_DIPLOMAT_EJECTED_TT', 00H
	ORG $+3
$SG226043 DB	'TXT_KEY_NOTIFICATION_NON_AGGRESSION', 00H
$SG226046 DB	'TXT_KEY_NOTIFICATION_NON_AGGRESSION_S', 00H
	ORG $+2
$SG226076 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG226082 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG226118 DB	'TXT_KEY_NOTIFICATION_RESEARCH_AGREEMENT', 00H
$SG226143 DB	'TXT_KEY_MISC_PLAYERS_SIGN_TRADE_AGREEMENT', 00H
	ORG $+2
$SG226321 DB	'TXT_KEY_MISC_COMPLETES_PROJECT', 00H
	ORG $+1
$SG226327 DB	'TXT_KEY_MISC_SOMEONE_HAS_COMPLETED', 00H
	ORG $+1
$SG226330 DB	'TXT_KEY_MISC_WONDER_COMPLETED_UNKNOWN', 00H
	ORG $+2
$SG226558 DB	'TXT_KEY_VICTORY_RESET', 00H
	ORG $+2
$SG226566 DB	'AS2D_MELTDOWN', 00H
	ORG $+2
$SG226693 DB	'TXT_KEY_MISC_PROGRESS_TOWARDS_TECH', 00H
	ORG $+1
$SG226694 DB	'TXT_KEY_MISC_YOU_DISCOVERED_TECH', 00H
	ORG $+3
$SG226716 DB	'TECH_SATELLITES', 00H
$SG226717 DB	'CIVILIZATION_HUNS', 00H
	ORG $+2
$SG226718 DB	'WORLDSIZE_HUGE', 00H
	ORG $+1
$SG226722 DB	'GAMEOPTION_TWEAKED_SCORING', 00H
	ORG $+1
$SG226772 DB	'TXT_KEY_NOTIFICATION_FOUND_RESOURCE', 00H
$SG226775 DB	'TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE', 00H
$SG226812 DB	'RESOURCE_ARTIFACTS', 00H
	ORG $+1
$SG226817 DB	'RESOURCE_HIDDEN_ARTIFACTS', 00H
	ORG $+2
$SG226838 DB	'TXT_KEY_NOTIFICATION_FOUND_ARTIFACTS', 00H
	ORG $+3
$SG226840 DB	'TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE', 00H
$SG226844 DB	'TXT_KEY_NOTIFICATION_FOUND_HIDDEN_ARTIFACTS', 00H
$SG226846 DB	'TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE', 00H
$SG226907 DB	'TXT_KEY_MISC_FIRST_TECH_CHOOSE_FREE', 00H
$SG226920 DB	'TXT_KEY_MISC_SOMEONE_FIRST_TO_TECH', 00H
	ORG $+1
$SG226923 DB	'TXT_KEY_MISC_UNKNOWN_FIRST_TO_TECH', 00H
	ORG $+1
$SG226927 DB	'TXT_KEY_MISC_SOMEONE_FIRST_TO_TECH', 00H
	ORG $+1
$SG226953 DB	'RESOURCE_ARTIFACTS', 00H
	ORG $+1
$SG226955 DB	'TXT_KEY_MISC_DISCOVERED_ARTIFACTS_NEAR', 00H
	ORG $+1
$SG226958 DB	'RESOURCE_HIDDEN_ARTIFACTS', 00H
	ORG $+2
$SG226960 DB	'TXT_KEY_MISC_DISCOVERED_HIDDEN_ARTIFACTS_NEAR', 00H
	ORG $+2
$SG226965 DB	'TXT_KEY_MISC_YOU_DISCOVERED_RESOURCE', 00H
	ORG $+3
$SG226984 DB	'TXT_KEY_MISC_RESOURCE_DISCOVERED_CITY_DEMANDS', 00H
	ORG $+2
$SG227016 DB	'TXT_KEY_MISC_WHAT_TO_RESEARCH_NEXT', 00H
	ORG $+1
$SG227042 DB	'TXT_KEY_MISC_YOU_DISCOVERED_TECH', 00H
	ORG $+3
$SG227172 DB	'TXT_KEY_MISC_SOMEONE_CIRC_GLOBE', 00H
$SG227180 DB	'TXT_KEY_MISC_YOU_CIRC_GLOBE', 00H
$SG227185 DB	'TXT_KEY_MISC_SOMEONE_CIRC_GLOBE', 00H
$SG227188 DB	'TXT_KEY_MISC_UNKNOWN_CIRC_GLOBE', 00H
$SG227194 DB	'CircumnavigatedGlobe', 00H
	ORG $+3
$SG227197 DB	'TXT_KEY_MISC_SOMEONE_CIRC_GLOBE', 00H
$SG227297 DB	'SPECIALUNIT_PEOPLE', 00H
	ORG $+1
$SG227301 DB	'TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER', 00H
$SG227304 DB	'TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON', 00H
	ORG $+2
$SG227375 DB	'TeamTechResearched', 00H
	ORG $+1
$SG227654 DB	'TXT_KEY_NTFN_PLAYER_ERA', 00H
$SG227666 DB	'TXT_KEY_UNMET_PLAYER', 00H
	ORG $+3
$SG227691 DB	'TXT_KEY_NTFN_MINOR_BONUSES_CHANGED', 00H
	ORG $+1
$SG227693 DB	'TXT_KEY_NTFN_MINOR_BONUSES_CHANGED_SM', 00H
	ORG $+2
$SG227775 DB	'TeamSetEra', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??_GCvTeamTechs@@QAEPAXI@Z			; CvTeamTechs::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??1CvTeamTechs@@QAE@XZ:PROC			; CvTeamTechs::~CvTeamTechs
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTeamTechs@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTeamTechs@@QAEPAXI@Z PROC				; CvTeamTechs::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTeamTechs@@QAE@XZ			; CvTeamTechs::~CvTeamTechs
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTeamTechs@@QAEPAXI@Z ENDP				; CvTeamTechs::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ	; CvTeam::GetTeamTechs
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ
_TEXT	SEGMENT
?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ PROC	; CvTeam::GetTeamTechs, COMDAT
; _this$ = ecx

; 2486 : 	return m_pTeamTechs;

	mov	eax, DWORD PTR [ecx+2980]

; 2487 : }

	ret	0
?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ENDP	; CvTeam::GetTeamTechs
_TEXT	ENDS
PUBLIC	?isBarbarian@CvTeam@@QBE_NXZ			; CvTeam::isBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?isBarbarian@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isBarbarian@CvTeam@@QBE_NXZ PROC			; CvTeam::isBarbarian, COMDAT
; _this$ = ecx

; 2525 : 	return (m_eID == BARBARIAN_TEAM);

	xor	eax, eax
	cmp	DWORD PTR [ecx+4], 63			; 0000003fH
	sete	al

; 2526 : }

	ret	0
?isBarbarian@CvTeam@@QBE_NXZ ENDP			; CvTeam::isBarbarian
_TEXT	ENDS
PUBLIC	?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ		; CvTeam::GetNumMinorCivsAttacked
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ PROC		; CvTeam::GetNumMinorCivsAttacked, COMDAT
; _this$ = ecx

; 2569 : 	return m_iNumMinorCivsAttacked;

	mov	eax, DWORD PTR [ecx+124]

; 2570 : }

	ret	0
?GetNumMinorCivsAttacked@CvTeam@@QBEHXZ ENDP		; CvTeam::GetNumMinorCivsAttacked
_TEXT	ENDS
PUBLIC	?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z	; CvTeam::SetNumMinorCivsAttacked
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z PROC		; CvTeam::SetNumMinorCivsAttacked, COMDAT
; _this$ = ecx

; 2576 : 	if(GetNumMinorCivsAttacked() != iValue)

	mov	eax, DWORD PTR _iValue$[esp-4]
	cmp	DWORD PTR [ecx+124], eax
	je	SHORT $LN1@SetNumMino

; 2577 : 	{
; 2578 : 		m_iNumMinorCivsAttacked = iValue;

	mov	DWORD PTR [ecx+124], eax
$LN1@SetNumMino:

; 2579 : 	}
; 2580 : }

	ret	4
?SetNumMinorCivsAttacked@CvTeam@@QAEXH@Z ENDP		; CvTeam::SetNumMinorCivsAttacked
_TEXT	ENDS
PUBLIC	?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z	; CvTeam::ChangeNumMinorCivsAttacked
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z PROC	; CvTeam::ChangeNumMinorCivsAttacked, COMDAT
; _this$ = ecx

; 2586 : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN6@ChangeNumM

; 2587 : 		SetNumMinorCivsAttacked(GetNumMinorCivsAttacked() + iChange);

	mov	eax, DWORD PTR [ecx+124]
	add	edx, eax
	cmp	eax, edx
	je	SHORT $LN6@ChangeNumM
	mov	DWORD PTR [ecx+124], edx
$LN6@ChangeNumM:

; 2588 : }

	ret	4
?ChangeNumMinorCivsAttacked@CvTeam@@QAEXH@Z ENDP	; CvTeam::ChangeNumMinorCivsAttacked
_TEXT	ENDS
PUBLIC	?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ	; CvTeam::IsBrokenMilitaryPromise
; Function compile flags: /Ogtpy
;	COMDAT ?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenMilitaryPromise, COMDAT
; _this$ = ecx

; 2616 : 	return m_bBrokenMilitaryPromise;

	mov	al, BYTE PTR [ecx+132]

; 2617 : }

	ret	0
?IsBrokenMilitaryPromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenMilitaryPromise
_TEXT	ENDS
PUBLIC	?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenMilitaryPromise
; Function compile flags: /Ogtpy
;	COMDAT ?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetBrokenMilitaryPromise, COMDAT
; _this$ = ecx

; 2622 : 	if(IsBrokenMilitaryPromise() != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [ecx+132], al
	je	SHORT $LN1@SetBrokenM

; 2623 : 		m_bBrokenMilitaryPromise = bValue;

	mov	BYTE PTR [ecx+132], al
$LN1@SetBrokenM:

; 2624 : }

	ret	4
?SetBrokenMilitaryPromise@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetBrokenMilitaryPromise
_TEXT	ENDS
PUBLIC	?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ	; CvTeam::IsBrokenExpansionPromise
; Function compile flags: /Ogtpy
;	COMDAT ?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenExpansionPromise, COMDAT
; _this$ = ecx

; 2629 : 	return m_bBrokenExpansionPromise;

	mov	al, BYTE PTR [ecx+133]

; 2630 : }

	ret	0
?IsBrokenExpansionPromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenExpansionPromise
_TEXT	ENDS
PUBLIC	?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenExpansionPromise
; Function compile flags: /Ogtpy
;	COMDAT ?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z PROC	; CvTeam::SetBrokenExpansionPromise, COMDAT
; _this$ = ecx

; 2635 : 	if(IsBrokenExpansionPromise() != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [ecx+133], al
	je	SHORT $LN1@SetBrokenE

; 2636 : 		m_bBrokenExpansionPromise = bValue;

	mov	BYTE PTR [ecx+133], al
$LN1@SetBrokenE:

; 2637 : }

	ret	4
?SetBrokenExpansionPromise@CvTeam@@QAEX_N@Z ENDP	; CvTeam::SetBrokenExpansionPromise
_TEXT	ENDS
PUBLIC	?IsBrokenBorderPromise@CvTeam@@QBE_NXZ		; CvTeam::IsBrokenBorderPromise
; Function compile flags: /Ogtpy
;	COMDAT ?IsBrokenBorderPromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsBrokenBorderPromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenBorderPromise, COMDAT
; _this$ = ecx

; 2642 : 	return m_bBrokenBorderPromise;

	mov	al, BYTE PTR [ecx+134]

; 2643 : }

	ret	0
?IsBrokenBorderPromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenBorderPromise
_TEXT	ENDS
PUBLIC	?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenBorderPromise
; Function compile flags: /Ogtpy
;	COMDAT ?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetBrokenBorderPromise, COMDAT
; _this$ = ecx

; 2648 : 	if(IsBrokenBorderPromise() != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [ecx+134], al
	je	SHORT $LN1@SetBrokenB

; 2649 : 		m_bBrokenBorderPromise = bValue;

	mov	BYTE PTR [ecx+134], al
$LN1@SetBrokenB:

; 2650 : }

	ret	4
?SetBrokenBorderPromise@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetBrokenBorderPromise
_TEXT	ENDS
PUBLIC	?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ	; CvTeam::IsBrokenCityStatePromise
; Function compile flags: /Ogtpy
;	COMDAT ?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ PROC		; CvTeam::IsBrokenCityStatePromise, COMDAT
; _this$ = ecx

; 2656 : 	return m_bBrokenCityStatePromise;

	mov	al, BYTE PTR [ecx+135]

; 2657 : }

	ret	0
?IsBrokenCityStatePromise@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsBrokenCityStatePromise
_TEXT	ENDS
PUBLIC	?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z	; CvTeam::SetBrokenCityStatePromise
; Function compile flags: /Ogtpy
;	COMDAT ?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z PROC	; CvTeam::SetBrokenCityStatePromise, COMDAT
; _this$ = ecx

; 2662 : 	if(IsBrokenCityStatePromise() != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [ecx+135], al
	je	SHORT $LN1@SetBrokenC

; 2663 : 		m_bBrokenCityStatePromise = bValue;

	mov	BYTE PTR [ecx+135], al
$LN1@SetBrokenC:

; 2664 : }

	ret	4
?SetBrokenCityStatePromise@CvTeam@@QAEX_N@Z ENDP	; CvTeam::SetBrokenCityStatePromise
_TEXT	ENDS
PUBLIC	?getNumMembers@CvTeam@@QBEHXZ			; CvTeam::getNumMembers
; Function compile flags: /Ogtpy
;	COMDAT ?getNumMembers@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getNumMembers@CvTeam@@QBEHXZ PROC			; CvTeam::getNumMembers, COMDAT
; _this$ = ecx

; 2825 : 	return m_iNumMembers;

	mov	eax, DWORD PTR [ecx+8]

; 2826 : }

	ret	0
?getNumMembers@CvTeam@@QBEHXZ ENDP			; CvTeam::getNumMembers
_TEXT	ENDS
PUBLIC	?changeNumMembers@CvTeam@@QAEXH@Z		; CvTeam::changeNumMembers
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumMembers@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumMembers@CvTeam@@QAEXH@Z PROC			; CvTeam::changeNumMembers, COMDAT
; _this$ = ecx

; 2832 : 	m_iNumMembers = (m_iNumMembers + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+8], eax

; 2833 : 	CvAssert(getNumMembers() >= 0);
; 2834 : }

	ret	4
?changeNumMembers@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeNumMembers
_TEXT	ENDS
PUBLIC	?getAliveCount@CvTeam@@QBEHXZ			; CvTeam::getAliveCount
; Function compile flags: /Ogtpy
;	COMDAT ?getAliveCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getAliveCount@CvTeam@@QBEHXZ PROC			; CvTeam::getAliveCount, COMDAT
; _this$ = ecx

; 2840 : 	return m_iAliveCount;

	mov	eax, DWORD PTR [ecx+12]

; 2841 : }

	ret	0
?getAliveCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getAliveCount
_TEXT	ENDS
PUBLIC	?changeAliveCount@CvTeam@@QAEXH@Z		; CvTeam::changeAliveCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeAliveCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeAliveCount@CvTeam@@QAEXH@Z PROC			; CvTeam::changeAliveCount, COMDAT
; _this$ = ecx

; 2846 : 	m_iAliveCount = (m_iAliveCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+12], eax

; 2847 : 	CvAssert(getAliveCount() >= 0);
; 2848 : }

	ret	4
?changeAliveCount@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeAliveCount
_TEXT	ENDS
PUBLIC	?getEverAliveCount@CvTeam@@QBEHXZ		; CvTeam::getEverAliveCount
; Function compile flags: /Ogtpy
;	COMDAT ?getEverAliveCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getEverAliveCount@CvTeam@@QBEHXZ PROC			; CvTeam::getEverAliveCount, COMDAT
; _this$ = ecx

; 2854 : 	return m_iEverAliveCount;

	mov	eax, DWORD PTR [ecx+16]

; 2855 : }

	ret	0
?getEverAliveCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getEverAliveCount
_TEXT	ENDS
PUBLIC	?isEverAlive@CvTeam@@QBEHXZ			; CvTeam::isEverAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isEverAlive@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?isEverAlive@CvTeam@@QBEHXZ PROC			; CvTeam::isEverAlive, COMDAT
; _this$ = ecx

; 2861 : 	return (getEverAliveCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+16], eax
	setg	al

; 2862 : }

	ret	0
?isEverAlive@CvTeam@@QBEHXZ ENDP			; CvTeam::isEverAlive
_TEXT	ENDS
PUBLIC	?changeEverAliveCount@CvTeam@@QAEXH@Z		; CvTeam::changeEverAliveCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeEverAliveCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeEverAliveCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeEverAliveCount, COMDAT
; _this$ = ecx

; 2868 : 	m_iEverAliveCount = (m_iEverAliveCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+16], eax

; 2869 : 	CvAssert(getEverAliveCount() >= 0);
; 2870 : }

	ret	4
?changeEverAliveCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeEverAliveCount
_TEXT	ENDS
PUBLIC	?getNumCities@CvTeam@@QBEHXZ			; CvTeam::getNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCities@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getNumCities@CvTeam@@QBEHXZ PROC			; CvTeam::getNumCities, COMDAT
; _this$ = ecx

; 2876 : 	return m_iNumCities;

	mov	eax, DWORD PTR [ecx+20]

; 2877 : }

	ret	0
?getNumCities@CvTeam@@QBEHXZ ENDP			; CvTeam::getNumCities
_TEXT	ENDS
PUBLIC	?changeNumCities@CvTeam@@QAEXH@Z		; CvTeam::changeNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumCities@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumCities@CvTeam@@QAEXH@Z PROC			; CvTeam::changeNumCities, COMDAT
; _this$ = ecx

; 2883 : 	m_iNumCities = (m_iNumCities + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+20], eax

; 2884 : 	CvAssert(getNumCities() >= 0);
; 2885 : }

	ret	4
?changeNumCities@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeNumCities
_TEXT	ENDS
PUBLIC	?getTotalPopulation@CvTeam@@QBEHXZ		; CvTeam::getTotalPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?getTotalPopulation@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getTotalPopulation@CvTeam@@QBEHXZ PROC			; CvTeam::getTotalPopulation, COMDAT
; _this$ = ecx

; 2891 : 	return (m_iTotalPopulation);

	mov	eax, DWORD PTR [ecx+24]

; 2892 : }

	ret	0
?getTotalPopulation@CvTeam@@QBEHXZ ENDP			; CvTeam::getTotalPopulation
_TEXT	ENDS
PUBLIC	?changeTotalPopulation@CvTeam@@QAEXH@Z		; CvTeam::changeTotalPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?changeTotalPopulation@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeTotalPopulation@CvTeam@@QAEXH@Z PROC		; CvTeam::changeTotalPopulation, COMDAT
; _this$ = ecx

; 2898 : 	m_iTotalPopulation = (m_iTotalPopulation + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+24], eax

; 2899 : 	CvAssert(getTotalPopulation() >= 0);
; 2900 : }

	ret	4
?changeTotalPopulation@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeTotalPopulation
_TEXT	ENDS
PUBLIC	?getTotalLand@CvTeam@@QBEHXZ			; CvTeam::getTotalLand
; Function compile flags: /Ogtpy
;	COMDAT ?getTotalLand@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getTotalLand@CvTeam@@QBEHXZ PROC			; CvTeam::getTotalLand, COMDAT
; _this$ = ecx

; 2906 : 	return (m_iTotalLand);

	mov	eax, DWORD PTR [ecx+28]

; 2907 : }

	ret	0
?getTotalLand@CvTeam@@QBEHXZ ENDP			; CvTeam::getTotalLand
_TEXT	ENDS
PUBLIC	?changeTotalLand@CvTeam@@QAEXH@Z		; CvTeam::changeTotalLand
; Function compile flags: /Ogtpy
;	COMDAT ?changeTotalLand@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeTotalLand@CvTeam@@QAEXH@Z PROC			; CvTeam::changeTotalLand, COMDAT
; _this$ = ecx

; 2913 : 	m_iTotalLand = (m_iTotalLand + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+28], eax

; 2914 : 	CvAssert(getTotalLand() >= 0);
; 2915 : }

	ret	4
?changeTotalLand@CvTeam@@QAEXH@Z ENDP			; CvTeam::changeTotalLand
_TEXT	ENDS
PUBLIC	?getNukeInterception@CvTeam@@QBEHXZ		; CvTeam::getNukeInterception
; Function compile flags: /Ogtpy
;	COMDAT ?getNukeInterception@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getNukeInterception@CvTeam@@QBEHXZ PROC		; CvTeam::getNukeInterception, COMDAT
; _this$ = ecx

; 2921 : 	return m_iNukeInterception;

	mov	eax, DWORD PTR [ecx+32]

; 2922 : }

	ret	0
?getNukeInterception@CvTeam@@QBEHXZ ENDP		; CvTeam::getNukeInterception
_TEXT	ENDS
PUBLIC	?changeNukeInterception@CvTeam@@QAEXH@Z		; CvTeam::changeNukeInterception
; Function compile flags: /Ogtpy
;	COMDAT ?changeNukeInterception@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNukeInterception@CvTeam@@QAEXH@Z PROC		; CvTeam::changeNukeInterception, COMDAT
; _this$ = ecx

; 2928 : 	m_iNukeInterception = (m_iNukeInterception + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+32], eax

; 2929 : 	CvAssert(getNukeInterception() >= 0);
; 2930 : }

	ret	4
?changeNukeInterception@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeNukeInterception
_TEXT	ENDS
PUBLIC	?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z ; CvTeam::getForceTeamVoteEligibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z
_TEXT	SEGMENT
_eVoteSource$ = 8					; size = 4
?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z PROC ; CvTeam::getForceTeamVoteEligibilityCount, COMDAT
; _this$ = ecx

; 2936 : 	return m_aiForceTeamVoteEligibilityCount[eVoteSource];

	mov	eax, DWORD PTR [ecx+2892]
	mov	ecx, DWORD PTR _eVoteSource$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2937 : }

	ret	4
?getForceTeamVoteEligibilityCount@CvTeam@@QBEHW4VoteSourceTypes@@@Z ENDP ; CvTeam::getForceTeamVoteEligibilityCount
_TEXT	ENDS
PUBLIC	?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z ; CvTeam::changeForceTeamVoteEligibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z
_TEXT	SEGMENT
_eVoteSource$ = 8					; size = 4
_iChange$ = 12						; size = 4
?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z PROC ; CvTeam::changeForceTeamVoteEligibilityCount, COMDAT
; _this$ = ecx

; 2950 : 	m_aiForceTeamVoteEligibilityCount[eVoteSource] += iChange;

	mov	eax, DWORD PTR [ecx+2892]
	mov	ecx, DWORD PTR _eVoteSource$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 2951 : 	CvAssert(getForceTeamVoteEligibilityCount(eVoteSource) >= 0);
; 2952 : }

	ret	8
?changeForceTeamVoteEligibilityCount@CvTeam@@QAEXW4VoteSourceTypes@@H@Z ENDP ; CvTeam::changeForceTeamVoteEligibilityCount
_TEXT	ENDS
PUBLIC	?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ	; CvTeam::getExtraWaterSeeFromCount
; Function compile flags: /Ogtpy
;	COMDAT ?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ PROC		; CvTeam::getExtraWaterSeeFromCount, COMDAT
; _this$ = ecx

; 2958 : 	return m_iExtraWaterSeeFromCount;

	mov	eax, DWORD PTR [ecx+36]

; 2959 : }

	ret	0
?getExtraWaterSeeFromCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getExtraWaterSeeFromCount
_TEXT	ENDS
PUBLIC	?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ		; CvTeam::isExtraWaterSeeFrom
; Function compile flags: /Ogtpy
;	COMDAT ?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ PROC		; CvTeam::isExtraWaterSeeFrom, COMDAT
; _this$ = ecx

; 2965 : 	return (getExtraWaterSeeFromCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+36], eax
	setg	al

; 2966 : }

	ret	0
?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ ENDP		; CvTeam::isExtraWaterSeeFrom
_TEXT	ENDS
PUBLIC	?getMapTradingCount@CvTeam@@QBEHXZ		; CvTeam::getMapTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?getMapTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getMapTradingCount@CvTeam@@QBEHXZ PROC			; CvTeam::getMapTradingCount, COMDAT
; _this$ = ecx

; 2987 : 	return m_iMapTradingCount;

	mov	eax, DWORD PTR [ecx+40]

; 2988 : }

	ret	0
?getMapTradingCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getMapTradingCount
_TEXT	ENDS
PUBLIC	?isMapTrading@CvTeam@@QBE_NXZ			; CvTeam::isMapTrading
; Function compile flags: /Ogtpy
;	COMDAT ?isMapTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isMapTrading@CvTeam@@QBE_NXZ PROC			; CvTeam::isMapTrading, COMDAT
; _this$ = ecx

; 2994 : 	return (getMapTradingCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+40], eax
	setg	al

; 2995 : }

	ret	0
?isMapTrading@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMapTrading
_TEXT	ENDS
PUBLIC	?changeMapTradingCount@CvTeam@@QAEXH@Z		; CvTeam::changeMapTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeMapTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeMapTradingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeMapTradingCount, COMDAT
; _this$ = ecx

; 3001 : 	m_iMapTradingCount = (m_iMapTradingCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+40], eax

; 3002 : 	CvAssert(getMapTradingCount() >= 0);
; 3003 : }

	ret	4
?changeMapTradingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeMapTradingCount
_TEXT	ENDS
PUBLIC	?getTechTradingCount@CvTeam@@QBEHXZ		; CvTeam::getTechTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?getTechTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getTechTradingCount@CvTeam@@QBEHXZ PROC		; CvTeam::getTechTradingCount, COMDAT
; _this$ = ecx

; 3009 : 	return m_iTechTradingCount;

	mov	eax, DWORD PTR [ecx+44]

; 3010 : }

	ret	0
?getTechTradingCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getTechTradingCount
_TEXT	ENDS
PUBLIC	?isTechTrading@CvTeam@@QBE_NXZ			; CvTeam::isTechTrading
; Function compile flags: /Ogtpy
;	COMDAT ?isTechTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isTechTrading@CvTeam@@QBE_NXZ PROC			; CvTeam::isTechTrading, COMDAT
; _this$ = ecx

; 3016 : 	return (getTechTradingCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+44], eax
	setg	al

; 3017 : }

	ret	0
?isTechTrading@CvTeam@@QBE_NXZ ENDP			; CvTeam::isTechTrading
_TEXT	ENDS
PUBLIC	?changeTechTradingCount@CvTeam@@QAEXH@Z		; CvTeam::changeTechTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeTechTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeTechTradingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeTechTradingCount, COMDAT
; _this$ = ecx

; 3023 : 	m_iTechTradingCount = (m_iTechTradingCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+44], eax

; 3024 : 	CvAssert(getTechTradingCount() >= 0);
; 3025 : }

	ret	4
?changeTechTradingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeTechTradingCount
_TEXT	ENDS
PUBLIC	?getGoldTradingCount@CvTeam@@QBEHXZ		; CvTeam::getGoldTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getGoldTradingCount@CvTeam@@QBEHXZ PROC		; CvTeam::getGoldTradingCount, COMDAT
; _this$ = ecx

; 3031 : 	return m_iGoldTradingCount;

	mov	eax, DWORD PTR [ecx+48]

; 3032 : }

	ret	0
?getGoldTradingCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getGoldTradingCount
_TEXT	ENDS
PUBLIC	?isGoldTrading@CvTeam@@QBE_NXZ			; CvTeam::isGoldTrading
; Function compile flags: /Ogtpy
;	COMDAT ?isGoldTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isGoldTrading@CvTeam@@QBE_NXZ PROC			; CvTeam::isGoldTrading, COMDAT
; _this$ = ecx

; 3038 : 	return (getGoldTradingCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+48], eax
	setg	al

; 3039 : }

	ret	0
?isGoldTrading@CvTeam@@QBE_NXZ ENDP			; CvTeam::isGoldTrading
_TEXT	ENDS
PUBLIC	?changeGoldTradingCount@CvTeam@@QAEXH@Z		; CvTeam::changeGoldTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeGoldTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeGoldTradingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeGoldTradingCount, COMDAT
; _this$ = ecx

; 3045 : 	m_iGoldTradingCount = (m_iGoldTradingCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+48], eax

; 3046 : 	CvAssert(getGoldTradingCount() >= 0);
; 3047 : }

	ret	4
?changeGoldTradingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeGoldTradingCount
_TEXT	ENDS
PUBLIC	?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getAllowEmbassyTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ PROC	; CvTeam::getAllowEmbassyTradingAllowedCount, COMDAT
; _this$ = ecx

; 3076 : 	return m_iAllowEmbassyTradingAllowedCount;

	mov	eax, DWORD PTR [ecx+52]

; 3077 : }

	ret	0
?getAllowEmbassyTradingAllowedCount@CvTeam@@QBEHXZ ENDP	; CvTeam::getAllowEmbassyTradingAllowedCount
_TEXT	ENDS
PUBLIC	?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::isAllowEmbassyTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::isAllowEmbassyTradingAllowed, COMDAT
; _this$ = ecx

; 3082 : 	return (getAllowEmbassyTradingAllowedCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+52], eax
	setg	al

; 3083 : }

	ret	0
?isAllowEmbassyTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::isAllowEmbassyTradingAllowed
_TEXT	ENDS
PUBLIC	?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeAllowEmbassyTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changeAllowEmbassyTradingAllowedCount, COMDAT
; _this$ = ecx

; 3088 : 	m_iAllowEmbassyTradingAllowedCount = (m_iAllowEmbassyTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+52], eax

; 3089 : 	CvAssert(getAllowEmbassyTradingAllowedCount() >= 0);
; 3090 : }

	ret	4
?changeAllowEmbassyTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changeAllowEmbassyTradingAllowedCount
_TEXT	ENDS
PUBLIC	?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getOpenBordersTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ PROC	; CvTeam::getOpenBordersTradingAllowedCount, COMDAT
; _this$ = ecx

; 3096 : 	return m_iOpenBordersTradingAllowedCount;

	mov	eax, DWORD PTR [ecx+56]

; 3097 : }

	ret	0
?getOpenBordersTradingAllowedCount@CvTeam@@QBEHXZ ENDP	; CvTeam::getOpenBordersTradingAllowedCount
_TEXT	ENDS
PUBLIC	?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::isOpenBordersTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::isOpenBordersTradingAllowed, COMDAT
; _this$ = ecx

; 3103 : 	return (getOpenBordersTradingAllowedCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+56], eax
	setg	al

; 3104 : }

	ret	0
?isOpenBordersTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::isOpenBordersTradingAllowed
_TEXT	ENDS
PUBLIC	?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeOpenBordersTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changeOpenBordersTradingAllowedCount, COMDAT
; _this$ = ecx

; 3115 : 	m_iOpenBordersTradingAllowedCount = (m_iOpenBordersTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+56], eax

; 3116 : 	CvAssert(getOpenBordersTradingAllowedCount() >= 0);
; 3117 : }

	ret	4
?changeOpenBordersTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changeOpenBordersTradingAllowedCount
_TEXT	ENDS
PUBLIC	?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::getDefensivePactTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ PROC ; CvTeam::getDefensivePactTradingAllowedCount, COMDAT
; _this$ = ecx

; 3123 : 	return m_iDefensivePactTradingAllowedCount;

	mov	eax, DWORD PTR [ecx+60]

; 3124 : }

	ret	0
?getDefensivePactTradingAllowedCount@CvTeam@@QBEHXZ ENDP ; CvTeam::getDefensivePactTradingAllowedCount
_TEXT	ENDS
PUBLIC	?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::isDefensivePactTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::isDefensivePactTradingAllowed, COMDAT
; _this$ = ecx

; 3130 : 	return (getDefensivePactTradingAllowedCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+60], eax
	setg	al

; 3131 : }

	ret	0
?isDefensivePactTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::isDefensivePactTradingAllowed
_TEXT	ENDS
PUBLIC	?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::changeDefensivePactTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changeDefensivePactTradingAllowedCount, COMDAT
; _this$ = ecx

; 3142 : 	m_iDefensivePactTradingAllowedCount = (m_iDefensivePactTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+60], eax

; 3143 : 	CvAssert(getDefensivePactTradingAllowedCount() >= 0);
; 3144 : }

	ret	4
?changeDefensivePactTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changeDefensivePactTradingAllowedCount
_TEXT	ENDS
PUBLIC	?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::GetResearchAgreementTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ PROC ; CvTeam::GetResearchAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3150 : 	return m_iResearchAgreementTradingAllowedCount;

	mov	eax, DWORD PTR [ecx+64]

; 3151 : }

	ret	0
?GetResearchAgreementTradingAllowedCount@CvTeam@@QBEHXZ ENDP ; CvTeam::GetResearchAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ; CvTeam::IsResearchAgreementTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::IsResearchAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 3157 : 	return (GetResearchAgreementTradingAllowedCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+64], eax
	setg	al

; 3158 : }

	ret	0
?IsResearchAgreementTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::IsResearchAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::ChangeResearchAgreementTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::ChangeResearchAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3169 : 	m_iResearchAgreementTradingAllowedCount = (m_iResearchAgreementTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+64], eax

; 3170 : 	CvAssert(GetResearchAgreementTradingAllowedCount() >= 0);
; 3171 : }

	ret	4
?ChangeResearchAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::ChangeResearchAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ ; CvTeam::GetTradeAgreementTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ PROC ; CvTeam::GetTradeAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3177 : 	return m_iTradeAgreementTradingAllowedCount;

	mov	eax, DWORD PTR [ecx+68]

; 3178 : }

	ret	0
?GetTradeAgreementTradingAllowedCount@CvTeam@@QBEHXZ ENDP ; CvTeam::GetTradeAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ	; CvTeam::IsTradeAgreementTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ PROC	; CvTeam::IsTradeAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 3184 : 	return (GetTradeAgreementTradingAllowedCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+68], eax
	setg	al

; 3185 : }

	ret	0
?IsTradeAgreementTradingAllowed@CvTeam@@QBE_NXZ ENDP	; CvTeam::IsTradeAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ; CvTeam::ChangeTradeAgreementTradingAllowedCount
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z PROC ; CvTeam::ChangeTradeAgreementTradingAllowedCount, COMDAT
; _this$ = ecx

; 3191 : 	m_iTradeAgreementTradingAllowedCount = (m_iTradeAgreementTradingAllowedCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+68], eax

; 3192 : 	CvAssert(GetTradeAgreementTradingAllowedCount() >= 0);
; 3193 : }

	ret	4
?ChangeTradeAgreementTradingAllowedCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::ChangeTradeAgreementTradingAllowedCount
_TEXT	ENDS
PUBLIC	?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ ; CvTeam::getPermanentAllianceTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ PROC	; CvTeam::getPermanentAllianceTradingCount, COMDAT
; _this$ = ecx

; 3199 : 	return m_iPermanentAllianceTradingCount;

	mov	eax, DWORD PTR [ecx+72]

; 3200 : }

	ret	0
?getPermanentAllianceTradingCount@CvTeam@@QBEHXZ ENDP	; CvTeam::getPermanentAllianceTradingCount
_TEXT	ENDS
PUBLIC	?isPermanentAllianceTrading@CvTeam@@QBE_NXZ	; CvTeam::isPermanentAllianceTrading
; Function compile flags: /Ogtpy
;	COMDAT ?isPermanentAllianceTrading@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isPermanentAllianceTrading@CvTeam@@QBE_NXZ PROC	; CvTeam::isPermanentAllianceTrading, COMDAT
; _this$ = ecx

; 3206 : 	return false;

	xor	al, al

; 3207 : }

	ret	0
?isPermanentAllianceTrading@CvTeam@@QBE_NXZ ENDP	; CvTeam::isPermanentAllianceTrading
_TEXT	ENDS
PUBLIC	?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z ; CvTeam::changePermanentAllianceTradingCount
; Function compile flags: /Ogtpy
;	COMDAT ?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z PROC ; CvTeam::changePermanentAllianceTradingCount, COMDAT
; _this$ = ecx

; 3213 : 	m_iPermanentAllianceTradingCount = (m_iPermanentAllianceTradingCount + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+72], eax

; 3214 : 	CvAssert(getPermanentAllianceTradingCount() >= 0);
; 3215 : }

	ret	4
?changePermanentAllianceTradingCount@CvTeam@@QAEXH@Z ENDP ; CvTeam::changePermanentAllianceTradingCount
_TEXT	ENDS
PUBLIC	?getBridgeBuildingCount@CvTeam@@QBEHXZ		; CvTeam::getBridgeBuildingCount
; Function compile flags: /Ogtpy
;	COMDAT ?getBridgeBuildingCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getBridgeBuildingCount@CvTeam@@QBEHXZ PROC		; CvTeam::getBridgeBuildingCount, COMDAT
; _this$ = ecx

; 3220 : 	return m_iBridgeBuildingCount;

	mov	eax, DWORD PTR [ecx+76]

; 3221 : }

	ret	0
?getBridgeBuildingCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getBridgeBuildingCount
_TEXT	ENDS
PUBLIC	?isBridgeBuilding@CvTeam@@QBE_NXZ		; CvTeam::isBridgeBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?isBridgeBuilding@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isBridgeBuilding@CvTeam@@QBE_NXZ PROC			; CvTeam::isBridgeBuilding, COMDAT
; _this$ = ecx

; 3227 : 	return (getBridgeBuildingCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+76], eax
	setg	al

; 3228 : }

	ret	0
?isBridgeBuilding@CvTeam@@QBE_NXZ ENDP			; CvTeam::isBridgeBuilding
_TEXT	ENDS
PUBLIC	?getWaterWorkCount@CvTeam@@QBEHXZ		; CvTeam::getWaterWorkCount
; Function compile flags: /Ogtpy
;	COMDAT ?getWaterWorkCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getWaterWorkCount@CvTeam@@QBEHXZ PROC			; CvTeam::getWaterWorkCount, COMDAT
; _this$ = ecx

; 3260 : 	return m_iWaterWorkCount;

	mov	eax, DWORD PTR [ecx+80]

; 3261 : }

	ret	0
?getWaterWorkCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getWaterWorkCount
_TEXT	ENDS
PUBLIC	?isWaterWork@CvTeam@@QBE_NXZ			; CvTeam::isWaterWork
; Function compile flags: /Ogtpy
;	COMDAT ?isWaterWork@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isWaterWork@CvTeam@@QBE_NXZ PROC			; CvTeam::isWaterWork, COMDAT
; _this$ = ecx

; 3267 : 	return (getWaterWorkCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], eax
	setg	al

; 3268 : }

	ret	0
?isWaterWork@CvTeam@@QBE_NXZ ENDP			; CvTeam::isWaterWork
_TEXT	ENDS
PUBLIC	?changeWaterWorkCount@CvTeam@@QAEXH@Z		; CvTeam::changeWaterWorkCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeWaterWorkCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeWaterWorkCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeWaterWorkCount, COMDAT
; _this$ = ecx

; 3274 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@changeWate

; 3275 : 	{
; 3276 : 		m_iWaterWorkCount = (m_iWaterWorkCount + iChange);

	add	DWORD PTR [ecx+80], eax
$LN1@changeWate:

; 3277 : 		CvAssert(getWaterWorkCount() >= 0);
; 3278 : 	}
; 3279 : }

	ret	4
?changeWaterWorkCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeWaterWorkCount
_TEXT	ENDS
PUBLIC	?getBorderObstacleCount@CvTeam@@QBEHXZ		; CvTeam::getBorderObstacleCount
; Function compile flags: /Ogtpy
;	COMDAT ?getBorderObstacleCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getBorderObstacleCount@CvTeam@@QBEHXZ PROC		; CvTeam::getBorderObstacleCount, COMDAT
; _this$ = ecx

; 3284 : 	return m_iBorderObstacleCount;

	mov	eax, DWORD PTR [ecx+88]

; 3285 : }

	ret	0
?getBorderObstacleCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getBorderObstacleCount
_TEXT	ENDS
PUBLIC	?isBorderObstacle@CvTeam@@QBE_NXZ		; CvTeam::isBorderObstacle
; Function compile flags: /Ogtpy
;	COMDAT ?isBorderObstacle@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isBorderObstacle@CvTeam@@QBE_NXZ PROC			; CvTeam::isBorderObstacle, COMDAT
; _this$ = ecx

; 3290 : 	return (getBorderObstacleCount() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+88], eax
	setg	al

; 3291 : }

	ret	0
?isBorderObstacle@CvTeam@@QBE_NXZ ENDP			; CvTeam::isBorderObstacle
_TEXT	ENDS
PUBLIC	?changeBorderObstacleCount@CvTeam@@QAEXH@Z	; CvTeam::changeBorderObstacleCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeBorderObstacleCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeBorderObstacleCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeBorderObstacleCount, COMDAT
; _this$ = ecx

; 3296 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@changeBord

; 3297 : 	{
; 3298 : 		m_iBorderObstacleCount = (m_iBorderObstacleCount + iChange);

	add	DWORD PTR [ecx+88], eax
$LN1@changeBord:

; 3299 : 		CvAssert(getBorderObstacleCount() >= 0);
; 3300 : 	}
; 3301 : }

	ret	4
?changeBorderObstacleCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeBorderObstacleCount
_TEXT	ENDS
PUBLIC	?isMapCentering@CvTeam@@QBE_NXZ			; CvTeam::isMapCentering
; Function compile flags: /Ogtpy
;	COMDAT ?isMapCentering@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isMapCentering@CvTeam@@QBE_NXZ PROC			; CvTeam::isMapCentering, COMDAT
; _this$ = ecx

; 3307 : 	return m_bMapCentering;

	mov	al, BYTE PTR [ecx+128]

; 3308 : }

	ret	0
?isMapCentering@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMapCentering
_TEXT	ENDS
PUBLIC	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ		; CvTeam::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ PROC		; CvTeam::GetID, COMDAT
; _this$ = ecx

; 3329 : 	return m_eID;

	mov	eax, DWORD PTR [ecx+4]

; 3330 : }

	ret	0
?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP		; CvTeam::GetID
_TEXT	ENDS
PUBLIC	?canEmbark@CvTeam@@QBE_NXZ			; CvTeam::canEmbark
; Function compile flags: /Ogtpy
;	COMDAT ?canEmbark@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?canEmbark@CvTeam@@QBE_NXZ PROC				; CvTeam::canEmbark, COMDAT
; _this$ = ecx

; 3391 : 	return m_iCanEmbarkCount > 0 ? true : false;

	cmp	DWORD PTR [ecx+104], 0
	setg	al

; 3392 : }

	ret	0
?canEmbark@CvTeam@@QBE_NXZ ENDP				; CvTeam::canEmbark
_TEXT	ENDS
PUBLIC	?getCanEmbarkCount@CvTeam@@QBEHXZ		; CvTeam::getCanEmbarkCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCanEmbarkCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getCanEmbarkCount@CvTeam@@QBEHXZ PROC			; CvTeam::getCanEmbarkCount, COMDAT
; _this$ = ecx

; 3397 : 	return m_iCanEmbarkCount;

	mov	eax, DWORD PTR [ecx+104]

; 3398 : }

	ret	0
?getCanEmbarkCount@CvTeam@@QBEHXZ ENDP			; CvTeam::getCanEmbarkCount
_TEXT	ENDS
PUBLIC	?canDefensiveEmbark@CvTeam@@QBE_NXZ		; CvTeam::canDefensiveEmbark
; Function compile flags: /Ogtpy
;	COMDAT ?canDefensiveEmbark@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?canDefensiveEmbark@CvTeam@@QBE_NXZ PROC		; CvTeam::canDefensiveEmbark, COMDAT
; _this$ = ecx

; 3451 : 	return m_iDefensiveEmbarkCount > 0 ? true : false;

	cmp	DWORD PTR [ecx+108], 0
	setg	al

; 3452 : }

	ret	0
?canDefensiveEmbark@CvTeam@@QBE_NXZ ENDP		; CvTeam::canDefensiveEmbark
_TEXT	ENDS
PUBLIC	?getDefensiveEmbarkCount@CvTeam@@QBEHXZ		; CvTeam::getDefensiveEmbarkCount
; Function compile flags: /Ogtpy
;	COMDAT ?getDefensiveEmbarkCount@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getDefensiveEmbarkCount@CvTeam@@QBEHXZ PROC		; CvTeam::getDefensiveEmbarkCount, COMDAT
; _this$ = ecx

; 3457 : 	return m_iDefensiveEmbarkCount;

	mov	eax, DWORD PTR [ecx+108]

; 3458 : }

	ret	0
?getDefensiveEmbarkCount@CvTeam@@QBEHXZ ENDP		; CvTeam::getDefensiveEmbarkCount
_TEXT	ENDS
PUBLIC	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ	; CvTeam::canEmbarkAllWaterPassage
; Function compile flags: /Ogtpy
;	COMDAT ?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ PROC		; CvTeam::canEmbarkAllWaterPassage, COMDAT
; _this$ = ecx

; 3535 : 	return m_iEmbarkedAllWaterPassageCount > 0 ? true : false;

	cmp	DWORD PTR [ecx+112], 0
	setg	al

; 3536 : }

	ret	0
?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ENDP		; CvTeam::canEmbarkAllWaterPassage
_TEXT	ENDS
PUBLIC	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ	; CvTeam::getEmbarkedAllWaterPassage
; Function compile flags: /Ogtpy
;	COMDAT ?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ PROC		; CvTeam::getEmbarkedAllWaterPassage, COMDAT
; _this$ = ecx

; 3541 : 	return m_iEmbarkedAllWaterPassageCount;

	mov	eax, DWORD PTR [ecx+112]

; 3542 : }

	ret	0
?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ ENDP		; CvTeam::getEmbarkedAllWaterPassage
_TEXT	ENDS
PUBLIC	?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z	; CvTeam::changeEmbarkedAllWaterPassage
; Function compile flags: /Ogtpy
;	COMDAT ?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z PROC	; CvTeam::changeEmbarkedAllWaterPassage, COMDAT
; _this$ = ecx

; 3547 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@changeEmba

; 3548 : 	{
; 3549 : 		m_iEmbarkedAllWaterPassageCount += iChange;

	add	DWORD PTR [ecx+112], eax
$LN1@changeEmba:

; 3550 : 	}
; 3551 : 	CvAssert(getEmbarkedAllWaterPassage() >= 0);
; 3552 : }

	ret	4
?changeEmbarkedAllWaterPassage@CvTeam@@QAEXH@Z ENDP	; CvTeam::changeEmbarkedAllWaterPassage
_TEXT	ENDS
PUBLIC	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ	; CvTeam::GetNumNaturalWondersDiscovered
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ PROC	; CvTeam::GetNumNaturalWondersDiscovered, COMDAT
; _this$ = ecx

; 3557 : 	return m_iNumNaturalWondersDiscovered;

	mov	eax, DWORD PTR [ecx+116]

; 3558 : }

	ret	0
?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ ENDP	; CvTeam::GetNumNaturalWondersDiscovered
_TEXT	ENDS
PUBLIC	?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z ; CvTeam::ChangeNumNaturalWondersDiscovered
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z PROC	; CvTeam::ChangeNumNaturalWondersDiscovered, COMDAT
; _this$ = ecx

; 3563 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeNumN

; 3564 : 	{
; 3565 : 		m_iNumNaturalWondersDiscovered += iChange;

	add	DWORD PTR [ecx+116], eax
$LN1@ChangeNumN:

; 3566 : 	}
; 3567 : 	CvAssert(GetNumNaturalWondersDiscovered() >= 0);
; 3568 : }

	ret	4
?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z ENDP	; CvTeam::ChangeNumNaturalWondersDiscovered
_TEXT	ENDS
PUBLIC	?getEmbarkedExtraMoves@CvTeam@@QBEHXZ		; CvTeam::getEmbarkedExtraMoves
; Function compile flags: /Ogtpy
;	COMDAT ?getEmbarkedExtraMoves@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getEmbarkedExtraMoves@CvTeam@@QBEHXZ PROC		; CvTeam::getEmbarkedExtraMoves, COMDAT
; _this$ = ecx

; 3574 : 	return m_iEmbarkedExtraMoves;

	mov	eax, DWORD PTR [ecx+96]

; 3575 : }

	ret	0
?getEmbarkedExtraMoves@CvTeam@@QBEHXZ ENDP		; CvTeam::getEmbarkedExtraMoves
_TEXT	ENDS
PUBLIC	?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z	; CvTeam::changeEmbarkedExtraMoves
; Function compile flags: /Ogtpy
;	COMDAT ?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z PROC		; CvTeam::changeEmbarkedExtraMoves, COMDAT
; _this$ = ecx

; 3580 : 	m_iEmbarkedExtraMoves = (m_iEmbarkedExtraMoves + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+96], eax

; 3581 : }

	ret	4
?changeEmbarkedExtraMoves@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeEmbarkedExtraMoves
_TEXT	ENDS
PUBLIC	?getEmbarkedExtraSight@CvTeam@@QBEHXZ		; CvTeam::getEmbarkedExtraSight
; Function compile flags: /Ogtpy
;	COMDAT ?getEmbarkedExtraSight@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getEmbarkedExtraSight@CvTeam@@QBEHXZ PROC		; CvTeam::getEmbarkedExtraSight, COMDAT
; _this$ = ecx

; 3587 : 	return m_iEmbarkedExtraSight;

	mov	eax, DWORD PTR [ecx+100]

; 3588 : }

	ret	0
?getEmbarkedExtraSight@CvTeam@@QBEHXZ ENDP		; CvTeam::getEmbarkedExtraSight
_TEXT	ENDS
PUBLIC	?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z	; CvTeam::changeEmbarkedExtraSight
; Function compile flags: /Ogtpy
;	COMDAT ?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z PROC		; CvTeam::changeEmbarkedExtraSight, COMDAT
; _this$ = ecx

; 3594 : 	m_iEmbarkedExtraSight = (m_iEmbarkedExtraSight + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+100], eax

; 3595 : }

	ret	4
?changeEmbarkedExtraSight@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeEmbarkedExtraSight
_TEXT	ENDS
PUBLIC	?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ		; CvTeam::IsHasBrokenPeaceTreaty
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ PROC		; CvTeam::IsHasBrokenPeaceTreaty, COMDAT
; _this$ = ecx

; 3962 : 	return m_bHasBrokenPeaceTreaty;

	mov	al, BYTE PTR [ecx+129]

; 3963 : }

	ret	0
?IsHasBrokenPeaceTreaty@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsHasBrokenPeaceTreaty
_TEXT	ENDS
PUBLIC	?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z	; CvTeam::SetHasBrokenPeaceTreaty
; Function compile flags: /Ogtpy
;	COMDAT ?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetHasBrokenPeaceTreaty, COMDAT
; _this$ = ecx

; 3968 : 	m_bHasBrokenPeaceTreaty = bValue;

	mov	al, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [ecx+129], al

; 3969 : }

	ret	4
?SetHasBrokenPeaceTreaty@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetHasBrokenPeaceTreaty
_TEXT	ENDS
PUBLIC	?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetLiberatedByTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ PROC	; CvTeam::GetLiberatedByTeam, COMDAT
; _this$ = ecx

; 3991 : 	return m_eLiberatedByTeam;

	mov	eax, DWORD PTR [ecx+140]

; 3992 : }

	ret	0
?GetLiberatedByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP	; CvTeam::GetLiberatedByTeam
_TEXT	ENDS
PUBLIC	?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::SetLiberatedByTeam
; Function compile flags: /Ogtpy
;	COMDAT ?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::SetLiberatedByTeam, COMDAT
; _this$ = ecx

; 3998 : 	if(GetLiberatedByTeam() != eIndex)

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	DWORD PTR [ecx+140], eax
	je	SHORT $LN1@SetLiberat

; 3999 : 	{
; 4000 : 		m_eLiberatedByTeam = eIndex;

	mov	DWORD PTR [ecx+140], eax
$LN1@SetLiberat:

; 4001 : 	}
; 4002 : }

	ret	4
?SetLiberatedByTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::SetLiberatedByTeam
_TEXT	ENDS
PUBLIC	?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetKilledByTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ PROC	; CvTeam::GetKilledByTeam, COMDAT
; _this$ = ecx

; 4008 : 	return m_eKilledByTeam;

	mov	eax, DWORD PTR [ecx+144]

; 4009 : }

	ret	0
?GetKilledByTeam@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP	; CvTeam::GetKilledByTeam
_TEXT	ENDS
PUBLIC	?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::SetKilledByTeam
; Function compile flags: /Ogtpy
;	COMDAT ?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::SetKilledByTeam, COMDAT
; _this$ = ecx

; 4015 : 	if(GetKilledByTeam() != eIndex)

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	DWORD PTR [ecx+144], eax
	je	SHORT $LN1@SetKilledB

; 4016 : 	{
; 4017 : 		m_eKilledByTeam = eIndex;

	mov	DWORD PTR [ecx+144], eax
$LN1@SetKilledB:

; 4018 : 	}
; 4019 : }

	ret	4
?SetKilledByTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::SetKilledByTeam
_TEXT	ENDS
PUBLIC	?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z	; CvTeam::getRouteChange
; Function compile flags: /Ogtpy
;	COMDAT ?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z PROC	; CvTeam::getRouteChange, COMDAT
; _this$ = ecx

; 4422 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4423 : 	CvAssertMsg(eIndex < GC.getNumRouteInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4424 : 	return m_paiRouteChange[eIndex];

	mov	eax, DWORD PTR [ecx+2908]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4425 : }

	ret	4
?getRouteChange@CvTeam@@QBEHW4RouteTypes@@@Z ENDP	; CvTeam::getRouteChange
_TEXT	ENDS
PUBLIC	?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z ; CvTeam::changeRouteChange
; Function compile flags: /Ogtpy
;	COMDAT ?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z PROC	; CvTeam::changeRouteChange, COMDAT
; _this$ = ecx

; 4430 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4431 : 	CvAssertMsg(eIndex < GC.getNumRouteInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4432 : 	m_paiRouteChange[eIndex] = (m_paiRouteChange[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+2908]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 4433 : }

	ret	8
?changeRouteChange@CvTeam@@QAEXW4RouteTypes@@H@Z ENDP	; CvTeam::changeRouteChange
_TEXT	ENDS
PUBLIC	?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z ; CvTeam::getBuildTimeChange
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z PROC	; CvTeam::getBuildTimeChange, COMDAT
; _this$ = ecx

; 4438 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4439 : 	CvAssertMsg(eIndex < GC.getNumBuildInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4440 : 	return m_paiBuildTimeChange[eIndex];

	mov	eax, DWORD PTR [ecx+2912]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4441 : }

	ret	4
?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z ENDP	; CvTeam::getBuildTimeChange
_TEXT	ENDS
PUBLIC	?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z ; CvTeam::changeBuildTimeChange
; Function compile flags: /Ogtpy
;	COMDAT ?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z PROC ; CvTeam::changeBuildTimeChange, COMDAT
; _this$ = ecx

; 4446 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4447 : 	CvAssertMsg(eIndex < GC.getNumBuildInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4448 : 	if (iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@changeBuil

; 4449 : 	{
; 4450 : 		m_paiBuildTimeChange[eIndex] = (m_paiBuildTimeChange[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+2912]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]
$LN1@changeBuil:

; 4451 : 	}
; 4452 : }

	ret	8
?changeBuildTimeChange@CvTeam@@QAEXW4BuildTypes@@H@Z ENDP ; CvTeam::changeBuildTimeChange
_TEXT	ENDS
PUBLIC	?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ ; CvTeam::GetBestPossibleRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ
_TEXT	SEGMENT
?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ PROC ; CvTeam::GetBestPossibleRoute, COMDAT
; _this$ = ecx

; 4458 : 	return (RouteTypes) m_iBestPossibleRoute;

	mov	eax, DWORD PTR [ecx+120]

; 4459 : }

	ret	0
?GetBestPossibleRoute@CvTeam@@QAE?AW4RouteTypes@@XZ ENDP ; CvTeam::GetBestPossibleRoute
_TEXT	ENDS
PUBLIC	?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z ; CvTeam::SetBestPossibleRoute
; Function compile flags: /Ogtpy
;	COMDAT ?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z
_TEXT	SEGMENT
_eRoute$ = 8						; size = 4
?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z PROC	; CvTeam::SetBestPossibleRoute, COMDAT
; _this$ = ecx

; 4465 : 	CvAssertMsg(eRoute >= NO_ROUTE, "eIndex is expected to be non-negative (invalid Index)");
; 4466 : 	CvAssertMsg(eRoute < GC.getNumRouteInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4467 : 
; 4468 : 	if(GetBestPossibleRoute() != eRoute)

	mov	eax, DWORD PTR _eRoute$[esp-4]
	cmp	DWORD PTR [ecx+120], eax
	je	SHORT $LN1@SetBestPos

; 4469 : 	{
; 4470 : 		m_iBestPossibleRoute = eRoute;

	mov	DWORD PTR [ecx+120], eax
$LN1@SetBestPos:

; 4471 : 	}
; 4472 : }

	ret	4
?SetBestPossibleRoute@CvTeam@@QAEXW4RouteTypes@@@Z ENDP	; CvTeam::SetBestPossibleRoute
_TEXT	ENDS
PUBLIC	?DoUpdateBestRoute@CvTeam@@QAEXXZ		; CvTeam::DoUpdateBestRoute
EXTRN	?GetResearchCost@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetResearchCost
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?getRoute@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getRoute
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?DoUpdateBestRoute@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_iBestRouteValue$ = -16					; size = 4
_iBuildLoop$226186 = -12				; size = 4
_eBestRoute$ = -8					; size = 4
_this$ = -4						; size = 4
?DoUpdateBestRoute@CvTeam@@QAEXXZ PROC			; CvTeam::DoUpdateBestRoute, COMDAT
; _this$ = ecx

; 4477 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 4478 : 	RouteTypes eBestRoute = NO_ROUTE;
; 4479 : 	int iBestRouteValue = 0;

	xor	edi, edi
	or	esi, -1

; 4480 : 
; 4481 : 	// Loop through all builds to see if it allows us to build a Route
; 4482 : #ifdef AUI_WARNING_FIXES
; 4483 : 	for (uint iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
; 4484 : #else
; 4485 : 	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+28], ebx
	mov	DWORD PTR _eBestRoute$[esp+28], esi
	mov	DWORD PTR _iBestRouteValue$[esp+28], edi
	mov	DWORD PTR _iBuildLoop$226186[esp+28], edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN24@DoUpdateBe
	push	ebp
$LL30@DoUpdateBe:

; 4486 : #endif
; 4487 : 	{
; 4488 : 		const BuildTypes eBuild = static_cast<BuildTypes>(iBuildLoop);
; 4489 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	esi, eax

; 4490 : 		if(pkBuildInfo)

	test	esi, esi
	je	SHORT $LN9@DoUpdateBe

; 4491 : 		{
; 4492 : 			const RouteTypes eRoute = (RouteTypes) pkBuildInfo->getRoute();

	mov	ecx, esi
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	ebp, eax

; 4493 : 			if(eRoute != NO_ROUTE)

	cmp	ebp, -1
	je	SHORT $LN9@DoUpdateBe

; 4494 : 			{
; 4495 : 				int iRouteValue = -1;
; 4496 : 
; 4497 : 				// If this route requires a tech, it's value is the cost of the tech
; 4498 : 				const TechTypes eTech = (TechTypes) pkBuildInfo->getTechPrereq();

	mov	ecx, esi
	or	edi, -1
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	mov	esi, eax

; 4499 : 				CvTechEntry* pkTechInfo = (eTech != NO_TECH)? GC.getTechInfo(eTech) : NULL;

	cmp	esi, edi
	je	SHORT $LN25@DoUpdateBe
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ebx, eax

; 4500 : 				if(pkTechInfo)

	test	ebx, ebx
	je	SHORT $LN25@DoUpdateBe

; 4501 : 				{
; 4502 : 					if(GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [eax+2980]
	push	esi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN26@DoUpdateBe

; 4503 : 					{
; 4504 : 						iRouteValue = pkTechInfo->GetResearchCost();

	mov	ecx, ebx
	call	?GetResearchCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetResearchCost
	mov	edi, eax

; 4505 : 					}
; 4506 : 				}
; 4507 : 				// Route requires no tech, so it's value is simply 1
; 4508 : 				else

	jmp	SHORT $LN26@DoUpdateBe
$LN25@DoUpdateBe:

; 4509 : 				{
; 4510 : 					iRouteValue = 1;

	mov	edi, 1
$LN26@DoUpdateBe:

; 4511 : 				}
; 4512 : 
; 4513 : 				// Most valuable route found so far? (note we use greater than OR equal to so that we'll pick up the LAST entry in Builds - this is most likely to be the most advanced if there are ties)
; 4514 : 				if(iRouteValue >= iBestRouteValue)

	cmp	edi, DWORD PTR _iBestRouteValue$[esp+32]
	jl	SHORT $LN9@DoUpdateBe

; 4515 : 				{
; 4516 : 					iBestRouteValue = iRouteValue;

	mov	DWORD PTR _iBestRouteValue$[esp+32], edi

; 4517 : 					eBestRoute = eRoute;

	mov	DWORD PTR _eBestRoute$[esp+32], ebp
$LN9@DoUpdateBe:
	mov	edi, DWORD PTR _iBuildLoop$226186[esp+32]
	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBuildLoop$226186[esp+32], edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	$LL30@DoUpdateBe

; 4518 : 				}
; 4519 : 			}
; 4520 : 		}
; 4521 : 	}
; 4522 : 
; 4523 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 4524 : 	CvRouteInfo* pRouteInfo = NULL;
; 4525 : 	if (eBestRoute > NO_ROUTE)
; 4526 : #else
; 4527 : 	if(iBestRouteValue > -1)

	cmp	DWORD PTR _iBestRouteValue$[esp+32], -1
	pop	ebp
	jle	SHORT $LN17@DoUpdateBe
	mov	esi, DWORD PTR _eBestRoute$[esp+28]
	mov	ebx, DWORD PTR _this$[esp+28]
$LN24@DoUpdateBe:

; 4528 : #endif
; 4529 : 	{
; 4530 : 		SetBestPossibleRoute(eBestRoute);

	cmp	DWORD PTR [ebx+120], esi
	je	SHORT $LN17@DoUpdateBe
	mov	DWORD PTR [ebx+120], esi
$LN17@DoUpdateBe:
	pop	edi
	pop	esi
	pop	ebx

; 4531 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 4532 : 		pRouteInfo = GC.getRouteInfo(eBestRoute);
; 4533 : #endif
; 4534 : 	}
; 4535 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 4536 : 	if (pRouteInfo)
; 4537 : 	{
; 4538 : 		m_iBestRouteNormalCostMultiplier = GC.getMOVE_DENOMINATOR() / (pRouteInfo->getMovementCost() + getRouteChange(eBestRoute));
; 4539 : 		m_iBestRouteFlatCostMultiplier = GC.getMOVE_DENOMINATOR() / pRouteInfo->getFlatMovementCost();
; 4540 : 		// Extra pRouteInfo->getFlatMovementCost() - 1 is to make sure value is always rounded up
; 4541 : 		m_iUseFlatCostIfBelowThis = (pRouteInfo->getMovementCost() + getRouteChange(eBestRoute) + pRouteInfo->getFlatMovementCost() - 1) / pRouteInfo->getFlatMovementCost();
; 4542 : 	}
; 4543 : 	else
; 4544 : 	{
; 4545 : 		m_iBestRouteFlatCostMultiplier = 0;
; 4546 : 		m_iBestRouteNormalCostMultiplier = 1;
; 4547 : 		m_iUseFlatCostIfBelowThis = -1;
; 4548 : 	}
; 4549 : #endif
; 4550 : }

	add	esp, 16					; 00000010H
	ret	0
?DoUpdateBestRoute@CvTeam@@QAEXXZ ENDP			; CvTeam::DoUpdateBestRoute
_TEXT	ENDS
PUBLIC	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z	; CvTeam::getProjectCount
; Function compile flags: /Ogtpy
;	COMDAT ?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z PROC	; CvTeam::getProjectCount, COMDAT
; _this$ = ecx

; 4574 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4575 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4576 : 	return m_paiProjectCount[eIndex];

	mov	eax, DWORD PTR [ecx+2916]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4577 : }

	ret	4
?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ENDP	; CvTeam::getProjectCount
_TEXT	ENDS
PUBLIC	?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectDefaultArtType
; Function compile flags: /Ogtpy
;	COMDAT ?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z PROC ; CvTeam::getProjectDefaultArtType, COMDAT
; _this$ = ecx

; 4582 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4583 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4584 : 	return m_paiProjectDefaultArtTypes[eIndex];

	mov	eax, DWORD PTR [ecx+2920]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4585 : }

	ret	4
?getProjectDefaultArtType@CvTeam@@QBEHW4ProjectTypes@@@Z ENDP ; CvTeam::getProjectDefaultArtType
_TEXT	ENDS
PUBLIC	?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::setProjectDefaultArtType
; Function compile flags: /Ogtpy
;	COMDAT ?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_value$ = 12						; size = 4
?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z PROC ; CvTeam::setProjectDefaultArtType, COMDAT
; _this$ = ecx

; 4590 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4591 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4592 : 	m_paiProjectDefaultArtTypes[eIndex] = value;

	mov	eax, DWORD PTR [ecx+2920]
	mov	ecx, DWORD PTR _value$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 4593 : }

	ret	8
?setProjectDefaultArtType@CvTeam@@QAEXW4ProjectTypes@@H@Z ENDP ; CvTeam::setProjectDefaultArtType
_TEXT	ENDS
PUBLIC	?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z ; CvTeam::isProjectMaxedOut
EXTRN	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetMaxTeamInstances
EXTRN	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z:PROC ; CvGlobals::getProjectInfo
EXTRN	?isTeamProject@@YA_NW4ProjectTypes@@@Z:PROC	; isTeamProject
; Function compile flags: /Ogtpy
;	COMDAT ?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iExtra$ = 12						; size = 4
?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z PROC ; CvTeam::isProjectMaxedOut, COMDAT
; _this$ = ecx

; 4617 : {

	push	esi

; 4618 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4619 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4620 : 
; 4621 : 	if(!isTeamProject(eIndex))

	mov	esi, DWORD PTR _eIndex$[esp]
	push	edi
	push	esi
	mov	edi, ecx
	call	?isTeamProject@@YA_NW4ProjectTypes@@@Z	; isTeamProject
	add	esp, 4
	test	al, al
	jne	SHORT $LN1@isProjectM
	pop	edi
	pop	esi

; 4629 : }

	ret	8
$LN1@isProjectM:

; 4622 : 	{
; 4623 : 		return false;
; 4624 : 	}
; 4625 : 
; 4626 : 	CvAssertMsg(getProjectCount(eIndex) <= GC.getProjectInfo(eIndex)->GetMaxTeamInstances(), "Current Project count is expected to not exceed the maximum number of instances for this project");
; 4627 : 
; 4628 : 	return ((getProjectCount(eIndex) + iExtra) >= GC.getProjectInfo(eIndex)->GetMaxTeamInstances());

	mov	eax, DWORD PTR [edi+2916]
	mov	edi, DWORD PTR [eax+esi*4]
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxTeamInstances
	mov	ecx, DWORD PTR _iExtra$[esp+4]
	add	edi, ecx
	xor	edx, edx
	cmp	edi, eax
	setge	dl
	pop	edi
	mov	al, dl
	pop	esi

; 4629 : }

	ret	8
?isProjectMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@H@Z ENDP ; CvTeam::isProjectMaxedOut
_TEXT	ENDS
PUBLIC	?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectMaking
; Function compile flags: /Ogtpy
;	COMDAT ?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z PROC	; CvTeam::getProjectMaking, COMDAT
; _this$ = ecx

; 4853 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4854 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4855 : 	return m_paiProjectMaking[eIndex];

	mov	eax, DWORD PTR [ecx+2924]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4856 : }

	ret	4
?getProjectMaking@CvTeam@@QBEHW4ProjectTypes@@@Z ENDP	; CvTeam::getProjectMaking
_TEXT	ENDS
PUBLIC	?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectMaking
; Function compile flags: /Ogtpy
;	COMDAT ?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z PROC ; CvTeam::changeProjectMaking, COMDAT
; _this$ = ecx

; 4862 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4863 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4864 : 	m_paiProjectMaking[eIndex] = (m_paiProjectMaking[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+2924]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 4865 : 	CvAssert(getProjectMaking(eIndex) >= 0);
; 4866 : }

	ret	8
?changeProjectMaking@CvTeam@@QAEXW4ProjectTypes@@H@Z ENDP ; CvTeam::changeProjectMaking
_TEXT	ENDS
PUBLIC	?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassCount
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z PROC ; CvTeam::getUnitClassCount, COMDAT
; _this$ = ecx

; 4872 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4873 : 	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4874 : 	return m_paiUnitClassCount[eIndex];

	mov	eax, DWORD PTR [ecx+2928]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4875 : }

	ret	4
?getUnitClassCount@CvTeam@@QBEHW4UnitClassTypes@@@Z ENDP ; CvTeam::getUnitClassCount
_TEXT	ENDS
PUBLIC	?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z ; CvTeam::isUnitClassMaxedOut
EXTRN	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxTeamInstances
EXTRN	?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z:PROC	; isTeamUnitClass
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iExtra$ = 12						; size = 4
?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z PROC ; CvTeam::isUnitClassMaxedOut, COMDAT
; _this$ = ecx

; 4880 : {

	push	ebx
	push	esi
	push	edi

; 4881 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4882 : 	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4883 : 
; 4884 : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eIndex);

	mov	edi, DWORD PTR _eIndex$[esp+8]
	mov	ebx, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	esi, eax

; 4885 : 	if(pkUnitClassInfo == NULL)

	test	esi, esi
	jne	SHORT $LN2@isUnitClas
$LN7@isUnitClas:
	pop	edi
	pop	esi

; 4886 : 	{
; 4887 : 		return false;

	xor	al, al
	pop	ebx

; 4898 : }

	ret	8
$LN2@isUnitClas:

; 4888 : 	}
; 4889 : 
; 4890 : 	if(!isTeamUnitClass(eIndex))

	push	edi
	call	?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z ; isTeamUnitClass
	add	esp, 4
	test	al, al

; 4891 : 	{
; 4892 : 		return false;

	je	SHORT $LN7@isUnitClas

; 4893 : 	}
; 4894 : 
; 4895 : 	CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxTeamInstances(), "The current unit class count is expected not to exceed the maximum number of instances allowed for this team");
; 4896 : 
; 4897 : 	return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxTeamInstances());

	mov	eax, DWORD PTR [ebx+2928]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	ecx, esi
	call	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxTeamInstances
	mov	ecx, DWORD PTR _iExtra$[esp+8]
	add	edi, ecx
	xor	edx, edx
	cmp	edi, eax
	pop	edi
	setge	dl
	pop	esi
	mov	al, dl
	pop	ebx

; 4898 : }

	ret	8
?isUnitClassMaxedOut@CvTeam@@QBE_NW4UnitClassTypes@@H@Z ENDP ; CvTeam::isUnitClassMaxedOut
_TEXT	ENDS
PUBLIC	?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z ; CvTeam::changeUnitClassCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z PROC ; CvTeam::changeUnitClassCount, COMDAT
; _this$ = ecx

; 4904 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4905 : 	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4906 : 	m_paiUnitClassCount[eIndex] = (m_paiUnitClassCount[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+2928]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 4907 : 	CvAssert(getUnitClassCount(eIndex) >= 0);
; 4908 : }

	ret	8
?changeUnitClassCount@CvTeam@@QAEXW4UnitClassTypes@@H@Z ENDP ; CvTeam::changeUnitClassCount
_TEXT	ENDS
PUBLIC	?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassCount
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z PROC ; CvTeam::getBuildingClassCount, COMDAT
; _this$ = ecx

; 4914 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4915 : 	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4916 : 	return m_paiBuildingClassCount[eIndex];

	mov	eax, DWORD PTR [ecx+2932]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4917 : }

	ret	4
?getBuildingClassCount@CvTeam@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvTeam::getBuildingClassCount
_TEXT	ENDS
PUBLIC	?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z ; CvTeam::isBuildingClassMaxedOut
EXTRN	?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ:PROC ; CvBuildingClassInfo::getMaxTeamInstances
EXTRN	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isTeamWonderClass
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iExtra$ = 12						; size = 4
?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z PROC ; CvTeam::isBuildingClassMaxedOut, COMDAT
; _this$ = ecx

; 4922 : {

	push	ebx

; 4923 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4924 : 	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4925 : 
; 4926 : 	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);

	mov	ebx, DWORD PTR _eIndex$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	esi, eax

; 4927 : 	if(pkBuildingClassInfo == NULL)

	test	esi, esi
	jne	SHORT $LN2@isBuilding
$LN7@isBuilding:
	pop	edi
	pop	esi

; 4928 : 	{
; 4929 : 		CvAssertMsg(false, "Could not find BuildingClassInfo for BuildingClassType.");
; 4930 : 		return false;

	xor	al, al
	pop	ebx

; 4941 : }

	ret	8
$LN2@isBuilding:

; 4931 : 	}
; 4932 : 
; 4933 : 	if(!isTeamWonderClass(*pkBuildingClassInfo))

	push	esi
	call	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isTeamWonderClass
	add	esp, 4
	test	al, al

; 4934 : 	{
; 4935 : 		return false;

	je	SHORT $LN7@isBuilding

; 4936 : 	}
; 4937 : 
; 4938 : 	CvAssertMsg(getBuildingClassCount(eIndex) <= pkBuildingClassInfo->getMaxTeamInstances(), "The current building class count is expected not to exceed the maximum number of instances allowed for this team");
; 4939 : 
; 4940 : 	return ((getBuildingClassCount(eIndex) + iExtra) >= pkBuildingClassInfo->getMaxTeamInstances());

	mov	eax, DWORD PTR [edi+2932]
	mov	edi, DWORD PTR [eax+ebx*4]
	mov	ecx, esi
	call	?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getMaxTeamInstances
	mov	ecx, DWORD PTR _iExtra$[esp+8]
	add	edi, ecx
	xor	edx, edx
	cmp	edi, eax
	pop	edi
	setge	dl
	pop	esi
	mov	al, dl
	pop	ebx

; 4941 : }

	ret	8
?isBuildingClassMaxedOut@CvTeam@@QBE_NW4BuildingClassTypes@@H@Z ENDP ; CvTeam::isBuildingClassMaxedOut
_TEXT	ENDS
PUBLIC	?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z ; CvTeam::changeBuildingClassCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z PROC ; CvTeam::changeBuildingClassCount, COMDAT
; _this$ = ecx

; 4947 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4948 : 	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4949 : 	m_paiBuildingClassCount[eIndex] = (m_paiBuildingClassCount[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+2932]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 4950 : 	CvAssert(getBuildingClassCount(eIndex) >= 0);
; 4951 : }

	ret	8
?changeBuildingClassCount@CvTeam@@QAEXW4BuildingClassTypes@@H@Z ENDP ; CvTeam::changeBuildingClassCount
_TEXT	ENDS
PUBLIC	?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z ; CvTeam::getObsoleteBuildingCount
; Function compile flags: /Ogtpy
;	COMDAT ?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z PROC ; CvTeam::getObsoleteBuildingCount, COMDAT
; _this$ = ecx

; 4957 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4958 : 	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4959 : 	return m_paiObsoleteBuildingCount[eIndex];

	mov	eax, DWORD PTR [ecx+2936]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4960 : }

	ret	4
?getObsoleteBuildingCount@CvTeam@@QBEHW4BuildingTypes@@@Z ENDP ; CvTeam::getObsoleteBuildingCount
_TEXT	ENDS
PUBLIC	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z PROC ; CvTeam::isObsoleteBuilding, COMDAT
; _this$ = ecx

; 4966 : 	return (getObsoleteBuildingCount(eIndex) > 0);

	mov	eax, DWORD PTR [ecx+2936]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+edx*4], ecx
	setg	cl
	mov	al, cl

; 4967 : }

	ret	4
?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ENDP ; CvTeam::isObsoleteBuilding
_TEXT	ENDS
PUBLIC	?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z ; CvTeam::getTerrainTradeCount
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z PROC ; CvTeam::getTerrainTradeCount, COMDAT
; _this$ = ecx

; 5065 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5066 : 	CvAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5067 : 	return m_paiTerrainTradeCount[eIndex];

	mov	eax, DWORD PTR [ecx+2940]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5068 : }

	ret	4
?getTerrainTradeCount@CvTeam@@QBEHW4TerrainTypes@@@Z ENDP ; CvTeam::getTerrainTradeCount
_TEXT	ENDS
PUBLIC	?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z	; CvTeam::isTerrainTrade
; Function compile flags: /Ogtpy
;	COMDAT ?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z PROC	; CvTeam::isTerrainTrade, COMDAT
; _this$ = ecx

; 5074 : 	return (getTerrainTradeCount(eIndex) > 0);

	mov	eax, DWORD PTR [ecx+2940]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+edx*4], ecx
	setg	cl
	mov	al, cl

; 5075 : }

	ret	4
?isTerrainTrade@CvTeam@@QBE_NW4TerrainTypes@@@Z ENDP	; CvTeam::isTerrainTrade
_TEXT	ENDS
PUBLIC	?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z ; CvTeam::changeTerrainTradeCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z PROC ; CvTeam::changeTerrainTradeCount, COMDAT
; _this$ = ecx

; 5081 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5082 : 	CvAssertMsg(eIndex < GC.getNumTerrainInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5083 : 
; 5084 : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@changeTerr

; 5085 : 	{
; 5086 : 		m_paiTerrainTradeCount[eIndex] = (m_paiTerrainTradeCount[eIndex] + iChange);

	mov	eax, DWORD PTR [ecx+2940]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]
$LN1@changeTerr:

; 5087 : 		CvAssert(getTerrainTradeCount(eIndex) >= 0);
; 5088 : 	}
; 5089 : }

	ret	8
?changeTerrainTradeCount@CvTeam@@QAEXW4TerrainTypes@@H@Z ENDP ; CvTeam::changeTerrainTradeCount
_TEXT	ENDS
PUBLIC	?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ		; CvTeam::IsHomeOfUnitedNations
; Function compile flags: /Ogtpy
;	COMDAT ?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ PROC		; CvTeam::IsHomeOfUnitedNations, COMDAT
; _this$ = ecx

; 5095 : 	return m_bHomeOfUnitedNations;

	mov	al, BYTE PTR [ecx+130]

; 5096 : }

	ret	0
?IsHomeOfUnitedNations@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsHomeOfUnitedNations
_TEXT	ENDS
PUBLIC	?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z	; CvTeam::SetHomeOfUnitedNations
; Function compile flags: /Ogtpy
;	COMDAT ?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z PROC		; CvTeam::SetHomeOfUnitedNations, COMDAT
; _this$ = ecx

; 5102 : 	if(bValue != IsHomeOfUnitedNations())

	mov	al, BYTE PTR _bValue$[esp-4]
	cmp	al, BYTE PTR [ecx+130]
	je	SHORT $LN1@SetHomeOfU

; 5103 : 	{
; 5104 : 		m_bHomeOfUnitedNations = bValue;

	mov	BYTE PTR [ecx+130], al
$LN1@SetHomeOfU:

; 5105 : 	}
; 5106 : }

	ret	4
?SetHomeOfUnitedNations@CvTeam@@QAEX_N@Z ENDP		; CvTeam::SetHomeOfUnitedNations
_TEXT	ENDS
PUBLIC	?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z ; CvTeam::getVictoryCountdown
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z PROC ; CvTeam::getVictoryCountdown, COMDAT
; _this$ = ecx

; 5111 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5112 : 	CvAssertMsg(eIndex < GC.getNumVictoryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5113 : 	return m_aiVictoryCountdown[eIndex];

	mov	eax, DWORD PTR [ecx+2944]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5114 : }

	ret	4
?getVictoryCountdown@CvTeam@@QBEHW4VictoryTypes@@@Z ENDP ; CvTeam::getVictoryCountdown
_TEXT	ENDS
PUBLIC	?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ; CvTeam::setVictoryCountdown
; Function compile flags: /Ogtpy
;	COMDAT ?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iTurnsLeft$ = 12					; size = 4
?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z PROC ; CvTeam::setVictoryCountdown, COMDAT
; _this$ = ecx

; 5119 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5120 : 	CvAssertMsg(eIndex < GC.getNumVictoryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5121 : 	m_aiVictoryCountdown[eIndex] = iTurnsLeft;

	mov	eax, DWORD PTR [ecx+2944]
	mov	ecx, DWORD PTR _iTurnsLeft$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 5122 : }

	ret	8
?setVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ENDP ; CvTeam::setVictoryCountdown
_TEXT	ENDS
PUBLIC	?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ; CvTeam::changeVictoryCountdown
; Function compile flags: /Ogtpy
;	COMDAT ?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z PROC ; CvTeam::changeVictoryCountdown, COMDAT
; _this$ = ecx

; 5128 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5129 : 	CvAssertMsg(eIndex < GC.getNumVictoryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5130 : 
; 5131 : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@changeVict

; 5132 : 	{
; 5133 : 		m_aiVictoryCountdown[eIndex] += iChange;

	mov	eax, DWORD PTR [ecx+2944]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]
$LN1@changeVict:

; 5134 : 		CvAssert(m_aiVictoryCountdown[eIndex] >= 0);
; 5135 : 	}
; 5136 : }

	ret	8
?changeVictoryCountdown@CvTeam@@QAEXW4VictoryTypes@@H@Z ENDP ; CvTeam::changeVictoryCountdown
_TEXT	ENDS
PUBLIC	?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z	; CvTeam::setCanLaunch
; Function compile flags: /Ogtpy
;	COMDAT ?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z
_TEXT	SEGMENT
_eVictory$ = 8						; size = 4
_bCan$ = 12						; size = 1
?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z PROC	; CvTeam::setCanLaunch, COMDAT
; _this$ = ecx

; 5169 : 	m_abCanLaunch[eVictory] = bCan;

	mov	eax, DWORD PTR [ecx+2896]
	mov	cl, BYTE PTR _bCan$[esp-4]
	mov	edx, DWORD PTR _eVictory$[esp-4]
	mov	BYTE PTR [edx+eax], cl

; 5170 : }

	ret	8
?setCanLaunch@CvTeam@@QAEXW4VictoryTypes@@_N@Z ENDP	; CvTeam::setCanLaunch
_TEXT	ENDS
PUBLIC	?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z	; CvTeam::canLaunch
; Function compile flags: /Ogtpy
;	COMDAT ?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z
_TEXT	SEGMENT
_eVictory$ = 8						; size = 4
?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z PROC		; CvTeam::canLaunch, COMDAT
; _this$ = ecx

; 5175 : 	return m_abCanLaunch[eVictory];

	mov	eax, DWORD PTR [ecx+2896]
	mov	ecx, DWORD PTR _eVictory$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 5176 : }

	ret	4
?canLaunch@CvTeam@@QBE_NW4VictoryTypes@@@Z ENDP		; CvTeam::canLaunch
_TEXT	ENDS
PUBLIC	?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z ; CvTeam::isVictoryAchieved
; Function compile flags: /Ogtpy
;	COMDAT ?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z
_TEXT	SEGMENT
_eVictory$ = 8						; size = 4
?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z PROC	; CvTeam::isVictoryAchieved, COMDAT
; _this$ = ecx

; 5232 : 	return m_abVictoryAchieved[eVictory];

	mov	eax, DWORD PTR [ecx+2900]
	mov	ecx, DWORD PTR _eVictory$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 5233 : }

	ret	4
?isVictoryAchieved@CvTeam@@QBE_NW4VictoryTypes@@@Z ENDP	; CvTeam::isVictoryAchieved
_TEXT	ENDS
PUBLIC	?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z ; CvTeam::setVictoryAchieved
; Function compile flags: /Ogtpy
;	COMDAT ?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z
_TEXT	SEGMENT
_eVictory$ = 8						; size = 4
_bValue$ = 12						; size = 1
?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z PROC ; CvTeam::setVictoryAchieved, COMDAT
; _this$ = ecx

; 5238 : 	if(m_abVictoryAchieved[eVictory] != bValue)

	mov	eax, DWORD PTR [ecx+2900]
	mov	ecx, DWORD PTR _eVictory$[esp-4]
	add	eax, ecx
	mov	cl, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [eax], cl
	je	SHORT $LN1@setVictory

; 5239 : 	{
; 5240 : 		m_abVictoryAchieved[eVictory] = bValue;

	mov	BYTE PTR [eax], cl
$LN1@setVictory:

; 5241 : 	}
; 5242 : }

	ret	8
?setVictoryAchieved@CvTeam@@QAEXW4VictoryTypes@@_N@Z ENDP ; CvTeam::setVictoryAchieved
_TEXT	ENDS
PUBLIC	?getVictoryPoints@CvTeam@@QBEHXZ		; CvTeam::getVictoryPoints
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryPoints@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getVictoryPoints@CvTeam@@QBEHXZ PROC			; CvTeam::getVictoryPoints, COMDAT
; _this$ = ecx

; 5247 : 	return m_iVictoryPoints;

	mov	eax, DWORD PTR [ecx+92]

; 5248 : }

	ret	0
?getVictoryPoints@CvTeam@@QBEHXZ ENDP			; CvTeam::getVictoryPoints
_TEXT	ENDS
PUBLIC	?changeVictoryPoints@CvTeam@@QAEXH@Z		; CvTeam::changeVictoryPoints
; Function compile flags: /Ogtpy
;	COMDAT ?changeVictoryPoints@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeVictoryPoints@CvTeam@@QAEXH@Z PROC		; CvTeam::changeVictoryPoints, COMDAT
; _this$ = ecx

; 5273 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@changeVict@2

; 5274 : 	{
; 5275 : 		m_iVictoryPoints += iChange;

	add	DWORD PTR [ecx+92], eax
$LN1@changeVict@2:

; 5276 : 	}
; 5277 : 
; 5278 : 	// Right now there's no reason VPs should ever be negative
; 5279 : 	CvAssert(m_iVictoryPoints >= 0);
; 5280 : }

	ret	4
?changeVictoryPoints@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeVictoryPoints
_TEXT	ENDS
PUBLIC	?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z ; CvTeam::IsSmallAwardAchieved
; Function compile flags: /Ogtpy
;	COMDAT ?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z
_TEXT	SEGMENT
_eAward$ = 8						; size = 4
?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z PROC ; CvTeam::IsSmallAwardAchieved, COMDAT
; _this$ = ecx

; 5422 : 	FAssert(eAward >= 0);
; 5423 : 	FAssert(eAward < GC.getNumSmallAwardInfos());
; 5424 : 
; 5425 : 	return m_abSmallAwardAchieved[eAward];

	mov	eax, DWORD PTR [ecx+2904]
	mov	ecx, DWORD PTR _eAward$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 5426 : }

	ret	4
?IsSmallAwardAchieved@CvTeam@@QBE_NW4SmallAwardTypes@@@Z ENDP ; CvTeam::IsSmallAwardAchieved
_TEXT	ENDS
PUBLIC	?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z ; CvTeam::SetSmallAwardAchieved
; Function compile flags: /Ogtpy
;	COMDAT ?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z
_TEXT	SEGMENT
_eAward$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z PROC ; CvTeam::SetSmallAwardAchieved, COMDAT
; _this$ = ecx

; 5432 : 	FAssert(eAward >= 0);
; 5433 : 	FAssert(eAward < GC.getNumSmallAwardInfos());
; 5434 : 
; 5435 : 	m_abSmallAwardAchieved[eAward] = bValue;

	mov	eax, DWORD PTR [ecx+2904]
	mov	cl, BYTE PTR _bValue$[esp-4]
	mov	edx, DWORD PTR _eAward$[esp-4]
	mov	BYTE PTR [edx+eax], cl

; 5436 : }

	ret	8
?SetSmallAwardAchieved@CvTeam@@QAEXW4SmallAwardTypes@@_N@Z ENDP ; CvTeam::SetSmallAwardAchieved
_TEXT	ENDS
PUBLIC	?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTeam::getImprovementYieldChange, COMDAT
; _this$ = ecx

; 6175 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6176 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6177 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6178 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6179 : 	return m_ppaaiImprovementYieldChange[eIndex1][eIndex2];

	mov	eax, DWORD PTR [ecx+2948]
	mov	ecx, DWORD PTR _eIndex1$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eIndex2$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 6180 : }

	ret	8
?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTeam::getImprovementYieldChange
_TEXT	ENDS
PUBLIC	?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementNoFreshWaterYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTeam::getImprovementNoFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6204 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6205 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6206 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6207 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6208 : 	return m_ppaaiImprovementNoFreshWaterYieldChange[eIndex1][eIndex2];

	mov	eax, DWORD PTR [ecx+2952]
	mov	ecx, DWORD PTR _eIndex1$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eIndex2$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 6209 : }

	ret	8
?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTeam::getImprovementNoFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementFreshWaterYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTeam::getImprovementFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6233 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6234 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6235 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6236 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6237 : 	return m_ppaaiImprovementFreshWaterYieldChange[eIndex1][eIndex2];

	mov	eax, DWORD PTR [ecx+2956]
	mov	ecx, DWORD PTR _eIndex1$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eIndex2$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 6238 : }

	ret	8
?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTeam::getImprovementFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isFriendlyTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::isFriendlyTerritory, COMDAT
; _this$ = ecx

; 6897 : 	if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN2@isFriendly

; 6898 : 	{
; 6899 : 		return false;

	xor	al, al

; 6903 : 	{
; 6904 : 		return true;
; 6905 : 	}
; 6906 : 
; 6907 : 	return false;
; 6908 : }

	ret	4
$LN2@isFriendly:

; 6900 : 	}
; 6901 : 
; 6902 : 	if(eTeam == GetID())

	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 6903 : 	{
; 6904 : 		return true;
; 6905 : 	}
; 6906 : 
; 6907 : 	return false;
; 6908 : }

	ret	4
?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::isFriendlyTerritory
_TEXT	ENDS
PUBLIC	?HasTechForWorldCongress@CvTeam@@QBE_NXZ	; CvTeam::HasTechForWorldCongress
; Function compile flags: /Ogtpy
;	COMDAT ?HasTechForWorldCongress@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?HasTechForWorldCongress@CvTeam@@QBE_NXZ PROC		; CvTeam::HasTechForWorldCongress, COMDAT
; _this$ = ecx

; 7030 : 	return m_bHasTechForWorldCongress;

	mov	al, BYTE PTR [ecx+131]

; 7031 : }

	ret	0
?HasTechForWorldCongress@CvTeam@@QBE_NXZ ENDP		; CvTeam::HasTechForWorldCongress
_TEXT	ENDS
PUBLIC	?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z	; CvTeam::SetHasTechForWorldCongress
; Function compile flags: /Ogtpy
;	COMDAT ?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z PROC	; CvTeam::SetHasTechForWorldCongress, COMDAT
; _this$ = ecx

; 7036 : 	m_bHasTechForWorldCongress = bValue;

	mov	al, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [ecx+131], al

; 7037 : }

	ret	4
?SetHasTechForWorldCongress@CvTeam@@QAEX_N@Z ENDP	; CvTeam::SetHasTechForWorldCongress
_TEXT	ENDS
PUBLIC	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ	; CvTeam::GetCurrentEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ
_TEXT	SEGMENT
?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ PROC		; CvTeam::GetCurrentEra, COMDAT
; _this$ = ecx

; 7043 : 	return m_eCurrentEra;

	mov	eax, DWORD PTR [ecx+136]

; 7044 : }

	ret	0
?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ENDP		; CvTeam::GetCurrentEra
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@H$0FA@@Firaxis@@QBEABHI@Z		; Firaxis::Array<int,80>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\farray.h
;	COMDAT ??A?$Array@H$0FA@@Firaxis@@QBEABHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$0FA@@Firaxis@@QBEABHI@Z PROC		; Firaxis::Array<int,80>::operator[], COMDAT
; _this$ = ecx

; 144  : #		ifdef _MSC_VER
; 145  : #			pragma warning ( push )
; 146  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 147  : 			// sad day. 
; 148  : #		endif//_MSC_VER
; 149  : 		    assert( i < ARRAY_SIZE );
; 150  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 151  : #		ifdef _MSC_VER
; 152  : #		pragma warning ( pop )
; 153  : #		endif//_MSC_VER
; 154  : 	    }

	ret	4
??A?$Array@H$0FA@@Firaxis@@QBEABHI@Z ENDP		; Firaxis::Array<int,80>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@H$0FA@@Firaxis@@QAEAAHI@Z		; Firaxis::Array<int,80>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@H$0FA@@Firaxis@@QAEAAHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$0FA@@Firaxis@@QAEAAHI@Z PROC		; Firaxis::Array<int,80>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@H$0FA@@Firaxis@@QAEAAHI@Z ENDP		; Firaxis::Array<int,80>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@H$04@Firaxis@@QBEABHI@Z		; Firaxis::Array<int,5>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@H$04@Firaxis@@QBEABHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$04@Firaxis@@QBEABHI@Z PROC			; Firaxis::Array<int,5>::operator[], COMDAT
; _this$ = ecx

; 144  : #		ifdef _MSC_VER
; 145  : #			pragma warning ( push )
; 146  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 147  : 			// sad day. 
; 148  : #		endif//_MSC_VER
; 149  : 		    assert( i < ARRAY_SIZE );
; 150  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 151  : #		ifdef _MSC_VER
; 152  : #		pragma warning ( pop )
; 153  : #		endif//_MSC_VER
; 154  : 	    }

	ret	4
??A?$Array@H$04@Firaxis@@QBEABHI@Z ENDP			; Firaxis::Array<int,5>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@H$04@Firaxis@@QAEAAHI@Z		; Firaxis::Array<int,5>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@H$04@Firaxis@@QAEAAHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$04@Firaxis@@QAEAAHI@Z PROC			; Firaxis::Array<int,5>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@H$04@Firaxis@@QAEAAHI@Z ENDP			; Firaxis::Array<int,5>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@_N$0FA@@Firaxis@@QBEAB_NI@Z		; Firaxis::Array<bool,80>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@_N$0FA@@Firaxis@@QBEAB_NI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@_N$0FA@@Firaxis@@QBEAB_NI@Z PROC		; Firaxis::Array<bool,80>::operator[], COMDAT
; _this$ = ecx

; 144  : #		ifdef _MSC_VER
; 145  : #			pragma warning ( push )
; 146  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 147  : 			// sad day. 
; 148  : #		endif//_MSC_VER
; 149  : 		    assert( i < ARRAY_SIZE );
; 150  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	add	eax, ecx

; 151  : #		ifdef _MSC_VER
; 152  : #		pragma warning ( pop )
; 153  : #		endif//_MSC_VER
; 154  : 	    }

	ret	4
??A?$Array@_N$0FA@@Firaxis@@QBEAB_NI@Z ENDP		; Firaxis::Array<bool,80>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@_N$0FA@@Firaxis@@QAEAA_NI@Z		; Firaxis::Array<bool,80>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@_N$0FA@@Firaxis@@QAEAA_NI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@_N$0FA@@Firaxis@@QAEAA_NI@Z PROC		; Firaxis::Array<bool,80>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	add	eax, ecx

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@_N$0FA@@Firaxis@@QAEAA_NI@Z ENDP		; Firaxis::Array<bool,80>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$0A@@@QAEAAHI@Z		; BaseVector<int,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$0A@@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$0A@@@QAEAAHI@Z PROC			; BaseVector<int,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$0A@@@QAEAAHI@Z ENDP			; BaseVector<int,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z ; BaseVector<CvEspionageSpy,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z PROC ; BaseVector<CvEspionageSpy,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z ENDP ; BaseVector<CvEspionageSpy,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ	; BaseVector<enum TechTypes,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ PROC	; BaseVector<enum TechTypes,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ ENDP	; BaseVector<enum TechTypes,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z ; BaseVector<enum PlayerTypes,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z PROC ; BaseVector<enum PlayerTypes,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@I@Z ENDP ; BaseVector<enum PlayerTypes,1>::operator[]
_TEXT	ENDS
PUBLIC	?front@?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@XZ ; BaseVector<enum PlayerTypes,1>::front
; Function compile flags: /Ogtpy
;	COMDAT ?front@?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@XZ
_TEXT	SEGMENT
?front@?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@XZ PROC ; BaseVector<enum PlayerTypes,1>::front, COMDAT
; _this$ = ecx

; 150  :         return *m_pData; 

	mov	eax, DWORD PTR [ecx]

; 151  :     };

	ret	0
?front@?$BaseVector@W4PlayerTypes@@$00@@QAEAAW4PlayerTypes@@XZ ENDP ; BaseVector<enum PlayerTypes,1>::front
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ	; BaseVector<enum PlayerTypes,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ PROC	; BaseVector<enum PlayerTypes,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4PlayerTypes@@$00@@QBEIXZ ENDP	; BaseVector<enum PlayerTypes,1>::size
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ; std::auto_ptr<ICvUnit1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ PROC ; std::auto_ptr<ICvUnit1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ENDP ; std::auto_ptr<ICvUnit1>::get
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@XZ ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@_N@@QAE@HPA_N@Z		; ArrayWrapper<bool>::ArrayWrapper<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ArrayWrapper@_N@@QAE@HPA_N@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z PROC			; ArrayWrapper<bool>::ArrayWrapper<bool>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z ENDP			; ArrayWrapper<bool>::ArrayWrapper<bool>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapperConst@H@@QAE@HPBH@Z		; ArrayWrapperConst<int>::ArrayWrapperConst<int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ArrayWrapperConst@H@@QAE@HPBH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapperConst@H@@QAE@HPBH@Z PROC		; ArrayWrapperConst<int>::ArrayWrapperConst<int>, COMDAT
; _this$ = ecx

; 458  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapperConst@H@@QAE@HPBH@Z ENDP		; ArrayWrapperConst<int>::ArrayWrapperConst<int>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapperConst@_N@@QAE@HPB_N@Z		; ArrayWrapperConst<bool>::ArrayWrapperConst<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ArrayWrapperConst@_N@@QAE@HPB_N@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapperConst@_N@@QAE@HPB_N@Z PROC		; ArrayWrapperConst<bool>::ArrayWrapperConst<bool>, COMDAT
; _this$ = ecx

; 458  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapperConst@_N@@QAE@HPB_N@Z ENDP		; ArrayWrapperConst<bool>::ArrayWrapperConst<bool>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::size
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4ResourceTypes@@@std@@QAE@XZ	; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4ResourceTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4ResourceTypes@@@std@@QAE@XZ PROC	; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4ResourceTypes@@@std@@QAE@XZ ENDP	; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 63			; 0000003fH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEPAW4PlayerTypes@@I@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ	; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ PROC		; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@W4PlayerTypes@@$00@@QAE@XZ ENDP		; BaseVector<enum PlayerTypes,1>::~BaseVector<enum PlayerTypes,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ	; BaseVector<enum PlayerTypes,1>::BaseVector<enum PlayerTypes,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ PROC		; BaseVector<enum PlayerTypes,1>::BaseVector<enum PlayerTypes,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@W4PlayerTypes@@$00@@IAE@XZ ENDP		; BaseVector<enum PlayerTypes,1>::BaseVector<enum PlayerTypes,1>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231663 = -80						; size = 28
$T231662 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231663[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231662[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231663[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231662[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231662[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231662[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231662[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231663[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231662[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4ResourceTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum ResourceTypes>::allocator<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z ; std::allocator<enum ResourceTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z PROC ; std::allocator<enum ResourceTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@I@Z ENDP ; std::allocator<enum ResourceTypes>::deallocate
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z ; BaseVector<enum PlayerTypes,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z PROC ; BaseVector<enum PlayerTypes,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@W4PlayerTypes@@$00@@IAEXPAW4PlayerTypes@@I@Z ENDP ; BaseVector<enum PlayerTypes,1>::Destroy
_TEXT	ENDS
PUBLIC	??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ; CvPopupInfo::CvPopupInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z
_TEXT	SEGMENT
_buttonPopupType$ = 8					; size = 4
_data1$ = 12						; size = 4
_data2$ = 16						; size = 4
_data3$ = 20						; size = 4
_flags$ = 24						; size = 4
_option1$ = 28						; size = 1
_option2$ = 32						; size = 1
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z PROC	; CvPopupInfo::CvPopupInfo, COMDAT
; _this$ = ecx

; 119  : 	{

	mov	edx, DWORD PTR _data2$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _data1$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _data3$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _flags$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	cl, BYTE PTR _option1$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR _option2$[esp-4]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _buttonPopupType$[esp-4]
	mov	BYTE PTR [eax+17], dl
	mov	DWORD PTR [eax+20], ecx

; 120  : 		//Nothing
; 121  : 		szText[0] = 0;

	mov	BYTE PTR [eax+24], 0

; 122  : 	}

	ret	28					; 0000001cH
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ENDP	; CvPopupInfo::CvPopupInfo
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 63			; 0000003fH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ
_TEXT	SEGMENT
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis, COMDAT
; _this$ = ecx

; 701  : 	inline GenericClass *GetClosureThis() const { return m_pthis; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
_TEXT	ENDS
PUBLIC	?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ
_TEXT	SEGMENT
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr, COMDAT
; _this$ = ecx

; 702  : 	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ ; std::allocator<enum ResourceTypes>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ PROC ; std::allocator<enum ResourceTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4ResourceTypes@@@std@@QBEIXZ ENDP ; std::allocator<enum ResourceTypes>::max_size
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NABV12@@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z PROC ; operator<<<Localization::String>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NABV12@@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ENDP ; operator<<<Localization::String>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T231767 = -12						; size = 12
$T231771 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z PROC ; std::_Allocate<enum ResourceTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231771[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231767[esp+16]
	mov	DWORD PTR $T231771[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231767[esp+16]
	push	ecx
	mov	DWORD PTR $T231767[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@I@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@I@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEABW4ResourceTypes@@I@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAW4ResourceTypes@@I@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAW4ResourceTypes@@I@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAW4ResourceTypes@@I@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ		; ArrayWrapper<bool>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ PROC		; ArrayWrapper<bool>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ ENDP		; ArrayWrapper<bool>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@_N@@QBEHXZ		; ArrayWrapper<bool>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@_N@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@_N@@QBEHXZ PROC		; ArrayWrapper<bool>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@_N@@QBEHXZ ENDP		; ArrayWrapper<bool>::getCount
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapperConst@H@@QBEPBHXZ	; ArrayWrapperConst<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapperConst@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapperConst@H@@QBEPBHXZ PROC		; ArrayWrapperConst<int>::getArray, COMDAT
; _this$ = ecx

; 462  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 463  : 	}

	ret	0
?getArray@?$ArrayWrapperConst@H@@QBEPBHXZ ENDP		; ArrayWrapperConst<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapperConst@H@@QBEHXZ		; ArrayWrapperConst<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapperConst@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapperConst@H@@QBEHXZ PROC		; ArrayWrapperConst<int>::getCount, COMDAT
; _this$ = ecx

; 466  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 467  : 	}

	ret	0
?getCount@?$ArrayWrapperConst@H@@QBEHXZ ENDP		; ArrayWrapperConst<int>::getCount
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapperConst@_N@@QBEPB_NXZ	; ArrayWrapperConst<bool>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapperConst@_N@@QBEPB_NXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapperConst@_N@@QBEPB_NXZ PROC	; ArrayWrapperConst<bool>::getArray, COMDAT
; _this$ = ecx

; 462  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 463  : 	}

	ret	0
?getArray@?$ArrayWrapperConst@_N@@QBEPB_NXZ ENDP	; ArrayWrapperConst<bool>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapperConst@_N@@QBEHXZ	; ArrayWrapperConst<bool>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapperConst@_N@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapperConst@_N@@QBEHXZ PROC		; ArrayWrapperConst<bool>::getCount, COMDAT
; _this$ = ecx

; 466  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 467  : 	}

	ret	0
?getCount@?$ArrayWrapperConst@_N@@QBEHXZ ENDP		; ArrayWrapperConst<bool>::getCount
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4ResourceTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4ResourceTypes@@0@Z ; std::_Iter_random<enum ResourceTypes *,enum ResourceTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAW4ResourceTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4ResourceTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4ResourceTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4ResourceTypes@@0@Z PROC ; std::_Iter_random<enum ResourceTypes *,enum ResourceTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4ResourceTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4ResourceTypes@@0@Z ENDP ; std::_Iter_random<enum ResourceTypes *,enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z ; std::_Ptr_cat<enum ResourceTypes *,enum ResourceTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z PROC ; std::_Ptr_cat<enum ResourceTypes *,enum ResourceTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4ResourceTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4ResourceTypes@@0@Z ENDP ; std::_Ptr_cat<enum ResourceTypes *,enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z ; std::_Fill<enum ResourceTypes *,enum ResourceTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z PROC ; std::_Fill<enum ResourceTypes *,enum ResourceTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z ENDP ; std::_Fill<enum ResourceTypes *,enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4ResourceTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4ResourceTypes@@@Z ; std::_Move_cat<enum ResourceTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4ResourceTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4ResourceTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4ResourceTypes@@@Z PROC ; std::_Move_cat<enum ResourceTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4ResourceTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4ResourceTypes@@@Z ENDP ; std::_Move_cat<enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z PROC ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>, COMDAT

; 153  : 	return input;

	mov	eax, DWORD PTR _input$[esp-4]

; 154  : }

	ret	0
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ENDP ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z ; std::_Construct<enum ResourceTypes,enum ResourceTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z PROC ; std::_Construct<enum ResourceTypes,enum ResourceTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@W4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@ABW41@@Z ENDP ; std::_Construct<enum ResourceTypes,enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z ; std::_Destroy<enum ResourceTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z PROC ; std::_Destroy<enum ResourceTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4ResourceTypes@@@std@@YAXPAW4ResourceTypes@@@Z ENDP ; std::_Destroy<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBE_NABU01@@Z ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::pair<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>::pair<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::pair<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>::pair<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::pair<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>::pair<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
_bound_func$ = 16					; size = 4
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z PROC ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>, COMDAT

; 306  : 			GenericMemFuncType &bound_func) {
; 307  : #if defined __DMC__  
; 308  : 		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
; 309  : 		// even though the standard says you can. The 32-bit compiler lets you
; 310  : 		// static_cast through an int, but the DOS compiler doesn't.
; 311  : 		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
; 312  : #else 
; 313  :         bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);

	mov	eax, DWORD PTR _bound_func$[esp-4]
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax], ecx

; 314  : #endif
; 315  :         return reinterpret_cast<GenericClass *>(pthis);

	mov	eax, DWORD PTR _pthis$[esp-4]

; 316  : 	}

	ret	0
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ENDP ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ; std::_Dist_type<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::swap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::swap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::swap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Iter_random<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getNEW_SCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getNEW_SCORE_FUTURE_TECH_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getNEW_SCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNEW_SCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getNEW_SCORE_FUTURE_TECH_MULTIPLIER, COMDAT
; _this$ = ecx

; 859  : 	GD_INT_DEF(NEW_SCORE_FUTURE_TECH_MULTIPLIER);

	mov	eax, DWORD PTR [ecx+1792]
	ret	0
?getNEW_SCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getNEW_SCORE_FUTURE_TECH_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_AGGRESSOR_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_AGGRESSOR_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_AGGRESSOR_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_AGGRESSOR_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_AGGRESSOR_THRESHOLD, COMDAT
; _this$ = ecx

; 1837 : 		return m_iMINOR_CIV_AGGRESSOR_THRESHOLD;

	mov	eax, DWORD PTR [ecx+2772]

; 1838 : 	}

	ret	0
?getMINOR_CIV_AGGRESSOR_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_AGGRESSOR_THRESHOLD
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_WARMONGER_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getMINOR_CIV_WARMONGER_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_WARMONGER_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_WARMONGER_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMINOR_CIV_WARMONGER_THRESHOLD, COMDAT
; _this$ = ecx

; 1841 : 		return m_iMINOR_CIV_WARMONGER_THRESHOLD;

	mov	eax, DWORD PTR [ecx+2776]

; 1842 : 	}

	ret	0
?getMINOR_CIV_WARMONGER_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMINOR_CIV_WARMONGER_THRESHOLD
_TEXT	ENDS
PUBLIC	?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ	; CvGlobals::getEVENT_MESSAGE_TIME
; Function compile flags: /Ogtpy
;	COMDAT ?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ PROC		; CvGlobals::getEVENT_MESSAGE_TIME, COMDAT
; _this$ = ecx

; 5252 : 		return m_iEVENT_MESSAGE_TIME;

	mov	eax, DWORD PTR [ecx+6176]

; 5253 : 	}

	ret	0
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getEVENT_MESSAGE_TIME
_TEXT	ENDS
PUBLIC	?getPEACE_TREATY_LENGTH@CvGlobals@@QAEHXZ	; CvGlobals::getPEACE_TREATY_LENGTH
; Function compile flags: /Ogtpy
;	COMDAT ?getPEACE_TREATY_LENGTH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPEACE_TREATY_LENGTH@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPEACE_TREATY_LENGTH, COMDAT
; _this$ = ecx

; 5764 : 		return m_iPEACE_TREATY_LENGTH;

	mov	eax, DWORD PTR [ecx+6688]

; 5765 : 	}

	ret	0
?getPEACE_TREATY_LENGTH@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPEACE_TREATY_LENGTH
_TEXT	ENDS
PUBLIC	?getCIRCUMNAVIGATE_FREE_MOVES@CvGlobals@@QAEHXZ	; CvGlobals::getCIRCUMNAVIGATE_FREE_MOVES
; Function compile flags: /Ogtpy
;	COMDAT ?getCIRCUMNAVIGATE_FREE_MOVES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCIRCUMNAVIGATE_FREE_MOVES@CvGlobals@@QAEHXZ PROC	; CvGlobals::getCIRCUMNAVIGATE_FREE_MOVES, COMDAT
; _this$ = ecx

; 5820 : 		return m_iCIRCUMNAVIGATE_FREE_MOVES;

	mov	eax, DWORD PTR [ecx+6744]

; 5821 : 	}

	ret	0
?getCIRCUMNAVIGATE_FREE_MOVES@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getCIRCUMNAVIGATE_FREE_MOVES
_TEXT	ENDS
PUBLIC	?getBARBARIAN_TECH_PERCENT@CvGlobals@@QAEHXZ	; CvGlobals::getBARBARIAN_TECH_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getBARBARIAN_TECH_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_TECH_PERCENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_TECH_PERCENT, COMDAT
; _this$ = ecx

; 6168 : 		return m_iBARBARIAN_TECH_PERCENT;

	mov	eax, DWORD PTR [ecx+7092]

; 6169 : 	}

	ret	0
?getBARBARIAN_TECH_PERCENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_TECH_PERCENT
_TEXT	ENDS
PUBLIC	?getMINOR_CIV_TECH_PERCENT@CvGlobals@@QAEHXZ	; CvGlobals::getMINOR_CIV_TECH_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getMINOR_CIV_TECH_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMINOR_CIV_TECH_PERCENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMINOR_CIV_TECH_PERCENT, COMDAT
; _this$ = ecx

; 6429 : 		return m_iMINOR_CIV_TECH_PERCENT;

	mov	eax, DWORD PTR [ecx+7300]

; 6430 : 	}

	ret	0
?getMINOR_CIV_TECH_PERCENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMINOR_CIV_TECH_PERCENT
_TEXT	ENDS
PUBLIC	?getOWN_UNITED_NATIONS_VOTE_BONUS@CvGlobals@@QAEHXZ ; CvGlobals::getOWN_UNITED_NATIONS_VOTE_BONUS
; Function compile flags: /Ogtpy
;	COMDAT ?getOWN_UNITED_NATIONS_VOTE_BONUS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getOWN_UNITED_NATIONS_VOTE_BONUS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getOWN_UNITED_NATIONS_VOTE_BONUS, COMDAT
; _this$ = ecx

; 6857 : 		return m_iOWN_UNITED_NATIONS_VOTE_BONUS;

	mov	eax, DWORD PTR [ecx+7728]

; 6858 : 	}

	ret	0
?getOWN_UNITED_NATIONS_VOTE_BONUS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getOWN_UNITED_NATIONS_VOTE_BONUS
_TEXT	ENDS
PUBLIC	?getSCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getSCORE_FUTURE_TECH_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getSCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSCORE_FUTURE_TECH_MULTIPLIER, COMDAT
; _this$ = ecx

; 6893 : 		return m_iSCORE_FUTURE_TECH_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+7764]

; 6894 : 	}

	ret	0
?getSCORE_FUTURE_TECH_MULTIPLIER@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSCORE_FUTURE_TECH_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ		; CvGlobals::getSTANDARD_HANDICAP
; Function compile flags: /Ogtpy
;	COMDAT ?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ PROC		; CvGlobals::getSTANDARD_HANDICAP, COMDAT
; _this$ = ecx

; 7235 : 		return m_iSTANDARD_HANDICAP;

	mov	eax, DWORD PTR [ecx+8452]

; 7236 : 	}

	ret	0
?getSTANDARD_HANDICAP@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getSTANDARD_HANDICAP
_TEXT	ENDS
PUBLIC	?getLAST_BRIDGE_ART_ERA@CvGlobals@@QAEHXZ	; CvGlobals::getLAST_BRIDGE_ART_ERA
; Function compile flags: /Ogtpy
;	COMDAT ?getLAST_BRIDGE_ART_ERA@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getLAST_BRIDGE_ART_ERA@CvGlobals@@QAEHXZ PROC		; CvGlobals::getLAST_BRIDGE_ART_ERA, COMDAT
; _this$ = ecx

; 7279 : 		return m_iLAST_BRIDGE_ART_ERA;

	mov	eax, DWORD PTR [ecx+8496]

; 7280 : 	}

	ret	0
?getLAST_BRIDGE_ART_ERA@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getLAST_BRIDGE_ART_ERA
_TEXT	ENDS
PUBLIC	?getPROMOTION_EMBARKATION@CvGlobals@@QAEHXZ	; CvGlobals::getPROMOTION_EMBARKATION
; Function compile flags: /Ogtpy
;	COMDAT ?getPROMOTION_EMBARKATION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPROMOTION_EMBARKATION@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPROMOTION_EMBARKATION, COMDAT
; _this$ = ecx

; 7307 : 		return m_iPROMOTION_EMBARKATION;

	mov	eax, DWORD PTR [ecx+8524]

; 7308 : 	}

	ret	0
?getPROMOTION_EMBARKATION@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPROMOTION_EMBARKATION
_TEXT	ENDS
PUBLIC	?getPROMOTION_ALLWATER_EMBARKATION@CvGlobals@@QAEHXZ ; CvGlobals::getPROMOTION_ALLWATER_EMBARKATION
; Function compile flags: /Ogtpy
;	COMDAT ?getPROMOTION_ALLWATER_EMBARKATION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPROMOTION_ALLWATER_EMBARKATION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPROMOTION_ALLWATER_EMBARKATION, COMDAT
; _this$ = ecx

; 7315 : 		return m_iPROMOTION_ALLWATER_EMBARKATION;

	mov	eax, DWORD PTR [ecx+8532]

; 7316 : 	}

	ret	0
?getPROMOTION_ALLWATER_EMBARKATION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPROMOTION_ALLWATER_EMBARKATION
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7738 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8596]

; 7739 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7748 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8600]

; 7749 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?isBeingResurrected@CvPlayer@@QBE_NXZ		; CvPlayer::isBeingResurrected
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isBeingResurrected@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isBeingResurrected@CvPlayer@@QBE_NXZ PROC		; CvPlayer::isBeingResurrected, COMDAT
; _this$ = ecx

; 1107 : 		return m_bBeingResurrected;

	mov	al, BYTE PTR [ecx+2276]

; 1108 : 	}

	ret	0
?isBeingResurrected@CvPlayer@@QBE_NXZ ENDP		; CvPlayer::isBeingResurrected
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?isAlive@CvTeam@@QBE_NXZ			; CvTeam::isAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isAlive@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvTeam@@QBE_NXZ PROC				; CvTeam::isAlive, COMDAT
; _this$ = ecx

; 131  : 		return m_iAliveCount > 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	setg	al

; 132  : 	}

	ret	0
?isAlive@CvTeam@@QBE_NXZ ENDP				; CvTeam::isAlive
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetExtraSpies@CvPlayerTraits@@QBEHXZ		; CvPlayerTraits::GetExtraSpies
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetExtraSpies@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetExtraSpies@CvPlayerTraits@@QBEHXZ PROC		; CvPlayerTraits::GetExtraSpies, COMDAT
; _this$ = ecx

; 690  : 		return m_iExtraSpies;

	mov	eax, DWORD PTR [ecx+272]

; 691  : 	};

	ret	0
?GetExtraSpies@CvPlayerTraits@@QBEHXZ ENDP		; CvPlayerTraits::GetExtraSpies
_TEXT	ENDS
PUBLIC	?GetFreeSocialPoliciesPerEra@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetFreeSocialPoliciesPerEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeSocialPoliciesPerEra@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetFreeSocialPoliciesPerEra@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetFreeSocialPoliciesPerEra, COMDAT
; _this$ = ecx

; 708  : 		return m_iFreeSocialPoliciesPerEra;

	mov	eax, DWORD PTR [ecx+288]

; 709  : 	}

	ret	0
?GetFreeSocialPoliciesPerEra@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetFreeSocialPoliciesPerEra
_TEXT	ENDS
PUBLIC	??0DelegateMemento@fastdelegate@@QAE@XZ		; fastdelegate::DelegateMemento::DelegateMemento
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0DelegateMemento@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0DelegateMemento@fastdelegate@@QAE@XZ PROC		; fastdelegate::DelegateMemento::DelegateMemento, COMDAT
; _this$ = ecx

; 579  : 	DelegateMemento() : m_pthis(0), m_pFunction(0) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0DelegateMemento@fastdelegate@@QAE@XZ ENDP		; fastdelegate::DelegateMemento::DelegateMemento
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ		; FAllocBase<0,0,0>::FAllocBase<0,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ??0?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ PROC		; FAllocBase<0,0,0>::FAllocBase<0,0,0>, COMDAT
; _this$ = ecx

; 31   : 	{}

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ ENDP		; FAllocBase<0,0,0>::FAllocBase<0,0,0>
_TEXT	ENDS
PUBLIC	??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ		; FAllocBase<0,0,0>::~FAllocBase<0,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ PROC		; FAllocBase<0,0,0>::~FAllocBase<0,0,0>, COMDAT
; _this$ = ecx

; 34   : 		FAssert( !m_pData );
; 35   : 	}

	ret	0
??1?$FAllocBase@$0A@$0A@$0A@@@QAE@XZ ENDP		; FAllocBase<0,0,0>::~FAllocBase<0,0,0>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T232061 = -80						; size = 28
$T232060 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T232061[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232060[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232061[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T232060[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T232060[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T232060[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T232060[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T232061[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T232060[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?Free@?$FAllocBase@$0A@$0A@$0A@@@QAEXXZ		; FAllocBase<0,0,0>::Free
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocBase@$0A@$0A@$0A@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocBase@$0A@$0A@$0A@@@QAEXXZ PROC		; FAllocBase<0,0,0>::Free, COMDAT
; _this$ = ecx

; 48   : 	{

	push	esi
	mov	esi, ecx

; 49   : 		delete[] m_pData;

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 50   : 		m_pData = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 51   : 	}

	ret	0
?Free@?$FAllocBase@$0A@$0A@$0A@@@QAEXXZ ENDP		; FAllocBase<0,0,0>::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocBase@$0A@$0A@$0A@@@QAEPAXIPAUAllocData@@@Z ; FAllocBase<0,0,0>::Alloc
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocBase@$0A@$0A@$0A@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocBase@$0A@$0A@$0A@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocBase<0,0,0>::Alloc, COMDAT
; _this$ = ecx

; 42   : 	{

	push	esi
	push	edi

; 43   : 		m_pData = FNEW( unsigned char[nBytes], AllocPool, nSubID );

	mov	edi, DWORD PTR _nBytes$[esp+4]
	push	edi
	mov	esi, ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 44   : 		return static_cast< void* >( m_pData + nBytes );

	add	eax, edi
	pop	edi
	pop	esi

; 45   : 	}

	ret	8
?Alloc@?$FAllocBase@$0A@$0A@$0A@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocBase<0,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T232128 = -12						; size = 12
$T232132 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232132[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232128[esp+16]
	mov	DWORD PTR $T232132[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232128[esp+16]
	push	ecx
	mov	DWORD PTR $T232128[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T232203 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T232203[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 
; 517  : 	size_t bytes = 0;
; 518  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 519  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 520  : 	str.assign(szComposedString, bytes);
; 521  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T232203[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 522  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T232203[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T232203[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??0?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocBase<0,0,0> >::FAllocArray2DType<int,FAllocBase<0,0,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocBase<0,0,0> >::FAllocArray2DType<int,FAllocBase<0,0,0> >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocBase<0,0,0> >::FAllocArray2DType<int,FAllocBase<0,0,0> >
_TEXT	ENDS
PUBLIC	??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocBase<0,0,0> >::~FAllocArray2DType<int,FAllocBase<0,0,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocBase<0,0,0> >::~FAllocArray2DType<int,FAllocBase<0,0,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocBase<0,0,0> >::~FAllocArray2DType<int,FAllocBase<0,0,0> >
_TEXT	ENDS
PUBLIC	?IsMinorCivAggressor@CvTeam@@QBE_NXZ		; CvTeam::IsMinorCivAggressor
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?IsMinorCivAggressor@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsMinorCivAggressor@CvTeam@@QBE_NXZ PROC		; CvTeam::IsMinorCivAggressor, COMDAT
; _this$ = ecx

; 2594 : 	// Player has attacked enough Minors that they're getting antsy
; 2595 : 	if(GetNumMinorCivsAttacked() >= /*2*/ GC.getMINOR_CIV_AGGRESSOR_THRESHOLD())

	mov	eax, DWORD PTR [ecx+124]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2772
	setge	al

; 2596 : 		return true;
; 2597 : 
; 2598 : 	return false;
; 2599 : }

	ret	0
?IsMinorCivAggressor@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsMinorCivAggressor
_TEXT	ENDS
PUBLIC	?IsMinorCivWarmonger@CvTeam@@QBE_NXZ		; CvTeam::IsMinorCivWarmonger
; Function compile flags: /Ogtpy
;	COMDAT ?IsMinorCivWarmonger@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?IsMinorCivWarmonger@CvTeam@@QBE_NXZ PROC		; CvTeam::IsMinorCivWarmonger, COMDAT
; _this$ = ecx

; 2605 : 	// Player has attacked enough Minors that an Alliance has formed
; 2606 : 	if(GetNumMinorCivsAttacked() >= /*4*/ GC.getMINOR_CIV_WARMONGER_THRESHOLD())

	mov	eax, DWORD PTR [ecx+124]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2776
	setge	al

; 2607 : 		return true;
; 2608 : 
; 2609 : 	return false;
; 2610 : }

	ret	0
?IsMinorCivWarmonger@CvTeam@@QBE_NXZ ENDP		; CvTeam::IsMinorCivWarmonger
_TEXT	ENDS
PUBLIC	?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z	; CvTeam::changeExtraWaterSeeFromCount
EXTRN	?updateSight@CvMap@@QAEX_N@Z:PROC		; CvMap::updateSight
; Function compile flags: /Ogtpy
;	COMDAT ?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z PROC	; CvTeam::changeExtraWaterSeeFromCount, COMDAT
; _this$ = ecx

; 2971 : {

	push	esi
	push	edi

; 2972 : 	if(iChange != 0)

	mov	edi, DWORD PTR _iChange$[esp+4]
	mov	esi, ecx
	test	edi, edi
	je	SHORT $LN1@changeExtr

; 2973 : 	{
; 2974 : 		GC.getMap().updateSight(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	0
	call	?updateSight@CvMap@@QAEX_N@Z		; CvMap::updateSight

; 2975 : 
; 2976 : 		m_iExtraWaterSeeFromCount = (m_iExtraWaterSeeFromCount + iChange);

	add	DWORD PTR [esi+36], edi
	pop	edi
	pop	esi

; 2977 : 		CvAssert(getExtraWaterSeeFromCount() >= 0);
; 2978 : 
; 2979 : 		GC.getMap().updateSight(true);

	mov	DWORD PTR _iChange$[esp-4], 1
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	?updateSight@CvMap@@QAEX_N@Z		; CvMap::updateSight
$LN1@changeExtr:
	pop	edi
	pop	esi

; 2980 : 	}
; 2981 : }

	ret	4
?changeExtraWaterSeeFromCount@CvTeam@@QAEXH@Z ENDP	; CvTeam::changeExtraWaterSeeFromCount
_TEXT	ENDS
PUBLIC	?changeBridgeBuildingCount@CvTeam@@QAEXH@Z	; CvTeam::changeBridgeBuildingCount
EXTRN	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ:PROC	; CvGlobals::IsGraphicsInitialized
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
; Function compile flags: /Ogtpy
;	COMDAT ?changeBridgeBuildingCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeBridgeBuildingCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeBridgeBuildingCount, COMDAT
; _this$ = ecx

; 3234 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN1@changeBrid

; 3235 : 	{
; 3236 : 		m_iBridgeBuildingCount = (m_iBridgeBuildingCount + iChange);

	add	DWORD PTR [esi+76], eax

; 3237 : 		CvAssert(getBridgeBuildingCount() >= 0);
; 3238 : 
; 3239 : 		if(m_eID == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@changeBrid

; 3240 : 		{
; 3241 : 			if(GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN1@changeBrid

; 3242 : 			{
; 3243 : 				if(GetCurrentEra() >= GC.getLAST_BRIDGE_ART_ERA())

	mov	eax, DWORD PTR [esi+136]

; 3244 : 				{
; 3245 : 					gDLL->GameplayBridgeChanged(true, 1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8496
	mov	eax, DWORD PTR [edx+580]
	jl	SHORT $LN2@changeBrid
	push	1

; 3246 : 				}
; 3247 : 				else
; 3248 : 				{
; 3249 : 					gDLL->GameplayBridgeChanged(true, 0);

	push	1
	call	eax
	pop	esi

; 3250 : 				}
; 3251 : 			}
; 3252 : 		}
; 3253 : 	}
; 3254 : }

	ret	4
$LN2@changeBrid:

; 3246 : 				}
; 3247 : 				else
; 3248 : 				{
; 3249 : 					gDLL->GameplayBridgeChanged(true, 0);

	push	0
	push	1
	call	eax
$LN1@changeBrid:
	pop	esi

; 3250 : 				}
; 3251 : 			}
; 3252 : 		}
; 3253 : 	}
; 3254 : }

	ret	4
?changeBridgeBuildingCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeBridgeBuildingCount
_TEXT	ENDS
PUBLIC	?setMapCentering@CvTeam@@QAEX_N@Z		; CvTeam::setMapCentering
; Function compile flags: /Ogtpy
;	COMDAT ?setMapCentering@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?setMapCentering@CvTeam@@QAEX_N@Z PROC			; CvTeam::setMapCentering, COMDAT
; _this$ = ecx

; 3314 : 	if(isMapCentering() != bNewValue)

	mov	al, BYTE PTR _bNewValue$[esp-4]
	cmp	BYTE PTR [ecx+128], al
	je	SHORT $LN1@setMapCent
	push	esi

; 3315 : 	{
; 3316 : 		m_bMapCentering = bNewValue;
; 3317 : 
; 3318 : 		if(GetID() == GC.getGame().getActiveTeam())

	mov	esi, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+128], al
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	pop	esi
	jne	SHORT $LN1@setMapCent

; 3319 : 		{
; 3320 : 			DLLUI->setDirty(MinimapSection_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	15					; 0000000fH
	call	edx
$LN1@setMapCent:

; 3321 : 		}
; 3322 : 	}
; 3323 : }

	ret	4
?setMapCentering@CvTeam@@QAEX_N@Z ENDP			; CvTeam::setMapCentering
_TEXT	ENDS
PUBLIC	?getTechShareCount@CvTeam@@QBEHH@Z		; CvTeam::getTechShareCount
; Function compile flags: /Ogtpy
;	COMDAT ?getTechShareCount@CvTeam@@QBEHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getTechShareCount@CvTeam@@QBEHH@Z PROC			; CvTeam::getTechShareCount, COMDAT
; _this$ = ecx

; 3336 : 	CvAssertMsg(iIndex >= 0, "iIndex is expected to be non-negative (invalid Index)");
; 3337 : 	CvAssertMsg(iIndex < MAX_TEAMS, "iIndex is expected to be within maximum bounds (invalid Index)");
; 3338 : 	if(iIndex < 0 || iIndex >= MAX_TEAMS) return 0; // as set in reset()

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getTechSha

; 3339 : 	return m_aiTechShareCount[iIndex];

	mov	eax, DWORD PTR [ecx+eax*4+148]

; 3340 : }

	ret	4
$LN1@getTechSha:

; 3336 : 	CvAssertMsg(iIndex >= 0, "iIndex is expected to be non-negative (invalid Index)");
; 3337 : 	CvAssertMsg(iIndex < MAX_TEAMS, "iIndex is expected to be within maximum bounds (invalid Index)");
; 3338 : 	if(iIndex < 0 || iIndex >= MAX_TEAMS) return 0; // as set in reset()

	xor	eax, eax

; 3340 : }

	ret	4
?getTechShareCount@CvTeam@@QBEHH@Z ENDP			; CvTeam::getTechShareCount
_TEXT	ENDS
PUBLIC	?isTechShare@CvTeam@@QBE_NH@Z			; CvTeam::isTechShare
; Function compile flags: /Ogtpy
;	COMDAT ?isTechShare@CvTeam@@QBE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?isTechShare@CvTeam@@QBE_NH@Z PROC			; CvTeam::isTechShare, COMDAT
; _this$ = ecx

; 3346 : 	return (getTechShareCount(iIndex) > 0);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@isTechShar
	mov	eax, DWORD PTR [ecx+eax*4+148]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3347 : }

	ret	4

; 3346 : 	return (getTechShareCount(iIndex) > 0);

$LN3@isTechShar:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3347 : }

	ret	4
?isTechShare@CvTeam@@QBE_NH@Z ENDP			; CvTeam::isTechShare
_TEXT	ENDS
PUBLIC	?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z	; CvTeam::getExtraMoves
; Function compile flags: /Ogtpy
;	COMDAT ?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z PROC	; CvTeam::getExtraMoves, COMDAT
; _this$ = ecx

; 3372 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3373 : 	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3374 : 	return m_aiExtraMoves[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+1108]

; 3375 : }

	ret	4
?getExtraMoves@CvTeam@@QBEHW4DomainTypes@@@Z ENDP	; CvTeam::getExtraMoves
_TEXT	ENDS
PUBLIC	?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z ; CvTeam::changeExtraMoves
; Function compile flags: /Ogtpy
;	COMDAT ?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z PROC	; CvTeam::changeExtraMoves, COMDAT
; _this$ = ecx

; 3381 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3382 : 	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3383 : 	m_aiExtraMoves[eIndex] = (m_aiExtraMoves[eIndex] + iChange);

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+eax*4+1108], edx

; 3384 : 	CvAssert(getExtraMoves(eIndex) >= 0);
; 3385 : }

	ret	8
?changeExtraMoves@CvTeam@@QAEXW4DomainTypes@@H@Z ENDP	; CvTeam::changeExtraMoves
_TEXT	ENDS
PUBLIC	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z		; CvTeam::isHasMet
; Function compile flags: /Ogtpy
;	COMDAT ?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z PROC		; CvTeam::isHasMet, COMDAT
; _this$ = ecx

; 3601 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3602 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3603 : 	return m_abHasMet[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+1848]

; 3604 : }

	ret	4
?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP		; CvTeam::isHasMet
_TEXT	ENDS
PUBLIC	?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetTurnsSinceMeetingTeam
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z PROC ; CvTeam::GetTurnsSinceMeetingTeam, COMDAT
; _this$ = ecx

; 3785 : {

	push	esi
	mov	esi, ecx

; 3786 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3787 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3788 : 	return GC.getGame().getGameTurn() - m_aiTurnTeamMet[eTeam];

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _eTeam$[esp]
	sub	eax, DWORD PTR [esi+ecx*4+2568]
	pop	esi

; 3789 : }

	ret	4
?GetTurnsSinceMeetingTeam@CvTeam@@QBEHW4TeamTypes@@@Z ENDP ; CvTeam::GetTurnsSinceMeetingTeam
_TEXT	ENDS
PUBLIC	?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z	; CvTeam::GetTurnTeamMet
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z PROC	; CvTeam::GetTurnTeamMet, COMDAT
; _this$ = ecx

; 3794 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3795 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3796 : 	return m_aiTurnTeamMet[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+2568]

; 3797 : }

	ret	4
?GetTurnTeamMet@CvTeam@@QBEHW4TeamTypes@@@Z ENDP	; CvTeam::GetTurnTeamMet
_TEXT	ENDS
PUBLIC	?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z	; CvTeam::SetTurnTeamMet
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_iTurn$ = 12						; size = 4
?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z PROC	; CvTeam::SetTurnTeamMet, COMDAT
; _this$ = ecx

; 3802 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3803 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3804 : 	m_aiTurnTeamMet[eTeam] = iTurn;

	mov	eax, DWORD PTR _iTurn$[esp-4]
	mov	edx, DWORD PTR _eTeam$[esp-4]
	mov	DWORD PTR [ecx+edx*4+2568], eax

; 3805 : }

	ret	8
?SetTurnTeamMet@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP	; CvTeam::SetTurnTeamMet
_TEXT	ENDS
PUBLIC	?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z ; CvTeam::IsHasFoundPlayersTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z PROC ; CvTeam::IsHasFoundPlayersTerritory, COMDAT
; _this$ = ecx

; 3811 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3812 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3813 : 	return m_abHasFoundPlayersTerritory[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	al, BYTE PTR [eax+ecx+1768]

; 3814 : }

	ret	4
?IsHasFoundPlayersTerritory@CvTeam@@QBE_NW4PlayerTypes@@@Z ENDP ; CvTeam::IsHasFoundPlayersTerritory
_TEXT	ENDS
PUBLIC	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ; CvTeam::SetHasFoundPlayersTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z PROC ; CvTeam::SetHasFoundPlayersTerritory, COMDAT
; _this$ = ecx

; 3820 : 	CvAssertMsg(ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 3821 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 3822 : 
; 3823 : 	if(IsHasFoundPlayersTerritory(ePlayer) != bValue)

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	dl, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [eax+ecx+1768], dl
	je	SHORT $LN1@SetHasFoun

; 3824 : 	{
; 3825 : 		m_abHasFoundPlayersTerritory[ePlayer] = bValue;

	mov	BYTE PTR [eax+ecx+1768], dl

; 3826 : 		return true;

	mov	al, 1

; 3829 : }

	ret	8
$LN1@SetHasFoun:

; 3827 : 	}
; 3828 : 	return false;

	xor	al, al

; 3829 : }

	ret	8
?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ENDP ; CvTeam::SetHasFoundPlayersTerritory
_TEXT	ENDS
PUBLIC	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z		; CvTeam::isAtWar
; Function compile flags: /Ogtpy
;	COMDAT ?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z PROC		; CvTeam::isAtWar, COMDAT
; _this$ = ecx

; 3834 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3835 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3836 : 	return m_abAtWar[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+1928]

; 3837 : }

	ret	4
?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP		; CvTeam::isAtWar
_TEXT	ENDS
PUBLIC	?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z		; CvTeam::setAtWar
; Function compile flags: /Ogtpy
;	COMDAT ?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::setAtWar, COMDAT
; _this$ = ecx

; 3843 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3844 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3845 : 	CvAssertMsg(eIndex != GetID() || bNewValue == false, "Team is setting war with itself!");
; 3846 : 	if(eIndex != GetID() || bNewValue == false)

	mov	edx, DWORD PTR _bNewValue$[esp-4]
	push	esi
	mov	esi, DWORD PTR _eIndex$[esp]
	mov	eax, ecx
	push	edi
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LN1@setAtWar
	test	dl, dl
	jne	SHORT $LN2@setAtWar
$LN1@setAtWar:

; 3847 : 		m_abAtWar[eIndex] = bNewValue;

	mov	BYTE PTR [esi+eax+1928], dl
$LN2@setAtWar:

; 3848 : 
; 3849 : 	gDLL->GameplayWarStateChanged(GetID(), eIndex, bNewValue);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	push	edx
	mov	edx, DWORD PTR [edi+728]
	push	esi
	push	eax
	call	edx
	pop	edi
	pop	esi

; 3850 : 
; 3851 : #ifndef FINAL_RELEASE
; 3852 : 	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
; 3853 : 	{
; 3854 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes) iMinorLoop);
; 3855 : 		if(kPlayer.getTeam() == eIndex && kPlayer.isAlive())
; 3856 : 			CvAssertMsg(GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->GetAlly() != getLeaderID(), "Major civ is now at war with a minor it is allied with! This is dumb and bad. If you didn't do this on purpose, please send Jon this along with your last 5 autosaves and a changelist #.");
; 3857 : 	}
; 3858 : #endif
; 3859 : }

	ret	8
?setAtWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::setAtWar
_TEXT	ENDS
PUBLIC	?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z	; CvTeam::GetNumTurnsAtWar
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z PROC	; CvTeam::GetNumTurnsAtWar, COMDAT
; _this$ = ecx

; 3891 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3892 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3893 : 	return m_aiNumTurnsAtWar[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+468]

; 3894 : }

	ret	4
?GetNumTurnsAtWar@CvTeam@@QBEHW4TeamTypes@@@Z ENDP	; CvTeam::GetNumTurnsAtWar
_TEXT	ENDS
PUBLIC	?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z	; CvTeam::SetNumTurnsAtWar
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC	; CvTeam::SetNumTurnsAtWar, COMDAT
; _this$ = ecx

; 3900 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3901 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3902 : 	CvAssertMsg(eTeam != GetID() || iValue == 0, "Team is setting war turns with itself!");
; 3903 : 	if(eTeam != GetID() || iValue == 0)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	mov	edx, DWORD PTR _iValue$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN1@SetNumTurn
	test	edx, edx
	jne	SHORT $LN2@SetNumTurn
$LN1@SetNumTurn:

; 3904 : 		m_aiNumTurnsAtWar[eTeam] = iValue;

	mov	DWORD PTR [ecx+eax*4+468], edx
$LN2@SetNumTurn:

; 3905 : }

	ret	8
?SetNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP	; CvTeam::SetNumTurnsAtWar
_TEXT	ENDS
PUBLIC	?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsAtWar
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC	; CvTeam::ChangeNumTurnsAtWar, COMDAT
; _this$ = ecx

; 3911 : 	SetNumTurnsAtWar(eTeam, GetNumTurnsAtWar(eTeam) + iChange);

	mov	edx, DWORD PTR _eTeam$[esp-4]
	mov	eax, DWORD PTR [ecx+edx*4+468]
	add	eax, DWORD PTR _iChange$[esp-4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN7@ChangeNumT
	test	eax, eax
	jne	SHORT $LN8@ChangeNumT
$LN7@ChangeNumT:
	mov	DWORD PTR [ecx+edx*4+468], eax
$LN8@ChangeNumT:

; 3912 : }

	ret	8
?ChangeNumTurnsAtWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP	; CvTeam::ChangeNumTurnsAtWar
_TEXT	ENDS
PUBLIC	?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetNumTurnsLockedIntoWar
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z PROC ; CvTeam::GetNumTurnsLockedIntoWar, COMDAT
; _this$ = ecx

; 3918 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3919 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3920 : 	return m_aiNumTurnsLockedIntoWar[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+788]

; 3921 : }

	ret	4
?GetNumTurnsLockedIntoWar@CvTeam@@QBEHW4TeamTypes@@@Z ENDP ; CvTeam::GetNumTurnsLockedIntoWar
_TEXT	ENDS
PUBLIC	?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetNumTurnsLockedIntoWar
; Function compile flags: /Ogtpy
;	COMDAT ?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC ; CvTeam::SetNumTurnsLockedIntoWar, COMDAT
; _this$ = ecx

; 3927 : 	CvAssertMsg(eTeam >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3928 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3929 : 	CvAssertMsg(iValue >= 0, "Num turns locked into war should always be 0 or greater. Please show Jon this and send your last 5 autosaves and what changelist # you were playing.");
; 3930 : 	CvAssertMsg(eTeam != GetID() || iValue == 0, "Team is setting locked war turns with itself!");
; 3931 : 	if(eTeam != GetID() || iValue == 0)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	mov	edx, DWORD PTR _iValue$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN1@SetNumTurn@2
	test	edx, edx
	jne	SHORT $LN2@SetNumTurn@2
$LN1@SetNumTurn@2:

; 3932 : 		m_aiNumTurnsLockedIntoWar[eTeam] = iValue;

	mov	DWORD PTR [ecx+eax*4+788], edx
$LN2@SetNumTurn@2:

; 3933 : }

	ret	8
?SetNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP ; CvTeam::SetNumTurnsLockedIntoWar
_TEXT	ENDS
PUBLIC	?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::ChangeNumTurnsLockedIntoWar
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z PROC ; CvTeam::ChangeNumTurnsLockedIntoWar, COMDAT
; _this$ = ecx

; 3939 : 	SetNumTurnsLockedIntoWar(eTeam, GetNumTurnsLockedIntoWar(eTeam) + iChange);

	mov	edx, DWORD PTR _eTeam$[esp-4]
	mov	eax, DWORD PTR [ecx+edx*4+788]
	add	eax, DWORD PTR _iChange$[esp-4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN7@ChangeNumT@2
	test	eax, eax
	jne	SHORT $LN8@ChangeNumT@2
$LN7@ChangeNumT@2:
	mov	DWORD PTR [ecx+edx*4+788], eax
$LN8@ChangeNumT@2:

; 3940 : }

	ret	8
?ChangeNumTurnsLockedIntoWar@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP ; CvTeam::ChangeNumTurnsLockedIntoWar
_TEXT	ENDS
PUBLIC	?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::GetTurnMadePeaceTreatyWithTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z PROC ; CvTeam::GetTurnMadePeaceTreatyWithTeam, COMDAT
; _this$ = ecx

; 3945 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3946 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3947 : 	return m_paiTurnMadePeaceTreatyWithTeam[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+1128]

; 3948 : }

	ret	4
?GetTurnMadePeaceTreatyWithTeam@CvTeam@@QBEHW4TeamTypes@@@Z ENDP ; CvTeam::GetTurnMadePeaceTreatyWithTeam
_TEXT	ENDS
PUBLIC	?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z ; CvTeam::SetTurnMadePeaceTreatyWithTeam
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z PROC ; CvTeam::SetTurnMadePeaceTreatyWithTeam, COMDAT
; _this$ = ecx

; 3954 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3955 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3956 : 	m_paiTurnMadePeaceTreatyWithTeam[eIndex] = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [ecx+edx*4+1128], eax

; 3957 : }

	ret	8
?SetTurnMadePeaceTreatyWithTeam@CvTeam@@QAEXW4TeamTypes@@H@Z ENDP ; CvTeam::SetTurnMadePeaceTreatyWithTeam
_TEXT	ENDS
PUBLIC	?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isPermanentWarPeace
; Function compile flags: /Ogtpy
;	COMDAT ?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::isPermanentWarPeace, COMDAT
; _this$ = ecx

; 3974 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3975 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3976 : 	return m_abPermanentWarPeace[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+2008]

; 3977 : }

	ret	4
?isPermanentWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::isPermanentWarPeace
_TEXT	ENDS
PUBLIC	?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::setPermanentWarPeace
; Function compile flags: /Ogtpy
;	COMDAT ?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::setPermanentWarPeace, COMDAT
; _this$ = ecx

; 3983 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3984 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3985 : 	m_abPermanentWarPeace[eIndex] = bNewValue;

	mov	al, BYTE PTR _bNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	BYTE PTR [edx+ecx+2008], al

; 3986 : }

	ret	8
?setPermanentWarPeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::setPermanentWarPeace
_TEXT	ENDS
PUBLIC	?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::HasEmbassyAtTeam
; Function compile flags: /Ogtpy
;	COMDAT ?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::HasEmbassyAtTeam, COMDAT
; _this$ = ecx

; 4039 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4040 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4041 : 
; 4042 : 	return m_abEmbassy[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+2088]

; 4043 : }

	ret	4
?HasEmbassyAtTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::HasEmbassyAtTeam
_TEXT	ENDS
PUBLIC	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::IsAllowsOpenBordersToTeam, COMDAT
; _this$ = ecx

; 4187 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4188 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4189 : 
; 4190 : 	if(GetLiberatedByTeam() == eIndex && !isAtWar(eIndex))

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	DWORD PTR [ecx+140], eax
	jne	SHORT $LN1@IsAllowsOp
	cmp	BYTE PTR [eax+ecx+1928], 0
	jne	SHORT $LN1@IsAllowsOp

; 4191 : 	{
; 4192 : 		return true;

	mov	al, 1

; 4196 : }

	ret	4
$LN1@IsAllowsOp:

; 4193 : 	}
; 4194 : 
; 4195 : 	return m_abOpenBorders[eIndex];

	mov	al, BYTE PTR [eax+ecx+2168]

; 4196 : }

	ret	4
?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::IsAllowsOpenBordersToTeam
_TEXT	ENDS
PUBLIC	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
EXTRN	?verifyUnitValidPlot@CvMap@@QAEXXZ:PROC		; CvMap::verifyUnitValidPlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::SetAllowsOpenBordersToTeam, COMDAT
; _this$ = ecx

; 4201 : {

	push	esi
	push	edi

; 4202 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4203 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4204 : 
; 4205 : 	if(IsAllowsOpenBordersToTeam(eIndex) != bNewValue)

	mov	edi, DWORD PTR _eIndex$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+140], edi
	jne	SHORT $LN6@SetAllowsO
	cmp	BYTE PTR [edi+esi+1928], 0
	mov	al, 1
	je	SHORT $LN7@SetAllowsO
$LN6@SetAllowsO:
	mov	al, BYTE PTR [edi+esi+2168]
$LN7@SetAllowsO:
	mov	cl, BYTE PTR _bNewValue$[esp+4]
	cmp	al, cl
	je	SHORT $LN2@SetAllowsO

; 4206 : 	{
; 4207 : 		m_abOpenBorders[eIndex] = bNewValue;

	mov	BYTE PTR [edi+esi+2168], cl

; 4208 : 
; 4209 : 		GC.getMap().verifyUnitValidPlot();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot

; 4210 : 
; 4211 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [esi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN1@SetAllowsO
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN2@SetAllowsO
$LN1@SetAllowsO:

; 4212 : 		{
; 4213 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	pop	edi
	pop	esi
	mov	DWORD PTR _bNewValue$[esp-4], 1
	mov	DWORD PTR _eIndex$[esp-4], 12		; 0000000cH
	mov	edx, DWORD PTR [eax+260]
	jmp	edx
$LN2@SetAllowsO:
	pop	edi
	pop	esi

; 4214 : 		}
; 4215 : 	}
; 4216 : }

	ret	8
?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::SetAllowsOpenBordersToTeam
_TEXT	ENDS
PUBLIC	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::IsHasDefensivePact, COMDAT
; _this$ = ecx

; 4222 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4223 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4224 : 	return m_abDefensivePact[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+2248]

; 4225 : }

	ret	4
?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::IsHasDefensivePact
_TEXT	ENDS
PUBLIC	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::IsHasResearchAgreement, COMDAT
; _this$ = ecx

; 4328 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4329 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4330 : 	return m_abResearchAgreement[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+2328]

; 4331 : }

	ret	4
?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::IsHasResearchAgreement
_TEXT	ENDS
PUBLIC	?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasTradeAgreement
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::IsHasTradeAgreement, COMDAT
; _this$ = ecx

; 4364 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4365 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4366 : 	return m_abTradeAgreement[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+2408]

; 4367 : }

	ret	4
?IsHasTradeAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::IsHasTradeAgreement
_TEXT	ENDS
PUBLIC	?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CancelResearchAgreement
; Function compile flags: /Ogtpy
;	COMDAT ?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z PROC ; CvTeam::CancelResearchAgreement, COMDAT
; _this$ = ecx

; 4372 : 	if (IsHasResearchAgreement(eIndex))

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	BYTE PTR [eax+ecx+2328], 0
	je	SHORT $LN1@CancelRese

; 4373 : 	{
; 4374 : 		m_abResearchAgreement[eIndex] = false;

	mov	BYTE PTR [eax+ecx+2328], 0
$LN1@CancelRese:

; 4375 : 	}
; 4376 : }

	ret	4
?CancelResearchAgreement@CvTeam@@QAEXW4TeamTypes@@@Z ENDP ; CvTeam::CancelResearchAgreement
_TEXT	ENDS
PUBLIC	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isForcePeace
; Function compile flags: /Ogtpy
;	COMDAT ?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z PROC		; CvTeam::isForcePeace, COMDAT
; _this$ = ecx

; 4404 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4405 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4406 : 	return m_abForcePeace[eIndex];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [eax+ecx+2488]

; 4407 : }

	ret	4
?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP		; CvTeam::isForcePeace
_TEXT	ENDS
PUBLIC	?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::setForcePeace
; Function compile flags: /Ogtpy
;	COMDAT ?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC	; CvTeam::setForcePeace, COMDAT
; _this$ = ecx

; 4413 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4414 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4415 : 	m_abForcePeace[eIndex] = bNewValue;

	mov	al, BYTE PTR _bNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	BYTE PTR [edx+ecx+2488], al

; 4416 : }

	ret	8
?setForcePeace@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::setForcePeace
_TEXT	ENDS
PUBLIC	?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z ; CvTeam::getProjectArtType
; Function compile flags: /Ogtpy
;	COMDAT ?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_number$ = 12						; size = 4
?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z PROC	; CvTeam::getProjectArtType, COMDAT
; _this$ = ecx

; 4598 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4599 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4600 : 	CvAssertMsg(number >= 0, "number is expected to be non-negative (invalid Index)");
; 4601 : 	CvAssertMsg(number < getProjectCount(eIndex), "number is expected to be within maximum bounds (invalid Index)");
; 4602 : 	return m_pavProjectArtTypes[eIndex][number];

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	ecx, DWORD PTR [ecx+2960]
	shl	eax, 4
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR _number$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 4603 : }

	ret	8
?getProjectArtType@CvTeam@@QBEHW4ProjectTypes@@H@Z ENDP	; CvTeam::getProjectArtType
_TEXT	ENDS
PUBLIC	?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z ; CvTeam::setProjectArtType
; Function compile flags: /Ogtpy
;	COMDAT ?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_number$ = 12						; size = 4
_value$ = 16						; size = 4
?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z PROC ; CvTeam::setProjectArtType, COMDAT
; _this$ = ecx

; 4608 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4609 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4610 : 	CvAssertMsg(number >= 0, "number is expected to be non-negative (invalid Index)");
; 4611 : 	CvAssertMsg(number < getProjectCount(eIndex), "number is expected to be within maximum bounds (invalid Index)");
; 4612 : 	m_pavProjectArtTypes[eIndex][number] = value;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	ecx, DWORD PTR [ecx+2960]
	shl	eax, 4
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR _value$[esp-4]
	mov	ecx, DWORD PTR _number$[esp-4]
	mov	DWORD PTR [edx+ecx*4], eax

; 4613 : }

	ret	12					; 0000000cH
?setProjectArtType@CvTeam@@QAEXW4ProjectTypes@@HH@Z ENDP ; CvTeam::setProjectArtType
_TEXT	ENDS
PUBLIC	?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z ; CvTeam::isProjectAndArtMaxedOut
; Function compile flags: /Ogtpy
;	COMDAT ?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z PROC ; CvTeam::isProjectAndArtMaxedOut, COMDAT
; _this$ = ecx

; 4633 : {

	push	ebx
	push	esi

; 4634 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4635 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4636 : 
; 4637 : 	if(getProjectCount(eIndex) >= GC.getProjectInfo(eIndex)->GetMaxTeamInstances())

	mov	esi, DWORD PTR _eIndex$[esp+4]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+2916]
	mov	ebx, DWORD PTR [eax+esi*4]
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxTeamInstances
	cmp	ebx, eax
	jl	SHORT $LN6@isProjectA

; 4638 : 	{
; 4639 : 		int count = getProjectCount(eIndex);

	mov	ecx, DWORD PTR [edi+2916]
	mov	ecx, DWORD PTR [ecx+esi*4]

; 4640 : 		for(int i=0; i<count; i++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN3@isProjectA
	mov	edx, DWORD PTR [edi+2960]
	shl	esi, 4
	mov	esi, DWORD PTR [edx+esi+4]
$LL5@isProjectA:

; 4641 : 		{
; 4642 : 			if(getProjectArtType(eIndex, i) == -1) //undefined

	cmp	DWORD PTR [esi], -1
	je	SHORT $LN6@isProjectA
	inc	eax
	add	esi, 4
	cmp	eax, ecx
	jl	SHORT $LL5@isProjectA
$LN3@isProjectA:
	pop	edi
	pop	esi

; 4643 : 				return false;
; 4644 : 		}
; 4645 : 
; 4646 : 		return true;

	mov	al, 1
	pop	ebx

; 4651 : 	}
; 4652 : }

	ret	4
$LN6@isProjectA:
	pop	edi
	pop	esi

; 4647 : 	}
; 4648 : 	else
; 4649 : 	{
; 4650 : 		return false;

	xor	al, al
	pop	ebx

; 4651 : 	}
; 4652 : }

	ret	4
?isProjectAndArtMaxedOut@CvTeam@@QBE_NW4ProjectTypes@@@Z ENDP ; CvTeam::isProjectAndArtMaxedOut
_TEXT	ENDS
PUBLIC	?finalizeProjectArtTypes@CvTeam@@QAEXXZ		; CvTeam::finalizeProjectArtTypes
EXTRN	?getNumProjectInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumProjectInfos
; Function compile flags: /Ogtpy
;	COMDAT ?finalizeProjectArtTypes@CvTeam@@QAEXXZ
_TEXT	SEGMENT
?finalizeProjectArtTypes@CvTeam@@QAEXXZ PROC		; CvTeam::finalizeProjectArtTypes, COMDAT
; _this$ = ecx

; 4656 : {

	push	esi
	mov	esi, ecx
	push	edi

; 4657 : 	//loop through each project and fill in default art values
; 4658 : #ifdef AUI_WARNING_FIXES
; 4659 : 	for (uint i = 0; i<GC.getNumProjectInfos(); i++)
; 4660 : #else
; 4661 : 	for(int i=0; i<GC.getNumProjectInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	test	eax, eax
	jle	SHORT $LN5@finalizePr
	push	ebx
	push	ebp
	npad	10
$LL26@finalizePr:

; 4662 : #endif
; 4663 : 	{
; 4664 : 		ProjectTypes projectType = (ProjectTypes) i;
; 4665 : 		int projectCount = getProjectCount(projectType);

	mov	eax, DWORD PTR [esi+2916]
	mov	ebx, DWORD PTR [eax+edi*4]

; 4666 : 		for(int j=0; j<projectCount; j++)

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN6@finalizePr
	mov	edx, edi
	shl	edx, 4
	npad	12
$LL4@finalizePr:
	mov	eax, DWORD PTR [esi+2960]
	mov	eax, DWORD PTR [eax+edx+4]

; 4667 : 		{
; 4668 : 			int projectArtType = getProjectArtType(projectType, j);
; 4669 : 			if(projectArtType == -1) //undefined

	cmp	DWORD PTR [eax+ecx*4], -1
	lea	eax, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN3@finalizePr

; 4670 : 			{
; 4671 : 				int defaultArtType = getProjectDefaultArtType(projectType);
; 4672 : 				setProjectArtType(projectType, j, defaultArtType);

	mov	ebp, DWORD PTR [esi+2920]
	mov	ebp, DWORD PTR [ebp+edi*4]
	mov	DWORD PTR [eax], ebp
$LN3@finalizePr:
	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LL4@finalizePr
$LN6@finalizePr:

; 4657 : 	//loop through each project and fill in default art values
; 4658 : #ifdef AUI_WARNING_FIXES
; 4659 : 	for (uint i = 0; i<GC.getNumProjectInfos(); i++)
; 4660 : #else
; 4661 : 	for(int i=0; i<GC.getNumProjectInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	edi, eax
	jl	SHORT $LL26@finalizePr
	pop	ebp
	pop	ebx
$LN5@finalizePr:
	pop	edi
	pop	esi

; 4673 : 			}
; 4674 : 		}
; 4675 : 	}
; 4676 : }

	ret	0
?finalizeProjectArtTypes@CvTeam@@QAEXXZ ENDP		; CvTeam::finalizeProjectArtTypes
_TEXT	ENDS
PUBLIC	?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z	; CvTeam::getVictoryDelay
EXTRN	?victoryDelay@CvGame@@QBEHW4VictoryTypes@@@Z:PROC ; CvGame::victoryDelay
EXTRN	?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetVictoryDelayPercent
EXTRN	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z:PROC ; CvProjectEntry::GetVictoryThreshold
EXTRN	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z:PROC ; CvProjectEntry::GetVictoryMinThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z
_TEXT	SEGMENT
_iExtraDelayPercent$ = -12				; size = 4
_iProject$226512 = -8					; size = 4
_this$ = -4						; size = 4
_eVictory$ = 8						; size = 4
?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z PROC	; CvTeam::getVictoryDelay, COMDAT
; _this$ = ecx

; 5140 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+24], ecx

; 5141 : 	int iExtraDelayPercent = 0;

	xor	ebp, ebp
	push	edi

; 5142 : #ifdef AUI_WARNING_FIXES
; 5143 : 	for (uint iProject = 0; iProject < GC.getNumProjectInfos(); ++iProject)
; 5144 : #else
; 5145 : 	for(int iProject = 0; iProject < GC.getNumProjectInfos(); ++iProject)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iExtraDelayPercent$[esp+28], ebp
	mov	DWORD PTR _iProject$226512[esp+28], ebp
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	ebx, DWORD PTR _eVictory$[esp+24]
	test	eax, eax
	jle	$LN3@getVictory
	npad	5
$LL15@getVictory:

; 5146 : #endif
; 5147 : 	{
; 5148 : 		CvProjectEntry* pkProject = GC.getProjectInfo((ProjectTypes)iProject);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	esi, eax

; 5149 : 		int iCount = getProjectCount((ProjectTypes)iProject);

	mov	eax, DWORD PTR _this$[esp+28]
	mov	ecx, DWORD PTR [eax+2916]
	mov	edi, DWORD PTR [ecx+ebp*4]

; 5150 : 
; 5151 : 		if(iCount < pkProject->GetVictoryMinThreshold(eVictory))

	push	ebx
	mov	ecx, esi
	call	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryMinThreshold
	cmp	edi, eax
	jl	$LN13@getVictory

; 5155 : 		}
; 5156 : 
; 5157 : 		if(iCount < pkProject->GetVictoryThreshold(eVictory))

	push	ebx
	mov	ecx, esi
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	cmp	edi, eax
	jge	SHORT $LN4@getVictory

; 5158 : 		{
; 5159 : 			iExtraDelayPercent += ((pkProject->GetVictoryThreshold(eVictory)  - iCount) * pkProject->GetVictoryDelayPercent()) / pkProject->GetVictoryThreshold(eVictory);

	push	ebx
	mov	ecx, esi
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	mov	ebp, eax
	mov	ecx, esi
	sub	ebp, edi
	call	?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetVictoryDelayPercent
	mov	edi, eax
	push	ebx
	imul	edi, ebp
	mov	ecx, esi
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	mov	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	ebp, DWORD PTR _iProject$226512[esp+28]
	add	DWORD PTR _iExtraDelayPercent$[esp+28], eax
$LN4@getVictory:
	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iProject$226512[esp+28], ebp
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	ebp, eax
	jl	SHORT $LL15@getVictory
$LN3@getVictory:

; 5160 : 		}
; 5161 : 	}
; 5162 : 
; 5163 : 	return (GC.getGame().victoryDelay(eVictory)  * (100 + iExtraDelayPercent)) / 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	call	?victoryDelay@CvGame@@QBEHW4VictoryTypes@@@Z ; CvGame::victoryDelay
	mov	edx, DWORD PTR _iExtraDelayPercent$[esp+28]
	mov	ecx, eax
	add	edx, 100				; 00000064H
	imul	ecx, edx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	esi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebp
	add	eax, edx
	pop	ebx

; 5164 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN13@getVictory:
	pop	edi
	pop	esi
	pop	ebp

; 5152 : 		{
; 5153 : 			CvAssert(false);
; 5154 : 			return -1;

	or	eax, -1
	pop	ebx

; 5164 : }

	add	esp, 12					; 0000000cH
	ret	4
?getVictoryDelay@CvTeam@@QBEHW4VictoryTypes@@@Z ENDP	; CvTeam::getVictoryDelay
_TEXT	ENDS
PUBLIC	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ; CvTeam::IsResourceObsolete
EXTRN	?getAIStopTradingEra@CvResourceInfo@@QBEHXZ:PROC ; CvResourceInfo::getAIStopTradingEra
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z PROC ; CvTeam::IsResourceObsolete, COMDAT
; _this$ = ecx

; 7004 : 	CvResourceInfo* pResource = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	esi, eax

; 7005 : 
; 7006 : 	if(pResource == NULL)

	test	esi, esi
	jne	SHORT $LN4@IsResource
$LN9@IsResource:
	pop	edi

; 7007 : 		return false;

	xor	al, al
	pop	esi

; 7021 : 		return false;
; 7022 : 
; 7023 : 	return true;
; 7024 : }

	ret	4
$LN4@IsResource:

; 7008 : 
; 7009 : 	// If this is a luxury or bonus resource it doesn't go obsolete
; 7010 : 	if(pResource->getResourceUsage() != RESOURCEUSAGE_STRATEGIC)

	mov	ecx, esi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1

; 7011 : 		return false;

	jne	SHORT $LN9@IsResource

; 7012 : 
; 7013 : 	EraTypes eObsoleteEra = (EraTypes) pResource->getAIStopTradingEra();

	mov	ecx, esi
	call	?getAIStopTradingEra@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getAIStopTradingEra

; 7014 : 
; 7015 : 	// AI will always trade for this
; 7016 : 	if(eObsoleteEra == NO_ERA)

	cmp	eax, -1

; 7017 : 		return false;

	je	SHORT $LN9@IsResource

; 7018 : 
; 7019 : 	// Not obsolete yet
; 7020 : 	if(GetCurrentEra() < eObsoleteEra)

	cmp	DWORD PTR [edi+136], eax
	pop	edi
	setge	al
	pop	esi

; 7021 : 		return false;
; 7022 : 
; 7023 : 	return true;
; 7024 : }

	ret	4
?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ENDP ; CvTeam::IsResourceObsolete
_TEXT	ENDS
PUBLIC	?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::PushIgnoreWarning
; Function compile flags: /Ogtpy
;	COMDAT ?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::PushIgnoreWarning, COMDAT
; _this$ = ecx

; 7364 : 	CvAssertMsg(eTeam != NO_TEAM, "PushIgnoreWarning got NO_TEAM passed to it");
; 7365 : 	if (eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	je	SHORT $LN2@PushIgnore

; 7366 : 	{
; 7367 : 		return;
; 7368 : 	}
; 7369 : 
; 7370 : 	m_aiIgnoreWarningCount[eTeam] += 1;

	inc	DWORD PTR [ecx+eax*4+1448]
$LN2@PushIgnore:

; 7371 : }

	ret	4
?PushIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::PushIgnoreWarning
_TEXT	ENDS
PUBLIC	?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::PopIgnoreWarning
; Function compile flags: /Ogtpy
;	COMDAT ?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::PopIgnoreWarning, COMDAT
; _this$ = ecx

; 7376 : 	CvAssertMsg(eTeam != NO_TEAM, "PopIgnoreWarning got NO_TEAM passed to it");
; 7377 : 	if (eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	je	SHORT $LN1@PopIgnoreW

; 7378 : 	{
; 7379 : 		return;
; 7380 : 	}
; 7381 : 
; 7382 : 	CvAssertMsg(m_aiIgnoreWarningCount[eTeam] > 0, "Trying to pop when there's nothing to be popped");
; 7383 : 	if (m_aiIgnoreWarningCount[eTeam] > 0)

	cmp	DWORD PTR [ecx+eax*4+1448], 0
	jle	SHORT $LN1@PopIgnoreW

; 7384 : 	{
; 7385 : 		m_aiIgnoreWarningCount[eTeam] -= 1;

	dec	DWORD PTR [ecx+eax*4+1448]
$LN1@PopIgnoreW:

; 7386 : 	}
; 7387 : }

	ret	4
?PopIgnoreWarning@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::PopIgnoreWarning
_TEXT	ENDS
PUBLIC	?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z ; CvTeam::GetIgnoreWarningCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z PROC	; CvTeam::GetIgnoreWarningCount, COMDAT
; _this$ = ecx

; 7392 : 	CvAssertMsg(eTeam != NO_TEAM, "GetIgnoreWarningCount got NO_TEAM passed to it");
; 7393 : 	if (eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@GetIgnoreW

; 7394 : 	{
; 7395 : 		return -1;

	or	eax, eax

; 7399 : }

	ret	4
$LN1@GetIgnoreW:

; 7396 : 	}
; 7397 : 
; 7398 : 	return m_aiIgnoreWarningCount[eTeam];

	mov	eax, DWORD PTR [ecx+eax*4+1448]

; 7399 : }

	ret	4
?GetIgnoreWarningCount@CvTeam@@QAEHW4TeamTypes@@@Z ENDP	; CvTeam::GetIgnoreWarningCount
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 63			; 0000003fH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::FStaticVector<enum PlayerTypes,63,1,297,0>
_TEXT	ENDS
PUBLIC	?empty@?$BaseVector@W4PlayerTypes@@$00@@QBE_NXZ	; BaseVector<enum PlayerTypes,1>::empty
; Function compile flags: /Ogtpy
;	COMDAT ?empty@?$BaseVector@W4PlayerTypes@@$00@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$BaseVector@W4PlayerTypes@@$00@@QBE_NXZ PROC	; BaseVector<enum PlayerTypes,1>::empty, COMDAT
; _this$ = ecx

; 166  : 		return size() == 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+4], eax
	sete	al

; 167  : 	};

	ret	0
?empty@?$BaseVector@W4PlayerTypes@@$00@@QBE_NXZ ENDP	; BaseVector<enum PlayerTypes,1>::empty
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z ; CvWeightedVector<enum TeamTypes,63,1>::GetWeight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 8

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[esp+8], edx

; 75   : 	}

	add	esp, 8
	ret	4
?GetWeight@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QBEHI@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::GetWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ ; CvWeightedVector<enum TeamTypes,63,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEHXZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::size
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEAAW4ResourceTypes@@XZ ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEAAW4ResourceTypes@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEAAW4ResourceTypes@@XZ PROC ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEAAW4ResourceTypes@@XZ ENDP ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ; std::vector<int,std::allocator<int> >::empty
; Function compile flags: /Ogtpy
;	COMDAT ?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ PROC	; std::vector<int,std::allocator<int> >::empty, COMDAT
; _this$ = ecx

; 736  : 		return (size() == 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	and	eax, -4					; fffffffcH
	neg	eax
	sbb	eax, eax
	inc	eax

; 737  : 		}

	ret	0
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::vector<int,std::allocator<int> >::empty
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z PROC ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE@V?$allocator@W4ResourceTypes@@@1@@Z ENDP ; std::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_val<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXPAW4PlayerTypes@@I@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 63			; 0000003fH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
_TEXT	ENDS
PUBLIC	??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z PROC	; fastdelegate::FastDelegate2<int,char const *,int>::operator(), COMDAT
; _this$ = ecx

; 1080 : 	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	eax
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::operator()
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z PROC ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@PAW4ResourceTypes@@@Z ENDP ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z ; std::allocator<enum ResourceTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z PROC ; std::allocator<enum ResourceTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4ResourceTypes@@@std@@QAEPAW4ResourceTypes@@I@Z ENDP ; std::allocator<enum ResourceTypes>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+=
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc, COMDAT
; _this$ = ecx

; 97   : 	{

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 98   : 		unsigned int nArrayBytes = sizeof(TYPE*) * (pData->nX + 1);

	mov	edi, DWORD PTR _pData$[esp+16]

; 99   : 		unsigned int nDataBytes = sizeof(TYPE) * pData->nX * ( pData->nY + 1 );

	mov	esi, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	inc	esi
	imul	esi, eax
	add	esi, esi
	lea	ebp, DWORD PTR [eax*4+4]
	add	esi, esi

; 100  : 		void* pRet = BASE::Alloc( nBytes + nDataBytes + nArrayBytes, pData+1 );

	lea	ebx, DWORD PTR [esi+ebp]
	add	ebx, DWORD PTR _nBytes$[esp+16]
	mov	DWORD PTR _this$[esp+20], ecx
	push	ebx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _this$[esp+24]
	mov	DWORD PTR [ecx], eax

; 101  : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet );
; 102  : 
; 103  : 		unsigned int iDataAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart -= nDataBytes) % sizeof(TYPE);

	sub	eax, esi
	add	eax, ebx
	mov	edx, eax
	and	edx, 3

; 104  : 		TYPE* pFirstElement = (TYPE*)( pLocMemStart + iDataAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx

; 105  : 
; 106  : 		unsigned int iArrayAlignmentFix = sizeof(TYPE*) - reinterpret_cast< unsigned int >(pLocMemStart -= nArrayBytes) % sizeof(TYPE*);

	sub	eax, ebp
	mov	edx, eax
	and	edx, 3

; 107  : 		TYPE** ppArray = (*static_cast< TYPE*** >(pData->pOut)) = (TYPE**)( pLocMemStart + iArrayAlignmentFix );

	mov	esi, eax
	sub	esi, edx
	mov	edx, DWORD PTR [edi]
	add	esi, 4
	mov	DWORD PTR [edx], esi
	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edx]

; 108  : 
; 109  : 		for( unsigned int i = 0; i < pData->nX; ++i )

	xor	edx, edx
	add	esp, 4
	add	ecx, 4
	cmp	DWORD PTR [edi+4], edx
	jbe	SHORT $LN1@Alloc@3
$LL3@Alloc@3:

; 110  : 		{
; 111  : 			*ppArray = pFirstElement + i * pData->nY;

	mov	ebx, DWORD PTR [edi+8]
	imul	ebx, edx
	lea	ebx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [esi], ebx
	inc	edx

; 112  : 			++ppArray;

	add	esi, 4
	cmp	edx, DWORD PTR [edi+4]
	jb	SHORT $LL3@Alloc@3
$LN1@Alloc@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 113  : 		}
; 114  : 
; 115  : 		return static_cast< void* >( pLocMemStart );
; 116  : 	}

	pop	ecx
	ret	8
?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T232969 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 539  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 540  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T232969[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 541  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 542  : 
; 543  : 	size_t bytes = 0;
; 544  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 545  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 546  : 	str.assign(szComposedString, bytes);
; 547  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T232969[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 548  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	mov	eax, DWORD PTR $T232969[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T232969[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T232992 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 526  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 527  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T232992[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 528  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 529  : 
; 530  : 	size_t bytes = 0;
; 531  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 532  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 533  : 	str.assign(szComposedString, bytes);
; 534  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T232992[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 535  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	mov	eax, DWORD PTR $T232992[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@3
	and	DWORD PTR $T232992[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$0
__ehfuncinfo$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T233012 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z PROC	; GetLocalizedText<int,int>, COMDAT

; 539  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 540  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T233012[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 541  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 542  : 
; 543  : 	size_t bytes = 0;
; 544  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 545  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 546  : 	str.assign(szComposedString, bytes);
; 547  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T233012[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 548  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z$1:
	mov	eax, DWORD PTR $T233012[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@4
	and	DWORD PTR $T233012[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@4:
	ret	0
__ehhandler$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ENDP	; GetLocalizedText<int,int>
PUBLIC	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z	; GetLocalizedText<int>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$0
__ehfuncinfo$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T233035 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z PROC	; GetLocalizedText<int>, COMDAT

; 526  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 527  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T233035[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 528  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 529  : 
; 530  : 	size_t bytes = 0;
; 531  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 532  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 533  : 	str.assign(szComposedString, bytes);
; 534  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T233035[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 535  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z$1:
	mov	eax, DWORD PTR $T233035[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@5
	and	DWORD PTR $T233035[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@5:
	ret	0
__ehhandler$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ENDP	; GetLocalizedText<int>
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@2
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@2:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@2

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@2:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$229052 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$229055 = -8					; size = 4
_tValue$229060 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$229052[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$229055[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$229055[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$229052[esp+32], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$229060[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z PROC ; operator>><bool>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 518  : 	ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@3
	push	ebp
	mov	ebp, DWORD PTR _loadFrom$[esp+12]
$LL3@operator@3:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@3

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
$LN14@operator@3:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ENDP ; operator>><bool>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$229077 = -7					; size = 1
_bValid$229074 = -6					; size = 1
_tValue$229082 = -5					; size = 1
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	sub	esp, 8
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiNumEntries$[esp+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+16], ebx
	jbe	SHORT $LN5@ReadHashed@2
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+16]
	push	esi
$LL7@ReadHashed@2:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$229074[esp+24]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@2

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$229077[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@2

; 262  : 				paArray[iType] = tValue;

	mov	al, BYTE PTR _tValue$229077[esp+24]
	mov	ecx, DWORD PTR _paArray$[esp+20]
	mov	BYTE PTR [esi+ecx], al

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@2
$LN4@ReadHashed@2:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$229074[esp+24], 0
	jne	SHORT $LN6@ReadHashed@2

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$229082[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN6@ReadHashed@2:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+24]
	jb	SHORT $LL7@ReadHashed@2
	pop	esi
	pop	ebp
$LN5@ReadHashed@2:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 8
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z PROC ; operator<<<int>, COMDAT

; 529  : 	int i = 0;
; 530  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 531  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 532  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@4
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@4:

; 533  : 	{
; 534  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@4

; 535  : 	}
; 536  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 537  : }

	ret	0
$LN14@operator@4:

; 535  : 	}
; 536  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 537  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VoteSourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VoteSourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	edi
$LN2@WriteHashe:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>
_TEXT	ENDS
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 529  : 	int i = 0;
; 530  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 531  : 	const ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 532  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@5
	push	ebp
	mov	ebp, DWORD PTR _saveTo$[esp+12]
$LL3@operator@5:

; 533  : 	{
; 534  : 		saveTo << values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@5

; 535  : 	}
; 536  : 	return saveTo;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 537  : }

	ret	0
$LN14@operator@5:

; 535  : 	}
; 536  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 537  : }

	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VictoryTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>, COMDAT

; 559  : {

	push	esi
	push	edi

; 560  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@2
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@2:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VictoryTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN3@WriteHashe@2:
	inc	esi
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@2
	pop	ebx
$LN2@WriteHashe@2:
	pop	edi
	pop	esi

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4SmallAwardTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>, COMDAT

; 559  : {

	push	esi
	push	edi

; 560  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@3
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@3:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4SmallAwardTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@3

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN3@WriteHashe@3:
	inc	esi
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@3
	pop	ebx
$LN2@WriteHashe@3:
	pop	edi
	pop	esi

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4RouteTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@4
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@4:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4RouteTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@4

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@4:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@4
	pop	edi
$LN2@WriteHashe@4:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4BuildTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@5
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@5:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4BuildTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@5

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@5:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@5
	pop	edi
$LN2@WriteHashe@5:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ProjectTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@6
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@6:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ProjectTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@6

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@6:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@6
	pop	edi
$LN2@WriteHashe@6:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@7
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@7:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@7

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@7:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@7
	pop	edi
$LN2@WriteHashe@7:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@8
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@8:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4VictoryTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@8

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@8:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@8
	pop	edi
$LN2@WriteHashe@8:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>
_TEXT	ENDS
PUBLIC	??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
$T233229 = 12						; size = 4
_aiArray$ = 12						; size = 4
??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z PROC ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>, COMDAT

; 661  : {

	push	ebx

; 662  : 	kStream << aiArray.size();

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	mov	esi, DWORD PTR _aiArray$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T233229[esp+8]
	sar	eax, 2
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T233229[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 663  : 
; 664  : 	for(uint iI = 0; iI < aiArray.size(); iI++)

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
	sar	edx, 2
	xor	edi, edi
	test	edx, edx
	jbe	SHORT $LN1@WriteHashe@9
$LL3@WriteHashe@9:

; 665  : 	{
; 666  : 		WriteHashed(kStream, aiArray[iI]);

	mov	eax, DWORD PTR [eax+edi*4]
	push	eax
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	inc	edi
	sar	ecx, 2
	add	esp, 8
	cmp	edi, ecx
	jb	SHORT $LL3@WriteHashe@9
$LN1@WriteHashe@9:
	pop	edi
	pop	esi
	pop	ebx

; 667  : 	}
; 668  : }

	ret	0
??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum ResourceTypes *,enum ResourceTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z PROC ; stdext::unchecked_copy<enum ResourceTypes *,enum ResourceTypes *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z ENDP ; stdext::unchecked_copy<enum ResourceTypes *,enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	??$fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z ; std::fill<enum ResourceTypes *,enum ResourceTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z PROC ; std::fill<enum ResourceTypes *,enum ResourceTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z ENDP ; std::fill<enum ResourceTypes *,enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4ResourceTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum ResourceTypes *,enum ResourceTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z ; std::allocator<enum ResourceTypes>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z PROC ; std::allocator<enum ResourceTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@ABW43@@Z ENDP ; std::allocator<enum ResourceTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z ; std::allocator<enum ResourceTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z PROC ; std::allocator<enum ResourceTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4ResourceTypes@@@std@@QAEXPAW4ResourceTypes@@@Z ENDP ; std::allocator<enum ResourceTypes>::destroy
_TEXT	ENDS
PUBLIC	??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>, COMDAT
; _this$ = ecx

; 673  : 		m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
; 674  : 			::Convert(pthis, function_to_bind, m_pFunction);

	mov	eax, DWORD PTR _function_to_bind$[esp-4]
	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx

; 675  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 676  : 		m_pStaticFunction = 0;
; 677  : #endif
; 678  : 	}

	ret	8
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::iter_swap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL8@unchecked_@2:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL6@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@2:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1096 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1097 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?isEverAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isEverAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isEverAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isEverAlive@CvPlayer@@QBE_NXZ PROC			; CvPlayer::isEverAlive, COMDAT
; _this$ = ecx

; 1101 : 		return m_bEverAlive;

	mov	al, BYTE PTR [ecx+2268]

; 1102 : 	}

	ret	0
?isEverAlive@CvPlayer@@QBE_NXZ ENDP			; CvPlayer::isEverAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1172 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1173 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1177 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1178 : 	}

	ret	0

; 1177 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1178 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z PROC		; CvMap::plotUnchecked, COMDAT
; _this$ = ecx

; 292  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 293  : 	}

	ret	8
?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z ENDP		; CvMap::plotUnchecked
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 239  : 	// convert the start coord to hex-space coordinates
; 240  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 241  : 
; 242  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 243  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 244  : 
; 245  : 	// convert from hex-space coordinates to the storage array
; 246  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 259  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 260  : 	// I'm assuming iDX and iDY are in hex-space
; 261  : 	if (hexDistance(iDX, iDY) > iRange)
; 262  : #else
; 263  : 	int hexRange;
; 264  : 
; 265  : 	// I'm assuming iDX and iDY are in hex-space
; 266  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 267  : 	{
; 268  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 269  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 270  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 271  : 	}
; 272  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 273  : 	{
; 274  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 275  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 276  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 277  : 	}
; 278  : 
; 279  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 280  : #endif
; 281  : 	{
; 282  : 		return NULL;

	xor	eax, eax
	pop	esi

; 286  : }

	ret	0
$LN1@plotXYWith:

; 283  : 	}
; 284  : 
; 285  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 286  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >
_TEXT	ENDS
PUBLIC	?updateYield@CvTeam@@QAEXXZ			; CvTeam::updateYield
EXTRN	?updateYield@CvPlayer@@QAEXXZ:PROC		; CvPlayer::updateYield
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?updateYield@CvTeam@@QAEXXZ
_TEXT	SEGMENT
?updateYield@CvTeam@@QAEXXZ PROC			; CvTeam::updateYield, COMDAT
; _this$ = ecx

; 1024 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1025 : 	int iI;
; 1026 : 
; 1027 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	esi, esi
	npad	10
$LL5@updateYiel:

; 1028 : 	{
; 1029 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN4@updateYiel

; 1030 : 		{
; 1031 : 			if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN20@updateYiel
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN21@updateYiel
$LN20@updateYiel:
	or	eax, -1
$LN21@updateYiel:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN4@updateYiel

; 1032 : 			{
; 1033 : 				GET_PLAYER((PlayerTypes)iI).updateYield();

	call	?updateYield@CvPlayer@@QAEXXZ		; CvPlayer::updateYield
$LN4@updateYiel:

; 1025 : 	int iI;
; 1026 : 
; 1027 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@updateYiel
	pop	edi
	pop	esi

; 1034 : 			}
; 1035 : 		}
; 1036 : 	}
; 1037 : }

	ret	0
?updateYield@CvTeam@@QAEXXZ ENDP			; CvTeam::updateYield
_TEXT	ENDS
PUBLIC	?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::canChangeWarPeace
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
; Function compile flags: /Ogtpy
;	COMDAT ?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::canChangeWarPeace, COMDAT
; _this$ = ecx

; 1041 : {

	push	esi

; 1042 : 	if(eTeam == NO_TEAM) return false;

	mov	esi, DWORD PTR _eTeam$[esp]
	push	edi
	mov	edi, ecx
	cmp	esi, -1
	je	SHORT $LN1@canChangeW

; 1043 : 
; 1044 : 	if(GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	6
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 1045 : 	{
; 1046 : 		return false;

	jne	SHORT $LN1@canChangeW

; 1047 : 	}
; 1048 : 
; 1049 : 	if(GC.getGame().isOption(GAMEOPTION_ALWAYS_PEACE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	4
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 1050 : 	{
; 1051 : 		return false;

	jne	SHORT $LN1@canChangeW

; 1052 : 	}
; 1053 : 
; 1054 : 	if(GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	3
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 1055 : 	{
; 1056 : 		return false;

	jne	SHORT $LN1@canChangeW

; 1057 : 	}
; 1058 : 
; 1059 : 	if(eTeam == GetID())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, eax

; 1060 : 	{
; 1061 : 		return false;

	je	SHORT $LN1@canChangeW

; 1062 : 	}
; 1063 : 
; 1064 : 	if(isPermanentWarPeace(eTeam) || GET_TEAM(eTeam).isPermanentWarPeace(GetID()))

	cmp	BYTE PTR [esi+edi+2008], 0
	jne	SHORT $LN1@canChangeW
	imul	esi, 2984				; 00000ba8H
	add	esi, eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [esi+eax+2008], 0
	jne	SHORT $LN1@canChangeW
	pop	edi

; 1067 : 	}
; 1068 : 
; 1069 : 	return true;

	mov	al, 1
	pop	esi

; 1070 : }

	ret	4
$LN1@canChangeW:
	pop	edi

; 1065 : 	{
; 1066 : 		return false;

	xor	al, al
	pop	esi

; 1070 : }

	ret	4
?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::canChangeWarPeace
_TEXT	ENDS
PUBLIC	?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::makeHasMet
PUBLIC	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z		; CvTeam::meet
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@I@Z:PROC		; CvLuaArgsHandle::CvLuaArgsHandle
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
__ehfuncinfo$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_bResult$224417 = 8					; size = 1
_eTeam$ = 8						; size = 4
_bSuppressMessages$ = 12				; size = 1
_args$224416 = 12					; size = 4
?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::meet, COMDAT
; _this$ = ecx

; 1878 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi

; 1879 : 	if(!isHasMet(eTeam))

	mov	edi, DWORD PTR _eTeam$[esp+20]
	mov	esi, ecx
	mov	al, BYTE PTR [edi+esi+1848]
	test	al, al
	jne	$LN1@meet

; 1880 : 	{
; 1881 : 		makeHasMet(eTeam, bSuppressMessages);

	mov	ebx, DWORD PTR _bSuppressMessages$[esp+20]
	push	ebx
	push	edi
	call	?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::makeHasMet

; 1882 : 		GET_TEAM(eTeam).makeHasMet(GetID(), bSuppressMessages);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edi
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	push	eax
	call	?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::makeHasMet

; 1883 : 
; 1884 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ebx, eax

; 1885 : 		if(pkScriptSystem)

	test	ebx, ebx
	je	SHORT $LN1@meet

; 1886 : 		{
; 1887 : 			CvLuaArgsHandle args(2);

	push	2
	lea	ecx, DWORD PTR _args$224416[esp+24]
	call	??0CvLuaArgsHandle@@QAE@I@Z		; CvLuaArgsHandle::CvLuaArgsHandle

; 1888 : 			args->Push(eTeam);

	mov	ecx, DWORD PTR _args$224416[esp+20]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	edi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	edx

; 1889 : 			args->Push(GetID());

	mov	ecx, DWORD PTR _args$224416[esp+20]
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	call	edx

; 1890 : 
; 1891 : 			bool bResult;
; 1892 : 			LuaSupport::CallHook(pkScriptSystem, "TeamMeet", args.get(), bResult);

	mov	ecx, DWORD PTR _args$224416[esp+20]
	lea	eax, DWORD PTR _bResult$224417[esp+20]
	push	eax
	push	ecx
	push	OFFSET $SG224418
	push	ebx
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1893 : 		}

	lea	ecx, DWORD PTR _args$224416[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN1@meet:

; 1894 : 	}
; 1895 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$224416[ebp-4]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::meet
PUBLIC	?getPower@CvTeam@@QBEHXZ			; CvTeam::getPower
EXTRN	?getPower@CvPlayer@@QBEHXZ:PROC			; CvPlayer::getPower
; Function compile flags: /Ogtpy
;	COMDAT ?getPower@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getPower@CvTeam@@QBEHXZ PROC				; CvTeam::getPower, COMDAT
; _this$ = ecx

; 1900 : {

	push	ebx
	push	esi
	push	edi

; 1901 : 	int iCount;
; 1902 : 	int iI;
; 1903 : 
; 1904 : 	iCount = 0;

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	7
$LL5@getPower:

; 1905 : 
; 1906 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)
; 1907 : 	{
; 1908 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1909 : 		if(kLoopPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN4@getPower

; 1910 : 		{
; 1911 : 			if(kLoopPlayer.getTeam() == GetID())

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@getPower
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@getPower
$LN18@getPower:
	or	eax, -1
$LN19@getPower:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN4@getPower

; 1912 : 			{
; 1913 : 				iCount += kLoopPlayer.getPower();

	call	?getPower@CvPlayer@@QBEHXZ		; CvPlayer::getPower
	add	edi, eax
$LN4@getPower:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@getPower

; 1914 : 			}
; 1915 : 		}
; 1916 : 	}
; 1917 : 
; 1918 : 	return iCount;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1919 : }

	ret	0
?getPower@CvTeam@@QBEHXZ ENDP				; CvTeam::getPower
_TEXT	ENDS
PUBLIC	?getDefensivePower@CvTeam@@QBEHXZ		; CvTeam::getDefensivePower
; Function compile flags: /Ogtpy
;	COMDAT ?getDefensivePower@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getDefensivePower@CvTeam@@QBEHXZ PROC			; CvTeam::getDefensivePower, COMDAT
; _this$ = ecx

; 1924 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 1925 : 	int iCount;
; 1926 : 	int iI;
; 1927 : 
; 1928 : 	iCount = 0;

	xor	ebp, ebp

; 1929 : 
; 1930 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	4
$LL21@getDefensi:

; 1931 : 	{
; 1932 : 		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 1933 : 		if(kLoopTeam.isAlive())

	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN5@getDefensi

; 1934 : 		{
; 1935 : 			if(GetID() == iI || IsHasDefensivePact((TeamTypes)iI))

	cmp	DWORD PTR [ebx+4], edi
	je	SHORT $LN1@getDefensi
	cmp	BYTE PTR [edi+ebx+2248], 0
	je	SHORT $LN5@getDefensi
$LN1@getDefensi:

; 1936 : 			{
; 1937 : 				iCount += kLoopTeam.getPower();

	call	?getPower@CvTeam@@QBEHXZ		; CvTeam::getPower
	add	ebp, eax
$LN5@getDefensi:
	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL21@getDefensi
	pop	edi
	pop	esi

; 1938 : 			}
; 1939 : 		}
; 1940 : 	}
; 1941 : 
; 1942 : 	return iCount;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 1943 : }

	ret	0
?getDefensivePower@CvTeam@@QBEHXZ ENDP			; CvTeam::getDefensivePower
_TEXT	ENDS
PUBLIC	?getEnemyPower@CvTeam@@QBEHXZ			; CvTeam::getEnemyPower
; Function compile flags: /Ogtpy
;	COMDAT ?getEnemyPower@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getEnemyPower@CvTeam@@QBEHXZ PROC			; CvTeam::getEnemyPower, COMDAT
; _this$ = ecx

; 1948 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 1949 : 	int iCount = 0;

	xor	ebp, ebp

; 1950 : 
; 1951 : 	for(int iI = 0; iI < MAX_CIV_TEAMS; iI++)

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	4
$LL20@getEnemyPo:

; 1952 : 	{
; 1953 : 		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 1954 : 		if(kLoopTeam.isAlive())

	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN4@getEnemyPo

; 1955 : 		{
; 1956 : 			if(GetID() != iI && isAtWar((TeamTypes)iI))

	cmp	DWORD PTR [ebx+4], edi
	je	SHORT $LN4@getEnemyPo
	cmp	BYTE PTR [edi+ebx+1928], 0
	je	SHORT $LN4@getEnemyPo

; 1957 : 			{
; 1958 : 				iCount += kLoopTeam.getPower();

	call	?getPower@CvTeam@@QBEHXZ		; CvTeam::getPower
	add	ebp, eax
$LN4@getEnemyPo:
	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL20@getEnemyPo
	pop	edi
	pop	esi

; 1959 : 			}
; 1960 : 		}
; 1961 : 	}
; 1962 : 
; 1963 : 	return iCount;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 1964 : }

	ret	0
?getEnemyPower@CvTeam@@QBEHXZ ENDP			; CvTeam::getEnemyPower
_TEXT	ENDS
PUBLIC	?getNumNukeUnits@CvTeam@@QBEHXZ			; CvTeam::getNumNukeUnits
EXTRN	?getNumNukeUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumNukeUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getNumNukeUnits@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?getNumNukeUnits@CvTeam@@QBEHXZ PROC			; CvTeam::getNumNukeUnits, COMDAT
; _this$ = ecx

; 1969 : {

	push	ebx
	push	esi
	push	edi

; 1970 : 	int iCount;
; 1971 : 	int iI;
; 1972 : 
; 1973 : 	iCount = 0;

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	7
$LL5@getNumNuke:

; 1974 : 
; 1975 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)
; 1976 : 	{
; 1977 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1978 : 		if(kLoopPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN4@getNumNuke

; 1979 : 		{
; 1980 : 			if(kLoopPlayer.getTeam() == GetID())

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@getNumNuke
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@getNumNuke
$LN18@getNumNuke:
	or	eax, -1
$LN19@getNumNuke:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN4@getNumNuke

; 1981 : 			{
; 1982 : 				iCount += kLoopPlayer.getNumNukeUnits();

	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	add	edi, eax
$LN4@getNumNuke:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@getNumNuke

; 1983 : 			}
; 1984 : 		}
; 1985 : 	}
; 1986 : 
; 1987 : 	return iCount;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1988 : }

	ret	0
?getNumNukeUnits@CvTeam@@QBEHXZ ENDP			; CvTeam::getNumNukeUnits
_TEXT	ENDS
PUBLIC	?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z ; CvTeam::getDefensivePactCount
; Function compile flags: /Ogtpy
;	COMDAT ?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z PROC	; CvTeam::getDefensivePactCount, COMDAT
; _this$ = ecx

; 2288 : {

	push	ebx
	push	ebp
	push	esi

; 2289 : 	int iCount;
; 2290 : 	int iI;
; 2291 : 
; 2292 : 	iCount = 0;

	mov	esi, DWORD PTR _eTeam$[esp+8]
	push	edi
	mov	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	xor	eax, eax

; 2293 : 
; 2294 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	xor	edx, edx
	lea	ebx, DWORD PTR [edi+2996]
	npad	8
$LL35@getDefensi@2:

; 2295 : 	{
; 2296 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	cmp	DWORD PTR [ebx-2984], 0
	jle	SHORT $LN7@getDefensi@2

; 2297 : 		{
; 2298 : 			if(iI != m_eID)

	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN7@getDefensi@2

; 2299 : 			{
; 2300 : 				if(IsHasDefensivePact((TeamTypes)iI))

	cmp	BYTE PTR [edx+ecx+2248], 0
	je	SHORT $LN7@getDefensi@2

; 2301 : 				{
; 2302 : 					if(NO_TEAM == eTeam || GET_TEAM(eTeam).isHasMet((TeamTypes)iI))

	cmp	esi, -1
	je	SHORT $LN1@getDefensi@2
	mov	ebp, esi
	imul	ebp, 2984				; 00000ba8H
	add	ebp, edi
	cmp	BYTE PTR [edx+ebp+1848], 0
	je	SHORT $LN7@getDefensi@2
$LN1@getDefensi@2:

; 2303 : 					{
; 2304 : 						iCount++;

	inc	eax
$LN7@getDefensi@2:

; 2295 : 	{
; 2296 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	cmp	DWORD PTR [ebx], 0
	jle	SHORT $LN33@getDefensi@2

; 2297 : 		{
; 2298 : 			if(iI != m_eID)

	lea	ebp, DWORD PTR [edx+1]
	cmp	ebp, DWORD PTR [ecx+4]
	je	SHORT $LN33@getDefensi@2

; 2299 : 			{
; 2300 : 				if(IsHasDefensivePact((TeamTypes)iI))

	cmp	BYTE PTR [edx+ecx+2249], 0
	je	SHORT $LN33@getDefensi@2

; 2301 : 				{
; 2302 : 					if(NO_TEAM == eTeam || GET_TEAM(eTeam).isHasMet((TeamTypes)iI))

	cmp	esi, -1
	je	SHORT $LN28@getDefensi@2
	mov	ebp, esi
	imul	ebp, 2984				; 00000ba8H
	add	ebp, edi
	cmp	BYTE PTR [edx+ebp+1849], 0
	je	SHORT $LN33@getDefensi@2
$LN28@getDefensi@2:

; 2303 : 					{
; 2304 : 						iCount++;

	inc	eax
$LN33@getDefensi@2:

; 2295 : 	{
; 2296 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	cmp	DWORD PTR [ebx+2984], 0
	jle	SHORT $LN34@getDefensi@2

; 2297 : 		{
; 2298 : 			if(iI != m_eID)

	lea	ebp, DWORD PTR [edx+2]
	cmp	ebp, DWORD PTR [ecx+4]
	je	SHORT $LN34@getDefensi@2

; 2299 : 			{
; 2300 : 				if(IsHasDefensivePact((TeamTypes)iI))

	cmp	BYTE PTR [edx+ecx+2250], 0
	je	SHORT $LN34@getDefensi@2

; 2301 : 				{
; 2302 : 					if(NO_TEAM == eTeam || GET_TEAM(eTeam).isHasMet((TeamTypes)iI))

	cmp	esi, -1
	je	SHORT $LN30@getDefensi@2
	mov	ebp, esi
	imul	ebp, 2984				; 00000ba8H
	add	ebp, edi
	cmp	BYTE PTR [edx+ebp+1850], 0
	je	SHORT $LN34@getDefensi@2
$LN30@getDefensi@2:

; 2303 : 					{
; 2304 : 						iCount++;

	inc	eax
$LN34@getDefensi@2:
	add	edx, 3
	add	ebx, 8952				; 000022f8H
	cmp	edx, 63					; 0000003fH
	jl	$LL35@getDefensi@2
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2305 : 					}
; 2306 : 				}
; 2307 : 			}
; 2308 : 		}
; 2309 : 	}
; 2310 : 
; 2311 : 	return iCount;
; 2312 : }

	ret	4
?getDefensivePactCount@CvTeam@@QBEHW4TeamTypes@@@Z ENDP	; CvTeam::getDefensivePactCount
_TEXT	ENDS
PUBLIC	?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassMaking
EXTRN	?getUnitClassMaking@CvPlayer@@QBEHW4UnitClassTypes@@@Z:PROC ; CvPlayer::getUnitClassMaking
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eUnitClass$ = 8					; size = 4
?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z PROC ; CvTeam::getUnitClassMaking, COMDAT
; _this$ = ecx

; 2316 : {

	push	ebx

; 2317 : 	int iCount;
; 2318 : 	int iI;
; 2319 : 
; 2320 : 	iCount = 0;

	mov	ebx, DWORD PTR _eUnitClass$[esp]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	ebp, ecx
	xor	esi, esi
	npad	2
$LL5@getUnitCla@2:

; 2321 : 
; 2322 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)
; 2323 : 	{
; 2324 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2325 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN4@getUnitCla@2

; 2326 : 		{
; 2327 : 			if(kPlayer.getTeam() == m_eID)

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@getUnitCla@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@getUnitCla@2
$LN18@getUnitCla@2:
	or	eax, -1
$LN19@getUnitCla@2:
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN4@getUnitCla@2

; 2328 : 			{
; 2329 : 				iCount += kPlayer.getUnitClassMaking(eUnitClass);

	push	ebx
	call	?getUnitClassMaking@CvPlayer@@QBEHW4UnitClassTypes@@@Z ; CvPlayer::getUnitClassMaking
	add	edi, eax
$LN4@getUnitCla@2:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@getUnitCla@2

; 2330 : 			}
; 2331 : 		}
; 2332 : 	}
; 2333 : 
; 2334 : 	return iCount;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2335 : }

	ret	4
?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ENDP ; CvTeam::getUnitClassMaking
_TEXT	ENDS
PUBLIC	?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassCountPlusMaking
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z PROC ; CvTeam::getUnitClassCountPlusMaking, COMDAT
; _this$ = ecx

; 2341 : 	return (getUnitClassCount(eIndex) + getUnitClassMaking(eIndex));

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR [ecx+2928]
	push	esi
	mov	esi, DWORD PTR [edx+eax*4]
	push	eax
	call	?getUnitClassMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ; CvTeam::getUnitClassMaking
	add	eax, esi
	pop	esi

; 2342 : }

	ret	4
?getUnitClassCountPlusMaking@CvTeam@@QBEHW4UnitClassTypes@@@Z ENDP ; CvTeam::getUnitClassCountPlusMaking
_TEXT	ENDS
PUBLIC	?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassMaking
EXTRN	?getBuildingClassMaking@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::getBuildingClassMaking
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eBuildingClass$ = 8					; size = 4
?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z PROC ; CvTeam::getBuildingClassMaking, COMDAT
; _this$ = ecx

; 2347 : {

	push	ebx

; 2348 : 	int iCount;
; 2349 : 	int iI;
; 2350 : 
; 2351 : 	iCount = 0;

	mov	ebx, DWORD PTR _eBuildingClass$[esp]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	ebp, ecx
	xor	esi, esi
	npad	2
$LL5@getBuildin:

; 2352 : 
; 2353 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)
; 2354 : 	{
; 2355 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2356 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN4@getBuildin

; 2357 : 		{
; 2358 : 			if(kPlayer.getTeam() == m_eID)

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@getBuildin
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@getBuildin
$LN18@getBuildin:
	or	eax, -1
$LN19@getBuildin:
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN4@getBuildin

; 2359 : 			{
; 2360 : 				iCount += kPlayer.getBuildingClassMaking(eBuildingClass);

	push	ebx
	call	?getBuildingClassMaking@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::getBuildingClassMaking
	add	edi, eax
$LN4@getBuildin:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@getBuildin

; 2361 : 			}
; 2362 : 		}
; 2363 : 	}
; 2364 : 
; 2365 : 	return iCount;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2366 : }

	ret	4
?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvTeam::getBuildingClassMaking
_TEXT	ENDS
PUBLIC	?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassCountPlusMaking
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z PROC ; CvTeam::getBuildingClassCountPlusMaking, COMDAT
; _this$ = ecx

; 2372 : 	return (getBuildingClassCount(eIndex) + getBuildingClassMaking(eIndex));

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR [ecx+2932]
	push	esi
	mov	esi, DWORD PTR [edx+eax*4]
	push	eax
	call	?getBuildingClassMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ; CvTeam::getBuildingClassMaking
	add	eax, esi
	pop	esi

; 2373 : }

	ret	4
?getBuildingClassCountPlusMaking@CvTeam@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvTeam::getBuildingClassCountPlusMaking
_TEXT	ENDS
PUBLIC	?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z	; CvTeam::countNumUnitsByArea
EXTRN	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getUnitsPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pArea$ = 8						; size = 4
?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC	; CvTeam::countNumUnitsByArea, COMDAT
; _this$ = ecx

; 2377 : {

	push	ecx
	push	ebx
	push	ebp

; 2378 : 	int iCount;
; 2379 : 	int iI;
; 2380 : 
; 2381 : 	iCount = 0;

	mov	ebp, DWORD PTR _pArea$[esp+8]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+20], ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebx, ebx

; 2382 : 
; 2383 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	xor	esi, esi
	npad	7
$LL5@countNumUn:

; 2384 : 	{
; 2385 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);
; 2386 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN4@countNumUn

; 2387 : 		{
; 2388 : 			if(kPlayer.getTeam() == m_eID)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@countNumUn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@countNumUn
$LN18@countNumUn:
	or	eax, -1
$LN19@countNumUn:
	mov	edx, DWORD PTR _this$[esp+20]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN4@countNumUn

; 2389 : 			{
; 2390 : 				iCount += pArea->getUnitsPerPlayer((PlayerTypes)iI);

	push	edi
	mov	ecx, ebp
	call	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getUnitsPerPlayer
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ebx, eax
$LN4@countNumUn:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@countNumUn
	pop	edi
	pop	esi
	pop	ebp

; 2391 : 			}
; 2392 : 		}
; 2393 : 	}
; 2394 : 
; 2395 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 2396 : }

	pop	ecx
	ret	4
?countNumUnitsByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP	; CvTeam::countNumUnitsByArea
_TEXT	ENDS
PUBLIC	?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z	; CvTeam::countNumCitiesByArea
EXTRN	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getCitiesPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pArea$ = 8						; size = 4
?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC	; CvTeam::countNumCitiesByArea, COMDAT
; _this$ = ecx

; 2401 : {

	push	ecx
	push	ebx
	push	ebp

; 2402 : 	int iCount;
; 2403 : 	int iI;
; 2404 : 
; 2405 : 	iCount = 0;

	mov	ebp, DWORD PTR _pArea$[esp+8]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+20], ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebx, ebx

; 2406 : 
; 2407 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	xor	esi, esi
	npad	7
$LL5@countNumCi:

; 2408 : 	{
; 2409 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);
; 2410 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN4@countNumCi

; 2411 : 		{
; 2412 : 			if(kPlayer.getTeam() == m_eID)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@countNumCi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@countNumCi
$LN18@countNumCi:
	or	eax, -1
$LN19@countNumCi:
	mov	edx, DWORD PTR _this$[esp+20]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN4@countNumCi

; 2413 : 			{
; 2414 : 				iCount += pArea->getCitiesPerPlayer((PlayerTypes)iI);

	push	edi
	mov	ecx, ebp
	call	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ebx, eax
$LN4@countNumCi:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@countNumCi
	pop	edi
	pop	esi
	pop	ebp

; 2415 : 			}
; 2416 : 		}
; 2417 : 	}
; 2418 : 
; 2419 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 2420 : }

	pop	ecx
	ret	4
?countNumCitiesByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP	; CvTeam::countNumCitiesByArea
_TEXT	ENDS
PUBLIC	?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z ; CvTeam::countTotalPopulationByArea
EXTRN	?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getPopulationPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pArea$ = 8						; size = 4
?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC ; CvTeam::countTotalPopulationByArea, COMDAT
; _this$ = ecx

; 2425 : {

	push	ecx
	push	ebx
	push	ebp

; 2426 : 	int iCount;
; 2427 : 	int iI;
; 2428 : 
; 2429 : 	iCount = 0;

	mov	ebp, DWORD PTR _pArea$[esp+8]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+20], ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebx, ebx

; 2430 : 
; 2431 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	xor	esi, esi
	npad	7
$LL5@countTotal:

; 2432 : 	{
; 2433 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);
; 2434 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN4@countTotal

; 2435 : 		{
; 2436 : 			if(kPlayer.getTeam() == m_eID)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@countTotal
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@countTotal
$LN18@countTotal:
	or	eax, -1
$LN19@countTotal:
	mov	edx, DWORD PTR _this$[esp+20]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN4@countTotal

; 2437 : 			{
; 2438 : 				iCount += pArea->getPopulationPerPlayer((PlayerTypes)iI);

	push	edi
	mov	ecx, ebp
	call	?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getPopulationPerPlayer
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ebx, eax
$LN4@countTotal:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@countTotal
	pop	edi
	pop	esi
	pop	ebp

; 2439 : 			}
; 2440 : 		}
; 2441 : 	}
; 2442 : 
; 2443 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 2444 : }

	pop	ecx
	ret	4
?countTotalPopulationByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP ; CvTeam::countTotalPopulationByArea
_TEXT	ENDS
PUBLIC	?isHuman@CvTeam@@QBE_NXZ			; CvTeam::isHuman
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?isHuman@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isHuman@CvTeam@@QBE_NXZ PROC				; CvTeam::isHuman, COMDAT
; _this$ = ecx

; 2491 : {

	push	esi
	push	edi
	mov	edi, ecx

; 2492 : 	int iI;
; 2493 : 
; 2494 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	esi, esi
	npad	10
$LL5@isHuman:

; 2495 : 	{
; 2496 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN4@isHuman
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN20@isHuman
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN21@isHuman
$LN20@isHuman:
	or	eax, -1
$LN21@isHuman:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN4@isHuman

; 2497 : 		{
; 2498 : 			if(GET_PLAYER((PlayerTypes)iI).isHuman())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN30@isHuman
$LN4@isHuman:

; 2492 : 	int iI;
; 2493 : 
; 2494 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@isHuman
	pop	edi

; 2501 : 			}
; 2502 : 		}
; 2503 : 	}
; 2504 : 
; 2505 : 	return false;

	xor	al, al
	pop	esi

; 2506 : }

	ret	0
$LN30@isHuman:
	pop	edi

; 2499 : 			{
; 2500 : 				return true;

	mov	al, 1
	pop	esi

; 2506 : }

	ret	0
?isHuman@CvTeam@@QBE_NXZ ENDP				; CvTeam::isHuman
_TEXT	ENDS
PUBLIC	?isObserver@CvTeam@@QBE_NXZ			; CvTeam::isObserver
EXTRN	?isObserver@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isObserver
; Function compile flags: /Ogtpy
;	COMDAT ?isObserver@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isObserver@CvTeam@@QBE_NXZ PROC			; CvTeam::isObserver, COMDAT
; _this$ = ecx

; 2510 : {

	push	esi
	push	edi
	mov	edi, ecx

; 2511 : 	int iI;
; 2512 : 	for(iI = 0; iI < MAX_PLAYERS; iI++){

	xor	esi, esi
	npad	10
$LL4@isObserver:

; 2513 : 		CvPlayer &player = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]

; 2514 : 		if(player.getTeam() == GetID() && player.isObserver()){

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@isObserver
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN14@isObserver
$LN13@isObserver:
	or	eax, -1
$LN14@isObserver:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN3@isObserver
	call	?isObserver@CvPlayer@@QBE_NXZ		; CvPlayer::isObserver
	test	al, al
	jne	SHORT $LN21@isObserver
$LN3@isObserver:

; 2511 : 	int iI;
; 2512 : 	for(iI = 0; iI < MAX_PLAYERS; iI++){

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL4@isObserver
	pop	edi

; 2516 : 		}
; 2517 : 	}
; 2518 : 	return false;

	xor	al, al
	pop	esi

; 2519 : }

	ret	0
$LN21@isObserver:
	pop	edi

; 2515 : 			return true;

	mov	al, 1
	pop	esi

; 2519 : }

	ret	0
?isObserver@CvTeam@@QBE_NXZ ENDP			; CvTeam::isObserver
_TEXT	ENDS
PUBLIC	?isMinorCiv@CvTeam@@QBE_NXZ			; CvTeam::isMinorCiv
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?isMinorCiv@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
_bValid$ = -1						; size = 1
?isMinorCiv@CvTeam@@QBE_NXZ PROC			; CvTeam::isMinorCiv, COMDAT
; _this$ = ecx

; 2531 : {

	push	ecx

; 2532 : 	bool bValid;
; 2533 : 	int iI;
; 2534 : 
; 2535 : 	bValid = false;

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	mov	BYTE PTR _bValid$[esp+20], 0

; 2536 : 
; 2537 : 	for(iI = MAX_MAJOR_CIVS; iI < MAX_PLAYERS; iI++)

	mov	edi, 22					; 00000016H
	add	edx, 1391236				; 00153a84H
$LL30@isMinorCiv:

; 2538 : 	{
; 2539 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);
; 2540 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [edx+2212], 0
	lea	ecx, DWORD PTR [edx-44]
	je	SHORT $LN6@isMinorCiv

; 2541 : 		{
; 2542 : 			if(kPlayer.getTeam() == GetID())

	mov	esi, DWORD PTR [edx]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN20@isMinorCiv
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN21@isMinorCiv
$LN20@isMinorCiv:
	or	esi, -1
$LN21@isMinorCiv:
	cmp	esi, DWORD PTR [ebp+4]
	je	SHORT $LN28@isMinorCiv
$LN6@isMinorCiv:

; 2536 : 
; 2537 : 	for(iI = MAX_MAJOR_CIVS; iI < MAX_PLAYERS; iI++)

	inc	edi
	add	edx, 63236				; 0000f704H
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL30@isMinorCiv

; 2541 : 		{
; 2542 : 			if(kPlayer.getTeam() == GetID())

	mov	al, BYTE PTR _bValid$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2552 : 				}
; 2553 : 			}
; 2554 : 		}
; 2555 : 	}
; 2556 : 
; 2557 : 	return bValid;
; 2558 : }

	pop	ecx
	ret	0
$LN28@isMinorCiv:

; 2543 : 			{
; 2544 : 				if(kPlayer.isMinorCiv())

	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN2@isMinorCiv
	pop	edi
	pop	esi
	pop	ebp

; 2545 : 				{
; 2546 : 					bValid = true;

	mov	al, 1
	pop	ebx

; 2552 : 				}
; 2553 : 			}
; 2554 : 		}
; 2555 : 	}
; 2556 : 
; 2557 : 	return bValid;
; 2558 : }

	pop	ecx
	ret	0
$LN2@isMinorCiv:
	pop	edi
	pop	esi
	pop	ebp

; 2547 : 					break;
; 2548 : 				}
; 2549 : 				else
; 2550 : 				{
; 2551 : 					return false;

	xor	al, al
	pop	ebx

; 2552 : 				}
; 2553 : 			}
; 2554 : 		}
; 2555 : 	}
; 2556 : 
; 2557 : 	return bValid;
; 2558 : }

	pop	ecx
	ret	0
?isMinorCiv@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMinorCiv
_TEXT	ENDS
PUBLIC	?isMajorCiv@CvTeam@@QBE_NXZ			; CvTeam::isMajorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?isMajorCiv@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isMajorCiv@CvTeam@@QBE_NXZ PROC			; CvTeam::isMajorCiv, COMDAT
; _this$ = ecx

; 2561 : {

	push	esi
	mov	esi, ecx

; 2562 : 	return !(isMinorCiv() || isBarbarian() || isObserver());

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN3@isMajorCiv
	cmp	DWORD PTR [esi+4], 63			; 0000003fH
	je	SHORT $LN3@isMajorCiv
	mov	ecx, esi
	call	?isObserver@CvTeam@@QBE_NXZ		; CvTeam::isObserver
	test	al, al
	jne	SHORT $LN3@isMajorCiv
	mov	eax, 1
	pop	esi

; 2563 : }

	ret	0
$LN3@isMajorCiv:

; 2562 : 	return !(isMinorCiv() || isBarbarian() || isObserver());

	xor	eax, eax
	pop	esi

; 2563 : }

	ret	0
?isMajorCiv@CvTeam@@QBE_NXZ ENDP			; CvTeam::isMajorCiv
_TEXT	ENDS
PUBLIC	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ	; CvTeam::getLeaderID
; Function compile flags: /Ogtpy
;	COMDAT ?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ PROC	; CvTeam::getLeaderID, COMDAT
; _this$ = ecx

; 2668 : {

	push	ebx

; 2669 : 	int iI;
; 2670 : 
; 2671 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	eax, eax
	add	edi, 44					; 0000002cH
	mov	esi, edi
$LL44@getLeaderI:

; 2672 : 	{
; 2673 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);
; 2674 : 		if(thisPlayer.isAlive())

	cmp	BYTE PTR [esi+2212], 0
	je	SHORT $LN8@getLeaderI

; 2675 : 		{
; 2676 : 			if(thisPlayer.getTeam() == m_eID)

	mov	edx, DWORD PTR [esi]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN22@getLeaderI
	mov	ebp, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebp+edx*4]
	jmp	SHORT $LN23@getLeaderI
$LN22@getLeaderI:
	or	edx, -1
$LN23@getLeaderI:
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN10@getLeaderI
$LN8@getLeaderI:

; 2669 : 	int iI;
; 2670 : 
; 2671 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	inc	eax
	add	esi, 63236				; 0000f704H
	cmp	eax, 64					; 00000040H
	jl	SHORT $LL44@getLeaderI
	mov	esi, DWORD PTR [ecx+4]

; 2677 : 			{
; 2678 : 				return ((PlayerTypes)iI);
; 2679 : 			}
; 2680 : 		}
; 2681 : 	}
; 2682 : 
; 2683 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	eax, eax
	mov	edx, edi
	npad	5
$LL4@getLeaderI:

; 2684 : 	{
; 2685 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);
; 2686 : 		if(thisPlayer.getTeam() == m_eID)

	mov	ecx, DWORD PTR [edx]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN33@getLeaderI
	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [edi+ecx*4]
	jmp	SHORT $LN34@getLeaderI
$LN33@getLeaderI:
	or	ecx, -1
$LN34@getLeaderI:
	cmp	ecx, esi
	je	SHORT $LN10@getLeaderI
	inc	eax
	add	edx, 63236				; 0000f704H
	cmp	eax, 64					; 00000040H
	jl	SHORT $LL4@getLeaderI

; 2687 : 		{
; 2688 : 			return ((PlayerTypes)iI);
; 2689 : 		}
; 2690 : 	}
; 2691 : 
; 2692 : 	return NO_PLAYER;

	or	eax, -1
$LN10@getLeaderI:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2693 : }

	ret	0
?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ENDP	; CvTeam::getLeaderID
_TEXT	ENDS
PUBLIC	?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ	; CvTeam::getSecretaryID
; Function compile flags: /Ogtpy
;	COMDAT ?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ PROC	; CvTeam::getSecretaryID, COMDAT
; _this$ = ecx

; 2698 : {

	push	ebx
	push	esi
	push	edi

; 2699 : 	int iI;
; 2700 : 
; 2701 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	7
$LL6@getSecreta:

; 2702 : 	{
; 2703 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN5@getSecreta

; 2704 : 		{
; 2705 : 			if(GET_PLAYER((PlayerTypes)iI).isHuman())

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN5@getSecreta

; 2706 : 			{
; 2707 : 				if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@getSecreta
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN24@getSecreta
$LN23@getSecreta:
	or	eax, -1
$LN24@getSecreta:
	cmp	eax, DWORD PTR [ebx+4]
	je	SHORT $LN31@getSecreta
$LN5@getSecreta:

; 2699 : 	int iI;
; 2700 : 
; 2701 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL6@getSecreta
	pop	edi
	pop	esi

; 2710 : 				}
; 2711 : 			}
; 2712 : 		}
; 2713 : 	}
; 2714 : 
; 2715 : 	return getLeaderID();

	mov	ecx, ebx
	pop	ebx
	jmp	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
$LN31@getSecreta:

; 2708 : 				{
; 2709 : 					return ((PlayerTypes)iI);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2716 : }

	ret	0
?getSecretaryID@CvTeam@@QBE?AW4PlayerTypes@@XZ ENDP	; CvTeam::getSecretaryID
_TEXT	ENDS
PUBLIC	?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ ; CvTeam::getHandicapType
EXTRN	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ:PROC ; CvPlayer::getHandicapType
; Function compile flags: /Ogtpy
;	COMDAT ?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ
_TEXT	SEGMENT
?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ PROC	; CvTeam::getHandicapType, COMDAT
; _this$ = ecx

; 2721 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 2722 : 	int iGameHandicap;
; 2723 : 	int iCount;
; 2724 : 	int iI;
; 2725 : 
; 2726 : 	iGameHandicap = 0;

	xor	ebx, ebx

; 2727 : 	iCount = 0;

	xor	edi, edi
	mov	ebp, ecx
	xor	esi, esi
	npad	4
$LL7@getHandica:

; 2728 : 
; 2729 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)
; 2730 : 	{
; 2731 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2732 : 		if(thisPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN6@getHandica

; 2733 : 		{
; 2734 : 			if(thisPlayer.getTeam() == m_eID)

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN20@getHandica
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN21@getHandica
$LN20@getHandica:
	or	eax, -1
$LN21@getHandica:
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN6@getHandica

; 2735 : 			{
; 2736 : 				iGameHandicap += GET_PLAYER((PlayerTypes)iI).getHandicapType();

	call	?getHandicapType@CvPlayer@@QBE?AW4HandicapTypes@@XZ ; CvPlayer::getHandicapType
	add	ebx, eax

; 2737 : 				iCount++;

	inc	edi
$LN6@getHandica:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL7@getHandica

; 2738 : 			}
; 2739 : 		}
; 2740 : 	}
; 2741 : 
; 2742 : 	if(iCount > 0)

	test	edi, edi
	jle	SHORT $LN2@getHandica

; 2743 : 	{
; 2744 : 		CvAssertMsg((iGameHandicap / iCount) >= 0, "(iGameHandicap / iCount) is expected to be non-negative (invalid Index)");
; 2745 : 		return ((HandicapTypes)(iGameHandicap / iCount));

	mov	eax, ebx
	cdq
	idiv	edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2750 : 	}
; 2751 : }

	ret	0
$LN2@getHandica:

; 2746 : 	}
; 2747 : 	else
; 2748 : 	{
; 2749 : 		return ((HandicapTypes)(GC.getSTANDARD_HANDICAP()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8452
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2750 : 	}
; 2751 : }

	ret	0
?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ ENDP	; CvTeam::getHandicapType
_TEXT	ENDS
PUBLIC	?getName@CvTeam@@QBE?AVCvString@@XZ		; CvTeam::getName
EXTRN	?getName@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getName
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?getName@CvTeam@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getName@CvTeam@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?getName@CvTeam@@QBE?AVCvString@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getName@CvTeam@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?getName@CvTeam@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T234866 = -20						; size = 4
_eID$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getName@CvTeam@@QBE?AVCvString@@XZ PROC		; CvTeam::getName, COMDAT
; _this$ = ecx

; 2756 : {

	push	-1
	push	__ehhandler$?getName@CvTeam@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebp
	push	esi
	mov	DWORD PTR $T234866[esp+28], 0

; 2757 : 	CvString strBuffer;

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2778 : 			}
; 2779 : 		}
; 2780 : 	}
; 2781 : 
; 2782 : 	return strBuffer;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, 1
	mov	DWORD PTR __$EHRec$[esp+40], 0
	mov	DWORD PTR $T234866[esp+32], ecx
	mov	DWORD PTR _eID$[esp+32], eax
	xor	edi, edi
	npad	13
$LL7@getName:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+edx+2256], 0
	lea	esi, DWORD PTR [edi+edx]
	jne	SHORT $LN3@getName

; 2758 : 	bool bFirst = true;
; 2759 : 	const TeamTypes eID(GetID());
; 2760 : 
; 2761 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)
; 2762 : 	{
; 2763 : 		const PlayerTypes ePlayer(static_cast<PlayerTypes>(iI));
; 2764 : 		CvPlayerAI& kPlayer(GET_PLAYER(ePlayer));
; 2765 : 
; 2766 : 		if(kPlayer.isAlive() || kPlayer.isBeingResurrected())

	cmp	BYTE PTR [esi+2276], 0
	je	SHORT $LN6@getName
$LN3@getName:

; 2767 : 		{
; 2768 : 			if(kPlayer.getTeam() == eID)

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN29@getName
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN30@getName
$LN29@getName:
	or	eax, -1
$LN30@getName:
	cmp	eax, DWORD PTR _eID$[esp+32]
	jne	SHORT $LN6@getName

; 2769 : 			{
; 2770 : 				if(!bFirst)

	test	cl, cl
	jne	SHORT $LN1@getName

; 2771 : 				{
; 2772 : 					strBuffer += "/";

	push	OFFSET $SG225254
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@getName:

; 2773 : 				}
; 2774 : 
; 2775 : 				strBuffer += kPlayer.getName();

	mov	ecx, esi
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2776 : 
; 2777 : 				bFirst = false;

	xor	cl, cl
$LN6@getName:
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL7@getName

; 2783 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getName@CvTeam@@QBE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T234866[ebp]
	and	eax, 1
	je	$LN11@getName
	and	DWORD PTR $T234866[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN11@getName:
	ret	0
__ehhandler$?getName@CvTeam@@QBE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?getName@CvTeam@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getName@CvTeam@@QBE?AVCvString@@XZ ENDP		; CvTeam::getName
PUBLIC	?getNameKey@CvTeam@@QBE?AVCvString@@XZ		; CvTeam::getNameKey
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?getNameKey@CvTeam@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getNameKey@CvTeam@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?getNameKey@CvTeam@@QBE?AVCvString@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getNameKey@CvTeam@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?getNameKey@CvTeam@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
_bOneManTeam$ = -21					; size = 1
$T234927 = -20						; size = 4
_eID$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getNameKey@CvTeam@@QBE?AVCvString@@XZ PROC		; CvTeam::getNameKey, COMDAT
; _this$ = ecx

; 2787 : {

	push	-1
	push	__ehhandler$?getNameKey@CvTeam@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebp
	push	esi
	mov	DWORD PTR $T234927[esp+32], 0

; 2788 : 	CvString strBuffer;

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	esi, ecx
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2814 : 			}
; 2815 : 		}
; 2816 : 	}
; 2817 : 
; 2818 : 	return strBuffer;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, 1
	cmp	DWORD PTR [esi+8], ecx
	mov	DWORD PTR __$EHRec$[esp+44], 0
	sete	BYTE PTR _bOneManTeam$[esp+36]
	mov	DWORD PTR $T234927[esp+36], ecx
	mov	DWORD PTR _eID$[esp+36], eax
	xor	edi, edi
	npad	5
$LL8@getNameKey:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+edx+2256], 0
	lea	esi, DWORD PTR [edi+edx]
	je	SHORT $LN7@getNameKey
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN30@getNameKey
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN31@getNameKey

; 2789 : 	bool bFirst = true;
; 2790 : 	const TeamTypes eID(GetID());
; 2791 : 	bool bOneManTeam = (this->getNumMembers() == 1);
; 2792 : 
; 2793 : 
; 2794 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)
; 2795 : 	{
; 2796 : 		const PlayerTypes ePlayer(static_cast<PlayerTypes>(iI));
; 2797 : 		CvPlayerAI& kPlayer(GET_PLAYER(ePlayer));
; 2798 : 
; 2799 : 		if(kPlayer.isAlive())
; 2800 : 		{
; 2801 : 			if(kPlayer.getTeam() == eID)

$LN30@getNameKey:
	or	eax, -1
$LN31@getNameKey:
	cmp	eax, DWORD PTR _eID$[esp+36]
	jne	SHORT $LN7@getNameKey

; 2802 : 			{
; 2803 : 				if(!bFirst)

	test	cl, cl
	jne	SHORT $LN3@getNameKey

; 2804 : 				{
; 2805 : 					strBuffer += "/";

	push	OFFSET $SG225273
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN3@getNameKey:

; 2806 : 				}
; 2807 : 				
; 2808 : 				if(bOneManTeam)

	cmp	BYTE PTR _bOneManTeam$[esp+36], 0

; 2809 : 					strBuffer += kPlayer.getNameKey();

	mov	ecx, esi
	je	SHORT $LN2@getNameKey
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey

; 2810 : 				else

	jmp	SHORT $LN38@getNameKey
$LN2@getNameKey:

; 2811 : 					strBuffer += kPlayer.getName();

	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
$LN38@getNameKey:
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2812 : 
; 2813 : 				bFirst = false;

	xor	cl, cl
$LN7@getNameKey:
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL8@getNameKey

; 2819 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getNameKey@CvTeam@@QBE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T234927[ebp]
	and	eax, 1
	je	$LN12@getNameKey
	and	DWORD PTR $T234927[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN12@getNameKey:
	ret	0
__ehhandler$?getNameKey@CvTeam@@QBE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?getNameKey@CvTeam@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getNameKey@CvTeam@@QBE?AVCvString@@XZ ENDP		; CvTeam::getNameKey
PUBLIC	?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z ; CvTeam::isForceTeamVoteEligible
; Function compile flags: /Ogtpy
;	COMDAT ?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z
_TEXT	SEGMENT
_eVoteSource$ = 8					; size = 4
?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z PROC ; CvTeam::isForceTeamVoteEligible, COMDAT
; _this$ = ecx

; 2943 : 	return ((getForceTeamVoteEligibilityCount(eVoteSource) > 0) && !isMinorCiv());

	mov	eax, DWORD PTR [ecx+2892]
	mov	edx, DWORD PTR _eVoteSource$[esp-4]
	cmp	DWORD PTR [eax+edx*4], 0
	jle	SHORT $LN3@isForceTea
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN3@isForceTea
	mov	eax, 1

; 2944 : }

	ret	4
$LN3@isForceTea:

; 2943 : 	return ((getForceTeamVoteEligibilityCount(eVoteSource) > 0) && !isMinorCiv());

	xor	eax, eax

; 2944 : }

	ret	4
?isForceTeamVoteEligible@CvTeam@@QBE_NW4VoteSourceTypes@@@Z ENDP ; CvTeam::isForceTeamVoteEligible
_TEXT	ENDS
PUBLIC	?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z ; CvTeam::HavePolicyInTeam
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_ePolicy$ = 8						; size = 4
?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z PROC	; CvTeam::HavePolicyInTeam, COMDAT
; _this$ = ecx

; 3051 : {

	push	ebx

; 3052 : 	const TeamTypes eID(GetID());

	mov	ebx, DWORD PTR _ePolicy$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	xor	esi, esi
	npad	4
$LL6@HavePolicy:

; 3055 : 	{
; 3056 : 		const PlayerTypes ePlayer(static_cast<PlayerTypes>(iI));
; 3057 : 		CvPlayerAI& kPlayer(GET_PLAYER(ePlayer));

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3058 : 
; 3059 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN5@HavePolicy

; 3060 : 		{
; 3061 : 			if(kPlayer.getTeam() == eID)

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@HavePolicy
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN22@HavePolicy
$LN21@HavePolicy:
	or	eax, -1
$LN22@HavePolicy:
	cmp	eax, edi
	jne	SHORT $LN5@HavePolicy

; 3062 : 			{
; 3063 : 				if (kPlayer.GetPlayerPolicies()->HasPolicy(ePolicy))

	push	ebx
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	jne	SHORT $LN27@HavePolicy
$LN5@HavePolicy:

; 3053 : 
; 3054 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL6@HavePolicy
	pop	edi
	pop	esi

; 3066 : 				}
; 3067 : 			}
; 3068 : 		}
; 3069 : 	}
; 3070 : 	return false;

	xor	al, al
	pop	ebx

; 3071 : }

	ret	4
$LN27@HavePolicy:
	pop	edi
	pop	esi

; 3064 : 				{
; 3065 : 					return true;

	mov	al, 1
	pop	ebx

; 3071 : }

	ret	4
?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z ENDP	; CvTeam::HavePolicyInTeam
_TEXT	ENDS
PUBLIC	?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isOpenBordersTradingAllowedWithTeam
; Function compile flags: /Ogtpy
;	COMDAT ?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::isOpenBordersTradingAllowedWithTeam, COMDAT
; _this$ = ecx

; 3109 : 	return HasEmbassyAtTeam(eTeam) && isOpenBordersTradingAllowed();

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	BYTE PTR [eax+ecx+2088], 0
	je	SHORT $LN3@isOpenBord
	cmp	DWORD PTR [ecx+56], 0
	jle	SHORT $LN3@isOpenBord
	mov	eax, 1

; 3110 : }

	ret	4
$LN3@isOpenBord:

; 3109 : 	return HasEmbassyAtTeam(eTeam) && isOpenBordersTradingAllowed();

	xor	eax, eax

; 3110 : }

	ret	4
?isOpenBordersTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::isOpenBordersTradingAllowedWithTeam
_TEXT	ENDS
PUBLIC	?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isDefensivePactTradingAllowedWithTeam
; Function compile flags: /Ogtpy
;	COMDAT ?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::isDefensivePactTradingAllowedWithTeam, COMDAT
; _this$ = ecx

; 3136 : 	return HasEmbassyAtTeam(eTeam) && GET_TEAM(eTeam).HasEmbassyAtTeam(m_eID) && isDefensivePactTradingAllowed();

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	BYTE PTR [eax+ecx+2088], 0
	je	SHORT $LN3@isDefensiv
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+edx+2088], 0
	je	SHORT $LN3@isDefensiv
	cmp	DWORD PTR [ecx+60], 0
	jle	SHORT $LN3@isDefensiv
	mov	eax, 1

; 3137 : }

	ret	4
$LN3@isDefensiv:

; 3136 : 	return HasEmbassyAtTeam(eTeam) && GET_TEAM(eTeam).HasEmbassyAtTeam(m_eID) && isDefensivePactTradingAllowed();

	xor	eax, eax

; 3137 : }

	ret	4
?isDefensivePactTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::isDefensivePactTradingAllowedWithTeam
_TEXT	ENDS
PUBLIC	?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsResearchAgreementTradingAllowedWithTeam
; Function compile flags: /Ogtpy
;	COMDAT ?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z PROC ; CvTeam::IsResearchAgreementTradingAllowedWithTeam, COMDAT
; _this$ = ecx

; 3163 : 	return HasEmbassyAtTeam(eTeam) && IsResearchAgreementTradingAllowed();

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	BYTE PTR [eax+ecx+2088], 0
	je	SHORT $LN3@IsResearch
	cmp	DWORD PTR [ecx+64], 0
	jle	SHORT $LN3@IsResearch
	mov	eax, 1

; 3164 : }

	ret	4
$LN3@IsResearch:

; 3163 : 	return HasEmbassyAtTeam(eTeam) && IsResearchAgreementTradingAllowed();

	xor	eax, eax

; 3164 : }

	ret	4
?IsResearchAgreementTradingAllowedWithTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP ; CvTeam::IsResearchAgreementTradingAllowedWithTeam
_TEXT	ENDS
PUBLIC	?changeCanEmbarkCount@CvTeam@@QAEXH@Z		; CvTeam::changeCanEmbarkCount
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z:PROC ; CvUnit::setHasPromotion
EXTRN	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z:PROC ; IsPromotionValidForUnitCombatType
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ:PROC ; CvPlayer::GetEmbarkationPromotion
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?changeCanEmbarkCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iLoop$225558 = 8					; size = 4
_iChange$ = 8						; size = 4
?changeCanEmbarkCount@CvTeam@@QAEXH@Z PROC		; CvTeam::changeCanEmbarkCount, COMDAT
; _this$ = ecx

; 3402 : {

	push	ecx

; 3403 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+8], edi
	test	eax, eax
	je	$LN9@changeCanE

; 3404 : 	{
; 3405 : 		m_iCanEmbarkCount += iChange;

	add	DWORD PTR [edi+104], eax

; 3406 : 
; 3407 : 		if(canEmbark())

	cmp	DWORD PTR [edi+104], 0
	jle	$LN9@changeCanE
	push	ebx
	push	ebp

; 3408 : 		{
; 3409 : 			int iLoop;
; 3410 : 			CvUnit* pLoopUnit;
; 3411 : 
; 3412 : 			// Give embarkation promotion to all civilians, because they have no way to earn it later
; 3413 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebp, ebp
	push	esi
	xor	ebx, ebx
	npad	8
$LL53@changeCanE:

; 3414 : 			{
; 3415 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	ecx, DWORD PTR [ebx+eax]
	je	$LN10@changeCanE
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN30@changeCanE
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN31@changeCanE
$LN30@changeCanE:
	or	eax, -1
$LN31@changeCanE:
	cmp	eax, DWORD PTR [edi+4]
	jne	$LN10@changeCanE

; 3416 : 				{
; 3417 : 					for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$225558[esp+20]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN10@changeCanE
	npad	6
$LL7@changeCanE:

; 3418 : 					{
; 3419 : 						// Land Unit
; 3420 : 						if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN6@changeCanE

; 3421 : 						{
; 3422 : 							// If we're in friendly territory and we can embark, give the promotion for free
; 3423 : 							if(pLoopUnit->plot()->IsFriendlyTerritory((PlayerTypes)iI))

	push	ebp
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al
	je	SHORT $LN6@changeCanE

; 3424 : 							{
; 3425 : 								// Civilian unit or the unit can acquire this promotion
; 3426 : 								PromotionTypes ePromotionEmbarkation = GET_PLAYER((PlayerTypes)iI).GetEmbarkationPromotion();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebx
	call	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ ; CvPlayer::GetEmbarkationPromotion

; 3427 : 								if(!pLoopUnit->IsCombatUnit() || ::IsPromotionValidForUnitCombatType(ePromotionEmbarkation, pLoopUnit->getUnitType()))

	cmp	DWORD PTR [esi+1044], 0
	mov	edi, eax
	jle	SHORT $LN1@changeCanE
	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	push	edi
	call	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForUnitCombatType
	add	esp, 8
	test	al, al
	je	SHORT $LN6@changeCanE
$LN1@changeCanE:

; 3428 : 								{
; 3429 : 									pLoopUnit->setHasPromotion(ePromotionEmbarkation, true);

	push	1
	push	edi
	mov	ecx, esi
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
$LN6@changeCanE:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$225558[esp+20]
	lea	ecx, DWORD PTR [ebx+edx]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL7@changeCanE

; 3416 : 				{
; 3417 : 					for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))

	mov	edi, DWORD PTR _this$[esp+20]
$LN10@changeCanE:

; 3408 : 		{
; 3409 : 			int iLoop;
; 3410 : 			CvUnit* pLoopUnit;
; 3411 : 
; 3412 : 			// Give embarkation promotion to all civilians, because they have no way to earn it later
; 3413 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	ebx, 63236				; 0000f704H
	inc	ebp
	cmp	ebx, 4047104				; 003dc100H
	jl	$LL53@changeCanE
	pop	esi
	pop	ebp
	pop	ebx
$LN9@changeCanE:
	pop	edi

; 3430 : 								}
; 3431 : 									
; 3432 : 							}
; 3433 : 						}
; 3434 : 					}
; 3435 : 				}
; 3436 : 			}
; 3437 : 		}
; 3438 : 	}
; 3439 : 
; 3440 : 	CvAssert(getCanEmbarkCount() >= 0);
; 3441 : }

	pop	ecx
	ret	4
?changeCanEmbarkCount@CvTeam@@QAEXH@Z ENDP		; CvTeam::changeCanEmbarkCount
_TEXT	ENDS
PUBLIC	?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z	; CvTeam::changeDefensiveEmbarkCount
EXTRN	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z:PROC ; CvUnit::isHasPromotion
; Function compile flags: /Ogtpy
;	COMDAT ?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z
_TEXT	SEGMENT
_iLoop$225591 = 8					; size = 4
_iChange$ = 8						; size = 4
?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z PROC	; CvTeam::changeDefensiveEmbarkCount, COMDAT
; _this$ = ecx

; 3463 : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	push	ebp
	mov	ebp, ecx
	test	eax, eax
	je	$LN8@changeDefe

; 3464 : 	{
; 3465 : 		m_iDefensiveEmbarkCount += iChange;

	add	DWORD PTR [ebp+108], eax

; 3466 : 
; 3467 : 		if(canDefensiveEmbark())

	cmp	DWORD PTR [ebp+108], 0
	jle	$LN8@changeDefe
	push	ebx
	push	esi
	push	edi

; 3468 : 		{
; 3469 : 			int iLoop;
; 3470 : 			CvUnit* pLoopUnit;
; 3471 : 
; 3472 : 			// Give embarkation promotion to all units who can currently embark
; 3473 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebx, ebx
	npad	15
$LL55@changeDefe:

; 3474 : 			{
; 3475 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive() && GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	ecx, DWORD PTR [ebx+eax]
	je	$LN9@changeDefe
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN29@changeDefe
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN30@changeDefe
$LN29@changeDefe:
	or	eax, -1
$LN30@changeDefe:
	cmp	eax, DWORD PTR [ebp+4]
	jne	$LN9@changeDefe

; 3476 : 				{
; 3477 : 					PromotionTypes ePromotionDefensiveEmbarkation = GET_PLAYER((PlayerTypes)iI).GetEmbarkationPromotion();

	call	?GetEmbarkationPromotion@CvPlayer@@QBE?AW4PromotionTypes@@XZ ; CvPlayer::GetEmbarkationPromotion
	mov	edi, eax

; 3478 : 
; 3479 : 					for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$225591[esp+16]
	lea	ecx, DWORD PTR [ebx+eax]
	push	edx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN9@changeDefe
	npad	3
$LL6@changeDefe:

; 3480 : 					{
; 3481 : 						// Land Unit
; 3482 : 						if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN5@changeDefe

; 3483 : 						{
; 3484 : 							// Take away old promotion and give the new one instead
; 3485 : 							if(pLoopUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_EMBARKATION()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8524
	push	eax
	mov	ecx, esi
	call	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z ; CvUnit::isHasPromotion
	test	al, al
	je	SHORT $LN2@changeDefe

; 3486 : 							{
; 3487 : 								pLoopUnit->setHasPromotion((PromotionTypes)GC.getPROMOTION_EMBARKATION(), false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8524
	push	0
	push	ecx
	mov	ecx, esi
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion

; 3488 : 								pLoopUnit->setHasPromotion(ePromotionDefensiveEmbarkation, true);

	push	1
	push	edi
	mov	ecx, esi
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
$LN2@changeDefe:

; 3489 : 							}
; 3490 : 							// Could be cleaner if add "allwater defensive promotion".  Luckily for now the only way you can get
; 3491 : 							// both is in the Polynesia scenario and this works for that
; 3492 : 							if(pLoopUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_ALLWATER_EMBARKATION()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8532
	push	edx
	mov	ecx, esi
	call	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z ; CvUnit::isHasPromotion
	test	al, al
	je	SHORT $LN5@changeDefe

; 3493 : 							{
; 3494 : 								pLoopUnit->setHasPromotion((PromotionTypes)GC.getPROMOTION_ALLWATER_EMBARKATION(), false);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8532
	push	0
	push	eax
	mov	ecx, esi
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion

; 3495 : 								pLoopUnit->setHasPromotion(ePromotionDefensiveEmbarkation, true);

	push	1
	push	edi
	mov	ecx, esi
	call	?setHasPromotion@CvUnit@@QAEXW4PromotionTypes@@_N@Z ; CvUnit::setHasPromotion
$LN5@changeDefe:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$225591[esp+16]
	add	ecx, ebx
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL6@changeDefe
$LN9@changeDefe:

; 3468 : 		{
; 3469 : 			int iLoop;
; 3470 : 			CvUnit* pLoopUnit;
; 3471 : 
; 3472 : 			// Give embarkation promotion to all units who can currently embark
; 3473 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	ebx, 63236				; 0000f704H
	cmp	ebx, 4047104				; 003dc100H
	jl	$LL55@changeDefe
	pop	edi
	pop	esi
	pop	ebx
$LN8@changeDefe:
	pop	ebp

; 3496 : 							}
; 3497 : 						}
; 3498 : 					}
; 3499 : 				}
; 3500 : 			}
; 3501 : 		}
; 3502 : 	}
; 3503 : 	CvAssert(getDefensiveEmbarkCount() >= 0);
; 3504 : }

	ret	4
?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z ENDP	; CvTeam::changeDefensiveEmbarkCount
_TEXT	ENDS
PUBLIC	?UpdateEmbarkGraphics@CvTeam@@QAEXXZ		; CvTeam::UpdateEmbarkGraphics
EXTRN	??3CvDllUnit@@SAXPAX@Z:PROC			; CvDllUnit::operator delete
EXTRN	??0CvDllUnit@@QAE@PAVCvUnit@@@Z:PROC		; CvDllUnit::CvDllUnit
EXTRN	??2CvDllUnit@@SAPAXI@Z:PROC			; CvDllUnit::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$1
__ehfuncinfo$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_iLoop$225624 = -20					; size = 4
$T235283 = -16						; size = 4
_pDllUnit$225682 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?UpdateEmbarkGraphics@CvTeam@@QAEXXZ PROC		; CvTeam::UpdateEmbarkGraphics, COMDAT
; _this$ = ecx

; 3508 : {

	push	-1
	push	__ehhandler$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 3509 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _this$[esp+40], ecx
	xor	ebp, ebp
	npad	12
$LL53@UpdateEmba:

; 3510 : 	{
; 3511 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3512 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [eax+ebp+2256], bl
	lea	edi, DWORD PTR [eax+ebp]
	je	$LN8@UpdateEmba
	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN26@UpdateEmba
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN27@UpdateEmba
$LN26@UpdateEmba:
	or	eax, -1
$LN27@UpdateEmba:
	mov	ecx, DWORD PTR _this$[esp+40]
	cmp	eax, DWORD PTR [ecx+4]
	jne	$LN8@UpdateEmba

; 3513 : 		{
; 3514 : 			int iLoop;
; 3515 : 			for(CvUnit* pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	ebx
	lea	edx, DWORD PTR _iLoop$225624[esp+44]
	push	edx
	mov	ecx, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	cmp	esi, ebx
	je	$LN8@UpdateEmba
$LL5@UpdateEmba:

; 3516 : 			{
; 3517 : 				// Land Unit
; 3518 : 				if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@UpdateEmba

; 3519 : 				{
; 3520 : 					// At sea so its graphic look needs to change too?
; 3521 : 					if(pLoopUnit->isEmbarked())

	cmp	BYTE PTR [esi+1652], bl
	je	SHORT $LN4@UpdateEmba

; 3522 : 					{
; 3523 : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T235283[esp+40], eax
	mov	DWORD PTR __$EHRec$[esp+48], ebx
	cmp	eax, ebx
	je	SHORT $LN12@UpdateEmba
	push	esi
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN13@UpdateEmba
$LN12@UpdateEmba:
	xor	esi, esi
$LN13@UpdateEmba:
	mov	DWORD PTR _pDllUnit$225682[esp+40], esi

; 3524 : 						gDLL->GameplayUnitEmbark(pDllUnit.get(), true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+624]
	push	1
	push	esi
	mov	DWORD PTR __$EHRec$[esp+56], 1
	call	edx

; 3525 : 					}

	mov	DWORD PTR __$EHRec$[esp+48], -1
	cmp	esi, ebx
	je	SHORT $LN4@UpdateEmba
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN4@UpdateEmba:
	push	ebx
	lea	edx, DWORD PTR _iLoop$225624[esp+44]
	push	edx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	cmp	esi, ebx
	jne	SHORT $LL5@UpdateEmba
$LN8@UpdateEmba:

; 3509 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	ebp, 63236				; 0000f704H
	cmp	ebp, 4047104				; 003dc100H
	jl	$LL53@UpdateEmba

; 3526 : 				}
; 3527 : 			}
; 3528 : 		}
; 3529 : 	}
; 3530 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$0:
	mov	eax, DWORD PTR $T235283[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ$1:
	lea	ecx, DWORD PTR _pDllUnit$225682[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?UpdateEmbarkGraphics@CvTeam@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateEmbarkGraphics@CvTeam@@QAEXXZ ENDP		; CvTeam::UpdateEmbarkGraphics
PUBLIC	?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::HasCommonEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv179 = 8						; size = 4
_eOtherTeam$ = 8					; size = 4
?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::HasCommonEnemy, COMDAT
; _this$ = ecx

; 3865 : 	CvTeam& kOtherTeam = GET_TEAM(eOtherTeam);
; 3866 : 	int iI;
; 3867 : 
; 3868 : 	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	mov	eax, DWORD PTR [ecx+4]
	push	ebx
	mov	ebx, DWORD PTR _eOtherTeam$[esp]
	mov	edx, ebx
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	push	esi
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	xor	edi, edi
	mov	DWORD PTR tv179[esp+12], eax
	add	esi, 2256				; 000008d0H
	npad	5
$LL37@HasCommonE:

; 3869 : 	{
; 3870 : 		CvPlayerAI& kEnemyPlayer = GET_PLAYER((PlayerTypes)iI);
; 3871 : 		TeamTypes eEnemyTeam = kEnemyPlayer.getTeam();

	mov	eax, DWORD PTR [esi-2212]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN17@HasCommonE
	mov	ebp, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebp, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp+eax*4]
	jmp	SHORT $LN18@HasCommonE
$LN17@HasCommonE:
	or	eax, -1
$LN18@HasCommonE:

; 3872 : 		if(eEnemyTeam != m_eID && eEnemyTeam != eOtherTeam)

	cmp	eax, DWORD PTR tv179[esp+12]
	je	SHORT $LN5@HasCommonE
	cmp	eax, ebx
	je	SHORT $LN5@HasCommonE

; 3873 : 		{
; 3874 : 			if(kEnemyPlayer.isAlive())

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN5@HasCommonE

; 3875 : 			{
; 3876 : 				if(kOtherTeam.isAtWar(eEnemyTeam) && isAtWar(eEnemyTeam))

	cmp	BYTE PTR [eax+edx+1928], 0
	je	SHORT $LN5@HasCommonE
	cmp	BYTE PTR [eax+ecx+1928], 0
	jne	SHORT $LN35@HasCommonE
$LN5@HasCommonE:

; 3865 : 	CvTeam& kOtherTeam = GET_TEAM(eOtherTeam);
; 3866 : 	int iI;
; 3867 : 
; 3868 : 	for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	inc	edi
	add	esi, 63236				; 0000f704H
	cmp	edi, 22					; 00000016H
	jl	SHORT $LL37@HasCommonE
	pop	edi
	pop	esi
	pop	ebp

; 3879 : 				}
; 3880 : 			}
; 3881 : 		}
; 3882 : 	}
; 3883 : 
; 3884 : 	return false;

	xor	al, al
	pop	ebx

; 3885 : }

	ret	4
$LN35@HasCommonE:
	pop	edi
	pop	esi
	pop	ebp

; 3877 : 				{
; 3878 : 					return true;

	mov	al, 1
	pop	ebx

; 3885 : }

	ret	4
?HasCommonEnemy@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::HasCommonEnemy
_TEXT	ENDS
PUBLIC	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam
EXTRN	?LogCloseEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::LogCloseEmbassy
EXTRN	?LogOpenEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::LogOpenEmbassy
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?updateDeferredFog@CvMap@@QAEXXZ:PROC		; CvMap::updateDeferredFog
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pPlot$225946 = -12					; size = 4
tv595 = -8						; size = 4
tv378 = -4						; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC	; CvTeam::SetHasEmbassyAtTeam, COMDAT
; _this$ = ecx

; 4047 : {

	sub	esp, 16					; 00000010H

; 4048 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4049 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4050 : 
; 4051 : 	if(HasEmbassyAtTeam(eIndex) != bNewValue)

	mov	al, BYTE PTR _bNewValue$[esp+12]
	push	ebp
	push	edi
	mov	edi, DWORD PTR _eIndex$[esp+20]
	mov	ebp, ecx
	mov	DWORD PTR _this$[esp+24], ebp
	cmp	BYTE PTR [edi+ebp+2088], al
	je	$LN8@SetHasEmba
	push	ebx
	push	esi

; 4052 : 	{
; 4053 : 		m_abEmbassy[eIndex] = bNewValue;
; 4054 : 		bool bRevealPlots = false;

	xor	bl, bl
	xor	esi, esi
	mov	BYTE PTR [edi+ebp+2088], al
	mov	DWORD PTR tv595[esp+32], esi
$LL26@SetHasEmba:

; 4055 : 
; 4056 : 		// find capital of team
; 4057 : 		// reveal hexes around capital
; 4058 : 		for(int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)
; 4059 : 		{
; 4060 : 			PlayerTypes ePlayer = (PlayerTypes)iPlayer;
; 4061 : 			if(GET_PLAYER(ePlayer).getTeam() == eIndex)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN42@SetHasEmba
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN43@SetHasEmba
$LN42@SetHasEmba:
	or	eax, -1
$LN43@SetHasEmba:
	cmp	eax, edi
	jne	$LN25@SetHasEmba

; 4062 : 			{
; 4063 : 				CvCity* pCity = GET_PLAYER(ePlayer).getCapitalCity();

	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 4064 : 				if(pCity)

	test	eax, eax
	je	$LN25@SetHasEmba

; 4065 : 				{
; 4066 : 					CvPlot* pPlot = pCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, eax
	mov	DWORD PTR _pPlot$225946[esp+32], edx

; 4067 : 					CvAssertMsg(pPlot, "Capital city lacks plot? How'd that happen?");
; 4068 : 					if(pPlot)

	test	edx, edx
	je	$LN25@SetHasEmba

; 4069 : 					{
; 4070 : 						const int iPopRange = 2;
; 4071 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 4072 : 						int iMaxDX, iDX;
; 4073 : 						CvPlot* pLoopPlot;
; 4074 : 						for (int iDY = -iPopRange; iDY <= iPopRange; iDY++)
; 4075 : 						{
; 4076 : 							iMaxDX = iPopRange - MAX(0, iDY);
; 4077 : 							for (iDX = -iPopRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 4078 : 							{
; 4079 : 								// No need for range check because loops are set up properly
; 4080 : 								pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 4081 : #else
; 4082 : 						for(int iDX = -(iPopRange); iDX <= iPopRange; iDX++)

	mov	ebx, -2					; fffffffeH
	lea	edi, DWORD PTR [ebx+4]
$LL125@SetHasEmba:

; 4085 : 							{
; 4086 : 								CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iPopRange);

	xor	eax, eax
	test	ebx, ebx
	setge	al
	mov	esi, -2					; fffffffeH
	lea	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR tv378[esp+32], eax
$LL127@SetHasEmba:
	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv378[esp+32], ecx
	mov	ecx, ebx
	jne	SHORT $LN55@SetHasEmba
	test	edi, edi
	jle	SHORT $LN59@SetHasEmba
	mov	ecx, edi
$LN59@SetHasEmba:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN61@SetHasEmba
	mov	eax, ebp
$LN61@SetHasEmba:
	add	eax, ecx
	jmp	SHORT $LN66@SetHasEmba
$LN55@SetHasEmba:
	test	edi, edi
	jle	SHORT $LN63@SetHasEmba
	mov	ecx, edi
$LN63@SetHasEmba:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN65@SetHasEmba
	mov	eax, ebp
$LN65@SetHasEmba:
	cmp	ecx, eax
	jl	SHORT $LN66@SetHasEmba
	mov	eax, ecx
$LN66@SetHasEmba:
	cmp	eax, 2
	jg	SHORT $LN16@SetHasEmba
	movsx	eax, WORD PTR [edx+2]
	movsx	ecx, WORD PTR [edx]
	push	esi
	push	ebx
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 4087 : #endif
; 4088 : 								if(pLoopPlot == NULL)

	test	eax, eax
	je	SHORT $LN126@SetHasEmba

; 4089 : 								{
; 4090 : 									continue;
; 4091 : 								}
; 4092 : 
; 4093 : 								pLoopPlot->setRevealed(GetID(), true);

	mov	edx, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [edx+4]
	push	-1
	push	0
	push	1
	push	ecx
	mov	ecx, eax
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
$LN126@SetHasEmba:
	mov	edx, DWORD PTR _pPlot$225946[esp+32]
$LN16@SetHasEmba:

; 4083 : 						{
; 4084 : 							for(int iDY = -(iPopRange); iDY <= iPopRange; iDY++)

	dec	ebp
	inc	esi
	cmp	ebp, -2					; fffffffeH
	jge	SHORT $LL127@SetHasEmba
	dec	edi
	inc	ebx
	cmp	edi, -2					; fffffffeH
	jge	$LL125@SetHasEmba

; 4094 : 							}
; 4095 : 						}
; 4096 : 						bRevealPlots = true;

	mov	edi, DWORD PTR _eIndex$[esp+28]
	mov	ebp, DWORD PTR _this$[esp+32]
	mov	esi, DWORD PTR tv595[esp+32]
	mov	bl, 1
$LN25@SetHasEmba:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv595[esp+32], esi
	jl	$LL26@SetHasEmba

; 4097 : 					}
; 4098 : 				}
; 4099 : 			}
; 4100 : 		}
; 4101 : 
; 4102 : 		if(bRevealPlots)

	test	bl, bl
	je	SHORT $LN13@SetHasEmba

; 4103 : 		{
; 4104 : 			GC.getMap().updateDeferredFog();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN13@SetHasEmba:

; 4105 : 		}
; 4106 : 
; 4107 : 		GC.getMap().verifyUnitValidPlot();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot

; 4108 : 
; 4109 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ebp+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN11@SetHasEmba
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN124@SetHasEmba
$LN11@SetHasEmba:

; 4110 : 		{
; 4111 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	12					; 0000000cH
	call	eax
$LN124@SetHasEmba:

; 4112 : 		}
; 4113 : 
; 4114 : 		// logging
; 4115 : 		for (uint uiMyPlayer = 0; uiMyPlayer < MAX_MAJOR_CIVS; uiMyPlayer++)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebp, ebp
	npad	2
$LL10@SetHasEmba:

; 4116 : 		{
; 4117 : 			PlayerTypes eMyPlayer = (PlayerTypes)uiMyPlayer;
; 4118 : 			if (GET_PLAYER(eMyPlayer).getTeam() == m_eID)

	mov	eax, DWORD PTR [ecx+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN88@SetHasEmba
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN89@SetHasEmba
$LN88@SetHasEmba:
	or	eax, -1
$LN89@SetHasEmba:
	mov	edx, DWORD PTR _this$[esp+32]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN9@SetHasEmba

; 4119 : 			{
; 4120 : 				for (uint uiOtherPlayer = 0; uiOtherPlayer < MAX_MAJOR_CIVS; uiOtherPlayer++)

	xor	edi, edi
	xor	esi, esi
$LL128@SetHasEmba:

; 4121 : 				{
; 4122 : 					PlayerTypes eOtherPlayer = (PlayerTypes)uiOtherPlayer;
; 4123 : 					CvPlayer& kOtherPlayer = GET_PLAYER(eOtherPlayer);
; 4124 : 					if (kOtherPlayer.getTeam() == eIndex && kOtherPlayer.isAlive())

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN99@SetHasEmba
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN100@SetHasEmba
$LN99@SetHasEmba:
	or	eax, -1
$LN100@SetHasEmba:
	cmp	eax, DWORD PTR _eIndex$[esp+28]
	jne	SHORT $LN5@SetHasEmba
	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN5@SetHasEmba

; 4125 : 					{
; 4126 : 						if (bNewValue)
; 4127 : 						{
; 4128 : 							GET_PLAYER(eMyPlayer).GetDiplomacyAI()->LogOpenEmbassy(eOtherPlayer);

	add	ecx, ebp
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	cmp	BYTE PTR _bNewValue$[esp+32], 0
	mov	ecx, eax
	je	SHORT $LN2@SetHasEmba
	call	?LogOpenEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::LogOpenEmbassy

; 4129 : 						}
; 4130 : 						else

	jmp	SHORT $LN129@SetHasEmba
$LN2@SetHasEmba:

; 4131 : 						{
; 4132 : 							GET_PLAYER(eMyPlayer).GetDiplomacyAI()->LogCloseEmbassy(eOtherPlayer);

	call	?LogCloseEmbassy@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::LogCloseEmbassy
$LN129@SetHasEmba:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN5@SetHasEmba:

; 4119 : 			{
; 4120 : 				for (uint uiOtherPlayer = 0; uiOtherPlayer < MAX_MAJOR_CIVS; uiOtherPlayer++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jb	SHORT $LL128@SetHasEmba
$LN9@SetHasEmba:

; 4112 : 		}
; 4113 : 
; 4114 : 		// logging
; 4115 : 		for (uint uiMyPlayer = 0; uiMyPlayer < MAX_MAJOR_CIVS; uiMyPlayer++)

	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	jb	$LL10@SetHasEmba
	pop	esi
	pop	ebx
$LN8@SetHasEmba:
	pop	edi
	pop	ebp

; 4133 : 						}
; 4134 : 					}
; 4135 : 				}
; 4136 : 			}
; 4137 : 		}
; 4138 : 	}
; 4139 : }

	add	esp, 16					; 00000010H
	ret	8
?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::SetHasEmbassyAtTeam
_TEXT	ENDS
PUBLIC	?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::EvacuateDiplomatsAtTeam
EXTRN	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z:PROC ; CvPlayerEspionage::MoveSpyTo
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z:PROC	; CvCivilizationInfo::getSpyNames
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z:PROC ; CvPlayerEspionage::GetSpyRankName
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z:PROC ; CvPlayerEspionage::GetSpyIndexInCity
EXTRN	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvPlayerEspionage::IsMyDiplomatVisitingThem
EXTRN	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ:PROC ; CvPlayer::GetEspionage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
xdata$x	SEGMENT
__unwindtable$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1
__ehfuncinfo$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_iPlayer2$225990 = -196					; size = 4
tv416 = -192						; size = 4
_eSpyRank$226005 = -188					; size = 4
_pNotifications$226001 = -184				; size = 4
_this$ = -180						; size = 4
_pCapitalCity$225998 = -176				; size = 4
_strNotification$226009 = -172				; size = 80
_strSummary$226006 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC ; CvTeam::EvacuateDiplomatsAtTeam, COMDAT
; _this$ = ecx

; 4143 : {

	push	-1
	push	__ehhandler$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 184				; 000000b8H
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+208], ecx

; 4144 : 	for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	xor	ebp, ebp
	npad	5
$LL69@EvacuateDi:

; 4145 : 	{
; 4146 : 		PlayerTypes ePlayer1 = (PlayerTypes)iPlayer;
; 4147 : 		if (GET_PLAYER(ePlayer1).getTeam() == m_eID)

	mov	eax, DWORD PTR [ecx+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN22@EvacuateDi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN23@EvacuateDi
$LN22@EvacuateDi:
	or	eax, -1
$LN23@EvacuateDi:
	mov	edx, DWORD PTR _this$[esp+212]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN10@EvacuateDi

; 4148 : 		{
; 4149 : 			for (int iPlayer2 = 0; iPlayer2 < MAX_MAJOR_CIVS; iPlayer2++)

	xor	esi, esi
	mov	DWORD PTR _iPlayer2$225990[esp+212], 0
	mov	DWORD PTR tv416[esp+212], esi
$LL68@EvacuateDi:

; 4150 : 			{
; 4151 : 				PlayerTypes ePlayer2 = (PlayerTypes)iPlayer2;
; 4152 : 				if (GET_PLAYER(ePlayer2).getTeam() != eIndex)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN33@EvacuateDi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN34@EvacuateDi
$LN33@EvacuateDi:
	or	eax, -1
$LN34@EvacuateDi:
	cmp	eax, DWORD PTR _eIndex$[esp+208]
	jne	$LN6@EvacuateDi

; 4153 : 				{
; 4154 : 					continue;
; 4155 : 				}
; 4156 : 
; 4157 : 				if (GET_PLAYER(ePlayer1).GetEspionage()->IsMyDiplomatVisitingThem(ePlayer2, true))

	mov	eax, DWORD PTR _iPlayer2$225990[esp+212]
	push	1
	add	ecx, ebp
	push	eax
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ; CvPlayerEspionage::IsMyDiplomatVisitingThem
	test	al, al
	je	$LN66@EvacuateDi

; 4158 : 				{
; 4159 : 					CvCity* pCapitalCity = GET_PLAYER(ePlayer2).getCapitalCity();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 4160 : 					int iSpyIndex = GET_PLAYER(ePlayer1).GetEspionage()->GetSpyIndexInCity(pCapitalCity);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	push	eax
	mov	DWORD PTR _pCapitalCity$225998[esp+216], eax
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z ; CvPlayerEspionage::GetSpyIndexInCity
	mov	edi, eax

; 4161 : 					if (iSpyIndex != -1)

	cmp	edi, -1
	je	$LN66@EvacuateDi

; 4162 : 					{
; 4163 : 						CvNotifications* pNotifications = GET_PLAYER(ePlayer1).GetNotifications();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$226001[esp+212], eax

; 4164 : 						if(pNotifications)

	test	eax, eax
	je	$LN1@EvacuateDi

; 4165 : 						{
; 4166 : 							CvPlayerEspionage* pEspionage = GET_PLAYER(ePlayer1).GetEspionage();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	esi, eax

; 4167 : 							int iSpyName = pEspionage->m_aSpyList[iSpyIndex].m_iName;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi

; 4168 : 							CvSpyRank eSpyRank = pEspionage->m_aSpyList[iSpyIndex].m_eRank;

	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	ebx, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 4169 : 							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMAT_EJECTED");

	lea	edx, DWORD PTR _strSummary$226006[esp+212]
	push	OFFSET $SG226008
	push	edx
	mov	DWORD PTR _eSpyRank$226005[esp+220], ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z

; 4170 : 							Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_DIPLOMAT_EJECTED_TT");

	lea	eax, DWORD PTR _strNotification$226009[esp+220]
	push	OFFSET $SG226011
	push	eax
	mov	DWORD PTR __$EHRec$[esp+236], 0
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 16					; 00000010H

; 4171 : 							strNotification << pEspionage->GetSpyRankName(eSpyRank);

	mov	ecx, DWORD PTR _eSpyRank$226005[esp+212]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strNotification$226009[esp+216]
	call	esi

; 4172 : 							strNotification << GET_PLAYER(ePlayer1).getCivilizationInfo().getSpyNames(iSpyName);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	push	ebx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$226009[esp+216]
	call	esi

; 4173 : 							strNotification << pCapitalCity->getNameKey();

	mov	ecx, DWORD PTR _pCapitalCity$225998[esp+212]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$226009[esp+216]
	call	esi

; 4174 : 							pNotifications->Add(NOTIFICATION_SPY_CANT_STEAL_TECH, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$226006[esp+228]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$226009[esp+232]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$226001[esp+232]
	push	eax
	push	240697813				; 0e58c1d5H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 4175 : 						}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$226009[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 0
	call	esi
	lea	ecx, DWORD PTR _strSummary$226006[esp+212]
	mov	DWORD PTR __$EHRec$[esp+220], -1
	call	esi
	mov	esi, DWORD PTR tv416[esp+212]
$LN1@EvacuateDi:

; 4176 : 						GET_PLAYER(ePlayer1).GetEspionage()->MoveSpyTo(NULL, iSpyIndex, false);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	edi
	lea	ecx, DWORD PTR [eax+ebp]
	push	0
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo
$LN66@EvacuateDi:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN6@EvacuateDi:

; 4148 : 		{
; 4149 : 			for (int iPlayer2 = 0; iPlayer2 < MAX_MAJOR_CIVS; iPlayer2++)

	inc	DWORD PTR _iPlayer2$225990[esp+212]
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv416[esp+212], esi
	jl	$LL68@EvacuateDi
$LN10@EvacuateDi:

; 4144 : 	for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)

	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	jl	$LL69@EvacuateDi

; 4177 : 					}
; 4178 : 				}
; 4179 : 			}
; 4180 : 		}
; 4181 : 	}
; 4182 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 196				; 000000c4H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _strSummary$226006[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR _strNotification$226009[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP ; CvTeam::EvacuateDiplomatsAtTeam
PUBLIC	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
EXTRN	__imp_??0String@Localization@@QAE@ABV01@@Z:PROC
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
xdata$x	SEGMENT
__unwindtable$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$3
__ehfuncinfo$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_bHasMetThisTeam$226071 = -365				; size = 1
_jPlayer$226055 = -364					; size = 4
_iPlayer$226051 = -360					; size = 4
tv600 = -356						; size = 4
_iCurPlayer$226047 = -352				; size = 4
tv584 = -348						; size = 4
tv562 = -344						; size = 4
_pNotifications$226066 = -340				; size = 4
_this$ = -336						; size = 4
_tempInfoStr$226085 = -332				; size = 80
_tempSummaryStr$226086 = -252				; size = 80
_strSummary$226044 = -172				; size = 80
_strText$226041 = -92					; size = 80
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC	; CvTeam::SetHasDefensivePact, COMDAT
; _this$ = ecx

; 4230 : {

	push	-1
	push	__ehhandler$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 356				; 00000164H
	push	ebx

; 4231 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4232 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4233 : 
; 4234 : 	if(IsHasDefensivePact(eIndex) != bNewValue)

	mov	bl, BYTE PTR _bNewValue$[esp+368]
	push	edi
	mov	edi, DWORD PTR _eIndex$[esp+372]
	mov	al, BYTE PTR [edi+ecx+2248]
	mov	DWORD PTR _this$[esp+376], ecx
	cmp	al, bl
	je	$LN19@SetHasDefe

; 4235 : 	{
; 4236 : 		m_abDefensivePact[eIndex] = bNewValue;

	mov	BYTE PTR [edi+ecx+2248], bl
	push	esi

; 4237 : 
; 4238 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN20@SetHasDefe
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN131@SetHasDefe
$LN20@SetHasDefe:

; 4239 : 		{
; 4240 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	12					; 0000000cH
	call	edx
$LN131@SetHasDefe:

; 4241 : 		}
; 4242 : #ifdef NEW_DEFENSIVE_PACT
; 4243 : 	if(bNewValue)

	test	bl, bl
	je	$LN137@SetHasDefe

; 4244 : 	{
; 4245 : 		// Someone made a Non-Aggression Pact, send out notifications to everyone
; 4246 : 		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_NON_AGGRESSION");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	push	ebp
	lea	eax, DWORD PTR _strText$226041[esp+384]
	push	OFFSET $SG226043
	push	eax
	call	esi

; 4247 : 		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_NON_AGGRESSION_S");

	lea	ecx, DWORD PTR _strSummary$226044[esp+392]
	push	OFFSET $SG226046
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+408], ebx
	call	esi
	add	esp, 16					; 00000010H
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 4248 : 		for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer)
; 4249 : 		{
; 4250 : 			for(int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; ++iPlayer)

	xor	edi, edi
	mov	BYTE PTR __$EHRec$[esp+392], 1
	mov	DWORD PTR _iCurPlayer$226047[esp+384], ebx
	mov	DWORD PTR tv600[esp+384], ebx
	mov	DWORD PTR _iPlayer$226051[esp+384], ebx
	mov	DWORD PTR tv584[esp+384], edi
	jmp	SHORT $LN15@SetHasDefe
	npad	4
$LL133@SetHasDefe:

; 4244 : 	{
; 4245 : 		// Someone made a Non-Aggression Pact, send out notifications to everyone
; 4246 : 		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_NON_AGGRESSION");

	xor	ebx, ebx

; 4248 : 		for(int iCurPlayer = 0; iCurPlayer < MAX_MAJOR_CIVS; ++iCurPlayer)
; 4249 : 		{
; 4250 : 			for(int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; ++iPlayer)

	xor	edi, edi
	mov	DWORD PTR _iPlayer$226051[esp+384], ebx
	mov	DWORD PTR tv584[esp+384], edi
	jmp	SHORT $LN15@SetHasDefe
	npad	2
$LL134@SetHasDefe:
	xor	ebx, ebx
$LN15@SetHasDefe:

; 4251 : 			{
; 4252 : 				for(int jPlayer = 0; jPlayer < MAX_MAJOR_CIVS; ++jPlayer)

	mov	DWORD PTR _jPlayer$226055[esp+384], ebx
	mov	DWORD PTR tv562[esp+384], ebx
	npad	6
$LL135@SetHasDefe:

; 4253 : 				{
; 4254 : 					if (GET_PLAYER((PlayerTypes) iPlayer).getTeam() != eIndex || GET_PLAYER((PlayerTypes) jPlayer).getTeam() != /*GetTeam()->*/GetID())

	mov	eax, DWORD PTR [edi+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN49@SetHasDefe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN50@SetHasDefe
$LN49@SetHasDefe:
	or	eax, -1
$LN50@SetHasDefe:
	cmp	eax, DWORD PTR _eIndex$[esp+380]
	jne	$LN11@SetHasDefe
	mov	eax, DWORD PTR [ebx+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN60@SetHasDefe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN61@SetHasDefe
$LN60@SetHasDefe:
	or	eax, -1
$LN61@SetHasDefe:
	mov	ecx, DWORD PTR _this$[esp+384]
	cmp	eax, DWORD PTR [ecx+4]
	jne	$LN11@SetHasDefe

; 4255 : 						continue;
; 4256 : 
; 4257 : 					PlayerTypes eCurPlayer = (PlayerTypes) iCurPlayer;
; 4258 : 					CvPlayerAI& kCurPlayer = GET_PLAYER(eCurPlayer);

	mov	eax, DWORD PTR tv600[esp+384]
	lea	esi, DWORD PTR [eax+edx]

; 4259 : 					CvNotifications* pNotifications = GET_PLAYER(eCurPlayer).GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications

; 4260 : 					if(iCurPlayer != iPlayer && iCurPlayer != jPlayer /*GetPlayer()->GetID() */&& pNotifications)

	mov	ecx, DWORD PTR _iCurPlayer$226047[esp+384]
	mov	DWORD PTR _pNotifications$226066[esp+384], eax
	cmp	ecx, DWORD PTR _iPlayer$226051[esp+384]
	je	$LN130@SetHasDefe
	cmp	ecx, DWORD PTR _jPlayer$226055[esp+384]
	je	$LN130@SetHasDefe
	test	eax, eax
	je	$LN130@SetHasDefe

; 4261 : 					{
; 4262 : 						const char* strThisPlayerName;
; 4263 : 						const char* strOtherPlayerName;
; 4264 : 
; 4265 : 						CvTeam* pCurTeam = &GET_TEAM(kCurPlayer.getTeam());

	mov	esi, DWORD PTR [esi+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN75@SetHasDefe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN76@SetHasDefe
$LN75@SetHasDefe:
	or	eax, -1
$LN76@SetHasDefe:

; 4266 : 
; 4267 : 						// Have we met these guys yet?
; 4268 : 						bool bHasMetThisTeam = pCurTeam->isHasMet(GET_PLAYER((PlayerTypes) iPlayer).getTeam());

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, eax
	mov	eax, DWORD PTR [edi+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN88@SetHasDefe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN89@SetHasDefe
$LN88@SetHasDefe:
	or	eax, -1
$LN89@SetHasDefe:
	mov	al, BYTE PTR [eax+esi+1848]
	mov	BYTE PTR _bHasMetThisTeam$226071[esp+384], al

; 4269 : 						if(bHasMetThisTeam)

	test	al, al
	je	SHORT $LN6@SetHasDefe

; 4270 : 							strThisPlayerName = GET_PLAYER((PlayerTypes) iPlayer).getCivilizationShortDescriptionKey();

	lea	ecx, DWORD PTR [edi+edx]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey

; 4271 : 						else

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, eax
	jmp	SHORT $LN5@SetHasDefe
$LN6@SetHasDefe:

; 4272 : 							strThisPlayerName = "TXT_KEY_UNMET_PLAYER";

	mov	edi, OFFSET $SG226076
$LN5@SetHasDefe:

; 4273 : 
; 4274 : 						bool bHasMetOtherTeam = pCurTeam->isHasMet(GET_PLAYER((PlayerTypes) jPlayer).getTeam());

	mov	eax, DWORD PTR [ebx+edx+44]
	lea	ecx, DWORD PTR [ebx+edx]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN105@SetHasDefe
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN106@SetHasDefe
$LN105@SetHasDefe:
	or	eax, -1
$LN106@SetHasDefe:
	mov	bl, BYTE PTR [eax+esi+1848]

; 4275 : 						if(bHasMetOtherTeam)

	test	bl, bl
	je	SHORT $LN4@SetHasDefe

; 4276 : 							strOtherPlayerName = GET_PLAYER((PlayerTypes) jPlayer).getCivilizationShortDescriptionKey();

	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey

; 4277 : 						else

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax
	jmp	SHORT $LN3@SetHasDefe
$LN4@SetHasDefe:

; 4278 : 							strOtherPlayerName = "TXT_KEY_UNMET_PLAYER";

	mov	esi, OFFSET $SG226082
$LN3@SetHasDefe:

; 4279 : 
; 4280 : 						//Only display notification if we've met one of the players.
; 4281 : 						if(bHasMetThisTeam || bHasMetOtherTeam)

	cmp	BYTE PTR _bHasMetThisTeam$226071[esp+384], 0
	jne	SHORT $LN1@SetHasDefe
	test	bl, bl
	je	$LN132@SetHasDefe
$LN1@SetHasDefe:

; 4282 : 						{
; 4283 : 							Localization::String tempInfoStr = strText;

	mov	ebx, DWORD PTR __imp_??0String@Localization@@QAE@ABV01@@Z
	lea	edx, DWORD PTR _strText$226041[esp+384]
	push	edx
	lea	ecx, DWORD PTR _tempInfoStr$226085[esp+388]
	call	ebx

; 4284 : 							tempInfoStr << strThisPlayerName << strOtherPlayerName;

	push	edi
	lea	ecx, DWORD PTR _tempInfoStr$226085[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 2
	call	ebp
	push	esi
	lea	ecx, DWORD PTR _tempInfoStr$226085[esp+388]
	call	ebp

; 4285 : 							Localization::String tempSummaryStr = strSummary;

	lea	eax, DWORD PTR _strSummary$226044[esp+384]
	push	eax
	lea	ecx, DWORD PTR _tempSummaryStr$226086[esp+388]
	call	ebx

; 4286 : 							tempSummaryStr << strThisPlayerName << strOtherPlayerName;

	push	edi
	lea	ecx, DWORD PTR _tempSummaryStr$226086[esp+388]
	mov	BYTE PTR __$EHRec$[esp+396], 3
	call	ebp
	push	esi
	lea	ecx, DWORD PTR _tempSummaryStr$226086[esp+388]
	call	ebp

; 4287 : 							pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, tempInfoStr.toUTF8(), tempSummaryStr.toUTF8(), -1, -1, (PlayerTypes) iPlayer, (PlayerTypes) jPlayer);

	mov	ecx, DWORD PTR _jPlayer$226055[esp+384]
	mov	edx, DWORD PTR _iPlayer$226051[esp+384]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	ecx
	push	edx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _tempSummaryStr$226086[esp+400]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _tempInfoStr$226085[esp+404]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$226066[esp+404]
	push	eax
	push	1319111517				; 4ea00b5dH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 4288 : 						}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _tempSummaryStr$226086[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 2
	call	esi
	lea	ecx, DWORD PTR _tempInfoStr$226085[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 1
	call	esi
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN132@SetHasDefe:
	mov	edi, DWORD PTR tv584[esp+384]
	mov	ebx, DWORD PTR tv562[esp+384]
$LN11@SetHasDefe:
	inc	DWORD PTR _jPlayer$226055[esp+384]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	mov	DWORD PTR tv562[esp+384], ebx
	jl	$LL135@SetHasDefe
	inc	DWORD PTR _iPlayer$226051[esp+384]
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	mov	DWORD PTR tv584[esp+384], edi
	jl	$LL134@SetHasDefe
	mov	eax, DWORD PTR tv600[esp+384]
	inc	DWORD PTR _iCurPlayer$226047[esp+384]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv600[esp+384], eax
	jl	$LL133@SetHasDefe

; 4289 : 					}
; 4290 : 				}
; 4291 : 			}
; 4292 : 		}
; 4293 : 	}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$226044[esp+384]
	mov	BYTE PTR __$EHRec$[esp+392], 0
	call	esi
	lea	ecx, DWORD PTR _strText$226041[esp+384]
	mov	DWORD PTR __$EHRec$[esp+392], -1
	call	esi
	pop	ebp
$LN137@SetHasDefe:
	pop	esi
$LN19@SetHasDefe:

; 4294 : #else
; 4295 : 		if(bNewValue && !GET_TEAM(eIndex).IsHasDefensivePact(GetID()))
; 4296 : 		{
; 4297 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYERS_SIGN_DEFENSIVE_PACT", getName().GetCString(), GET_TEAM(eIndex).getName().GetCString());
; 4298 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);
; 4299 : 		}
; 4300 : #endif
; 4301 : 	}
; 4302 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+376]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 368				; 00000170H
	ret	8
$LN130@SetHasDefe:

; 4288 : 						}

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	jmp	$LN11@SetHasDefe
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strText$226041[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strSummary$226044[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _tempInfoStr$226085[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z$3:
	lea	ecx, DWORD PTR _tempSummaryStr$226086[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::SetHasDefensivePact
PUBLIC	?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ	; CvTeam::GetTotalNumResearchAgreements
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ PROC	; CvTeam::GetTotalNumResearchAgreements, COMDAT
; _this$ = ecx

; 4305 : {

	push	esi

; 4306 : 	int iCount = 0;

	mov	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	xor	eax, eax

; 4307 : 
; 4308 : 	TeamTypes eLoopTeam;
; 4309 : 	for(int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	edx, edx
	add	esi, 5980				; 0000175cH
$LL5@GetTotalNu:

; 4310 : 	{
; 4311 : 		eLoopTeam = (TeamTypes) iTeamLoop;
; 4312 : 
; 4313 : 		if(GET_TEAM(eLoopTeam).isAlive())

	cmp	DWORD PTR [esi-5968], 0
	jle	SHORT $LN4@GetTotalNu

; 4314 : 		{
; 4315 : 			if(IsHasResearchAgreement(eLoopTeam))

	cmp	BYTE PTR [edx+ecx+2328], 0
	je	SHORT $LN4@GetTotalNu

; 4316 : 			{
; 4317 : 				iCount++;

	inc	eax
$LN4@GetTotalNu:

; 4310 : 	{
; 4311 : 		eLoopTeam = (TeamTypes) iTeamLoop;
; 4312 : 
; 4313 : 		if(GET_TEAM(eLoopTeam).isAlive())

	cmp	DWORD PTR [esi-2984], 0
	jle	SHORT $LN19@GetTotalNu

; 4314 : 		{
; 4315 : 			if(IsHasResearchAgreement(eLoopTeam))

	cmp	BYTE PTR [edx+ecx+2329], 0
	je	SHORT $LN19@GetTotalNu

; 4316 : 			{
; 4317 : 				iCount++;

	inc	eax
$LN19@GetTotalNu:

; 4310 : 	{
; 4311 : 		eLoopTeam = (TeamTypes) iTeamLoop;
; 4312 : 
; 4313 : 		if(GET_TEAM(eLoopTeam).isAlive())

	cmp	DWORD PTR [esi], 0
	jle	SHORT $LN20@GetTotalNu

; 4314 : 		{
; 4315 : 			if(IsHasResearchAgreement(eLoopTeam))

	cmp	BYTE PTR [edx+ecx+2330], 0
	je	SHORT $LN20@GetTotalNu

; 4316 : 			{
; 4317 : 				iCount++;

	inc	eax
$LN20@GetTotalNu:
	add	edx, 3
	add	esi, 8952				; 000022f8H
	cmp	edx, 63					; 0000003fH
	jl	SHORT $LL5@GetTotalNu
	pop	esi

; 4318 : 			}
; 4319 : 		}
; 4320 : 	}
; 4321 : 
; 4322 : 	return iCount;
; 4323 : }

	ret	0
?GetTotalNumResearchAgreements@CvTeam@@QBEHXZ ENDP	; CvTeam::GetTotalNumResearchAgreements
_TEXT	ENDS
PUBLIC	?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasResearchAgreement
EXTRN	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z:PROC ; CvGame::addReplayMessage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
__ehfuncinfo$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_strBuffer$226116 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_strLeaderName$226114 = 8				; size = 4
_eIndex$ = 8						; size = 4
_strOtherLeaderName$226115 = 12				; size = 4
_bNewValue$ = 12					; size = 1
?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::SetHasResearchAgreement, COMDAT
; _this$ = ecx

; 4336 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx

; 4337 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4338 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4339 : 
; 4340 : 	if(IsHasResearchAgreement(eIndex) != bNewValue)

	mov	bl, BYTE PTR _bNewValue$[esp+40]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eIndex$[esp+48]
	mov	esi, ecx
	mov	al, BYTE PTR [edi+esi+2328]
	cmp	al, bl
	je	$LN1@SetHasRese

; 4341 : 	{
; 4342 : 		m_abResearchAgreement[eIndex] = bNewValue;

	mov	BYTE PTR [edi+esi+2328], bl

; 4343 : 
; 4344 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	mov	ebp, DWORD PTR [esi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebp, eax
	pop	ebp
	je	SHORT $LN2@SetHasRese
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN3@SetHasRese
$LN2@SetHasRese:

; 4345 : 		{
; 4346 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	12					; 0000000cH
	call	edx
$LN3@SetHasRese:

; 4347 : 		}
; 4348 : 
; 4349 : 		if(bNewValue && !GET_TEAM(eIndex).IsHasResearchAgreement(GetID()))

	test	bl, bl
	je	$LN1@SetHasRese
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	edi, 2984				; 00000ba8H
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [edi+ecx]
	cmp	BYTE PTR [edx+eax+2328], 0
	jne	$LN1@SetHasRese

; 4350 : 		{
; 4351 : 			const char* strLeaderName = GET_PLAYER(getLeaderID()).getCivilizationShortDescriptionKey();

	mov	ecx, esi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR _strLeaderName$226114[esp+48], eax

; 4352 : 			const char* strOtherLeaderName = GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getCivilizationShortDescriptionKey();

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [edi+eax]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey

; 4353 : 
; 4354 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_RESEARCH_AGREEMENT", strLeaderName, strOtherLeaderName);

	lea	ecx, DWORD PTR _strOtherLeaderName$226115[esp+48]
	push	ecx
	lea	edx, DWORD PTR _strLeaderName$226114[esp+52]
	push	edx
	mov	DWORD PTR _strOtherLeaderName$226115[esp+56], eax
	lea	eax, DWORD PTR _strBuffer$226116[esp+60]
	push	OFFSET $SG226118
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H

; 4355 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	push	-1
	push	-1
	lea	ecx, DWORD PTR _strBuffer$226116[esp+60]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+72], 0
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 4356 : 		}

	lea	ecx, DWORD PTR _strBuffer$226116[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@SetHasRese:

; 4357 : 	}
; 4358 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$226116[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasResearchAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::SetHasResearchAgreement
PUBLIC	?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasTradeAgreement
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_strBuffer$226137 = -96					; size = 28
$T236095 = -68						; size = 28
$T236093 = -40						; size = 28
__$EHRec$ = -12						; size = 12
$T236094 = 8						; size = 4
_eIndex$ = 8						; size = 4
$T236092 = 12						; size = 4
_bNewValue$ = 12					; size = 1
?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC ; CvTeam::SetHasTradeAgreement, COMDAT
; _this$ = ecx

; 4380 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx

; 4381 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4382 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4383 : 
; 4384 : 	if(IsHasTradeAgreement(eIndex) != bNewValue)

	mov	bl, BYTE PTR _bNewValue$[esp+96]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eIndex$[esp+104]
	mov	esi, ecx
	mov	al, BYTE PTR [edi+esi+2408]
	cmp	al, bl
	je	$LN1@SetHasTrad

; 4385 : 	{
; 4386 : 		m_abTradeAgreement[eIndex] = bNewValue;

	mov	BYTE PTR [edi+esi+2408], bl

; 4387 : 
; 4388 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	mov	ebp, DWORD PTR [esi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebp, eax
	pop	ebp
	je	SHORT $LN2@SetHasTrad
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN3@SetHasTrad
$LN2@SetHasTrad:

; 4389 : 		{
; 4390 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	12					; 0000000cH
	call	edx
$LN3@SetHasTrad:

; 4391 : 		}
; 4392 : 
; 4393 : 		if(bNewValue && !GET_TEAM(eIndex).IsHasTradeAgreement(GetID()))

	test	bl, bl
	je	$LN1@SetHasTrad
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	edi, 2984				; 00000ba8H
	mov	eax, DWORD PTR [esi+4]
	add	ecx, edi
	cmp	BYTE PTR [ecx+eax+2408], 0
	jne	$LN1@SetHasTrad

; 4394 : 		{
; 4395 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYERS_SIGN_TRADE_AGREEMENT", getName().GetCString(), GET_TEAM(eIndex).getName().GetCString());

	lea	edx, DWORD PTR $T236093[esp+108]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236092[esp+104], eax
	lea	eax, DWORD PTR $T236095[esp+108]
	push	eax
	mov	ecx, esi
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+116], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR $T236092[esp+104]
	push	ecx
	lea	edx, DWORD PTR $T236094[esp+108]
	push	edx
	mov	DWORD PTR $T236094[esp+112], eax
	lea	eax, DWORD PTR _strBuffer$226137[esp+116]
	push	OFFSET $SG226143
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T236095[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T236093[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4396 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	push	-1
	push	-1
	lea	ecx, DWORD PTR _strBuffer$226137[esp+116]
	push	ecx
	mov	ecx, esi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 4397 : 		}

	lea	ecx, DWORD PTR _strBuffer$226137[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@SetHasTrad:

; 4398 : 	}
; 4399 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR $T236093[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR $T236095[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _strBuffer$226137[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasTradeAgreement@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP ; CvTeam::SetHasTradeAgreement
PUBLIC	?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::changeObsoleteBuildingCount
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z:PROC ; CvCity::processBuilding
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iLoop$ = 12						; size = 4
_iChange$ = 12						; size = 4
?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z PROC ; CvTeam::changeObsoleteBuildingCount, COMDAT
; _this$ = ecx

; 4973 : 	CvCity* pLoopCity;
; 4974 : 	bool bOldObsoleteBuilding;
; 4975 : 	int iLoop;
; 4976 : 	int iI;
; 4977 : 
; 4978 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4979 : 	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4980 : 
; 4981 : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	push	ebp
	mov	ebp, ecx
	test	edx, edx
	je	$LN7@changeObso

; 4982 : 	{
; 4983 : 		bOldObsoleteBuilding = isObsoleteBuilding(eIndex);

	mov	eax, DWORD PTR [ebp+2936]
	push	edi
	mov	edi, DWORD PTR _eIndex$[esp+4]
	mov	ecx, DWORD PTR [eax+edi*4]

; 4984 : 
; 4985 : 		m_paiObsoleteBuildingCount[eIndex] = (m_paiObsoleteBuildingCount[eIndex] + iChange);

	add	DWORD PTR [eax+edi*4], edx

; 4986 : 		CvAssert(getObsoleteBuildingCount(eIndex) >= 0);
; 4987 : 
; 4988 : 		if(bOldObsoleteBuilding != isObsoleteBuilding(eIndex))

	mov	edx, DWORD PTR [ebp+2936]
	cmp	DWORD PTR [edx+edi*4], 0
	lea	eax, DWORD PTR [eax+edi*4]
	setg	al
	test	ecx, ecx
	setg	cl
	cmp	cl, al
	je	$LN57@changeObso
	push	ebx
	push	esi

; 4989 : 		{
; 4990 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebx, ebx
$LL56@changeObso:

; 4991 : 			{
; 4992 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [ebx+edx+2256], 0
	lea	ecx, DWORD PTR [ebx+edx]
	je	$LN8@changeObso

; 4993 : 				{
; 4994 : 					if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN36@changeObso
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN37@changeObso
$LN36@changeObso:
	or	eax, -1
$LN37@changeObso:
	cmp	eax, DWORD PTR [ebp+4]
	jne	$LN8@changeObso

; 4995 : 					{
; 4996 : 						for(pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN8@changeObso
	npad	4
$LL4@changeObso:

; 4997 : 						{
; 4998 : 							if(pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex) > 0)

	push	edi
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN3@changeObso

; 4999 : 							{
; 5000 : 								pLoopCity->processBuilding(eIndex, ((isObsoleteBuilding(eIndex)) ? -pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex) : pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex)), /*bFirst*/ false, /*bObsolete*/ true);

	mov	ecx, DWORD PTR [ebp+2936]
	cmp	DWORD PTR [ecx+edi*4], 0
	push	edi
	mov	ecx, esi
	jle	SHORT $LN14@changeObso
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	neg	eax
	jmp	SHORT $LN15@changeObso
$LN14@changeObso:
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
$LN15@changeObso:
	push	0
	push	1
	push	0
	push	eax
	push	edi
	mov	ecx, esi
	call	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z ; CvCity::processBuilding
$LN3@changeObso:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+16]
	lea	ecx, DWORD PTR [ebx+edx]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL4@changeObso
$LN8@changeObso:

; 4989 : 		{
; 4990 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	add	ebx, 63236				; 0000f704H
	cmp	ebx, 4047104				; 003dc100H
	jl	$LL56@changeObso
	pop	esi
	pop	ebx
$LN57@changeObso:
	pop	edi
$LN7@changeObso:
	pop	ebp

; 5001 : 							}
; 5002 : 						}
; 5003 : 					}
; 5004 : 				}
; 5005 : 			}
; 5006 : 		}
; 5007 : 	}
; 5008 : }

	ret	8
?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z ENDP ; CvTeam::changeObsoleteBuildingCount
_TEXT	ENDS
PUBLIC	?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::enhanceBuilding
EXTRN	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z:PROC ; CvCity::ChangeBaseYieldRateFromBuildings
EXTRN	?ChangeFaithPerTurnFromBuildings@CvCity@@QAEXH@Z:PROC ; CvCity::ChangeFaithPerTurnFromBuildings
EXTRN	?ChangeJONSCulturePerTurnFromBuildings@CvCity@@QAEXH@Z:PROC ; CvCity::ChangeJONSCulturePerTurnFromBuildings
EXTRN	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetTechEnhancedYieldChange
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
; Function compile flags: /Ogtpy
;	COMDAT ?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_kPlayer$226451 = -8					; size = 4
_iLoop$ = -4						; size = 4
_eIndex$ = 8						; size = 4
tv258 = 12						; size = 4
_iChange$ = 12						; size = 4
?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z PROC	; CvTeam::enhanceBuilding, COMDAT
; _this$ = ecx

; 5013 : {

	sub	esp, 12					; 0000000cH

; 5014 : 	CvCity* pLoopCity;
; 5015 : 	int iLoop;
; 5016 : 
; 5017 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5018 : 	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5019 : 
; 5020 : 	CvBuildingEntry* thisBuildingEntry = GC.getBuildingInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[esp+8]
	push	ebx
	mov	DWORD PTR _this$[esp+16], ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebx, eax

; 5021 : 	if(thisBuildingEntry == NULL)

	test	ebx, ebx
	je	$LN14@enhanceBui
	push	ebp

; 5022 : 		return;
; 5023 : 
; 5024 : 	if(iChange != 0)

	mov	ebp, DWORD PTR _iChange$[esp+16]
	test	ebp, ebp
	je	$LN46@enhanceBui
	push	esi

; 5025 : 	{
; 5026 : 		for(int i = 0; i < MAX_PLAYERS; i++)

	xor	esi, esi
	push	edi
	mov	DWORD PTR tv258[esp+24], esi
	npad	10
$LL45@enhanceBui:

; 5027 : 		{
; 5028 : 			CvPlayerAI& kPlayer = GET_PLAYER(static_cast<PlayerTypes>(i));

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, ecx

; 5029 : 
; 5030 : 			if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+2256], 0
	mov	DWORD PTR _kPlayer$226451[esp+28], esi
	je	$LN15@enhanceBui

; 5031 : 			{
; 5032 : 				if(kPlayer.getTeam() == GetID())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN31@enhanceBui
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN32@enhanceBui
$LN31@enhanceBui:
	or	eax, -1
$LN32@enhanceBui:
	mov	edx, DWORD PTR _this$[esp+28]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN15@enhanceBui

; 5033 : 				{
; 5034 : 					for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+32]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN15@enhanceBui
$LL11@enhanceBui:

; 5035 : 					{
; 5036 : 						if(pLoopCity->GetCityBuildings()->GetNumBuilding(eIndex) > 0)

	mov	ecx, DWORD PTR _eIndex$[esp+24]
	push	ecx
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN10@enhanceBui

; 5037 : 						{
; 5038 : 							for(int k = 0; k < NUM_YIELD_TYPES; k++)

	xor	esi, esi
	npad	4
$LL7@enhanceBui:

; 5039 : 							{
; 5040 : 								if((YieldTypes)k == YIELD_CULTURE)
; 5041 : 								{
; 5042 : 									pLoopCity->ChangeJONSCulturePerTurnFromBuildings(thisBuildingEntry->GetTechEnhancedYieldChange(k) * iChange);

	mov	ecx, ebx
	cmp	esi, 4
	jne	SHORT $LN4@enhanceBui
	push	esi
	call	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
	imul	eax, ebp
	push	eax
	mov	ecx, edi
	call	?ChangeJONSCulturePerTurnFromBuildings@CvCity@@QAEXH@Z ; CvCity::ChangeJONSCulturePerTurnFromBuildings
	jmp	SHORT $LN6@enhanceBui
$LN4@enhanceBui:

; 5043 : 								}
; 5044 : 								else if((YieldTypes)k == YIELD_FAITH)

	cmp	esi, 5
	jne	SHORT $LN2@enhanceBui

; 5045 : 								{
; 5046 : 									pLoopCity->ChangeFaithPerTurnFromBuildings(thisBuildingEntry->GetTechEnhancedYieldChange(k) * iChange);

	push	esi
	call	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
	imul	eax, ebp
	push	eax
	mov	ecx, edi
	call	?ChangeFaithPerTurnFromBuildings@CvCity@@QAEXH@Z ; CvCity::ChangeFaithPerTurnFromBuildings

; 5047 : 								}
; 5048 : 								else

	jmp	SHORT $LN6@enhanceBui
$LN2@enhanceBui:

; 5049 : 								{
; 5050 : 									pLoopCity->ChangeBaseYieldRateFromBuildings(((YieldTypes)k), thisBuildingEntry->GetTechEnhancedYieldChange(k) * iChange);

	push	esi
	call	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
	imul	eax, ebp
	push	eax
	push	esi
	mov	ecx, edi
	call	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromBuildings
$LN6@enhanceBui:
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL7@enhanceBui

; 5037 : 						{
; 5038 : 							for(int k = 0; k < NUM_YIELD_TYPES; k++)

	mov	esi, DWORD PTR _kPlayer$226451[esp+28]
$LN10@enhanceBui:

; 5033 : 				{
; 5034 : 					for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+32]
	push	edx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL11@enhanceBui
$LN15@enhanceBui:

; 5025 : 	{
; 5026 : 		for(int i = 0; i < MAX_PLAYERS; i++)

	mov	esi, DWORD PTR tv258[esp+24]
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	mov	DWORD PTR tv258[esp+24], esi
	jl	$LL45@enhanceBui
	pop	edi
	pop	esi
$LN46@enhanceBui:
	pop	ebp
$LN14@enhanceBui:
	pop	ebx

; 5051 : 								}
; 5052 : 							}
; 5053 : 						}
; 5054 : 					}
; 5055 : 				}
; 5056 : 			}
; 5057 : 		}
; 5058 : 	}
; 5059 : }

	add	esp, 12					; 0000000cH
	ret	8
?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z ENDP	; CvTeam::enhanceBuilding
_TEXT	ENDS
PUBLIC	?GetScore@CvTeam@@QBEHXZ			; CvTeam::GetScore
EXTRN	?GetScore@CvPlayer@@QBEH_N0@Z:PROC		; CvPlayer::GetScore
; Function compile flags: /Ogtpy
;	COMDAT ?GetScore@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetScore@CvTeam@@QBEHXZ PROC				; CvTeam::GetScore, COMDAT
; _this$ = ecx

; 5252 : {

	push	ebx
	push	esi
	push	edi

; 5253 : 	int iScore = 0;

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	7
$LL4@GetScore:

; 5254 : 
; 5255 : 	// Sum up score for all players
; 5256 : 	PlayerTypes ePlayer;
; 5257 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 5258 : 	{
; 5259 : 		ePlayer = (PlayerTypes) iPlayerLoop;
; 5260 : 
; 5261 : 		if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@GetScore
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN14@GetScore
$LN13@GetScore:
	or	eax, -1
$LN14@GetScore:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN3@GetScore

; 5262 : 		{
; 5263 : 			iScore += GET_PLAYER(ePlayer).GetScore();

	push	0
	push	0
	call	?GetScore@CvPlayer@@QBEH_N0@Z		; CvPlayer::GetScore
	add	edi, eax
$LN3@GetScore:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL4@GetScore

; 5264 : 		}
; 5265 : 	}
; 5266 : 
; 5267 : 	return iScore;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 5268 : }

	ret	0
?GetScore@CvTeam@@QBEHXZ ENDP				; CvTeam::GetScore
_TEXT	ENDS
PUBLIC	?DoTestSmallAwards@CvTeam@@QAEXXZ		; CvTeam::DoTestSmallAwards
EXTRN	?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ:PROC ; CvSmallAwardInfo::GetTeamNotificationString
EXTRN	?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ:PROC ; CvSmallAwardInfo::GetNotificationString
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ:PROC ; CvSmallAwardInfo::GetCityPopulation
EXTRN	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ:PROC ; CvSmallAwardInfo::GetNumVictoryPoints
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetNumCities@CvSmallAwardInfo@@QBEHXZ:PROC	; CvSmallAwardInfo::GetNumCities
EXTRN	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z:PROC ; CvGlobals::getSmallAwardInfo
EXTRN	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumSmallAwardInfos
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoTestSmallAwards@CvTeam@@QAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?DoTestSmallAwards@CvTeam@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoTestSmallAwards@CvTeam@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoTestSmallAwards@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_bShouldShowNotification$ = -177			; size = 1
_this$ = -176						; size = 4
$T236368 = -172						; size = 4
$T236364 = -172						; size = 4
_iSmallAwardLoop$226610 = -172				; size = 4
_iNotificationData$ = -168				; size = 4
_iNotificationX$ = -164					; size = 4
_iNotificationY$ = -160					; size = 4
_iCityLoop$ = -156					; size = 4
$T236370 = -152						; size = 28
$T236367 = -152						; size = 28
$T236365 = -152						; size = 28
_strSummary$226639 = -124				; size = 28
_strBuffer$226638 = -96					; size = 28
$T236369 = -68						; size = 28
$T236366 = -68						; size = 28
$T236371 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?DoTestSmallAwards@CvTeam@@QAEXXZ PROC			; CvTeam::DoTestSmallAwards, COMDAT
; _this$ = ecx

; 5285 : {

	push	-1
	push	__ehhandler$?DoTestSmallAwards@CvTeam@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	esi
	mov	esi, ecx

; 5286 : 	if(!isAlive() || isMinorCiv())

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR _this$[esp+184], esi
	jle	$LN30@DoTestSmal
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	$LN30@DoTestSmal
	push	ebp

; 5287 : 	{
; 5288 : 		return;
; 5289 : 	}
; 5290 : 
; 5291 : 	int iPlayerLoop;
; 5292 : 	PlayerTypes ePlayer;
; 5293 : 
; 5294 : 	CvCity* pLoopCity;
; 5295 : 	int iCityLoop;
; 5296 : 
; 5297 : 	int iAwardRequirement;
; 5298 : 
; 5299 : 	bool bShouldShowNotification;
; 5300 : 	int iNotificationData;
; 5301 : 	int iNotificationX, iNotificationY;
; 5302 : 
; 5303 : #ifdef AUI_WARNING_FIXES
; 5304 : 	for (uint iSmallAwardLoop = 0; iSmallAwardLoop < GC.getNumSmallAwardInfos(); iSmallAwardLoop++)
; 5305 : #else
; 5306 : 	for(int iSmallAwardLoop = 0; iSmallAwardLoop < GC.getNumSmallAwardInfos(); iSmallAwardLoop++)

	xor	ebp, ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSmallAwardLoop$226610[esp+188], ebp
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	test	eax, eax
	jle	$LN195@DoTestSmal
	push	ebx
	push	edi
	jmp	SHORT $LN29@DoTestSmal
$LL193@DoTestSmal:
	mov	esi, DWORD PTR _this$[esp+196]
$LN29@DoTestSmal:

; 5307 : #endif
; 5308 : 	{
; 5309 : 		SmallAwardTypes eAward = static_cast<SmallAwardTypes>(iSmallAwardLoop);
; 5310 : 		CvSmallAwardInfo* pkSmallAwardInfo = GC.getSmallAwardInfo(eAward);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ; CvGlobals::getSmallAwardInfo
	mov	edi, eax

; 5311 : 		if(pkSmallAwardInfo)

	test	edi, edi
	je	$LN28@DoTestSmal

; 5312 : 		{
; 5313 : 			bShouldShowNotification = false;
; 5314 : 			iNotificationX = -1;

	or	eax, -1
	mov	DWORD PTR _iNotificationX$[esp+196], eax

; 5315 : 			iNotificationY = -1;

	mov	DWORD PTR _iNotificationY$[esp+196], eax

; 5316 : 
; 5317 : 			if(!IsSmallAwardAchieved(eAward))

	mov	eax, DWORD PTR [esi+2904]
	cmp	BYTE PTR [eax+ebp], 0
	mov	BYTE PTR _bShouldShowNotification$[esp+196], 0
	jne	$LN28@DoTestSmal

; 5318 : 			{
; 5319 : 				// Cities
; 5320 : #ifdef AUI_WARNING_FIXES
; 5321 : 				iAwardRequirement = pkSmallAwardInfo->GetNumCities();
; 5322 : #else
; 5323 : 				iAwardRequirement = GC.getSmallAwardInfo(eAward)->GetNumCities();

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ; CvGlobals::getSmallAwardInfo
	mov	ecx, eax
	call	?GetNumCities@CvSmallAwardInfo@@QBEHXZ	; CvSmallAwardInfo::GetNumCities
	mov	ebx, eax

; 5324 : #endif
; 5325 : 				if(iAwardRequirement > 0)

	test	ebx, ebx
	jle	$LN190@DoTestSmal

; 5326 : 				{
; 5327 : 					for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	npad	3
$LL23@DoTestSmal:

; 5328 : 					{
; 5329 : 						ePlayer = (PlayerTypes) iPlayerLoop;
; 5330 : 
; 5331 : 						if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+esi+44]
	add	ecx, esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN52@DoTestSmal
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN53@DoTestSmal
$LN52@DoTestSmal:
	or	eax, -1
$LN53@DoTestSmal:
	mov	edx, DWORD PTR _this$[esp+196]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN22@DoTestSmal

; 5332 : 						{
; 5333 : 							if(GET_PLAYER(ePlayer).getNumCities() >= iAwardRequirement)

	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, ebx
	jl	SHORT $LN22@DoTestSmal

; 5334 : 							{
; 5335 : 								SetSmallAwardAchieved(eAward, true);

	mov	eax, DWORD PTR _this$[esp+196]
	mov	ecx, DWORD PTR [eax+2904]
	mov	BYTE PTR [ecx+ebp], 1

; 5336 : #ifdef AUI_WARNING_FIXES
; 5337 : 								changeVictoryPoints(pkSmallAwardInfo->GetNumVictoryPoints());
; 5338 : #else
; 5339 : 								changeVictoryPoints(GC.getSmallAwardInfo(eAward)->GetNumVictoryPoints());

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSmallAwardInfo@CvGlobals@@QAEPAVCvSmallAwardInfo@@W4SmallAwardTypes@@@Z ; CvGlobals::getSmallAwardInfo
	mov	ecx, eax
	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	test	eax, eax
	je	SHORT $LN63@DoTestSmal
	mov	ecx, DWORD PTR _this$[esp+196]
	add	DWORD PTR [ecx+92], eax
$LN63@DoTestSmal:

; 5340 : #endif
; 5341 : 
; 5342 : 								bShouldShowNotification = true;
; 5343 : 								iNotificationData = iAwardRequirement;
; 5344 : 
; 5345 : 								if(GET_PLAYER(ePlayer).getCapitalCity() != NULL)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	mov	BYTE PTR _bShouldShowNotification$[esp+196], 1
	mov	DWORD PTR _iNotificationData$[esp+196], ebx
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN22@DoTestSmal

; 5346 : 								{
; 5347 : 									iNotificationX = GET_PLAYER(ePlayer).getCapitalCity()->getX();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, DWORD PTR [eax+96]

; 5348 : 									iNotificationY = GET_PLAYER(ePlayer).getCapitalCity()->getY();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _iNotificationX$[esp+196], ecx
	lea	ecx, DWORD PTR [esi+edx]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	eax, DWORD PTR [eax+108]
	mov	DWORD PTR _iNotificationY$[esp+196], eax
$LN22@DoTestSmal:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jl	$LL23@DoTestSmal
$LN190@DoTestSmal:

; 5349 : 								}
; 5350 : 							}
; 5351 : 						}
; 5352 : 					}
; 5353 : 				}
; 5354 : 
; 5355 : 				// Population
; 5356 : 				iAwardRequirement = pkSmallAwardInfo->GetCityPopulation();

	mov	ecx, edi
	call	?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetCityPopulation
	mov	ebx, eax

; 5357 : 				if(iAwardRequirement > 0)

	test	ebx, ebx
	jle	$LN14@DoTestSmal

; 5358 : 				{
; 5359 : 					for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	ebp, ebp
	npad	4
$LL16@DoTestSmal:

; 5360 : 					{
; 5361 : 						ePlayer = (PlayerTypes) iPlayerLoop;
; 5362 : 
; 5363 : 						if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+ebp+44]
	add	ecx, ebp
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN86@DoTestSmal
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN87@DoTestSmal
$LN86@DoTestSmal:
	or	eax, -1
$LN87@DoTestSmal:
	mov	edx, DWORD PTR _this$[esp+196]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN15@DoTestSmal

; 5364 : 						{
; 5365 : 							// Check all Cities
; 5366 : 							for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+200]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN15@DoTestSmal
	npad	3
$LL12@DoTestSmal:

; 5367 : 							{
; 5368 : 								if(pLoopCity->getPopulation() >= iAwardRequirement)

	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, ebx
	jl	SHORT $LN11@DoTestSmal

; 5369 : 								{
; 5370 : 									SetSmallAwardAchieved(eAward, true);

	mov	ecx, DWORD PTR _this$[esp+196]
	mov	edx, DWORD PTR [ecx+2904]
	mov	eax, DWORD PTR _iSmallAwardLoop$226610[esp+196]

; 5371 : 									changeVictoryPoints(pkSmallAwardInfo->GetNumVictoryPoints());

	mov	ecx, edi
	mov	BYTE PTR [eax+edx], 1
	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	test	eax, eax
	je	SHORT $LN99@DoTestSmal
	mov	ecx, DWORD PTR _this$[esp+196]
	add	DWORD PTR [ecx+92], eax
$LN99@DoTestSmal:

; 5372 : 
; 5373 : 									bShouldShowNotification = true;
; 5374 : 									iNotificationData = iAwardRequirement;
; 5375 : 									iNotificationX = pLoopCity->getX();

	mov	ecx, DWORD PTR [esi+96]

; 5376 : 									iNotificationY = pLoopCity->getY();

	mov	edx, DWORD PTR [esi+108]
	mov	BYTE PTR _bShouldShowNotification$[esp+196], 1
	mov	DWORD PTR _iNotificationData$[esp+196], ebx
	mov	DWORD PTR _iNotificationX$[esp+196], ecx
	mov	DWORD PTR _iNotificationY$[esp+196], edx
$LN11@DoTestSmal:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+200]
	lea	ecx, DWORD PTR [eax+ebp]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL12@DoTestSmal
$LN15@DoTestSmal:

; 5358 : 				{
; 5359 : 					for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	jl	$LL16@DoTestSmal
	mov	ebp, DWORD PTR _iSmallAwardLoop$226610[esp+196]
$LN14@DoTestSmal:

; 5377 : 								}
; 5378 : 							}
; 5379 : 						}
; 5380 : 					}
; 5381 : 				}
; 5382 : 
; 5383 : 				// Give notification to all players on this team
; 5384 : 				if(bShouldShowNotification)

	cmp	BYTE PTR _bShouldShowNotification$[esp+196], 0
	je	$LN28@DoTestSmal

; 5385 : 				{
; 5386 : 					CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$226638[esp+196]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebx, ebx

; 5387 : 					CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$226639[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+204], 1
	npad	10
$LL7@DoTestSmal:

; 5388 : 					for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 5389 : 					{
; 5390 : 						ePlayer = (PlayerTypes) iPlayerLoop;
; 5391 : 
; 5392 : 						if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN122@DoTestSmal
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN123@DoTestSmal
$LN122@DoTestSmal:
	or	eax, -1
$LN123@DoTestSmal:
	mov	edx, DWORD PTR _this$[esp+196]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN6@DoTestSmal

; 5393 : 						{
; 5394 : 							CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 5395 : 							if(pNotifications)

	test	esi, esi
	je	$LN6@DoTestSmal

; 5396 : 							{
; 5397 : 								if(getNumMembers() == 1)

	mov	eax, DWORD PTR _this$[esp+196]
	cmp	DWORD PTR [eax+8], 1

; 5398 : 								{
; 5399 : 									strBuffer = GetLocalizedText(pkSmallAwardInfo->GetNotificationString(), iNotificationData, pkSmallAwardInfo->GetNumVictoryPoints());

	mov	ecx, edi
	jne	$LN2@DoTestSmal
	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	lea	ecx, DWORD PTR $T236365[esp+196]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T236364[esp+200], eax
	call	?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ; CvSmallAwardInfo::GetNotificationString
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+204], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	edx, DWORD PTR $T236364[esp+196]
	push	edx
	lea	ecx, DWORD PTR _iNotificationData$[esp+200]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T236366[esp+208]
	push	edx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$226638[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236366[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T236365[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5400 : 									strSummary = GetLocalizedText(pkSmallAwardInfo->GetDescription());

	lea	ecx, DWORD PTR [edi+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T236367[esp+200]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$226639[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236367[esp+196]

; 5401 : 								}
; 5402 : 								// Team game, different string
; 5403 : 								else

	jmp	$LN197@DoTestSmal
$LN2@DoTestSmal:

; 5404 : 								{
; 5405 : 									strBuffer = GetLocalizedText(pkSmallAwardInfo->GetTeamNotificationString(), iNotificationData, pkSmallAwardInfo->GetNumVictoryPoints());

	call	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ; CvSmallAwardInfo::GetNumVictoryPoints
	lea	ecx, DWORD PTR $T236369[esp+196]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T236368[esp+200], eax
	call	?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ; CvSmallAwardInfo::GetTeamNotificationString
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+204], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	edx, DWORD PTR $T236368[esp+196]
	push	edx
	lea	ecx, DWORD PTR _iNotificationData$[esp+200]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T236370[esp+208]
	push	edx
	call	??$GetLocalizedText@HH@@YA?AVCvString@@PBDABH1@Z ; GetLocalizedText<int,int>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$226638[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236370[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T236369[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5406 : 									strSummary = GetLocalizedText(pkSmallAwardInfo->GetDescription());

	lea	ecx, DWORD PTR [edi+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T236371[esp+200]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$226639[esp+200]
	mov	BYTE PTR __$EHRec$[esp+208], 7
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236371[esp+196]
$LN197@DoTestSmal:
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5407 : 								}
; 5408 : 								pNotifications->Add(NOTIFICATION_VICTORY, strBuffer, strSummary, iNotificationX, iNotificationY, -1);

	lea	ecx, DWORD PTR _strSummary$226639[esp+196]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _iNotificationY$[esp+196]
	mov	edx, DWORD PTR _iNotificationX$[esp+196]
	push	-1
	push	-1
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strBuffer$226638[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1482916943				; 5863844fH
	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN6@DoTestSmal:
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	jl	$LL7@DoTestSmal

; 5409 : 							}
; 5410 : 						}
; 5411 : 					}
; 5412 : 				}

	lea	ecx, DWORD PTR _strSummary$226639[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$226638[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN28@DoTestSmal:
	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSmallAwardLoop$226610[esp+196], ebp
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	cmp	ebp, eax
	jl	$LL193@DoTestSmal
	pop	edi
	pop	ebx
$LN195@DoTestSmal:
	pop	ebp
$LN30@DoTestSmal:

; 5413 : 			}
; 5414 : 		}
; 5415 : 	}
; 5416 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+184]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 180				; 000000b4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$226638[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$226639[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T236365[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T236366[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T236367[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T236369[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T236370[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTestSmallAwards@CvTeam@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T236371[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoTestSmallAwards@CvTeam@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTestSmallAwards@CvTeam@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTestSmallAwards@CvTeam@@QAEXXZ ENDP			; CvTeam::DoTestSmallAwards
PUBLIC	?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ; CvTeam::announceTechToPlayers
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z$0
__ehfuncinfo$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
_szTechTextKey$ = -44					; size = 4
_strBuffer$226691 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_bSound$ = 8						; size = 1
_eIndex$ = 8						; size = 4
_bPartial$ = 12						; size = 1
?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z PROC ; CvTeam::announceTechToPlayers, COMDAT
; _this$ = ecx

; 5440 : {

	push	-1
	push	__ehhandler$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H

; 5441 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[esp+44]
	mov	DWORD PTR _this$[esp+48], ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 5442 : 	if(pkTechInfo == NULL)

	test	eax, eax
	je	$LN3@announceTe

; 5443 : 		return;
; 5444 : 
; 5445 : 	const char* szTechTextKey = pkTechInfo->GetTextKey();

	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey

; 5446 : 
; 5447 : 	bool bSound = (GC.getGame().isNetworkMultiPlayer() && !bPartial);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _szTechTextKey$[esp+48], eax
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	je	SHORT $LN9@announceTe
	cmp	BYTE PTR _bPartial$[esp+44], 0
	mov	BYTE PTR _bSound$[esp+44], 1
	je	SHORT $LN10@announceTe
$LN9@announceTe:
	mov	BYTE PTR _bSound$[esp+44], 0
$LN10@announceTe:
	push	ebx
	push	ebp
	push	esi

; 5448 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebx, ebx
	push	edi
	xor	ebp, ebp
	npad	11
$LL49@announceTe:

; 5449 : 	{
; 5450 : 		const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
; 5451 : 		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
; 5452 : 
; 5453 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [eax+ebp+2256], 0
	je	$LN4@announceTe
	mov	eax, DWORD PTR [eax+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN28@announceTe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN29@announceTe
$LN28@announceTe:
	or	eax, -1
$LN29@announceTe:
	mov	ecx, DWORD PTR _this$[esp+64]
	cmp	eax, DWORD PTR [ecx+4]
	jne	$LN4@announceTe

; 5454 : 		{
; 5455 : 			if(ePlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebx, eax
	jne	$LN4@announceTe

; 5456 : 			{
; 5457 : 				CvString strBuffer = GetLocalizedText((bPartial ? "TXT_KEY_MISC_PROGRESS_TOWARDS_TECH" : "TXT_KEY_MISC_YOU_DISCOVERED_TECH"), szTechTextKey);

	cmp	BYTE PTR _bPartial$[esp+60], 0
	mov	eax, OFFSET $SG226693
	jne	SHORT $LN12@announceTe
	mov	eax, OFFSET $SG226694
$LN12@announceTe:
	mov	edx, DWORD PTR _szTechTextKey$[esp+64]
	push	edx
	push	eax
	lea	eax, DWORD PTR _strBuffer$226691[esp+72]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH

; 5458 : 				DLLUI->AddMessage(0, ePlayer, false, (bSound ? GC.getEVENT_MESSAGE_TIME() : -1), strBuffer/*, (bSound ? GC.getTechInfo(eIndex)->GetSoundMP() : NULL), MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_TECH_TEXT")*/);

	cmp	BYTE PTR _bSound$[esp+60], 0
	mov	DWORD PTR __$EHRec$[esp+72], 0
	je	SHORT $LN13@announceTe
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	jmp	SHORT $LN14@announceTe
$LN13@announceTe:
	or	edi, -1
$LN14@announceTe:
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$226691[esp+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	0
	mov	edx, DWORD PTR [esi]
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR [edx+160]
	push	edi
	push	0
	push	ebx
	push	0
	mov	ecx, esi
	call	eax

; 5459 : 			}

	lea	ecx, DWORD PTR _strBuffer$226691[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@announceTe:
	add	ebp, 63236				; 0000f704H
	inc	ebx
	cmp	ebp, 4047104				; 003dc100H
	jl	$LL49@announceTe
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@announceTe:

; 5460 : 		}
; 5461 : 	}
; 5462 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$226691[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ENDP ; CvTeam::announceTechToPlayers
PUBLIC	?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z PROC ; CvTeam::changeImprovementYieldChange, COMDAT
; _this$ = ecx

; 6186 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6187 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6188 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6189 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6190 : 
; 6191 : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@changeImpr

; 6192 : 	{
; 6193 : 		m_ppaaiImprovementYieldChange[eIndex1][eIndex2] = (m_ppaaiImprovementYieldChange[eIndex1][eIndex2] + iChange);

	mov	eax, DWORD PTR [ecx+2948]
	push	esi
	mov	esi, DWORD PTR _eIndex1$[esp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR _eIndex2$[esp]
	add	DWORD PTR [eax+esi*4], edx
	lea	eax, DWORD PTR [eax+esi*4]

; 6194 : 		CvAssert(getImprovementYieldChange(eIndex1, eIndex2) >= 0);
; 6195 : 
; 6196 : 		updateYield();

	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
	pop	esi
$LN1@changeImpr:

; 6197 : 	}
; 6198 : }

	ret	12					; 0000000cH
?changeImprovementYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ENDP ; CvTeam::changeImprovementYieldChange
_TEXT	ENDS
PUBLIC	?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementNoFreshWaterYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z PROC ; CvTeam::changeImprovementNoFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6215 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6216 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6217 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6218 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6219 : 
; 6220 : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@changeImpr@2

; 6221 : 	{
; 6222 : 		m_ppaaiImprovementNoFreshWaterYieldChange[eIndex1][eIndex2] = (m_ppaaiImprovementNoFreshWaterYieldChange[eIndex1][eIndex2] + iChange);

	mov	eax, DWORD PTR [ecx+2952]
	push	esi
	mov	esi, DWORD PTR _eIndex1$[esp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR _eIndex2$[esp]
	add	DWORD PTR [eax+esi*4], edx
	lea	eax, DWORD PTR [eax+esi*4]

; 6223 : 		CvAssert(getImprovementNoFreshWaterYieldChange(eIndex1, eIndex2) >= 0);
; 6224 : 
; 6225 : 		updateYield();

	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
	pop	esi
$LN1@changeImpr@2:

; 6226 : 	}
; 6227 : }

	ret	12					; 0000000cH
?changeImprovementNoFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ENDP ; CvTeam::changeImprovementNoFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ; CvTeam::changeImprovementFreshWaterYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z PROC ; CvTeam::changeImprovementFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 6244 : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
; 6245 : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
; 6246 : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
; 6247 : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
; 6248 : 
; 6249 : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@changeImpr@3

; 6250 : 	{
; 6251 : 		m_ppaaiImprovementFreshWaterYieldChange[eIndex1][eIndex2] = (m_ppaaiImprovementFreshWaterYieldChange[eIndex1][eIndex2] + iChange);

	mov	eax, DWORD PTR [ecx+2956]
	push	esi
	mov	esi, DWORD PTR _eIndex1$[esp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR _eIndex2$[esp]
	add	DWORD PTR [eax+esi*4], edx
	lea	eax, DWORD PTR [eax+esi*4]

; 6252 : 		CvAssert(getImprovementFreshWaterYieldChange(eIndex1, eIndex2) >= 0);
; 6253 : 
; 6254 : 		updateYield();

	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
	pop	esi
$LN1@changeImpr@3:

; 6255 : 	}
; 6256 : }

	ret	12					; 0000000cH
?changeImprovementFreshWaterYieldChange@CvTeam@@QAEXW4ImprovementTypes@@W4YieldTypes@@H@Z ENDP ; CvTeam::changeImprovementFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?testCircumnavigated@CvTeam@@IAEXXZ		; CvTeam::testCircumnavigated
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?makeCircumnavigated@CvGame@@QAEXXZ:PROC	; CvGame::makeCircumnavigated
EXTRN	?circumnavigationAvailable@CvGame@@QBE_NXZ:PROC	; CvGame::circumnavigationAvailable
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?testCircumnavigated@CvTeam@@IAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?testCircumnavigated@CvTeam@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?testCircumnavigated@CvTeam@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?testCircumnavigated@CvTeam@@IAEXXZ
_TEXT	SEGMENT
_bResult$227193 = -121					; size = 1
tv642 = -120						; size = 4
tv651 = -116						; size = 4
_args$227192 = -116					; size = 4
_kGame$ = -112						; size = 4
tv656 = -108						; size = 4
_iActivePlayerID$ = -108				; size = 4
_iY$ = -108						; size = 4
tv864 = -104						; size = 4
_this$ = -104						; size = 4
_iFreeMoves$227157 = -100				; size = 4
_strBuffer$ = -96					; size = 28
$T236770 = -68						; size = 28
$T236768 = -68						; size = 28
$T236766 = -68						; size = 28
$T236765 = -68						; size = 28
$T236771 = -40						; size = 28
$T236769 = -40						; size = 28
$T236767 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?testCircumnavigated@CvTeam@@IAEXXZ PROC		; CvTeam::testCircumnavigated, COMDAT
; _this$ = ecx

; 6334 : {

	push	-1
	push	__ehhandler$?testCircumnavigated@CvTeam@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	edi
	mov	edi, ecx

; 6335 : 	CvPlot* pPlot;
; 6336 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+128]
	mov	DWORD PTR _this$[esp+128], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6337 : 	bool bFoundVisible;
; 6338 : 	int iX, iY;
; 6339 : 
; 6340 : 	if(isBarbarian())

	cmp	DWORD PTR [edi+4], 63			; 0000003fH
	mov	DWORD PTR __$EHRec$[esp+136], 0
	jne	SHORT $LN33@testCircum

; 6341 : 	{
; 6342 : 		return;

	lea	ecx, DWORD PTR _strBuffer$[esp+128]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi

; 6462 : 	}
; 6463 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
$LN33@testCircum:
	push	esi

; 6343 : 	}
; 6344 : 
; 6345 : 	CvGame& kGame = GC.getGame();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48

; 6346 : 	if(!kGame.circumnavigationAvailable())

	mov	ecx, esi
	mov	DWORD PTR _kGame$[esp+132], esi
	call	?circumnavigationAvailable@CvGame@@QBE_NXZ ; CvGame::circumnavigationAvailable
	test	al, al
	jne	SHORT $LN32@testCircum

; 6347 : 	{
; 6348 : 		return;

	lea	ecx, DWORD PTR _strBuffer$[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	edi

; 6462 : 	}
; 6463 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
$LN32@testCircum:

; 6349 : 	}
; 6350 : 
; 6351 : 	CvMap& kMap = GC.getMap();
; 6352 : 
; 6353 : 	// Test one of the wrapping axises.  This is brute force and not exactly "correct".
; 6354 : 	// It does not test for continuity and is not able to test whether the plot was revealed by exploration or
; 6355 : 	// some other method such as gifted "maps".
; 6356 : 	TeamTypes eTeamID = GetID();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR tv642[esp+132], eax

; 6357 : 	if(kMap.isWrapX())

	mov	al, BYTE PTR [ecx+4056]
	push	ebx
	push	ebp
	test	al, al
	je	$LN31@testCircum

; 6358 : 	{
; 6359 : 		for(iX = kMap.getGridWidth(); iX--;)

	mov	ebp, DWORD PTR [ecx+4020]
	mov	DWORD PTR tv651[esp+140], ebp
	test	ebp, ebp
	je	SHORT $LN208@testCircum

; 6413 : 
; 6414 : 		for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	ecx, DWORD PTR [ecx+4024]
	mov	DWORD PTR tv656[esp+140], ecx
	npad	6
$LL30@testCircum:
	mov	edx, DWORD PTR tv656[esp+140]
	dec	ebp
	test	edx, edx
	je	$LN221@testCircum
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR tv642[esp+140]
	mov	ebx, DWORD PTR [eax+4068]
	mov	ecx, DWORD PTR tv642[esp+140]
	shr	esi, 5
	mov	eax, esi
	shl	eax, 5
	sub	ecx, eax
	mov	edi, 1
	shl	edi, cl
$LL28@testCircum:
	mov	eax, DWORD PTR tv651[esp+140]
	dec	edx
	imul	eax, edx
	add	eax, ebp
	imul	eax, 484				; 000001e4H
	add	eax, ebx
	test	DWORD PTR [eax+esi*4+8], edi
	jne	SHORT $LN201@testCircum

; 6360 : 		{
; 6361 : 			bFoundVisible = false;
; 6362 : 
; 6363 : 			for(iY = kMap.getGridHeight(); iY--;)

	test	edx, edx
	jne	SHORT $LL28@testCircum
	jmp	$LN221@testCircum
$LN201@testCircum:

; 6358 : 	{
; 6359 : 		for(iX = kMap.getGridWidth(); iX--;)

	test	ebp, ebp
	jne	SHORT $LL30@testCircum
$LN220@testCircum:

; 6381 : 	{
; 6382 : 		for(iY = kMap.getGridHeight(); iY--;)

	mov	esi, DWORD PTR _kGame$[esp+140]
	mov	edi, DWORD PTR _this$[esp+140]
$LN208@testCircum:

; 6391 : 				{
; 6392 : 					bFoundVisible = true;
; 6393 : 					break;
; 6394 : 				}
; 6395 : 			}
; 6396 : 
; 6397 : 			if(!bFoundVisible)
; 6398 : 			{
; 6399 : 				return;
; 6400 : 			}
; 6401 : 		}
; 6402 : 	}
; 6403 : 
; 6404 : 	kGame.makeCircumnavigated();

	mov	ecx, esi
	call	?makeCircumnavigated@CvGame@@QAEXXZ	; CvGame::makeCircumnavigated

; 6405 : 
; 6406 : 	int iActivePlayerID = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 6407 : 
; 6408 : 	if(kGame.getElapsedGameTurns() > 0)

	mov	ecx, esi
	mov	DWORD PTR _iActivePlayerID$[esp+140], eax
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	test	eax, eax
	jle	$LN221@testCircum

; 6409 : 	{
; 6410 : 		int iFreeMoves = GC.getCIRCUMNAVIGATE_FREE_MOVES();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6744
	mov	ecx, eax
	mov	DWORD PTR _iFreeMoves$227157[esp+140], ecx

; 6411 : 		if(iFreeMoves != 0)

	test	ecx, ecx
	je	SHORT $LN108@testCircum

; 6412 : 			changeExtraMoves(DOMAIN_SEA, GC.getCIRCUMNAVIGATE_FREE_MOVES());

	add	DWORD PTR [edi+1108], eax
$LN108@testCircum:

; 6413 : 
; 6414 : 		for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebx, ebx
	xor	esi, esi
	mov	DWORD PTR tv864[esp+140], esi
$LL14@testCircum:

; 6415 : 		{
; 6416 : 			CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, ecx

; 6417 : 			if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+2256], 0
	je	$LN13@testCircum

; 6418 : 			{
; 6419 : 				if(eTeamID == kPlayer.getTeam())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	$LN124@testCircum
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	$LN125@testCircum
$LN31@testCircum:

; 6364 : 			{
; 6365 : 				pPlot = kMap.plotUnchecked(iX, iY);
; 6366 : 
; 6367 : 				if(pPlot->isRevealed(eTeamID))
; 6368 : 				{
; 6369 : 					bFoundVisible = true;
; 6370 : 					break;
; 6371 : 				}
; 6372 : 			}
; 6373 : 
; 6374 : 			if(!bFoundVisible)
; 6375 : 			{
; 6376 : 				return;
; 6377 : 			}
; 6378 : 		}
; 6379 : 	}
; 6380 : 	else if(kMap.isWrapY())

	cmp	BYTE PTR [ecx+4057], 0
	je	SHORT $LN208@testCircum

; 6381 : 	{
; 6382 : 		for(iY = kMap.getGridHeight(); iY--;)

	mov	eax, DWORD PTR [ecx+4024]
	test	eax, eax
	je	$LN208@testCircum
	mov	esi, DWORD PTR [ecx+4020]
	mov	DWORD PTR tv651[esp+140], esi
$LL22@testCircum:
	dec	eax

; 6383 : 		{
; 6384 : 			bFoundVisible = false;
; 6385 : 
; 6386 : 			for(iX = kMap.getGridWidth(); iX--;)

	mov	edi, esi
	mov	DWORD PTR _iY$[esp+140], eax
	test	edi, edi
	je	$LN221@testCircum

; 6387 : 			{
; 6388 : 				pPlot = kMap.plotUnchecked(iX, iY);
; 6389 : 
; 6390 : 				if(pPlot->isRevealed(GetID()))

	mov	ecx, DWORD PTR tv642[esp+140]
	imul	esi, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, DWORD PTR [eax+4068]
	mov	edx, ecx
	shr	edx, 5
	mov	eax, edx
	shl	eax, 5
	sub	ecx, eax
	mov	ebp, 1
	shl	ebp, cl
	npad	9
$LL20@testCircum:
	dec	edi
	lea	eax, DWORD PTR [esi+edi]
	imul	eax, 484				; 000001e4H
	add	eax, ebx
	test	DWORD PTR [eax+edx*4+8], ebp
	jne	SHORT $LN203@testCircum

; 6383 : 		{
; 6384 : 			bFoundVisible = false;
; 6385 : 
; 6386 : 			for(iX = kMap.getGridWidth(); iX--;)

	test	edi, edi
	jne	SHORT $LL20@testCircum
	jmp	$LN221@testCircum
$LN203@testCircum:

; 6381 : 	{
; 6382 : 		for(iY = kMap.getGridHeight(); iY--;)

	cmp	DWORD PTR _iY$[esp+140], 0
	je	$LN220@testCircum
	mov	esi, DWORD PTR tv651[esp+140]
	mov	eax, DWORD PTR _iY$[esp+140]
	jmp	SHORT $LL22@testCircum

; 6418 : 			{
; 6419 : 				if(eTeamID == kPlayer.getTeam())

$LN124@testCircum:
	or	eax, -1
$LN125@testCircum:
	mov	ebp, DWORD PTR tv642[esp+140]
	cmp	ebp, eax
	jne	SHORT $LN216@testCircum

; 6420 : 				{
; 6421 : 					if(!kGame.isGameMultiPlayer() && kPlayer.isHuman())

	mov	ecx, DWORD PTR _kGame$[esp+140]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN216@testCircum
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN216@testCircum

; 6422 : 					{
; 6423 : 						gDLL->UnlockAchievement(ACHIEVEMENT_ROUND_WORLD);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	95					; 0000005fH
	call	eax
$LN216@testCircum:

; 6424 : 					}
; 6425 : 				}
; 6426 : 
; 6427 : 				if(iActivePlayerID == iI)

	cmp	DWORD PTR _iActivePlayerID$[esp+140], ebx
	jne	$LN13@testCircum

; 6428 : 				{
; 6429 : 					if(eTeamID == kPlayer.getTeam())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN135@testCircum
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN136@testCircum
$LN135@testCircum:
	or	eax, -1
$LN136@testCircum:
	cmp	ebp, eax
	jne	SHORT $LN7@testCircum

; 6430 : 					{
; 6431 : 						if(iFreeMoves == 0)

	mov	eax, DWORD PTR _iFreeMoves$227157[esp+140]
	test	eax, eax
	jne	SHORT $LN6@testCircum

; 6432 : 							// Not the most ideal solution, but if the free moves are 0, use the string designed for telling about another team circling the globe
; 6433 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_CIRC_GLOBE", kPlayer.getName());

	mov	ecx, esi
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	push	eax
	lea	eax, DWORD PTR $T236765[esp+144]
	push	OFFSET $SG227172
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236765[esp+140]

; 6434 : 						else

	jmp	$LN226@testCircum
$LN6@testCircum:

; 6435 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_CIRC_GLOBE", iFreeMoves);

	push	eax
	lea	ecx, DWORD PTR $T236766[esp+144]
	push	OFFSET $SG227180
	push	ecx
	call	??$GetLocalizedText@H@@YA?AVCvString@@PBDH@Z ; GetLocalizedText<int>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236766[esp+140]
	jmp	$LN226@testCircum
$LN7@testCircum:

; 6436 : 					}
; 6437 : 					else if(isHasMet(kPlayer.getTeam()))

	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	BYTE PTR [eax+edi+1848], 0
	je	SHORT $LN3@testCircum

; 6438 : 					{
; 6439 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_CIRC_GLOBE", getName().GetCString());

	lea	edx, DWORD PTR $T236767[esp+140]
	push	edx
	mov	ecx, edi
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+148], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T236768[esp+144]
	push	OFFSET $SG227185
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236768[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6440 : 					}
; 6441 : 					else

	jmp	SHORT $LN227@testCircum
$LN3@testCircum:

; 6442 : 					{
; 6443 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_UNKNOWN_CIRC_GLOBE");

	lea	ecx, DWORD PTR $T236769[esp+140]
	push	OFFSET $SG227188
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN227@testCircum:
	lea	ecx, DWORD PTR $T236769[esp+140]
$LN226@testCircum:
	mov	BYTE PTR __$EHRec$[esp+148], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6444 : 					}
; 6445 : 					DLLUI->AddMessage(0, ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+140]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	0
	mov	edx, DWORD PTR [esi]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	ebx
	push	0
	mov	ecx, esi
	call	edx

; 6446 : 
; 6447 : 					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, eax

; 6448 : 					if (pkScriptSystem)

	test	esi, esi
	je	SHORT $LN13@testCircum

; 6449 : 					{
; 6450 : 						CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$227192[esp+140]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 6451 : 						args->Push(eTeamID);

	mov	ecx, DWORD PTR _args$227192[esp+140]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+152], 6
	call	edx

; 6452 : 
; 6453 : 						bool bResult = false;
; 6454 : 						LuaSupport::CallHook(pkScriptSystem, "CircumnavigatedGlobe", args.get(), bResult);

	mov	ecx, DWORD PTR _args$227192[esp+140]
	lea	eax, DWORD PTR _bResult$227193[esp+140]
	push	eax
	push	ecx
	push	OFFSET $SG227194
	push	esi
	mov	BYTE PTR _bResult$227193[esp+156], 0
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 6455 : 					}

	lea	ecx, DWORD PTR _args$227192[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN13@testCircum:
	mov	esi, DWORD PTR tv864[esp+140]
	add	esi, 63236				; 0000f704H
	inc	ebx
	cmp	esi, 4047104				; 003dc100H
	mov	DWORD PTR tv864[esp+140], esi
	jl	$LL14@testCircum

; 6456 : 				}
; 6457 : 			}
; 6458 : 		}
; 6459 : 
; 6460 : 		strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_CIRC_GLOBE", getName().GetCString());

	lea	edx, DWORD PTR $T236770[esp+140]
	push	edx
	mov	ecx, edi
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	bl, 7
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+148], bl
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T236771[esp+144]
	push	OFFSET $SG227197
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236771[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T236770[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6461 : 		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	push	-1
	push	-1
	lea	ecx, DWORD PTR _strBuffer$[esp+148]
	push	ecx
	mov	ecx, edi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
$LN221@testCircum:

; 6462 : 	}
; 6463 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+140]
	mov	DWORD PTR __$EHRec$[esp+148], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+140]
	pop	ebp
	pop	ebx
	pop	esi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$1:
	lea	ecx, DWORD PTR $T236765[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$2:
	lea	ecx, DWORD PTR $T236766[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$3:
	lea	ecx, DWORD PTR $T236767[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$4:
	lea	ecx, DWORD PTR $T236768[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$5:
	lea	ecx, DWORD PTR $T236769[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$6:
	lea	ecx, DWORD PTR _args$227192[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$7:
	lea	ecx, DWORD PTR $T236770[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?testCircumnavigated@CvTeam@@IAEXXZ$8:
	lea	ecx, DWORD PTR $T236771[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?testCircumnavigated@CvTeam@@IAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?testCircumnavigated@CvTeam@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?testCircumnavigated@CvTeam@@IAEXXZ ENDP		; CvTeam::testCircumnavigated
PUBLIC	?processTech@CvTeam@@IAEXW4TechTypes@@H@Z	; CvTeam::processTech
EXTRN	?SetEndGameTechResearched@CvGame@@QAEX_N@Z:PROC	; CvGame::SetEndGameTechResearched
EXTRN	?IsEndsGame@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsEndsGame
EXTRN	?updateCityRoute@CvPlot@@QAEXXZ:PROC		; CvPlot::updateCityRoute
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?setLayoutDirty@CvPlot@@QAEX_N@Z:PROC		; CvPlot::setLayoutDirty
EXTRN	?updateYield@CvPlot@@QAEXXZ:PROC		; CvPlot::updateYield
EXTRN	?getTechReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechReveal
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?chooseProduction@CvCity@@QAEXW4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@_N3@Z:PROC ; CvCity::chooseProduction
EXTRN	?clearOrderQueue@CvCity@@QAEXXZ:PROC		; CvCity::clearOrderQueue
EXTRN	?getFirstBuildingOrder@CvCity@@QBEHW4BuildingTypes@@@Z:PROC ; CvCity::getFirstBuildingOrder
EXTRN	?ChangeNumCitiesFreeChosenBuilding@CvPlayer@@QAEXW4BuildingClassTypes@@H@Z:PROC ; CvPlayer::ChangeNumCitiesFreeChosenBuilding
EXTRN	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumFreeBuilding
EXTRN	?isValidBuildingLocation@CvCity@@QBE_NW4BuildingTypes@@@Z:PROC ; CvCity::isValidBuildingLocation
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?IsFreeBuildingAllCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z:PROC ; CvPlayer::IsFreeBuildingAllCity
EXTRN	?IsFreeChosenBuildingNewCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z:PROC ; CvPlayer::IsFreeChosenBuildingNewCity
EXTRN	?GetNumCitiesFreeChosenBuilding@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::GetNumCitiesFreeChosenBuilding
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTraits::GetFreeBuildingPrereqTech
EXTRN	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:PROC ; CvCityBuildings::SetNumFreeBuilding
EXTRN	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:PROC ; CvCityBuildings::SetNumRealBuilding
EXTRN	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumRealBuilding
EXTRN	?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ:PROC ; CvPlayerTraits::GetFreeCapitalBuilding
EXTRN	?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
EXTRN	?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ:PROC	; CvPlayerTraits::GetNextFreeUnit
EXTRN	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetSpecialUnitType
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?addFreeUnit@CvPlayer@@QAEPAVCvPlot@@W4UnitTypes@@W4UnitAITypes@@@Z:PROC ; CvPlayer::addFreeUnit
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z:PROC ; CvPlayerTraits::GetFirstFreeUnit
EXTRN	?recomputePolicyCostModifier@CvPlayer@@QAEXXZ:PROC ; CvPlayer::recomputePolicyCostModifier
EXTRN	?InitPlayerTraits@CvPlayerTraits@@QAEXXZ:PROC	; CvPlayerTraits::InitPlayerTraits
EXTRN	?Reset@CvPlayerTraits@@QAEXXZ:PROC		; CvPlayerTraits::Reset
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?ChangeFreePromotionCount@CvPlayer@@QAEXW4PromotionTypes@@H@Z:PROC ; CvPlayer::ChangeFreePromotionCount
EXTRN	?IsFreePromotion@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::IsFreePromotion
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
EXTRN	?ChangeExtraVotesPerDiplomat@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeExtraVotesPerDiplomat
EXTRN	?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetExtraVotesPerDiplomat
EXTRN	?ChangeInfluenceSpreadModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeInfluenceSpreadModifier
EXTRN	?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetInfluenceSpreadModifier
EXTRN	?changeWorkerSpeedModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeWorkerSpeedModifier
EXTRN	?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetWorkerSpeedModifier
EXTRN	?changeUnitBaseHealModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeUnitBaseHealModifier
EXTRN	?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetUnitBaseHealModifier
EXTRN	?changeUnitFortificationModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeUnitFortificationModifier
EXTRN	?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetUnitFortificationModifier
EXTRN	?changeFeatureProductionModifier@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeFeatureProductionModifier
EXTRN	?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetFeatureProductionModifier
EXTRN	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechFreshWaterYieldChanges
EXTRN	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
EXTRN	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechYieldChanges
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetEnhancedYieldTech
EXTRN	?GetObsoleteTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetObsoleteTech
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetDomainExtraMoves
EXTRN	?getTechTimeChange@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getTechTimeChange
EXTRN	?getTechMovementChange@CvRouteInfo@@QBEHH@Z:PROC ; CvRouteInfo::getTechMovementChange
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?getNumRouteInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumRouteInfos
EXTRN	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetEmbarkedSightChange
EXTRN	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetEmbarkedMoveChange
EXTRN	?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsEmbarkedAllWaterPassage
EXTRN	?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsAllowsDefensiveEmbarking
EXTRN	?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsAllowsEmbarking
EXTRN	?IsWaterWork@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsWaterWork
EXTRN	?IsBridgeBuilding@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsBridgeBuilding
EXTRN	?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsPermanentAllianceTrading
EXTRN	?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsTradeAgreementTradingAllowed
EXTRN	?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsResearchAgreementTradingAllowed
EXTRN	?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsDefensivePactTradingAllowed
EXTRN	?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsOpenBordersTradingAllowed
EXTRN	?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsAllowEmbassyTradingAllowed
EXTRN	?IsGoldTrading@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsGoldTrading
EXTRN	?IsTechTrading@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsTechTrading
EXTRN	?IsMapTrading@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsMapTrading
EXTRN	?IsMapCentering@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsMapCentering
EXTRN	?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ:PROC	; CvTechEntry::IsExtraWaterSeeFrom
EXTRN	?TriggerArchaeologySiteCreation@CvGame@@QAEX_N@Z:PROC ; CvGame::TriggerArchaeologySiteCreation
EXTRN	?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsTriggersArchaeologicalSites
EXTRN	?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ:PROC ; CvTechEntry::IsAllowsWorldCongress
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$2
__ehfuncinfo$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
_TEXT	SEGMENT
_iI$ = -200						; size = 4
_args$227373 = -196					; size = 4
_this$ = -192						; size = 4
_pTech$ = -188						; size = 4
_bResult$227374 = -181					; size = 1
_iLoop$227330 = -180					; size = 4
_thisCiv$227311 = -176					; size = 4
_strSummary$227302 = -172				; size = 80
_strText$227299 = -92					; size = 80
__$EHRec$ = -12						; size = 12
_eTech$ = 8						; size = 4
_iChange$ = 12						; size = 4
?processTech@CvTeam@@IAEXW4TechTypes@@H@Z PROC		; CvTeam::processTech, COMDAT
; _this$ = ecx

; 6467 : {

	push	-1
	push	__ehhandler$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 188				; 000000bcH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 6468 : 	CvCity* pCity;
; 6469 : 	CvPlot* pLoopPlot;
; 6470 : 	ResourceTypes eResource;
; 6471 : #ifdef AUI_WARNING_FIXES
; 6472 : 	uint iI;
; 6473 : 	int iJ;
; 6474 : #else
; 6475 : 	int iI, iJ;
; 6476 : #endif
; 6477 : 
; 6478 : 	CvTechEntry* pTech = GC.getTechInfo(eTech);

	mov	edi, DWORD PTR _eTech$[esp+212]
	mov	ebx, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+220], ebx
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	esi, eax

; 6479 : 
; 6480 : 	if (pTech->IsAllowsWorldCongress())

	mov	ecx, esi
	mov	DWORD PTR _pTech$[esp+216], esi
	call	?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowsWorldCongress
	test	al, al
	je	SHORT $LN108@processTec

; 6481 : 	{
; 6482 : 		SetHasTechForWorldCongress(true);

	mov	BYTE PTR [ebx+131], 1
$LN108@processTec:

; 6483 : 	}
; 6484 : 
; 6485 : 	if(pTech->IsTriggersArchaeologicalSites())

	mov	ecx, esi
	call	?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTriggersArchaeologicalSites
	test	al, al
	je	SHORT $LN101@processTec

; 6486 : 	{
; 6487 : 		GC.getGame().TriggerArchaeologySiteCreation(true /*bCheckInitialized*/);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	call	?TriggerArchaeologySiteCreation@CvGame@@QAEX_N@Z ; CvGame::TriggerArchaeologySiteCreation
$LN101@processTec:

; 6488 : 	}
; 6489 : 
; 6490 : 	if(pTech->IsExtraWaterSeeFrom())

	mov	ecx, esi
	call	?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsExtraWaterSeeFrom
	mov	ebp, DWORD PTR _iChange$[esp+212]
	test	al, al
	je	SHORT $LN112@processTec

; 6491 : 	{
; 6492 : 		changeExtraWaterSeeFromCount(iChange);

	test	ebp, ebp
	je	SHORT $LN112@processTec
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	0
	call	?updateSight@CvMap@@QAEX_N@Z		; CvMap::updateSight
	add	DWORD PTR [ebx+36], ebp
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	call	?updateSight@CvMap@@QAEX_N@Z		; CvMap::updateSight
$LN112@processTec:

; 6493 : 	}
; 6494 : 
; 6495 : 	if(pTech->IsMapCentering())

	mov	ecx, esi
	call	?IsMapCentering@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsMapCentering
	test	al, al
	je	SHORT $LN98@processTec

; 6496 : 	{
; 6497 : 		if(iChange > 0)

	test	ebp, ebp
	jle	SHORT $LN98@processTec

; 6498 : 		{
; 6499 : 			setMapCentering(true);

	push	1
	mov	ecx, ebx
	call	?setMapCentering@CvTeam@@QAEX_N@Z	; CvTeam::setMapCentering
$LN98@processTec:

; 6500 : 		}
; 6501 : 	}
; 6502 : 
; 6503 : 	if(pTech->IsMapTrading())

	mov	ecx, esi
	call	?IsMapTrading@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsMapTrading
	test	al, al
	je	SHORT $LN119@processTec

; 6504 : 	{
; 6505 : 		changeMapTradingCount(iChange);

	add	DWORD PTR [ebx+40], ebp
$LN119@processTec:

; 6506 : 	}
; 6507 : 
; 6508 : 	if(pTech->IsTechTrading())

	mov	ecx, esi
	call	?IsTechTrading@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsTechTrading
	test	al, al
	je	SHORT $LN121@processTec

; 6509 : 	{
; 6510 : 		changeTechTradingCount(iChange);

	add	DWORD PTR [ebx+44], ebp
$LN121@processTec:

; 6511 : 	}
; 6512 : 
; 6513 : 	if(pTech->IsGoldTrading())

	mov	ecx, esi
	call	?IsGoldTrading@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsGoldTrading
	test	al, al
	je	SHORT $LN123@processTec

; 6514 : 	{
; 6515 : 		changeGoldTradingCount(iChange);

	add	DWORD PTR [ebx+48], ebp
$LN123@processTec:

; 6516 : 	}
; 6517 : 
; 6518 : 	if(pTech->IsAllowEmbassyTradingAllowed())

	mov	ecx, esi
	call	?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowEmbassyTradingAllowed
	test	al, al
	je	SHORT $LN125@processTec

; 6519 : 	{
; 6520 : 		changeAllowEmbassyTradingAllowedCount(iChange);

	add	DWORD PTR [ebx+52], ebp
$LN125@processTec:

; 6521 : 	}
; 6522 : 
; 6523 : 	if(pTech->IsOpenBordersTradingAllowed())

	mov	ecx, esi
	call	?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsOpenBordersTradingAllowed
	test	al, al
	je	SHORT $LN127@processTec

; 6524 : 	{
; 6525 : 		changeOpenBordersTradingAllowedCount(iChange);

	add	DWORD PTR [ebx+56], ebp
$LN127@processTec:

; 6526 : 	}
; 6527 : 
; 6528 : 	if(pTech->IsDefensivePactTradingAllowed())

	mov	ecx, esi
	call	?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsDefensivePactTradingAllowed
	test	al, al
	je	SHORT $LN129@processTec

; 6529 : 	{
; 6530 : 		changeDefensivePactTradingAllowedCount(iChange);

	add	DWORD PTR [ebx+60], ebp
$LN129@processTec:

; 6531 : 	}
; 6532 : 
; 6533 : 	if(pTech->IsResearchAgreementTradingAllowed())

	mov	ecx, esi
	call	?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsResearchAgreementTradingAllowed
	test	al, al
	je	SHORT $LN131@processTec

; 6534 : 	{
; 6535 : 		ChangeResearchAgreementTradingAllowedCount(iChange);

	add	DWORD PTR [ebx+64], ebp
$LN131@processTec:

; 6536 : 	}
; 6537 : 
; 6538 : 	if(pTech->IsTradeAgreementTradingAllowed())

	mov	ecx, esi
	call	?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTradeAgreementTradingAllowed
	test	al, al
	je	SHORT $LN133@processTec

; 6539 : 	{
; 6540 : 		ChangeTradeAgreementTradingAllowedCount(iChange);

	add	DWORD PTR [ebx+68], ebp
$LN133@processTec:

; 6541 : 	}
; 6542 : 
; 6543 : 	if(pTech->IsPermanentAllianceTrading())

	mov	ecx, esi
	call	?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsPermanentAllianceTrading
	test	al, al
	je	SHORT $LN135@processTec

; 6544 : 	{
; 6545 : 		changePermanentAllianceTradingCount(iChange);

	add	DWORD PTR [ebx+72], ebp
$LN135@processTec:

; 6546 : 	}
; 6547 : 
; 6548 : 	if(pTech->IsBridgeBuilding())

	mov	ecx, esi
	call	?IsBridgeBuilding@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsBridgeBuilding
	test	al, al
	je	SHORT $LN88@processTec

; 6549 : 	{
; 6550 : 		changeBridgeBuildingCount(iChange);

	push	ebp
	mov	ecx, ebx
	call	?changeBridgeBuildingCount@CvTeam@@QAEXH@Z ; CvTeam::changeBridgeBuildingCount
$LN88@processTec:

; 6551 : 	}
; 6552 : 
; 6553 : 	if(pTech->IsWaterWork())

	mov	ecx, esi
	call	?IsWaterWork@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsWaterWork
	test	al, al
	je	SHORT $LN137@processTec

; 6554 : 	{
; 6555 : 		changeWaterWorkCount(iChange);

	test	ebp, ebp
	je	SHORT $LN137@processTec
	add	DWORD PTR [ebx+80], ebp
$LN137@processTec:

; 6556 : 	}
; 6557 : 
; 6558 : 	if(pTech->IsAllowsEmbarking())

	mov	ecx, esi
	call	?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsEmbarking
	test	al, al
	je	SHORT $LN86@processTec

; 6559 : 	{
; 6560 : 		changeCanEmbarkCount(iChange);

	push	ebp
	mov	ecx, ebx
	call	?changeCanEmbarkCount@CvTeam@@QAEXH@Z	; CvTeam::changeCanEmbarkCount
$LN86@processTec:

; 6561 : 	}
; 6562 : 
; 6563 : 	if(pTech->IsAllowsDefensiveEmbarking())

	mov	ecx, esi
	call	?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowsDefensiveEmbarking
	test	al, al
	je	SHORT $LN85@processTec

; 6564 : 	{
; 6565 : 		changeDefensiveEmbarkCount(iChange);

	push	ebp
	mov	ecx, ebx
	call	?changeDefensiveEmbarkCount@CvTeam@@QAEXH@Z ; CvTeam::changeDefensiveEmbarkCount
$LN85@processTec:

; 6566 : 	}
; 6567 : 
; 6568 : 	if(pTech->IsEmbarkedAllWaterPassage())

	mov	ecx, esi
	call	?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsEmbarkedAllWaterPassage
	test	al, al
	je	SHORT $LN140@processTec

; 6569 : 	{
; 6570 : 		changeEmbarkedAllWaterPassage(iChange);

	test	ebp, ebp
	je	SHORT $LN140@processTec
	add	DWORD PTR [ebx+112], ebp
$LN140@processTec:

; 6571 : 	}
; 6572 : 
; 6573 : 	if(pTech->GetEmbarkedMoveChange() != 0)

	mov	ecx, esi
	call	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedMoveChange
	test	eax, eax
	je	SHORT $LN143@processTec

; 6574 : 	{
; 6575 : 		changeEmbarkedExtraMoves(pTech->GetEmbarkedMoveChange() * iChange);

	mov	ecx, esi
	call	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedMoveChange
	imul	eax, ebp
	add	DWORD PTR [ebx+96], eax
$LN143@processTec:

; 6576 : 	}
; 6577 : 
; 6578 : 	//EAP: Add Embarked Visibility Extra on Techs
; 6579 : 
; 6580 : 	if(pTech->GetEmbarkedSightChange() != 0)

	mov	ecx, esi
	call	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedSightChange
	test	eax, eax
	je	SHORT $LN145@processTec

; 6581 : 	{
; 6582 : 		changeEmbarkedExtraSight(pTech->GetEmbarkedSightChange() * iChange);

	mov	ecx, esi
	call	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetEmbarkedSightChange
	imul	eax, ebp
	add	DWORD PTR [ebx+100], eax
$LN145@processTec:

; 6583 : 	}
; 6584 : 
; 6585 : 	for(iI = 0; iI < GC.getNumRouteInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	test	eax, eax
	jle	SHORT $LN79@processTec
	npad	3
$LL81@processTec:

; 6586 : 	{
; 6587 : 		changeRouteChange(((RouteTypes)iI), (GC.getRouteInfo((RouteTypes) iI)->getTechMovementChange(eTech) * iChange));

	push	edi
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?getTechMovementChange@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getTechMovementChange
	imul	eax, ebp
	mov	ecx, DWORD PTR [ebx+2908]
	add	DWORD PTR [ecx+esi*4], eax
	lea	ecx, DWORD PTR [ecx+esi*4]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	cmp	esi, eax
	jl	SHORT $LL81@processTec
$LN79@processTec:

; 6588 : 	}
; 6589 : 
; 6590 : #ifdef AUI_WARNING_FIXES
; 6591 : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 6592 : #else
; 6593 : 	for (int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN76@processTec
$LL78@processTec:

; 6594 : #endif
; 6595 : 	{
; 6596 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes)i);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 6597 : 		if (pkBuildInfo != NULL)

	test	eax, eax
	je	SHORT $LN77@processTec

; 6598 : 			changeBuildTimeChange(((BuildTypes)i), (pkBuildInfo->getTechTimeChange(eTech) * iChange));

	push	edi
	mov	ecx, eax
	call	?getTechTimeChange@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getTechTimeChange
	imul	eax, ebp
	test	eax, eax
	je	SHORT $LN77@processTec
	mov	edx, DWORD PTR [ebx+2912]
	add	DWORD PTR [edx+esi*4], eax
	lea	ecx, DWORD PTR [edx+esi*4]
$LN77@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL78@processTec
$LN76@processTec:

; 6599 : 	}
; 6600 : 
; 6601 : 	for(iI = 0; iI < NUM_DOMAIN_TYPES; iI++)

	xor	esi, esi
	lea	edi, DWORD PTR [ebx+1108]
$LL74@processTec:

; 6602 : 	{
; 6603 : 		changeExtraMoves(((DomainTypes)iI), (pTech->GetDomainExtraMoves(iI) * iChange));

	mov	ecx, DWORD PTR _pTech$[esp+216]
	push	esi
	call	?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z ; CvTechEntry::GetDomainExtraMoves
	imul	eax, ebp
	add	DWORD PTR [edi], eax
	inc	esi
	add	edi, 4
	cmp	esi, 5
	jl	SHORT $LL74@processTec

; 6604 : 	}
; 6605 : 
; 6606 : 	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	SHORT $LN265@processTec
	npad	6
$LL71@processTec:

; 6607 : 	{
; 6608 : 		CvBuildingEntry* pBuildingEntry = GC.getBuildingInfo((BuildingTypes) iI);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 6609 : 		if(pBuildingEntry)

	test	edi, edi
	je	SHORT $LN70@processTec

; 6610 : 		{
; 6611 : 			if(pBuildingEntry->GetObsoleteTech() == eTech)

	mov	ecx, edi
	call	?GetObsoleteTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetObsoleteTech
	cmp	eax, DWORD PTR _eTech$[esp+212]
	jne	SHORT $LN67@processTec

; 6612 : 			{
; 6613 : 				changeObsoleteBuildingCount(((BuildingTypes)iI), iChange);

	push	ebp
	push	esi
	mov	ecx, ebx
	call	?changeObsoleteBuildingCount@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::changeObsoleteBuildingCount
$LN67@processTec:

; 6614 : 			}
; 6615 : 			if(pBuildingEntry->GetEnhancedYieldTech() == eTech)

	mov	ecx, edi
	call	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetEnhancedYieldTech
	cmp	eax, DWORD PTR _eTech$[esp+212]
	jne	SHORT $LN70@processTec

; 6616 : 			{
; 6617 : 				enhanceBuilding(((BuildingTypes)iI), iChange);

	push	ebp
	push	esi
	mov	ecx, ebx
	call	?enhanceBuilding@CvTeam@@QAEXW4BuildingTypes@@H@Z ; CvTeam::enhanceBuilding
$LN70@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	SHORT $LL71@processTec
$LN265@processTec:

; 6618 : 			}
; 6619 : 		}
; 6620 : 	}
; 6621 : 
; 6622 : 	for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)

	xor	esi, esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$[esp+216], esi
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	test	eax, eax
	jle	$LN63@processTec
	npad	6
$LL65@processTec:

; 6623 : 	{
; 6624 : 		CvImprovementEntry* pImprovementEntry = GC.getImprovementInfo((ImprovementTypes)iI);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	edi, eax

; 6625 : 		if(pImprovementEntry)

	test	edi, edi
	je	$LN64@processTec

; 6626 : 		{
; 6627 : 			for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)

	xor	esi, esi
$LL61@processTec:

; 6628 : 			{
; 6629 : 				changeImprovementYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pImprovementEntry->GetTechYieldChanges(eTech, iJ) * iChange));

	mov	eax, DWORD PTR _eTech$[esp+212]
	push	esi
	push	eax
	mov	ecx, edi
	call	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechYieldChanges
	imul	eax, ebp
	test	eax, eax
	je	SHORT $LN158@processTec
	mov	ecx, DWORD PTR [ebx+2948]
	mov	edx, DWORD PTR _iI$[esp+216]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	DWORD PTR [ecx+esi*4], eax
	lea	ecx, DWORD PTR [ecx+esi*4]
	mov	ecx, ebx
	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
$LN158@processTec:

; 6630 : 				changeImprovementNoFreshWaterYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pImprovementEntry->GetTechNoFreshWaterYieldChanges(eTech, iJ) * iChange));

	mov	edx, DWORD PTR _eTech$[esp+212]
	push	esi
	push	edx
	mov	ecx, edi
	call	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
	imul	eax, ebp
	test	eax, eax
	je	SHORT $LN161@processTec
	mov	ecx, DWORD PTR [ebx+2952]
	mov	edx, DWORD PTR _iI$[esp+216]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	DWORD PTR [ecx+esi*4], eax
	lea	ecx, DWORD PTR [ecx+esi*4]
	mov	ecx, ebx
	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
$LN161@processTec:

; 6631 : 				changeImprovementFreshWaterYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pImprovementEntry->GetTechFreshWaterYieldChanges(eTech, iJ) * iChange));

	mov	edx, DWORD PTR _eTech$[esp+212]
	push	esi
	push	edx
	mov	ecx, edi
	call	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChanges
	imul	eax, ebp
	test	eax, eax
	je	SHORT $LN60@processTec
	mov	ecx, DWORD PTR [ebx+2956]
	mov	edx, DWORD PTR _iI$[esp+216]
	mov	ecx, DWORD PTR [ecx+edx*4]
	add	DWORD PTR [ecx+esi*4], eax
	lea	ecx, DWORD PTR [ecx+esi*4]
	mov	ecx, ebx
	call	?updateYield@CvTeam@@QAEXXZ		; CvTeam::updateYield
$LN60@processTec:
	inc	esi
	cmp	esi, 6
	jl	$LL61@processTec

; 6626 : 		{
; 6627 : 			for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)

	mov	esi, DWORD PTR _iI$[esp+216]
$LN64@processTec:

; 6618 : 			}
; 6619 : 		}
; 6620 : 	}
; 6621 : 
; 6622 : 	for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)

	inc	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$[esp+216], esi
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	esi, eax
	jl	$LL65@processTec
$LN63@processTec:

; 6632 : 			}
; 6633 : 		}
; 6634 : 	}
; 6635 : 
; 6636 : 	CvPlot* pNewUnitPlot;
; 6637 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[esp+216], 0
	npad	9
$LL58@processTec:

; 6638 : 	{
; 6639 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	esi, DWORD PTR _iI$[esp+216]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 6640 : 		if(kPlayer.getTeam() == GetID() && kPlayer.isEverAlive())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN173@processTec
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN174@processTec
$LN173@processTec:
	or	eax, -1
$LN174@processTec:
	mov	edx, DWORD PTR _this$[esp+216]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN57@processTec
	cmp	BYTE PTR [esi+2268], 0
	je	$LN57@processTec

; 6641 : 		{
; 6642 : 			kPlayer.changeFeatureProductionModifier(pTech->GetFeatureProductionModifier() * iChange);

	mov	ebp, DWORD PTR _pTech$[esp+216]
	mov	ecx, ebp
	call	?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFeatureProductionModifier
	mov	ebx, DWORD PTR _iChange$[esp+212]
	imul	eax, ebx
	push	eax
	mov	ecx, esi
	call	?changeFeatureProductionModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeFeatureProductionModifier

; 6643 : 			kPlayer.changeUnitFortificationModifier(pTech->GetUnitFortificationModifier() * iChange);

	mov	ecx, ebp
	call	?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetUnitFortificationModifier
	imul	eax, ebx
	push	eax
	mov	ecx, esi
	call	?changeUnitFortificationModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeUnitFortificationModifier

; 6644 : 			kPlayer.changeUnitBaseHealModifier(pTech->GetUnitBaseHealModifier() * iChange);

	mov	ecx, ebp
	call	?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetUnitBaseHealModifier
	imul	eax, ebx
	push	eax
	mov	ecx, esi
	call	?changeUnitBaseHealModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeUnitBaseHealModifier

; 6645 : 			kPlayer.changeWorkerSpeedModifier(pTech->GetWorkerSpeedModifier() * iChange);

	mov	ecx, ebp
	call	?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetWorkerSpeedModifier
	imul	eax, ebx
	push	eax
	mov	ecx, esi
	call	?changeWorkerSpeedModifier@CvPlayer@@QAEXH@Z ; CvPlayer::changeWorkerSpeedModifier

; 6646 : 			kPlayer.ChangeInfluenceSpreadModifier(pTech->GetInfluenceSpreadModifier() * iChange);

	mov	ecx, ebp
	call	?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetInfluenceSpreadModifier
	imul	eax, ebx
	push	eax
	mov	ecx, esi
	call	?ChangeInfluenceSpreadModifier@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeInfluenceSpreadModifier

; 6647 : 			kPlayer.ChangeExtraVotesPerDiplomat(pTech->GetExtraVotesPerDiplomat() * iChange);

	mov	ecx, ebp
	call	?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ ; CvTechEntry::GetExtraVotesPerDiplomat
	imul	eax, ebx
	push	eax
	mov	ecx, esi
	call	?ChangeExtraVotesPerDiplomat@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeExtraVotesPerDiplomat

; 6648 : 
; 6649 : 			// Free promotion from this tech?
; 6650 : #ifdef AUI_WARNING_FIXES
; 6651 : 			for (uint iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); iPromotion++)
; 6652 : #else
; 6653 : 			for(int iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); iPromotion++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	test	eax, eax
	jle	SHORT $LN52@processTec
	npad	6
$LL54@processTec:

; 6654 : #endif
; 6655 : 			{
; 6656 : 				PromotionTypes ePromotion = (PromotionTypes) iPromotion;
; 6657 : 				if(pTech->IsFreePromotion(ePromotion))

	push	edi
	mov	ecx, ebp
	call	?IsFreePromotion@CvTechEntry@@QBEHH@Z	; CvTechEntry::IsFreePromotion
	test	eax, eax
	je	SHORT $LN53@processTec

; 6658 : 					kPlayer.ChangeFreePromotionCount(ePromotion, iChange);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?ChangeFreePromotionCount@CvPlayer@@QAEXW4PromotionTypes@@H@Z ; CvPlayer::ChangeFreePromotionCount
$LN53@processTec:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	edi, eax
	jl	SHORT $LL54@processTec
$LN52@processTec:

; 6659 : 			}
; 6660 : 
; 6661 : 			// Update our traits (some may have become obsolete)
; 6662 : 			kPlayer.GetPlayerTraits()->Reset();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?Reset@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Reset

; 6663 : 			kPlayer.GetPlayerTraits()->InitPlayerTraits();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?InitPlayerTraits@CvPlayerTraits@@QAEXXZ ; CvPlayerTraits::InitPlayerTraits

; 6664 : 			kPlayer.recomputePolicyCostModifier();

	mov	ecx, esi
	call	?recomputePolicyCostModifier@CvPlayer@@QAEXXZ ; CvPlayer::recomputePolicyCostModifier

; 6665 : 
; 6666 : 			// Does our trait give us a new unit when we reach this tech?
; 6667 : 			UnitTypes eLoopUnit;
; 6668 : 			int iDefaultAI;
; 6669 : 			int iUnitClass = kPlayer.GetPlayerTraits()->GetFirstFreeUnit(eTech);

	mov	eax, DWORD PTR _eTech$[esp+212]
	push	eax
	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z ; CvPlayerTraits::GetFirstFreeUnit
	mov	edi, eax

; 6670 : 			while(iUnitClass != NO_UNITCLASS)

	cmp	edi, -1
	je	$LN49@processTec
$LL50@processTec:

; 6671 : 			{
; 6672 : 				CvCivilizationInfo& playerCivilization = kPlayer.getCivilizationInfo();

	mov	ecx, esi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 6673 : 				eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iUnitClass);

	push	edi
	mov	ecx, eax
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	edi, eax

; 6674 : 				iDefaultAI = GC.GetGameUnits()->GetEntry(eLoopUnit)->GetDefaultUnitAIType();

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType

; 6675 : 				pNewUnitPlot = kPlayer.addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);

	push	eax
	push	edi
	mov	ecx, esi
	call	?addFreeUnit@CvPlayer@@QAEPAVCvPlot@@W4UnitTypes@@W4UnitAITypes@@@Z ; CvPlayer::addFreeUnit

; 6676 : 
; 6677 : 				// Notification below only tells user if their civ gets a Great Person from their trait.  But trait code allows ANY unit to be received from reaching a tech.
; 6678 : 				// So in the future we should use a different notification ("you received a new unit from your trait since you reached this tech") instead.
; 6679 : 				SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	0
	push	OFFSET $SG227297
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebx, eax

; 6680 : 				if(pNewUnitPlot && kPlayer.GetNotifications() && GC.GetGameUnits()->GetEntry(eLoopUnit)->GetSpecialUnitType() == eSpecialUnitGreatPerson)

	test	ebp, ebp
	je	$LN259@processTec
	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN259@processTec
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetSpecialUnitType
	cmp	eax, ebx
	jne	$LN259@processTec

; 6681 : 				{
; 6682 : 					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _strText$227299[esp+216]
	push	OFFSET $SG227301
	push	ecx
	call	ebx

; 6683 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");

	lea	edx, DWORD PTR _strSummary$227302[esp+224]
	push	OFFSET $SG227304
	push	edx
	mov	DWORD PTR __$EHRec$[esp+240], 0
	call	ebx
	add	esp, 16					; 00000010H

; 6684 : 					kPlayer.GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pNewUnitPlot->getX(), pNewUnitPlot->getY(), eLoopUnit);

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	-1
	push	edi
	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$227302[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 1
	call	edi
	push	eax
	lea	ecx, DWORD PTR _strText$227299[esp+236]
	call	edi
	push	eax
	push	-2083717098				; 83cd0016H
	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 6685 : 				}

	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$227302[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 0
	call	edi
	lea	ecx, DWORD PTR _strText$227299[esp+216]
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	edi
$LN259@processTec:

; 6686 : 
; 6687 : 				// Another?
; 6688 : 				iUnitClass = kPlayer.GetPlayerTraits()->GetNextFreeUnit();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ	; CvPlayerTraits::GetNextFreeUnit
	mov	edi, eax
	cmp	edi, -1
	jne	$LL50@processTec
$LN49@processTec:

; 6689 : 			}
; 6690 : 
; 6691 : 
; 6692 : 
; 6693 : 
; 6694 : 
; 6695 : // -- From CMP DLL inserted table entried, very usefull ~EAP
; 6696 : 
; 6697 : 			if(kPlayer.getCapitalCity() != NULL) 

	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN261@processTec

; 6698 : 			{
; 6699 : 		
; 6700 : 				//Free building in capital unlocked via tech?
; 6701 : 				if(kPlayer.GetPlayerTraits()->GetCapitalFreeBuildingPrereqTech() == eTech)

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
	cmp	eax, DWORD PTR _eTech$[esp+212]
	jne	SHORT $LN261@processTec

; 6702 : 				{
; 6703 : 					BuildingTypes eFreeCapitalBuilding = kPlayer.GetPlayerTraits()->GetFreeCapitalBuilding();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeCapitalBuilding
	mov	edi, eax

; 6704 : 					if(eFreeCapitalBuilding != NO_BUILDING)

	cmp	edi, -1
	je	SHORT $LN261@processTec

; 6705 : 					{
; 6706 : 						if(kPlayer.getCapitalCity()->GetCityBuildings()->GetNumRealBuilding(eFreeCapitalBuilding) > 0)

	push	edi
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	test	eax, eax
	jle	SHORT $LN260@processTec

; 6707 : 						{
; 6708 : 							kPlayer.getCapitalCity()->GetCityBuildings()->SetNumRealBuilding(eFreeCapitalBuilding, 0);

	push	0
	push	edi
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
$LN260@processTec:

; 6709 : 						}
; 6710 : 						kPlayer.getCapitalCity()->GetCityBuildings()->SetNumFreeBuilding(eFreeCapitalBuilding, 1);

	push	1
	push	edi
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding
$LN261@processTec:

; 6711 : 					}
; 6712 : 				}
; 6713 : 			}
; 6714 : 
; 6715 : 			// Free buildings (once unlocked via tech) -- From CMP DLL inserted table entried, very usefull ~EAP
; 6716 : 			CvCity* pLoopCity;
; 6717 : 			const CvCivilizationInfo& thisCiv = kPlayer.getCivilizationInfo();

	mov	ecx, esi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo

; 6718 : 			if(kPlayer.GetPlayerTraits()->GetFreeBuildingPrereqTech() == eTech)

	mov	ecx, esi
	mov	DWORD PTR _thisCiv$227311[esp+216], eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetFreeBuildingPrereqTech
	cmp	eax, DWORD PTR _eTech$[esp+212]
	jne	$LN57@processTec

; 6719 : 			{
; 6720 : 				for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	xor	ebx, ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$[esp+216], ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	$LN57@processTec
$LL266@processTec:

; 6721 : 				{
; 6722 : 					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 6723 : 					if(!pkBuildingClassInfo)

	test	eax, eax
	je	$LN41@processTec

; 6724 : 					{
; 6725 : 						continue;
; 6726 : 					}
; 6727 : 					
; 6728 : 					if (kPlayer.GetNumCitiesFreeChosenBuilding((BuildingClassTypes)iI) > 0 || kPlayer.IsFreeChosenBuildingNewCity((BuildingClassTypes)iI) || kPlayer.IsFreeBuildingAllCity((BuildingClassTypes)iI))

	push	ebx
	mov	ecx, esi
	call	?GetNumCitiesFreeChosenBuilding@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::GetNumCitiesFreeChosenBuilding
	test	eax, eax
	jg	SHORT $LN37@processTec
	push	ebx
	mov	ecx, esi
	call	?IsFreeChosenBuildingNewCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeChosenBuildingNewCity
	test	al, al
	jne	SHORT $LN37@processTec
	push	ebx
	mov	ecx, esi
	call	?IsFreeBuildingAllCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeBuildingAllCity
	test	al, al
	je	$LN41@processTec
$LN37@processTec:

; 6729 : 					{
; 6730 : 						BuildingTypes eBuilding = ((BuildingTypes)(thisCiv.getCivilizationBuildings((BuildingClassTypes)iI)));

	mov	ecx, DWORD PTR _thisCiv$227311[esp+216]
	push	ebx
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	ebp, eax

; 6731 : 
; 6732 : 						if(eBuilding != NO_BUILDING)

	cmp	ebp, -1
	je	$LN41@processTec

; 6733 : 						{
; 6734 : 							CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 6735 : 							if(pkBuildingInfo)

	test	eax, eax
	je	$LN41@processTec

; 6736 : 							{
; 6737 : 								int iLoop;
; 6738 : 								for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$227330[esp+220]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	$LN41@processTec
	npad	5
$LL34@processTec:

; 6739 : 								{
; 6740 : 									//bool bHasBuildingClass = pLoopCity->HasBuildingClass((BuildingClassTypes)iI);
; 6741 : 									BuildingTypes eReplacedBuilding = eBuilding;
; 6742 : 								
; 6743 : 									if(pLoopCity->isValidBuildingLocation(eBuilding) || (eBuilding != eReplacedBuilding && pLoopCity->isValidBuildingLocation(eReplacedBuilding)))

	push	ebp
	mov	ecx, edi
	call	?isValidBuildingLocation@CvCity@@QBE_NW4BuildingTypes@@@Z ; CvCity::isValidBuildingLocation
	test	al, al
	je	$LN33@processTec

; 6744 : 									{
; 6745 : 										if (kPlayer.GetNumCitiesFreeChosenBuilding((BuildingClassTypes)iI) > 0 || kPlayer.IsFreeChosenBuildingNewCity((BuildingClassTypes)iI) || kPlayer.IsFreeBuildingAllCity((BuildingClassTypes)iI))

	push	ebx
	mov	ecx, esi
	call	?GetNumCitiesFreeChosenBuilding@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::GetNumCitiesFreeChosenBuilding
	test	eax, eax
	jg	SHORT $LN27@processTec
	push	ebx
	mov	ecx, esi
	call	?IsFreeChosenBuildingNewCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeChosenBuildingNewCity
	test	al, al
	jne	SHORT $LN27@processTec
	push	ebx
	mov	ecx, esi
	call	?IsFreeBuildingAllCity@CvPlayer@@QBE_NW4BuildingClassTypes@@@Z ; CvPlayer::IsFreeBuildingAllCity
	test	al, al
	je	$LN33@processTec
$LN27@processTec:

; 6746 : 										{
; 6747 : 											if (eBuilding != eReplacedBuilding)
; 6748 : 											{
; 6749 : 												pLoopCity->GetCityBuildings()->SetNumRealBuilding(eReplacedBuilding, 0);
; 6750 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eReplacedBuilding) <= 0)
; 6751 : 												{
; 6752 : 													pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eReplacedBuilding, 1);
; 6753 : 												}
; 6754 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eReplacedBuilding) > 0)
; 6755 : 												{
; 6756 : 													kPlayer.ChangeNumCitiesFreeChosenBuilding((BuildingClassTypes)iI, -1);
; 6757 : 												}
; 6758 : 												if (pLoopCity->getFirstBuildingOrder(eReplacedBuilding) == 0)
; 6759 : 												{
; 6760 : 													pLoopCity->clearOrderQueue();
; 6761 : 													pLoopCity->chooseProduction();
; 6762 : 													// Send a notification to the user that what they were building was given to them, and they need to produce something else.
; 6763 : 												}
; 6764 : 											}
; 6765 : 											else
; 6766 : 											{
; 6767 : 												if (pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)

	push	ebp
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	test	eax, eax
	jle	SHORT $LN22@processTec

; 6768 : 												{
; 6769 : 													pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);

	push	0
	push	ebp
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
$LN22@processTec:

; 6770 : 												}
; 6771 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) <= 0)

	push	ebp
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	test	eax, eax
	jg	SHORT $LN21@processTec

; 6772 : 												{
; 6773 : 													pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

	push	1
	push	ebp
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding
$LN21@processTec:

; 6774 : 												}
; 6775 : 												if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)

	push	ebp
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	test	eax, eax
	jle	SHORT $LN20@processTec

; 6776 : 												{
; 6777 : 													kPlayer.ChangeNumCitiesFreeChosenBuilding((BuildingClassTypes)iI, -1);

	push	-1
	push	ebx
	mov	ecx, esi
	call	?ChangeNumCitiesFreeChosenBuilding@CvPlayer@@QAEXW4BuildingClassTypes@@H@Z ; CvPlayer::ChangeNumCitiesFreeChosenBuilding
$LN20@processTec:

; 6778 : 												}
; 6779 : 												if (pLoopCity->getFirstBuildingOrder(eBuilding) == 0)

	push	ebp
	mov	ecx, edi
	call	?getFirstBuildingOrder@CvCity@@QBEHW4BuildingTypes@@@Z ; CvCity::getFirstBuildingOrder
	test	eax, eax
	jne	SHORT $LN33@processTec

; 6780 : 												{
; 6781 : 													pLoopCity->clearOrderQueue();

	mov	ecx, edi
	call	?clearOrderQueue@CvCity@@QAEXXZ		; CvCity::clearOrderQueue

; 6782 : 													pLoopCity->chooseProduction();

	push	0
	push	0
	push	-1
	push	-1
	push	-1
	mov	ecx, edi
	call	?chooseProduction@CvCity@@QAEXW4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@_N3@Z ; CvCity::chooseProduction
$LN33@processTec:
	push	0
	lea	ecx, DWORD PTR _iLoop$227330[esp+220]
	push	ecx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	$LL34@processTec
$LN41@processTec:

; 6719 : 			{
; 6720 : 				for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	$LL266@processTec
	mov	DWORD PTR _iI$[esp+216], ebx
$LN57@processTec:

; 6632 : 			}
; 6633 : 		}
; 6634 : 	}
; 6635 : 
; 6636 : 	CvPlot* pNewUnitPlot;
; 6637 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	eax, DWORD PTR _iI$[esp+216]
	inc	eax
	cmp	eax, 64					; 00000040H
	mov	DWORD PTR _iI$[esp+216], eax
	jl	$LL58@processTec

; 6783 : 													// Send a notification to the user that what they were building was given to them, and they need to produce something else.
; 6784 : 												}
; 6785 : 											}
; 6786 : 										}
; 6787 : 									}
; 6788 : 								}
; 6789 : 							}
; 6790 : 						}
; 6791 : 					}
; 6792 : 				}
; 6793 : 			}
; 6794 : 
; 6795 : 
; 6796 : 		}
; 6797 : 	}
; 6798 : 
; 6799 : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4028]
	xor	ebx, ebx
	test	ecx, ecx
	jle	SHORT $LN264@processTec
	mov	ebp, DWORD PTR _this$[esp+216]
	xor	edi, edi
	npad	7
$LL18@processTec:

; 6800 : 	{
; 6801 : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [eax+4068]
	add	esi, edi

; 6802 : 
; 6803 : 		eResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 6804 : 
; 6805 : 		if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN17@processTec

; 6806 : 		{
; 6807 : 			if(GC.getResourceInfo(eResource)->getTechReveal() == eTech)

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, DWORD PTR _eTech$[esp+212]
	jne	SHORT $LN17@processTec

; 6808 : 			{
; 6809 : 				pLoopPlot->updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6810 : 				if(pLoopPlot->isRevealed(m_eID))

	mov	ecx, DWORD PTR [ebp+4]
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	je	SHORT $LN17@processTec

; 6811 : 				{
; 6812 : 					pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, esi
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN17@processTec:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	ebx
	add	edi, 484				; 000001e4H
	cmp	ebx, DWORD PTR [eax+4028]
	jl	SHORT $LL18@processTec
$LN264@processTec:

; 6813 : 				}
; 6814 : 			}
; 6815 : 		}
; 6816 : 	}
; 6817 : 
; 6818 : 	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$[esp+216], edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN10@processTec
	npad	7
$LL12@processTec:

; 6819 : 	{
; 6820 : 		CvBuildInfo* pBuildInfo = GC.getBuildInfo((BuildTypes) iI);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	esi, eax

; 6821 : 		if(pBuildInfo && pBuildInfo->getTechPrereq() == eTech)

	test	esi, esi
	je	$LN11@processTec
	mov	ecx, esi
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	cmp	eax, DWORD PTR _eTech$[esp+212]
	jne	SHORT $LN11@processTec

; 6822 : 		{
; 6823 : 			if(pBuildInfo->getRoute() != NO_ROUTE)

	mov	ecx, esi
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, -1
	je	SHORT $LN11@processTec

; 6824 : 			{
; 6825 : #ifdef AUI_WARNING_FIXES
; 6826 : 				for (uint iK = 0; iK < GC.getMap().numPlots(); iK++)
; 6827 : 				{
; 6828 : 					pLoopPlot = GC.getMap().plotByIndexUnchecked(iK);
; 6829 : #else
; 6830 : 				for(iJ = 0; iJ < GC.getMap().numPlots(); iJ++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	xor	ebp, ebp
	cmp	DWORD PTR [eax+4028], ebp
	jle	SHORT $LN11@processTec
	xor	ebx, ebx
$LL7@processTec:

; 6831 : 				{
; 6832 : 					pLoopPlot = GC.getMap().plotByIndexUnchecked(iJ);

	mov	esi, DWORD PTR [eax+4068]

; 6833 : #endif
; 6834 : 
; 6835 : 					pCity = pLoopPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+ebx+104]
	add	esi, ebx
	test	eax, eax
	jl	SHORT $LN6@processTec
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN6@processTec
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 6836 : 
; 6837 : 					if(pCity != NULL)

	test	eax, eax
	je	SHORT $LN6@processTec

; 6838 : 					{
; 6839 : 						if(pCity->getTeam() == GetID())

	mov	edx, DWORD PTR _this$[esp+216]
	mov	edi, DWORD PTR [edx+4]
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, edi
	jne	SHORT $LN6@processTec

; 6840 : 						{
; 6841 : 							pLoopPlot->updateCityRoute();

	mov	ecx, esi
	call	?updateCityRoute@CvPlot@@QAEXXZ		; CvPlot::updateCityRoute
$LN6@processTec:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	ebp
	add	ebx, 484				; 000001e4H
	cmp	ebp, DWORD PTR [eax+4028]
	jl	SHORT $LL7@processTec

; 6824 : 			{
; 6825 : #ifdef AUI_WARNING_FIXES
; 6826 : 				for (uint iK = 0; iK < GC.getMap().numPlots(); iK++)
; 6827 : 				{
; 6828 : 					pLoopPlot = GC.getMap().plotByIndexUnchecked(iK);
; 6829 : #else
; 6830 : 				for(iJ = 0; iJ < GC.getMap().numPlots(); iJ++)

	mov	edi, DWORD PTR _iI$[esp+216]
$LN11@processTec:

; 6813 : 				}
; 6814 : 			}
; 6815 : 		}
; 6816 : 	}
; 6817 : 
; 6818 : 	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)

	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$[esp+216], edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	$LL12@processTec
$LN10@processTec:

; 6842 : 						}
; 6843 : 					}
; 6844 : 				}
; 6845 : 			}
; 6846 : 		}
; 6847 : 	}
; 6848 : 
; 6849 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, eax

; 6850 : 	if(pkScriptSystem)

	test	esi, esi
	je	SHORT $LN2@processTec

; 6851 : 	{
; 6852 : 		CvLuaArgsHandle args(3);

	push	3
	lea	ecx, DWORD PTR _args$227373[esp+220]
	call	??0CvLuaArgsHandle@@QAE@I@Z		; CvLuaArgsHandle::CvLuaArgsHandle

; 6853 : 		args->Push(GetID());

	mov	eax, DWORD PTR _this$[esp+216]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _args$227373[esp+216]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+228], 2
	call	eax

; 6854 : 		args->Push(eTech);

	mov	ecx, DWORD PTR _args$227373[esp+216]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _eTech$[esp+212]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 6855 : 		args->Push(iChange);

	mov	ecx, DWORD PTR _args$227373[esp+216]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iChange$[esp+212]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	call	eax

; 6856 : 
; 6857 : 		bool bResult;
; 6858 : 		LuaSupport::CallHook(pkScriptSystem, "TeamTechResearched", args.get(), bResult);

	mov	edx, DWORD PTR _args$227373[esp+216]
	lea	ecx, DWORD PTR _bResult$227374[esp+216]
	push	ecx
	push	edx
	push	OFFSET $SG227375
	push	esi
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 6859 : 	}

	lea	ecx, DWORD PTR _args$227373[esp+216]
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN2@processTec:

; 6860 : 
; 6861 : 	// End game!
; 6862 : 	if(pTech->IsEndsGame())

	mov	ecx, DWORD PTR _pTech$[esp+216]
	call	?IsEndsGame@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsEndsGame
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	test	al, al
	je	SHORT $LN1@processTec

; 6863 : 	{
; 6864 : 		GC.getGame().SetEndGameTechResearched(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	call	?SetEndGameTechResearched@CvGame@@QAEX_N@Z ; CvGame::SetEndGameTechResearched
$LN1@processTec:

; 6865 : 	}
; 6866 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+200]
	mov	DWORD PTR fs:0, ecx
	add	esp, 200				; 000000c8H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$0:
	lea	ecx, DWORD PTR _strText$227299[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$1:
	lea	ecx, DWORD PTR _strSummary$227302[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z$2:
	lea	ecx, DWORD PTR _args$227373[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?processTech@CvTeam@@IAEXW4TechTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?processTech@CvTeam@@IAEXW4TechTypes@@H@Z ENDP		; CvTeam::processTech
PUBLIC	?cancelDefensivePacts@CvTeam@@IAEXXZ		; CvTeam::cancelDefensivePacts
; Function compile flags: /Ogtpy
;	COMDAT ?cancelDefensivePacts@CvTeam@@IAEXXZ
_TEXT	SEGMENT
?cancelDefensivePacts@CvTeam@@IAEXXZ PROC		; CvTeam::cancelDefensivePacts, COMDAT
; _this$ = ecx

; 6871 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 6872 : 	int iI;
; 6873 : 
; 6874 : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	esi, esi
	mov	edi, ecx
	xor	ebx, ebx
	npad	6
$LL23@cancelDefe:

; 6875 : 	{
; 6876 : 		TeamTypes eTeam = (TeamTypes)iI;
; 6877 : 		CvTeam& kTeam = GET_TEAM(eTeam);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ebp, DWORD PTR [ebx+eax]

; 6878 : 
; 6879 : 		if(eTeam != GetID())

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN5@cancelDefe

; 6880 : 		{
; 6881 : 			if(kTeam.isAlive())

	cmp	DWORD PTR [ebp+12], 0
	jle	SHORT $LN5@cancelDefe

; 6882 : 			{
; 6883 : 				if(IsHasDefensivePact(eTeam))

	cmp	BYTE PTR [esi+edi+2248], 0
	je	SHORT $LN5@cancelDefe

; 6884 : 				{
; 6885 : 					SetHasDefensivePact(eTeam, false);

	push	0
	push	esi
	mov	ecx, edi
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 6886 : 					kTeam.SetHasDefensivePact(GetID(), false);

	mov	ecx, DWORD PTR [edi+4]
	push	0
	push	ecx
	mov	ecx, ebp
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
$LN5@cancelDefe:
	add	ebx, 2984				; 00000ba8H
	inc	esi
	cmp	ebx, 190976				; 0002ea00H
	jl	SHORT $LL23@cancelDefe
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 6887 : 				}
; 6888 : 			}
; 6889 : 		}
; 6890 : 	}
; 6891 : }

	ret	0
?cancelDefensivePacts@CvTeam@@IAEXXZ ENDP		; CvTeam::cancelDefensivePacts
_TEXT	ENDS
PUBLIC	?isAtWarWithHumans@CvTeam@@QBE_NXZ		; CvTeam::isAtWarWithHumans
; Function compile flags: /Ogtpy
;	COMDAT ?isAtWarWithHumans@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isAtWarWithHumans@CvTeam@@QBE_NXZ PROC			; CvTeam::isAtWarWithHumans, COMDAT
; _this$ = ecx

; 6913 : {//are we currently fighting a war with a human controlled civ?

	push	ebx
	push	esi
	push	edi

; 6914 : 	for(int oppTeamIdx = 0; oppTeamIdx < MAX_TEAMS; ++oppTeamIdx)

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	7
$LL4@isAtWarWit:

; 6915 : 	{
; 6916 : 		CvTeam& oppTeam = GET_TEAM((TeamTypes)oppTeamIdx);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 6917 : 		if(oppTeam.isAlive() && isAtWar((TeamTypes)oppTeamIdx) && oppTeam.isHuman())

	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN3@isAtWarWit
	cmp	BYTE PTR [edi+ebx+1928], 0
	je	SHORT $LN3@isAtWarWit
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	jne	SHORT $LN16@isAtWarWit
$LN3@isAtWarWit:

; 6914 : 	for(int oppTeamIdx = 0; oppTeamIdx < MAX_TEAMS; ++oppTeamIdx)

	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 190976				; 0002ea00H
	jl	SHORT $LL4@isAtWarWit
	pop	edi
	pop	esi

; 6920 : 		}
; 6921 : 	}
; 6922 : 	return false;

	xor	al, al
	pop	ebx

; 6923 : }

	ret	0
$LN16@isAtWarWit:
	pop	edi
	pop	esi

; 6918 : 		{//we're at war with a human team
; 6919 : 			return true;

	mov	al, 1
	pop	ebx

; 6923 : }

	ret	0
?isAtWarWithHumans@CvTeam@@QBE_NXZ ENDP			; CvTeam::isAtWarWithHumans
_TEXT	ENDS
PUBLIC	?isSimultaneousTurns@CvTeam@@QBE_NXZ		; CvTeam::isSimultaneousTurns
EXTRN	?isSimultaneousTurns@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::isSimultaneousTurns
; Function compile flags: /Ogtpy
;	COMDAT ?isSimultaneousTurns@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isSimultaneousTurns@CvTeam@@QBE_NXZ PROC		; CvTeam::isSimultaneousTurns, COMDAT
; _this$ = ecx

; 6928 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	xor	esi, esi
	mov	ebx, ecx
	add	eax, 44					; 0000002cH
	npad	10
$LL4@isSimultan:

; 6929 : 	{
; 6930 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
; 6931 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [eax+2212], 0
	lea	ecx, DWORD PTR [eax-44]
	je	SHORT $LN3@isSimultan
	mov	edx, DWORD PTR [eax]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN17@isSimultan
	mov	ebp, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ebp+edx*4]
	jmp	SHORT $LN18@isSimultan
$LN17@isSimultan:
	or	edx, -1
$LN18@isSimultan:
	cmp	edx, DWORD PTR [ebx+4]
	je	SHORT $LN25@isSimultan
$LN3@isSimultan:

; 6928 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	inc	esi
	add	eax, 63236				; 0000f704H
	cmp	esi, 64					; 00000040H
	jl	SHORT $LL4@isSimultan
	pop	edi
	pop	esi
	pop	ebp

; 6935 : 		}
; 6936 : 	}
; 6937 : 
; 6938 : 	return false;

	xor	al, al
	pop	ebx

; 6939 : }

	ret	0
$LN25@isSimultan:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 6932 : 		{
; 6933 : 			//just use the status of the first player we find for this team.
; 6934 : 			return kPlayer.isSimultaneousTurns();

	jmp	?isSimultaneousTurns@CvPlayer@@QBE_NXZ	; CvPlayer::isSimultaneousTurns
?isSimultaneousTurns@CvTeam@@QBE_NXZ ENDP		; CvTeam::isSimultaneousTurns
_TEXT	ENDS
PUBLIC	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ; CvTeam::isForceRevealedResource
; Function compile flags: /Ogtpy
;	COMDAT ?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z PROC ; CvTeam::isForceRevealedResource, COMDAT
; _this$ = ecx

; 6987 : 	std::vector<ResourceTypes>::const_iterator it;
; 6988 : 
; 6989 : 	for(it = m_aeRevealedResources.begin(); it != m_aeRevealedResources.end(); ++it)

	mov	eax, DWORD PTR [ecx+2968]
	mov	ecx, DWORD PTR [ecx+2972]
	cmp	eax, ecx
	je	SHORT $LN2@isForceRev
	mov	edx, DWORD PTR _eResource$[esp-4]
$LL13@isForceRev:

; 6990 : 	{
; 6991 : 		if(*it == eResource)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN26@isForceRev
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@isForceRev
$LN2@isForceRev:

; 6994 : 		}
; 6995 : 	}
; 6996 : 
; 6997 : 	return false;

	xor	al, al

; 6998 : }

	ret	4
$LN26@isForceRev:

; 6992 : 		{
; 6993 : 			return true;

	mov	al, 1

; 6998 : }

	ret	4
?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ENDP ; CvTeam::isForceRevealedResource
_TEXT	ENDS
PUBLIC	?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z	; CvTeam::SetCurrentEra
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedImprovementType
EXTRN	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumFreePolicies
EXTRN	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getSpiesGrantedForEveryone
EXTRN	?CreateSpy@CvPlayerEspionage@@QAEXXZ:PROC	; CvPlayerEspionage::CreateSpy
EXTRN	?GetNumSpies@CvPlayerEspionage@@QAEHXZ:PROC	; CvPlayerEspionage::GetNumSpies
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getSpiesGrantedForPlayer
EXTRN	?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z:PROC ; CvMinorCivAI::DoMajorCivEraChange
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?getNickName@CvPlayer@@QBEQBDXZ:PROC		; CvPlayer::getNickName
EXTRN	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z:PROC ; CvGlobals::getEraInfo
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getStartEra
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	?isFinalInitialized@CvGame@@QBE_NXZ:PROC	; CvGame::isFinalInitialized
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__ehfuncinfo$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
_TEXT	SEGMENT
_bResult$227774 = -801					; size = 1
_bMinorBonusesChanged$227636 = -801			; size = 1
_args$227773 = -800					; size = 4
_this$ = -800						; size = 4
tv1642 = -796						; size = 4
_pEraInfo$227694 = -796					; size = 4
_iPlayerLoop$227675 = -796				; size = 4
_pNotifications$227650 = -792				; size = 4
_strMessage$227638 = -788				; size = 80
$T237543 = -708						; size = 80
$T237542 = -708						; size = 80
_unmetPlayer$227664 = -708				; size = 80
$T237539 = -708						; size = 80
_strSummary$227639 = -628				; size = 80
_kPopupInfo$227642 = -548				; size = 536
__$EHRec$ = -12						; size = 12
_eNewValue$ = 8						; size = 4
?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z PROC		; CvTeam::SetCurrentEra, COMDAT
; _this$ = ecx

; 7049 : {

	push	-1
	push	__ehhandler$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 792				; 00000318H
	push	ebp

; 7050 : 	CvPlot* pLoopPlot;
; 7051 : #ifdef AUI_WARNING_FIXES
; 7052 : 	uint iI;
; 7053 : #else
; 7054 : 	int iI;
; 7055 : #endif
; 7056 : 
; 7057 : 	if(GetCurrentEra() != eNewValue)

	mov	ebp, DWORD PTR _eNewValue$[esp+804]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+136]
	mov	DWORD PTR _this$[esp+812], edi
	cmp	eax, ebp
	je	$LN1@SetCurrent
	push	ebx
	push	esi

; 7058 : 	{
; 7059 : 		if(!isMinorCiv())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	$LN359@SetCurrent

; 7060 : 		{
; 7061 : 			if(GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN74@SetCurrent

; 7062 : 			{
; 7063 : 				bool bMinorBonusesChanged;
; 7064 : 				bool bTemp;
; 7065 : 				Localization::String strMessage;

	mov	esi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _strMessage$227638[esp+820]
	call	esi

; 7066 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$227639[esp+820]
	mov	DWORD PTR __$EHRec$[esp+828], 0
	call	esi

; 7067 : 
; 7068 : 				
; 7069 : 				if(!isBarbarian() && (eNewValue != GC.getGame().getStartEra())){

	cmp	DWORD PTR [edi+4], 63			; 0000003fH
	mov	ebx, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[esp+828], 1
	je	$LN352@SetCurrent
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	cmp	ebp, eax
	je	$LN352@SetCurrent

; 7070 : 					//Era Popup
; 7071 : 					if (!GC.getGame().isNetworkMultiPlayer() && isHuman() && GetID() == GC.getGame().getActiveTeam()){

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	jne	SHORT $LN72@SetCurrent
	mov	ecx, edi
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	je	SHORT $LN72@SetCurrent
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN72@SetCurrent

; 7072 : 						CvPopupInfo kPopupInfo(BUTTONPOPUP_NEW_ERA, eNewValue);
; 7073 : 						DLLUI->AddPopup(kPopupInfo);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	or	eax, -1
	mov	DWORD PTR _kPopupInfo$227642[esp+824], eax
	mov	DWORD PTR _kPopupInfo$227642[esp+828], eax
	mov	DWORD PTR _kPopupInfo$227642[esp+820], ebp
	mov	DWORD PTR _kPopupInfo$227642[esp+832], 0
	mov	BYTE PTR _kPopupInfo$227642[esp+836], 0
	mov	BYTE PTR _kPopupInfo$227642[esp+837], 0
	mov	DWORD PTR _kPopupInfo$227642[esp+840], 55 ; 00000037H
	mov	BYTE PTR _kPopupInfo$227642[esp+844], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+180]
	lea	edx, DWORD PTR _kPopupInfo$227642[esp+820]
	push	edx
	call	eax
$LN72@SetCurrent:

; 7074 : 					}
; 7075 : 
; 7076 : 					//Notify Everyone
; 7077 : 					for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	xor	esi, esi
	mov	DWORD PTR tv1642[esp+820], esi
$LL71@SetCurrent:

; 7078 : 						PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyLoop;
; 7079 : 						CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ebp, DWORD PTR [esi+ecx]

; 7080 : 						CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();

	mov	ecx, ebp
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$227650[esp+820], eax

; 7081 : 						if(pNotifications && 
; 7082 : 							(kCurNotifyPlayer.getTeam() != GetID() || GC.getGame().isNetworkMultiPlayer()) &&
; 7083 : 							kCurNotifyPlayer.isAlive()){

	test	eax, eax
	je	$LN70@SetCurrent
	mov	eax, DWORD PTR [ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN110@SetCurrent
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN111@SetCurrent
$LN110@SetCurrent:
	or	eax, -1
$LN111@SetCurrent:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN67@SetCurrent
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	je	$LN70@SetCurrent
$LN67@SetCurrent:
	cmp	BYTE PTR [ebp+2256], 0
	je	$LN70@SetCurrent

; 7084 : 							strMessage = Localization::Lookup("TXT_KEY_NTFN_PLAYER_ERA");

	lea	edx, DWORD PTR $T237539[esp+820]
	push	OFFSET $SG227654
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$227638[esp+824]
	mov	BYTE PTR __$EHRec$[esp+832], 2
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237539[esp+820]
	mov	BYTE PTR __$EHRec$[esp+828], 1
	call	ebx

; 7085 : 
; 7086 : 							CvEraInfo* pkEraInfo = GC.getEraInfo(eNewValue);

	mov	eax, DWORD PTR _eNewValue$[esp+816]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo

; 7087 : 							const char* szEraTextKey = pkEraInfo->GetTextKey();

	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey

; 7088 : 
; 7089 : 							// Notify player has met this team
; 7090 : 							if(GET_TEAM(kCurNotifyPlayer.getTeam()).isHasMet(GetID()))

	mov	ecx, DWORD PTR _this$[esp+820]
	mov	esi, DWORD PTR [ecx+4]
	mov	ecx, ebp
	mov	edi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [esi+eax+1848], 0
	je	SHORT $LN66@SetCurrent

; 7091 : 							{
; 7092 : 								CvPlayerAI& player = GET_PLAYER(getLeaderID());

	mov	ecx, DWORD PTR _this$[esp+820]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID

; 7093 : 								if(GC.getGame().isGameMultiPlayer() && player.isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN65@SetCurrent
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN65@SetCurrent

; 7094 : 									strMessage << player.getNickName() << szEraTextKey;

	mov	ecx, esi
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 7095 : 								else

	jmp	SHORT $LN371@SetCurrent
$LN65@SetCurrent:

; 7096 : 									strMessage << player.getName() << szEraTextKey;

	mov	ecx, esi
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
$LN371@SetCurrent:
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strMessage$227638[esp+824]
	call	esi
	push	edi
	lea	ecx, DWORD PTR _strMessage$227638[esp+824]
	call	esi

; 7097 : 							}
; 7098 : 
; 7099 : 							// Has not met this team
; 7100 : 							else

	jmp	SHORT $LN63@SetCurrent
$LN66@SetCurrent:

; 7101 : 							{
; 7102 : 								Localization::String unmetPlayer = Localization::Lookup("TXT_KEY_UNMET_PLAYER");

	lea	edx, DWORD PTR _unmetPlayer$227664[esp+820]
	push	OFFSET $SG227666
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 7103 : 								strMessage << unmetPlayer << szEraTextKey;

	lea	eax, DWORD PTR _unmetPlayer$227664[esp+820]
	push	eax
	lea	ecx, DWORD PTR _strMessage$227638[esp+824]
	mov	BYTE PTR __$EHRec$[esp+832], 3
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NABV12@@Z
	push	edi
	lea	ecx, DWORD PTR _strMessage$227638[esp+824]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 7104 : 							}

	lea	ecx, DWORD PTR _unmetPlayer$227664[esp+820]
	mov	BYTE PTR __$EHRec$[esp+828], 1
	call	ebx
$LN63@SetCurrent:

; 7105 : 
; 7106 : 							pNotifications->Add(NOTIFICATION_OTHER_PLAYER_NEW_ERA, strMessage.toUTF8(), strMessage.toUTF8(), -1, -1, -1);

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strMessage$227638[esp+836]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strMessage$227638[esp+840]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$227650[esp+840]
	push	eax
	push	-66586748				; fc07f784H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	mov	edi, DWORD PTR _this$[esp+820]
	mov	esi, DWORD PTR tv1642[esp+820]
$LN70@SetCurrent:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv1642[esp+820], esi
	jl	$LL71@SetCurrent
$LN352@SetCurrent:

; 7107 : 						}
; 7108 : 					}
; 7109 : 				}
; 7110 : 
; 7111 : 				// Apply Minor Civ changes BEFORE setting the new era
; 7112 : 				PlayerTypes eLoopMinor;
; 7113 : 				int iMinorLoop;
; 7114 : 
; 7115 : 				PlayerTypes eLoopPlayer;
; 7116 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	ebp, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	xor	edi, edi
	mov	DWORD PTR _iPlayerLoop$227675[esp+820], edi
$LL62@SetCurrent:

; 7117 : 				{
; 7118 : 					eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 7119 : 
; 7120 : 					// Must be on this team
; 7121 : 					if(GET_PLAYER(eLoopPlayer).getTeam() != GetID())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN153@SetCurrent
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN154@SetCurrent
$LN153@SetCurrent:
	or	eax, -1
$LN154@SetCurrent:
	mov	edx, DWORD PTR _this$[esp+820]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN61@SetCurrent

; 7122 : 						continue;
; 7123 : 
; 7124 : 					// Player not ever alive
; 7125 : 					if(!GET_PLAYER(eLoopPlayer).isEverAlive())

	cmp	BYTE PTR [edi+ecx+2268], 0
	je	$LN61@SetCurrent

; 7126 : 						continue;
; 7127 : 
; 7128 : 					bMinorBonusesChanged = false;

	mov	BYTE PTR _bMinorBonusesChanged$227636[esp+820], 0
	mov	esi, 1391192				; 00153a58H
	jmp	SHORT $LN57@SetCurrent
	npad	9
$LL365@SetCurrent:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN57@SetCurrent:

; 7131 : 					{
; 7132 : 						eLoopMinor = (PlayerTypes) iMinorLoop;
; 7133 : 
; 7134 : 						// Minor not alive
; 7135 : 						if(!GET_PLAYER(eLoopMinor).isAlive())

	add	ecx, esi
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN56@SetCurrent

; 7136 : 							continue;
; 7137 : 
; 7138 : 						bTemp = GET_PLAYER(eLoopMinor).GetMinorCivAI()->DoMajorCivEraChange(eLoopPlayer, eNewValue);

	mov	eax, DWORD PTR _eNewValue$[esp+816]
	mov	edx, DWORD PTR _iPlayerLoop$227675[esp+820]
	push	eax
	push	edx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoMajorCivEraChange@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4EraTypes@@@Z ; CvMinorCivAI::DoMajorCivEraChange

; 7139 : 
; 7140 : 						if(bTemp)

	test	al, al
	je	SHORT $LN56@SetCurrent

; 7141 : 							bMinorBonusesChanged = true;

	mov	BYTE PTR _bMinorBonusesChanged$227636[esp+820], 1
$LN56@SetCurrent:

; 7129 : 
; 7130 : 					for(iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL365@SetCurrent

; 7142 : 					}
; 7143 : 
; 7144 : 					if(bMinorBonusesChanged)

	cmp	BYTE PTR _bMinorBonusesChanged$227636[esp+820], 0
	je	$LN61@SetCurrent

; 7145 : 					{
; 7146 : 						if(GET_PLAYER(eLoopPlayer).GetNotifications())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN61@SetCurrent

; 7147 : 						{
; 7148 : 							strMessage = Localization::Lookup("TXT_KEY_NTFN_MINOR_BONUSES_CHANGED");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR $T237542[esp+820]
	push	OFFSET $SG227691
	push	ecx
	call	esi
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMessage$227638[esp+824]
	mov	BYTE PTR __$EHRec$[esp+832], 4
	call	ebp
	lea	ecx, DWORD PTR $T237542[esp+820]
	mov	BYTE PTR __$EHRec$[esp+828], 1
	call	ebx

; 7149 : 							strSummary = Localization::Lookup("TXT_KEY_NTFN_MINOR_BONUSES_CHANGED_SM");

	lea	edx, DWORD PTR $T237543[esp+820]
	push	OFFSET $SG227693
	push	edx
	call	esi
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$227639[esp+824]
	mov	BYTE PTR __$EHRec$[esp+832], 5
	call	ebp
	lea	ecx, DWORD PTR $T237543[esp+820]
	mov	BYTE PTR __$EHRec$[esp+828], 1
	call	ebx

; 7150 : 							GET_PLAYER(eLoopPlayer).GetNotifications()->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$227639[esp+836]
	lea	esi, DWORD PTR [edi+eax]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$227638[esp+840]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-967190754				; c659d71eH
	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN61@SetCurrent:
	inc	DWORD PTR _iPlayerLoop$227675[esp+820]
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jl	$LL62@SetCurrent

; 7151 : 						}
; 7152 : 					}
; 7153 : 				}
; 7154 : 			}

	lea	ecx, DWORD PTR _strSummary$227639[esp+820]
	mov	BYTE PTR __$EHRec$[esp+828], 0
	call	ebx
	lea	ecx, DWORD PTR _strMessage$227638[esp+820]
	mov	DWORD PTR __$EHRec$[esp+828], -1
	call	ebx
	mov	ebp, DWORD PTR _eNewValue$[esp+816]
	mov	edi, DWORD PTR _this$[esp+820]
$LN74@SetCurrent:

; 7155 : 
; 7156 : 			CvEraInfo* pEraInfo = GC.getEraInfo(eNewValue);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ebx, eax

; 7157 : 			if(pEraInfo->getSpiesGrantedForPlayer() > 0)

	mov	ecx, ebx
	mov	DWORD PTR _pEraInfo$227694[esp+820], ebx
	call	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForPlayer
	test	eax, eax
	jle	$LN47@SetCurrent

; 7158 : 			{
; 7159 : 				PlayerTypes ePlayer;
; 7160 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	ebp, ebp
	npad	13
$LL49@SetCurrent:

; 7161 : 				{
; 7162 : 					ePlayer = (PlayerTypes) iPlayerLoop;
; 7163 : 					CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7164 : 					if(kPlayer.isAlive() && kPlayer.getTeam() == GetID() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())

	cmp	BYTE PTR [ecx+ebp+2256], 0
	lea	esi, DWORD PTR [ecx+ebp]
	je	$LN48@SetCurrent
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN188@SetCurrent
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN189@SetCurrent
$LN188@SetCurrent:
	or	eax, -1
$LN189@SetCurrent:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN48@SetCurrent
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN356@SetCurrent
	mov	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN356@SetCurrent

; 7165 : 					{
; 7166 : 						// provide the player with the extra spies according to their trait when they get their first spy
; 7167 : 						if (kPlayer.GetEspionage()->GetNumSpies() == 0)

	mov	ecx, esi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetNumSpies@CvPlayerEspionage@@QAEHXZ	; CvPlayerEspionage::GetNumSpies
	test	eax, eax
	jne	SHORT $LN42@SetCurrent

; 7168 : 						{
; 7169 : 							int iNumTraitSpies = kPlayer.GetPlayerTraits()->GetExtraSpies();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+272]

; 7170 : 							for (int i = 0; i < iNumTraitSpies; i++)

	test	eax, eax
	jle	SHORT $LN42@SetCurrent

; 7168 : 						{
; 7169 : 							int iNumTraitSpies = kPlayer.GetPlayerTraits()->GetExtraSpies();

	mov	edi, eax
$LL44@SetCurrent:

; 7171 : 							{
; 7172 : 								kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, esi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy
	sub	edi, 1
	jne	SHORT $LL44@SetCurrent
$LN42@SetCurrent:

; 7173 : 							}
; 7174 : 						}
; 7175 : 
; 7176 : 						for(int i = 0; i < pEraInfo->getSpiesGrantedForPlayer(); i++)

	mov	ecx, ebx
	xor	edi, edi
	call	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForPlayer
	test	eax, eax
	jle	SHORT $LN356@SetCurrent
$LL41@SetCurrent:

; 7177 : 						{
; 7178 : 							kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, esi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy
	mov	ecx, ebx
	inc	edi
	call	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForPlayer
	cmp	edi, eax
	jl	SHORT $LL41@SetCurrent
$LN356@SetCurrent:

; 7173 : 							}
; 7174 : 						}
; 7175 : 
; 7176 : 						for(int i = 0; i < pEraInfo->getSpiesGrantedForPlayer(); i++)

	mov	edi, DWORD PTR _this$[esp+820]
$LN48@SetCurrent:

; 7158 : 			{
; 7159 : 				PlayerTypes ePlayer;
; 7160 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	add	ebp, 63236				; 0000f704H
	cmp	ebp, 3983868				; 003cc9fcH
	jl	$LL49@SetCurrent
$LN47@SetCurrent:

; 7179 : 						}
; 7180 : 					}
; 7181 : 				}
; 7182 : 			}
; 7183 : 
; 7184 : 			if(pEraInfo->getSpiesGrantedForEveryone() > 0)

	mov	ecx, ebx
	call	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForEveryone
	test	eax, eax
	jle	$LN359@SetCurrent

; 7185 : 			{
; 7186 : 				// check to see if anyone else has reached or surpassed this era yet
; 7187 : 				bool bAlreadyProvided = false;
; 7188 : 				PlayerTypes ePlayer;
; 7189 : 				TeamTypes eTeam;
; 7190 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	edi, edi
$LL37@SetCurrent:

; 7191 : 				{
; 7192 : 					ePlayer = (PlayerTypes) iPlayerLoop;
; 7193 : 					CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7194 : 					if (kPlayer.isEverAlive() && !kPlayer.isBarbarian() && !kPlayer.isMinorCiv())

	cmp	BYTE PTR [edi+edx+2268], 0
	lea	esi, DWORD PTR [edi+edx]
	je	SHORT $LN36@SetCurrent
	mov	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN36@SetCurrent
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN36@SetCurrent

; 7195 : 					{
; 7196 : 						eTeam = kPlayer.getTeam();

	mov	esi, DWORD PTR [esi+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN207@SetCurrent
	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN208@SetCurrent
$LN207@SetCurrent:
	or	eax, -1
$LN208@SetCurrent:

; 7197 : 
; 7198 : 						if(GET_TEAM(eTeam).GetCurrentEra() >= eNewValue)

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	eax, 2984				; 00000ba8H
	mov	ecx, DWORD PTR _eNewValue$[esp+816]
	cmp	DWORD PTR [eax+edx+136], ecx
	jge	$LN359@SetCurrent
$LN36@SetCurrent:

; 7185 : 			{
; 7186 : 				// check to see if anyone else has reached or surpassed this era yet
; 7187 : 				bool bAlreadyProvided = false;
; 7188 : 				PlayerTypes ePlayer;
; 7189 : 				TeamTypes eTeam;
; 7190 : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jl	SHORT $LL37@SetCurrent

; 7199 : 						{
; 7200 : 							bAlreadyProvided = true;
; 7201 : 							break;
; 7202 : 						}
; 7203 : 					}
; 7204 : 				}
; 7205 : 
; 7206 : 				if(!bAlreadyProvided)
; 7207 : 				{
; 7208 : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	ebx, ebx
$LL366@SetCurrent:

; 7209 : 					{
; 7210 : 						ePlayer = (PlayerTypes) iPlayerLoop;
; 7211 : 						CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7212 : 						if(!kPlayer.isAlive() || kPlayer.isBarbarian() || kPlayer.isMinorCiv())

	cmp	BYTE PTR [ebx+edx+2256], 0
	lea	esi, DWORD PTR [ebx+edx]
	je	$LN30@SetCurrent
	mov	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN30@SetCurrent
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN30@SetCurrent

; 7213 : 						{
; 7214 : 							continue;
; 7215 : 						}
; 7216 : 
; 7217 : 						for(int i = 0; i < pEraInfo->getSpiesGrantedForEveryone(); i++)

	mov	ecx, DWORD PTR _pEraInfo$227694[esp+820]
	xor	ebp, ebp
	call	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForEveryone
	test	eax, eax
	jle	SHORT $LN30@SetCurrent
	npad	2
$LL26@SetCurrent:

; 7218 : 						{
; 7219 : 							// provide the player with the extra spies according to their trait when they get their first spy
; 7220 : 							if (kPlayer.GetEspionage()->GetNumSpies() == 0)

	mov	ecx, esi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetNumSpies@CvPlayerEspionage@@QAEHXZ	; CvPlayerEspionage::GetNumSpies
	test	eax, eax
	jne	SHORT $LN20@SetCurrent

; 7221 : 							{
; 7222 : 								int iNumTraitSpies = kPlayer.GetPlayerTraits()->GetExtraSpies();

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+272]

; 7223 : 								for (int iIndex = 0; iIndex < iNumTraitSpies; iIndex++)

	test	eax, eax
	jle	SHORT $LN20@SetCurrent

; 7221 : 							{
; 7222 : 								int iNumTraitSpies = kPlayer.GetPlayerTraits()->GetExtraSpies();

	mov	edi, eax
$LL22@SetCurrent:

; 7224 : 								{
; 7225 : 									kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, esi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy
	sub	edi, 1
	jne	SHORT $LL22@SetCurrent
$LN20@SetCurrent:

; 7226 : 								}
; 7227 : 							}
; 7228 : 							kPlayer.GetEspionage()->CreateSpy();

	mov	ecx, esi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?CreateSpy@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::CreateSpy
	mov	ecx, DWORD PTR _pEraInfo$227694[esp+820]
	inc	ebp
	call	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ ; CvEraInfo::getSpiesGrantedForEveryone
	cmp	ebp, eax
	jl	SHORT $LL26@SetCurrent
$LN30@SetCurrent:

; 7199 : 						{
; 7200 : 							bAlreadyProvided = true;
; 7201 : 							break;
; 7202 : 						}
; 7203 : 					}
; 7204 : 				}
; 7205 : 
; 7206 : 				if(!bAlreadyProvided)
; 7207 : 				{
; 7208 : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	add	ebx, 63236				; 0000f704H
	cmp	ebx, 3983868				; 003cc9fcH
	jl	$LL366@SetCurrent
$LN359@SetCurrent:

; 7229 : 						}
; 7230 : 					}
; 7231 : 				}
; 7232 : 			}
; 7233 : 		}
; 7234 : 
; 7235 : 		// Trait to provide free policies on era change?
; 7236 : 		PlayerTypes ePlayer;
; 7237 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	ebx, DWORD PTR _this$[esp+820]
	xor	edi, edi
	npad	4
$LL19@SetCurrent:

; 7238 : 		{
; 7239 : 			ePlayer = (PlayerTypes) iPlayerLoop;
; 7240 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7241 : 			if(kPlayer.isAlive() && kPlayer.getTeam() == GetID() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	esi, DWORD PTR [edi+eax]
	je	SHORT $LN18@SetCurrent
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN234@SetCurrent
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN235@SetCurrent
$LN234@SetCurrent:
	or	eax, -1
$LN235@SetCurrent:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN18@SetCurrent
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN18@SetCurrent
	mov	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN18@SetCurrent

; 7242 : 			{
; 7243 : 				int iNumFreePolicies = kPlayer.GetPlayerTraits()->GetFreeSocialPoliciesPerEra() > 0;

	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+288]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	eax, ecx

; 7244 : 				if (iNumFreePolicies > 0)

	test	eax, eax
	jle	SHORT $LN18@SetCurrent

; 7245 : 				{
; 7246 : 					kPlayer.ChangeNumFreePolicies(iNumFreePolicies);

	push	eax
	mov	ecx, esi
	call	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePolicies
$LN18@SetCurrent:
	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jl	SHORT $LL19@SetCurrent

; 7247 : 				}
; 7248 : 			}
; 7249 : 		}
; 7250 : 
; 7251 : 		m_eCurrentEra = eNewValue;

	mov	edx, DWORD PTR _eNewValue$[esp+816]
	mov	DWORD PTR [ebx+136], edx

; 7252 : 
; 7253 : 		if(GC.getGame().getActiveTeam() != NO_TEAM)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, -1
	je	$LN11@SetCurrent

; 7254 : 		{
; 7255 : 			for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	xor	ebx, ebx
	cmp	DWORD PTR [eax+4028], ebx
	jle	$LN11@SetCurrent
	xor	ebp, ebp
	npad	4
$LL13@SetCurrent:

; 7256 : 			{
; 7257 : 				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [eax+4068]

; 7258 : 
; 7259 : 				if(pLoopPlot->getRevealedImprovementType(GC.getGame().getActiveTeam(), true) != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	add	esi, ebp
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, esi
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
	cmp	eax, -1
	je	SHORT $LN12@SetCurrent

; 7260 : 				{
; 7261 : 					if((pLoopPlot->getTeam() == GetID()) ||
; 7262 : 					        (!pLoopPlot->isOwned() && GetID() == GC.getGame().getActiveTeam()))

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN256@SetCurrent
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN256@SetCurrent
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN255@SetCurrent
$LN256@SetCurrent:
	or	eax, -1
$LN255@SetCurrent:
	mov	ecx, DWORD PTR _this$[esp+820]
	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $LN8@SetCurrent
	mov	ecx, esi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	jne	SHORT $LN12@SetCurrent
	mov	edx, DWORD PTR _this$[esp+820]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [edx+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN12@SetCurrent
$LN8@SetCurrent:

; 7263 : 					{
; 7264 : 						pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, esi
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN12@SetCurrent:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	ebx
	add	ebp, 484				; 000001e4H
	cmp	ebx, DWORD PTR [eax+4028]
	jl	$LL13@SetCurrent
$LN11@SetCurrent:

; 7265 : 					}
; 7266 : 				}
; 7267 : 			}
; 7268 : 		}
; 7269 : 
; 7270 : 		// need to map gameplay eras to the artwork eras
; 7271 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, DWORD PTR _this$[esp+820]
	mov	ebp, DWORD PTR _eNewValue$[esp+816]
	xor	edi, edi
	xor	esi, esi
$LL7@SetCurrent:

; 7272 : 		{
; 7273 : 			ePlayer = (PlayerTypes) iPlayerLoop;
; 7274 : 
; 7275 : 			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
; 7276 : 			if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN6@SetCurrent
	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN284@SetCurrent
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN285@SetCurrent
$LN284@SetCurrent:
	or	eax, -1
$LN285@SetCurrent:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN6@SetCurrent

; 7277 : 			{
; 7278 : 				gDLL->GameplayEraChanged(ePlayer, eNewValue);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+576]
	push	ebp
	push	edi
	call	edx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN6@SetCurrent:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL7@SetCurrent

; 7279 : 			}
; 7280 : 		}
; 7281 : 
; 7282 : 		if(GC.getGame().getActiveTeam() == GetID() && isBridgeBuilding() && eNewValue >= GC.getLAST_BRIDGE_ART_ERA())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ebx+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, esi
	jne	SHORT $LN363@SetCurrent
	cmp	DWORD PTR [ebx+76], 0
	jle	SHORT $LN363@SetCurrent
	cmp	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8496
	jl	SHORT $LN363@SetCurrent

; 7283 : 		{
; 7284 : 			gDLL->GameplayBridgeChanged(true, 1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+580]
	push	1
	push	1
	call	edx
$LN363@SetCurrent:

; 7285 : 		}
; 7286 : 
; 7287 : 		if(GetID() == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ebx+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN2@SetCurrent

; 7288 : 		{
; 7289 : 			DLLUI->setDirty(Soundtrack_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	28					; 0000001cH
	call	edx
$LN2@SetCurrent:

; 7290 : 		}
; 7291 : 
; 7292 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, eax

; 7293 : 		if(pkScriptSystem)

	test	esi, esi
	je	$LN369@SetCurrent

; 7294 : 		{
; 7295 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$227773[esp+820]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 7296 : 			args->Push(GetID());

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _args$227773[esp+820]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+832], 6
	call	eax

; 7297 : 			args->Push(GetCurrentEra());

	mov	eax, DWORD PTR [ebx+136]
	mov	ecx, DWORD PTR _args$227773[esp+820]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 7298 : 			
; 7299 : 			bool bResult = false;
; 7300 : 			LuaSupport::CallHook(pkScriptSystem, "TeamSetEra", args.get(), bResult);

	mov	edx, DWORD PTR _args$227773[esp+820]
	lea	ecx, DWORD PTR _bResult$227774[esp+820]
	push	ecx
	push	edx
	push	OFFSET $SG227775
	push	esi
	mov	BYTE PTR _bResult$227774[esp+836], 0
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 7301 : 		}

	lea	ecx, DWORD PTR _args$227773[esp+820]
	mov	DWORD PTR __$EHRec$[esp+828], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN369@SetCurrent:
	pop	esi
	pop	ebx
$LN1@SetCurrent:

; 7302 : 	}
; 7303 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+812]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 804				; 00000324H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMessage$227638[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$227639[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$2:
	lea	ecx, DWORD PTR $T237539[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$3:
	lea	ecx, DWORD PTR _unmetPlayer$227664[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$4:
	lea	ecx, DWORD PTR $T237542[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$5:
	lea	ecx, DWORD PTR $T237543[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z$6:
	lea	ecx, DWORD PTR _args$227773[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z ENDP		; CvTeam::SetCurrentEra
PUBLIC	?countNumHumanGameTurnActive@CvTeam@@QBEHXZ	; CvTeam::countNumHumanGameTurnActive
EXTRN	?isTurnActive@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isTurnActive
; Function compile flags: /Ogtpy
;	COMDAT ?countNumHumanGameTurnActive@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?countNumHumanGameTurnActive@CvTeam@@QBEHXZ PROC	; CvTeam::countNumHumanGameTurnActive, COMDAT
; _this$ = ecx

; 7307 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 7308 : 	int iCount = 0;

	xor	ebx, ebx
	mov	ebp, ecx
	xor	edi, edi
	npad	6
$LL5@countNumHu:

; 7311 : 	{
; 7312 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	esi, DWORD PTR [edi+eax]

; 7313 : 
; 7314 : 		if(kLoopPlayer.isHuman() && kLoopPlayer.getTeam() == GetID())

	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN4@countNumHu
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@countNumHu
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN15@countNumHu
$LN14@countNumHu:
	or	eax, -1
$LN15@countNumHu:
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN4@countNumHu

; 7315 : 		{
; 7316 : 			if(kLoopPlayer.isTurnActive())

	mov	ecx, esi
	call	?isTurnActive@CvPlayer@@QBE_NXZ		; CvPlayer::isTurnActive
	test	al, al
	je	SHORT $LN4@countNumHu

; 7317 : 			{
; 7318 : 				++iCount;

	inc	ebx
$LN4@countNumHu:

; 7309 : 
; 7310 : 	for(int iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jl	SHORT $LL5@countNumHu
	pop	edi
	pop	esi
	pop	ebp

; 7319 : 			}
; 7320 : 		}
; 7321 : 	}
; 7322 : 
; 7323 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 7324 : }

	ret	0
?countNumHumanGameTurnActive@CvTeam@@QBEHXZ ENDP	; CvTeam::countNumHumanGameTurnActive
_TEXT	ENDS
PUBLIC	?setTurnActive@CvTeam@@QAEX_N0@Z		; CvTeam::setTurnActive
EXTRN	?setTurnActive@CvPlayer@@QAEX_N0@Z:PROC		; CvPlayer::setTurnActive
; Function compile flags: /Ogtpy
;	COMDAT ?setTurnActive@CvTeam@@QAEX_N0@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
_bDoTurn$ = 12						; size = 1
?setTurnActive@CvTeam@@QAEX_N0@Z PROC			; CvTeam::setTurnActive, COMDAT
; _this$ = ecx

; 7328 : {

	push	ebx

; 7329 : 	CvAssert(GC.getGame().isSimultaneousTeamTurns());
; 7330 : 
; 7331 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	ebx, DWORD PTR _bDoTurn$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _bNewValue$[esp+12]
	mov	ebp, ecx
	xor	esi, esi
$LL4@setTurnAct:

; 7332 : 	{
; 7333 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7334 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN3@setTurnAct
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN17@setTurnAct
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN18@setTurnAct
$LN17@setTurnAct:
	or	eax, -1
$LN18@setTurnAct:
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN3@setTurnAct

; 7335 : 		{
; 7336 : 			kPlayer.setTurnActive(bNewValue, bDoTurn);

	push	ebx
	push	edi
	call	?setTurnActive@CvPlayer@@QAEX_N0@Z	; CvPlayer::setTurnActive
$LN3@setTurnAct:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL4@setTurnAct
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7337 : 		}
; 7338 : 	}
; 7339 : }

	ret	8
?setTurnActive@CvTeam@@QAEX_N0@Z ENDP			; CvTeam::setTurnActive
_TEXT	ENDS
PUBLIC	?isTurnActive@CvTeam@@QBE_NXZ			; CvTeam::isTurnActive
; Function compile flags: /Ogtpy
;	COMDAT ?isTurnActive@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isTurnActive@CvTeam@@QBE_NXZ PROC			; CvTeam::isTurnActive, COMDAT
; _this$ = ecx

; 7343 : {

	push	esi
	push	edi
	mov	edi, ecx

; 7344 : 	CvAssert(GC.getGame().isSimultaneousTeamTurns());
; 7345 : 
; 7346 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	xor	esi, esi
	npad	10
$LL5@isTurnActi:

; 7347 : 	{
; 7348 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7349 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN4@isTurnActi
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@isTurnActi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN19@isTurnActi
$LN18@isTurnActi:
	or	eax, -1
$LN19@isTurnActi:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN4@isTurnActi

; 7350 : 		{
; 7351 : 			if(kPlayer.isTurnActive())

	call	?isTurnActive@CvPlayer@@QBE_NXZ		; CvPlayer::isTurnActive
	test	al, al
	jne	SHORT $LN26@isTurnActi
$LN4@isTurnActi:

; 7344 : 	CvAssert(GC.getGame().isSimultaneousTeamTurns());
; 7345 : 
; 7346 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL5@isTurnActi
	pop	edi

; 7354 : 			}
; 7355 : 		}
; 7356 : 	}
; 7357 : 
; 7358 : 	return false;

	xor	al, al
	pop	esi

; 7359 : }

	ret	0
$LN26@isTurnActi:
	pop	edi

; 7352 : 			{
; 7353 : 				return true;

	mov	al, 1
	pop	esi

; 7359 : }

	ret	0
?isTurnActive@CvTeam@@QBE_NXZ ENDP			; CvTeam::isTurnActive
_TEXT	ENDS
PUBLIC	?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z	; CvTeam::setDynamicTurnsSimultMode
EXTRN	?setDynamicTurnsSimultMode@CvPlayer@@QAEX_N@Z:PROC ; CvPlayer::setDynamicTurnsSimultMode
; Function compile flags: /Ogtpy
;	COMDAT ?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z
_TEXT	SEGMENT
_simultaneousTurns$ = 8					; size = 1
?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z PROC	; CvTeam::setDynamicTurnsSimultMode, COMDAT
; _this$ = ecx

; 7512 : {//set DynamicTurnsSimultMode for every player on this team.

	push	ebx
	push	esi
	push	edi

; 7513 : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)

	mov	edi, DWORD PTR _simultaneousTurns$[esp+8]
	mov	ebx, ecx
	xor	esi, esi
	npad	5
$LL4@setDynamic:

; 7514 : 	{
; 7515 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7516 : 		if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN3@setDynamic
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN17@setDynamic
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN18@setDynamic
$LN17@setDynamic:
	or	eax, -1
$LN18@setDynamic:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN3@setDynamic

; 7517 : 		{
; 7518 : 			kPlayer.setDynamicTurnsSimultMode(simultaneousTurns);

	push	edi
	call	?setDynamicTurnsSimultMode@CvPlayer@@QAEX_N@Z ; CvPlayer::setDynamicTurnsSimultMode
$LN3@setDynamic:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL4@setDynamic
	pop	edi
	pop	esi
	pop	ebx

; 7519 : 		}
; 7520 : 	}
; 7521 : }

	ret	4
?setDynamicTurnsSimultMode@CvTeam@@QAEX_N@Z ENDP	; CvTeam::setDynamicTurnsSimultMode
_TEXT	ENDS
PUBLIC	?Write@CvTeam@@UBEXAAVFDataStream@@@Z		; CvTeam::Write
EXTRN	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z:PROC ; ImprovementArrayHelpers::WriteYieldArray
EXTRN	?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z:PROC	; CvTeamTechs::Write
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
EXTRN	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; BuildingArrayHelpers::Write
EXTRN	?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; BuildingClassArrayHelpers::Write
EXTRN	?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; UnitClassArrayHelpers::Write
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
EXTRN	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVoteSourceInfos
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvTeam@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -12					; size = 4
$T238304 = -8						; size = 8
$T238303 = -8						; size = 8
$T238302 = -8						; size = 8
$T238301 = -8						; size = 8
$T238300 = -8						; size = 8
$T238299 = -8						; size = 8
$T238298 = -8						; size = 8
$T238297 = -8						; size = 8
$T238296 = -8						; size = 8
$T238295 = -8						; size = 8
tv761 = 8						; size = 4
tv86 = 8						; size = 4
$T238305 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvTeam@@UBEXAAVFDataStream@@@Z PROC		; CvTeam::Write, COMDAT
; _this$ = ecx

; 7712 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 7713 : 	// Current version number
; 7714 : 	uint uiVersion = 1;
; 7715 : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+20]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+32], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 7716 : 
; 7717 : 	kStream << m_iNumMembers;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7718 : 	kStream << m_iAliveCount;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7719 : 	kStream << m_iEverAliveCount;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7720 : 	kStream << m_iNumCities;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7721 : 	kStream << m_iTotalPopulation;

	lea	edx, DWORD PTR [edi+24]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7722 : 	kStream << m_iTotalLand;

	lea	eax, DWORD PTR [edi+28]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7723 : 	kStream << m_iNukeInterception;

	lea	ecx, DWORD PTR [edi+32]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7724 : 	kStream << m_iExtraWaterSeeFromCount;

	lea	edx, DWORD PTR [edi+36]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7725 : 	kStream << m_iMapTradingCount;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7726 : 	kStream << m_iTechTradingCount;

	lea	ecx, DWORD PTR [edi+44]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7727 : 	kStream << m_iGoldTradingCount;

	lea	edx, DWORD PTR [edi+48]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7728 : 	kStream << m_iAllowEmbassyTradingAllowedCount;

	lea	eax, DWORD PTR [edi+52]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7729 : 	kStream << m_iOpenBordersTradingAllowedCount;

	lea	ecx, DWORD PTR [edi+56]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7730 : 	kStream << m_iDefensivePactTradingAllowedCount;

	lea	edx, DWORD PTR [edi+60]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7731 : 	kStream << m_iResearchAgreementTradingAllowedCount;

	lea	eax, DWORD PTR [edi+64]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7732 : 	kStream << m_iTradeAgreementTradingAllowedCount;

	lea	ecx, DWORD PTR [edi+68]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7733 : 	kStream << m_iPermanentAllianceTradingCount;

	lea	edx, DWORD PTR [edi+72]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7734 : 	kStream << m_iBridgeBuildingCount;

	lea	eax, DWORD PTR [edi+76]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7735 : 	kStream << m_iWaterWorkCount;

	lea	ecx, DWORD PTR [edi+80]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7736 : 	kStream << m_iRiverTradeCount;

	lea	edx, DWORD PTR [edi+84]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7737 : 	kStream << m_iBorderObstacleCount;

	lea	eax, DWORD PTR [edi+88]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7738 : 	kStream << m_iVictoryPoints;

	lea	ecx, DWORD PTR [edi+92]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7739 : 	kStream << m_iEmbarkedExtraMoves;

	lea	edx, DWORD PTR [edi+96]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7740 : 	//EAP: Extra embarked sight on tech
; 7741 : 	kStream << m_iEmbarkedExtraSight;

	lea	eax, DWORD PTR [edi+100]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7742 : 	kStream << m_iCanEmbarkCount;

	lea	ecx, DWORD PTR [edi+104]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7743 : 	kStream << m_iDefensiveEmbarkCount;

	lea	edx, DWORD PTR [edi+108]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7744 : 	kStream << m_iEmbarkedAllWaterPassageCount;

	lea	eax, DWORD PTR [edi+112]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7745 : 	kStream << m_iNumNaturalWondersDiscovered;

	lea	ecx, DWORD PTR [edi+116]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7746 : 	kStream << m_iBestPossibleRoute;

	lea	edx, DWORD PTR [edi+120]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7747 : 	kStream << m_iNumMinorCivsAttacked;

	lea	eax, DWORD PTR [edi+124]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7748 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 7749 : 	kStream << m_iBestRouteFlatCostMultiplier;
; 7750 : 	kStream << m_iBestRouteNormalCostMultiplier;
; 7751 : 	kStream << m_iUseFlatCostIfBelowThis;
; 7752 : #endif
; 7753 : 
; 7754 : 	kStream << m_bMapCentering;

	lea	ecx, DWORD PTR [edi+128]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7755 : 	kStream << m_bHasBrokenPeaceTreaty;

	lea	edx, DWORD PTR [edi+129]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7756 : 	kStream << m_bHomeOfUnitedNations;

	lea	eax, DWORD PTR [edi+130]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7757 : 	kStream << m_bHasTechForWorldCongress;

	lea	ecx, DWORD PTR [edi+131]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7758 : 
; 7759 : 	kStream << m_bBrokenMilitaryPromise;

	lea	edx, DWORD PTR [edi+132]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7760 : 	kStream << m_bBrokenExpansionPromise;

	lea	eax, DWORD PTR [edi+133]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7761 : 	kStream << m_bBrokenBorderPromise;

	lea	ecx, DWORD PTR [edi+134]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7762 : 	kStream << m_bBrokenCityStatePromise;

	lea	edx, DWORD PTR [edi+135]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 7763 : 
; 7764 : 	kStream << m_eID;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z ; operator<<

; 7765 : 
; 7766 : 	kStream << m_eCurrentEra;

	lea	ecx, DWORD PTR [edi+136]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<

; 7767 : 	kStream << m_eLiberatedByTeam;

	lea	edx, DWORD PTR [edi+140]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z ; operator<<

; 7768 : 	kStream << m_eKilledByTeam;

	lea	eax, DWORD PTR [edi+144]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TeamTypes@@@Z ; operator<<
	add	esp, 32					; 00000020H

; 7769 : 
; 7770 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiTechShareCount[0]);

	lea	ebx, DWORD PTR [edi+148]
	mov	ebp, 64					; 00000040H
	npad	6
$LL93@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL93@Write

; 7771 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiNumTurnsAtWar[0]);

	lea	ebx, DWORD PTR [edi+468]
	mov	ebp, 64					; 00000040H
	npad	5
$LL108@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL108@Write

; 7772 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiNumTurnsLockedIntoWar[0]);

	lea	ebx, DWORD PTR [edi+788]
	mov	ebp, 64					; 00000040H
	npad	5
$LL123@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL123@Write

; 7773 : 	kStream << ArrayWrapperConst<int>(NUM_DOMAIN_TYPES, &m_aiExtraMoves[0]);

	lea	ebx, DWORD PTR [edi+1108]
	mov	ebp, 5
	npad	5
$LL138@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL138@Write

; 7774 : 
; 7775 : 	CvInfosSerializationHelper::WriteHashedDataArray<VoteSourceTypes, int>(kStream, m_aiForceTeamVoteEligibilityCount, GC.getNumVoteSourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumVoteSourceInfos
	mov	ecx, DWORD PTR [edi+2892]
	push	eax
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4VoteSourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VoteSourceTypes,int>
	add	esp, 12					; 0000000cH

; 7776 : 
; 7777 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_paiTurnMadePeaceTreatyWithTeam[0]);

	lea	ebx, DWORD PTR [edi+1128]
	mov	ebp, 64					; 00000040H
$LL153@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL153@Write

; 7778 : 	kStream << ArrayWrapperConst<int>(MAX_TEAMS, &m_aiIgnoreWarningCount[0]);

	mov	ebp, 64					; 00000040H
	lea	ebx, DWORD PTR [edi+1448]
	mov	DWORD PTR tv86[esp+24], ebp
$LL168@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	DWORD PTR tv86[esp+24], 1
	jne	SHORT $LL168@Write

; 7779 : 
; 7780 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abHasMet[0]);

	lea	eax, DWORD PTR $T238295[esp+28]
	push	eax
	lea	edx, DWORD PTR [edi+1848]
	push	esi
	mov	DWORD PTR $T238295[esp+36], edx
	mov	DWORD PTR $T238295[esp+40], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7781 : 	kStream << ArrayWrapperConst<bool>(MAX_PLAYERS, &m_abHasFoundPlayersTerritory[0]);

	lea	edx, DWORD PTR $T238296[esp+36]
	push	edx
	lea	ecx, DWORD PTR [edi+1768]
	push	esi
	mov	DWORD PTR $T238296[esp+44], ecx
	mov	DWORD PTR $T238296[esp+48], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7782 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abAtWar[0]);

	lea	ecx, DWORD PTR $T238297[esp+44]
	push	ecx
	lea	eax, DWORD PTR [edi+1928]
	push	esi
	mov	DWORD PTR $T238297[esp+52], eax
	mov	DWORD PTR $T238297[esp+56], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7783 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abPermanentWarPeace[0]);

	lea	eax, DWORD PTR $T238298[esp+52]
	push	eax
	lea	edx, DWORD PTR [edi+2008]
	push	esi
	mov	DWORD PTR $T238298[esp+60], edx
	mov	DWORD PTR $T238298[esp+64], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7784 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abEmbassy[0]);

	lea	edx, DWORD PTR $T238299[esp+60]
	push	edx
	lea	ecx, DWORD PTR [edi+2088]
	push	esi
	mov	DWORD PTR $T238299[esp+68], ecx
	mov	DWORD PTR $T238299[esp+72], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7785 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abOpenBorders[0]);

	lea	ecx, DWORD PTR $T238300[esp+68]
	push	ecx
	lea	eax, DWORD PTR [edi+2168]
	push	esi
	mov	DWORD PTR $T238300[esp+76], eax
	mov	DWORD PTR $T238300[esp+80], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7786 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abDefensivePact[0]);

	lea	eax, DWORD PTR $T238301[esp+76]
	push	eax
	lea	edx, DWORD PTR [edi+2248]
	push	esi
	mov	DWORD PTR $T238301[esp+84], edx
	mov	DWORD PTR $T238301[esp+88], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7787 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abResearchAgreement[0]);

	lea	edx, DWORD PTR $T238302[esp+84]
	push	edx
	lea	ecx, DWORD PTR [edi+2328]
	push	esi
	mov	DWORD PTR $T238302[esp+92], ecx
	mov	DWORD PTR $T238302[esp+96], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 64					; 00000040H

; 7788 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abTradeAgreement[0]);

	lea	ecx, DWORD PTR $T238303[esp+28]
	push	ecx
	lea	eax, DWORD PTR [edi+2408]
	push	esi
	mov	DWORD PTR $T238303[esp+36], eax
	mov	DWORD PTR $T238303[esp+40], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>

; 7789 : 	kStream << ArrayWrapperConst<bool>(MAX_TEAMS, &m_abForcePeace[0]);

	lea	eax, DWORD PTR $T238304[esp+36]
	push	eax
	lea	edx, DWORD PTR [edi+2488]
	push	esi
	mov	DWORD PTR $T238304[esp+44], edx
	mov	DWORD PTR $T238304[esp+48], ebp
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapperConst@_N@@@Z ; operator<<<bool>
	add	esp, 16					; 00000010H

; 7790 : 
; 7791 : 	CvInfosSerializationHelper::WriteHashedDataArray<VictoryTypes, bool>(kStream, m_abCanLaunch, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	ecx, DWORD PTR [edi+2896]
	push	eax
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
	add	esp, 12					; 0000000cH

; 7792 : 	CvInfosSerializationHelper::WriteHashedDataArray<VictoryTypes, bool>(kStream, m_abVictoryAchieved, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	edx, DWORD PTR [edi+2900]
	push	eax
	push	edx
	push	esi
	call	??$WriteHashedDataArray@W4VictoryTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,bool>
	add	esp, 12					; 0000000cH

; 7793 : 	CvInfosSerializationHelper::WriteHashedDataArray<SmallAwardTypes, bool>(kStream, m_abSmallAwardAchieved, GC.getNumSmallAwardInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	push	eax
	mov	eax, DWORD PTR [edi+2904]
	push	eax
	push	esi
	call	??$WriteHashedDataArray@W4SmallAwardTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum SmallAwardTypes,bool>
	add	esp, 12					; 0000000cH

; 7794 : 	CvInfosSerializationHelper::WriteHashedDataArray<RouteTypes, int>(kStream, m_paiRouteChange, GC.getNumRouteInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	mov	ecx, DWORD PTR [edi+2908]
	push	eax
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4RouteTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum RouteTypes,int>
	add	esp, 12					; 0000000cH

; 7795 : 	CvInfosSerializationHelper::WriteHashedDataArray<BuildTypes, int>(kStream, m_paiBuildTimeChange, GC.getNumBuildInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	edx, DWORD PTR [edi+2912]
	push	eax
	push	edx
	push	esi
	call	??$WriteHashedDataArray@W4BuildTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum BuildTypes,int>
	add	esp, 12					; 0000000cH

; 7796 : 	CvInfosSerializationHelper::WriteHashedDataArray<ProjectTypes, int>(kStream, m_paiProjectCount, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	eax, DWORD PTR [edi+2916]
	push	eax
	push	esi
	call	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
	add	esp, 12					; 0000000cH

; 7797 : 	CvInfosSerializationHelper::WriteHashedDataArray<ProjectTypes, int>(kStream, m_paiProjectDefaultArtTypes, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	ecx, DWORD PTR [edi+2920]
	push	eax
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
	add	esp, 12					; 0000000cH

; 7798 : 
; 7799 : 	//project art types
; 7800 : 	kStream << GC.getNumProjectInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	lea	edx, DWORD PTR $T238305[esp+24]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T238305[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 7801 : 
; 7802 : #ifdef AUI_WARNING_FIXES
; 7803 : 	for (uint i = 0; i<GC.getNumProjectInfos(); i++)
; 7804 : #else
; 7805 : 	for(int i=0; i<GC.getNumProjectInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	test	eax, eax
	jle	SHORT $LN4@Write
	npad	2
$LL256@Write:

; 7806 : #endif
; 7807 : 	{
; 7808 : 		CvInfosSerializationHelper::WriteHashed(kStream, GC.getProjectInfo((ProjectTypes)i));

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	push	eax
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed

; 7809 : 		for(int j=0; j<m_paiProjectCount[i]; j++)

	mov	eax, DWORD PTR [edi+2916]
	xor	ebx, ebx
	add	esp, 8
	cmp	DWORD PTR [eax+ebp*4], ebx
	jle	SHORT $LN5@Write
	mov	eax, ebp
	shl	eax, 4
	mov	DWORD PTR tv761[esp+24], eax
	jmp	SHORT $LN3@Write
	npad	3
$LL257@Write:

; 7801 : 
; 7802 : #ifdef AUI_WARNING_FIXES
; 7803 : 	for (uint i = 0; i<GC.getNumProjectInfos(); i++)
; 7804 : #else
; 7805 : 	for(int i=0; i<GC.getNumProjectInfos(); i++)

	mov	eax, DWORD PTR tv761[esp+24]
$LN3@Write:

; 7809 : 		for(int j=0; j<m_paiProjectCount[i]; j++)

	mov	ecx, DWORD PTR [edi+2960]
	mov	edx, DWORD PTR [eax+ecx+4]
	lea	eax, DWORD PTR [edx+ebx*4]

; 7810 : 		{
; 7811 : 			kStream << m_pavProjectArtTypes[i][j];

	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	ecx, DWORD PTR [edi+2916]
	inc	ebx
	cmp	ebx, DWORD PTR [ecx+ebp*4]
	jl	SHORT $LL257@Write
$LN5@Write:

; 7801 : 
; 7802 : #ifdef AUI_WARNING_FIXES
; 7803 : 	for (uint i = 0; i<GC.getNumProjectInfos(); i++)
; 7804 : #else
; 7805 : 	for(int i=0; i<GC.getNumProjectInfos(); i++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	ebp, eax
	jl	SHORT $LL256@Write
$LN4@Write:

; 7812 : 		}
; 7813 : 	}
; 7814 : 
; 7815 : 	CvInfosSerializationHelper::WriteHashedDataArray<ProjectTypes, int>(kStream, m_paiProjectMaking, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	edx, DWORD PTR [edi+2924]
	push	eax
	push	edx
	push	esi
	call	??$WriteHashedDataArray@W4ProjectTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ProjectTypes,int>
	add	esp, 12					; 0000000cH

; 7816 : 
; 7817 : 	UnitClassArrayHelpers::Write(kStream, m_paiUnitClassCount, GC.getNumUnitClassInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	push	eax
	mov	eax, DWORD PTR [edi+2928]
	push	eax
	push	esi
	call	?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; UnitClassArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 7818 : 	BuildingClassArrayHelpers::Write(kStream, m_paiBuildingClassCount, GC.getNumBuildingClassInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	mov	ecx, DWORD PTR [edi+2932]
	push	eax
	push	ecx
	push	esi
	call	?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingClassArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 7819 : 	BuildingArrayHelpers::Write(kStream, m_paiObsoleteBuildingCount, GC.getNumBuildingInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	mov	edx, DWORD PTR [edi+2936]
	push	eax
	push	edx
	push	esi
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 7820 : 
; 7821 : 	CvInfosSerializationHelper::WriteHashedDataArray<TerrainTypes, int>(kStream, m_paiTerrainTradeCount, GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	push	eax
	mov	eax, DWORD PTR [edi+2940]
	push	eax
	push	esi
	call	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
	add	esp, 12					; 0000000cH

; 7822 : 	CvInfosSerializationHelper::WriteHashedDataArray<VictoryTypes, int>(kStream, m_aiVictoryCountdown, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	ecx, DWORD PTR [edi+2944]
	push	eax
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4VictoryTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum VictoryTypes,int>
	add	esp, 12					; 0000000cH

; 7823 : 	kStream << ArrayWrapperConst<int>(MAX_CIV_TEAMS, &m_aiTurnTeamMet[0]);

	lea	ebx, DWORD PTR [edi+2568]
	mov	ebp, 63					; 0000003fH
$LL229@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL229@Write

; 7824 : 
; 7825 : 	m_pTeamTechs->Write(kStream);

	mov	ecx, DWORD PTR [edi+2980]
	push	esi
	call	?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z ; CvTeamTechs::Write

; 7826 : 
; 7827 : 	int iNumImprovements = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos

; 7828 : 	ImprovementArrayHelpers::WriteYieldArray(kStream, m_ppaaiImprovementYieldChange, iNumImprovements);

	mov	edx, DWORD PTR [edi+2948]
	mov	ebx, eax
	push	ebx
	push	edx
	push	esi
	call	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray

; 7829 : 	ImprovementArrayHelpers::WriteYieldArray(kStream, m_ppaaiImprovementNoFreshWaterYieldChange, iNumImprovements);

	mov	eax, DWORD PTR [edi+2952]
	push	ebx
	push	eax
	push	esi
	call	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray

; 7830 : 	ImprovementArrayHelpers::WriteYieldArray(kStream, m_ppaaiImprovementFreshWaterYieldChange, iNumImprovements);

	mov	ecx, DWORD PTR [edi+2956]
	push	ebx
	push	ecx
	push	esi
	call	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray

; 7831 : 
; 7832 : 	CvInfosSerializationHelper::WriteHashedTypeArray(kStream, m_aeRevealedResources);

	add	edi, 2964				; 00000b94H
	push	edi
	push	esi
	call	??$WriteHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum ResourceTypes>
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7833 : }

	add	esp, 12					; 0000000cH
	ret	4
?Write@CvTeam@@UBEXAAVFDataStream@@@Z ENDP		; CvTeam::Write
_TEXT	ENDS
PUBLIC	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification
; Function compile flags: /Ogtpy
;	COMDAT ?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z
_TEXT	SEGMENT
tv202 = -8						; size = 4
_this$ = -4						; size = 4
_eNotificationType$ = 8					; size = 4
_strMessage$ = 12					; size = 4
_strSummary$ = 16					; size = 4
_iX$ = 20						; size = 4
_iY$ = 24						; size = 4
_iGameDataIndex$ = 28					; size = 4
_iExtraGameData$ = 32					; size = 4
?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z PROC ; CvTeam::AddNotification, COMDAT
; _this$ = ecx

; 7841 : {

	sub	esp, 8
	push	ebx

; 7842 : 	PlayerTypes eLoopPlayer;
; 7843 : 
; 7844 : 	for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	mov	ebx, DWORD PTR _iGameDataIndex$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _iY$[esp+12]
	push	esi
	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _iExtraGameData$[esp+20]
	mov	DWORD PTR _this$[esp+24], ecx
	mov	DWORD PTR tv202[esp+24], esi
	npad	3
$LL29@AddNotific:

; 7845 : 	{
; 7846 : 		eLoopPlayer = (PlayerTypes) iI;
; 7847 : 		CvPlayer& loopPlayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, eax

; 7848 : 
; 7849 : 		if(!loopPlayer.isAlive())

	cmp	BYTE PTR [esi+2256], 0
	je	SHORT $LN5@AddNotific

; 7850 : 			continue;
; 7851 : 
; 7852 : 		if(loopPlayer.getTeam() != GetID())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN19@AddNotific
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN20@AddNotific
$LN19@AddNotific:
	or	eax, -1
$LN20@AddNotific:
	mov	ecx, DWORD PTR _this$[esp+24]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN5@AddNotific

; 7853 : 			continue;
; 7854 : 
; 7855 : 		if(!loopPlayer.GetNotifications())

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	SHORT $LN5@AddNotific

; 7856 : 			continue;
; 7857 : 
; 7858 : 		loopPlayer.GetNotifications()->Add(eNotificationType, strMessage, strSummary, iX, iY, iGameDataIndex, iExtraGameData);

	mov	edx, DWORD PTR _iX$[esp+20]
	mov	eax, DWORD PTR _strSummary$[esp+20]
	mov	ecx, DWORD PTR _strMessage$[esp+20]
	push	edi
	push	ebx
	push	ebp
	push	edx
	mov	edx, DWORD PTR _eNotificationType$[esp+36]
	push	eax
	push	ecx
	push	edx
	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN5@AddNotific:
	mov	esi, DWORD PTR tv202[esp+24]
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv202[esp+24], esi
	jl	SHORT $LL29@AddNotific
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7859 : 	}
; 7860 : }

	add	esp, 8
	ret	28					; 0000001cH
?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ENDP ; CvTeam::AddNotification
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::end
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
_TEXT	ENDS
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_iNumChoices$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebx
	push	esi
	mov	ebx, ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR [ebx+4]
	push	edi
	mov	edi, DWORD PTR _iNumChoices$[esp+8]
	cmp	edi, eax
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	edi, eax
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	xor	esi, esi

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	xor	ecx, ecx

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	test	edi, edi
	jle	SHORT $LN5@ChooseFrom
	mov	eax, DWORD PTR [ebx]
	mov	edx, edi
	npad	2
$LL7@ChooseFrom:

; 237  : 		{
; 238  : 			elem = m_pItems[i];
; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	add	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax]
	add	eax, 8
	sub	edx, 1
	jne	SHORT $LL7@ChooseFrom
$LN5@ChooseFrom:

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	eax, DWORD PTR _szRollName$[esp+8]
	push	eax
	mov	eax, DWORD PTR _rndFcn$[esp+12]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	edx

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN2@ChooseFrom

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	ecx, DWORD PTR [ebx]
$LL4@ChooseFrom:

; 247  : 		{
; 248  : 			elem = m_pItems[i];
; 249  : 			iChoice -= elem.m_iWeight;

	sub	eax, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]

; 250  : 			if (iChoice < 0)

	js	SHORT $LN2@ChooseFrom
	inc	edx
	add	ecx, 8
	cmp	edx, edi
	jl	SHORT $LL4@ChooseFrom
$LN2@ChooseFrom:
	pop	edi

; 251  : 			{
; 252  : 				return elem.m_Element;
; 253  : 			}
; 254  : 		}
; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, esi
	pop	esi
	pop	ebx

; 260  : 	};

	ret	12					; 0000000cH
?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 63					; 0000003fH
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 63			; 0000003fH
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+264], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::~FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN34@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 63					; 0000003fH
	jbe	SHORT $LN16@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@2
$LN16@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 63			; 0000003fH
$LN15@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+516], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum ResourceTypes,std::allocator<enum ResourceTypes> >::operator+
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc, COMDAT
; _this$ = ecx

; 97   : 	{

	push	ebx
	push	esi
	push	edi

; 98   : 		unsigned int nArrayBytes = sizeof(TYPE*) * (pData->nX + 1);

	mov	edi, DWORD PTR _pData$[esp+8]
	mov	eax, DWORD PTR [edi+4]

; 99   : 		unsigned int nDataBytes = sizeof(TYPE) * pData->nX * ( pData->nY + 1 );

	mov	esi, DWORD PTR [edi+8]
	inc	esi
	imul	esi, eax
	lea	ebx, DWORD PTR [eax*4+4]
	add	esi, esi
	add	esi, esi

; 100  : 		void* pRet = BASE::Alloc( nBytes + nDataBytes + nArrayBytes, pData+1 );

	lea	eax, DWORD PTR [edi+12]

; 101  : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet );
; 102  : 
; 103  : 		unsigned int iDataAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart -= nDataBytes) % sizeof(TYPE);

	lea	edx, DWORD PTR [esi+ebx]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocBase<0,0,0> >::Alloc
	sub	eax, esi
	mov	edx, eax
	and	edx, 3

; 104  : 		TYPE* pFirstElement = (TYPE*)( pLocMemStart + iDataAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx

; 105  : 
; 106  : 		unsigned int iArrayAlignmentFix = sizeof(TYPE*) - reinterpret_cast< unsigned int >(pLocMemStart -= nArrayBytes) % sizeof(TYPE*);

	sub	eax, ebx
	mov	edx, eax
	and	edx, 3

; 107  : 		TYPE** ppArray = (*static_cast< TYPE*** >(pData->pOut)) = (TYPE**)( pLocMemStart + iArrayAlignmentFix );

	mov	esi, eax
	sub	esi, edx
	mov	edx, DWORD PTR [edi]
	add	esi, 4
	mov	DWORD PTR [edx], esi
	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edx]

; 108  : 
; 109  : 		for( unsigned int i = 0; i < pData->nX; ++i )

	xor	edx, edx
	add	ecx, 4
	cmp	DWORD PTR [edi+4], edx
	jbe	SHORT $LN1@Alloc@4
	npad	8
$LL3@Alloc@4:

; 110  : 		{
; 111  : 			*ppArray = pFirstElement + i * pData->nY;

	mov	ebx, DWORD PTR [edi+8]
	imul	ebx, edx
	lea	ebx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [esi], ebx
	inc	edx

; 112  : 			++ppArray;

	add	esi, 4
	cmp	edx, DWORD PTR [edi+4]
	jb	SHORT $LL3@Alloc@4
$LN1@Alloc@4:
	pop	edi
	pop	esi
	pop	ebx

; 113  : 		}
; 114  : 
; 115  : 		return static_cast< void* >( pLocMemStart );
; 116  : 	}

	ret	8
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum ResourceTypes *,enum ResourceTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum ResourceTypes *,enum ResourceTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum ResourceTypes *,enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>, COMDAT
; _this$ = ecx

; 1057 : 		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	ret	8
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum ResourceTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Med3<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z
_TEXT	SEGMENT
$T239234 = -4						; size = 1
__Cat$239238 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239234[esp+4], 0
	mov	eax, DWORD PTR $T239234[esp+4]
	mov	ecx, DWORD PTR __Cat$239238[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAE@XZ ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::~FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >
_TEXT	ENDS
PUBLIC	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::canDeclareWar
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z$0
__ehfuncinfo$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_args$223909 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bResult$223910 = 8					; size = 1
_eTeam$ = 8						; size = 4
?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z PROC	; CvTeam::canDeclareWar, COMDAT
; _this$ = ecx

; 1074 : {

	push	-1
	push	__ehhandler$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 1075 : 	if(eTeam == GetID())

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+20]
	cmp	edi, eax
	jne	SHORT $LN14@canDeclare
$LN62@canDeclare:
	pop	edi

; 1076 : 	{
; 1077 : 		return false;

	xor	al, al
	pop	esi

; 1147 : 
; 1148 : 	return true;
; 1149 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN14@canDeclare:

; 1078 : 	}
; 1079 : #ifdef AI_CANT_DECLARE_WAR
; 1080 : 	if(GC.getGame().isOption("GAMEOPTION_AI_TWEAKS"))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG223897
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN12@canDeclare

; 1081 : 	{
; 1082 : 		if(!isHuman())

	mov	ecx, esi
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al

; 1083 : 		{
; 1084 : 			return false;

	je	SHORT $LN62@canDeclare
$LN12@canDeclare:

; 1085 : 		}
; 1086 : 	}
; 1087 : #endif
; 1088 : 
; 1089 : 	if(!(isAlive()) || !(GET_TEAM(eTeam).isAlive()))

	cmp	DWORD PTR [esi+12], 0
	push	ebp
	jle	$LN10@canDeclare
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ebp, edi
	imul	ebp, 2984				; 00000ba8H
	cmp	DWORD PTR [eax+ebp+12], 0
	jle	$LN10@canDeclare

; 1090 : 	{
; 1091 : 		return false;
; 1092 : 	}
; 1093 : 
; 1094 : 	if(isAtWar(eTeam))

	cmp	BYTE PTR [edi+esi+1928], 0

; 1095 : 	{
; 1096 : 		return false;

	jne	$LN10@canDeclare

; 1097 : 	}
; 1098 : 
; 1099 : 	if(!isHasMet(eTeam))

	cmp	BYTE PTR [edi+esi+1848], 0

; 1100 : 	{
; 1101 : 		return false;

	je	$LN10@canDeclare

; 1102 : 	}
; 1103 : 
; 1104 : 	if(isForcePeace(eTeam))

	cmp	BYTE PTR [edi+esi+2488], 0

; 1105 : 	{
; 1106 : 		return false;

	jne	$LN10@canDeclare

; 1107 : 	}
; 1108 : 
; 1109 : 	if(!canChangeWarPeace(eTeam))

	push	edi
	mov	ecx, esi
	call	?canChangeWarPeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::canChangeWarPeace
	test	al, al

; 1110 : 	{
; 1111 : 		return false;

	je	$LN10@canDeclare

; 1112 : 	}
; 1113 : 
; 1114 : 	if(GC.getGame().isOption(GAMEOPTION_ALWAYS_PEACE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	4
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al

; 1115 : 	{
; 1116 : 		return false;

	jne	$LN10@canDeclare

; 1117 : 	}
; 1118 : 
; 1119 : #ifdef NEW_DEFENSIVE_PACT
; 1120 : 	if(GET_TEAM(eTeam).IsHasDefensivePact(GetID()))

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, DWORD PTR [esi+4]
	add	ebp, ecx
	cmp	BYTE PTR [eax+ebp+2248], 0

; 1121 : 	{
; 1122 : 		return false;

	jne	SHORT $LN10@canDeclare

; 1123 : 	}
; 1124 : #endif
; 1125 : 
; 1126 : 	// First, obtain the Lua script system.
; 1127 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ebp, eax

; 1128 : 	if(pkScriptSystem)

	test	ebp, ebp
	je	$LN3@canDeclare

; 1129 : 	{
; 1130 : 		// Construct and push in some event arguments.
; 1131 : 		CvLuaArgsHandle args(2);

	push	2
	lea	ecx, DWORD PTR _args$223909[esp+32]
	call	??0CvLuaArgsHandle@@QAE@I@Z		; CvLuaArgsHandle::CvLuaArgsHandle

; 1132 : 		args->Push(GetID());

	mov	ecx, DWORD PTR _args$223909[esp+28]
	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	esi
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	eax

; 1133 : 		args->Push(eTeam);

	mov	ecx, DWORD PTR _args$223909[esp+28]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	edi
	call	eax

; 1134 : 
; 1135 : 		// Attempt to execute the game events.
; 1136 : 		// Will return false if there are no registered listeners.
; 1137 : 		bool bResult = false;
; 1138 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "CanDeclareWar", args.get(), bResult))

	mov	edx, DWORD PTR _args$223909[esp+28]
	lea	ecx, DWORD PTR _bResult$223910[esp+24]
	push	ecx
	push	edx
	push	OFFSET $SG223912
	push	ebp
	mov	BYTE PTR _bResult$223910[esp+40], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN1@canDeclare

; 1139 : 		{
; 1140 : 			// Check the result.
; 1141 : 			if(bResult == false)

	cmp	BYTE PTR _bResult$223910[esp+24], 0
	jne	SHORT $LN1@canDeclare

; 1142 : 			{
; 1143 : 				return false;

	lea	ecx, DWORD PTR _args$223909[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN10@canDeclare:
	pop	ebp
	pop	edi
	xor	al, al
	pop	esi

; 1147 : 
; 1148 : 	return true;
; 1149 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN1@canDeclare:

; 1144 : 			}
; 1145 : 		}
; 1146 : 	}

	lea	ecx, DWORD PTR _args$223909[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@canDeclare:

; 1147 : 
; 1148 : 	return true;
; 1149 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	ebp
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$223909[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z ENDP	; CvTeam::canDeclareWar
PUBLIC	?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ	; CvTeam::GetProjectedVotesFromCivs
EXTRN	?GetPreviousVoteCast@CvGame@@QBE?AW4TeamTypes@@W42@@Z:PROC ; CvGame::GetPreviousVoteCast
; Function compile flags: /Ogtpy
;	COMDAT ?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ
_TEXT	SEGMENT
_iVotes$ = -4						; size = 4
?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ PROC		; CvTeam::GetProjectedVotesFromCivs, COMDAT
; _this$ = ecx

; 2145 : {

	push	ecx
	push	ebp

; 2146 : 	int iVotes = 0;

	xor	eax, eax
	mov	ebp, ecx

; 2147 : 
; 2148 : 	if (isAlive())

	cmp	DWORD PTR [ebp+12], eax
	mov	DWORD PTR _iVotes$[esp+8], eax
	jle	SHORT $LN3@GetProject
	push	ebx
	push	esi
	push	edi

; 2149 : 	{
; 2150 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	ebx, ebx
	xor	edi, edi
	npad	10
$LL26@GetProject:

; 2151 : 		{
; 2152 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;
; 2153 : 			CvTeam* pTeamLoop = &GET_TEAM(eTeamLoop);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 2154 : 			if (pTeamLoop->isAlive() && !pTeamLoop->isMinorCiv() && !pTeamLoop->isBarbarian())

	cmp	DWORD PTR [edi+eax+12], 0
	lea	esi, DWORD PTR [edi+eax]
	jle	SHORT $LN4@GetProject
	mov	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN4@GetProject
	cmp	DWORD PTR [esi+4], 63			; 0000003fH
	je	SHORT $LN4@GetProject

; 2155 : 			{
; 2156 : 				// Did they vote for us last time?
; 2157 : 				if (GC.getGame().GetPreviousVoteCast(eTeamLoop) == GetID())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ebp+4]
	push	ebx
	call	?GetPreviousVoteCast@CvGame@@QBE?AW4TeamTypes@@W42@@Z ; CvGame::GetPreviousVoteCast
	cmp	eax, esi
	jne	SHORT $LN4@GetProject

; 2158 : 					iVotes++;

	inc	DWORD PTR _iVotes$[esp+20]
$LN4@GetProject:

; 2149 : 	{
; 2150 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	edi, 2984				; 00000ba8H
	inc	ebx
	cmp	edi, 187992				; 0002de58H
	jl	SHORT $LL26@GetProject

; 2159 : 			}
; 2160 : 		}
; 2161 : 	}
; 2162 : 
; 2163 : 	return iVotes;

	mov	eax, DWORD PTR _iVotes$[esp+20]
	pop	edi
	pop	esi
	pop	ebx
$LN3@GetProject:
	pop	ebp

; 2164 : }

	pop	ecx
	ret	0
?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ ENDP		; CvTeam::GetProjectedVotesFromCivs
_TEXT	ENDS
PUBLIC	?getAtWarCount@CvTeam@@QBEH_N@Z			; CvTeam::getAtWarCount
; Function compile flags: /Ogtpy
;	COMDAT ?getAtWarCount@CvTeam@@QBEH_N@Z
_TEXT	SEGMENT
_bIgnoreMinors$ = 8					; size = 1
?getAtWarCount@CvTeam@@QBEH_N@Z PROC			; CvTeam::getAtWarCount, COMDAT
; _this$ = ecx

; 2204 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 2205 : 	int iCount;
; 2206 : 	int iI;
; 2207 : 
; 2208 : 	iCount = 0;

	xor	ebx, ebx

; 2209 : 
; 2210 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	xor	edi, edi
	mov	ebp, ecx
	xor	esi, esi
	npad	4
$LL24@getAtWarCo:

; 2211 : 	{
; 2212 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN6@getAtWarCo

; 2213 : 		{
; 2214 : 			if(!bIgnoreMinors || !(GET_TEAM((TeamTypes)iI).isMinorCiv()))

	cmp	BYTE PTR _bIgnoreMinors$[esp+12], 0
	je	SHORT $LN2@getAtWarCo
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN6@getAtWarCo
$LN2@getAtWarCo:

; 2215 : 			{
; 2216 : 				if(isAtWar((TeamTypes)iI))

	cmp	BYTE PTR [edi+ebp+1928], 0
	je	SHORT $LN6@getAtWarCo

; 2217 : 				{
; 2218 : 					CvAssert(iI != GetID());
; 2219 : 					iCount++;

	inc	ebx
$LN6@getAtWarCo:

; 2209 : 
; 2210 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL24@getAtWarCo
	pop	edi
	pop	esi
	pop	ebp

; 2220 : 				}
; 2221 : 			}
; 2222 : 		}
; 2223 : 	}
; 2224 : 
; 2225 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 2226 : }

	ret	4
?getAtWarCount@CvTeam@@QBEH_N@Z ENDP			; CvTeam::getAtWarCount
_TEXT	ENDS
PUBLIC	?getHasMetCivCount@CvTeam@@QBEH_N@Z		; CvTeam::getHasMetCivCount
; Function compile flags: /Ogtpy
;	COMDAT ?getHasMetCivCount@CvTeam@@QBEH_N@Z
_TEXT	SEGMENT
_bIgnoreMinors$ = 8					; size = 1
?getHasMetCivCount@CvTeam@@QBEH_N@Z PROC		; CvTeam::getHasMetCivCount, COMDAT
; _this$ = ecx

; 2231 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 2232 : 	int iCount;
; 2233 : 	int iI;
; 2234 : 
; 2235 : 	iCount = 0;

	xor	ebx, ebx

; 2236 : 
; 2237 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	xor	edi, edi
	mov	ebp, ecx
	xor	esi, esi
	npad	4
$LL27@getHasMetC:

; 2238 : 	{
; 2239 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN7@getHasMetC

; 2240 : 		{
; 2241 : 			if(iI != GetID())

	cmp	edi, DWORD PTR [ebp+4]
	je	SHORT $LN7@getHasMetC

; 2242 : 			{
; 2243 : 				if(!bIgnoreMinors || !(GET_TEAM((TeamTypes)iI).isMinorCiv()))

	cmp	BYTE PTR _bIgnoreMinors$[esp+12], 0
	je	SHORT $LN2@getHasMetC
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN7@getHasMetC
$LN2@getHasMetC:

; 2244 : 				{
; 2245 : 					if(isHasMet((TeamTypes)iI))

	cmp	BYTE PTR [edi+ebp+1848], 0
	je	SHORT $LN7@getHasMetC

; 2246 : 					{
; 2247 : 						CvAssert(iI != GetID());
; 2248 : 						iCount++;

	inc	ebx
$LN7@getHasMetC:

; 2236 : 
; 2237 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL27@getHasMetC
	pop	edi
	pop	esi
	pop	ebp

; 2249 : 					}
; 2250 : 				}
; 2251 : 			}
; 2252 : 		}
; 2253 : 	}
; 2254 : 
; 2255 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 2256 : }

	ret	4
?getHasMetCivCount@CvTeam@@QBEH_N@Z ENDP		; CvTeam::getHasMetCivCount
_TEXT	ENDS
PUBLIC	?hasMetHuman@CvTeam@@QBE_NXZ			; CvTeam::hasMetHuman
; Function compile flags: /Ogtpy
;	COMDAT ?hasMetHuman@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?hasMetHuman@CvTeam@@QBE_NXZ PROC			; CvTeam::hasMetHuman, COMDAT
; _this$ = ecx

; 2261 : {

	push	ebx
	push	esi
	push	edi

; 2262 : 	int iI;
; 2263 : 
; 2264 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	xor	edi, edi
	mov	ebx, ecx
	xor	esi, esi
	npad	7
$LL7@hasMetHuma:

; 2265 : 	{
; 2266 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN6@hasMetHuma

; 2267 : 		{
; 2268 : 			if(iI != GetID())

	cmp	edi, DWORD PTR [ebx+4]
	je	SHORT $LN6@hasMetHuma

; 2269 : 			{
; 2270 : 				if(GET_TEAM((TeamTypes)iI).isHuman())

	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	je	SHORT $LN6@hasMetHuma

; 2271 : 				{
; 2272 : 					if(isHasMet((TeamTypes)iI))

	cmp	BYTE PTR [edi+ebx+1848], 0
	jne	SHORT $LN23@hasMetHuma
$LN6@hasMetHuma:

; 2262 : 	int iI;
; 2263 : 
; 2264 : 	for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL7@hasMetHuma
	pop	edi
	pop	esi

; 2276 : 					}
; 2277 : 				}
; 2278 : 			}
; 2279 : 		}
; 2280 : 	}
; 2281 : 
; 2282 : 	return false;

	xor	al, al
	pop	ebx

; 2283 : }

	ret	0
$LN23@hasMetHuma:
	pop	edi
	pop	esi

; 2273 : 					{
; 2274 : 						CvAssert(iI != GetID());
; 2275 : 						return true;

	mov	al, 1
	pop	ebx

; 2283 : }

	ret	0
?hasMetHuman@CvTeam@@QBE_NXZ ENDP			; CvTeam::hasMetHuman
_TEXT	ENDS
PUBLIC	?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z ; CvTeam::countEnemyDangerByArea
EXTRN	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z:PROC ; CvPlot::plotCount
EXTRN	?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z:PROC	; PUF_canDefendEnemy
EXTRN	?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z:PROC	; PUF_isVisible
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
; Function compile flags: /Ogtpy
;	COMDAT ?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z
_TEXT	SEGMENT
tv217 = -4						; size = 4
_pArea$ = 8						; size = 4
?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z PROC	; CvTeam::countEnemyDangerByArea, COMDAT
; _this$ = ecx

; 2449 : {

	push	ecx

; 2450 : 	CvPlot* pLoopPlot;
; 2451 : 	int iCount;
; 2452 : #ifdef AUI_WARNING_FIXES
; 2453 : 	uint iI;
; 2454 : #else
; 2455 : 	int iI;
; 2456 : #endif
; 2457 : 
; 2458 : 	iCount = 0;
; 2459 : 
; 2460 : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	xor	ebp, ebp
	xor	ebx, ebx
	cmp	DWORD PTR [eax+4028], ebp
	push	edi
	mov	edi, ecx
	jle	$LN34@countEnemy
	mov	DWORD PTR tv217[esp+16], ebp
	push	esi
$LL6@countEnemy:

; 2461 : 	{
; 2462 : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [eax+4068]
	add	esi, DWORD PTR tv217[esp+20]

; 2463 : 
; 2464 : 		if(pLoopPlot != NULL)

	je	SHORT $LN5@countEnemy

; 2465 : 		{
; 2466 : 			if(pLoopPlot->area() == pArea)

	mov	ecx, esi
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, DWORD PTR _pArea$[esp+16]
	jne	SHORT $LN5@countEnemy

; 2467 : 			{
; 2468 : 				if(pLoopPlot->getTeam() == GetID())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN18@countEnemy
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@countEnemy
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN17@countEnemy
$LN18@countEnemy:
	or	eax, -1
$LN17@countEnemy:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN5@countEnemy

; 2469 : 				{
; 2470 : #ifdef AUI_WARNING_FIXES
; 2471 : 					iCount += pLoopPlot->plotCount(PUF_canDefendEnemy, getLeaderID(), -1, NO_PLAYER, NO_TEAM, PUF_isVisible, getLeaderID());
; 2472 : #else
; 2473 : 					iCount += pLoopPlot->plotCount(PUF_canDefendEnemy, getLeaderID(), false, NO_PLAYER, NO_TEAM, PUF_isVisible, getLeaderID());

	push	-1
	mov	ecx, edi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	OFFSET ?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z ; PUF_isVisible
	push	-1
	push	-1
	push	0
	mov	ecx, edi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	OFFSET ?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z ; PUF_canDefendEnemy
	mov	ecx, esi
	call	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
	add	ebx, eax
$LN5@countEnemy:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv217[esp+20], 484		; 000001e4H
	inc	ebp
	cmp	ebp, DWORD PTR [eax+4028]
	jl	SHORT $LL6@countEnemy
	pop	esi
$LN34@countEnemy:
	pop	edi
	pop	ebp

; 2474 : #endif
; 2475 : 				}
; 2476 : 			}
; 2477 : 		}
; 2478 : 	}
; 2479 : 
; 2480 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 2481 : }

	pop	ecx
	ret	4
?countEnemyDangerByArea@CvTeam@@QBEHPAVCvArea@@@Z ENDP	; CvTeam::countEnemyDangerByArea
_TEXT	ENDS
PUBLIC	?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::CloseEmbassyAtTeam
; Function compile flags: /Ogtpy
;	COMDAT ?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC	; CvTeam::CloseEmbassyAtTeam, COMDAT
; _this$ = ecx

; 4023 : {

	push	esi
	push	edi

; 4024 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4025 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 4026 : 
; 4027 : 	SetHasEmbassyAtTeam(eIndex, false);

	mov	edi, DWORD PTR _eIndex$[esp+4]
	push	0
	push	edi
	mov	esi, ecx
	call	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam

; 4028 : 	SetAllowsOpenBordersToTeam(m_eID, false);

	mov	eax, DWORD PTR [esi+4]
	push	0
	push	eax
	mov	ecx, esi
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 4029 : 	SetHasDefensivePact(m_eID, false);

	mov	ecx, DWORD PTR [esi+4]
	push	0
	push	ecx
	mov	ecx, esi
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 4030 : 	GET_TEAM(eIndex).SetHasDefensivePact(m_eID, false);

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, edi
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	edx
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
	pop	edi
	pop	esi

; 4031 : 
; 4032 : 	//SetHasResearchAgreement(m_eID, false);
; 4033 : 	//GET_TEAM(eIndex).SetHasResearchAgreement(m_eID, false);
; 4034 : }

	ret	4
?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP	; CvTeam::CloseEmbassyAtTeam
_TEXT	ENDS
PUBLIC	?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z	; CvTeam::updateTechShare
PUBLIC	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
EXTRN	?DoUpdateHappiness@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateHappiness
EXTRN	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlayerEspionage::BuildStealableTechList
EXTRN	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ:PROC ; CvPlayerTechs::GetCurrentResearch
EXTRN	?IsResearch@CvPlayerTechs@@QBE_NXZ:PROC		; CvPlayerTechs::IsResearch
EXTRN	?SetOwedCultureBuilding@CvCity@@QAEX_N@Z:PROC	; CvCity::SetOwedCultureBuilding
EXTRN	?ChooseFreeCultureBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ:PROC ; CvCity::ChooseFreeCultureBuilding
EXTRN	?IsOwedCultureBuilding@CvCity@@QBE_NXZ:PROC	; CvCity::IsOwedCultureBuilding
EXTRN	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ:PROC	; CvCity::GetIDInfo
EXTRN	?GetResourceDemanded@CvCity@@QBE?AW4ResourceTypes@@_N@Z:PROC ; CvCity::GetResourceDemanded
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
EXTRN	?clearResearchQueue@CvPlayer@@QAEXXZ:PROC	; CvPlayer::clearResearchQueue
EXTRN	?chooseTech@CvPlayer@@QAEXHPBDW4TechTypes@@@Z:PROC ; CvPlayer::chooseTech
EXTRN	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetFirstFreeTechs
EXTRN	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z:PROC ; CvCityCitizens::DoSpawnGreatPerson
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ:PROC	; CvTechEntry::GetFirstFreeUnitClass
EXTRN	?countKnownTechNumTeams@CvGame@@QAEHW4TechTypes@@@Z:PROC ; CvGame::countKnownTechNumTeams
EXTRN	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z:PROC ; CvPlayer::invalidateYieldRankCache
EXTRN	?popResearch@CvPlayer@@QAEXW4TechTypes@@@Z:PROC	; CvPlayer::popResearch
EXTRN	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z:PROC ; CvPlayerTechs::IsResearchingTech
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z:PROC ; CvMap::setRevealedPlots
EXTRN	?IsMapVisible@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsMapVisible
EXTRN	?getNumEraInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumEraInfos
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z:PROC ; CvPlot::SetResourceLinkedCityActive
EXTRN	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ:PROC ; CvPlot::GetResourceLinkedCity
EXTRN	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlayer::changeNumResourceTotal
EXTRN	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumResourceForPlayer
EXTRN	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovedByGiftFromMajor
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getTechCityTrade@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechCityTrade
EXTRN	?loadWBScenario@CvPreGame@@YA_NXZ:PROC		; CvPreGame::loadWBScenario
EXTRN	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::IsResourceForceReveal
EXTRN	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z:PROC ; CvPlot::DoFindCityToLinkResourceTo
EXTRN	?updateStrengthValue@CvCity@@QAEXXZ:PROC	; CvCity::updateStrengthValue
EXTRN	?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z:PROC ; CvTeamTechs::SetHasTech
EXTRN	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z:PROC ; CvTeamTechs::GetTechCount
EXTRN	?ChangeScoreFromFutureTech@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeScoreFromFutureTech
EXTRN	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z:PROC ; CvTeamTechs::SetResearchProgress
EXTRN	?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z:PROC ; CvTeamTechs::IncrementTechCount
EXTRN	?IsRepeat@CvTechEntry@@QBE_NXZ:PROC		; CvTechEntry::IsRepeat
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$17
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
_TEXT	SEGMENT
_this$ = -764						; size = 4
_bTechRevealsHiddenArtifacts$226809 = -758		; size = 1
_bIsActiveTeam$226749 = -758				; size = 1
_bTechRevealsArtifacts$226808 = -757			; size = 1
$T239763 = -756						; size = 4
$T239761 = -756						; size = 4
_pResourceInfo$226951 = -756				; size = 4
$T239755 = -756						; size = 4
$T239751 = -756						; size = 4
_eArtifactResource$226810 = -756			; size = 4
tv3805 = -752						; size = 4
tv2213 = -752						; size = 4
_iI$226941 = -752					; size = 4
_iLoop$226736 = -752					; size = 4
$T239764 = -748						; size = 4
$T239760 = -748						; size = 4
$T239756 = -748						; size = 4
$T239752 = -748						; size = 4
_eActivePlayer$226821 = -748				; size = 4
_eNotificationType$226835 = -744			; size = 4
_eNotificationType$226748 = -744			; size = 4
_eHiddenArtifactResource$226815 = -740			; size = 4
_eResource$226756 = -740				; size = 4
tv2460 = -736						; size = 4
_iLoop$226996 = -736					; size = 4
_pArtifactResource$226813 = -736			; size = 4
_iLoop$226967 = -732					; size = 4
_pHiddenArtifactResource$226818 = -732			; size = 4
_pResourceInfo$226758 = -732				; size = 4
tv3795 = -728						; size = 4
tv3742 = -728						; size = 4
tv3727 = -728						; size = 4
$T239766 = -728						; size = 8
_pkTechInfo$ = -720					; size = 4
tv2663 = -716						; size = 4
$T239767 = -712						; size = 28
$T239765 = -712						; size = 28
$T239762 = -712						; size = 28
$T239759 = -712						; size = 28
$T239758 = -712						; size = 28
$T239757 = -712						; size = 28
$T239754 = -712						; size = 28
$T239753 = -712						; size = 28
$T239750 = -712						; size = 28
$T239749 = -712						; size = 28
$T239748 = -712						; size = 28
$T239747 = -712						; size = 28
$T239746 = -712						; size = 28
$T239745 = -712						; size = 28
_strBuffer$ = -684					; size = 28
_strSummary$226833 = -656				; size = 28
_strSummary$226773 = -656				; size = 28
_localizedText$227040 = -628				; size = 80
_kPopup$227047 = -548					; size = 536
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_ePlayer$ = 16						; size = 4
_bFirst$ = 20						; size = 1
_bAnnounce$ = 24					; size = 1
?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z PROC ; CvTeam::setHasTech, COMDAT
; _this$ = ecx

; 5466 : {

	push	-1
	push	__ehhandler$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 752				; 000002f0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 5467 : 	CvCity* pCapitalCity;
; 5468 : 	CvCity* pCity;
; 5469 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+776]
	mov	DWORD PTR _this$[esp+776], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5470 : 	UnitTypes eFreeUnit;
; 5471 : 	bool bFirstResource;
; 5472 : 	
; 5473 : 	if(eIndex == NO_TECH)

	mov	esi, DWORD PTR _eIndex$[esp+772]
	or	ebx, -1
	mov	DWORD PTR __$EHRec$[esp+784], 0
	cmp	esi, ebx
	jne	SHORT $LN182@setHasTech
$LN908@setHasTech:

; 5474 : 	{
; 5475 : 		return;

	mov	DWORD PTR __$EHRec$[esp+784], ebx
	jmp	$LN902@setHasTech
$LN182@setHasTech:

; 5476 : 	}
; 5477 : 
; 5478 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eIndex);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[esp+776], eax

; 5479 : 	if(pkTechInfo == NULL)

	test	eax, eax

; 5480 : 	{
; 5481 : 		return;

	je	SHORT $LN908@setHasTech

; 5482 : 	}
; 5483 : 
; 5484 : 	if(ePlayer == NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[esp+772], ebx
	jne	SHORT $LN179@setHasTech

; 5485 : 	{
; 5486 : 		ePlayer = getLeaderID();

	mov	ecx, edi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR _ePlayer$[esp+772], eax

; 5487 : 	}
; 5488 : 
; 5489 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5490 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 5491 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 5492 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 5493 : 
; 5494 : 	if(ePlayer == NO_PLAYER)

	cmp	eax, ebx

; 5495 : 	{
; 5496 : 		return;

	je	SHORT $LN908@setHasTech
$LN179@setHasTech:

; 5497 : 	}
; 5498 : 
; 5499 : 	if(GetTeamTechs()->HasTech(eIndex) != bNewValue)

	mov	ecx, DWORD PTR [edi+2980]
	push	esi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	mov	ebx, DWORD PTR _bNewValue$[esp+772]
	cmp	al, bl
	je	$LN1@setHasTech

; 5500 : 	{
; 5501 : 		CvPlayerAI& kResearchingPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ebp, DWORD PTR _ePlayer$[esp+776]
	mov	eax, ebp
	imul	eax, 63236				; 0000f704H
	lea	edi, DWORD PTR [eax+ecx]

; 5502 : 
; 5503 : 		if(	GC.getGame().getActivePlayer() == ePlayer &&
; 5504 : 			strcmp(pkTechInfo->GetType(), "TECH_SATELLITES") == 0 &&
; 5505 : 			strcmp(kResearchingPlayer.getCivilizationTypeKey(), "CIVILIZATION_HUNS") == 0 &&
; 5506 : 			strcmp(GC.getMap().getWorldInfo().GetType(), "WORLDSIZE_HUGE") == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR tv2663[esp+780], eax
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, ebp
	jne	$LN877@setHasTech
	mov	ecx, DWORD PTR _pkTechInfo$[esp+780]
	add	ecx, 176				; 000000b0H
	mov	esi, OFFSET $SG226716
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL844@setHasTech:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN845@setHasTech
	test	cl, cl
	je	SHORT $LN846@setHasTech
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN845@setHasTech
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL844@setHasTech
$LN846@setHasTech:
	xor	eax, eax
	jmp	SHORT $LN847@setHasTech
$LN845@setHasTech:
	sbb	eax, eax
	sbb	eax, -1
$LN847@setHasTech:
	test	eax, eax
	jne	$LN877@setHasTech
	mov	ecx, edi
	mov	esi, OFFSET $SG226717
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	npad	6
$LL848@setHasTech:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN849@setHasTech
	test	cl, cl
	je	SHORT $LN850@setHasTech
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN849@setHasTech
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL848@setHasTech
$LN850@setHasTech:
	xor	eax, eax
	jmp	SHORT $LN851@setHasTech
$LN849@setHasTech:
	sbb	eax, eax
	sbb	eax, -1
$LN851@setHasTech:
	test	eax, eax
	jne	SHORT $LN877@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	lea	ecx, DWORD PTR [eax+176]
	mov	esi, OFFSET $SG226718
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL852@setHasTech:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN853@setHasTech
	test	cl, cl
	je	SHORT $LN854@setHasTech
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN853@setHasTech
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL852@setHasTech
$LN854@setHasTech:
	xor	eax, eax
	jmp	SHORT $LN855@setHasTech
$LN853@setHasTech:
	sbb	eax, eax
	sbb	eax, -1
$LN855@setHasTech:
	test	eax, eax
	jne	SHORT $LN877@setHasTech

; 5507 : 		{
; 5508 : 			gDLL->UnlockAchievement(ACHIEVEMENT_XP1_30);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	220					; 000000dcH
	call	eax
$LN877@setHasTech:

; 5509 : 		}
; 5510 : 
; 5511 : 		if(pkTechInfo->IsRepeat())

	mov	ecx, DWORD PTR _pkTechInfo$[esp+780]
	call	?IsRepeat@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsRepeat
	test	al, al
	je	$LN176@setHasTech

; 5512 : 		{
; 5513 : 			GetTeamTechs()->IncrementTechCount(eIndex);

	mov	edi, DWORD PTR _this$[esp+780]
	mov	ebx, DWORD PTR _eIndex$[esp+776]
	mov	ecx, DWORD PTR [edi+2980]
	push	ebx
	call	?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z ; CvTeamTechs::IncrementTechCount

; 5514 : 
; 5515 : 			GetTeamTechs()->SetResearchProgress(eIndex, 0, ePlayer);

	mov	ecx, DWORD PTR [edi+2980]
	push	ebp
	push	0
	push	ebx
	call	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgress

; 5516 : 
; 5517 : 			// Repeating techs are good for score!
; 5518 : 			int iScoreChange = /*10*/ GC.getSCORE_FUTURE_TECH_MULTIPLIER();
; 5519 : #ifdef NQM_OPTIONAL_SCORING_TWEAKS
; 5520 : 			if (GC.getGame().isOption("GAMEOPTION_TWEAKED_SCORING"))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7764
	push	OFFSET $SG226722
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN237@setHasTech

; 5521 : 				iScoreChange = GC.getNEW_SCORE_FUTURE_TECH_MULTIPLIER();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1792
$LN237@setHasTech:

; 5522 : #endif
; 5523 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	esi, esi
	npad	4
$LL174@setHasTech:

; 5524 : 			{
; 5525 : 				const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);
; 5526 : 				CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi

; 5527 : 				if(kLoopPlayer.isAlive() && kLoopPlayer.getTeam() == GetID())

	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN173@setHasTech
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN249@setHasTech
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN250@setHasTech
$LN249@setHasTech:
	or	eax, -1
$LN250@setHasTech:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN173@setHasTech

; 5528 : 				{
; 5529 : 					kLoopPlayer.ChangeScoreFromFutureTech(iScoreChange);

	push	ebp
	call	?ChangeScoreFromFutureTech@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeScoreFromFutureTech
$LN173@setHasTech:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL174@setHasTech

; 5530 : 				}
; 5531 : 			}
; 5532 : 
; 5533 : 			// report event to Python
; 5534 : 			////gDLL->getEventReporterIFace()->techAcquired(eIndex, GetID(), ePlayer, bAnnounce && 1 == GetTeamTechs()->GetTechCount(eIndex));
; 5535 : 
; 5536 : 			if(1 == GetTeamTechs()->GetTechCount(eIndex))

	mov	ecx, DWORD PTR [edi+2980]
	push	ebx
	call	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetTechCount
	cmp	eax, 1
	jne	$LN157@setHasTech

; 5537 : 			{
; 5538 : 				if(bAnnounce)

	cmp	BYTE PTR _bAnnounce$[esp+776], 0
	je	$LN157@setHasTech

; 5539 : 				{
; 5540 : 					if(GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN157@setHasTech

; 5541 : 					{
; 5542 : 						announceTechToPlayers(eIndex);

	push	0
	mov	eax, ebx
	push	eax
	mov	ecx, edi
	call	?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ; CvTeam::announceTechToPlayers

; 5543 : 					}
; 5544 : 				}
; 5545 : 			}
; 5546 : 		}
; 5547 : 		else

	jmp	$LN157@setHasTech
$LN176@setHasTech:

; 5548 : 		{
; 5549 : 			GetTeamTechs()->SetHasTech(eIndex, bNewValue);

	mov	edx, DWORD PTR _eIndex$[esp+776]
	mov	ebp, DWORD PTR _this$[esp+780]
	mov	ecx, DWORD PTR [ebp+2980]
	push	ebx
	push	edx
	call	?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetHasTech
	xor	edi, edi
	npad	12
$LL166@setHasTech:

; 5556 : 			{
; 5557 : 				const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);
; 5558 : 				CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5559 : 				if(kLoopPlayer.isAlive() && kLoopPlayer.getTeam() == GetID())

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	esi, DWORD PTR [edi+eax]
	je	SHORT $LN165@setHasTech
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN272@setHasTech
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN273@setHasTech
$LN272@setHasTech:
	or	eax, -1
$LN273@setHasTech:
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN165@setHasTech

; 5560 : 				{
; 5561 : 					for(pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$226736[esp+784]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN165@setHasTech
$LL162@setHasTech:

; 5562 : 					{
; 5563 : 						pLoopCity->updateStrengthValue();

	mov	ecx, eax
	call	?updateStrengthValue@CvCity@@QAEXXZ	; CvCity::updateStrengthValue
	push	0
	lea	ecx, DWORD PTR _iLoop$226736[esp+784]
	push	ecx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL162@setHasTech
$LN165@setHasTech:

; 5550 : 
; 5551 : 			// Tech progress affects city strength, so update
; 5552 : 			CvCity* pLoopCity;
; 5553 : 			int iLoop;
; 5554 : 
; 5555 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL166@setHasTech

; 5564 : 					}
; 5565 : 				}
; 5566 : 			}
; 5567 : 
; 5568 : 			NotificationTypes eNotificationType = NO_NOTIFICATION_TYPE;
; 5569 : 
; 5570 : 			const bool bIsActiveTeam = (GetID() == GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ebp+4]
	mov	DWORD PTR _eNotificationType$226748[esp+780], -1
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam

; 5571 : 			const int iNumPlots = GC.getMap().numPlots();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	esi, eax
	mov	eax, DWORD PTR [edx+4028]
	sete	BYTE PTR _bIsActiveTeam$226749[esp+780]

; 5572 : 			for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)

	test	eax, eax
	jle	$LN157@setHasTech
	mov	DWORD PTR tv3727[esp+780], 0
	mov	DWORD PTR tv2460[esp+780], eax
	npad	10
$LL865@setHasTech:

; 5573 : 			{
; 5574 : 				CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [eax+4068]
	add	esi, DWORD PTR tv3727[esp+780]

; 5575 : 
; 5576 : 				const ResourceTypes eResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$226756[esp+780], eax

; 5577 : 				if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	$LN158@setHasTech

; 5578 : 				{
; 5579 : 					CvResourceInfo* pResourceInfo = GC.getResourceInfo(eResource);

	mov	ecx, eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 5580 : 					CvAssert(pResourceInfo);
; 5581 : 
; 5582 : 					if(bNewValue)

	cmp	BYTE PTR _bNewValue$[esp+776], 0
	mov	ebp, eax
	mov	DWORD PTR _pResourceInfo$226758[esp+780], ebp
	je	$LN885@setHasTech

; 5583 : 					{
; 5584 : 						const TechTypes eTechReveal = static_cast<TechTypes>(pResourceInfo->getTechReveal());

	mov	ecx, ebp
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal

; 5585 : 						// Resource Reveal
; 5586 : 						if(eTechReveal == eIndex)

	cmp	eax, DWORD PTR _eIndex$[esp+776]
	jne	$LN885@setHasTech

; 5587 : 						{
; 5588 : 							// update the resources
; 5589 : 							if(pLoopPlot->isRevealed(m_eID))

	mov	ebx, DWORD PTR _this$[esp+780]
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, edx
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edi, ecx
	mov	ecx, edx
	sub	ecx, edi
	mov	edi, 1
	shl	edi, cl
	test	edi, DWORD PTR [esi+eax*4+8]
	je	$LN147@setHasTech

; 5590 : 							{
; 5591 : 								if(pLoopPlot->getResourceType(m_eID) != NO_RESOURCE)

	push	edx
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN147@setHasTech

; 5592 : 								{
; 5593 : 									// Create resource link
; 5594 : 									if(pLoopPlot->isOwned())

	mov	ecx, esi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN883@setHasTech

; 5595 : 										pLoopPlot->DoFindCityToLinkResourceTo();

	push	0
	mov	ecx, esi
	call	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo
$LN883@setHasTech:

; 5596 : 
; 5597 : 									// Only update for active team
; 5598 : 									if(bIsActiveTeam)

	cmp	BYTE PTR _bIsActiveTeam$226749[esp+780], 0
	je	$LN147@setHasTech

; 5599 : 									{
; 5600 : 										// If we've force revealed the resource for this team, then don't send another event
; 5601 : 										if(!pLoopPlot->IsResourceForceReveal(GetID()))

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	mov	ecx, esi
	call	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsResourceForceReveal
	test	al, al
	jne	SHORT $LN149@setHasTech

; 5602 : 										{
; 5603 : 											pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, esi
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN149@setHasTech:

; 5604 : 										}
; 5605 : 
; 5606 : 										// Notify the player that owns this Plot
; 5607 : 										if(pLoopPlot->getOwner() == GC.getGame().getActivePlayer() && pLoopPlot->getTeam() == GetID())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	movsx	edi, BYTE PTR [esi+4]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	$LN147@setHasTech
	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, esi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	cmp	eax, edi
	jne	$LN147@setHasTech

; 5608 : 										{
; 5609 : 											if(!CvPreGame::loadWBScenario() || GC.getGame().getGameTurn() > 0)

	call	?loadWBScenario@CvPreGame@@YA_NXZ	; CvPreGame::loadWBScenario
	test	al, al
	je	SHORT $LN146@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	test	eax, eax
	jle	$LN147@setHasTech
$LN146@setHasTech:

; 5610 : 											{
; 5611 : 												strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_RESOURCE", pResourceInfo->GetTextKey());

	mov	ecx, ebp
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	edx, DWORD PTR $T239745[esp+784]
	push	OFFSET $SG226772
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	mov	BYTE PTR __$EHRec$[esp+792], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239745[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5612 : 									
; 5613 : 												CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pResourceInfo->GetTextKey());

	mov	ecx, ebp
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	eax, DWORD PTR _strSummary$226773[esp+784]
	push	OFFSET $SG226775
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH

; 5614 : 
; 5615 : 												switch(pResourceInfo->getResourceUsage())

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+788], 2
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	sub	eax, 0
	je	SHORT $LN141@setHasTech
	sub	eax, 1
	je	SHORT $LN142@setHasTech
	sub	eax, 1
	jne	SHORT $LN144@setHasTech

; 5616 : 												{
; 5617 : 												case RESOURCEUSAGE_LUXURY:
; 5618 : 													eNotificationType = NOTIFICATION_DISCOVERED_LUXURY_RESOURCE;

	mov	DWORD PTR _eNotificationType$226748[esp+780], -1226075946 ; b6eb90d6H

; 5619 : 													break;

	jmp	SHORT $LN144@setHasTech
$LN142@setHasTech:

; 5620 : 												case RESOURCEUSAGE_STRATEGIC:
; 5621 : 													eNotificationType = NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE;

	mov	DWORD PTR _eNotificationType$226748[esp+780], 2094204588 ; 7cd306acH

; 5622 : 													break;

	jmp	SHORT $LN144@setHasTech
$LN141@setHasTech:

; 5623 : 												case RESOURCEUSAGE_BONUS:
; 5624 : 													eNotificationType = NOTIFICATION_DISCOVERED_BONUS_RESOURCE;

	mov	DWORD PTR _eNotificationType$226748[esp+780], 2117152609 ; 7e312f61H
$LN144@setHasTech:

; 5625 : 													break;
; 5626 : 												}
; 5627 : 
; 5628 : 												CvNotifications* pNotifications = GET_PLAYER(pLoopPlot->getOwner()).GetNotifications();

	movsx	eax, BYTE PTR [esi+4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	edi, eax

; 5629 : 												if(pNotifications)

	test	edi, edi
	je	SHORT $LN140@setHasTech

; 5630 : 												{
; 5631 : 													pNotifications->Add(eNotificationType, strBuffer, strSummary, pLoopPlot->getX(), pLoopPlot->getY(), eResource);

	movsx	ebp, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	lea	ecx, DWORD PTR _strSummary$226773[esp+780]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _eResource$226756[esp+780]
	push	-1
	push	ecx
	push	ebp
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+800]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR _eNotificationType$226748[esp+800]
	push	eax
	push	edx
	mov	ecx, edi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	mov	ebp, DWORD PTR _pResourceInfo$226758[esp+780]
	mov	ebx, DWORD PTR _this$[esp+780]
$LN140@setHasTech:

; 5632 : 												}
; 5633 : 											}

	lea	ecx, DWORD PTR _strSummary$226773[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN147@setHasTech
$LN885@setHasTech:
	mov	ebx, DWORD PTR _this$[esp+780]
$LN147@setHasTech:

; 5634 : 										}
; 5635 : 									}
; 5636 : 								}
; 5637 : 							}
; 5638 : 						}
; 5639 : 					}
; 5640 : 					// Resource Connection
; 5641 : 					if(pLoopPlot->getTeam() == GetID())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN326@setHasTech
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN326@setHasTech
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN325@setHasTech
$LN326@setHasTech:
	or	eax, -1
$LN325@setHasTech:
	cmp	eax, DWORD PTR [ebx+4]
	jne	$LN158@setHasTech

; 5642 : 					{
; 5643 : 						if(pResourceInfo->getTechCityTrade() == eIndex)

	mov	ecx, ebp
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	cmp	eax, DWORD PTR _eIndex$[esp+776]
	jne	$LN158@setHasTech

; 5644 : 						{
; 5645 : 							if(pLoopPlot->isCity() || pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	jne	SHORT $LN136@setHasTech
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN158@setHasTech
$LN136@setHasTech:

; 5646 : 							{
; 5647 : 								// Appropriate Improvement on this Plot?
; 5648 : 								if(pLoopPlot->isCity() || GC.getImprovementInfo(pLoopPlot->getImprovementType())->IsImprovementResourceTrade(eResource))

	mov	ecx, esi
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	jne	SHORT $LN134@setHasTech
	mov	eax, DWORD PTR _eResource$226756[esp+780]
	push	eax
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	$LN158@setHasTech
$LN134@setHasTech:

; 5649 : 								{
; 5650 : 									for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebp, ebp
	xor	ebx, ebx
$LL133@setHasTech:

; 5651 : 									{
; 5652 : 										const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);
; 5653 : 										CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5654 : 										if(kLoopPlayer.isAlive() && kLoopPlayer.getTeam() == GetID() && pLoopPlot->getOwner() == eLoopPlayer)

	cmp	BYTE PTR [ebx+ecx+2256], 0
	lea	edi, DWORD PTR [ebx+ecx]
	je	$LN132@setHasTech
	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN350@setHasTech
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN351@setHasTech
$LN350@setHasTech:
	or	eax, -1
$LN351@setHasTech:
	mov	edx, DWORD PTR _this$[esp+780]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN132@setHasTech
	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, ebp
	jne	$LN132@setHasTech

; 5655 : 										{
; 5656 : 											// We now have a new Tech
; 5657 : 											if(bNewValue)

	cmp	BYTE PTR _bNewValue$[esp+776], 0
	je	SHORT $LN129@setHasTech

; 5658 : 											{
; 5659 : 												// slewis - added in so resources wouldn't be double counted when the minor civ researches the technology
; 5660 : 												if (!(kLoopPlayer.isMinorCiv() && pLoopPlot->IsImprovedByGiftFromMajor()))

	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN127@setHasTech
	mov	ecx, esi
	call	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ ; CvPlot::IsImprovedByGiftFromMajor
	test	al, al
	jne	SHORT $LN128@setHasTech
$LN127@setHasTech:

; 5661 : 												{
; 5662 : 													kLoopPlayer.changeNumResourceTotal(eResource, pLoopPlot->getNumResourceForPlayer(eLoopPlayer));

	push	0
	push	ebp
	mov	ecx, esi
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	mov	ecx, DWORD PTR _eResource$226756[esp+784]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal
$LN128@setHasTech:

; 5663 : 												}
; 5664 : 
; 5665 : 												// Reconnect resource link
; 5666 : 												if(pLoopPlot->GetResourceLinkedCity() != NULL)

	mov	ecx, esi
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity

; 5667 : 												{
; 5668 : 													pLoopPlot->SetResourceLinkedCityActive(true);

	mov	ecx, esi
	test	eax, eax
	je	SHORT $LN126@setHasTech
	push	1

; 5669 : 												}
; 5670 : 												// Create resource link
; 5671 : 												else

	jmp	SHORT $LN903@setHasTech
$LN126@setHasTech:

; 5672 : 												{
; 5673 : 													pLoopPlot->DoFindCityToLinkResourceTo();

	push	0
	call	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo

; 5674 : 												}
; 5675 : 											}
; 5676 : 											// Removing Tech
; 5677 : 											else

	jmp	SHORT $LN132@setHasTech
$LN129@setHasTech:

; 5678 : 											{
; 5679 : 												kLoopPlayer.changeNumResourceTotal(eResource, -pLoopPlot->getNumResourceForPlayer(eLoopPlayer));

	push	0
	push	ebp
	mov	ecx, esi
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	mov	edx, DWORD PTR _eResource$226756[esp+784]
	neg	eax
	push	eax
	push	edx
	mov	ecx, edi
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 5680 : 
; 5681 : 												// Disconnect resource link
; 5682 : 												if(pLoopPlot->GetResourceLinkedCity() != NULL)

	mov	ecx, esi
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN132@setHasTech

; 5683 : 													pLoopPlot->SetResourceLinkedCityActive(false);

	push	0
	mov	ecx, esi
$LN903@setHasTech:
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive
$LN132@setHasTech:

; 5649 : 								{
; 5650 : 									for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	ebx, 63236				; 0000f704H
	inc	ebp
	cmp	ebx, 4047104				; 003dc100H
	jl	$LL133@setHasTech
$LN158@setHasTech:

; 5572 : 			for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)

	add	DWORD PTR tv3727[esp+780], 484		; 000001e4H
	sub	DWORD PTR tv2460[esp+780], 1
	jne	$LL865@setHasTech
$LN157@setHasTech:

; 5684 : 											}
; 5685 : 										}
; 5686 : 									}
; 5687 : 								}
; 5688 : 							}
; 5689 : 						}
; 5690 : 					}
; 5691 : 				}
; 5692 : 			}
; 5693 : 		}
; 5694 : 
; 5695 : 		processTech(eIndex, ((bNewValue) ? 1 : -1));

	mov	esi, DWORD PTR _eIndex$[esp+776]
	mov	ecx, DWORD PTR _this$[esp+780]
	xor	eax, eax
	cmp	BYTE PTR _bNewValue$[esp+776], al
	setne	al
	lea	eax, DWORD PTR [eax+eax-1]
	push	eax
	push	esi
	call	?processTech@CvTeam@@IAEXW4TechTypes@@H@Z ; CvTeam::processTech

; 5696 : 
; 5697 : 		//Antiquity site notifications.
; 5698 : 		//Notifications for Artifacts and Hidden Artifacts have to come AFTER processTech because they may not have been spawned yet.
; 5699 : 		if(!CvPreGame::loadWBScenario() || GC.getGame().getGameTurn() > 0)

	call	?loadWBScenario@CvPreGame@@YA_NXZ	; CvPreGame::loadWBScenario
	test	al, al
	je	SHORT $LN121@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	test	eax, eax
	jle	$LN878@setHasTech
$LN121@setHasTech:

; 5700 : 		{
; 5701 : 			bool bTechRevealsArtifacts = false;
; 5702 : 			bool bTechRevealsHiddenArtifacts = false;
; 5703 : 
; 5704 : 			ResourceTypes eArtifactResource = (ResourceTypes)GC.getInfoTypeForString("RESOURCE_ARTIFACTS", true);

	push	1
	xor	bl, bl
	push	OFFSET $SG226812
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bTechRevealsArtifacts$226808[esp+788], 0
	mov	BYTE PTR _bTechRevealsHiddenArtifacts$226809[esp+788], bl
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebp, eax
	mov	DWORD PTR _eArtifactResource$226810[esp+780], ebp

; 5705 : 			CvResourceInfo* pArtifactResource = NULL;

	mov	DWORD PTR _pArtifactResource$226813[esp+780], 0

; 5706 : 			if(eArtifactResource != NO_RESOURCE)

	cmp	ebp, -1
	je	SHORT $LN120@setHasTech

; 5707 : 			{
; 5708 : 				pArtifactResource = GC.getResourceInfo(eArtifactResource);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 5709 : 				bTechRevealsArtifacts = pArtifactResource->getTechReveal() == eIndex;			

	mov	ecx, eax
	mov	DWORD PTR _pArtifactResource$226813[esp+780], eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, esi
	sete	BYTE PTR _bTechRevealsArtifacts$226808[esp+780]
$LN120@setHasTech:

; 5710 : 			}
; 5711 : 
; 5712 : 			ResourceTypes eHiddenArtifactResource = (ResourceTypes)GC.getInfoTypeForString("RESOURCE_HIDDEN_ARTIFACTS", true);;

	push	1
	push	OFFSET $SG226817
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 5713 : 			CvResourceInfo* pHiddenArtifactResource = NULL;

	xor	edi, edi
	mov	DWORD PTR _eHiddenArtifactResource$226815[esp+780], eax
	mov	DWORD PTR _pHiddenArtifactResource$226818[esp+780], edi

; 5714 : 			if(eHiddenArtifactResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN119@setHasTech

; 5715 : 			{
; 5716 : 				pHiddenArtifactResource = GC.getResourceInfo(eHiddenArtifactResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	edi, eax

; 5717 : 				bTechRevealsHiddenArtifacts = pHiddenArtifactResource->getTechReveal() == eIndex;

	mov	ecx, edi
	mov	DWORD PTR _pHiddenArtifactResource$226818[esp+780], edi
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, esi
	sete	bl
	mov	BYTE PTR _bTechRevealsHiddenArtifacts$226809[esp+780], bl
$LN119@setHasTech:

; 5718 : 			}
; 5719 : 
; 5720 : 			if(bTechRevealsArtifacts | bTechRevealsHiddenArtifacts)

	or	bl, BYTE PTR _bTechRevealsArtifacts$226808[esp+780]
	je	$LN878@setHasTech

; 5721 : 			{
; 5722 : 				const PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 5723 : #ifdef AUI_WARNING_FIXES
; 5724 : 				for (uint iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
; 5725 : #else
; 5726 : 				const int iNumPlots = GC.getMap().numPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _eActivePlayer$226821[esp+780], eax
	mov	eax, DWORD PTR [ecx+4028]

; 5727 : 				for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)

	test	eax, eax
	jle	$LN878@setHasTech
	mov	DWORD PTR tv3742[esp+780], 0
	mov	DWORD PTR tv2213[esp+780], eax
	npad	15
$LL892@setHasTech:

; 5728 : #endif
; 5729 : 				{
; 5730 : 					CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4068]
	add	esi, DWORD PTR tv3742[esp+780]

; 5731 : 
; 5732 : 					if(pLoopPlot->getOwner() == eActivePlayer && pLoopPlot->getTeam() == m_eID && pLoopPlot->isRevealed(m_eID))

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, DWORD PTR _eActivePlayer$226821[esp+780]
	jne	$LN116@setHasTech
	cmp	eax, -1
	je	SHORT $LN374@setHasTech
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN374@setHasTech
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN373@setHasTech
$LN374@setHasTech:
	or	eax, -1
$LN373@setHasTech:
	mov	ecx, DWORD PTR _this$[esp+780]
	mov	edx, DWORD PTR [ecx+4]
	cmp	eax, edx
	jne	$LN116@setHasTech
	mov	eax, edx
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	ebx, ecx
	mov	ecx, edx
	sub	ecx, ebx
	mov	ebx, 1
	shl	ebx, cl
	test	ebx, DWORD PTR [esi+eax*4+8]
	je	$LN116@setHasTech

; 5733 : 					{
; 5734 : 						const ResourceTypes ePlotResource = pLoopPlot->getResourceType(m_eID);

	push	edx
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 5735 : 						if( (bTechRevealsArtifacts && ePlotResource == eArtifactResource) || 
; 5736 : 							(bTechRevealsHiddenArtifacts && ePlotResource == eHiddenArtifactResource))

	cmp	BYTE PTR _bTechRevealsArtifacts$226808[esp+780], 0
	mov	ebx, eax
	je	SHORT $LN111@setHasTech
	cmp	ebx, ebp
	je	SHORT $LN112@setHasTech
$LN111@setHasTech:
	cmp	BYTE PTR _bTechRevealsHiddenArtifacts$226809[esp+780], 0
	je	$LN116@setHasTech
	cmp	ebx, DWORD PTR _eHiddenArtifactResource$226815[esp+780]
	jne	$LN116@setHasTech
$LN112@setHasTech:

; 5737 : 						{
; 5738 : 							CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$226833[esp+780]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+788], 3

; 5739 : 					//		CvString strBuffer;
; 5740 : 							ResourceUsageTypes eResourceUsage = RESOURCEUSAGE_LUXURY;

	mov	eax, 2

; 5741 : 							NotificationTypes eNotificationType = NO_NOTIFICATION_TYPE;

	mov	DWORD PTR _eNotificationType$226835[esp+780], -1

; 5742 : 
; 5743 : 							if(ePlotResource == eArtifactResource)

	cmp	ebx, ebp
	jne	SHORT $LN110@setHasTech

; 5744 : 							{
; 5745 : 								strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_ARTIFACTS");

	lea	edx, DWORD PTR $T239746[esp+780]
	push	OFFSET $SG226838
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	mov	BYTE PTR __$EHRec$[esp+792], 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239746[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5746 : 								strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pArtifactResource->GetTextKey());

	mov	edi, DWORD PTR _pArtifactResource$226813[esp+780]
	mov	ecx, edi
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	eax, DWORD PTR $T239747[esp+784]
	push	OFFSET $SG226840
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+788], 5

; 5747 : 								eResourceUsage = pArtifactResource->getResourceUsage();

	jmp	SHORT $LN904@setHasTech
$LN110@setHasTech:

; 5748 : 							}
; 5749 : 							else if(ePlotResource == eHiddenArtifactResource)

	cmp	ebx, DWORD PTR _eHiddenArtifactResource$226815[esp+780]
	jne	$LN108@setHasTech

; 5750 : 							{
; 5751 : 								strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_HIDDEN_ARTIFACTS");

	lea	ecx, DWORD PTR $T239748[esp+780]
	push	OFFSET $SG226844
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	mov	BYTE PTR __$EHRec$[esp+792], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239748[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5752 : 								strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pHiddenArtifactResource->GetTextKey());

	mov	ecx, edi
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	edx, DWORD PTR $T239749[esp+784]
	push	OFFSET $SG226846
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+788], 7
$LN904@setHasTech:
	push	eax
	lea	ecx, DWORD PTR _strSummary$226833[esp+784]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239749[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5753 : 								eResourceUsage = pHiddenArtifactResource->getResourceUsage();

	mov	ecx, edi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
$LN108@setHasTech:

; 5754 : 							}
; 5755 : 
; 5756 : 							switch(eResourceUsage)

	sub	eax, 0
	je	SHORT $LN103@setHasTech
	sub	eax, 1
	je	SHORT $LN104@setHasTech
	sub	eax, 1
	jne	SHORT $LN106@setHasTech

; 5757 : 							{
; 5758 : 							case RESOURCEUSAGE_LUXURY:
; 5759 : 								eNotificationType = NOTIFICATION_DISCOVERED_LUXURY_RESOURCE;

	mov	DWORD PTR _eNotificationType$226835[esp+780], -1226075946 ; b6eb90d6H

; 5760 : 								break;

	jmp	SHORT $LN106@setHasTech
$LN104@setHasTech:

; 5761 : 							case RESOURCEUSAGE_STRATEGIC:
; 5762 : 								eNotificationType = NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE;

	mov	DWORD PTR _eNotificationType$226835[esp+780], 2094204588 ; 7cd306acH

; 5763 : 								break;

	jmp	SHORT $LN106@setHasTech
$LN103@setHasTech:

; 5764 : 							case RESOURCEUSAGE_BONUS:
; 5765 : 								eNotificationType = NOTIFICATION_DISCOVERED_BONUS_RESOURCE;

	mov	DWORD PTR _eNotificationType$226835[esp+780], 2117152609 ; 7e312f61H
$LN106@setHasTech:

; 5766 : 								break;
; 5767 : 							}
; 5768 : 
; 5769 : 							CvNotifications* pNotifications = GET_PLAYER(pLoopPlot->getOwner()).GetNotifications();

	movsx	eax, BYTE PTR [esi+4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	edi, eax

; 5770 : 							if(pNotifications)

	test	edi, edi
	je	SHORT $LN102@setHasTech

; 5771 : 							{
; 5772 : 								pNotifications->Add(eNotificationType, strBuffer, strSummary, pLoopPlot->getX(), pLoopPlot->getY(), ePlotResource);

	movsx	ebp, WORD PTR [esi+2]
	movsx	esi, WORD PTR [esi]
	lea	ecx, DWORD PTR _strSummary$226833[esp+780]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	ebx
	push	ebp
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+800]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	eax, DWORD PTR _eNotificationType$226835[esp+804]
	push	eax
	mov	ecx, edi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	mov	ebp, DWORD PTR _eArtifactResource$226810[esp+780]
$LN102@setHasTech:

; 5773 : 							}
; 5774 : 						}

	lea	ecx, DWORD PTR _strSummary$226833[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	edi, DWORD PTR _pHiddenArtifactResource$226818[esp+780]
$LN116@setHasTech:
	add	DWORD PTR tv3742[esp+780], 484		; 000001e4H
	sub	DWORD PTR tv2213[esp+780], 1
	jne	$LL892@setHasTech

; 5727 : 				for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)

	mov	esi, DWORD PTR _eIndex$[esp+776]
$LN878@setHasTech:

; 5775 : 					}
; 5776 : 				}
; 5777 : 			}
; 5778 : 
; 5779 : 		}
; 5780 : 
; 5781 : 		if(GetTeamTechs()->HasTech(eIndex))

	mov	ecx, DWORD PTR _this$[esp+780]
	mov	ecx, DWORD PTR [ecx+2980]
	push	esi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN874@setHasTech

; 5782 : 		{
; 5783 : 			EraTypes eThisTechsEra = (EraTypes) pkTechInfo->GetEra();

	mov	ebp, DWORD PTR _pkTechInfo$[esp+780]
	mov	ecx, ebp
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra

; 5784 : 
; 5785 : 			// Era change for this Team?
; 5786 : 			if(GetCurrentEra() < eThisTechsEra)

	mov	ebx, DWORD PTR _this$[esp+780]
	cmp	DWORD PTR [ebx+136], eax
	jge	SHORT $LN100@setHasTech

; 5787 : 			{
; 5788 : 				EraTypes eNewEra = (EraTypes) pkTechInfo->GetEra();

	mov	ecx, ebp
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra

; 5789 : 				//int iEraChange = eNewEra - GetCurrentEra();
; 5790 : 
; 5791 : 				//int iVictoryPointChange = iEraChange * /*1*/ GC.getVICTORY_POINTS_PER_ERA();
; 5792 : 				//changeVictoryPoints(iVictoryPointChange);
; 5793 : 
; 5794 : 				//strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ERA_VICTORY_POINTS", iVictoryPointChange);
; 5795 : 				//CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ERA_VICTORY_POINTS");
; 5796 : 				//AddNotification(NOTIFICATION_VICTORY, strBuffer, strSummary);
; 5797 : 
; 5798 : 				SetCurrentEra(eNewEra);

	push	eax

; 5799 : 			}
; 5800 : 			// DON'T enter a new era with this tech
; 5801 : 			else

	jmp	SHORT $LN905@setHasTech
$LN100@setHasTech:

; 5802 : 			{
; 5803 : 				// If we have all the techs in the earlier eras, then we're in that era
; 5804 : 				bool bHasAllEarlierTechs = true;
; 5805 : #ifdef AUI_WARNING_FIXES
; 5806 : 				for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 5807 : #else
; 5808 : 				for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN886@setHasTech
$LL895@setHasTech:

; 5809 : #endif
; 5810 : 				{
; 5811 : 					const TechTypes eLoopTech = static_cast<TechTypes>(iTechLoop);
; 5812 : 					CvTechEntry* pkLoopTech = GC.getTechInfo(eLoopTech);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 5813 : 					if(pkLoopTech)

	test	eax, eax
	je	SHORT $LN97@setHasTech

; 5814 : 					{
; 5815 : 						// Only look at techs prior to our era - there's no need to go further
; 5816 : 						if(pkLoopTech->GetEra() <= GetCurrentEra())

	mov	edi, DWORD PTR [ebx+136]
	mov	ecx, eax
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	cmp	eax, edi
	jg	SHORT $LN97@setHasTech

; 5817 : 						{
; 5818 : 							if(!GetTeamTechs()->HasTech(eLoopTech))

	mov	ecx, DWORD PTR [ebx+2980]
	push	esi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN888@setHasTech
$LN97@setHasTech:

; 5802 : 			{
; 5803 : 				// If we have all the techs in the earlier eras, then we're in that era
; 5804 : 				bool bHasAllEarlierTechs = true;
; 5805 : #ifdef AUI_WARNING_FIXES
; 5806 : 				for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 5807 : #else
; 5808 : 				for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	SHORT $LL895@setHasTech
$LN886@setHasTech:

; 5819 : 							{
; 5820 : 								bHasAllEarlierTechs = false;
; 5821 : 								break;
; 5822 : 							}
; 5823 : 						}
; 5824 : 					}
; 5825 : 				}
; 5826 : 
; 5827 : 				if(bHasAllEarlierTechs)
; 5828 : 				{
; 5829 : #ifdef AUI_WARNING_FIXES
; 5830 : 					const uint iNextEra = static_cast<uint>(GetCurrentEra()) + 1;
; 5831 : #else
; 5832 : 					const EraTypes currentEra = GetCurrentEra();

	mov	esi, DWORD PTR [ebx+136]

; 5833 : 					const int iNextEra = static_cast<int>(currentEra) + 1;
; 5834 : #endif
; 5835 : 					if(iNextEra < GC.getNumEraInfos())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumEraInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumEraInfos
	cmp	esi, eax
	jge	SHORT $LN888@setHasTech

; 5836 : 					{
; 5837 : 						const EraTypes nextEra = static_cast<EraTypes>(iNextEra);
; 5838 : 						const CvEraInfo* pkEraInfo = GC.getEraInfo(nextEra);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo

; 5839 : 						if(pkEraInfo != NULL)

	test	eax, eax
	je	SHORT $LN888@setHasTech

; 5840 : 						{
; 5841 : 							SetCurrentEra(nextEra);

	push	esi
$LN905@setHasTech:
	mov	ecx, ebx
	call	?SetCurrentEra@CvTeam@@QAEXW4EraTypes@@@Z ; CvTeam::SetCurrentEra
$LN888@setHasTech:

; 5842 : 						}
; 5843 : 					}
; 5844 : 
; 5845 : 				}
; 5846 : 			}
; 5847 : 
; 5848 : 			if(pkTechInfo->IsMapVisible())

	mov	ecx, ebp
	call	?IsMapVisible@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsMapVisible
	test	al, al
	je	SHORT $LN89@setHasTech

; 5849 : 			{
; 5850 : 				GC.getMap().setRevealedPlots(GetID(), true, true);

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	1
	push	eax
	call	?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z ; CvMap::setRevealedPlots

; 5851 : 				GC.getMap().updateDeferredFog();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN89@setHasTech:

; 5852 : 			}
; 5853 : 
; 5854 : 			DoUpdateBestRoute();

	mov	ecx, ebx
	call	?DoUpdateBestRoute@CvTeam@@QAEXXZ	; CvTeam::DoUpdateBestRoute

; 5855 : 
; 5856 : 			// report event to Python, along with some other key state
; 5857 : 			//////gDLL->getEventReporterIFace()->techAcquired(eIndex, GetID(), ePlayer, bAnnounce);
; 5858 : 
; 5859 : 			bFirstResource = false;

	xor	bl, bl
	xor	edi, edi
$LL88@setHasTech:

; 5860 : 
; 5861 : 			for(int iI = 0; iI < MAX_PLAYERS; iI++)
; 5862 : 			{
; 5863 : 				const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);
; 5864 : 				CvPlayerAI& kPlayer = GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5865 : 				if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [edi+edx+2256], 0
	lea	esi, DWORD PTR [edi+edx]
	je	SHORT $LN87@setHasTech
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN454@setHasTech
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN455@setHasTech
$LN454@setHasTech:
	or	eax, -1
$LN455@setHasTech:
	mov	ecx, DWORD PTR _this$[esp+780]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN87@setHasTech

; 5866 : 				{
; 5867 : 					if(kPlayer.GetPlayerTechs()->IsResearchingTech(eIndex))

	mov	edx, DWORD PTR _eIndex$[esp+776]
	push	edx
	mov	ecx, esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::IsResearchingTech
	test	al, al
	je	SHORT $LN84@setHasTech

; 5868 : 					{
; 5869 : 						kPlayer.popResearch(eIndex);

	mov	eax, DWORD PTR _eIndex$[esp+776]
	push	eax
	mov	ecx, esi
	call	?popResearch@CvPlayer@@QAEXW4TechTypes@@@Z ; CvPlayer::popResearch
$LN84@setHasTech:

; 5870 : 					}
; 5871 : 
; 5872 : 					// notify the player they now have the tech, if they want to make immediate changes
; 5873 : 					//GET_PLAYER((PlayerTypes)iI).AI_nowHasTech(eIndex);
; 5874 : 
; 5875 : 					kPlayer.invalidateYieldRankCache();

	push	-1
	mov	ecx, esi
	call	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z ; CvPlayer::invalidateYieldRankCache
$LN87@setHasTech:
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL88@setHasTech

; 5876 : 				}
; 5877 : 			}
; 5878 : 
; 5879 : 			if(bFirst)

	cmp	BYTE PTR _bFirst$[esp+776], 0
	je	$LN881@setHasTech

; 5880 : 			{
; 5881 : 				if(GC.getGame().countKnownTechNumTeams(eIndex) == 1)

	mov	ecx, DWORD PTR _eIndex$[esp+776]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?countKnownTechNumTeams@CvGame@@QAEHW4TechTypes@@@Z ; CvGame::countKnownTechNumTeams
	cmp	eax, 1
	jne	$LN881@setHasTech

; 5882 : 				{
; 5883 : 					if(pkTechInfo->GetFirstFreeUnitClass() != NO_UNITCLASS)

	mov	ecx, ebp
	call	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFirstFreeUnitClass

; 5884 : 					{
; 5885 : 						bFirstResource = true;
; 5886 : 
; 5887 : 						eFreeUnit = ((UnitTypes)(GET_PLAYER(ePlayer).getCivilizationInfo().getCivilizationUnits(GC.getTechInfo(eIndex)->GetFirstFreeUnitClass())));

	mov	edi, DWORD PTR tv2663[esp+780]
	cmp	eax, -1
	je	SHORT $LN79@setHasTech
	mov	eax, DWORD PTR _eIndex$[esp+776]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	bl, 1
	lea	esi, DWORD PTR [edi+edx]
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFirstFreeUnitClass
	push	eax
	mov	ecx, esi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	esi, eax

; 5888 : 
; 5889 : 						if(eFreeUnit != NULL)

	test	esi, esi
	je	SHORT $LN79@setHasTech

; 5890 : 						{
; 5891 : 							pCapitalCity = GET_PLAYER(ePlayer).getCapitalCity();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 5892 : 
; 5893 : 							if(pCapitalCity != NULL)

	test	eax, eax
	je	SHORT $LN79@setHasTech

; 5894 : 							{
; 5895 : 								pCapitalCity->GetCityCitizens()->DoSpawnGreatPerson(eFreeUnit, true, false);

	push	0
	push	1
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson
$LN79@setHasTech:

; 5896 : 							}
; 5897 : 						}
; 5898 : 					}
; 5899 : 
; 5900 : 					if(pkTechInfo->GetFirstFreeTechs() > 0)

	mov	ecx, ebp
	call	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeTechs
	test	eax, eax
	jle	$LN78@setHasTech

; 5901 : 					{
; 5902 : 						bFirstResource = true;
; 5903 : 
; 5904 : 						if(!isHuman())

	mov	ecx, DWORD PTR _this$[esp+780]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman

; 5905 : 						{
; 5906 : 							for(int iI = 0; iI < pkTechInfo->GetFirstFreeTechs(); iI++)

	mov	ecx, ebp
	test	al, al
	jne	SHORT $LN77@setHasTech
	xor	esi, esi
	call	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeTechs
	test	eax, eax
	jle	$LN73@setHasTech
	npad	6
$LL76@setHasTech:

; 5907 : 							{
; 5908 : 								GET_PLAYER(ePlayer).AI_chooseFreeTech();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+edx]
	lea	ecx, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR [eax+56]
	call	edx
	mov	ecx, ebp
	inc	esi
	call	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeTechs
	cmp	esi, eax
	jl	SHORT $LL76@setHasTech

; 5909 : 							}
; 5910 : 						}
; 5911 : 						else

	jmp	SHORT $LN73@setHasTech
$LN77@setHasTech:

; 5912 : 						{
; 5913 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_FIRST_TECH_CHOOSE_FREE", pkTechInfo->GetTextKey());

	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	eax, DWORD PTR $T239750[esp+784]
	push	OFFSET $SG226907
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	mov	BYTE PTR __$EHRec$[esp+792], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239750[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5914 : 							GET_PLAYER(ePlayer).chooseTech(GC.getTechInfo(eIndex)->GetFirstFreeTechs(), strBuffer.GetCString());

	lea	ecx, DWORD PTR _strBuffer$[esp+780]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR _eIndex$[esp+776]
	push	-1
	push	eax
	lea	esi, DWORD PTR [edi+ecx]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeTechs
	push	eax
	mov	ecx, esi
	call	?chooseTech@CvPlayer@@QAEXHPBDW4TechTypes@@@Z ; CvPlayer::chooseTech
$LN73@setHasTech:

; 5915 : 						}
; 5916 : 
; 5917 : 						for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebp, ebp
	xor	ebx, ebx
	npad	9
$LL72@setHasTech:

; 5918 : 						{
; 5919 : 							const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);
; 5920 : 							CvPlayerAI& kLoopPLayer = GET_PLAYER(eLoopPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5921 : 							if(kLoopPLayer.isAlive() && GC.getGame().getActivePlayer())

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	esi, DWORD PTR [ebx+eax]
	je	$LN71@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	test	eax, eax
	je	$LN71@setHasTech

; 5922 : 							{
; 5923 : 								if(isHasMet(kLoopPLayer.getTeam()))

	mov	esi, DWORD PTR [esi+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN490@setHasTech
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN491@setHasTech
$LN490@setHasTech:
	or	eax, -1
$LN491@setHasTech:
	mov	ecx, DWORD PTR _this$[esp+780]
	cmp	BYTE PTR [eax+ecx+1848], 0
	je	SHORT $LN68@setHasTech

; 5924 : 								{
; 5925 : 									strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_FIRST_TO_TECH", GET_PLAYER(ePlayer).getNameKey(), pkTechInfo->GetTextKey());

	mov	ecx, DWORD PTR _pkTechInfo$[esp+780]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR $T239751[esp+780], eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T239752[esp+780], eax
	lea	eax, DWORD PTR $T239751[esp+780]
	push	eax
	lea	ecx, DWORD PTR $T239752[esp+784]
	push	ecx
	lea	edx, DWORD PTR $T239753[esp+788]
	push	OFFSET $SG226920
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+788], 9

; 5926 : 								}
; 5927 : 								else

	jmp	SHORT $LN906@setHasTech
$LN68@setHasTech:

; 5928 : 								{
; 5929 : 									strBuffer = GetLocalizedText("TXT_KEY_MISC_UNKNOWN_FIRST_TO_TECH", GC.getTechInfo(eIndex)->GetTextKey());

	mov	eax, DWORD PTR _eIndex$[esp+776]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR $T239754[esp+784]
	push	OFFSET $SG226923
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+788], 10		; 0000000aH
$LN906@setHasTech:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239754[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5930 : 								}
; 5931 : 								DLLUI->AddMessage(0, eLoopPlayer, false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_FIRSTTOTECH", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_HIGHLIGHT_TEXT")*/);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+780]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	0
	mov	edx, DWORD PTR [esi]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	ebp
	push	0
	mov	ecx, esi
	call	edx
$LN71@setHasTech:
	add	ebx, 63236				; 0000f704H
	inc	ebp
	cmp	ebx, 4047104				; 003dc100H
	jl	$LL72@setHasTech

; 5932 : 							}
; 5933 : 						}
; 5934 : 
; 5935 : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_FIRST_TO_TECH", GET_PLAYER(ePlayer).getName(), GC.getTechInfo(eIndex)->GetTextKey());

	mov	eax, DWORD PTR _eIndex$[esp+776]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	mov	DWORD PTR $T239755[esp+780], eax
	call	?getName@CvPlayer@@QBEPBDXZ		; CvPlayer::getName
	lea	edx, DWORD PTR $T239755[esp+780]
	push	edx
	mov	DWORD PTR $T239756[esp+784], eax
	lea	eax, DWORD PTR $T239756[esp+784]
	push	eax
	lea	ecx, DWORD PTR $T239757[esp+788]
	push	OFFSET $SG226927
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	mov	BYTE PTR __$EHRec$[esp+792], 11		; 0000000bH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239757[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5936 : 						GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, ePlayer, strBuffer, -1, -1);

	mov	eax, DWORD PTR _ePlayer$[esp+776]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	-1
	push	-1
	lea	edx, DWORD PTR _strBuffer$[esp+788]
	push	edx
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 5937 : 					}
; 5938 : 
; 5939 : 					if(bFirstResource)

	jmp	SHORT $LN842@setHasTech
$LN78@setHasTech:
	test	bl, bl
	je	SHORT $LN881@setHasTech
$LN842@setHasTech:

; 5940 : 					{
; 5941 : 						for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	ebx, DWORD PTR _eIndex$[esp+776]
	xor	edi, edi
	npad	3
$LL65@setHasTech:

; 5942 : 						{
; 5943 : 							const PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iI);
; 5944 : 							CvPlayerAI& kPlayer = GET_PLAYER(eLoopPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5945 : 							if(kPlayer.isAlive())

	cmp	BYTE PTR [edi+ecx+2256], 0
	lea	esi, DWORD PTR [edi+ecx]
	je	SHORT $LN64@setHasTech

; 5946 : 							{
; 5947 : 								if(!(kPlayer.isHuman()))

	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN64@setHasTech

; 5948 : 								{
; 5949 : 									if(kPlayer.GetPlayerTechs()->IsResearchingTech(eIndex))

	push	ebx
	mov	ecx, esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::IsResearchingTech
	test	al, al
	je	SHORT $LN64@setHasTech

; 5950 : 									{
; 5951 : 										kPlayer.clearResearchQueue();

	mov	ecx, esi
	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue
$LN64@setHasTech:
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL65@setHasTech
$LN881@setHasTech:

; 5952 : 									}
; 5953 : 								}
; 5954 : 							}
; 5955 : 						}
; 5956 : 					}
; 5957 : 				}
; 5958 : 			}
; 5959 : 
; 5960 : 			if(bAnnounce)

	cmp	BYTE PTR _bAnnounce$[esp+776], 0
	je	$LN44@setHasTech

; 5961 : 			{
; 5962 : 				if(GC.getGame().isFinalInitialized()/* && !(gDLL->GetWorldBuilderMode())*/)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN44@setHasTech

; 5963 : 				{
; 5964 : 					announceTechToPlayers(eIndex);

	mov	edx, DWORD PTR _eIndex$[esp+776]
	mov	edi, DWORD PTR _this$[esp+780]
	xor	esi, esi
	push	esi
	push	edx
	mov	ecx, edi
	call	?announceTechToPlayers@CvTeam@@IAEXW4TechTypes@@_N@Z ; CvTeam::announceTechToPlayers

; 5965 : 
; 5966 : 					// Resources discovered in a player's territory
; 5967 : #ifdef AUI_WARNING_FIXES
; 5968 : 					for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 5969 : #else
; 5970 : 					for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [eax+4028], esi
	mov	DWORD PTR _iI$226941[esp+780], esi
	jle	$LN871@setHasTech

; 5963 : 				{
; 5964 : 					announceTechToPlayers(eIndex);

	mov	DWORD PTR tv3795[esp+780], esi
	npad	10
$LL893@setHasTech:

; 5971 : #endif
; 5972 : 					{
; 5973 : 						CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	ebp, DWORD PTR [eax+4068]
	add	ebp, DWORD PTR tv3795[esp+780]

; 5974 : 
; 5975 : 						if(pLoopPlot->getTeam() == GetID() && pLoopPlot->getOwner() == GC.getGame().getActivePlayer())

	movsx	esi, BYTE PTR [ebp+4]
	cmp	esi, -1
	je	SHORT $LN543@setHasTech
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN543@setHasTech
	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN542@setHasTech
$LN543@setHasTech:
	or	eax, -1
$LN542@setHasTech:
	cmp	eax, DWORD PTR [edi+4]
	jne	$LN56@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	$LN56@setHasTech

; 5976 : 						{
; 5977 : 							ResourceTypes eResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, ebp
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	esi, eax

; 5978 : 
; 5979 : 							if(eResource != NO_RESOURCE)

	cmp	esi, -1
	je	$LN56@setHasTech

; 5980 : 							{
; 5981 : 								if(GC.getResourceInfo(eResource)->getTechReveal() == eIndex && !isForceRevealedResource(eResource))

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, DWORD PTR _eIndex$[esp+776]
	jne	$LN56@setHasTech
	mov	eax, DWORD PTR [edi+2968]
	mov	ecx, DWORD PTR [edi+2972]
	cmp	eax, ecx
	je	SHORT $LN562@setHasTech
$LL573@setHasTech:
	cmp	DWORD PTR [eax], esi
	je	$LN56@setHasTech
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL573@setHasTech
$LN562@setHasTech:

; 5982 : 								{
; 5983 : 									pCity = GC.getMap().findCity(pLoopPlot->getX(), pLoopPlot->getY(), NO_PLAYER, GetID(), false);

	mov	eax, DWORD PTR [edi+4]
	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	0
	push	-1
	push	-1
	push	0
	push	0
	push	eax
	push	-1
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	ebx, eax

; 5984 : 
; 5985 : 									if(pCity != NULL)

	test	ebx, ebx
	je	$LN56@setHasTech

; 5986 : 									{
; 5987 : 										CvResourceInfo* pResourceInfo = GC.getResourceInfo(eResource);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 5988 : 
; 5989 : 										if(strcmp(pResourceInfo->GetType(), "RESOURCE_ARTIFACTS") == 0)

	lea	edi, DWORD PTR [eax+176]
	mov	ecx, edi
	mov	DWORD PTR _pResourceInfo$226951[esp+780], eax
	mov	esi, OFFSET $SG226953
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL856@setHasTech:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN857@setHasTech
	test	cl, cl
	je	SHORT $LN858@setHasTech
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN857@setHasTech
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL856@setHasTech
$LN858@setHasTech:
	xor	eax, eax
	jmp	SHORT $LN859@setHasTech
$LN857@setHasTech:
	sbb	eax, eax
	sbb	eax, -1
$LN859@setHasTech:
	test	eax, eax
	jne	SHORT $LN50@setHasTech

; 5990 : 										{
; 5991 : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	edx, DWORD PTR $T239758[esp+784]
	push	OFFSET $SG226955
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+788], 12		; 0000000cH
	jmp	$LN907@setHasTech
$LN50@setHasTech:

; 5992 : 										}
; 5993 : 										else if(strcmp(pResourceInfo->GetType(), "RESOURCE_HIDDEN_ARTIFACTS") == 0)

	mov	ecx, edi
	mov	esi, OFFSET $SG226958
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL860@setHasTech:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN861@setHasTech
	test	cl, cl
	je	SHORT $LN862@setHasTech
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN861@setHasTech
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL860@setHasTech
$LN862@setHasTech:
	xor	eax, eax
	jmp	SHORT $LN863@setHasTech
$LN861@setHasTech:
	sbb	eax, eax
	sbb	eax, -1
$LN863@setHasTech:

; 5994 : 										{
; 5995 : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_HIDDEN_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, ebx
	test	eax, eax
	jne	SHORT $LN48@setHasTech
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	eax, DWORD PTR $T239759[esp+784]
	push	OFFSET $SG226960
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+788], 13		; 0000000dH

; 5996 : 										}
; 5997 : 										else

	jmp	SHORT $LN907@setHasTech
$LN48@setHasTech:

; 5998 : 										{
; 5999 : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_YOU_DISCOVERED_RESOURCE", pResourceInfo->GetTextKey(), pCity->getNameKey());

	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, DWORD PTR _pResourceInfo$226951[esp+780]
	mov	DWORD PTR $T239760[esp+780], eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	lea	ecx, DWORD PTR $T239760[esp+780]
	push	ecx
	lea	edx, DWORD PTR $T239761[esp+784]
	push	edx
	mov	DWORD PTR $T239761[esp+788], eax
	lea	eax, DWORD PTR $T239762[esp+788]
	push	OFFSET $SG226965
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+788], 14		; 0000000eH
$LN907@setHasTech:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239762[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6000 : 										}
; 6001 : 
; 6002 : 										DLLUI->AddPlotMessage(0, pLoopPlot->GetPlotIndex(), pLoopPlot->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_DISCOVERRESOURCE", MESSAGE_TYPE_INFO, GC.getResourceInfo(eResource)->GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pLoopPlot->getX(), pLoopPlot->getY(), true, true*/);

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+780]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	movsx	ecx, BYTE PTR [ebp+4]
	mov	esi, DWORD PTR [edi]
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	edx
	push	0
	push	ecx
	mov	ecx, ebp
	add	esi, 168				; 000000a8H
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	push	eax
	mov	eax, DWORD PTR [esi]
	push	0
	mov	ecx, edi
	call	eax
	mov	edi, DWORD PTR _this$[esp+780]
$LN56@setHasTech:
	mov	ecx, DWORD PTR _iI$226941[esp+780]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv3795[esp+780], 484		; 000001e4H
	inc	ecx
	cmp	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iI$226941[esp+780], ecx
	jl	$LL893@setHasTech
$LN871@setHasTech:

; 6003 : 									}
; 6004 : 								}
; 6005 : 							}
; 6006 : 						}
; 6007 : 					}
; 6008 : 
; 6009 : 					// Cities demand a Resource that's been newly revealed
; 6010 : 					CvCity* pLoopCity;
; 6011 : 					int iLoop;
; 6012 : 					PlayerTypes eLoopPlayer;
; 6013 : 					ResourceTypes eResourceDemanded;
; 6014 : 
; 6015 : 					// Check all players on this team
; 6016 : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR tv3805[esp+780], ebp
	npad	3
$LL897@setHasTech:

; 6017 : 					{
; 6018 : 						eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 6019 : 
; 6020 : 						if(GET_PLAYER(eLoopPlayer).getTeam() == GetID() && eLoopPlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN626@setHasTech
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN627@setHasTech
$LN626@setHasTech:
	or	eax, -1
$LN627@setHasTech:
	mov	edx, DWORD PTR _this$[esp+780]
	cmp	eax, DWORD PTR [edx+4]
	jne	$LN45@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebx, eax
	jne	$LN45@setHasTech

; 6021 : 						{
; 6022 : 							// Look at all Cities
; 6023 : 							for(pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$226967[esp+784]
	lea	ecx, DWORD PTR [eax+ebp]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	$LN45@setHasTech
	npad	2
$LL42@setHasTech:

; 6024 : 							{
; 6025 : 								eResourceDemanded = pLoopCity->GetResourceDemanded();

	push	1
	mov	ecx, edi
	call	?GetResourceDemanded@CvCity@@QBE?AW4ResourceTypes@@_N@Z ; CvCity::GetResourceDemanded
	mov	esi, eax

; 6026 : 
; 6027 : 								if(eResourceDemanded != NO_RESOURCE)

	cmp	esi, -1
	je	$LN41@setHasTech

; 6028 : 								{
; 6029 : 									// Resource being demanded is revealed by this Tech
; 6030 : 									if(GC.getResourceInfo(eResourceDemanded)->getTechReveal() == eIndex)

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	cmp	eax, DWORD PTR _eIndex$[esp+776]
	jne	$LN41@setHasTech

; 6031 : 									{
; 6032 : 										strBuffer = GetLocalizedText("TXT_KEY_MISC_RESOURCE_DISCOVERED_CITY_DEMANDS", GC.getResourceInfo(eResourceDemanded)->GetTextKey(), pLoopCity->getNameKey());

	mov	ecx, edi
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR $T239763[esp+784], eax
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T239764[esp+780], eax
	lea	eax, DWORD PTR $T239763[esp+780]
	push	eax
	lea	ecx, DWORD PTR $T239764[esp+784]
	push	ecx
	lea	edx, DWORD PTR $T239765[esp+788]
	push	OFFSET $SG226984
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	mov	BYTE PTR __$EHRec$[esp+792], 15		; 0000000fH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239765[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6033 : 										DLLUI->AddCityMessage(0, pLoopCity->GetIDInfo(), eLoopPlayer, false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_DISCOVERRESOURCE", MESSAGE_TYPE_INFO, GC.getResourceInfo(eResourceDemanded)->GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), pLoopCity->getX(), pLoopCity->getY(), true, true*/);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+780]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	0
	push	0
	mov	esi, DWORD PTR [ebp]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	ebx
	lea	ecx, DWORD PTR $T239766[esp+828]
	push	ecx
	mov	ecx, edi
	add	esi, 172				; 000000acH
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	edx, DWORD PTR [esi]
	push	eax
	push	0
	mov	ecx, ebp
	call	edx
	mov	ebp, DWORD PTR tv3805[esp+780]
$LN41@setHasTech:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$226967[esp+784]
	lea	ecx, DWORD PTR [eax+ebp]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	$LL42@setHasTech
$LN45@setHasTech:

; 6003 : 									}
; 6004 : 								}
; 6005 : 							}
; 6006 : 						}
; 6007 : 					}
; 6008 : 
; 6009 : 					// Cities demand a Resource that's been newly revealed
; 6010 : 					CvCity* pLoopCity;
; 6011 : 					int iLoop;
; 6012 : 					PlayerTypes eLoopPlayer;
; 6013 : 					ResourceTypes eResourceDemanded;
; 6014 : 
; 6015 : 					// Check all players on this team
; 6016 : 					for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	ebp, 63236				; 0000f704H
	inc	ebx
	cmp	ebp, 1391192				; 00153a58H
	mov	DWORD PTR tv3805[esp+780], ebp
	jl	$LL897@setHasTech
$LN44@setHasTech:

; 6034 : 									}
; 6035 : 								}
; 6036 : 							}
; 6037 : 						}
; 6038 : 					}
; 6039 : 				}
; 6040 : 			}
; 6041 : 
; 6042 : 			for(int iI = 0; iI < MAX_TEAMS; iI++)

	mov	ebx, DWORD PTR _eIndex$[esp+776]
	mov	ebp, DWORD PTR _this$[esp+780]
	xor	edi, edi
	xor	esi, esi
	npad	11
$LL898@setHasTech:

; 6043 : 			{
; 6044 : 				const TeamTypes eLoopTeam = static_cast<TeamTypes>(iI);
; 6045 : 				CvTeam& kLoopTeam = GET_TEAM(eLoopTeam);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 6046 : 				if(kLoopTeam.isAlive())

	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN36@setHasTech

; 6047 : 				{
; 6048 : 					if(eLoopTeam != GetID())

	cmp	edi, DWORD PTR [ebp+4]
	je	SHORT $LN36@setHasTech

; 6049 : 					{
; 6050 : 						kLoopTeam.updateTechShare(eIndex);

	push	ebx
	call	?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z ; CvTeam::updateTechShare
$LN36@setHasTech:
	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 190976				; 0002ea00H
	jl	SHORT $LL898@setHasTech

; 6051 : 					}
; 6052 : 				}
; 6053 : 			}
; 6054 : 
; 6055 : 			// Cities that are owed a culture building are granted a culture building
; 6056 : 			CvCity* pLoopCity;
; 6057 : 			int iLoop;
; 6058 : 			PlayerTypes eLoopPlayer;
; 6059 : 
; 6060 : 			// Check all players on this team
; 6061 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	npad	5
$LL899@setHasTech:

; 6062 : 			{
; 6063 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 6064 : 
; 6065 : 				if(GET_PLAYER(eLoopPlayer).getTeam() == GetID())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+edi+44]
	add	ecx, edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN703@setHasTech
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN704@setHasTech
$LN703@setHasTech:
	or	eax, -1
$LN704@setHasTech:
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN31@setHasTech

; 6066 : 				{
; 6067 : 					// Look at all Cities
; 6068 : 					for(pLoopCity = GET_PLAYER(eLoopPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eLoopPlayer).nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$226996[esp+784]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN31@setHasTech
	npad	7
$LL28@setHasTech:

; 6069 : 					{
; 6070 : 						if (pLoopCity->IsOwedCultureBuilding())

	mov	ecx, esi
	call	?IsOwedCultureBuilding@CvCity@@QBE_NXZ	; CvCity::IsOwedCultureBuilding
	test	al, al
	je	SHORT $LN27@setHasTech

; 6071 : 						{
; 6072 : 							BuildingTypes eFreeCultureBuilding = pLoopCity->ChooseFreeCultureBuilding();

	mov	ecx, esi
	call	?ChooseFreeCultureBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ ; CvCity::ChooseFreeCultureBuilding

; 6073 : 							if (eFreeCultureBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN27@setHasTech

; 6074 : 							{
; 6075 : 								pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eFreeCultureBuilding, 1);

	push	1
	push	eax
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding

; 6076 : 								pLoopCity->SetOwedCultureBuilding(false);

	push	0
	mov	ecx, esi
	call	?SetOwedCultureBuilding@CvCity@@QAEX_N@Z ; CvCity::SetOwedCultureBuilding
$LN27@setHasTech:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$226996[esp+784]
	add	ecx, edi
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL28@setHasTech
$LN31@setHasTech:

; 6051 : 					}
; 6052 : 				}
; 6053 : 			}
; 6054 : 
; 6055 : 			// Cities that are owed a culture building are granted a culture building
; 6056 : 			CvCity* pLoopCity;
; 6057 : 			int iLoop;
; 6058 : 			PlayerTypes eLoopPlayer;
; 6059 : 
; 6060 : 			// Check all players on this team
; 6061 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jl	$LL899@setHasTech
$LN874@setHasTech:

; 6077 : 							}
; 6078 : 						}
; 6079 : 					}
; 6080 : 				}
; 6081 : 			}
; 6082 : 		}
; 6083 : 
; 6084 : 		if(bNewValue)

	cmp	BYTE PTR _bNewValue$[esp+776], 0
	mov	esi, DWORD PTR tv2663[esp+780]
	je	$LN889@setHasTech

; 6085 : 		{
; 6086 : 			if(bAnnounce)

	cmp	BYTE PTR _bAnnounce$[esp+776], 0
	je	$LN875@setHasTech

; 6087 : 			{
; 6088 : 				if(GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN875@setHasTech

; 6089 : 				{
; 6090 : 					CvAssert(ePlayer != NO_PLAYER);
; 6091 : 					if(GET_PLAYER(ePlayer).isHuman())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN875@setHasTech

; 6092 : 					{
; 6093 : 						if(GET_PLAYER(ePlayer).GetPlayerTechs()->IsResearch() && (GET_PLAYER(ePlayer).GetPlayerTechs()->GetCurrentResearch() == NO_TECH))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?IsResearch@CvPlayerTechs@@QBE_NXZ	; CvPlayerTechs::IsResearch
	test	al, al
	je	$LN875@setHasTech
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
	cmp	eax, -1
	jne	SHORT $LN875@setHasTech

; 6094 : 						{
; 6095 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_WHAT_TO_RESEARCH_NEXT");

	lea	eax, DWORD PTR $T239767[esp+780]
	push	OFFSET $SG227016
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+784]
	mov	BYTE PTR __$EHRec$[esp+792], 16		; 00000010H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239767[esp+780]
	mov	BYTE PTR __$EHRec$[esp+788], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6096 : 							GET_PLAYER(ePlayer).chooseTech(0, strBuffer, eIndex);

	lea	ecx, DWORD PTR _strBuffer$[esp+780]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _eIndex$[esp+776]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	push	eax
	push	0
	lea	ecx, DWORD PTR [esi+edx]
	call	?chooseTech@CvPlayer@@QAEXHPBDW4TechTypes@@@Z ; CvPlayer::chooseTech
$LN875@setHasTech:

; 6097 : 						}
; 6098 : 					}
; 6099 : 				}
; 6100 : 			}
; 6101 : 
; 6102 : 			// espionage logic. Whenever someone gains a tech, reset the stealable techs for all other leaders
; 6103 : 			if(!GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN889@setHasTech
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN889@setHasTech

; 6104 : 			{
; 6105 : 				CvPlayerEspionage* pEspionage = GET_PLAYER(ePlayer).GetEspionage();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	edi, eax

; 6106 : 				if(pEspionage)

	test	edi, edi
	je	SHORT $LN889@setHasTech

; 6107 : 				{
; 6108 : 					for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	ebp, ebp
	xor	esi, esi
	npad	1
$LL16@setHasTech:

; 6109 : 					{
; 6110 : 						pEspionage->BuildStealableTechList((PlayerTypes)ui);

	push	ebp
	mov	ecx, edi
	call	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ; CvPlayerEspionage::BuildStealableTechList

; 6111 : 
; 6112 : 						// if the player is out of techs to steal, set their number of stealable techs to zero
; 6113 : 						if(pEspionage->m_aaPlayerStealableTechList[ui].size() == 0)

	mov	eax, DWORD PTR [edi+264]
	cmp	DWORD PTR [esi+eax+4], 0
	jne	SHORT $LN15@setHasTech

; 6114 : 						{
; 6115 : 							pEspionage->m_aiNumTechsToStealList[ui] = 0;

	mov	ecx, DWORD PTR [edi+720]
	mov	DWORD PTR [ecx+ebp*4], 0
$LN15@setHasTech:
	add	esi, 20					; 00000014H
	inc	ebp
	cmp	esi, 440				; 000001b8H
	jb	SHORT $LL16@setHasTech
$LN889@setHasTech:

; 6116 : 						}
; 6117 : 					}
; 6118 : 				}
; 6119 : 			}
; 6120 : 		}
; 6121 : 
; 6122 : 		// Update Happiness for all players
; 6123 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	edi, DWORD PTR _this$[esp+780]
	xor	ebx, ebx
	xor	esi, esi
	pop	ebp
	npad	9
$LL12@setHasTech:

; 6124 : 		{
; 6125 : 			if(GET_PLAYER((PlayerTypes)iPlayerLoop).isAlive() && GET_PLAYER((PlayerTypes) iPlayerLoop).getTeam() == GetID())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+edx+2256], 0
	lea	ecx, DWORD PTR [esi+edx]
	je	SHORT $LN11@setHasTech
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN755@setHasTech
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN756@setHasTech
$LN755@setHasTech:
	or	eax, -1
$LN756@setHasTech:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN11@setHasTech

; 6126 : 			{
; 6127 : 				GET_PLAYER((PlayerTypes) iPlayerLoop).DoUpdateHappiness();

	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN11@setHasTech:

; 6116 : 						}
; 6117 : 					}
; 6118 : 				}
; 6119 : 			}
; 6120 : 		}
; 6121 : 
; 6122 : 		// Update Happiness for all players
; 6123 : 		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL12@setHasTech

; 6128 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6129 : 				GET_PLAYER((PlayerTypes)iPlayerLoop).doSelfConsistencyCheckAllCities();
; 6130 : #endif
; 6131 : 			}
; 6132 : 		}
; 6133 : 
; 6134 : 		if(GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN891@setHasTech

; 6135 : 		{
; 6136 : 			if(GetID() == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	SHORT $LN7@setHasTech

; 6137 : 			{
; 6138 : 				DLLUI->setDirty(MiscButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	4
	call	edx

; 6139 : 				DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	6
	call	edx

; 6140 : 				DLLUI->setDirty(ResearchButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	8
	call	edx
$LN7@setHasTech:

; 6141 : 			}
; 6142 : 
; 6143 : 			if(eIndex != NO_TECH && bNewValue)

	cmp	BYTE PTR _bNewValue$[esp+772], 0
	je	$LN1@setHasTech

; 6144 : 			{
; 6145 : 				bool bDontShowRewardPopup = DLLUI->IsOptionNoRewardPopups();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+456]
	call	edx

; 6146 : 
; 6147 : 				// Notification in MP games
; 6148 : 				if(bDontShowRewardPopup || GC.getGame().isNetworkMultiPlayer())

	test	al, al
	jne	$LN4@setHasTech
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	jne	$LN4@setHasTech

; 6154 : 				// Popup in SP games
; 6155 : 				else if(GetID() == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	jne	$LN891@setHasTech

; 6156 : 				{
; 6157 : 					CvPopupInfo kPopup(BUTTONPOPUP_TECH_AWARD, GC.getGame().getActivePlayer(), 0, eIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer

; 6158 : 					//kPopup.setText(localizedText.toUTF8());
; 6159 : 					DLLUI->AddPopup(kPopup);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	DWORD PTR _kPopup$227047[esp+776], eax
	mov	eax, DWORD PTR _eIndex$[esp+772]
	mov	DWORD PTR _kPopup$227047[esp+784], eax
	mov	DWORD PTR _kPopup$227047[esp+780], ebx
	mov	DWORD PTR _kPopup$227047[esp+788], ebx
	mov	BYTE PTR _kPopup$227047[esp+792], 0
	mov	BYTE PTR _kPopup$227047[esp+793], 0
	mov	DWORD PTR _kPopup$227047[esp+796], 68	; 00000044H
	mov	BYTE PTR _kPopup$227047[esp+800], 0
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+180]
	lea	eax, DWORD PTR _kPopup$227047[esp+776]
	push	eax
	call	edx
	jmp	$LN891@setHasTech
$LN4@setHasTech:

; 6149 : 				{
; 6150 : 					Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_YOU_DISCOVERED_TECH");

	lea	eax, DWORD PTR _localizedText$227040[esp+776]
	push	OFFSET $SG227042
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 6151 : 					localizedText << pkTechInfo->GetTextKey();

	mov	ecx, DWORD PTR _pkTechInfo$[esp+776]
	mov	BYTE PTR __$EHRec$[esp+784], 17		; 00000011H
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _localizedText$227040[esp+780]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 6152 : 					AddNotification(NOTIFICATION_TECH_AWARD, localizedText.toUTF8(), localizedText.toUTF8(), -1, -1, 0, (int) eIndex);

	mov	ecx, DWORD PTR _eIndex$[esp+772]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	ecx
	push	ebx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _localizedText$227040[esp+792]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _localizedText$227040[esp+796]
	call	esi
	push	eax
	push	-33507383				; fe00b7c9H
	mov	ecx, edi
	call	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification

; 6153 : 				}

	lea	ecx, DWORD PTR _localizedText$227040[esp+776]
	mov	BYTE PTR __$EHRec$[esp+784], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN891@setHasTech:

; 6160 : 				}
; 6161 : 			}
; 6162 : 		}
; 6163 : 
; 6164 : 		if(bNewValue)

	cmp	BYTE PTR _bNewValue$[esp+772], 0
	je	SHORT $LN1@setHasTech

; 6165 : 		{
; 6166 : 			gDLL->GameplayTechAcquired(GetID(), eIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR _eIndex$[esp+772]
	mov	edx, DWORD PTR [ecx]
	push	esi
	push	eax
	mov	eax, DWORD PTR [edx+684]
	call	eax
$LN1@setHasTech:

; 6167 : 		}
; 6168 : 	}
; 6169 : }

	mov	DWORD PTR __$EHRec$[esp+784], -1
$LN902@setHasTech:
	lea	ecx, DWORD PTR _strBuffer$[esp+776]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+776]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 764				; 000002fcH
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$1:
	lea	ecx, DWORD PTR $T239745[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$2:
	lea	ecx, DWORD PTR _strSummary$226773[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$3:
	lea	ecx, DWORD PTR _strSummary$226833[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$4:
	lea	ecx, DWORD PTR $T239746[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$5:
	lea	ecx, DWORD PTR $T239747[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$6:
	lea	ecx, DWORD PTR $T239748[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$7:
	lea	ecx, DWORD PTR $T239749[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$8:
	lea	ecx, DWORD PTR $T239750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$9:
	lea	ecx, DWORD PTR $T239753[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$10:
	lea	ecx, DWORD PTR $T239754[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$11:
	lea	ecx, DWORD PTR $T239757[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$12:
	lea	ecx, DWORD PTR $T239758[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$13:
	lea	ecx, DWORD PTR $T239759[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$14:
	lea	ecx, DWORD PTR $T239762[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$15:
	lea	ecx, DWORD PTR $T239765[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$16:
	lea	ecx, DWORD PTR $T239767[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z$17:
	lea	ecx, DWORD PTR _localizedText$227040[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:
	mov	eax, OFFSET __ehfuncinfo$?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ENDP ; CvTeam::setHasTech
EXTRN	__imp_?max@?$numeric_limits@H@std@@SAHXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z
_TEXT	SEGMENT
_iBestShare$ = -12					; size = 4
$T241108 = -8						; size = 4
_this$ = -4						; size = 4
_eTech$ = 8						; size = 4
?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z PROC	; CvTeam::updateTechShare, COMDAT
; _this$ = ecx

; 6262 : {

	sub	esp, 12					; 0000000cH

; 6263 : 	int iBestShare;
; 6264 : 	int iCount;
; 6265 : 	int iI;
; 6266 : 
; 6267 : 	if(GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR _eTech$[esp+8]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+2980]
	push	eax
	mov	DWORD PTR _this$[esp+20], esi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	$LN1@updateTech
	push	ebp

; 6268 : 	{
; 6269 : 		return;
; 6270 : 	}
; 6271 : 
; 6272 : #ifdef AUI_FAST_COMP
; 6273 : 	iBestShare = MAX_INT;
; 6274 : #else
; 6275 : 	iBestShare = numeric_limits<int>::max();

	call	DWORD PTR __imp_?max@?$numeric_limits@H@std@@SAHXZ
	mov	ebp, eax
	mov	DWORD PTR _iBestShare$[esp+20], ebp
	mov	eax, 1
	lea	edx, DWORD PTR [esi+152]
	npad	6
$LL12@updateTech:

; 6276 : #endif
; 6277 : 
; 6278 : 	for(iI = 0; iI < MAX_TEAMS; iI++)
; 6279 : 	{
; 6280 : 		if(isTechShare(iI))

	lea	ecx, DWORD PTR [eax-1]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN11@updateTech
	cmp	DWORD PTR [edx-4], 0
	jle	SHORT $LN11@updateTech

; 6281 : 		{
; 6282 : #ifdef AUI_FAST_COMP
; 6283 : 			iBestShare = MIN(iBestShare, (iI + 1));
; 6284 : #else
; 6285 : 			iBestShare = std::min(iBestShare, (iI + 1));

	cmp	eax, ebp
	mov	DWORD PTR $T241108[esp+20], eax
	lea	ecx, DWORD PTR $T241108[esp+20]
	jl	SHORT $LN29@updateTech
	lea	ecx, DWORD PTR _iBestShare$[esp+20]
$LN29@updateTech:
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR _iBestShare$[esp+20], ebp
$LN11@updateTech:

; 6276 : #endif
; 6277 : 
; 6278 : 	for(iI = 0; iI < MAX_TEAMS; iI++)
; 6279 : 	{
; 6280 : 		if(isTechShare(iI))

	test	eax, eax
	jl	SHORT $LN51@updateTech
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN51@updateTech
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN51@updateTech

; 6281 : 		{
; 6282 : #ifdef AUI_FAST_COMP
; 6283 : 			iBestShare = MIN(iBestShare, (iI + 1));
; 6284 : #else
; 6285 : 			iBestShare = std::min(iBestShare, (iI + 1));

	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR $T241108[esp+20], ecx
	cmp	ecx, ebp
	lea	ecx, DWORD PTR $T241108[esp+20]
	jl	SHORT $LN50@updateTech
	lea	ecx, DWORD PTR _iBestShare$[esp+20]
$LN50@updateTech:
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR _iBestShare$[esp+20], ebp
$LN51@updateTech:
	lea	ecx, DWORD PTR [eax+1]
	test	ecx, ecx
	jl	SHORT $LN56@updateTech

; 6276 : #endif
; 6277 : 
; 6278 : 	for(iI = 0; iI < MAX_TEAMS; iI++)
; 6279 : 	{
; 6280 : 		if(isTechShare(iI))

	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN56@updateTech
	cmp	DWORD PTR [edx+4], 0
	jle	SHORT $LN56@updateTech

; 6281 : 		{
; 6282 : #ifdef AUI_FAST_COMP
; 6283 : 			iBestShare = MIN(iBestShare, (iI + 1));
; 6284 : #else
; 6285 : 			iBestShare = std::min(iBestShare, (iI + 1));

	lea	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR $T241108[esp+20], ecx
	cmp	ecx, ebp
	lea	ecx, DWORD PTR $T241108[esp+20]
	jl	SHORT $LN55@updateTech
	lea	ecx, DWORD PTR _iBestShare$[esp+20]
$LN55@updateTech:
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR _iBestShare$[esp+20], ebp
$LN56@updateTech:
	lea	ecx, DWORD PTR [eax+2]
	test	ecx, ecx
	jl	SHORT $LN61@updateTech

; 6276 : #endif
; 6277 : 
; 6278 : 	for(iI = 0; iI < MAX_TEAMS; iI++)
; 6279 : 	{
; 6280 : 		if(isTechShare(iI))

	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN61@updateTech
	cmp	DWORD PTR [edx+8], 0
	jle	SHORT $LN61@updateTech

; 6281 : 		{
; 6282 : #ifdef AUI_FAST_COMP
; 6283 : 			iBestShare = MIN(iBestShare, (iI + 1));
; 6284 : #else
; 6285 : 			iBestShare = std::min(iBestShare, (iI + 1));

	lea	ecx, DWORD PTR [eax+3]
	mov	DWORD PTR $T241108[esp+20], ecx
	cmp	ecx, ebp
	lea	ecx, DWORD PTR $T241108[esp+20]
	jl	SHORT $LN60@updateTech
	lea	ecx, DWORD PTR _iBestShare$[esp+20]
$LN60@updateTech:
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR _iBestShare$[esp+20], ebp
$LN61@updateTech:
	add	eax, 4
	lea	ecx, DWORD PTR [eax-1]
	add	edx, 16					; 00000010H
	cmp	ecx, 64					; 00000040H
	jl	$LL12@updateTech

; 6286 : #endif
; 6287 : 		}
; 6288 : 	}
; 6289 : 
; 6290 : 	if(iBestShare != INT_MAX)

	cmp	ebp, 2147483647				; 7fffffffH
	je	SHORT $LN66@updateTech
	push	ebx
	push	edi

; 6291 : 	{
; 6292 : 		iCount = 0;

	xor	ebx, ebx

; 6293 : 
; 6294 : 		for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	xor	edi, edi
	xor	esi, esi
$LL65@updateTech:

; 6295 : 		{
; 6296 : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+eax+12], 0
	jle	SHORT $LN6@updateTech

; 6297 : 			{
; 6298 : 				if(GET_TEAM((TeamTypes)iI).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR _eTech$[esp+24]
	mov	ecx, DWORD PTR [esi+eax+2980]
	push	edx
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN6@updateTech

; 6299 : 				{
; 6300 : 					if(isHasMet((TeamTypes)iI))

	mov	eax, DWORD PTR _this$[esp+28]
	cmp	BYTE PTR [edi+eax+1848], 0
	je	SHORT $LN6@updateTech

; 6301 : 					{
; 6302 : 						CvAssertMsg(iI != GetID(), "iI is not expected to be equal with GetID()");
; 6303 : 						iCount++;

	inc	ebx
$LN6@updateTech:

; 6293 : 
; 6294 : 		for(iI = 0; iI < MAX_CIV_TEAMS; iI++)

	add	esi, 2984				; 00000ba8H
	inc	edi
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL65@updateTech
	pop	edi

; 6304 : 					}
; 6305 : 				}
; 6306 : 			}
; 6307 : 		}
; 6308 : 
; 6309 : 		if(iCount >= iBestShare)

	cmp	ebx, ebp
	pop	ebx
	jl	SHORT $LN66@updateTech

; 6310 : 		{
; 6311 : 			setHasTech(eTech, true, NO_PLAYER, true, true);

	mov	ecx, DWORD PTR _eTech$[esp+16]
	push	1
	push	1
	push	-1
	push	1
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+40]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN66@updateTech:
	pop	ebp
$LN1@updateTech:
	pop	esi

; 6312 : 		}
; 6313 : 	}
; 6314 : }

	add	esp, 12					; 0000000cH
	ret	4
?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z ENDP	; CvTeam::updateTechShare
_TEXT	ENDS
PUBLIC	?updateTechShare@CvTeam@@IAEXXZ			; CvTeam::updateTechShare
; Function compile flags: /Ogtpy
;	COMDAT ?updateTechShare@CvTeam@@IAEXXZ
_TEXT	SEGMENT
?updateTechShare@CvTeam@@IAEXXZ PROC			; CvTeam::updateTechShare, COMDAT
; _this$ = ecx

; 6319 : {

	push	esi
	push	edi
	mov	edi, ecx

; 6320 : #ifdef AUI_WARNING_FIXES
; 6321 : 	uint iI;
; 6322 : #else
; 6323 : 	int iI;
; 6324 : #endif
; 6325 : 
; 6326 : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN1@updateTech@2
$LL3@updateTech@2:

; 6327 : 	{
; 6328 : 		updateTechShare((TechTypes)iI);

	push	esi
	mov	ecx, edi
	call	?updateTechShare@CvTeam@@IAEXW4TechTypes@@@Z ; CvTeam::updateTechShare
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	SHORT $LL3@updateTech@2
$LN1@updateTech@2:
	pop	edi
	pop	esi

; 6329 : 	}
; 6330 : }

	ret	0
?updateTechShare@CvTeam@@IAEXXZ ENDP			; CvTeam::updateTechShare
_TEXT	ENDS
PUBLIC	?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::pop_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC ; std::vector<int,std::allocator<int> >::pop_back, COMDAT
; _this$ = ecx

; 842  : 		if (!empty())

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, eax
	sub	edx, DWORD PTR [ecx+4]
	test	edx, -4					; fffffffcH
	je	SHORT $LN1@pop_back

; 843  : 			{	// erase last element
; 844  : 			_Destroy(_Mylast - 1, _Mylast);
; 845  : 			--_Mylast;

	add	eax, -4					; fffffffcH
	mov	DWORD PTR [ecx+8], eax
$LN1@pop_back:

; 846  : 			}
; 847  : 		}

	ret	0
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP ; std::vector<int,std::allocator<int> >::pop_back
_TEXT	ENDS
PUBLIC	??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z PROC ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+264], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAEIABW4PlayerTypes@@@Z ENDP ; FStaticVector<enum PlayerTypes,63,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::CvWeightedVector<enum TeamTypes,63,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::CvWeightedVector<enum TeamTypes,63,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 63			; 0000003fH
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::CvWeightedVector<enum TeamTypes,63,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z PROC ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+516], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc, COMDAT
; _this$ = ecx

; 97   : 	{

	push	ebx
	push	esi
	push	edi

; 98   : 		unsigned int nArrayBytes = sizeof(TYPE*) * (pData->nX + 1);

	mov	edi, DWORD PTR _pData$[esp+8]
	mov	eax, DWORD PTR [edi+4]

; 99   : 		unsigned int nDataBytes = sizeof(TYPE) * pData->nX * ( pData->nY + 1 );

	mov	esi, DWORD PTR [edi+8]
	inc	esi
	imul	esi, eax
	lea	ebx, DWORD PTR [eax*4+4]
	add	esi, esi
	add	esi, esi

; 100  : 		void* pRet = BASE::Alloc( nBytes + nDataBytes + nArrayBytes, pData+1 );

	lea	eax, DWORD PTR [edi+12]

; 101  : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet );
; 102  : 
; 103  : 		unsigned int iDataAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart -= nDataBytes) % sizeof(TYPE);

	lea	edx, DWORD PTR [esi+ebx]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > >::Alloc
	sub	eax, esi
	mov	edx, eax
	and	edx, 3

; 104  : 		TYPE* pFirstElement = (TYPE*)( pLocMemStart + iDataAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx

; 105  : 
; 106  : 		unsigned int iArrayAlignmentFix = sizeof(TYPE*) - reinterpret_cast< unsigned int >(pLocMemStart -= nArrayBytes) % sizeof(TYPE*);

	sub	eax, ebx
	mov	edx, eax
	and	edx, 3

; 107  : 		TYPE** ppArray = (*static_cast< TYPE*** >(pData->pOut)) = (TYPE**)( pLocMemStart + iArrayAlignmentFix );

	mov	esi, eax
	sub	esi, edx
	mov	edx, DWORD PTR [edi]
	add	esi, 4
	mov	DWORD PTR [edx], esi
	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edx]

; 108  : 
; 109  : 		for( unsigned int i = 0; i < pData->nX; ++i )

	xor	edx, edx
	add	ecx, 4
	cmp	DWORD PTR [edi+4], edx
	jbe	SHORT $LN1@Alloc@5
	npad	8
$LL3@Alloc@5:

; 110  : 		{
; 111  : 			*ppArray = pFirstElement + i * pData->nY;

	mov	ebx, DWORD PTR [edi+8]
	imul	ebx, edx
	lea	ebx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [esi], ebx
	inc	edx

; 112  : 			++ppArray;

	add	esi, 4
	cmp	edx, DWORD PTR [edi+4]
	jb	SHORT $LL3@Alloc@5
$LN1@Alloc@5:
	pop	edi
	pop	esi
	pop	ebx

; 113  : 		}
; 114  : 
; 115  : 		return static_cast< void* >( pLocMemStart );
; 116  : 	}

	ret	8
?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc
_TEXT	ENDS
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR _func$[esp-4]
	mov	edx, DWORD PTR _x$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx

; 2032 : }

	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum ResourceTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@0AAV?$allocator@W4ResourceTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@std@@@Z
_TEXT	SEGMENT
$T241474 = -4						; size = 1
__Cat$241478 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241474[esp+4], 0
	mov	eax, DWORD PTR $T241474[esp+4]
	mov	ecx, DWORD PTR __Cat$241478[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__Tmp$241587 = -24					; size = 8
__Tmp$241516 = -16					; size = 8
__Tmp$241542 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Median<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$241516[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$241516[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$241542[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$241542[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$241587[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$241587[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$241587[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$241587[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241699 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241703 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$241703[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241699[esp+4], 0
	mov	eax, DWORD PTR $T241699[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::pop_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@2
	pop	esi
$LN9@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::~FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::~FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::~FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >
_TEXT	ENDS
PUBLIC	?DoBarbarianTech@CvTeam@@QAEXXZ			; CvTeam::DoBarbarianTech
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?DoBarbarianTech@CvTeam@@QAEXXZ
_TEXT	SEGMENT
$T241997 = -8						; size = 4
$T241998 = -4						; size = 4
_iTeamsNeeded$ = -4					; size = 4
?DoBarbarianTech@CvTeam@@QAEXXZ PROC			; CvTeam::DoBarbarianTech, COMDAT
; _this$ = ecx

; 885  : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 886  : 	int iCount;
; 887  : 
; 888  : 	TechTypes eTech;
; 889  : 	TeamTypes eTeam;
; 890  : 
; 891  : 	int iPossibleCount = 0;

	xor	edi, edi
	mov	ebp, ecx
	xor	esi, esi
	npad	4
$LL16@DoBarbaria:

; 896  : 	{
; 897  : 		eTeam = (TeamTypes) iTeamLoop;
; 898  : 
; 899  : 		if(GET_TEAM(eTeam).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN15@DoBarbaria

; 900  : 		{
; 901  : 			if(!GET_TEAM(eTeam).isMinorCiv())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN15@DoBarbaria

; 902  : 			{
; 903  : 				iPossibleCount++;

	inc	edi
$LN15@DoBarbaria:

; 892  : 
; 893  : 	// See how many majors are still around
; 894  : 	int iTeamLoop;
; 895  : 	for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	esi, 2984				; 00000ba8H
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL16@DoBarbaria

; 904  : 			}
; 905  : 		}
; 906  : 	}
; 907  : 
; 908  : 	CvAssertMsg(iPossibleCount > 0, "Zero possible players? Uhhh...");
; 909  : 
; 910  : 	// 75% of majors (rounded down) need the tech for the Barbs to get it
; 911  : 	int iTechPercent = /*75*/ GC.getBARBARIAN_TECH_PERCENT();
; 912  : 	int iTeamsNeeded = max(1, iPossibleCount * iTechPercent / 100);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7092
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR $T241997[esp+20], eax
	cmp	eax, 1
	mov	DWORD PTR $T241998[esp+20], 1
	lea	eax, DWORD PTR $T241997[esp+20]
	jg	SHORT $LN30@DoBarbaria
	lea	eax, DWORD PTR $T241998[esp+20]
$LN30@DoBarbaria:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iTeamsNeeded$[esp+20], ecx

; 913  : 
; 914  : #ifdef AUI_WARNING_FIXES
; 915  : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 916  : #else
; 917  : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	$LN9@DoBarbaria
	push	ebx
	npad	11
$LL52@DoBarbaria:

; 918  : #endif
; 919  : 	{
; 920  : 		eTech = (TechTypes) iTechLoop;
; 921  : 
; 922  : 		if(!GetTeamTechs()->HasTech(eTech))

	mov	ecx, DWORD PTR [ebp+2980]
	push	edi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	SHORT $LN10@DoBarbaria

; 923  : 		{
; 924  : 			iCount = 0;

	xor	ebx, ebx
	xor	esi, esi
	npad	12
$LL53@DoBarbaria:

; 927  : 			{
; 928  : 				eTeam = (TeamTypes) iTeamLoop;
; 929  : 
; 930  : 				if(GET_TEAM(eTeam).isAlive())

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+edx+12], 0
	lea	ecx, DWORD PTR [esi+edx]
	jle	SHORT $LN6@DoBarbaria

; 931  : 				{
; 932  : 					// Only look at Majors, as the City States will lag behind
; 933  : 					if(!GET_TEAM(eTeam).isMinorCiv())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN6@DoBarbaria

; 934  : 					{
; 935  : 						if(GET_TEAM(eTeam).GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [esi+eax+2980]
	push	edi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN6@DoBarbaria

; 936  : 						{
; 937  : 							iCount++;

	inc	ebx
$LN6@DoBarbaria:

; 925  : 
; 926  : 			for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	esi, 2984				; 00000ba8H
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL53@DoBarbaria

; 938  : 						}
; 939  : 					}
; 940  : 				}
; 941  : 			}
; 942  : 
; 943  : 			// Do enough majors have this tech?
; 944  : 			if(iCount >= iTeamsNeeded)

	cmp	ebx, DWORD PTR _iTeamsNeeded$[esp+24]
	jl	SHORT $LN10@DoBarbaria

; 945  : 			{
; 946  : 				setHasTech(eTech, true, getLeaderID(), false, false);

	push	0
	push	0
	mov	ecx, ebp
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	1
	push	edi
	mov	ecx, ebp
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN10@DoBarbaria:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	edi, eax
	jl	$LL52@DoBarbaria
	pop	ebx
$LN9@DoBarbaria:
	pop	edi
	pop	esi
	pop	ebp

; 947  : 			}
; 948  : 		}
; 949  : 	}
; 950  : }

	add	esp, 8
	ret	0
?DoBarbarianTech@CvTeam@@QAEXXZ ENDP			; CvTeam::DoBarbarianTech
_TEXT	ENDS
PUBLIC	?DoMinorCivTech@CvTeam@@QAEXXZ			; CvTeam::DoMinorCivTech
; Function compile flags: /Ogtpy
;	COMDAT ?DoMinorCivTech@CvTeam@@QAEXXZ
_TEXT	SEGMENT
$T242057 = -8						; size = 4
$T242058 = -4						; size = 4
_iTeamsNeeded$ = -4					; size = 4
?DoMinorCivTech@CvTeam@@QAEXXZ PROC			; CvTeam::DoMinorCivTech, COMDAT
; _this$ = ecx

; 955  : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 956  : 	int iCount;
; 957  : 
; 958  : 	TechTypes eTech;
; 959  : 	TeamTypes eTeam;
; 960  : 
; 961  : 	int iPossibleCount = 0;

	xor	edi, edi
	mov	ebp, ecx
	xor	esi, esi
	npad	4
$LL16@DoMinorCiv:

; 966  : 	{
; 967  : 		eTeam = (TeamTypes) iTeamLoop;
; 968  : 
; 969  : 		if(GET_TEAM(eTeam).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+eax+12], 0
	lea	ecx, DWORD PTR [esi+eax]
	jle	SHORT $LN15@DoMinorCiv

; 970  : 		{
; 971  : 			if(!GET_TEAM(eTeam).isMinorCiv())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN15@DoMinorCiv

; 972  : 			{
; 973  : 				iPossibleCount++;

	inc	edi
$LN15@DoMinorCiv:

; 962  : 
; 963  : 	// See how many majors are still around
; 964  : 	int iTeamLoop;
; 965  : 	for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	esi, 2984				; 00000ba8H
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL16@DoMinorCiv

; 974  : 			}
; 975  : 		}
; 976  : 	}
; 977  : 
; 978  : 	CvAssertMsg(iPossibleCount > 0, "Zero possible players? Uhhh...");
; 979  : 
; 980  : 	// 40% of majors (rounded down) need the tech for the Minors to get it
; 981  : 	int iTechPercent = /*40*/ GC.getMINOR_CIV_TECH_PERCENT();
; 982  : 	int iTeamsNeeded = max(1, iPossibleCount * iTechPercent / 100);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7300
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR $T242057[esp+20], eax
	cmp	eax, 1
	mov	DWORD PTR $T242058[esp+20], 1
	lea	eax, DWORD PTR $T242057[esp+20]
	jg	SHORT $LN30@DoMinorCiv
	lea	eax, DWORD PTR $T242058[esp+20]
$LN30@DoMinorCiv:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iTeamsNeeded$[esp+20], ecx

; 983  : 
; 984  : #ifdef AUI_WARNING_FIXES
; 985  : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 986  : #else
; 987  : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	$LN9@DoMinorCiv
	push	ebx
	npad	11
$LL52@DoMinorCiv:

; 988  : #endif
; 989  : 	{
; 990  : 		eTech = (TechTypes) iTechLoop;
; 991  : 
; 992  : 		if(!GetTeamTechs()->HasTech(eTech))

	mov	ecx, DWORD PTR [ebp+2980]
	push	edi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	SHORT $LN10@DoMinorCiv

; 993  : 		{
; 994  : 			iCount = 0;

	xor	ebx, ebx
	xor	esi, esi
	npad	12
$LL53@DoMinorCiv:

; 997  : 			{
; 998  : 				eTeam = (TeamTypes) iTeamLoop;
; 999  : 
; 1000 : 				if(GET_TEAM(eTeam).isAlive())

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [esi+edx+12], 0
	lea	ecx, DWORD PTR [esi+edx]
	jle	SHORT $LN6@DoMinorCiv

; 1001 : 				{
; 1002 : 					// Only look at Majors
; 1003 : 					if(!GET_TEAM(eTeam).isMinorCiv())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN6@DoMinorCiv

; 1004 : 					{
; 1005 : 						if(GET_TEAM(eTeam).GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [esi+eax+2980]
	push	edi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN6@DoMinorCiv

; 1006 : 						{
; 1007 : 							iCount++;

	inc	ebx
$LN6@DoMinorCiv:

; 995  : 
; 996  : 			for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	esi, 2984				; 00000ba8H
	cmp	esi, 187992				; 0002de58H
	jl	SHORT $LL53@DoMinorCiv

; 1008 : 						}
; 1009 : 					}
; 1010 : 				}
; 1011 : 			}
; 1012 : 
; 1013 : 			// Do enough majors have this tech?
; 1014 : 			if(iCount >= iTeamsNeeded)

	cmp	ebx, DWORD PTR _iTeamsNeeded$[esp+24]
	jl	SHORT $LN10@DoMinorCiv

; 1015 : 			{
; 1016 : 				setHasTech(eTech, true, getLeaderID(), false, false);

	push	0
	push	0
	mov	ecx, ebp
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	1
	push	edi
	mov	ecx, ebp
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN10@DoMinorCiv:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	edi, eax
	jl	$LL52@DoMinorCiv
	pop	ebx
$LN9@DoMinorCiv:
	pop	edi
	pop	esi
	pop	ebp

; 1017 : 			}
; 1018 : 		}
; 1019 : 	}
; 1020 : }

	add	esp, 8
	ret	0
?DoMinorCivTech@CvTeam@@QAEXXZ ENDP			; CvTeam::DoMinorCivTech
_TEXT	ENDS
PUBLIC	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z	; CvTeam::DoDeclareWar
PUBLIC	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsFriends
EXTRN	?IsNoMinorDOWIfFriends@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::IsNoMinorDOWIfFriends
EXTRN	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsAllies
EXTRN	?UpdateReligion@CvPlayer@@QAEXXZ:PROC		; CvPlayer::UpdateReligion
EXTRN	?SetDangerPlotsDirty@CvPlayer@@QAEXXZ:PROC	; CvPlayer::SetDangerPlotsDirty
EXTRN	?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMinorCivAI::DoNowPeaceWithTeam
EXTRN	?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMinorCivAI::DoNowAtWarWithTeam
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$11
	DD	09H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$13
	DD	09H
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$15
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv2427 = -756						; size = 4
_iMinorCivLoop$224220 = -752				; size = 4
_this$ = -748						; size = 4
_iPlayerCivLoop$224066 = -744				; size = 4
$T242126 = -740						; size = 28
$T242123 = -740						; size = 28
$T242122 = -740						; size = 28
$T242119 = -740						; size = 28
_strTheirEnemiesMessage$224256 = -712			; size = 28
_strOurAlliesMessage$224248 = -684			; size = 28
$T242128 = -656						; size = 28
$T242125 = -656						; size = 28
_strTemp$224240 = -628					; size = 80
$T242124 = -548						; size = 80
$T242120 = -548						; size = 80
$T242117 = -548						; size = 80
_veMinorAllies$224219 = -468				; size = 268
$T242127 = -200						; size = 28
_strOurAlliesSummary$224241 = -172			; size = 80
_strTheirEnemiesSummary$224249 = -92			; size = 80
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bWar$ = 12						; size = 1
?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z PROC	; CvTeam::DoNowAtWarOrPeace, COMDAT
; _this$ = ecx

; 1490 : {

	push	-1
	push	__ehhandler$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 744				; 000002e8H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+768], edi

; 1491 : 	// Major is at war with a minor
; 1492 : 	if(isMinorCiv())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	mov	bl, BYTE PTR _bWar$[esp+764]
	test	al, al
	je	SHORT $LN760@DoNowAtWar

; 1493 : 	{
; 1494 : 		PlayerTypes eMinor;
; 1495 : 		for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	esi, 1391192				; 00153a58H
	npad	7
$LL35@DoNowAtWar:

; 1496 : 		{
; 1497 : 			eMinor = (PlayerTypes) iMinorCivLoop;
; 1498 : 
; 1499 : 			if(GET_PLAYER(eMinor).getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN61@DoNowAtWar
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN62@DoNowAtWar
$LN61@DoNowAtWar:
	or	eax, -1
$LN62@DoNowAtWar:
	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN34@DoNowAtWar

; 1500 : 			{
; 1501 : 				if(GET_PLAYER(eMinor).isAlive())

	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN34@DoNowAtWar

; 1502 : 				{
; 1503 : 					if(bWar)

	test	bl, bl
	je	SHORT $LN30@DoNowAtWar

; 1504 : 						GET_PLAYER(eMinor).GetMinorCivAI()->DoNowAtWarWithTeam(eTeam);

	mov	eax, DWORD PTR _eTeam$[esp+764]
	push	eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoNowAtWarWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoNowAtWarWithTeam

; 1505 : 					else

	jmp	SHORT $LN34@DoNowAtWar
$LN30@DoNowAtWar:

; 1506 : 						GET_PLAYER(eMinor).GetMinorCivAI()->DoNowPeaceWithTeam(eTeam);

	mov	edx, DWORD PTR _eTeam$[esp+764]
	push	edx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoNowPeaceWithTeam@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoNowPeaceWithTeam
$LN34@DoNowAtWar:
	add	esi, 63236				; 0000f704H
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL35@DoNowAtWar
$LN760@DoNowAtWar:

; 1507 : 				}
; 1508 : 			}
; 1509 : 		}
; 1510 : 	}
; 1511 : 
; 1512 : 	if(bWar)

	test	bl, bl
	je	$LN25@DoNowAtWar

; 1513 : 	{
; 1514 : 		PlayerTypes eMinor;
; 1515 : 		PlayerTypes ePlayer;
; 1516 : 
; 1517 : 		// Loop through players on this team
; 1518 : 		for(int iPlayerCivLoop = 0; iPlayerCivLoop < MAX_MAJOR_CIVS; iPlayerCivLoop++)

	xor	ebx, ebx
	xor	esi, esi
	push	ebp
	mov	DWORD PTR _iPlayerCivLoop$224066[esp+772], ebx
	mov	DWORD PTR tv2427[esp+772], esi
	jmp	SHORT $LN27@DoNowAtWar
	npad	14
$LL772@DoNowAtWar:
	xor	ebx, ebx
$LN27@DoNowAtWar:

; 1519 : 		{
; 1520 : 			ePlayer = (PlayerTypes) iPlayerCivLoop;
; 1521 : 
; 1522 : 			if(!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	$LN26@DoNowAtWar

; 1523 : 				continue;
; 1524 : 
; 1525 : 			if(GET_PLAYER(ePlayer).getTeam() != GetID())

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN90@DoNowAtWar
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN91@DoNowAtWar
$LN90@DoNowAtWar:
	or	eax, -1
$LN91@DoNowAtWar:
	cmp	eax, DWORD PTR [edi+4]
	jne	$LN26@DoNowAtWar

; 1526 : 				continue;
; 1527 : 
; 1528 : 			GET_PLAYER(ePlayer).SetDangerPlotsDirty();

	call	?SetDangerPlotsDirty@CvPlayer@@QAEXXZ	; CvPlayer::SetDangerPlotsDirty

; 1529 : 			GET_PLAYER(ePlayer).UpdateReligion();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?UpdateReligion@CvPlayer@@QAEXXZ	; CvPlayer::UpdateReligion

; 1530 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 1531 : 			GET_PLAYER(ePlayer).doSelfConsistencyCheckAllCities();
; 1532 : #endif
; 1533 : 
; 1534 : 			// ******************************
; 1535 : 			// Our minor civ allies declare war on eTeam
; 1536 : 			// ******************************
; 1537 : 
; 1538 : 			FStaticVector<PlayerTypes, MAX_CIV_PLAYERS, true, c_eCiv5GameplayDLL, 0> veMinorAllies;

	lea	ecx, DWORD PTR _veMinorAllies$224219[esp+784]
	mov	DWORD PTR _veMinorAllies$224219[esp+776], ebx
	mov	DWORD PTR _veMinorAllies$224219[esp+780], 63 ; 0000003fH
	mov	DWORD PTR _veMinorAllies$224219[esp+772], ecx
	mov	DWORD PTR __$EHRec$[esp+780], ebx

; 1539 : 			for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	DWORD PTR _iMinorCivLoop$224220[esp+772], 22 ; 00000016H
	mov	ebp, 1391192				; 00153a58H
$LL769@DoNowAtWar:

; 1540 : 			{
; 1541 : 				eMinor = (PlayerTypes) iMinorCivLoop;
; 1542 : 
; 1543 : 				// Must be alive
; 1544 : 				if(!GET_PLAYER(eMinor).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edx+ebp+2256], 0
	lea	ecx, DWORD PTR [edx+ebp]
	je	$LN21@DoNowAtWar

; 1545 : 					continue;
; 1546 : 
; 1547 : 				if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(ePlayer))

	mov	eax, DWORD PTR _iPlayerCivLoop$224066[esp+772]
	push	eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAllies
	test	al, al
	je	$LN21@DoNowAtWar

; 1548 : 				{
; 1549 : 					// Don't declare war on self! (just in case)
; 1550 : 					if(GET_PLAYER(eMinor).getTeam() != eTeam)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN123@DoNowAtWar
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN124@DoNowAtWar
$LN123@DoNowAtWar:
	or	eax, -1
$LN124@DoNowAtWar:
	cmp	eax, DWORD PTR _eTeam$[esp+768]
	je	$LN21@DoNowAtWar

; 1551 : 					{
; 1552 : #ifdef NQ_POLICY_TOGGLE_NO_MINOR_DOW_IF_FRIENDS
; 1553 : 						// this = team that declared war
; 1554 : 						// eTeam = team that is targeted for war
; 1555 : 						// ePlayer = current position of iterator over every major civ in the game on this team
; 1556 : 						// eMinor = current position of iterator over every city state in the game
; 1557 : 
; 1558 : 						bool bFriendshipPreventsWar = false;

	xor	bl, bl

; 1559 : 						PlayerTypes eTargetPlayer;
; 1560 : 						for (int iTargetTeamCivLoop = 0; iTargetTeamCivLoop < MAX_MAJOR_CIVS; iTargetTeamCivLoop++)

	xor	esi, esi
	xor	edi, edi
	npad	13
$LL770@DoNowAtWar:

; 1561 : 						{
; 1562 : 							eTargetPlayer = (PlayerTypes) iTargetTeamCivLoop;
; 1563 : 
; 1564 : 							if(GET_PLAYER(eTargetPlayer).isAlive() && GET_PLAYER(eTargetPlayer).getTeam() == eTeam)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+edx+2256], 0
	lea	ecx, DWORD PTR [edi+edx]
	je	SHORT $LN15@DoNowAtWar
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN140@DoNowAtWar
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN141@DoNowAtWar
$LN140@DoNowAtWar:
	or	eax, -1
$LN141@DoNowAtWar:
	cmp	eax, DWORD PTR _eTeam$[esp+768]
	jne	SHORT $LN15@DoNowAtWar

; 1565 : 							{
; 1566 : 								if (GET_PLAYER(eTargetPlayer).IsNoMinorDOWIfFriends() && GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(eTargetPlayer))

	call	?IsNoMinorDOWIfFriends@CvPlayer@@QBE_NXZ ; CvPlayer::IsNoMinorDOWIfFriends
	test	al, al
	je	SHORT $LN15@DoNowAtWar
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+ebp]
	push	esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN15@DoNowAtWar

; 1567 : 								{
; 1568 : 									bFriendshipPreventsWar = true;

	mov	bl, 1
$LN15@DoNowAtWar:

; 1559 : 						PlayerTypes eTargetPlayer;
; 1560 : 						for (int iTargetTeamCivLoop = 0; iTargetTeamCivLoop < MAX_MAJOR_CIVS; iTargetTeamCivLoop++)

	add	edi, 63236				; 0000f704H
	inc	esi
	cmp	edi, 1391192				; 00153a58H
	jl	SHORT $LL770@DoNowAtWar

; 1569 : 								}
; 1570 : 							}
; 1571 : 						}
; 1572 : 
; 1573 : 						if (!bFriendshipPreventsWar)

	test	bl, bl
	jne	$LN21@DoNowAtWar

; 1574 : 						{
; 1575 : 							// Match war state
; 1576 : 							GET_TEAM(GET_PLAYER(eMinor).getTeam()).DoDeclareWar(eTeam, /*bDefensivePact*/ false, /*bMinorAllyPact*/ true);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN155@DoNowAtWar
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN156@DoNowAtWar
$LN155@DoNowAtWar:
	or	ecx, -1
$LN156@DoNowAtWar:
	mov	edx, DWORD PTR _eTeam$[esp+768]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	0
	push	edx
	call	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoDeclareWar

; 1577 : 
; 1578 : 							// Add to vector for notification sent out
; 1579 : 							veMinorAllies.push_back(eMinor);

	mov	eax, DWORD PTR _veMinorAllies$224219[esp+780]
	mov	BYTE PTR _veMinorAllies$224219[esp+1036], 0
	cmp	DWORD PTR _veMinorAllies$224219[esp+776], eax
	jne	SHORT $LN634@DoNowAtWar
	push	eax
	lea	ecx, DWORD PTR _veMinorAllies$224219[esp+776]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
$LN634@DoNowAtWar:
	mov	eax, DWORD PTR _veMinorAllies$224219[esp+776]
	mov	ecx, DWORD PTR _veMinorAllies$224219[esp+772]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN637@DoNowAtWar
	mov	edx, DWORD PTR _iMinorCivLoop$224220[esp+772]
	mov	DWORD PTR [eax], edx
$LN637@DoNowAtWar:
	inc	DWORD PTR _veMinorAllies$224219[esp+776]
$LN21@DoNowAtWar:

; 1539 : 			for(int iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	inc	DWORD PTR _iMinorCivLoop$224220[esp+772]
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 3983868				; 003cc9fcH
	jl	$LL769@DoNowAtWar

; 1580 : 						}
; 1581 : 					
; 1582 : #else
; 1583 : 						// Match war state
; 1584 : 						GET_TEAM(GET_PLAYER(eMinor).getTeam()).DoDeclareWar(eTeam, /*bDefensivePact*/ false, /*bMinorAllyPact*/ true);
; 1585 : 
; 1586 : 						// Add to vector for notification sent out
; 1587 : 						veMinorAllies.push_back(eMinor);
; 1588 : #endif
; 1589 : 					}
; 1590 : 				}
; 1591 : 			}
; 1592 : 
; 1593 : 			// Notifications about minor allies that join the war against a major civ
; 1594 : 			if(!veMinorAllies.empty())

	cmp	DWORD PTR _veMinorAllies$224219[esp+776], 0
	je	$LN764@DoNowAtWar

; 1595 : 			{
; 1596 : 				if(!GET_TEAM(eTeam).isMinorCiv())

	mov	ebp, DWORD PTR _eTeam$[esp+768]
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	ebp, 2984				; 00000ba8H
	lea	ecx, DWORD PTR [eax+ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	$LN764@DoNowAtWar

; 1597 : 				{
; 1598 : 					Localization::String strTemp;

	lea	ecx, DWORD PTR _strTemp$224240[esp+772]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 1599 : 
; 1600 : 					// Notification for us...allies got our back!
; 1601 : 					Localization::String strOurAlliesSummary = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_DECLARED_WAR_SUMMARY");

	mov	edi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _strOurAlliesSummary$224241[esp+772]
	push	OFFSET $SG224243
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+788], 1
	call	edi

; 1602 : 					strTemp = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_DECLARED_WAR");

	lea	edx, DWORD PTR $T242117[esp+780]
	push	OFFSET $SG224245
	push	edx
	mov	BYTE PTR __$EHRec$[esp+796], 2
	call	edi
	add	esp, 16					; 00000010H
	mov	ebx, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	push	eax
	lea	ecx, DWORD PTR _strTemp$224240[esp+776]
	mov	BYTE PTR __$EHRec$[esp+784], 3
	call	ebx
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T242117[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 2
	call	esi

; 1603 : 					strTemp << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	edx, DWORD PTR $T242119[esp+772]
	lea	ecx, DWORD PTR [eax+ebp]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+780], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$224240[esp+776]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	lea	ecx, DWORD PTR $T242119[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1604 : 					CvString strOurAlliesMessage = strTemp.toUTF8();

	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _strTemp$224240[esp+772]
	call	ebp
	test	eax, eax
	jne	SHORT $LN659@DoNowAtWar
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN659@DoNowAtWar:
	push	eax
	lea	ecx, DWORD PTR _strOurAlliesMessage$224248[esp+776]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1605 : 
; 1606 : 					// Notification for players on the other team
; 1607 : 					Localization::String strTheirEnemiesSummary = Localization::Lookup("TXT_KEY_MISC_MINOR_ALLIES_DECLARED_WAR_ON_YOU_SUMMARY");

	lea	eax, DWORD PTR _strTheirEnemiesSummary$224249[esp+772]
	push	OFFSET $SG224251
	push	eax
	mov	BYTE PTR __$EHRec$[esp+788], 5
	call	edi

; 1608 : 					strTemp = Localization::Lookup("TXT_KEY_MISC_MINOR_ALLIES_DECLARED_WAR_ON_YOU");

	lea	ecx, DWORD PTR $T242120[esp+780]
	push	OFFSET $SG224253
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+796], 6
	call	edi
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strTemp$224240[esp+776]
	mov	BYTE PTR __$EHRec$[esp+784], 7
	call	ebx
	lea	ecx, DWORD PTR $T242120[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 6
	call	esi

; 1609 : 					strTemp << getName().GetCString();

	mov	ecx, DWORD PTR _this$[esp+772]
	lea	edx, DWORD PTR $T242122[esp+772]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+780], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$224240[esp+776]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	lea	ecx, DWORD PTR $T242122[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1610 : 					CvString strTheirEnemiesMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$224240[esp+772]
	call	ebp
	test	eax, eax
	jne	SHORT $LN671@DoNowAtWar
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN671@DoNowAtWar:
	push	eax
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$224256[esp+776]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1611 : 
; 1612 : 					for(uint iMinorCivLoop = 0; iMinorCivLoop < veMinorAllies.size(); iMinorCivLoop++)

	xor	esi, esi
	mov	BYTE PTR __$EHRec$[esp+780], 9
	cmp	DWORD PTR _veMinorAllies$224219[esp+776], esi
	jbe	$LN6@DoNowAtWar
	jmp	SHORT $LN8@DoNowAtWar
	npad	6
$LL766@DoNowAtWar:
	mov	edi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	mov	ebx, DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
$LN8@DoNowAtWar:

; 1613 : 					{
; 1614 : 						eMinor = veMinorAllies[iMinorCivLoop];

	mov	eax, DWORD PTR _veMinorAllies$224219[esp+772]
	mov	eax, DWORD PTR [eax+esi*4]

; 1615 : 						strTemp = Localization::Lookup(GET_TEAM(GET_PLAYER(eMinor).getTeam()).getName().GetCString());

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN683@DoNowAtWar
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN684@DoNowAtWar
$LN683@DoNowAtWar:
	or	eax, -1
$LN684@DoNowAtWar:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR $T242123[esp+772]
	push	ecx
	mov	ecx, eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+780], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR $T242124[esp+776]
	push	edx
	call	edi
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strTemp$224240[esp+776]
	mov	BYTE PTR __$EHRec$[esp+784], 11		; 0000000bH
	call	ebx
	lea	ecx, DWORD PTR $T242124[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 10		; 0000000aH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T242123[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1616 : 						strOurAlliesMessage = strOurAlliesMessage + "[NEWLINE]" + strTemp.toUTF8();

	mov	ebx, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG224265
	lea	eax, DWORD PTR _strOurAlliesMessage$224248[esp+776]
	push	eax
	lea	ecx, DWORD PTR $T242125[esp+780]
	push	ecx
	call	ebx
	add	esp, 12					; 0000000cH
	mov	edi, eax
	lea	ecx, DWORD PTR _strTemp$224240[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 12		; 0000000cH
	call	ebp
	push	eax
	lea	edx, DWORD PTR $T242126[esp+776]
	push	edi
	push	edx
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+780], 13		; 0000000dH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOurAlliesMessage$224248[esp+776]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T242126[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 12		; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T242125[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1617 : 						strTheirEnemiesMessage = strTheirEnemiesMessage + "[NEWLINE]" + strTemp.toUTF8();

	push	OFFSET $SG224268
	lea	eax, DWORD PTR _strTheirEnemiesMessage$224256[esp+776]
	push	eax
	lea	ecx, DWORD PTR $T242127[esp+780]
	push	ecx
	call	ebx
	add	esp, 12					; 0000000cH
	mov	edi, eax
	lea	ecx, DWORD PTR _strTemp$224240[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 14		; 0000000eH
	call	ebp
	push	eax
	lea	edx, DWORD PTR $T242128[esp+776]
	push	edi
	push	edx
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+780], 15		; 0000000fH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$224256[esp+776]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T242128[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 14		; 0000000eH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T242127[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	esi
	cmp	esi, DWORD PTR _veMinorAllies$224219[esp+776]
	jb	$LL766@DoNowAtWar
$LN6@DoNowAtWar:

; 1618 : 					}
; 1619 : 
; 1620 : 					GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_WAR, strOurAlliesMessage, strOurAlliesSummary.toUTF8(), -1, -1, veMinorAllies.front(), eTeam);

	mov	esi, DWORD PTR _veMinorAllies$224219[esp+772]
	lea	ecx, DWORD PTR _strOurAlliesMessage$224248[esp+772]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR tv2427[esp+772]
	mov	edx, DWORD PTR _eTeam$[esp+768]
	mov	edi, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ebx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [esi]
	push	edx
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strOurAlliesSummary$224241[esp+788]
	call	ebp
	push	eax
	push	edi
	push	-958154983				; c6e3b719H
	mov	ecx, ebx
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	esi, esi
	npad	4
$LL5@DoNowAtWar:

; 1621 : 
; 1622 : 					for(int iOtherPlayerCivLoop = 0; iOtherPlayerCivLoop < MAX_MAJOR_CIVS; iOtherPlayerCivLoop++)
; 1623 : 					{
; 1624 : 						PlayerTypes eOtherPlayer = (PlayerTypes) iOtherPlayerCivLoop;
; 1625 : 
; 1626 : 						if(!GET_PLAYER(eOtherPlayer).isAlive())

	cmp	BYTE PTR [esi+ecx+2256], 0
	je	SHORT $LN4@DoNowAtWar

; 1627 : 							continue;
; 1628 : 
; 1629 : 						if(GET_PLAYER(eOtherPlayer).getTeam() != eTeam)

	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN717@DoNowAtWar
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN718@DoNowAtWar
$LN717@DoNowAtWar:
	or	eax, -1
$LN718@DoNowAtWar:
	cmp	eax, DWORD PTR _eTeam$[esp+768]
	jne	SHORT $LN4@DoNowAtWar

; 1630 : 							continue;
; 1631 : 
; 1632 : 						GET_PLAYER(eOtherPlayer).GetNotifications()->Add(NOTIFICATION_WAR_ACTIVE_PLAYER, strTheirEnemiesMessage, strTheirEnemiesSummary.toUTF8(), -1, -1, veMinorAllies.front());

	mov	edi, DWORD PTR _veMinorAllies$224219[esp+772]
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$224256[esp+772]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	push	-1
	push	ecx
	mov	ebp, eax
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strTheirEnemiesSummary$224249[esp+788]
	lea	ebx, DWORD PTR [esi+eax]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	ebp
	push	-190211195				; f4a99b85H
	mov	ecx, ebx
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN4@DoNowAtWar:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jl	$LL5@DoNowAtWar

; 1633 : 					}
; 1634 : 
; 1635 : 				}

	lea	ecx, DWORD PTR _strTheirEnemiesMessage$224256[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strTheirEnemiesSummary$224249[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 5
	call	esi
	lea	ecx, DWORD PTR _strOurAlliesMessage$224248[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOurAlliesSummary$224241[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 1
	call	esi
	lea	ecx, DWORD PTR _strTemp$224240[esp+772]
	mov	BYTE PTR __$EHRec$[esp+780], 0
	call	esi
$LN764@DoNowAtWar:

; 1636 : 			}
; 1637 : 		}

	mov	eax, DWORD PTR _veMinorAllies$224219[esp+772]
	lea	edx, DWORD PTR _veMinorAllies$224219[esp+784]
	mov	DWORD PTR __$EHRec$[esp+780], -1
	cmp	eax, edx
	je	SHORT $LN771@DoNowAtWar
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN771@DoNowAtWar:
	mov	esi, DWORD PTR tv2427[esp+772]
	mov	edi, DWORD PTR _this$[esp+772]
$LN26@DoNowAtWar:
	inc	DWORD PTR _iPlayerCivLoop$224066[esp+772]
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv2427[esp+772], esi
	jl	$LL772@DoNowAtWar
	pop	ebp
$LN25@DoNowAtWar:

; 1638 : 	}
; 1639 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+768]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 756				; 000002f4H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _veMinorAllies$224219[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strTemp$224240[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _strOurAlliesSummary$224241[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$3:
	lea	ecx, DWORD PTR $T242117[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$4:
	lea	ecx, DWORD PTR $T242119[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$5:
	lea	ecx, DWORD PTR _strOurAlliesMessage$224248[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$6:
	lea	ecx, DWORD PTR _strTheirEnemiesSummary$224249[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T242120[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T242122[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$9:
	lea	ecx, DWORD PTR _strTheirEnemiesMessage$224256[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$10:
	lea	ecx, DWORD PTR $T242123[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$11:
	lea	ecx, DWORD PTR $T242124[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T242125[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T242126[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T242127[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T242128[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ENDP	; CvTeam::DoNowAtWarOrPeace
PUBLIC	?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z	; CvTeam::DoMakePeace
EXTRN	?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMilitaryAI::LogPeace
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?DoWeMadePeaceWithSomeone@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z:PROC ; CvDiplomacyAI::DoWeMadePeaceWithSomeone
EXTRN	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPermanentWar
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$14
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$15
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$16
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$18
	DD	0bH
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$19
	DD	013H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$20
	DD	014H
	DD	FLAT:__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$21
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
_bPeaceBlocked$224310 = -737				; size = 1
_bResult$224295 = -737					; size = 1
tv2260 = -736						; size = 4
_args$224294 = -736					; size = 4
_this$ = -732						; size = 4
$T243555 = -728						; size = 4
_iPlayerLoop$224305 = -728				; size = 4
$T243557 = -724						; size = 4
_iMinorLoop$224303 = -724				; size = 4
tv1517 = -720						; size = 4
_iThirdPartyLoop$224307 = -716				; size = 4
$T243559 = -712						; size = 28
$T243554 = -712						; size = 28
$T243549 = -712						; size = 28
$T243546 = -712						; size = 28
$T243542 = -712						; size = 28
$T243558 = -684						; size = 28
$T243552 = -684						; size = 28
$T243543 = -684						; size = 28
$T243540 = -684						; size = 28
$T243539 = -684						; size = 28
$T243556 = -656						; size = 28
_strMessage$224347 = -656				; size = 28
_locString$224372 = -628				; size = 80
_strBuffer$ = -548					; size = 28
$T243550 = -520						; size = 80
$T243547 = -520						; size = 80
$T243544 = -520						; size = 80
$T243541 = -520						; size = 80
_strTemp$224339 = -440					; size = 80
_veMinorAllies$224317 = -360				; size = 268
_strSummary$224342 = -92				; size = 80
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bBumpUnits$ = 12					; size = 1
_bSuppressNotification$ = 16				; size = 1
?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z PROC	; CvTeam::DoMakePeace, COMDAT
; _this$ = ecx

; 1650 : {

	push	-1
	push	__ehhandler$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 728				; 000002d8H
	push	ebp
	push	edi
	mov	edi, ecx

; 1651 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+748]
	mov	DWORD PTR _this$[esp+748], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1652 : 	int iI;
; 1653 : 
; 1654 : 	CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 1655 : 	CvAssertMsg(eTeam != GetID(), "eTeam is not expected to be equal with GetID()");
; 1656 : 
; 1657 : 	if(isAtWar(eTeam))

	mov	ebp, DWORD PTR _eTeam$[esp+744]
	mov	al, BYTE PTR [edi+ebp+1928]
	mov	DWORD PTR __$EHRec$[esp+756], 0
	test	al, al
	je	$LN53@DoMakePeac
	push	ebx
	push	esi

; 1658 : 	{
; 1659 : 		setAtWar(eTeam, false);

	mov	BYTE PTR [edi+ebp+1928], 0
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx]
	push	0
	push	ebp
	push	eax
	mov	eax, DWORD PTR [edx+728]
	call	eax

; 1660 : 		GET_TEAM(eTeam).setAtWar(GetID(), false);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, DWORD PTR [edi+4]
	mov	ebx, ebp
	imul	ebx, 2984				; 00000ba8H
	lea	edx, DWORD PTR [ebx+ecx]
	mov	BYTE PTR [eax+edx+1928], 0
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx]
	push	0
	push	eax
	push	edx
	mov	edx, DWORD PTR [esi+728]
	mov	DWORD PTR tv1517[esp+768], ebx
	call	edx

; 1661 : 
; 1662 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, eax

; 1663 : 		if (pkScriptSystem)

	test	esi, esi
	je	SHORT $LN52@DoMakePeac

; 1664 : 		{
; 1665 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$224294[esp+756]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 1666 : 			args->Push(GetID());

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _args$224294[esp+756]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+768], 1
	call	eax

; 1667 : 			args->Push(eTeam);

	mov	ecx, DWORD PTR _args$224294[esp+756]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 1668 : 
; 1669 : 			bool bResult;
; 1670 : 			LuaSupport::CallHook(pkScriptSystem, "MakePeace", args.get(), bResult);

	mov	edx, DWORD PTR _args$224294[esp+756]
	lea	ecx, DWORD PTR _bResult$224295[esp+756]
	push	ecx
	push	edx
	push	OFFSET $SG224296
	push	esi
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1671 : 		}

	lea	ecx, DWORD PTR _args$224294[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN52@DoMakePeac:

; 1672 : 
; 1673 : 		// One shot things
; 1674 : 		DoNowAtWarOrPeace(eTeam, false);

	push	0
	push	ebp
	mov	ecx, edi
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1675 : 		GET_TEAM(eTeam).DoNowAtWarOrPeace(GetID(), false);

	mov	eax, DWORD PTR [edi+4]
	push	0
	push	eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [ebx+eax]
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1676 : 
; 1677 : 		// Move Units that shouldn't be in each others' territory any more
; 1678 : 		if(bBumpUnits)

	cmp	BYTE PTR _bBumpUnits$[esp+752], 0
	je	SHORT $LN51@DoMakePeac

; 1679 : 		{
; 1680 : 			GC.getMap().verifyUnitValidPlot();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot
$LN51@DoMakePeac:

; 1681 : 		}
; 1682 : 
; 1683 : 		// Both of us have now made a peace treaty.  Keep track of this in case either one breaks the agreement
; 1684 : 		int iCurrentTurn = GC.getGame().getElapsedGameTurns();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns

; 1685 : 		SetTurnMadePeaceTreatyWithTeam(eTeam, iCurrentTurn);

	mov	DWORD PTR [edi+ebp*4+1128], eax

; 1686 : 		GET_TEAM(eTeam).SetTurnMadePeaceTreatyWithTeam(GetID(), iCurrentTurn);

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [edi+4]
	add	edx, ebx
	mov	DWORD PTR [edx+ecx*4+1128], eax

; 1687 : 
; 1688 : 		TeamTypes eTeamWeMadePeaceWith = eTeam;
; 1689 : 
; 1690 : 		if(!isMinorCiv())

	mov	ecx, edi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	$LN46@DoMakePeac

; 1691 : 		{
; 1692 : 			// Made peace with a minor - see if we have allied minors which should also make peace
; 1693 : 			if(GET_TEAM(eTeamWeMadePeaceWith).isMinorCiv())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [ebx+eax]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	$LN46@DoMakePeac

; 1694 : 			{
; 1695 : 				PlayerTypes eOurMinor;
; 1696 : 				int iMinorLoop;
; 1697 : 
; 1698 : 				PlayerTypes eOurPlayer;
; 1699 : 				int iPlayerLoop;
; 1700 : 
; 1701 : 				PlayerTypes eThirdParty;
; 1702 : 				int iThirdPartyLoop;
; 1703 : 
; 1704 : 				PlayerTypes eMakingPeaceWithMinor;
; 1705 : 				int iMakingPeaceWithMinorLoop;
; 1706 : 
; 1707 : 				bool bPeaceBlocked;
; 1708 : 
; 1709 : 				// Loop through all players to see if they're on our team
; 1710 : 				for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	eax, eax
	mov	DWORD PTR _iPlayerLoop$224305[esp+756], eax
	mov	DWORD PTR tv2260[esp+756], eax
	npad	5
$LL48@DoMakePeac:

; 1711 : 				{
; 1712 : 					eOurPlayer = (PlayerTypes) iPlayerLoop;
; 1713 : 
; 1714 : 					// Not on this team
; 1715 : 					if(GET_PLAYER(eOurPlayer).getTeam() != GetID())

	mov	eax, DWORD PTR [eax+esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN151@DoMakePeac
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN152@DoMakePeac
$LN151@DoMakePeac:
	or	eax, -1
$LN152@DoMakePeac:
	cmp	eax, DWORD PTR [edi+4]
	jne	$LN47@DoMakePeac

; 1716 : 						continue;
; 1717 : 
; 1718 : 					FStaticVector<PlayerTypes, MAX_CIV_PLAYERS, true, c_eCiv5GameplayDLL, 0> veMinorAllies;

	lea	eax, DWORD PTR _veMinorAllies$224317[esp+768]
	mov	DWORD PTR _veMinorAllies$224317[esp+760], 0
	mov	DWORD PTR _veMinorAllies$224317[esp+764], 63 ; 0000003fH
	mov	DWORD PTR _veMinorAllies$224317[esp+756], eax
	mov	BYTE PTR __$EHRec$[esp+764], 2

; 1719 : 
; 1720 : 					// Loop through minors to see if they're allied with us
; 1721 : 					for(iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)

	mov	DWORD PTR _iMinorLoop$224303[esp+756], 22 ; 00000016H
	mov	ebx, 1391192				; 00153a58H
	npad	4
$LL508@DoMakePeac:

; 1722 : 					{
; 1723 : 						eOurMinor = (PlayerTypes) iMinorLoop;
; 1724 : 
; 1725 : 						// Minor not alive
; 1726 : 						if(!GET_PLAYER(eOurMinor).isAlive())

	cmp	BYTE PTR [ebx+esi+2256], 0
	lea	ecx, DWORD PTR [ebx+esi]
	je	$LN43@DoMakePeac

; 1727 : 							continue;
; 1728 : 
; 1729 : 						// Allied with us
; 1730 : 						if(GET_PLAYER(eOurMinor).GetMinorCivAI()->GetAlly() == eOurPlayer)

	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 1731 : 						{
; 1732 : 							bPeaceBlocked = false;

	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	eax, DWORD PTR _iPlayerLoop$224305[esp+756]
	jne	$LN43@DoMakePeac
	mov	BYTE PTR _bPeaceBlocked$224310[esp+756], 0

; 1733 : 
; 1734 : 							// Now... see if there's another major allied to the minor we just made peace with, which would block OUR allied minor from making peace with him
; 1735 : 							for(iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)

	mov	DWORD PTR _iThirdPartyLoop$224307[esp+756], 0
	mov	ebp, 44					; 0000002cH
	npad	1
$LL39@DoMakePeac:

; 1736 : 							{
; 1737 : 								eThirdParty = (PlayerTypes) iThirdPartyLoop;
; 1738 : 
; 1739 : 								for(iMakingPeaceWithMinorLoop = MAX_MAJOR_CIVS; iMakingPeaceWithMinorLoop < MAX_CIV_PLAYERS; iMakingPeaceWithMinorLoop++)

	mov	edi, 1391192				; 00153a58H
$LL36@DoMakePeac:

; 1740 : 								{
; 1741 : 									eMakingPeaceWithMinor = (PlayerTypes) iMakingPeaceWithMinorLoop;
; 1742 : 
; 1743 : 									// Not on the team we're making peace with
; 1744 : 									if(!GET_PLAYER(eMakingPeaceWithMinor).getTeam() == eTeamWeMadePeaceWith)

	mov	eax, DWORD PTR [edi+esi+44]
	lea	ecx, DWORD PTR [edi+esi]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN180@DoMakePeac
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN181@DoMakePeac
$LN180@DoMakePeac:
	or	eax, -1
$LN181@DoMakePeac:
	xor	edx, edx
	test	eax, eax
	sete	dl
	cmp	edx, DWORD PTR _eTeam$[esp+752]
	je	SHORT $LN35@DoMakePeac

; 1745 : 										continue;
; 1746 : 
; 1747 : 									// Minor not alive
; 1748 : 									if(!GET_PLAYER(eMakingPeaceWithMinor).isAlive())

	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN35@DoMakePeac

; 1749 : 										continue;
; 1750 : 
; 1751 : 									if(GET_PLAYER(eMakingPeaceWithMinor).GetMinorCivAI()->GetAlly() == eThirdParty)

	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 1752 : 									{
; 1753 : 										if(GET_TEAM(GET_PLAYER(eThirdParty).getTeam()).isAtWar(GET_PLAYER(eOurMinor).getTeam()))

	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	eax, DWORD PTR _iThirdPartyLoop$224307[esp+756]
	jne	SHORT $LN35@DoMakePeac
	mov	eax, DWORD PTR [ebx+esi+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN199@DoMakePeac
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN200@DoMakePeac
$LN199@DoMakePeac:
	or	ecx, -1
$LN200@DoMakePeac:
	mov	eax, DWORD PTR [esi+ebp]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN210@DoMakePeac
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN211@DoMakePeac
$LN210@DoMakePeac:
	or	eax, -1
$LN211@DoMakePeac:
	imul	eax, 2984				; 00000ba8H
	add	eax, ecx
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [eax+ecx+1928], 0
	jne	SHORT $LN489@DoMakePeac
$LN35@DoMakePeac:

; 1736 : 							{
; 1737 : 								eThirdParty = (PlayerTypes) iThirdPartyLoop;
; 1738 : 
; 1739 : 								for(iMakingPeaceWithMinorLoop = MAX_MAJOR_CIVS; iMakingPeaceWithMinorLoop < MAX_CIV_PLAYERS; iMakingPeaceWithMinorLoop++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jl	$LL36@DoMakePeac

; 1752 : 									{
; 1753 : 										if(GET_TEAM(GET_PLAYER(eThirdParty).getTeam()).isAtWar(GET_PLAYER(eOurMinor).getTeam()))

	jmp	SHORT $LN38@DoMakePeac
$LN489@DoMakePeac:

; 1754 : 										{
; 1755 : 											bPeaceBlocked = true;

	mov	BYTE PTR _bPeaceBlocked$224310[esp+756], 1
$LN38@DoMakePeac:

; 1733 : 
; 1734 : 							// Now... see if there's another major allied to the minor we just made peace with, which would block OUR allied minor from making peace with him
; 1735 : 							for(iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)

	inc	DWORD PTR _iThirdPartyLoop$224307[esp+756]
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391236				; 00153a84H
	jl	$LL39@DoMakePeac

; 1756 : 											break;
; 1757 : 										}
; 1758 : 									}
; 1759 : 								}
; 1760 : 							}
; 1761 : 
; 1762 : 							// Not at permanent war with this team
; 1763 : 							if(!bPeaceBlocked)

	cmp	BYTE PTR _bPeaceBlocked$224310[esp+756], 0
	jne	$LN43@DoMakePeac

; 1764 : 							{
; 1765 : 								if(!GET_PLAYER(eOurMinor).GetMinorCivAI()->IsPermanentWar(eTeamWeMadePeaceWith))

	lea	ecx, DWORD PTR [ebx+esi]
	mov	esi, DWORD PTR _eTeam$[esp+752]
	push	esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	test	al, al
	jne	$LN498@DoMakePeac

; 1766 : 								{
; 1767 : 									GET_TEAM(GET_PLAYER(eOurMinor).getTeam()).DoMakePeace(eTeamWeMadePeaceWith, /*bBumpUnits*/ true, /*bSuppressNotification*/ true);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ebx+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN229@DoMakePeac
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN230@DoMakePeac
$LN229@DoMakePeac:
	or	ecx, -1
$LN230@DoMakePeac:
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	1
	push	esi
	call	?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoMakePeace

; 1768 : 									veMinorAllies.push_back(eOurMinor);

	mov	eax, DWORD PTR _veMinorAllies$224317[esp+764]
	mov	BYTE PTR _veMinorAllies$224317[esp+1020], 0
	cmp	DWORD PTR _veMinorAllies$224317[esp+760], eax
	jne	SHORT $LN236@DoMakePeac
	push	eax
	lea	ecx, DWORD PTR _veMinorAllies$224317[esp+760]
	call	?GrowSize@?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum PlayerTypes,63,1,297,0>::GrowSize
$LN236@DoMakePeac:
	mov	eax, DWORD PTR _veMinorAllies$224317[esp+760]
	mov	ecx, DWORD PTR _veMinorAllies$224317[esp+756]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN239@DoMakePeac
	mov	edx, DWORD PTR _iMinorLoop$224303[esp+756]
	mov	DWORD PTR [eax], edx
$LN239@DoMakePeac:
	inc	DWORD PTR _veMinorAllies$224317[esp+760]
$LN498@DoMakePeac:
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN43@DoMakePeac:

; 1719 : 
; 1720 : 					// Loop through minors to see if they're allied with us
; 1721 : 					for(iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)

	inc	DWORD PTR _iMinorLoop$224303[esp+756]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 3983868				; 003cc9fcH
	jl	$LL508@DoMakePeac

; 1769 : 								}
; 1770 : 							}
; 1771 : 						}
; 1772 : 					}
; 1773 : 
; 1774 : 					// Send out a notification to us telling which of our minor allies made peace
; 1775 : 					if(!veMinorAllies.empty())

	cmp	DWORD PTR _veMinorAllies$224317[esp+760], 0
	je	$LN27@DoMakePeac

; 1776 : 					{
; 1777 : 						Localization::String strTemp = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_MADE_PEACE");

	mov	esi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR _strTemp$224339[esp+756]
	push	OFFSET $SG224341
	push	eax
	call	esi

; 1778 : 						Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_YOUR_MINOR_ALLIES_MADE_PEACE_SUMMARY");

	lea	ecx, DWORD PTR _strSummary$224342[esp+764]
	push	OFFSET $SG224344
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+780], 3
	call	esi
	add	esp, 16					; 00000010H

; 1779 : 						strTemp << GET_TEAM(eTeam).getName().GetCString();

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, DWORD PTR tv1517[esp+756]
	lea	ecx, DWORD PTR [eax+edx]
	lea	edx, DWORD PTR $T243539[esp+756]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+768], 4
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$224339[esp+760]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	lea	ecx, DWORD PTR $T243539[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1780 : 						CvString strMessage = strTemp.toUTF8();

	lea	ecx, DWORD PTR _strTemp$224339[esp+756]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	test	eax, eax
	jne	SHORT $LN259@DoMakePeac
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN259@DoMakePeac:
	push	eax
	lea	ecx, DWORD PTR _strMessage$224347[esp+760]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1781 : 
; 1782 : 						for(uint iMinorCivLoop = 0; iMinorCivLoop < veMinorAllies.size(); iMinorCivLoop++)

	xor	esi, esi
	mov	BYTE PTR __$EHRec$[esp+764], 6
	cmp	DWORD PTR _veMinorAllies$224317[esp+760], esi
	jbe	$LN24@DoMakePeac
	npad	2
$LL26@DoMakePeac:

; 1783 : 						{
; 1784 : 							PlayerTypes eMinor = veMinorAllies[iMinorCivLoop];

	mov	eax, DWORD PTR _veMinorAllies$224317[esp+756]
	mov	eax, DWORD PTR [eax+esi*4]

; 1785 : 							strTemp = Localization::Lookup(GET_TEAM(GET_PLAYER(eMinor).getTeam()).getName().GetCString());

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN271@DoMakePeac
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN272@DoMakePeac
$LN271@DoMakePeac:
	or	eax, -1
$LN272@DoMakePeac:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR $T243540[esp+756]
	push	ecx
	mov	ecx, eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR $T243541[esp+760]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strTemp$224339[esp+760]
	mov	BYTE PTR __$EHRec$[esp+768], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243541[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 7
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T243540[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1786 : 							strMessage = strMessage + "[NEWLINE]" + strTemp.toUTF8();

	mov	ebx, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG224357
	lea	eax, DWORD PTR _strMessage$224347[esp+760]
	push	eax
	lea	ecx, DWORD PTR $T243542[esp+764]
	push	ecx
	call	ebx
	add	esp, 12					; 0000000cH
	mov	edi, eax
	lea	ecx, DWORD PTR _strTemp$224339[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 9
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	edx, DWORD PTR $T243543[esp+760]
	push	edi
	push	edx
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$224347[esp+760]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T243543[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T243542[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	esi
	cmp	esi, DWORD PTR _veMinorAllies$224317[esp+760]
	jb	$LL26@DoMakePeac
$LN24@DoMakePeac:

; 1787 : 						}
; 1788 : 
; 1789 : 						if(GET_PLAYER(eOurPlayer).GetNotifications())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv2260[esp+756]
	add	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	SHORT $LN507@DoMakePeac

; 1790 : 							GET_PLAYER(eOurPlayer).GetNotifications()->Add(NOTIFICATION_PEACE, strMessage, strSummary.toUTF8(), -1, -1, veMinorAllies.front(), eTeam);

	mov	esi, DWORD PTR _veMinorAllies$224317[esp+756]
	lea	ecx, DWORD PTR _strMessage$224347[esp+756]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR _eTeam$[esp+752]
	mov	edi, eax
	mov	eax, DWORD PTR tv2260[esp+756]
	push	ecx
	lea	ebx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [esi]
	push	edx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$224342[esp+772]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	edi
	push	818263651				; 30c5b663H
	mov	ecx, ebx
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN507@DoMakePeac:

; 1791 : 					}

	lea	ecx, DWORD PTR _strMessage$224347[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$224342[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 3
	call	esi
	lea	ecx, DWORD PTR _strTemp$224339[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 2
	call	esi
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN27@DoMakePeac:

; 1792 : 				}

	mov	eax, DWORD PTR _veMinorAllies$224317[esp+756]
	lea	ecx, DWORD PTR _veMinorAllies$224317[esp+768]
	mov	BYTE PTR __$EHRec$[esp+764], 0
	cmp	eax, ecx
	je	SHORT $LN509@DoMakePeac
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esp, 4
$LN509@DoMakePeac:
	mov	ebp, DWORD PTR _eTeam$[esp+752]
	mov	edi, DWORD PTR _this$[esp+756]
$LN47@DoMakePeac:
	mov	eax, DWORD PTR tv2260[esp+756]
	inc	DWORD PTR _iPlayerLoop$224305[esp+756]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv2260[esp+756], eax
	jl	$LL48@DoMakePeac
$LN46@DoMakePeac:

; 1793 : 			}
; 1794 : 		}
; 1795 : 
; 1796 : 		// Update Interface
; 1797 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eTeam == GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN21@DoMakePeac
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebp, eax
	jne	SHORT $LN22@DoMakePeac
$LN21@DoMakePeac:

; 1798 : 		{
; 1799 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	12					; 0000000cH
	call	eax

; 1800 : 			DLLUI->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax
$LN22@DoMakePeac:

; 1801 : 		}
; 1802 : 
; 1803 : 		// What does it mean when we make peace
; 1804 : 		CvPlayer* pOurPlayer;
; 1805 : 		PlayerTypes eOurPlayer;
; 1806 : 		for(int iOurPlayerLoop = 0; iOurPlayerLoop < MAX_CIV_PLAYERS; iOurPlayerLoop++)

	mov	ebx, DWORD PTR _this$[esp+756]
	mov	ebp, DWORD PTR _eTeam$[esp+752]
	xor	edi, edi
	npad	5
$LL20@DoMakePeac:

; 1807 : 		{
; 1808 : 			eOurPlayer = (PlayerTypes) iOurPlayerLoop;
; 1809 : 			pOurPlayer = &GET_PLAYER(eOurPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1810 : 
; 1811 : 			if(pOurPlayer->isAlive())

	cmp	BYTE PTR [edi+ecx+2256], 0
	lea	esi, DWORD PTR [edi+ecx]
	je	$LN19@DoMakePeac

; 1812 : 			{
; 1813 : 				// Our Team
; 1814 : 				if(pOurPlayer->getTeam() == GetID())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN330@DoMakePeac
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN331@DoMakePeac
$LN330@DoMakePeac:
	or	ecx, -1
$LN331@DoMakePeac:
	mov	edx, DWORD PTR [ebx+4]
	cmp	ecx, edx
	jne	SHORT $LN16@DoMakePeac

; 1815 : 				{
; 1816 : 					pOurPlayer->GetDiplomacyAI()->DoWeMadePeaceWithSomeone(eTeam);

	push	ebp
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoWeMadePeaceWithSomeone@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z ; CvDiplomacyAI::DoWeMadePeaceWithSomeone

; 1817 : 					pOurPlayer->GetMilitaryAI()->LogPeace(eTeam);	// This is not quite correct, but it'll work well enough for AI testing

	push	ebp
	jmp	SHORT $LN511@DoMakePeac
$LN16@DoMakePeac:

; 1818 : 				}
; 1819 : 				// Their Team
; 1820 : 				else if(pOurPlayer->getTeam() == eTeam)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN341@DoMakePeac
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN342@DoMakePeac
$LN341@DoMakePeac:
	or	eax, -1
$LN342@DoMakePeac:
	cmp	eax, ebp
	jne	SHORT $LN19@DoMakePeac

; 1821 : 				{
; 1822 : 					pOurPlayer->GetDiplomacyAI()->DoWeMadePeaceWithSomeone(GetID());

	push	edx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoWeMadePeaceWithSomeone@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z ; CvDiplomacyAI::DoWeMadePeaceWithSomeone

; 1823 : 					pOurPlayer->GetMilitaryAI()->LogPeace(GetID());	// This is not quite correct, but it'll work well enough for AI testing

	mov	eax, DWORD PTR [ebx+4]
	push	eax
$LN511@DoMakePeac:
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z ; CvMilitaryAI::LogPeace
$LN19@DoMakePeac:
	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jl	$LL20@DoMakePeac

; 1824 : 				}
; 1825 : 			}
; 1826 : 		}
; 1827 : 
; 1828 : 		Localization::String locString;

	lea	ecx, DWORD PTR _locString$224372[esp+756]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 1829 : 
; 1830 : 		// Text stuff
; 1831 : 		if(!bSuppressNotification)

	cmp	BYTE PTR _bSuppressNotification$[esp+752], 0
	mov	bl, 11					; 0000000bH
	mov	BYTE PTR __$EHRec$[esp+764], bl
	jne	$LN502@DoMakePeac

; 1832 : 		{
; 1833 : 			PlayerTypes ePlayer;
; 1834 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	esi, esi
	npad	4
$LL12@DoMakePeac:

; 1835 : 			{
; 1836 : 				ePlayer = (PlayerTypes) iI;
; 1837 : 
; 1838 : 				if(GET_PLAYER(ePlayer).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+edx+2256], 0
	lea	ecx, DWORD PTR [esi+edx]
	je	$LN11@DoMakePeac

; 1839 : 				{
; 1840 : 					if(GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN362@DoMakePeac
	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN363@DoMakePeac
$LN362@DoMakePeac:
	or	eax, -1
$LN363@DoMakePeac:
	mov	ebp, DWORD PTR _this$[esp+756]
	mov	edi, DWORD PTR [ebp+4]
	cmp	eax, edi
	jne	$LN8@DoMakePeac

; 1841 : 					{
; 1842 : 						if(GET_PLAYER(ePlayer).GetNotifications())

	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN11@DoMakePeac

; 1843 : 						{
; 1844 : 							locString = Localization::Lookup("TXT_KEY_MISC_YOU_MADE_PEACE_WITH");

	lea	ecx, DWORD PTR $T243544[esp+756]
	push	OFFSET $SG224383
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+760]
	mov	BYTE PTR __$EHRec$[esp+768], 12		; 0000000cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243544[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1845 : 							locString << GET_TEAM(eTeam).getName().GetCString();

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, DWORD PTR tv1517[esp+756]
	lea	ecx, DWORD PTR [eax+edx]
	lea	edx, DWORD PTR $T243546[esp+756]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 13		; 0000000dH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+760]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	lea	ecx, DWORD PTR $T243546[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1846 : 							GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_PEACE_ACTIVE_PLAYER, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID());

	mov	ecx, ebp
$LN514@DoMakePeac:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	lea	edi, DWORD PTR [esi+eax]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$224372[esp+772]
	call	ebp
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+776]
	call	ebp
	push	eax
	push	-2028078871				; 871df8e9H

; 1847 : 						}
; 1848 : 					}

	jmp	$LN512@DoMakePeac
$LN8@DoMakePeac:

; 1849 : 					else if(GET_PLAYER(ePlayer).getTeam() == eTeam)

	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN388@DoMakePeac
	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN389@DoMakePeac
$LN388@DoMakePeac:
	or	eax, -1
$LN389@DoMakePeac:
	cmp	eax, DWORD PTR _eTeam$[esp+752]
	jne	$LN5@DoMakePeac

; 1850 : 					{
; 1851 : 						if(GET_PLAYER(ePlayer).GetNotifications())

	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN11@DoMakePeac

; 1852 : 						{
; 1853 : 							locString = Localization::Lookup("TXT_KEY_MISC_YOU_MADE_PEACE_WITH");

	lea	ecx, DWORD PTR $T243547[esp+756]
	push	OFFSET $SG224390
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+760]
	mov	BYTE PTR __$EHRec$[esp+768], 14		; 0000000eH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243547[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1854 : 							locString << getName().GetCString();

	lea	edx, DWORD PTR $T243549[esp+756]
	push	edx
	mov	ecx, ebp
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 15		; 0000000fH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+760]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	lea	ecx, DWORD PTR $T243549[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1855 : 							GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_PEACE_ACTIVE_PLAYER, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID());

	mov	ecx, ebp

; 1856 : 						}
; 1857 : 					}

	jmp	$LN514@DoMakePeac
$LN5@DoMakePeac:

; 1858 : 					else if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GetID()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eTeam))

	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN412@DoMakePeac
	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN413@DoMakePeac
$LN412@DoMakePeac:
	or	eax, -1
$LN413@DoMakePeac:
	imul	eax, 2984				; 00000ba8H
	add	eax, edi
	mov	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [eax+edi+1848], 0
	je	$LN11@DoMakePeac
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN429@DoMakePeac
	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN430@DoMakePeac
$LN429@DoMakePeac:
	or	eax, -1
$LN430@DoMakePeac:
	mov	ebp, DWORD PTR _eTeam$[esp+752]
	imul	eax, 2984				; 00000ba8H
	add	eax, edi
	cmp	BYTE PTR [eax+ebp+1848], 0
	je	$LN11@DoMakePeac

; 1859 : 					{
; 1860 : 						if(GET_PLAYER(ePlayer).GetNotifications())

	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN11@DoMakePeac

; 1861 : 						{
; 1862 : 							locString = Localization::Lookup("TXT_KEY_MISC_SOMEONE_MADE_PEACE");

	lea	ecx, DWORD PTR $T243550[esp+756]
	push	OFFSET $SG224397
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+760]
	mov	BYTE PTR __$EHRec$[esp+768], 16		; 00000010H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243550[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1863 : 							locString << getName().GetCString() << GET_TEAM(eTeam).getName().GetCString();

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, DWORD PTR tv1517[esp+756]
	lea	ecx, DWORD PTR [eax+edx]
	lea	edx, DWORD PTR $T243552[esp+756]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 17		; 00000011H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+756]
	mov	edi, eax
	lea	eax, DWORD PTR $T243554[esp+756]
	push	eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 18		; 00000012H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+760]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	edi
	lea	ecx, DWORD PTR _locString$224372[esp+760]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	lea	ecx, DWORD PTR $T243554[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 17		; 00000011H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T243552[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1864 : 							GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_PEACE, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID(), eTeam);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edi, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _this$[esp+756]
	push	ebp
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$224372[esp+772]
	call	ebp
	push	eax
	lea	ecx, DWORD PTR _locString$224372[esp+776]
	call	ebp
	push	eax
	push	818263651				; 30c5b663H
$LN512@DoMakePeac:
	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN11@DoMakePeac:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	$LL12@DoMakePeac
$LN502@DoMakePeac:

; 1865 : 						}
; 1866 : 					}
; 1867 : 				}
; 1868 : 			}
; 1869 : 		}
; 1870 : 
; 1871 : 		strBuffer = GetLocalizedText("TXT_KEY_MISC_SOMEONE_MADE_PEACE", getName().GetCString(), GET_TEAM(eTeam).getName().GetCString());

	mov	edx, DWORD PTR tv1517[esp+756]
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [edx+eax]
	lea	edx, DWORD PTR $T243556[esp+756]
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 19		; 00000013H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR _this$[esp+756]
	mov	DWORD PTR $T243555[esp+756], eax
	lea	eax, DWORD PTR $T243558[esp+756]
	push	eax
	mov	ecx, esi
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+764], 20		; 00000014H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR $T243555[esp+756]
	push	ecx
	lea	edx, DWORD PTR $T243557[esp+760]
	push	edx
	mov	DWORD PTR $T243557[esp+764], eax
	lea	eax, DWORD PTR $T243559[esp+764]
	push	OFFSET $SG224407
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+760]
	mov	BYTE PTR __$EHRec$[esp+768], 21		; 00000015H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T243559[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 20		; 00000014H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T243558[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 19		; 00000013H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T243556[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1872 : 		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	push	-1
	push	-1
	lea	ecx, DWORD PTR _strBuffer$[esp+764]
	push	ecx
	mov	ecx, esi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 1873 : 	}

	lea	ecx, DWORD PTR _locString$224372[esp+756]
	mov	BYTE PTR __$EHRec$[esp+764], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	pop	esi
	pop	ebx
$LN53@DoMakePeac:

; 1874 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+748]
	mov	DWORD PTR __$EHRec$[esp+756], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+748]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 740				; 000002e4H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR _args$224294[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2:
	lea	ecx, DWORD PTR _veMinorAllies$224317[ebp]
	jmp	??1?$FStaticVector@W4PlayerTypes@@$0DP@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum PlayerTypes,63,1,297,0>::~FStaticVector<enum PlayerTypes,63,1,297,0>
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3:
	lea	ecx, DWORD PTR _strTemp$224339[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4:
	lea	ecx, DWORD PTR _strSummary$224342[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5:
	lea	ecx, DWORD PTR $T243539[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6:
	lea	ecx, DWORD PTR _strMessage$224347[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7:
	lea	ecx, DWORD PTR $T243540[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8:
	lea	ecx, DWORD PTR $T243541[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9:
	lea	ecx, DWORD PTR $T243542[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10:
	lea	ecx, DWORD PTR $T243543[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11:
	lea	ecx, DWORD PTR _locString$224372[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12:
	lea	ecx, DWORD PTR $T243544[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$13:
	lea	ecx, DWORD PTR $T243546[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$14:
	lea	ecx, DWORD PTR $T243547[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$15:
	lea	ecx, DWORD PTR $T243549[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$16:
	lea	ecx, DWORD PTR $T243550[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$17:
	lea	ecx, DWORD PTR $T243552[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$18:
	lea	ecx, DWORD PTR $T243554[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$19:
	lea	ecx, DWORD PTR $T243556[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$20:
	lea	ecx, DWORD PTR $T243558[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z$21:
	lea	ecx, DWORD PTR $T243559[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z ENDP	; CvTeam::DoMakePeace
PUBLIC	?changeTechShareCount@CvTeam@@QAEXHH@Z		; CvTeam::changeTechShareCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeTechShareCount@CvTeam@@QAEXHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeTechShareCount@CvTeam@@QAEXHH@Z PROC		; CvTeam::changeTechShareCount, COMDAT
; _this$ = ecx

; 3353 : 	CvAssertMsg(iIndex >= 0, "iIndex is expected to be non-negative (invalid Index)");
; 3354 : 	CvAssertMsg(iIndex < MAX_TEAMS, "iIndex is expected to be within maximum bounds (invalid Index)");
; 3355 : 	if(iIndex < 0 || iIndex >= MAX_TEAMS) return;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	edx, ecx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@changeTech

; 3356 : 	if(iChange != 0)

	mov	ecx, DWORD PTR _iChange$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@changeTech

; 3357 : 	{
; 3358 : 		m_aiTechShareCount[iIndex] = (m_aiTechShareCount[iIndex] + iChange);

	add	DWORD PTR [edx+eax*4+148], ecx

; 3359 : 		CvAssert(getTechShareCount(iIndex) >= 0);
; 3360 : 
; 3361 : 		if(isTechShare(iIndex))

	push	eax
	mov	ecx, edx
	call	?isTechShare@CvTeam@@QBE_NH@Z		; CvTeam::isTechShare
	test	al, al
	je	SHORT $LN3@changeTech

; 3362 : 		{
; 3363 : 			updateTechShare();

	mov	ecx, edx
	call	?updateTechShare@CvTeam@@IAEXXZ		; CvTeam::updateTechShare
$LN3@changeTech:

; 3364 : 		}
; 3365 : 	}
; 3366 : }

	ret	8
?changeTechShareCount@CvTeam@@QAEXHH@Z ENDP		; CvTeam::changeTechShareCount
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z ; CvWeightedVector<enum TeamTypes,63,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z PROC ; CvWeightedVector<enum TeamTypes,63,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+516], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@3
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@$0DP@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement,63,1,0,0>::GrowSize
$LN5@push_back@3:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@3
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@3:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z ENDP ; CvWeightedVector<enum TeamTypes,63,1>::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXPAW4ResourceTypes@@0@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW43@IABW43@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T244544 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$244547 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$244547[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T244544[esp+12], 0
	mov	eax, DWORD PTR $T244544[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Alloc, COMDAT
; _this$ = ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);
; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _nBytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pData$[esp]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	edi, DWORD PTR [edi*4+4]
	lea	eax, DWORD PTR [edi+edx]
	push	eax
	call	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	ecx, eax
	and	ecx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	add	edx, 4
	pop	edi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > >::Alloc
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z
_TEXT	SEGMENT
$T244616 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244619 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244619[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244616[esp+4], 0
	mov	eax, DWORD PTR $T244616[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@stdext@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@5
	pop	esi
$LN13@unchecked_@5:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >
_TEXT	ENDS
PUBLIC	??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@2
	mov	eax, DWORD PTR [esi-4]
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	16					; 00000010H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@2
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@2:
	mov	eax, DWORD PTR [esi+4]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN11@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@vector@2:
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	test	bl, 1
	je	SHORT $LN1@vector@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_E?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z ; CvTeam::processBuilding
EXTRN	?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z:PROC ; CvCityBuildings::ChangeBuildingDefenseMod
EXTRN	?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetGlobalDefenseModifier
EXTRN	?IsMapCentering@CvBuildingEntry@@QBE_NXZ:PROC	; CvBuildingEntry::IsMapCentering
EXTRN	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ:PROC	; CvBuildingEntry::IsBorderObstacle
EXTRN	?GetTechShare@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetTechShare
EXTRN	?GetVictoryPoints@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetVictoryPoints
EXTRN	?DoUnitedNationsBuilt@CvGameLeagues@@QAEXW4PlayerTypes@@@Z:PROC ; CvGameLeagues::DoUnitedNationsBuilt
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsDiplomaticVoting
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iLoop$223779 = 8					; size = 4
_eBuilding$ = 8						; size = 4
_iChange$ = 12						; size = 4
tv310 = 16						; size = 4
_bFirst$ = 16						; size = 1
?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z PROC ; CvTeam::processBuilding, COMDAT
; _this$ = ecx

; 763  : {

	push	ecx

; 764  : 	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	eax, DWORD PTR _eBuilding$[esp]
	push	ebp
	push	esi
	mov	esi, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+16], esi
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ebp, eax

; 765  : 	if(pBuildingInfo == NULL)

	test	ebp, ebp
	je	$LN5@processBui

; 766  : 		return;
; 767  : 
; 768  : 	// One-shot items
; 769  : 	if(bFirst && iChange > 0)

	cmp	BYTE PTR _bFirst$[esp+8], 0
	push	ebx
	mov	ebx, DWORD PTR _iChange$[esp+12]
	push	edi
	je	SHORT $LN12@processBui
	test	ebx, ebx
	jle	SHORT $LN12@processBui

; 770  : 	{
; 771  : 		// Diplo victory
; 772  : 		if(pBuildingInfo->IsDiplomaticVoting())

	mov	ecx, ebp
	call	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsDiplomaticVoting
	test	al, al
	je	SHORT $LN12@processBui

; 773  : 		{
; 774  : 			SetHomeOfUnitedNations(true);

	cmp	BYTE PTR [esi+130], 1
	je	SHORT $LN17@processBui
	mov	BYTE PTR [esi+130], 1
$LN17@processBui:

; 775  : 			GC.getGame().GetGameLeagues()->DoUnitedNationsBuilt(getLeaderID());

	mov	ecx, esi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?DoUnitedNationsBuilt@CvGameLeagues@@QAEXW4PlayerTypes@@@Z ; CvGameLeagues::DoUnitedNationsBuilt
$LN12@processBui:

; 776  : 		}
; 777  : 	}
; 778  : 
; 779  : 	changeVictoryPoints((pBuildingInfo->GetVictoryPoints()) * iChange);

	mov	ecx, ebp
	call	?GetVictoryPoints@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetVictoryPoints
	imul	eax, ebx
	test	eax, eax
	je	SHORT $LN24@processBui
	add	DWORD PTR [esi+92], eax
$LN24@processBui:

; 780  : 
; 781  : 	if((pBuildingInfo->GetTechShare() > 0) && (pBuildingInfo->GetTechShare() <= MAX_TEAMS))

	mov	ecx, ebp
	call	?GetTechShare@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechShare
	test	eax, eax
	jle	SHORT $LN50@processBui
	mov	ecx, ebp
	call	?GetTechShare@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechShare
	cmp	eax, 64					; 00000040H
	jg	SHORT $LN50@processBui

; 782  : 	{
; 783  : 		changeTechShareCount((pBuildingInfo->GetTechShare() - 1), iChange);

	push	ebx
	mov	ecx, ebp
	call	?GetTechShare@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechShare
	dec	eax
	push	eax
	mov	ecx, esi
	call	?changeTechShareCount@CvTeam@@QAEXHH@Z	; CvTeam::changeTechShareCount
$LN50@processBui:

; 784  : 	}
; 785  : 
; 786  : 	if(pBuildingInfo->IsBorderObstacle())

	mov	ecx, ebp
	call	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsBorderObstacle
	test	al, al
	je	SHORT $LN27@processBui

; 787  : 	{
; 788  : 		changeBorderObstacleCount(pBuildingInfo->IsBorderObstacle() * iChange);

	mov	ecx, ebp
	call	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsBorderObstacle
	movzx	eax, al
	imul	eax, ebx
	test	eax, eax
	je	SHORT $LN27@processBui
	add	DWORD PTR [esi+88], eax
$LN27@processBui:

; 789  : 	}
; 790  : 
; 791  : 	if(pBuildingInfo->IsMapCentering())

	mov	ecx, ebp
	call	?IsMapCentering@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsMapCentering
	test	al, al
	je	SHORT $LN8@processBui

; 792  : 	{
; 793  : 		if(iChange > 0)

	test	ebx, ebx
	jle	SHORT $LN8@processBui

; 794  : 		{
; 795  : 			setMapCentering(true);

	push	1
	mov	ecx, esi
	call	?setMapCentering@CvTeam@@QAEX_N@Z	; CvTeam::setMapCentering
$LN8@processBui:

; 796  : 		}
; 797  : 	}
; 798  : 
; 799  : 	// Effects in every City on this Team
; 800  : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	edi, edi
	mov	DWORD PTR tv310[esp+16], edi
	npad	2
$LL7@processBui:

; 801  : 	{
; 802  : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes) iPlayerLoop);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 803  : 		if(kPlayer.getTeam() == m_eID && kPlayer.isAlive())

	mov	eax, DWORD PTR [edi+ecx+44]
	add	edi, ecx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN36@processBui
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN37@processBui
$LN36@processBui:
	or	eax, -1
$LN37@processBui:
	cmp	eax, DWORD PTR [esi+4]
	jne	SHORT $LN6@processBui
	cmp	BYTE PTR [edi+2256], 0
	je	SHORT $LN6@processBui

; 804  : 		{
; 805  : 			CvCity* pLoopCity;
; 806  : 			int iLoop;
; 807  : 
; 808  : 			for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$223779[esp+20]
	push	edx
	mov	ecx, edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN49@processBui
$LL3@processBui:

; 809  : 			{
; 810  : 				pLoopCity->GetCityBuildings()->ChangeBuildingDefenseMod(pBuildingInfo->GetGlobalDefenseModifier() * iChange);

	mov	ecx, ebp
	call	?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalDefenseModifier
	imul	eax, ebx
	push	eax
	mov	ecx, esi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingDefenseMod
	push	0
	lea	eax, DWORD PTR _iLoop$223779[esp+20]
	push	eax
	mov	ecx, edi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL3@processBui
$LN49@processBui:

; 804  : 		{
; 805  : 			CvCity* pLoopCity;
; 806  : 			int iLoop;
; 807  : 
; 808  : 			for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	mov	esi, DWORD PTR _this$[esp+20]
$LN6@processBui:

; 796  : 		}
; 797  : 	}
; 798  : 
; 799  : 	// Effects in every City on this Team
; 800  : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	edi, DWORD PTR tv310[esp+16]
	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	mov	DWORD PTR tv310[esp+16], edi
	jl	$LL7@processBui
	pop	edi
	pop	ebx
$LN5@processBui:
	pop	esi
	pop	ebp

; 811  : 			}
; 812  : 		}
; 813  : 	}
; 814  : }

	pop	ecx
	ret	12					; 0000000cH
?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z ENDP ; CvTeam::processBuilding
_TEXT	ENDS
PUBLIC	?doTurn@CvTeam@@QAEXXZ				; CvTeam::doTurn
EXTRN	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z:PROC ; CvTeamTechs::SetNoTradeTech
; Function compile flags: /Ogtpy
;	COMDAT ?doTurn@CvTeam@@QAEXXZ
_TEXT	SEGMENT
?doTurn@CvTeam@@QAEXXZ PROC				; CvTeam::doTurn, COMDAT
; _this$ = ecx

; 819  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 820  : #ifdef AUI_WARNING_FIXES
; 821  : 	uint iI;
; 822  : #else
; 823  : 	int iI;
; 824  : #endif
; 825  : 
; 826  : 	CvAssertMsg(isAlive(), "isAlive is expected to be true");
; 827  : 
; 828  : 	// Barbarians get all Techs that 3/4 of alive players get
; 829  : 	if(isBarbarian())

	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], 63			; 0000003fH
	push	edi
	jne	SHORT $LN13@doTurn

; 830  : 	{
; 831  : 		DoBarbarianTech();

	call	?DoBarbarianTech@CvTeam@@QAEXXZ		; CvTeam::DoBarbarianTech

; 832  : 	}
; 833  : 	// NOT barbs
; 834  : 	else

	jmp	$LN72@doTurn
$LN13@doTurn:
	push	ebp

; 835  : 	{
; 836  : 		// War counter
; 837  : 		TeamTypes eTeam;
; 838  : 		int iTeamLoop;
; 839  : 		for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	mov	edi, 2
	mov	ebp, 5968				; 00001750H
	lea	eax, DWORD PTR [esi+792]
	npad	8
$LL85@doTurn:

; 840  : 		{
; 841  : 			eTeam = (TeamTypes) iTeamLoop;
; 842  : 
; 843  : 			if(!GET_TEAM(eTeam).isBarbarian())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [ecx+ebp-5964], 63		; 0000003fH
	je	SHORT $LN41@doTurn

; 844  : 			{
; 845  : 				if(isAtWar(eTeam))

	cmp	BYTE PTR [edi+esi+1926], bl
	lea	edx, DWORD PTR [edi-2]
	je	SHORT $LN7@doTurn

; 846  : 					ChangeNumTurnsAtWar(eTeam, 1);

	mov	ecx, DWORD PTR [eax-324]
	inc	ecx
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN32@doTurn
	cmp	ecx, ebx
	jne	SHORT $LN41@doTurn
$LN32@doTurn:
	mov	DWORD PTR [eax-324], ecx

; 847  : 				else

	jmp	SHORT $LN41@doTurn
$LN7@doTurn:

; 848  : 					SetNumTurnsAtWar(eTeam, 0);

	mov	DWORD PTR [eax-324], ebx
$LN41@doTurn:

; 849  : 			}
; 850  : 
; 851  : 			if(GetNumTurnsLockedIntoWar(eTeam) > 0)

	mov	ecx, DWORD PTR [eax-4]
	cmp	ecx, ebx
	jle	SHORT $LN10@doTurn

; 852  : 				ChangeNumTurnsLockedIntoWar(eTeam, -1);

	lea	edx, DWORD PTR [edi-2]
	dec	ecx
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN58@doTurn
	cmp	ecx, ebx
	jne	SHORT $LN10@doTurn
$LN58@doTurn:
	mov	DWORD PTR [eax-4], ecx
$LN10@doTurn:

; 840  : 		{
; 841  : 			eTeam = (TeamTypes) iTeamLoop;
; 842  : 
; 843  : 			if(!GET_TEAM(eTeam).isBarbarian())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [ecx+ebp-2980], 63		; 0000003fH
	je	SHORT $LN76@doTurn

; 844  : 			{
; 845  : 				if(isAtWar(eTeam))

	cmp	BYTE PTR [edi+esi+1927], bl
	lea	edx, DWORD PTR [edi-1]
	je	SHORT $LN75@doTurn

; 846  : 					ChangeNumTurnsAtWar(eTeam, 1);

	mov	ecx, DWORD PTR [eax-320]
	inc	ecx
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN73@doTurn
	cmp	ecx, ebx
	jne	SHORT $LN76@doTurn
$LN73@doTurn:
	mov	DWORD PTR [eax-320], ecx

; 847  : 				else

	jmp	SHORT $LN76@doTurn
$LN75@doTurn:

; 848  : 					SetNumTurnsAtWar(eTeam, 0);

	mov	DWORD PTR [eax-320], ebx
$LN76@doTurn:

; 849  : 			}
; 850  : 
; 851  : 			if(GetNumTurnsLockedIntoWar(eTeam) > 0)

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, ebx
	jle	SHORT $LN78@doTurn

; 852  : 				ChangeNumTurnsLockedIntoWar(eTeam, -1);

	lea	edx, DWORD PTR [edi-1]
	dec	ecx
	cmp	edx, DWORD PTR [esi+4]
	jne	SHORT $LN77@doTurn
	cmp	ecx, ebx
	jne	SHORT $LN78@doTurn
$LN77@doTurn:
	mov	DWORD PTR [eax], ecx
$LN78@doTurn:

; 840  : 		{
; 841  : 			eTeam = (TeamTypes) iTeamLoop;
; 842  : 
; 843  : 			if(!GET_TEAM(eTeam).isBarbarian())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [ecx+ebp+4], 63		; 0000003fH
	je	SHORT $LN82@doTurn

; 844  : 			{
; 845  : 				if(isAtWar(eTeam))

	cmp	BYTE PTR [edi+esi+1928], bl
	je	SHORT $LN81@doTurn

; 846  : 					ChangeNumTurnsAtWar(eTeam, 1);

	mov	ecx, DWORD PTR [eax-316]
	inc	ecx
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LN79@doTurn
	cmp	ecx, ebx
	jne	SHORT $LN82@doTurn
$LN79@doTurn:
	mov	DWORD PTR [eax-316], ecx

; 847  : 				else

	jmp	SHORT $LN82@doTurn
$LN81@doTurn:

; 848  : 					SetNumTurnsAtWar(eTeam, 0);

	mov	DWORD PTR [eax-316], ebx
$LN82@doTurn:

; 849  : 			}
; 850  : 
; 851  : 			if(GetNumTurnsLockedIntoWar(eTeam) > 0)

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, ebx
	jle	SHORT $LN84@doTurn

; 852  : 				ChangeNumTurnsLockedIntoWar(eTeam, -1);

	dec	ecx
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LN83@doTurn
	cmp	ecx, ebx
	jne	SHORT $LN84@doTurn
$LN83@doTurn:
	mov	DWORD PTR [eax+4], ecx
$LN84@doTurn:

; 835  : 	{
; 836  : 		// War counter
; 837  : 		TeamTypes eTeam;
; 838  : 		int iTeamLoop;
; 839  : 		for(iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	edi, 3
	lea	edx, DWORD PTR [edi-2]
	add	eax, 12					; 0000000cH
	add	ebp, 8952				; 000022f8H
	cmp	edx, 63					; 0000003fH
	jl	$LL85@doTurn
	pop	ebp
$LN72@doTurn:

; 853  : 		}
; 854  : 	}
; 855  : 
; 856  : 	// City States also get all Techs that 3/4 of alive players get
; 857  : 	if(isMinorCiv())

	mov	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	SHORT $LN4@doTurn

; 858  : 	{
; 859  : 		DoMinorCivTech();

	mov	ecx, esi
	call	?DoMinorCivTech@CvTeam@@QAEXXZ		; CvTeam::DoMinorCivTech
$LN4@doTurn:

; 860  : 	}
; 861  : 
; 862  : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN1@doTurn
$LL3@doTurn:

; 863  : 	{
; 864  : 		GetTeamTechs()->SetNoTradeTech(((TechTypes)iI), false);

	mov	ecx, DWORD PTR [esi+2980]
	push	ebx
	push	edi
	call	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	edi, eax
	jl	SHORT $LL3@doTurn
$LN1@doTurn:

; 865  : 	}
; 866  : 
; 867  : 	DoTestSmallAwards();

	mov	ecx, esi
	call	?DoTestSmallAwards@CvTeam@@QAEXXZ	; CvTeam::DoTestSmallAwards
	pop	edi

; 868  : 
; 869  : 	testCircumnavigated();

	mov	ecx, esi
	pop	esi
	pop	ebx
	jmp	?testCircumnavigated@CvTeam@@IAEXXZ	; CvTeam::testCircumnavigated
?doTurn@CvTeam@@QAEXXZ ENDP				; CvTeam::doTurn
_TEXT	ENDS
EXTRN	?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z:PROC ; CvMinorCivAI::DoTeamDeclaredWarOnMe
EXTRN	?ChangeOtherPlayerNumMajorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@HW4TeamTypes@@@Z:PROC ; CvDiplomacyAI::ChangeOtherPlayerNumMajorsAttacked
EXTRN	?ChangeOtherPlayerNumMinorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeOtherPlayerNumMinorsAttacked
EXTRN	?DoPlayerDeclaredWarOnSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvDiplomacyAI::DoPlayerDeclaredWarOnSomeone
EXTRN	?DoSomeoneDeclaredWarOnMe@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z:PROC ; CvDiplomacyAI::DoSomeoneDeclaredWarOnMe
EXTRN	?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z:PROC ; CvGameDeals::DoCancelDealsBetweenTeams
EXTRN	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ:PROC ; CvGame::GetGameDeals
EXTRN	?ChangeNumCitiesLiberated@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeNumCitiesLiberated
EXTRN	?GetNumCitiesLiberated@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetNumCitiesLiberated
EXTRN	?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z:PROC ; CvGameTrade::InvalidateTradeBetweenTeams
EXTRN	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z:PROC ; CvGameTrade::CancelTradeBetweenTeams
EXTRN	?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z:PROC ; CvGameTrade::DoAutoWarPlundering
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
xdata$x	SEGMENT
__ehfuncinfo$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
tv2022 = -252						; size = 4
_iI$ = -252						; size = 4
_args$223952 = -252					; size = 4
_this$ = -248						; size = 4
tv1938 = -244						; size = 4
tv1345 = -244						; size = 4
tv1396 = -240						; size = 4
_bResult$223953 = -233					; size = 1
tv1351 = -232						; size = 4
$T245606 = -232						; size = 4
$T245158 = -228						; size = 28
$T245155 = -228						; size = 28
$T245152 = -228						; size = 28
$T245147 = -228						; size = 28
$T245144 = -228						; size = 28
_locString$ = -200					; size = 80
$T245157 = -120						; size = 28
$T245150 = -120						; size = 28
$T245153 = -92						; size = 80
$T245148 = -92						; size = 80
$T245145 = -92						; size = 80
$T245142 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bDefensivePact$ = 12					; size = 1
_bMinorAllyPact$ = 16					; size = 1
?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z PROC	; CvTeam::DoDeclareWar, COMDAT
; _this$ = ecx

; 1161 : {

	push	-1
	push	__ehhandler$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1162 : 	Localization::String locString;

	lea	ecx, DWORD PTR _locString$[esp+264]
	mov	DWORD PTR _this$[esp+264], esi
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 1163 : 	int iI;
; 1164 : 
; 1165 : 	CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 1166 : 	CvAssertMsg(eTeam != GetID(), "eTeam is not expected to be equal with GetID()");
; 1167 : 
; 1168 : 	if (isAtWar(eTeam))

	mov	edi, DWORD PTR _eTeam$[esp+260]
	xor	ebx, ebx
	lea	eax, DWORD PTR [edi+esi+1928]
	mov	DWORD PTR __$EHRec$[esp+272], ebx
	mov	DWORD PTR tv1345[esp+264], eax
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN58@DoDeclareW

; 1169 : 	{
; 1170 : 		return;

	lea	ecx, DWORD PTR _locString$[esp+264]
	mov	DWORD PTR __$EHRec$[esp+272], -1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN59@DoDeclareW
$LN58@DoDeclareW:

; 1171 : 	}
; 1172 : 
; 1173 : 	CvAssertMsg(eTeam != GetID(), "eTeam is not expected to be equal with GetID()");
; 1174 : 	if (!isBarbarian())

	mov	eax, DWORD PTR [esi+4]
	push	ebp
	cmp	eax, 63					; 0000003fH
	je	$LN473@DoDeclareW

; 1175 : 	{
; 1176 : 		// Since we declared war, all of OUR Defensive Pacts are nullified
; 1177 : 
; 1178 : 		
; 1179 : #ifndef NEW_DEFENSIVE_PACT //EAP: DP is now a peace treaty
; 1180 : 		cancelDefensivePacts();
; 1181 : #endif
; 1182 : 		GC.getGame().GetGameTrade()->DoAutoWarPlundering(m_eID, eTeam);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::DoAutoWarPlundering

; 1183 : #ifdef NQM_TEAM_TRADE_ROUTES_CANCELLED_NOT_DESTROYED_FOR_WAR_DEFENDER_ON_DOW
; 1184 : 		if (bDefensivePact)

	cmp	BYTE PTR _bDefensivePact$[esp+264], bl
	je	SHORT $LN56@DoDeclareW

; 1185 : 		{
; 1186 : 			GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(m_eID, eTeam, true);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	push	edi
	push	eax
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ; CvGameTrade::CancelTradeBetweenTeams

; 1187 : 		}
; 1188 : 		else

	jmp	$LN473@DoDeclareW
$LN56@DoDeclareW:

; 1189 : 		{
; 1190 : 			// Returns units for cancelled trade routes to the defender
; 1191 : 			GC.getGame().GetGameTrade()->InvalidateTradeBetweenTeams(eTeam, m_eID);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::InvalidateTradeBetweenTeams

; 1192 : 			// Destroys attackers' units for cancelled trade routes
; 1193 : 			GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(m_eID, eTeam);

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	edi
	push	edx
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ; CvGameTrade::CancelTradeBetweenTeams
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	edi, edi
	npad	10
$LL54@DoDeclareW:

; 1201 : 			{
; 1202 : 				PlayerTypes eAttackingPlayer = (PlayerTypes)iAttackingPlayer;
; 1203 : 				CvPlayerAI& kAttackingPlayer = GET_PLAYER(eAttackingPlayer);
; 1204 : 				if (kAttackingPlayer.isAlive() && kAttackingPlayer.getTeam() == GetID())

	cmp	BYTE PTR [edi+ecx+2256], 0
	je	$LN53@DoDeclareW
	mov	eax, DWORD PTR [edi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN98@DoDeclareW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN99@DoDeclareW
$LN98@DoDeclareW:
	or	eax, -1
$LN99@DoDeclareW:
	mov	edx, DWORD PTR _this$[esp+268]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN53@DoDeclareW

; 1205 : 				{
; 1206 : 					for (int iDefendingPlayer = 0; iDefendingPlayer < MAX_MAJOR_CIVS; iDefendingPlayer++)

	xor	ebp, ebp
$LL479@DoDeclareW:

; 1207 : 					{
; 1208 : 						PlayerTypes eDefendingPlayer = (PlayerTypes)iDefendingPlayer;
; 1209 : 						CvPlayerAI& kDefendingPlayer = GET_PLAYER(eDefendingPlayer);
; 1210 : 						if (kDefendingPlayer.isAlive() && kDefendingPlayer.getTeam() == eTeam)

	cmp	BYTE PTR [ecx+ebp+2256], 0
	lea	esi, DWORD PTR [ecx+ebp]
	je	SHORT $LN49@DoDeclareW
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN115@DoDeclareW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN116@DoDeclareW
$LN115@DoDeclareW:
	or	eax, -1
$LN116@DoDeclareW:
	cmp	eax, DWORD PTR _eTeam$[esp+264]
	jne	SHORT $LN49@DoDeclareW

; 1211 : 						{
; 1212 : 							// Forget any of that liberation crud!
; 1213 : 							int iNumCitiesLiberated = kDefendingPlayer.GetDiplomacyAI()->GetNumCitiesLiberated(eAttackingPlayer);

	push	ebx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumCitiesLiberated@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumCitiesLiberated

; 1214 : 							kDefendingPlayer.GetDiplomacyAI()->ChangeNumCitiesLiberated(eAttackingPlayer, -iNumCitiesLiberated);

	neg	eax
	push	eax
	push	ebx
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeNumCitiesLiberated@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNumCitiesLiberated
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN49@DoDeclareW:
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	jl	SHORT $LL479@DoDeclareW
$LN53@DoDeclareW:

; 1194 : #else
; 1195 : 		GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(m_eID, eTeam);
; 1196 : 
; 1197 : 		if (!bDefensivePact)
; 1198 : 		{
; 1199 : #endif
; 1200 : 			for (int iAttackingPlayer = 0; iAttackingPlayer < MAX_MAJOR_CIVS; iAttackingPlayer++)

	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 1391192				; 00153a58H
	jl	$LL54@DoDeclareW
	mov	edi, DWORD PTR _eTeam$[esp+264]
	mov	esi, DWORD PTR _this$[esp+268]
$LN473@DoDeclareW:

; 1215 : 						}
; 1216 : 					}
; 1217 : 				}
; 1218 : 			}
; 1219 : 		}
; 1220 : 
; 1221 : #ifndef NEW_DEFENSIVE_PACT // EAP: Defensive Pact is now a peace treaty
; 1222 : 		// Auto War for Defensive Pacts
; 1223 : 		for (iI = 0; iI < MAX_TEAMS; iI++)
; 1224 : 		{
; 1225 : 			if (GET_TEAM((TeamTypes)iI).isAlive())
; 1226 : 			{
; 1227 : 				if (GET_TEAM((TeamTypes)iI).IsHasDefensivePact(eTeam))
; 1228 : 				{
; 1229 : 					GET_TEAM((TeamTypes)iI).DoDeclareWar(GetID(), /*bDefensivePact*/ true);
; 1230 : 				}
; 1231 : 			}
; 1232 : 		}
; 1233 : #endif
; 1234 : 	}
; 1235 : 
; 1236 : 	// Cancel Trade Deals, RAs, diplomats
; 1237 : 	if (!isBarbarian())

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 63					; 0000003fH
	je	$LN46@DoDeclareW

; 1238 : 	{
; 1239 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1240 : 		// Because second team is the "to" team, so cancel all of their deals to this team first
; 1241 : 		GC.getGame().GetGameDeals()->DoCancelDealsBetweenTeams(eTeam, GetID());
; 1242 : #else
; 1243 : 		GC.getGame().GetGameDeals()->DoCancelDealsBetweenTeams(GetID(), eTeam);

	mov	ebp, DWORD PTR _eTeam$[esp+264]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	push	eax
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?DoCancelDealsBetweenTeams@CvGameDeals@@QAEXW4TeamTypes@@0@Z ; CvGameDeals::DoCancelDealsBetweenTeams

; 1244 : #endif
; 1245 : 		CloseEmbassyAtTeam(eTeam);

	mov	edi, DWORD PTR _this$[esp+268]
	push	ebp
	mov	ecx, edi
	call	?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CloseEmbassyAtTeam

; 1246 : 		GET_TEAM(eTeam).CloseEmbassyAtTeam(m_eID);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, ebp
	imul	esi, 2984				; 00000ba8H
	push	eax
	add	ecx, esi
	call	?CloseEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::CloseEmbassyAtTeam

; 1247 : 		CancelResearchAgreement(eTeam);

	cmp	BYTE PTR [edi+ebp+2328], 0
	je	SHORT $LN128@DoDeclareW
	mov	BYTE PTR [edi+ebp+2328], 0
$LN128@DoDeclareW:

; 1248 : 		GET_TEAM(eTeam).CancelResearchAgreement(m_eID);

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [esi+edx]
	cmp	BYTE PTR [ecx+eax+2328], 0
	je	SHORT $LN139@DoDeclareW
	mov	BYTE PTR [ecx+eax+2328], 0
$LN139@DoDeclareW:

; 1249 : 		EvacuateDiplomatsAtTeam(eTeam);

	push	ebp
	mov	ecx, edi
	call	?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::EvacuateDiplomatsAtTeam

; 1250 : 		GET_TEAM(eTeam).EvacuateDiplomatsAtTeam(m_eID);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	add	ecx, esi
	call	?EvacuateDiplomatsAtTeam@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::EvacuateDiplomatsAtTeam
	mov	esi, DWORD PTR _this$[esp+268]
	mov	edi, ebp
$LN46@DoDeclareW:

; 1251 : 	}
; 1252 : 
; 1253 : 	// Bump Units out of places they shouldn't be
; 1254 : 	GC.getMap().verifyUnitValidPlot();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?verifyUnitValidPlot@CvMap@@QAEXXZ	; CvMap::verifyUnitValidPlot

; 1255 : 
; 1256 : 	setAtWar(eTeam, true);

	cmp	edi, DWORD PTR [esi+4]
	je	SHORT $LN153@DoDeclareW
	mov	edx, DWORD PTR tv1345[esp+268]
	mov	BYTE PTR [edx], 1
$LN153@DoDeclareW:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	push	1
	push	edi
	push	eax
	mov	eax, DWORD PTR [edx+728]
	call	eax

; 1257 : 	GET_TEAM(eTeam).setAtWar(GetID(), true);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, DWORD PTR [esi+4]
	mov	ebp, edi
	imul	ebp, 2984				; 00000ba8H
	lea	edx, DWORD PTR [ecx+ebp]
	mov	DWORD PTR tv1396[esp+268], ebp
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN169@DoDeclareW
	mov	BYTE PTR [edx+eax+1928], 1
$LN169@DoDeclareW:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx]
	push	1
	push	eax
	push	edx
	mov	edx, DWORD PTR [esi+728]
	call	edx

; 1258 : 
; 1259 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	esi, eax

; 1260 : 	if (pkScriptSystem)

	test	esi, esi
	je	SHORT $LN477@DoDeclareW

; 1261 : 	{
; 1262 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$223952[esp+268]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 1263 : 		args->Push(GetID());

	mov	edi, DWORD PTR _this$[esp+268]
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _args$223952[esp+268]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+280], 1
	call	eax

; 1264 : 		args->Push(eTeam);

	mov	ecx, DWORD PTR _args$223952[esp+268]
	mov	edx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR _eTeam$[esp+264]
	mov	eax, DWORD PTR [edx+8]
	push	ebx
	call	eax

; 1265 : 
; 1266 : 		bool bResult;
; 1267 : 		LuaSupport::CallHook(pkScriptSystem, "DeclareWar", args.get(), bResult);

	mov	edx, DWORD PTR _args$223952[esp+268]
	lea	ecx, DWORD PTR _bResult$223953[esp+268]
	push	ecx
	push	edx
	push	OFFSET $SG223954
	push	esi
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1268 : 	}

	lea	ecx, DWORD PTR _args$223952[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	jmp	SHORT $LN45@DoDeclareW
$LN477@DoDeclareW:
	mov	edi, DWORD PTR _this$[esp+268]
	mov	ebx, DWORD PTR _eTeam$[esp+264]
$LN45@DoDeclareW:

; 1269 : 
; 1270 : 	// One shot things
; 1271 : 	DoNowAtWarOrPeace(eTeam, true);

	push	1
	push	ebx
	mov	ecx, edi
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1272 : 	GET_TEAM(eTeam).DoNowAtWarOrPeace(GetID(), true);

	mov	eax, DWORD PTR [edi+4]
	push	1
	push	eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [eax+ebp]
	call	?DoNowAtWarOrPeace@CvTeam@@IAEXW4TeamTypes@@_N@Z ; CvTeam::DoNowAtWarOrPeace

; 1273 : 
; 1274 : 	// Meet the team if we haven't already
; 1275 : 	meet(eTeam, false);

	push	0
	push	ebx
	mov	ecx, edi
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet

; 1276 : 
; 1277 : 	// Update the ATTACKED players' Diplo AI
; 1278 : 	if (!isBarbarian())

	cmp	DWORD PTR [edi+4], 63			; 0000003fH
	je	$LN478@DoDeclareW

; 1279 : 	{
; 1280 : 		for (iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	xor	esi, esi
	npad	3
$LL43@DoDeclareW:

; 1281 : 		{
; 1282 : 			CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi

; 1283 : 			if (kPlayer.isAlive() && kPlayer.getTeam() == eTeam)

	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN42@DoDeclareW
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN206@DoDeclareW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN207@DoDeclareW
$LN206@DoDeclareW:
	or	eax, -1
$LN207@DoDeclareW:
	cmp	eax, ebx
	jne	SHORT $LN42@DoDeclareW

; 1284 : 				kPlayer.GetDiplomacyAI()->DoSomeoneDeclaredWarOnMe(GetID());

	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoSomeoneDeclaredWarOnMe@CvDiplomacyAI@@QAEXW4TeamTypes@@@Z ; CvDiplomacyAI::DoSomeoneDeclaredWarOnMe
$LN42@DoDeclareW:
	add	esi, 63236				; 0000f704H
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL43@DoDeclareW

; 1285 : 		}
; 1286 : 
; 1287 : 		// If we've made a peace treaty before, this is bad news (no minors though)
; 1288 : 		if (!GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [eax+ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN478@DoDeclareW

; 1289 : 		{
; 1290 : 			int iPeaceTreatyTurn = GetTurnMadePeaceTreatyWithTeam(eTeam);

	mov	esi, DWORD PTR [edi+ebx*4+1128]

; 1291 : 			if (iPeaceTreatyTurn != -1)

	cmp	esi, -1
	je	SHORT $LN478@DoDeclareW

; 1292 : 			{
; 1293 : 				int iTurnsSincePeace = GC.getGame().getElapsedGameTurns() - iPeaceTreatyTurn;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	sub	eax, esi

; 1294 : 				if (iTurnsSincePeace < GC.getPEACE_TREATY_LENGTH())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6688
	jge	SHORT $LN478@DoDeclareW

; 1295 : 				{
; 1296 : 					SetHasBrokenPeaceTreaty(true);

	mov	BYTE PTR [edi+129], 1
$LN478@DoDeclareW:

; 1297 : 				}
; 1298 : 			}
; 1299 : 		}
; 1300 : 	}
; 1301 : 
; 1302 : 	// Update interface stuff
; 1303 : 	if ((GetID() == GC.getGame().getActiveTeam()) || (eTeam == GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN35@DoDeclareW
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebx, eax
	jne	SHORT $LN36@DoDeclareW
$LN35@DoDeclareW:

; 1304 : 	{
; 1305 : 		DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	12					; 0000000cH
	call	eax

; 1306 : 		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	18					; 00000012H
	call	eax
$LN36@DoDeclareW:

; 1307 : 	}
; 1308 : 
; 1309 : 	if (GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN33@DoDeclareW

; 1310 : 	{
; 1311 : 		// Message everyone about what happened
; 1312 : 		if (!isBarbarian() && !(GET_TEAM(eTeam).isBarbarian()))

	mov	eax, 63					; 0000003fH
	cmp	DWORD PTR [edi+4], eax
	je	$LN33@DoDeclareW
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [ecx+ebp+4], eax
	je	$LN33@DoDeclareW

; 1313 : 		{
; 1314 : 			{
; 1315 : 				PlayerTypes ePlayer;
; 1316 : 				for (iI = 0; iI < MAX_PLAYERS; iI++)

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	xor	ebx, ebx
	mov	DWORD PTR _iI$[esp+268], ebx
	mov	DWORD PTR tv1938[esp+268], ebx
	npad	11
$LL32@DoDeclareW:

; 1317 : 				{
; 1318 : 					ePlayer = (PlayerTypes)iI;
; 1319 : 
; 1320 : 					if (GET_PLAYER(ePlayer).isAlive() && GET_PLAYER(ePlayer).GetNotifications())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [ebx+edx+2256], 0
	lea	ecx, DWORD PTR [ebx+edx]
	je	$LN31@DoDeclareW
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	test	eax, eax
	je	$LN31@DoDeclareW

; 1321 : 					{
; 1322 : 						// If this declaration is a minor following a major's declaration, don't send out these individual notifications
; 1323 : 						if (!bMinorAllyPact)

	cmp	BYTE PTR _bMinorAllyPact$[esp+264], 0
	jne	$LN31@DoDeclareW

; 1324 : 						{
; 1325 : 							// Players on team that declared
; 1326 : 							if (GET_PLAYER(ePlayer).getTeam() == GetID())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN257@DoDeclareW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN258@DoDeclareW
$LN257@DoDeclareW:
	or	edx, -1
$LN258@DoDeclareW:
	mov	edi, DWORD PTR _this$[esp+268]
	mov	edi, DWORD PTR [edi+4]
	cmp	edx, edi
	jne	$LN27@DoDeclareW

; 1327 : 							{
; 1328 : 								if (ePlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _iI$[esp+268], eax
	jne	$LN31@DoDeclareW

; 1329 : 								{
; 1330 : 									locString = Localization::Lookup("TXT_KEY_MISC_YOU_DECLARED_WAR_ON");

	lea	eax, DWORD PTR $T245142[esp+268]
	push	OFFSET $SG223981
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 2
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T245142[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1331 : 									locString << GET_TEAM(eTeam).getName().GetCString();

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR tv1396[esp+268]
	lea	eax, DWORD PTR $T245144[esp+268]
	add	ecx, edx
	push	eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+276], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	call	ebp
	lea	ecx, DWORD PTR $T245144[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1332 : 									DLLUI->AddMessage(0, (ePlayer), true, GC.getEVENT_MESSAGE_TIME(), locString.toUTF8()/*, "AS2D_DECLAREWAR", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_WARNING_TEXT")*/);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edi, DWORD PTR [ebx]
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	mov	DWORD PTR $T245606[esp+296], ecx
	push	0
	lea	ecx, DWORD PTR _locString$[esp+300]
	add	edi, 160				; 000000a0H
	call	esi
	mov	edx, DWORD PTR $T245606[esp+300]
	push	eax
	mov	eax, DWORD PTR _iI$[esp+304]
	push	edx
	mov	edx, DWORD PTR [edi]
	push	1
	push	eax
	push	0
	mov	ecx, ebx
	call	edx

; 1333 : 								}
; 1334 : 							}

	mov	ebx, DWORD PTR tv1938[esp+268]
	jmp	$LN31@DoDeclareW
$LN27@DoDeclareW:

; 1335 : 							// Players on team that got declared on
; 1336 : 							else if (GET_PLAYER(ePlayer).getTeam() == eTeam)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN285@DoDeclareW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN286@DoDeclareW
$LN285@DoDeclareW:
	or	edx, -1
$LN286@DoDeclareW:
	cmp	edx, DWORD PTR _eTeam$[esp+264]
	jne	$LN24@DoDeclareW

; 1337 : 							{
; 1338 : 								locString = Localization::Lookup("TXT_KEY_MISC_DECLARED_WAR_ON_YOU");

	lea	eax, DWORD PTR $T245145[esp+268]
	push	OFFSET $SG223992
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T245145[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1339 : 								locString << getName().GetCString();

	lea	ecx, DWORD PTR $T245147[esp+268]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+272]
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+276], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	call	ebp
	lea	ecx, DWORD PTR $T245147[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1340 : 								GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_WAR_ACTIVE_PLAYER, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID());

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR _this$[esp+268]
	push	-1
	lea	edi, DWORD PTR [ebx+edx]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$[esp+284]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+288]
	call	esi
	push	eax
	push	-190211195				; f4a99b85H
	jmp	$LN481@DoDeclareW
$LN24@DoDeclareW:

; 1341 : 							}
; 1342 : 							// Players that are on neither team, but know both parties
; 1343 : 							else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GetID()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eTeam))

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN307@DoDeclareW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN308@DoDeclareW
$LN307@DoDeclareW:
	or	eax, -1
$LN308@DoDeclareW:
	imul	eax, 2984				; 00000ba8H
	add	eax, edi
	mov	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [eax+edi+1848], 0
	je	$LN31@DoDeclareW
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	imul	eax, 2984				; 00000ba8H
	mov	ecx, DWORD PTR _eTeam$[esp+264]
	add	eax, edi
	cmp	BYTE PTR [eax+ecx+1848], 0
	je	$LN31@DoDeclareW

; 1344 : 							{
; 1345 : 								locString = Localization::Lookup("TXT_KEY_MISC_SOMEONE_DECLARED_WAR");

	lea	edx, DWORD PTR $T245148[esp+268]
	push	OFFSET $SG223998
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 6
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T245148[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1346 : 								locString << getName().GetCString() << GET_TEAM(eTeam).getName().GetCString();

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR tv1396[esp+268]
	lea	edx, DWORD PTR $T245150[esp+268]
	add	ecx, eax
	push	edx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+276], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+268]
	mov	edi, eax
	lea	eax, DWORD PTR $T245152[esp+268]
	push	eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+276], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	call	ebp
	push	edi
	lea	ecx, DWORD PTR _locString$[esp+272]
	call	ebp
	lea	ecx, DWORD PTR $T245152[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T245150[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1347 : 								GET_PLAYER(ePlayer).GetNotifications()->Add(NOTIFICATION_WAR, locString.toUTF8(), locString.toUTF8(), -1, -1, this->getLeaderID(), eTeam);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR _eTeam$[esp+264]
	lea	edi, DWORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR _this$[esp+268]
	push	edx
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _locString$[esp+284]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+288]
	call	esi
	push	eax
	push	-958154983				; c6e3b719H
$LN481@DoDeclareW:
	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN31@DoDeclareW:
	inc	DWORD PTR _iI$[esp+268]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 4047104				; 003dc100H
	mov	DWORD PTR tv1938[esp+268], ebx
	jl	$LL32@DoDeclareW

; 1348 : 							}
; 1349 : 						}
; 1350 : 					}
; 1351 : 				}
; 1352 : 			}
; 1353 : 
; 1354 : 			locString = Localization::Lookup("TXT_KEY_MISC_SOMEONE_DECLARES_WAR");

	lea	eax, DWORD PTR $T245153[esp+268]
	push	OFFSET $SG224004
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T245153[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 1355 : 			locString << getName().GetCString() << GET_TEAM(eTeam).getName().GetCString();

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR tv1396[esp+268]
	lea	eax, DWORD PTR $T245155[esp+268]
	add	ecx, edx
	push	eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+276], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, DWORD PTR _this$[esp+268]
	lea	ecx, DWORD PTR $T245157[esp+268]
	push	ecx
	mov	ecx, edi
	mov	ebx, eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+276], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _locString$[esp+272]
	call	ebp
	push	ebx
	lea	ecx, DWORD PTR _locString$[esp+272]
	call	ebp
	lea	ecx, DWORD PTR $T245157[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T245155[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1356 : 			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), locString.toUTF8(), -1, -1);

	lea	ecx, DWORD PTR _locString$[esp+268]
	call	esi
	test	eax, eax
	jne	SHORT $LN363@DoDeclareW
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN363@DoDeclareW:
	push	eax
	lea	ecx, DWORD PTR $T245158[esp+272]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	-1
	push	-1
	lea	edx, DWORD PTR $T245158[esp+276]
	push	edx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+288], 12		; 0000000cH
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
	lea	ecx, DWORD PTR $T245158[esp+268]
	mov	BYTE PTR __$EHRec$[esp+276], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	edi, DWORD PTR _this$[esp+268]
$LN33@DoDeclareW:

; 1357 : 		}
; 1358 : 	}
; 1359 : 
; 1360 : #ifdef NQM_GAME_EXTEND_TURN_TIMER_ON_LAST_MINUTE_WAR_DECLARATION_IF_SIMULTANEOUS
; 1361 : 	if (isHuman() && GET_TEAM(eTeam).isHuman())
; 1362 : 	{
; 1363 : #ifdef AUI_GAME_BETTER_HYBRID_MODE
; 1364 : 		if (getTurnOrder() == GET_TEAM(eTeam).getTurnOrder())
; 1365 : #else
; 1366 : 		if (isSimultaneousTurns() || GET_TEAM(eTeam).isSimultaneousTurns())
; 1367 : #endif
; 1368 : 		{
; 1369 : 			CvGame& kGame = GC.getGame();
; 1370 : 			if (kGame.isOption(GAMEOPTION_END_TURN_TIMER_ENABLED) && kGame.getElapsedGameTurns() > 0 && 
; 1371 : #ifdef AUI_GAME_RELATIVE_TURN_TIMERS
; 1372 : 				(kGame.getPitbossTurnTime() == 0 || kGame.isOption("GAMEOPTION_RELATIVE_TURN_TIMER")))
; 1373 : #else
; 1374 : 				kGame.getPitbossTurnTime() == 0)
; 1375 : #endif
; 1376 : 			{
; 1377 : 				const CvTurnTimerInfo& kTurnTimer = CvPreGame::turnTimerInfo();
; 1378 : 				float fBaseTurnTime = static_cast<float>(kTurnTimer.getBaseTime());
; 1379 : 
; 1380 : #ifdef AUI_GAME_PLAYER_BASED_TURN_LENGTH
; 1381 : 				FFastVector<int, true, c_eCiv5GameplayDLL>::const_iterator piCurMaxTurnLength = kGame.m_aiMaxTurnLengths.begin();
; 1382 : 				piCurMaxTurnLength += GET_PLAYER(kGame.getActivePlayer()).getTurnOrder();
; 1383 : 
; 1384 : 				float fGameTurnEnd = static_cast<float>(*piCurMaxTurnLength);
; 1385 : #else
; 1386 : 				float fGameTurnEnd = static_cast<float>(kGame.getMaxTurnLen());
; 1387 : 
; 1388 : 				//NOTE:  These times exclude the time used for AI processing.
; 1389 : 				//Time since the current player's turn started.  Used for measuring time for players in sequential turn mode.
; 1390 : 				float fTimeSinceCurrentTurnStart = kGame.m_curTurnTimer.Peek() + kGame.m_fCurrentTurnTimerPauseDelta;
; 1391 : #ifndef AUI_GAME_BETTER_HYBRID_MODE
; 1392 : 				//Time since the game (year) turn started.  Used for measuring time for players in simultaneous turn mode.
; 1393 : 				float fTimeSinceGameTurnStart = kGame.m_timeSinceGameTurnStart.Peek() + kGame.m_fCurrentTurnTimerPauseDelta;
; 1394 : #endif
; 1395 : #endif
; 1396 : #ifdef AUI_GAME_PLAYER_BASED_TURN_LENGTH
; 1397 : 				float fTimeElapsed = kGame.m_curTurnTimer.Peek() + kGame.m_fCurrentTurnTimerPauseDelta;
; 1398 : #elif defined(AUI_GAME_BETTER_HYBRID_MODE)
; 1399 : 				float fTimeElapsed = timeSinceCurrentTurnStart;
; 1400 : #else
; 1401 : 				float fTimeElapsed = (GET_PLAYER(kGame.getActivePlayer()).isSimultaneousTurns() ? fTimeSinceGameTurnStart : fTimeSinceCurrentTurnStart);
; 1402 : #endif
; 1403 : 				float fTimeToAdd = MAX(0.0f, fTimeElapsed - fGameTurnEnd + fBaseTurnTime);
; 1404 : 				if (fTimeToAdd > 0)
; 1405 : 				{
; 1406 : 					kGame.m_curTurnTimer.m_qStart += (__int64)(fTimeToAdd/ kGame.m_curTurnTimer.m_fFreq);
; 1407 : 					kGame.m_timeSinceGameTurnStart.m_qStart += (__int64)(fTimeToAdd / kGame.m_timeSinceGameTurnStart.m_fFreq);
; 1408 : 				}
; 1409 : 			}
; 1410 : 		}
; 1411 : 	}
; 1412 : #endif
; 1413 : 
; 1414 : 	int iMinorCivLoop;
; 1415 : 	int iMajorCivLoop;
; 1416 : 
; 1417 : 	// Minor Civs declaring war
; 1418 : 	if(isMinorCiv())

	mov	ecx, edi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	$LN17@DoDeclareW

; 1419 : 	{
; 1420 : 
; 1421 : 	}
; 1422 : 	// Major is declaring War
; 1423 : 	else
; 1424 : 	{
; 1425 : 		int iMajorCivLoop2;
; 1426 : 
; 1427 : 		// Update what every Major Civ sees
; 1428 : 		for(iMajorCivLoop = 0; iMajorCivLoop < MAX_MAJOR_CIVS; iMajorCivLoop++)

	xor	ebx, ebx
	mov	DWORD PTR tv2022[esp+268], ebx
	npad	5
$LL19@DoDeclareW:

; 1429 : 		{
; 1430 : 			if(GET_PLAYER((PlayerTypes) iMajorCivLoop).getTeam() == GetID())

	mov	eax, DWORD PTR tv2022[esp+268]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN376@DoDeclareW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN377@DoDeclareW
$LN376@DoDeclareW:
	or	eax, -1
$LN377@DoDeclareW:
	cmp	eax, DWORD PTR [edi+4]
	jne	$LN18@DoDeclareW

; 1431 : 			{
; 1432 : 				if(GET_PLAYER((PlayerTypes) iMajorCivLoop).isAlive())

	mov	edx, DWORD PTR tv2022[esp+268]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edx+eax+2256], 0
	je	$LN18@DoDeclareW

; 1433 : 				{
; 1434 : 					// Alter Grand Strategy stats for all Majors in the game whove met this declaring war Major
; 1435 : 					for(iMajorCivLoop2 = 0; iMajorCivLoop2 < MAX_MAJOR_CIVS; iMajorCivLoop2++)

	xor	ebp, ebp
	xor	esi, esi
$LL14@DoDeclareW:

; 1436 : 					{
; 1437 : 						// I don't care if it's me
; 1438 : 						if(iMajorCivLoop != iMajorCivLoop2)

	cmp	ebx, ebp
	je	$LN13@DoDeclareW

; 1439 : 						{
; 1440 : 							// Have I actually met this player declaring war?
; 1441 : 							if(GET_TEAM(GET_PLAYER((PlayerTypes) iMajorCivLoop2).getTeam()).isHasMet(GET_PLAYER((PlayerTypes) iMajorCivLoop).getTeam()))

	mov	ecx, DWORD PTR tv2022[esp+268]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN395@DoDeclareW
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN396@DoDeclareW
$LN395@DoDeclareW:
	or	edx, -1
$LN396@DoDeclareW:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN406@DoDeclareW
	mov	edi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _this$[esp+268]
	jmp	SHORT $LN407@DoDeclareW
$LN406@DoDeclareW:
	or	eax, -1
$LN407@DoDeclareW:
	imul	eax, 2984				; 00000ba8H
	add	eax, edx
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [eax+edx+1848], 0
	je	SHORT $LN13@DoDeclareW

; 1442 : 							{
; 1443 : 								GET_PLAYER((PlayerTypes) iMajorCivLoop2).GetDiplomacyAI()->DoPlayerDeclaredWarOnSomeone((PlayerTypes) iMajorCivLoop, eTeam);

	mov	eax, DWORD PTR _eTeam$[esp+264]
	push	eax
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoPlayerDeclaredWarOnSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@W4TeamTypes@@@Z ; CvDiplomacyAI::DoPlayerDeclaredWarOnSomeone

; 1444 : 
; 1445 : 								if(!bDefensivePact)

	cmp	BYTE PTR _bDefensivePact$[esp+264], 0
	jne	SHORT $LN13@DoDeclareW

; 1446 : 								{
; 1447 : 									// Major declaring war on Minor
; 1448 : 									if(GET_TEAM(eTeam).isMinorCiv())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR tv1396[esp+268]
	add	ecx, edx
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	SHORT $LN8@DoDeclareW

; 1449 : 									{
; 1450 : 										GET_PLAYER((PlayerTypes) iMajorCivLoop2).GetDiplomacyAI()->ChangeOtherPlayerNumMinorsAttacked((PlayerTypes) iMajorCivLoop, 1);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	lea	ecx, DWORD PTR [esi+eax]
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeOtherPlayerNumMinorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeOtherPlayerNumMinorsAttacked

; 1451 : 									}
; 1452 : 									// Major declaring war on Major
; 1453 : 									else

	jmp	SHORT $LN13@DoDeclareW
$LN8@DoDeclareW:

; 1454 : 									{
; 1455 : 										GET_PLAYER((PlayerTypes) iMajorCivLoop2).GetDiplomacyAI()->ChangeOtherPlayerNumMajorsAttacked((PlayerTypes) iMajorCivLoop, 1, eTeam);

	mov	edx, DWORD PTR _eTeam$[esp+264]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	1
	add	ecx, esi
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeOtherPlayerNumMajorsAttacked@CvDiplomacyAI@@QAEXW4PlayerTypes@@HW4TeamTypes@@@Z ; CvDiplomacyAI::ChangeOtherPlayerNumMajorsAttacked
$LN13@DoDeclareW:
	add	esi, 63236				; 0000f704H
	inc	ebp
	cmp	esi, 1391192				; 00153a58H
	jl	$LL14@DoDeclareW

; 1456 : 									}
; 1457 : 								}
; 1458 : 							}
; 1459 : 						}
; 1460 : 					}
; 1461 : 
; 1462 : 					// Declaring war on Minor
; 1463 : 					for(iMinorCivLoop = MAX_MAJOR_CIVS; iMinorCivLoop < MAX_CIV_PLAYERS; iMinorCivLoop++)

	mov	esi, 1391192				; 00153a58H
	npad	11
$LL6@DoDeclareW:

; 1464 : 					{
; 1465 : 						// Now loop through all players on this team to nullify Quests for them
; 1466 : 						if(GET_PLAYER((PlayerTypes) iMinorCivLoop).getTeam() == eTeam)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN431@DoDeclareW
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN432@DoDeclareW
$LN431@DoDeclareW:
	or	eax, -1
$LN432@DoDeclareW:
	cmp	eax, DWORD PTR _eTeam$[esp+264]
	jne	SHORT $LN5@DoDeclareW

; 1467 : 						{
; 1468 : 							if(GET_PLAYER((PlayerTypes) iMinorCivLoop).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	je	SHORT $LN5@DoDeclareW

; 1469 : 							{
; 1470 : 								// Increment # of Minors this player has attacked - note that this will be called EACH time a team declares war on a Minor,
; 1471 : 								// even the same Minor multiple times.  The current design assumes that once a player is at war with a Minor it's forever, so this is fine
; 1472 : 								//antonjs: consider: this statement is no longer valid, since current design allows peace to be made; update the implementation
; 1473 : 								if(!isMinorCiv() && !bDefensivePact)

	mov	ecx, edi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN5@DoDeclareW
	cmp	BYTE PTR _bDefensivePact$[esp+264], al
	jne	SHORT $LN5@DoDeclareW

; 1474 : 								{
; 1475 : 									ChangeNumMinorCivsAttacked(1);

	mov	eax, DWORD PTR [edi+124]
	lea	ecx, DWORD PTR [eax+1]
	cmp	eax, ecx
	je	SHORT $LN447@DoDeclareW
	mov	DWORD PTR [edi+124], ecx
$LN447@DoDeclareW:

; 1476 : 
; 1477 : 									GET_PLAYER((PlayerTypes) iMinorCivLoop).GetMinorCivAI()->DoTeamDeclaredWarOnMe(GetID());

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	push	eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoTeamDeclaredWarOnMe@CvMinorCivAI@@QAEXW4TeamTypes@@@Z ; CvMinorCivAI::DoTeamDeclaredWarOnMe
$LN5@DoDeclareW:
	add	esi, 63236				; 0000f704H
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL6@DoDeclareW
$LN18@DoDeclareW:

; 1419 : 	{
; 1420 : 
; 1421 : 	}
; 1422 : 	// Major is declaring War
; 1423 : 	else
; 1424 : 	{
; 1425 : 		int iMajorCivLoop2;
; 1426 : 
; 1427 : 		// Update what every Major Civ sees
; 1428 : 		for(iMajorCivLoop = 0; iMajorCivLoop < MAX_MAJOR_CIVS; iMajorCivLoop++)

	mov	eax, DWORD PTR tv2022[esp+268]
	add	eax, 63236				; 0000f704H
	inc	ebx
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv2022[esp+268], eax
	jl	$LL19@DoDeclareW
$LN17@DoDeclareW:

; 1478 : 								}
; 1479 : 							}
; 1480 : 						}
; 1481 : 					}
; 1482 : 				}
; 1483 : 			}
; 1484 : 		}
; 1485 : 	}
; 1486 : }

	lea	ecx, DWORD PTR _locString$[esp+268]
	mov	DWORD PTR __$EHRec$[esp+276], -1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	pop	ebp
$LN59@DoDeclareW:
	mov	ecx, DWORD PTR __$EHRec$[esp+264]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 252				; 000000fcH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$0:
	lea	ecx, DWORD PTR _locString$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR _args$223952[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$2:
	lea	ecx, DWORD PTR $T245142[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$3:
	lea	ecx, DWORD PTR $T245144[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$4:
	lea	ecx, DWORD PTR $T245145[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$5:
	lea	ecx, DWORD PTR $T245147[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$6:
	lea	ecx, DWORD PTR $T245148[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$7:
	lea	ecx, DWORD PTR $T245150[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$8:
	lea	ecx, DWORD PTR $T245152[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$9:
	lea	ecx, DWORD PTR $T245153[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$10:
	lea	ecx, DWORD PTR $T245155[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$11:
	lea	ecx, DWORD PTR $T245157[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z$12:
	lea	ecx, DWORD PTR $T245158[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ENDP	; CvTeam::DoDeclareWar
PUBLIC	?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z	; CvTeam::makePeace
; Function compile flags: /Ogtpy
;	COMDAT ?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bBumpUnits$ = 12					; size = 1
_bSuppressNotification$ = 16				; size = 1
?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z PROC		; CvTeam::makePeace, COMDAT
; _this$ = ecx

; 1644 : 	DoMakePeace(eTeam, bBumpUnits, bSuppressNotification);

	jmp	?DoMakePeace@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoMakePeace
?makePeace@CvTeam@@QAEXW4TeamTypes@@_N1@Z ENDP		; CvTeam::makePeace
_TEXT	ENDS
PUBLIC	??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+4]
	cmp	eax, esi
	je	SHORT $LN9@erase
	push	edi
$LL11@erase:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, esi
	jne	SHORT $LL11@erase
	mov	edx, DWORD PTR __Where$[esp+4]
	pop	edi
$LN9@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [ecx+8], -4			; fffffffcH
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@2
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@2
	push	ebx
	npad	4
$LL28@erase@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@2
	pop	ebx
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@2:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+4]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [edi*4+4]
	lea	ebx, DWORD PTR [ebx*4+4]
	lea	eax, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [ebx+edi]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > >::Alloc
	sub	eax, ebx
	mov	ecx, eax
	and	ecx, 3
	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi+12]
	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	edx, eax
	and	edx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx
	mov	edx, DWORD PTR [esi]
	pop	edi
	add	ecx, 4
	pop	esi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4ResourceTypes@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW42@00@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Umove<enum ResourceTypes *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAW4ResourceTypes@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T246278 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$246281 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4ResourceTypes@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW42@00@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Umove<enum ResourceTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$246281[esp]
	mov	BYTE PTR $T246278[esp+4], 0
	mov	eax, DWORD PTR $T246278[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4ResourceTypes@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW42@00@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Umove<enum ResourceTypes *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215406 = 16					; size = 4
__Tmp$215396 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215396[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215406[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >
_TEXT	ENDS
PUBLIC	?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::declareWar
EXTRN	?RefreshDangerPlots@CvPlayerManager@@SAXXZ:PROC	; CvPlayerManager::RefreshDangerPlots
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDefensivePact$ = 12					; size = 1
?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::declareWar, COMDAT
; _this$ = ecx

; 1154 : 	DoDeclareWar(eTeam, bDefensivePact);

	mov	eax, DWORD PTR _bDefensivePact$[esp-4]
	mov	edx, DWORD PTR _eTeam$[esp-4]
	push	0
	push	eax
	push	edx
	call	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoDeclareWar

; 1155 : 
; 1156 : 	CvPlayerManager::RefreshDangerPlots();

	call	?RefreshDangerPlots@CvPlayerManager@@SAXXZ ; CvPlayerManager::RefreshDangerPlots

; 1157 : }

	ret	8
?declareWar@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::declareWar
_TEXT	ENDS
EXTRN	?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z:PROC ; CvMinorCivAI::DoFirstContactWithMajor
EXTRN	?DoPlayerMetSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@0@Z:PROC ; CvDiplomacyAI::DoPlayerMetSomeone
EXTRN	?DoFirstContact@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::DoFirstContact
EXTRN	?DoUpdateProximityToPlayer@CvPlayer@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlayer::DoUpdateProximityToPlayer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$1
__ehfuncinfo$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
_iMyPlayersLoop$225739 = -76				; size = 4
tv906 = -72						; size = 4
$T246805 = -72						; size = 1
_strSummary$225797 = -68				; size = 28
_strBuffer$225789 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bSuppressMessages$ = 12				; size = 1
?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::makeHasMet, COMDAT
; _this$ = ecx

; 3613 : {

	push	-1
	push	__ehhandler$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	ebp

; 3614 : 	int iI;
; 3615 : 
; 3616 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3617 : 	CvAssertMsg(eIndex < MAX_TEAMS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 3618 : 
; 3619 : 	if(!isHasMet(eIndex))

	mov	ebp, DWORD PTR _eIndex$[esp+84]
	mov	ebx, ecx
	mov	al, BYTE PTR [ebx+ebp+1848]
	mov	DWORD PTR _this$[esp+88], ebx
	test	al, al
	jne	$LN36@makeHasMet

; 3620 : 	{
; 3621 : 		m_abHasMet[eIndex] = true;

	mov	BYTE PTR [ebx+ebp+1848], 1

; 3622 : 
; 3623 : 		SetTurnTeamMet(eIndex, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 3624 : 
; 3625 : 		updateTechShare();

	mov	ecx, ebx
	mov	DWORD PTR [ebx+ebp*4+2568], eax
	call	?updateTechShare@CvTeam@@IAEXXZ		; CvTeam::updateTechShare

; 3626 : 
; 3627 : #ifdef AUI_GAME_OBSERVER_MEET_ALL_TEAMS
; 3628 : 		if (bForObserver)
; 3629 : 		{
; 3630 : 			if ((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))
; 3631 : 			{
; 3632 : 				DLLUI->setDirty(Score_DIRTY_BIT, true);
; 3633 : 			}
; 3634 : 			// Report event
; 3635 : 			gDLL->GameplayMetTeam(GetID(), eIndex);
; 3636 : 			return;
; 3637 : 		}
; 3638 : #endif
; 3639 : 
; 3640 : 		if(GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	3
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN209@makeHasMet

; 3641 : 		{
; 3642 : 			if(isHuman())

	mov	ecx, ebx
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	je	SHORT $LN209@makeHasMet

; 3643 : 			{
; 3644 : 				if(GetID() != eIndex)

	cmp	DWORD PTR [ebx+4], ebp
	je	SHORT $LN209@makeHasMet

; 3645 : 				{
; 3646 : 					declareWar(eIndex);

	push	0
	push	0
	push	ebp
	mov	ecx, ebx
	call	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoDeclareWar
	call	?RefreshDangerPlots@CvPlayerManager@@SAXXZ ; CvPlayerManager::RefreshDangerPlots
$LN209@makeHasMet:

; 3647 : 				}
; 3648 : 			}
; 3649 : 		}
; 3650 : 
; 3651 : 		int iMyPlayersLoop;
; 3652 : 		PlayerTypes eMyPlayer;
; 3653 : 
; 3654 : 		int iTheirPlayersLoop;
; 3655 : 		PlayerTypes eTheirPlayer;
; 3656 : 
; 3657 : 		int iThirdPlayersLoop;
; 3658 : 		PlayerTypes eThirdPlayer;
; 3659 : 
; 3660 : 		// First Contact in Diplo AI (Civ 5)
; 3661 : 		for(iMyPlayersLoop = 0; iMyPlayersLoop < MAX_CIV_PLAYERS; iMyPlayersLoop++)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _iMyPlayersLoop$225739[esp+96], edi
	mov	DWORD PTR tv906[esp+96], esi
	npad	6
$LL32@makeHasMet:

; 3662 : 		{
; 3663 : 			eMyPlayer = (PlayerTypes) iMyPlayersLoop;
; 3664 : 
; 3665 : 			if(GET_PLAYER(eMyPlayer).isAlive())

	cmp	BYTE PTR [esi+edx+2256], 0
	je	$LN31@makeHasMet

; 3666 : 			{
; 3667 : 				if(GET_PLAYER(eMyPlayer).getTeam() == GetID())

	mov	eax, DWORD PTR [esi+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN71@makeHasMet
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN72@makeHasMet
$LN71@makeHasMet:
	or	eax, -1
$LN72@makeHasMet:
	cmp	eax, DWORD PTR [ebx+4]
	jne	$LN31@makeHasMet

; 3668 : 				{
; 3669 : 					// Now loop through players on Their team
; 3670 : 					for(iTheirPlayersLoop = 0; iTheirPlayersLoop < MAX_CIV_PLAYERS; iTheirPlayersLoop++)

	xor	ebp, ebp
	xor	ebx, ebx
$LL27@makeHasMet:

; 3671 : 					{
; 3672 : 						eTheirPlayer = (PlayerTypes) iTheirPlayersLoop;
; 3673 : 
; 3674 : 						// Don't calculate proximity to oneself!
; 3675 : 						if(eMyPlayer != eTheirPlayer)

	cmp	edi, ebp
	je	$LN26@makeHasMet

; 3676 : 						{
; 3677 : 							if(GET_PLAYER(eTheirPlayer).isAlive())

	cmp	BYTE PTR [ebx+edx+2256], 0
	je	$LN26@makeHasMet

; 3678 : 							{
; 3679 : 								if(GET_PLAYER(eTheirPlayer).getTeam() == eIndex)

	mov	eax, DWORD PTR [ebx+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN90@makeHasMet
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN91@makeHasMet
$LN90@makeHasMet:
	or	eax, -1
$LN91@makeHasMet:
	cmp	eax, DWORD PTR _eIndex$[esp+92]
	jne	$LN26@makeHasMet

; 3680 : 								{
; 3681 : 									// Begin contact stuff here
; 3682 : 
; 3683 : 									// Update Proximity between players
; 3684 : 									GET_PLAYER(eMyPlayer).DoUpdateProximityToPlayer(eTheirPlayer);

	push	ebp
	lea	ecx, DWORD PTR [esi+edx]
	call	?DoUpdateProximityToPlayer@CvPlayer@@QAEXW4PlayerTypes@@@Z ; CvPlayer::DoUpdateProximityToPlayer

; 3685 : 									GET_PLAYER(eTheirPlayer).DoUpdateProximityToPlayer(eMyPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	lea	ecx, DWORD PTR [ebx+edx]
	call	?DoUpdateProximityToPlayer@CvPlayer@@QAEXW4PlayerTypes@@@Z ; CvPlayer::DoUpdateProximityToPlayer

; 3686 : 
; 3687 : 									// First contact Diplo changes (no Minors)
; 3688 : 									if(!isMinorCiv())

	mov	ecx, DWORD PTR _this$[esp+96]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN21@makeHasMet

; 3689 : 									{
; 3690 : 										GET_PLAYER(eMyPlayer).GetDiplomacyAI()->DoFirstContact(eTheirPlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	push	ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoFirstContact@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::DoFirstContact
$LN21@makeHasMet:

; 3691 : 									}
; 3692 : 
; 3693 : 									// THIRD party loop - let everyone else know that someone met someone!
; 3694 : 									for(iThirdPlayersLoop = 0; iThirdPlayersLoop < MAX_CIV_PLAYERS; iThirdPlayersLoop++)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	edi, edi
	xor	esi, esi
$LL20@makeHasMet:

; 3695 : 									{
; 3696 : 										eThirdPlayer = (PlayerTypes) iThirdPlayersLoop;
; 3697 : 
; 3698 : 										if(GET_PLAYER(eThirdPlayer).isAlive())

	cmp	BYTE PTR [esi+edx+2256], 0
	lea	ecx, DWORD PTR [esi+edx]
	je	SHORT $LN19@makeHasMet

; 3699 : 										{
; 3700 : 											// Don't notify diplo AI if we're the one meeting or the one being met
; 3701 : 											if(eThirdPlayer != eMyPlayer && eThirdPlayer != eTheirPlayer)

	mov	eax, DWORD PTR _iMyPlayersLoop$225739[esp+96]
	cmp	edi, eax
	je	SHORT $LN19@makeHasMet
	cmp	edi, ebp
	je	SHORT $LN19@makeHasMet

; 3702 : 											{
; 3703 : 												GET_PLAYER(eThirdPlayer).GetDiplomacyAI()->DoPlayerMetSomeone(eMyPlayer, eTheirPlayer);

	push	ebp
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoPlayerMetSomeone@CvDiplomacyAI@@QAEXW4PlayerTypes@@0@Z ; CvDiplomacyAI::DoPlayerMetSomeone
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN19@makeHasMet:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 3983868				; 003cc9fcH
	jl	SHORT $LL20@makeHasMet
	mov	esi, DWORD PTR tv906[esp+96]
	mov	edi, DWORD PTR _iMyPlayersLoop$225739[esp+96]
$LN26@makeHasMet:
	add	ebx, 63236				; 0000f704H
	inc	ebp
	cmp	ebx, 3983868				; 003cc9fcH
	jl	$LL27@makeHasMet
	mov	ebp, DWORD PTR _eIndex$[esp+92]
	mov	ebx, DWORD PTR _this$[esp+96]
$LN31@makeHasMet:
	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 3983868				; 003cc9fcH
	mov	DWORD PTR _iMyPlayersLoop$225739[esp+96], edi
	mov	DWORD PTR tv906[esp+96], esi
	jl	$LL32@makeHasMet

; 3704 : 											}
; 3705 : 										}
; 3706 : 									}
; 3707 : 								}
; 3708 : 							}
; 3709 : 						}
; 3710 : 					}
; 3711 : 				}
; 3712 : 			}
; 3713 : 		}
; 3714 : 
; 3715 : 		if(GET_TEAM(eIndex).isHuman())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, ebp
	imul	esi, 2984				; 00000ba8H
	add	ecx, esi
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	je	SHORT $LN12@makeHasMet

; 3716 : 		{
; 3717 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	npad	8
$LL14@makeHasMet:

; 3718 : 			{
; 3719 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+edx+2256], 0
	lea	ecx, DWORD PTR [edi+edx]
	je	SHORT $LN13@makeHasMet

; 3720 : 				{
; 3721 : 					if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN123@makeHasMet
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN124@makeHasMet
$LN123@makeHasMet:
	or	eax, -1
$LN124@makeHasMet:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN13@makeHasMet

; 3722 : 					{
; 3723 : 						if(!(GET_PLAYER((PlayerTypes)iI).isHuman()))

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN13@makeHasMet

; 3724 : 						{
; 3725 : 							GET_PLAYER((PlayerTypes)iI).clearResearchQueue();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?clearResearchQueue@CvPlayer@@QAEXXZ	; CvPlayer::clearResearchQueue
$LN13@makeHasMet:
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL14@makeHasMet
$LN12@makeHasMet:

; 3726 : 							//GET_PLAYER((PlayerTypes)iI).AI_makeProductionDirty();
; 3727 : 						}
; 3728 : 					}
; 3729 : 				}
; 3730 : 			}
; 3731 : 		}
; 3732 : 
; 3733 : 		if((GetID() == GC.getGame().getActiveTeam()) || (eIndex == GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [ebx+4]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	je	SHORT $LN7@makeHasMet
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebp, eax
	jne	SHORT $LN8@makeHasMet
$LN7@makeHasMet:

; 3734 : 		{
; 3735 : 			DLLUI->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	12					; 0000000cH
	call	eax
$LN8@makeHasMet:

; 3736 : 		}
; 3737 : 
; 3738 : 		if(GET_TEAM(eIndex).isMinorCiv())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	$LN1@makeHasMet

; 3739 : 		{
; 3740 : 			int iCapitalX = -1;
; 3741 : 			int iCapitalY = -1;
; 3742 : 			int iCapitalID = -1;
; 3743 : 
; 3744 : 			// Minor reveals his capital to the player so that he can click on the City to contact
; 3745 : 			CvCity* pCap = GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getCapitalCity();

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	or	edi, -1
	lea	ecx, DWORD PTR [esi+edx]
	or	ebp, edi
	or	ebx, edi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 3746 : 			if(pCap)

	test	eax, eax
	je	SHORT $LN4@makeHasMet

; 3747 : 			{
; 3748 : 				iCapitalX  = pCap->getX();

	mov	edi, DWORD PTR [eax+96]

; 3749 : 				iCapitalY  = pCap->getY();

	mov	ebp, DWORD PTR [eax+108]

; 3750 : 				iCapitalID = pCap->GetID();

	mov	ebx, DWORD PTR [eax+120]

; 3751 : 				CvPlot* pCapPlot = pCap->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 3752 : 				if(pCapPlot)

	test	eax, eax
	je	SHORT $LN4@makeHasMet

; 3753 : 				{
; 3754 : 					pCapPlot->setRevealed(GetID(), true);

	mov	ecx, DWORD PTR _this$[esp+96]
	mov	ecx, DWORD PTR [ecx+4]
	push	-1
	push	0
	push	1
	push	ecx
	mov	ecx, eax
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed

; 3755 : 					GC.getMap().updateDeferredFog();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN4@makeHasMet:

; 3756 : 				}
; 3757 : 			}
; 3758 : 
; 3759 : 			// First contact with major stuff
; 3760 : 			if(!isMinorCiv())

	mov	ecx, DWORD PTR _this$[esp+96]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN3@makeHasMet

; 3761 : 			{
; 3762 : 				GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).GetMinorCivAI()->DoFirstContactWithMajor(GetID(), /*bSuppressMessages*/ isAtWar(eIndex));

	mov	edx, DWORD PTR _eIndex$[esp+92]
	mov	eax, DWORD PTR _this$[esp+96]
	mov	cl, BYTE PTR [edx+eax+1928]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	BYTE PTR $T246805[esp+96], cl
	lea	ecx, DWORD PTR [esi+edx]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR $T246805[esp+96]
	mov	edx, DWORD PTR _this$[esp+96]
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	ecx, eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?DoFirstContactWithMajor@CvMinorCivAI@@QAEXW4TeamTypes@@_N@Z ; CvMinorCivAI::DoFirstContactWithMajor
$LN3@makeHasMet:

; 3763 : 			}
; 3764 : 
; 3765 : 			if(!isAtWar(eIndex))

	mov	eax, DWORD PTR _eIndex$[esp+92]
	mov	ecx, DWORD PTR _this$[esp+96]
	cmp	BYTE PTR [eax+ecx+1928], 0
	jne	$LN210@makeHasMet

; 3766 : 			{
; 3767 : 				// Notify the Team that they met someone
; 3768 : 				if(!bSuppressMessages)

	cmp	BYTE PTR _bSuppressMessages$[esp+92], 0
	jne	$LN210@makeHasMet

; 3769 : 				{
; 3770 : 					CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_MET_MINOR_CIV", GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getNameKey());

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+edx]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	eax, DWORD PTR _strBuffer$225789[esp+100]
	push	OFFSET $SG225796
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH

; 3771 : 					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_MET_MINOR_CIV", GET_PLAYER(GET_TEAM(eIndex).getLeaderID()).getNameKey());

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	edx, DWORD PTR _strSummary$225797[esp+100]
	push	OFFSET $SG225799
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH

; 3772 : 
; 3773 : 					AddNotification(NOTIFICATION_MET_MINOR, strBuffer, strSummary, iCapitalX, iCapitalY, iCapitalID);

	lea	ecx, DWORD PTR _strSummary$225797[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	ebx
	push	ebp
	push	edi
	push	eax
	lea	ecx, DWORD PTR _strBuffer$225789[esp+116]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+116]
	push	eax
	push	981828329				; 3a8582e9H
	call	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification

; 3774 : 				}

	lea	ecx, DWORD PTR _strSummary$225797[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$225789[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebp, DWORD PTR _eIndex$[esp+92]
	mov	ebx, DWORD PTR _this$[esp+96]
	jmp	SHORT $LN1@makeHasMet
$LN210@makeHasMet:
	mov	ebp, eax
	mov	ebx, ecx
$LN1@makeHasMet:

; 3775 : 			}
; 3776 : 		}
; 3777 : 
; 3778 : 		// Report event
; 3779 : 		gDLL->GameplayMetTeam(GetID(), eIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+740]
	push	ebp
	push	edx
	call	eax
	pop	edi
	pop	esi
$LN36@makeHasMet:

; 3780 : 	}
; 3781 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strBuffer$225789[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strSummary$225797[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?makeHasMet@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::makeHasMet
PUBLIC	?clear@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXXZ PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear
	push	edi
$LL42@clear:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear
	pop	edi
$LN40@clear:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXXZ ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$247249 = 8					; size = 1
__Cat$247176 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$228605 = 12					; size = 4
__Tmp$228595 = 12					; size = 4
__Newvec$228580 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T247246 = 16						; size = 1
$T247173 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@KAXXZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4ResourceTypes@@@std@@YAPAW4ResourceTypes@@IPAW41@@Z ; std::_Allocate<enum ResourceTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$228580[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW43@IABW43@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$247176[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T247173[ebp], 0
	mov	ecx, DWORD PTR $T247173[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$228580[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T247246[ebp], 0
	mov	edx, DWORD PTR $T247246[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$247249[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$228580[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4ResourceTypes@@PAW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAPAW4ResourceTypes@@PAW41@00AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum ResourceTypes *,enum ResourceTypes *,std::allocator<enum ResourceTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$228580[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$228595[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4ResourceTypes@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW42@00@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Umove<enum ResourceTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$228595[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW43@IABW43@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$228595[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z ; std::fill<enum ResourceTypes *,enum ResourceTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$228605[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4ResourceTypes@@@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEPAW4ResourceTypes@@PAW42@00@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Umove<enum ResourceTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4ResourceTypes@@PAW41@@stdext@@YAPAW4ResourceTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum ResourceTypes *,enum ResourceTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$228605[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4ResourceTypes@@W41@@std@@YAXPAW4ResourceTypes@@0ABW41@@Z ; std::fill<enum ResourceTypes *,enum ResourceTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);
; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _nBytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pData$[esp]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	edi, DWORD PTR [edi*4+4]
	lea	eax, DWORD PTR [edi+edx]
	push	eax
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	ecx, eax
	and	ecx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	add	edx, 4
	pop	edi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z
_TEXT	SEGMENT
$T247349 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize, COMDAT
; _this$ = ecx

; 718  : 		if (size() < _Newsize)

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	cmp	edx, eax
	jbe	SHORT $LN36@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
$LN36@resize:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T247349[esp+12]
	push	eax
	call	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
$LN1@resize:
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXIW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z
_TEXT	SEGMENT
__Mid$229501 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$229501[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$229501[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$229501[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$229501[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int,CvWeightedVector<enum TeamTypes,63,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@ABW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::insert
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+4]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [edi*4+4]
	lea	ebx, DWORD PTR [ebx*4+4]
	lea	eax, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [ebx+edi]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > >::Alloc
	sub	eax, ebx
	mov	ecx, eax
	and	ecx, 3
	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi+12]
	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	edx, eax
	and	edx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx
	mov	edx, DWORD PTR [esi]
	pop	edi
	add	ecx, 4
	pop	esi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ; std::sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z PROC ; std::sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0@Z ENDP ; std::sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T247864 = -4						; size = 4
$T247839 = 8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXI@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ecx

; 713  : 		resize(_Newsize, _Ty());

	mov	edx, DWORD PTR __Newsize$[esp]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T247864[esp+12], 0
	cmp	edx, eax
	jbe	SHORT $LN38@resize@2
	lea	edi, DWORD PTR $T247864[esp+12]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
	pop	edi
	pop	esi

; 714  : 		}

	pop	ecx
	ret	4
$LN38@resize@2:

; 713  : 		resize(_Newsize, _Ty());

	jae	SHORT $LN3@resize@2
	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T247839[esp+16]
	push	eax
	call	?erase@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@V?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@0@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::erase
$LN3@resize@2:
	pop	edi
	pop	esi

; 714  : 		}

	pop	ecx
	ret	4
?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXI@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@4
	xor	eax, eax
	jmp	SHORT $LN10@push_back@4
$LN9@push_back@4:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@4:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@4:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >
_TEXT	ENDS
PUBLIC	?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectCount
EXTRN	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeNumResourceUsed
EXTRN	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z:PROC ; CvProjectEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z:PROC	; CvProjectEntry::GetProjectsNeeded
EXTRN	?makeNukesValid@CvGame@@QAEX_N@Z:PROC		; CvGame::makeNukesValid
EXTRN	?IsAllowsNukes@CvProjectEntry@@QBE_NXZ:PROC	; CvProjectEntry::IsAllowsNukes
EXTRN	?makeSpecialUnitValid@CvGame@@QAEXW4SpecialUnitTypes@@@Z:PROC ; CvGame::makeSpecialUnitValid
EXTRN	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetEveryoneSpecialUnit
EXTRN	?testVictory@CvGame@@QAEXXZ:PROC		; CvGame::testVictory
EXTRN	?testVictory@CvGame@@QBE_NW4VictoryTypes@@W4TeamTypes@@PA_N@Z:PROC ; CvGame::testVictory
EXTRN	?GetTechShare@CvProjectEntry@@QBEHXZ:PROC	; CvProjectEntry::GetTechShare
EXTRN	?GetNukeInterception@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetNukeInterception
EXTRN	?incrementProjectCreatedCount@CvGame@@QAEXW4ProjectTypes@@H@Z:PROC ; CvGame::incrementProjectCreatedCount
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	SEGMENT
__ehfuncinfo$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$3
	DD	05H
	DD	FLAT:__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$4
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
_TEXT	SEGMENT
tv1233 = -188						; size = 4
tv1231 = -188						; size = 4
tv935 = -188						; size = 4
$T248777 = -188						; size = 4
$T248207 = -188						; size = 4
$T248204 = -188						; size = 4
tv1303 = -184						; size = 4
tv1277 = -184						; size = 4
tv745 = -184						; size = 4
tv721 = -184						; size = 4
tv949 = -180						; size = 4
_playerWhoLeadsTeam$226332 = -180			; size = 4
$T248208 = -180						; size = 4
$T248205 = -180						; size = 4
_pkProject$226287 = -180				; size = 4
_iI$ = -176						; size = 4
_defaultType$226276 = -176				; size = 4
_this$ = -172						; size = 4
_strSomeoneCompletedProject$226322 = -168		; size = 28
_strUnknownCompletesProject$226328 = -140		; size = 28
$T248210 = -112						; size = 8
$T248211 = -104						; size = 8
_strSomeoneCompletesProject$226316 = -96		; size = 28
$T248206 = -68						; size = 28
$T248209 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z PROC ; CvTeam::changeProjectCount, COMDAT
; _this$ = ecx

; 4681 : {

	push	-1
	push	__ehhandler$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	ebp

; 4682 : 	bool bChangeProduction;
; 4683 : 	int iOldProjectCount;
; 4684 : #ifdef AUI_WARNING_FIXES
; 4685 : 	int iI;
; 4686 : 	uint iJ;
; 4687 : #else
; 4688 : 	int iI, iJ;
; 4689 : #endif
; 4690 : 
; 4691 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4692 : 	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4693 : 
; 4694 : 	if(iChange != 0)
; 4695 : 	{
; 4696 : 		GC.getGame().incrementProjectCreatedCount(eIndex, iChange);

	mov	ebp, DWORD PTR _eIndex$[esp+192]
	push	esi
	mov	esi, DWORD PTR _iChange$[esp+196]
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[esp+204], ebx
	test	esi, esi
	je	$LN295@changeProj
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	push	ebp
	call	?incrementProjectCreatedCount@CvGame@@QAEXW4ProjectTypes@@H@Z ; CvGame::incrementProjectCreatedCount

; 4697 : 
; 4698 : 		iOldProjectCount = getProjectCount(eIndex);

	mov	eax, DWORD PTR [ebx+2916]
	mov	ecx, DWORD PTR [eax+ebp*4]
	lea	eax, DWORD PTR [eax+ebp*4]
	mov	DWORD PTR tv935[esp+204], ecx

; 4699 : 
; 4700 : 		m_paiProjectCount[eIndex] = (m_paiProjectCount[eIndex] + iChange);

	add	ecx, esi
	mov	DWORD PTR [eax], ecx

; 4701 : 		CvAssert(getProjectCount(eIndex) >= 0);
; 4702 : 
; 4703 : 		//adjust default art types
; 4704 : 		if(iChange >= 0)

	test	esi, esi
	jl	$LN45@changeProj

; 4705 : 		{
; 4706 : 			//multiplayer games default to first art type
; 4707 : 			int defaultType = -1;
; 4708 : 			if(GC.getGame().isNetworkMultiPlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _defaultType$226276[esp+204], -1
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	je	SHORT $LN44@changeProj

; 4709 : 				defaultType = getProjectDefaultArtType(eIndex);

	mov	ecx, DWORD PTR [ebx+2920]
	mov	edx, DWORD PTR [ecx+ebp*4]
	mov	DWORD PTR _defaultType$226276[esp+204], edx
$LN44@changeProj:

; 4710 : 
; 4711 : 			for(int i=0; i<iChange; i++)

	test	esi, esi
	jle	$LN292@changeProj
	mov	eax, ebp
	shl	eax, 4
	mov	DWORD PTR tv949[esp+204], eax
	mov	DWORD PTR tv745[esp+204], esi
	jmp	SHORT $LN43@changeProj
	npad	1
$LL296@changeProj:
	mov	eax, DWORD PTR tv949[esp+204]
$LN43@changeProj:

; 4712 : 				m_pavProjectArtTypes[eIndex].push_back(defaultType);

	mov	ecx, DWORD PTR [ebx+2960]
	mov	esi, DWORD PTR [ecx+eax+4]
	add	ecx, eax
	test	esi, esi
	jne	SHORT $LN70@changeProj
	xor	eax, eax
	jmp	SHORT $LN71@changeProj
$LN70@changeProj:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN71@changeProj:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax
	jae	SHORT $LN63@changeProj
	mov	eax, DWORD PTR _defaultType$226276[esp+204]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN42@changeProj
$LN63@changeProj:
	lea	eax, DWORD PTR _defaultType$226276[esp+204]
	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN42@changeProj:

; 4710 : 
; 4711 : 			for(int i=0; i<iChange; i++)

	sub	DWORD PTR tv745[esp+204], 1
	jne	SHORT $LL296@changeProj

; 4713 : 		}
; 4714 : 		else

	mov	esi, DWORD PTR _iChange$[esp+200]
	jmp	SHORT $LN292@changeProj
$LN45@changeProj:

; 4715 : 		{
; 4716 : 			for(int i=0; i<-iChange; i++)

	mov	eax, esi
	neg	eax
	test	eax, eax
	jle	SHORT $LN292@changeProj
	mov	edx, ebp
	shl	edx, 4
	mov	DWORD PTR tv721[esp+204], eax
	npad	6
$LL39@changeProj:

; 4717 : 				m_pavProjectArtTypes[eIndex].pop_back();

	mov	eax, DWORD PTR [ebx+2960]
	mov	ecx, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	edi, ecx
	sub	edi, DWORD PTR [eax+4]
	test	edi, -4					; fffffffcH
	je	SHORT $LN38@changeProj
	add	ecx, -4					; fffffffcH
	mov	DWORD PTR [eax+8], ecx
$LN38@changeProj:

; 4715 : 		{
; 4716 : 			for(int i=0; i<-iChange; i++)

	sub	DWORD PTR tv721[esp+204], 1
	jne	SHORT $LL39@changeProj
$LN292@changeProj:

; 4718 : 		}
; 4719 : 		CvAssertMsg(getProjectCount(eIndex) == (int)m_pavProjectArtTypes[eIndex].size(), "[Jason] Unbalanced project art types.");
; 4720 : 
; 4721 : 		CvProjectEntry* pkProject = GC.getProjectInfo(eIndex);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	edi, eax

; 4722 : 
; 4723 : 		changeNukeInterception(pkProject->GetNukeInterception() * iChange);

	mov	ecx, edi
	mov	DWORD PTR _pkProject$226287[esp+204], edi
	call	?GetNukeInterception@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetNukeInterception
	imul	eax, esi
	add	DWORD PTR [ebx+32], eax

; 4724 : 
; 4725 : 		if((pkProject->GetTechShare() > 0) && (pkProject->GetTechShare() <= MAX_TEAMS))

	mov	ecx, edi
	call	?GetTechShare@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechShare
	test	eax, eax
	jle	SHORT $LN293@changeProj
	mov	ecx, edi
	call	?GetTechShare@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechShare
	cmp	eax, 64					; 00000040H
	jg	SHORT $LN293@changeProj

; 4726 : 		{
; 4727 : 			changeTechShareCount((pkProject->GetTechShare() - 1), iChange);

	mov	ecx, edi
	call	?GetTechShare@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechShare
	dec	eax
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN293@changeProj
	add	DWORD PTR [ebx+eax*4+148], esi
	push	eax
	mov	ecx, ebx
	call	?isTechShare@CvTeam@@QBE_NH@Z		; CvTeam::isTechShare
	test	al, al
	je	SHORT $LN293@changeProj
	mov	ecx, ebx
	call	?updateTechShare@CvTeam@@IAEXXZ		; CvTeam::updateTechShare
$LN293@changeProj:

; 4728 : 		}
; 4729 : 
; 4730 : #ifdef AUI_WARNING_FIXES
; 4731 : 		for (uint iVictory = 0; iVictory < GC.getNumVictoryInfos(); ++iVictory)
; 4732 : #else
; 4733 : 		for(int iVictory = 0; iVictory < GC.getNumVictoryInfos(); ++iVictory)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	test	eax, eax
	jle	SHORT $LN33@changeProj
$LL35@changeProj:

; 4734 : #endif
; 4735 : 		{
; 4736 : 			if(pkProject->GetVictoryThreshold(iVictory) > 0)

	push	esi
	mov	ecx, edi
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	test	eax, eax
	jle	SHORT $LN34@changeProj

; 4737 : 			{
; 4738 : 				m_abCanLaunch[iVictory] = GC.getGame().testVictory((VictoryTypes)iVictory, GetID());

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	push	eax
	push	esi
	call	?testVictory@CvGame@@QBE_NW4VictoryTypes@@W4TeamTypes@@PA_N@Z ; CvGame::testVictory
	mov	ecx, DWORD PTR [ebx+2896]
	mov	BYTE PTR [esi+ecx], al

; 4739 : 				GC.getGame().testVictory();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?testVictory@CvGame@@QAEXXZ		; CvGame::testVictory
$LN34@changeProj:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	esi, eax
	jl	SHORT $LL35@changeProj
$LN33@changeProj:

; 4740 : 			}
; 4741 : 		}
; 4742 : 
; 4743 : 		if(iChange > 0)

	cmp	DWORD PTR _iChange$[esp+200], 0
	jle	$LN295@changeProj

; 4744 : 		{
; 4745 : 			if(pkProject->GetEveryoneSpecialUnit() != NO_SPECIALUNIT)

	mov	ecx, edi
	call	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetEveryoneSpecialUnit
	cmp	eax, -1
	je	SHORT $LN30@changeProj

; 4746 : 			{
; 4747 : 				GC.getGame().makeSpecialUnitValid((SpecialUnitTypes)(pkProject->GetEveryoneSpecialUnit()));

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ecx, edi
	call	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetEveryoneSpecialUnit
	push	eax
	mov	ecx, esi
	call	?makeSpecialUnitValid@CvGame@@QAEXW4SpecialUnitTypes@@@Z ; CvGame::makeSpecialUnitValid
$LN30@changeProj:

; 4748 : 			}
; 4749 : 
; 4750 : 			if(pkProject->IsAllowsNukes())

	mov	ecx, edi
	call	?IsAllowsNukes@CvProjectEntry@@QBE_NXZ	; CvProjectEntry::IsAllowsNukes
	test	al, al
	je	SHORT $LN29@changeProj

; 4751 : 			{
; 4752 : 				GC.getGame().makeNukesValid(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	call	?makeNukesValid@CvGame@@QAEX_N@Z	; CvGame::makeNukesValid
$LN29@changeProj:

; 4753 : 			}
; 4754 : 
; 4755 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edx, edx
	mov	DWORD PTR tv1277[esp+204], edx
$LL28@changeProj:

; 4756 : 			{
; 4757 : 				if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edx+eax+2256], 0
	lea	ecx, DWORD PTR [edx+eax]
	je	$LN27@changeProj

; 4758 : 				{
; 4759 : 					if(GET_PLAYER((PlayerTypes)iI).getTeam() == GetID())

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN164@changeProj
	mov	esi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN165@changeProj
$LN164@changeProj:
	or	eax, -1
$LN165@changeProj:
	cmp	eax, DWORD PTR [ebx+4]
	jne	$LN27@changeProj

; 4760 : 					{
; 4761 : 						if(!(GET_PLAYER((PlayerTypes)iI).isHuman()))

	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN298@changeProj

; 4762 : 						{
; 4763 : 							bChangeProduction = false;
; 4764 : 
; 4765 : 							for(iJ = 0; iJ < GC.getNumProjectInfos(); iJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	test	eax, eax
	jle	SHORT $LN298@changeProj
$LL22@changeProj:

; 4766 : 							{
; 4767 : 								if((getProjectCount(eIndex) >= GC.getProjectInfo((ProjectTypes)iJ)->GetProjectsNeeded(eIndex)) &&
; 4768 : 								        (iOldProjectCount < GC.getProjectInfo((ProjectTypes)iJ)->GetProjectsNeeded(eIndex)))

	mov	ecx, DWORD PTR [ebx+2916]
	mov	edi, DWORD PTR [ecx+ebp*4]
	push	ebp
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetProjectsNeeded
	cmp	edi, eax
	jl	SHORT $LN21@changeProj
	push	ebp
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetProjectsNeeded
	cmp	DWORD PTR tv935[esp+204], eax
	jl	SHORT $LN297@changeProj
$LN21@changeProj:

; 4762 : 						{
; 4763 : 							bChangeProduction = false;
; 4764 : 
; 4765 : 							for(iJ = 0; iJ < GC.getNumProjectInfos(); iJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	esi, eax
	jl	SHORT $LL22@changeProj
$LN297@changeProj:
	mov	edi, DWORD PTR _pkProject$226287[esp+204]
$LN298@changeProj:
	mov	edx, DWORD PTR tv1277[esp+204]
$LN27@changeProj:

; 4753 : 			}
; 4754 : 
; 4755 : 			for(iI = 0; iI < MAX_PLAYERS; iI++)

	add	edx, 63236				; 0000f704H
	cmp	edx, 4047104				; 003dc100H
	mov	DWORD PTR tv1277[esp+204], edx
	jl	$LL28@changeProj

; 4769 : 								{
; 4770 : 									bChangeProduction = true;
; 4771 : 									break;
; 4772 : 								}
; 4773 : 							}
; 4774 : 
; 4775 : 							if(bChangeProduction)
; 4776 : 							{
; 4777 : 								//GET_PLAYER((PlayerTypes)iI).AI_makeProductionDirty();
; 4778 : 							}
; 4779 : 						}
; 4780 : 					}
; 4781 : 				}
; 4782 : 			}
; 4783 : 
; 4784 : 			if(GC.getGame().isFinalInitialized())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	test	al, al
	je	$LN295@changeProj

; 4785 : 			{
; 4786 : 				CvString strSomeoneCompletesProject = GetLocalizedText("TXT_KEY_MISC_COMPLETES_PROJECT", getName().GetCString(), pkProject->GetTextKey());

	mov	ecx, edi
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	lea	edx, DWORD PTR $T248206[esp+204]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR $T248204[esp+208], eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	xor	ebp, ebp
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+212], ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T248205[esp+204], eax
	lea	eax, DWORD PTR $T248204[esp+204]
	push	eax
	lea	ecx, DWORD PTR $T248205[esp+208]
	push	ecx
	lea	edx, DWORD PTR _strSomeoneCompletesProject$226316[esp+212]
	push	OFFSET $SG226321
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T248206[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4787 : 				CvString strSomeoneCompletedProject = GetLocalizedText("TXT_KEY_MISC_SOMEONE_HAS_COMPLETED", getName().GetCString(), pkProject->GetTextKey());

	mov	ecx, edi
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T248207[esp+204], eax
	lea	eax, DWORD PTR $T248209[esp+204]
	push	eax
	mov	ecx, ebx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+212], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR $T248207[esp+204]
	push	ecx
	lea	edx, DWORD PTR $T248208[esp+208]
	push	edx
	mov	DWORD PTR $T248208[esp+212], eax
	lea	eax, DWORD PTR _strSomeoneCompletedProject$226322[esp+212]
	push	OFFSET $SG226327
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T248209[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4788 : 				CvString strUnknownCompletesProject = GetLocalizedText("TXT_KEY_MISC_WONDER_COMPLETED_UNKNOWN", pkProject->GetTextKey());

	mov	ecx, edi
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _strUnknownCompletesProject$226328[esp+208]
	push	OFFSET $SG226330
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH

; 4789 : 
; 4790 : 				const PlayerTypes eTeamLeader = getLeaderID();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+212], 6
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID

; 4791 : 				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, eTeamLeader, strSomeoneCompletesProject);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	-1
	push	-1
	lea	edx, DWORD PTR _strSomeoneCompletesProject$226316[esp+212]
	push	edx
	mov	esi, eax
	push	esi
	push	ebp
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 4792 : 
; 4793 : 				CvPlayerAI& playerWhoLeadsTeam = GET_PLAYER(eTeamLeader);

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, esi
	mov	DWORD PTR _playerWhoLeadsTeam$226332[esp+204], ecx

; 4794 : 				CvCity* pLeadersCapital = playerWhoLeadsTeam.getCapitalCity();

	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	edi, eax

; 4795 : 
; 4796 : 
; 4797 : 				for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	mov	DWORD PTR _iI$[esp+204], ebp
	xor	ebx, ebx
	mov	DWORD PTR tv1303[esp+204], ebx
	npad	3
$LL16@changeProj:

; 4798 : 				{
; 4799 : 					const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
; 4800 : 					CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ebx, eax

; 4801 : 
; 4802 : 					if(kPlayer.isAlive())

	cmp	BYTE PTR [ebx+2256], 0
	je	$LN15@changeProj

; 4803 : 					{
; 4804 : 						if(isHasMet(kPlayer.getTeam()))

	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN201@changeProj
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN202@changeProj
$LN201@changeProj:
	or	eax, -1
$LN202@changeProj:
	mov	ecx, DWORD PTR _this$[esp+204]
	cmp	BYTE PTR [eax+ecx+1848], 0

; 4805 : 						{
; 4806 : 							if(ePlayer == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	je	$LN12@changeProj
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	jne	SHORT $LN11@changeProj

; 4807 : 							{
; 4808 : 								DLLUI->AddCityMessage(0, pLeadersCapital->GetIDInfo(), ePlayer, false, GC.getEVENT_MESSAGE_TIME(), strSomeoneCompletedProject);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$226322[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	edx
	push	0
	push	ebp
	lea	eax, DWORD PTR $T248210[esp+252]
	mov	DWORD PTR tv1233[esp+252], ecx
	push	eax
	mov	ecx, edi
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	mov	eax, DWORD PTR tv1233[esp+256]
	mov	edx, DWORD PTR [eax+172]
	push	0
	mov	ecx, esi
	call	edx
$LN11@changeProj:

; 4809 : 							}
; 4810 : 							CvNotifications* pNotifications = kPlayer.GetNotifications();

	mov	ecx, ebx
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications

; 4811 : 							pNotifications->Add(NOTIFICATION_PROJECT_COMPLETED, strSomeoneCompletedProject, strSomeoneCompletedProject, pLeadersCapital->getX(), pLeadersCapital->getY(), eIndex, playerWhoLeadsTeam.GetID());

	mov	ecx, DWORD PTR [edi+96]
	mov	ebx, DWORD PTR [edi+108]
	mov	ebp, eax
	mov	eax, DWORD PTR _playerWhoLeadsTeam$226332[esp+204]
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR $T248777[esp+204], ecx
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$226322[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR _eIndex$[esp+200]
	mov	ecx, DWORD PTR $T248777[esp+204]
	push	esi
	push	edx
	push	ebx
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$226322[esp+224]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1595436701				; 5f186e9dH
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 4812 : 						}
; 4813 : 						else

	mov	ebp, DWORD PTR _iI$[esp+204]
	jmp	$LN15@changeProj
$LN12@changeProj:

; 4814 : 						{
; 4815 : 							if(ePlayer == GC.getGame().getActivePlayer())

	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	jne	SHORT $LN9@changeProj

; 4816 : 							{
; 4817 : 								DLLUI->AddCityMessage(0, pLeadersCapital->GetIDInfo(), ePlayer, false, GC.getEVENT_MESSAGE_TIME(), strUnknownCompletesProject);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strUnknownCompletesProject$226328[esp+204]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	edx
	push	0
	push	ebp
	lea	eax, DWORD PTR $T248211[esp+252]
	mov	DWORD PTR tv1231[esp+252], ecx
	push	eax
	mov	ecx, edi
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	mov	eax, DWORD PTR tv1231[esp+256]
	mov	edx, DWORD PTR [eax+172]
	push	0
	mov	ecx, esi
	call	edx
	mov	ebp, DWORD PTR _iI$[esp+204]
$LN9@changeProj:

; 4818 : 							}
; 4819 : 							CvNotifications* pNotifications = kPlayer.GetNotifications();

	mov	ecx, ebx
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications

; 4820 : 							pNotifications->Add(NOTIFICATION_PROJECT_COMPLETED, strUnknownCompletesProject, strUnknownCompletesProject, -1, -1, eIndex, NO_PLAYER);

	lea	ecx, DWORD PTR _strUnknownCompletesProject$226328[esp+204]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _eIndex$[esp+200]
	push	-1
	push	ecx
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strUnknownCompletesProject$226328[esp+224]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1595436701				; 5f186e9dH
	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN15@changeProj:
	mov	ebx, DWORD PTR tv1303[esp+204]
	add	ebx, 63236				; 0000f704H
	inc	ebp
	cmp	ebx, 1391192				; 00153a58H
	mov	DWORD PTR _iI$[esp+204], ebp
	mov	DWORD PTR tv1303[esp+204], ebx
	jl	$LL16@changeProj

; 4821 : 						}
; 4822 : 					}
; 4823 : 				}
; 4824 : 			}

	lea	ecx, DWORD PTR _strUnknownCompletesProject$226328[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$226322[esp+204]
	mov	BYTE PTR __$EHRec$[esp+212], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strSomeoneCompletesProject$226316[esp+204]
	mov	DWORD PTR __$EHRec$[esp+212], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, DWORD PTR _this$[esp+204]
	mov	ebp, DWORD PTR _eIndex$[esp+200]
$LN295@changeProj:

; 4825 : 		}
; 4826 : 	}
; 4827 : 
; 4828 : 	// Update the amount of a Resource used up by this Project
; 4829 : #ifdef AUI_WARNING_FIXES
; 4830 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 4831 : #else
; 4832 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN6@changeProj
$LL8@changeProj:

; 4833 : #endif
; 4834 : 	{
; 4835 : 		if(GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop) > 0)

	push	edi
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	$LN7@changeProj

; 4836 : 		{
; 4837 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	ebp, ebp
	npad	2
$LL4@changeProj:

; 4838 : 			{
; 4839 : 				CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes) iPlayerLoop);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 4840 : 				if(kPlayer.isAlive() && kPlayer.getTeam() == GetID())

	cmp	BYTE PTR [edx+ebp+2256], 0
	lea	esi, DWORD PTR [edx+ebp]
	je	SHORT $LN3@changeProj
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN265@changeProj
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN266@changeProj
$LN265@changeProj:
	or	eax, -1
$LN266@changeProj:
	cmp	eax, DWORD PTR [ebx+4]
	jne	SHORT $LN3@changeProj

; 4841 : 				{
; 4842 : 					kPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, iChange * GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop));

	mov	eax, DWORD PTR _eIndex$[esp+200]
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetResourceQuantityRequirement
	imul	eax, DWORD PTR _iChange$[esp+200]
	push	eax
	push	edi
	mov	ecx, esi
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN3@changeProj:
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 3983868				; 003cc9fcH
	jl	SHORT $LL4@changeProj

; 4836 : 		{
; 4837 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	ebp, DWORD PTR _eIndex$[esp+200]
$LN7@changeProj:

; 4825 : 		}
; 4826 : 	}
; 4827 : 
; 4828 : 	// Update the amount of a Resource used up by this Project
; 4829 : #ifdef AUI_WARNING_FIXES
; 4830 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 4831 : #else
; 4832 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	$LL8@changeProj
$LN6@changeProj:

; 4843 : 				}
; 4844 : 			}
; 4845 : 		}
; 4846 : 	}
; 4847 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+204]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 188				; 000000bcH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$0:
	lea	ecx, DWORD PTR $T248206[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$1:
	lea	ecx, DWORD PTR _strSomeoneCompletesProject$226316[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$2:
	lea	ecx, DWORD PTR $T248209[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$3:
	lea	ecx, DWORD PTR _strSomeoneCompletedProject$226322[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z$4:
	lea	ecx, DWORD PTR _strUnknownCompletesProject$226328[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ENDP ; CvTeam::changeProjectCount
PUBLIC	?resetVictoryProgress@CvTeam@@QAEXXZ		; CvTeam::resetVictoryProgress
EXTRN	?getGameState@CvGame@@QAE?AW4GameStateTypes@@XZ:PROC ; CvGame::getGameState
EXTRN	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z:PROC ; CvGlobals::getVictoryInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?resetVictoryProgress@CvTeam@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$1
__ehfuncinfo$?resetVictoryProgress@CvTeam@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?resetVictoryProgress@CvTeam@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?resetVictoryProgress@CvTeam@@QAEXXZ
_TEXT	SEGMENT
_iI$226534 = -80					; size = 4
$T248896 = -76						; size = 4
$T248897 = -72						; size = 4
_strBuffer$226553 = -68					; size = 28
$T248898 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?resetVictoryProgress@CvTeam@@QAEXXZ PROC		; CvTeam::resetVictoryProgress, COMDAT
; _this$ = ecx

; 5180 : {

	push	-1
	push	__ehhandler$?resetVictoryProgress@CvTeam@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	edi
	mov	ebx, ecx

; 5181 : #ifdef AUI_WARNING_FIXES
; 5182 : 	for (uint iI = 0; iI < GC.getNumVictoryInfos(); ++iI)
; 5183 : #else
; 5184 : 	for(int iI = 0; iI < GC.getNumVictoryInfos(); ++iI)

	xor	edi, edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$226534[esp+88], edi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	test	eax, eax
	jle	$LN12@resetVicto
	push	ebp
	push	esi
	npad	10
$LL55@resetVicto:

; 5185 : #endif
; 5186 : 	{
; 5187 : 		VictoryTypes eVictory = static_cast<VictoryTypes>(iI);
; 5188 : 		CvVictoryInfo* pkVictoryInfo = GC.getVictoryInfo((VictoryTypes)iI);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getVictoryInfo@CvGlobals@@QAEPAVCvVictoryInfo@@W4VictoryTypes@@@Z ; CvGlobals::getVictoryInfo
	mov	ebp, eax

; 5189 : 		if(pkVictoryInfo)

	test	ebp, ebp
	je	$LN13@resetVicto

; 5190 : 		{
; 5191 : 			if(getVictoryCountdown(eVictory) >= 0 && GC.getGame().getGameState() == GAMESTATE_ON)

	mov	eax, DWORD PTR [ebx+2944]
	cmp	DWORD PTR [eax+edi*4], 0
	jl	$LN13@resetVicto
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameState@CvGame@@QAE?AW4GameStateTypes@@XZ ; CvGame::getGameState
	test	eax, eax
	jne	$LN13@resetVicto

; 5192 : 			{
; 5193 : 				setVictoryCountdown(eVictory, -1);

	mov	ecx, DWORD PTR [ebx+2944]
	mov	DWORD PTR [ecx+edi*4], -1

; 5194 : 
; 5195 : #ifdef AUI_WARNING_FIXES
; 5196 : 				for (uint iK = 0; iK < GC.getNumProjectInfos(); iK++)
; 5197 : #else
; 5198 : 				for(int iK = 0; iK < GC.getNumProjectInfos(); iK++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	test	eax, eax
	jle	SHORT $LN7@resetVicto
$LL9@resetVicto:

; 5199 : #endif
; 5200 : 				{
; 5201 : 					ProjectTypes eProject = static_cast<ProjectTypes>(iK);
; 5202 : 					CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo

; 5203 : 					if(pkProjectInfo)

	test	eax, eax
	je	SHORT $LN8@resetVicto

; 5204 : 					{
; 5205 : 						if(pkProjectInfo->GetVictoryMinThreshold(eVictory) > 0)

	push	edi
	mov	ecx, eax
	call	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryMinThreshold
	test	eax, eax
	jle	SHORT $LN8@resetVicto

; 5206 : 						{
; 5207 : 							changeProjectCount(eProject, -getProjectCount(eProject));

	mov	edx, DWORD PTR [ebx+2916]
	mov	eax, DWORD PTR [edx+esi*4]
	neg	eax
	push	eax
	push	esi
	mov	ecx, ebx
	call	?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectCount
$LN8@resetVicto:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	esi, eax
	jl	SHORT $LL9@resetVicto
$LN7@resetVicto:

; 5208 : 						}
; 5209 : 					}
; 5210 : 				}
; 5211 : 
; 5212 : 				CvString strBuffer = GetLocalizedText("TXT_KEY_VICTORY_RESET", getName().GetCString(), pkVictoryInfo->GetTextKey());

	mov	ecx, ebp
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T248896[esp+96], eax
	lea	eax, DWORD PTR $T248898[esp+96]
	push	eax
	mov	ecx, ebx
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	xor	ebp, ebp
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+104], ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR $T248896[esp+96]
	push	ecx
	lea	edx, DWORD PTR $T248897[esp+100]
	push	edx
	mov	DWORD PTR $T248897[esp+104], eax
	lea	eax, DWORD PTR _strBuffer$226553[esp+104]
	push	OFFSET $SG226558
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T248898[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5213 : 
; 5214 : 				for(int iJ = 0; iJ < MAX_PLAYERS; ++iJ)

	xor	edi, edi
	npad	7
$LL4@resetVicto:

; 5215 : 				{
; 5216 : 					if(GET_PLAYER((PlayerTypes)iJ).isAlive())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [ecx+ebp+2256], 0
	je	SHORT $LN3@resetVicto

; 5217 : 					{
; 5218 : 						DLLUI->AddMessage(0, ((PlayerTypes)iJ), false, GC.getEVENT_MESSAGE_TIME(), strBuffer, "AS2D_MELTDOWN", MESSAGE_TYPE_MAJOR_EVENT);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$226553[esp+96]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	0
	mov	edx, DWORD PTR [esi]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	2
	push	OFFSET $SG226566
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	edi
	push	0
	mov	ecx, esi
	call	edx
$LN3@resetVicto:
	add	ebp, 63236				; 0000f704H
	inc	edi
	cmp	ebp, 4047104				; 003dc100H
	jl	SHORT $LL4@resetVicto

; 5219 : 					}
; 5220 : 				}
; 5221 : 
; 5222 : 				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	push	-1
	push	-1
	lea	eax, DWORD PTR _strBuffer$226553[esp+104]
	push	eax
	mov	ecx, ebx
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 5223 : 			}

	lea	ecx, DWORD PTR _strBuffer$226553[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	edi, DWORD PTR _iI$226534[esp+96]
$LN13@resetVicto:
	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$226534[esp+96], edi
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	edi, eax
	jl	$LL55@resetVicto
	pop	esi
	pop	ebp
$LN12@resetVicto:

; 5224 : 		}
; 5225 : 	}
; 5226 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$0:
	lea	ecx, DWORD PTR $T248898[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?resetVictoryProgress@CvTeam@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBuffer$226553[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?resetVictoryProgress@CvTeam@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?resetVictoryProgress@CvTeam@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?resetVictoryProgress@CvTeam@@QAEXXZ ENDP		; CvTeam::resetVictoryProgress
PUBLIC	?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z
_TEXT	SEGMENT
$T249004 = -4						; size = 1
__Cat$249007 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z PROC ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@5
	xor	eax, eax
	jmp	SHORT $LN10@push_back@5
$LN9@push_back@5:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@5:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$249007[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T249004[esp+12], 0
	mov	eax, DWORD PTR $T249004[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4ResourceTypes@@IW41@V?$allocator@W4ResourceTypes@@@std@@@std@@YAXPAW4ResourceTypes@@IABW41@AAV?$allocator@W4ResourceTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum ResourceTypes *,unsigned int,enum ResourceTypes,std::allocator<enum ResourceTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@5:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@2@IABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z ENDP ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ ; CvWeightedVector<enum TeamTypes,63,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ PROC ; CvWeightedVector<enum TeamTypes,63,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEXXZ ENDP ; CvWeightedVector<enum TeamTypes,63,1>::SortItems
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);
; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _nBytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pData$[esp]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	edi, DWORD PTR [edi*4+4]
	lea	eax, DWORD PTR [edi+edx]
	push	eax
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	ecx, eax
	and	ecx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	add	edx, 4
	pop	edi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z
_TEXT	SEGMENT
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_aArray$ = 12						; size = 4
??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z PROC ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>, COMDAT

; 438  : {

	push	ecx
	push	ebx
	push	ebp

; 439  : 	uint uiNumEntries;
; 440  : 
; 441  : 	kStream >> uiNumEntries;

	mov	ebp, DWORD PTR _kStream$[esp+8]
	push	esi
	lea	eax, DWORD PTR _uiNumEntries$[esp+16]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 442  : 
; 443  : 	if(aArray.size() < uiNumEntries)

	mov	ebx, DWORD PTR _aArray$[esp+12]
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR _uiNumEntries$[esp+16]
	sar	ecx, 2
	cmp	ecx, eax
	jae	SHORT $LN4@ReadHashed@3

; 444  : 		aArray.resize(uiNumEntries);

	push	eax
	mov	ecx, ebx
	call	?resize@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::resize
	mov	eax, DWORD PTR _uiNumEntries$[esp+16]
$LN4@ReadHashed@3:

; 445  : 
; 446  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	esi, esi
	test	eax, eax
	jbe	SHORT $LN1@ReadHashed@3
	push	edi
	npad	4
$LL15@ReadHashed@3:
	mov	edx, DWORD PTR [ebx+4]

; 447  : 	{
; 448  : 		aArray[iI] = (TType)ReadHashed(kStream);

	push	0
	push	ebp
	lea	edi, DWORD PTR [edx+esi*4]
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	inc	esi
	add	esp, 8
	mov	DWORD PTR [edi], eax
	cmp	esi, DWORD PTR _uiNumEntries$[esp+20]
	jb	SHORT $LL15@ReadHashed@3
	pop	edi
$LN1@ReadHashed@3:
	pop	esi
	pop	ebp
	pop	ebx

; 449  : 	}
; 450  : }

	pop	ecx
	ret	0
??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >
_TEXT	ENDS
PUBLIC	?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::shareCounters
EXTRN	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC ; CvTeamTechs::IsNoTradeTech
EXTRN	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z:PROC ; CvTeamTechs::GetResearchProgress
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv424 = 8						; size = 4
$T249418 = 8						; size = 4
_eTeam$ = 8						; size = 4
?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z PROC		; CvTeam::shareCounters, COMDAT
; _this$ = ecx

; 705  : {

	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx
	push	edi

; 706  : #ifdef AUI_WARNING_FIXES
; 707  : 	uint iI;
; 708  : #else
; 709  : 	int iI;
; 710  : #endif
; 711  : 
; 712  : 	for(iI = 0; iI < GC.getNumProjectInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	test	eax, eax
	jle	SHORT $LN15@shareCount
	mov	ebp, DWORD PTR _eTeam$[esp+12]
	imul	ebp, 2984				; 00000ba8H
$LL17@shareCount:

; 713  : 	{
; 714  : 		int iExtraProjects = GET_TEAM(eTeam).getProjectCount((ProjectTypes)iI) - getProjectCount((ProjectTypes)iI);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [eax+ebp+2916]
	mov	edx, DWORD PTR [ebx+2916]
	mov	edi, DWORD PTR [ecx+esi*4]
	sub	edi, DWORD PTR [edx+esi*4]

; 715  : 		if(iExtraProjects > 0)

	test	edi, edi
	jle	SHORT $LN14@shareCount

; 716  : 		{
; 717  : 			changeProjectCount((ProjectTypes)iI, iExtraProjects);

	push	edi
	push	esi
	mov	ecx, ebx
	call	?changeProjectCount@CvTeam@@QAEXW4ProjectTypes@@H@Z ; CvTeam::changeProjectCount

; 718  : 			GC.getGame().incrementProjectCreatedCount((ProjectTypes)iI, -iExtraProjects);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	neg	edi
	push	edi
	push	esi
	call	?incrementProjectCreatedCount@CvGame@@QAEXW4ProjectTypes@@H@Z ; CvGame::incrementProjectCreatedCount
$LN14@shareCount:

; 719  : 		}
; 720  : 
; 721  : 		changeProjectMaking(((ProjectTypes)iI), GET_TEAM(eTeam).getProjectMaking((ProjectTypes)iI));

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR [ecx+ebp+2924]
	mov	eax, DWORD PTR [ebx+2924]
	mov	ecx, DWORD PTR [edx+esi*4]
	add	DWORD PTR [eax+esi*4], ecx
	lea	eax, DWORD PTR [eax+esi*4]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	esi, eax
	jl	SHORT $LL17@shareCount
$LN15@shareCount:

; 722  : 	}
; 723  : 
; 724  : 	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	test	eax, eax
	jle	SHORT $LN11@shareCount
	npad	1
$LL13@shareCount:

; 725  : 	{
; 726  : 		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo((UnitClassTypes)iI);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo

; 727  : 		if(!pkUnitClassInfo)

	test	eax, eax
	je	SHORT $LN12@shareCount

; 728  : 		{
; 729  : 			continue;
; 730  : 		}
; 731  : 
; 732  : 		changeUnitClassCount(((UnitClassTypes)iI), GET_TEAM(eTeam).getUnitClassCount((UnitClassTypes)iI));

	mov	ecx, DWORD PTR _eTeam$[esp+12]
	mov	edx, DWORD PTR [ebx+2928]
	imul	ecx, 2984				; 00000ba8H
	lea	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [ecx+edx+2928]
	mov	edx, DWORD PTR [ecx+esi*4]
	add	DWORD PTR [eax], edx
$LN12@shareCount:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	esi, eax
	jl	SHORT $LL13@shareCount
$LN11@shareCount:

; 733  : 	}
; 734  : 
; 735  : 	for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN7@shareCount
$LL9@shareCount:

; 736  : 	{
; 737  : 		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 738  : 		if(!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN8@shareCount

; 739  : 		{
; 740  : 			continue;
; 741  : 		}
; 742  : 
; 743  : 		changeBuildingClassCount(((BuildingClassTypes)iI), GET_TEAM(eTeam).getBuildingClassCount((BuildingClassTypes)iI));

	mov	ecx, DWORD PTR _eTeam$[esp+12]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	ecx, 2984				; 00000ba8H
	mov	eax, DWORD PTR [ebx+2932]
	mov	ecx, DWORD PTR [ecx+edx+2932]
	mov	edx, DWORD PTR [ecx+esi*4]
	add	DWORD PTR [eax+esi*4], edx
	lea	eax, DWORD PTR [eax+esi*4]
$LN8@shareCount:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	esi, eax
	jl	SHORT $LL9@shareCount
$LN7@shareCount:

; 744  : 	}
; 745  : 
; 746  : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	$LN3@shareCount
	mov	eax, DWORD PTR _eTeam$[esp+12]
	imul	eax, 2984				; 00000ba8H
	lea	edi, DWORD PTR [eax+2980]
	npad	5
$LL5@shareCount:

; 747  : 	{
; 748  : 		if(GET_TEAM(eTeam).GetTeamTechs()->GetResearchProgress((TechTypes)iI) > GetTeamTechs()->GetResearchProgress((TechTypes)iI))

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [edi+eax]
	mov	ebp, DWORD PTR [ebx+2980]
	push	esi
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	push	esi
	mov	ecx, ebp
	mov	DWORD PTR tv424[esp+16], eax
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	mov	ecx, DWORD PTR tv424[esp+12]
	cmp	ecx, eax
	jle	SHORT $LN2@shareCount

; 749  : 		{
; 750  : 			GetTeamTechs()->SetResearchProgress(((TechTypes)iI), GET_TEAM(eTeam).GetTeamTechs()->GetResearchProgress((TechTypes)iI), getLeaderID());

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ebp, DWORD PTR [edi+ecx]
	mov	edx, DWORD PTR [ebx+2980]
	mov	ecx, ebx
	mov	DWORD PTR $T249418[esp+12], edx
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	push	eax
	push	esi
	mov	ecx, ebp
	call	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
	mov	ecx, DWORD PTR $T249418[esp+16]
	push	eax
	push	esi
	call	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgress
$LN2@shareCount:

; 751  : 		}
; 752  : 
; 753  : 		if(GET_TEAM(eTeam).GetTeamTechs()->IsNoTradeTech((TechTypes)iI))

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR [edi+eax]
	push	esi
	call	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::IsNoTradeTech
	test	al, al
	je	SHORT $LN4@shareCount

; 754  : 		{
; 755  : 			GetTeamTechs()->SetNoTradeTech((TechTypes)iI, true);

	mov	ecx, DWORD PTR [ebx+2980]
	push	1
	push	esi
	call	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech
$LN4@shareCount:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	$LL5@shareCount
$LN3@shareCount:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 756  : 		}
; 757  : 	}
; 758  : }

	ret	4
?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z ENDP		; CvTeam::shareCounters
_TEXT	ENDS
PUBLIC	?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetTeamVotingForInDiplo
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetMajorCivOpinionWeight@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMajorCivOpinionWeight
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ$0
__ehfuncinfo$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
_eVoteTeam$ = -552					; size = 4
_elem$249603 = -548					; size = 8
_randFn$224847 = -548					; size = 8
_eTeamLoop$224702 = -548				; size = 4
_elem$249626 = -540					; size = 8
_veVoteCandidates$224697 = -532				; size = 520
__$EHRec$ = -12						; size = 12
?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ PROC ; CvTeam::GetTeamVotingForInDiplo, COMDAT
; _this$ = ecx

; 1993 : {

	push	-1
	push	__ehhandler$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 540				; 0000021cH
	push	ebx
	push	esi
	mov	ebx, ecx

; 1994 : 	TeamTypes eVoteTeam = NO_TEAM;
; 1995 : 	
; 1996 : 	if(isBarbarian())

	mov	esi, 63					; 0000003fH
	mov	DWORD PTR _eVoteTeam$[esp+560], -1
	cmp	DWORD PTR [ebx+4], esi
	je	$LN154@GetTeamVot

; 1997 : 	{
; 1998 : 		// Barbarians do not vote!
; 1999 : 		CvAssertMsg(false, "Barbarian team should not be voting for diplo victory. Please send Anton your save file and verison.");
; 2000 : 	}
; 2001 : 	else if(isMinorCiv())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	SHORT $LN20@GetTeamVot

; 2002 : 	{
; 2003 : 		// Minor civs vote for their favored nation (liberator or ally)
; 2004 : 		if(GetLiberatedByTeam() != NO_TEAM && GET_TEAM(GetLiberatedByTeam()).isAlive())

	mov	eax, DWORD PTR [ebx+140]
	cmp	eax, -1
	je	SHORT $LN19@GetTeamVot
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	imul	ecx, 2984				; 00000ba8H
	cmp	DWORD PTR [ecx+edx+12], 0
	jle	SHORT $LN19@GetTeamVot

; 2005 : 		{
; 2006 : 			eVoteTeam = GetLiberatedByTeam();

	mov	DWORD PTR _eVoteTeam$[esp+560], eax

; 2007 : 		}
; 2008 : 		else

	jmp	$LN136@GetTeamVot
$LN19@GetTeamVot:

; 2009 : 		{
; 2010 : 			PlayerTypes eAlly = GET_PLAYER(getLeaderID()).GetMinorCivAI()->GetAlly();

	mov	ecx, ebx
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 2011 : 			if(eAlly != NO_PLAYER && GET_PLAYER(eAlly).isAlive())

	cmp	eax, -1
	je	$LN154@GetTeamVot
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	add	eax, ecx
	cmp	BYTE PTR [eax+2256], 0
	je	$LN154@GetTeamVot

; 2012 : 				eVoteTeam = GET_PLAYER(eAlly).getTeam();

	mov	ecx, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	DWORD PTR _eVoteTeam$[esp+560], eax

; 2013 : 		}
; 2014 : 	}
; 2015 : 	else

	jmp	$LN136@GetTeamVot
$LN20@GetTeamVot:
	push	ebp
	push	edi

; 2016 : 	{
; 2017 : 		// Major civs vote for other majors based on opinion weight (our team leader towards their team leader)
; 2018 : 		CvWeightedVector<TeamTypes, MAX_CIV_TEAMS, true> veVoteCandidates;

	xor	edi, edi
	lea	edx, DWORD PTR _veVoteCandidates$224697[esp+580]
	mov	DWORD PTR _veVoteCandidates$224697[esp+572], edi
	mov	DWORD PTR _veVoteCandidates$224697[esp+576], esi
	mov	DWORD PTR _veVoteCandidates$224697[esp+568], edx
	mov	DWORD PTR __$EHRec$[esp+576], edi
	xor	ebp, ebp
	jmp	SHORT $LN15@GetTeamVot
	npad	5
$LL162@GetTeamVot:
	mov	esi, 63					; 0000003fH
$LN15@GetTeamVot:

; 2019 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)
; 2020 : 		{
; 2021 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;

	mov	DWORD PTR _eTeamLoop$224702[esp+568], edi

; 2022 : 			if (GetID() != eTeamLoop && GET_TEAM(eTeamLoop).isAlive() && !GET_TEAM(eTeamLoop).isMinorCiv() && !GET_TEAM(eTeamLoop).isBarbarian() && isHasMet(eTeamLoop))

	cmp	DWORD PTR [ebx+4], edi
	je	$LN14@GetTeamVot
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [eax+ebp+12], 0
	lea	ecx, DWORD PTR [eax+ebp]
	jle	$LN14@GetTeamVot
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN14@GetTeamVot
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, ebp
	cmp	DWORD PTR [ecx+4], esi
	je	SHORT $LN14@GetTeamVot
	cmp	BYTE PTR [edi+ebx+1848], al
	je	SHORT $LN14@GetTeamVot

; 2023 : 			{
; 2024 : 				PlayerTypes eLeaderLoop = (PlayerTypes) GET_TEAM(eTeamLoop).getLeaderID();

	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID

; 2025 : 				CvAssertMsg(getLeaderID() != NO_PLAYER, "Our team leader ID should not be NO_PLAYER. Please send Anton your save file and version.");
; 2026 : 				CvAssertMsg(eLeaderLoop != NO_PLAYER, "Other team leader ID should not be NO_PLAYER. Please send Anton your save file and version.");
; 2027 : 				if (getLeaderID() != NO_PLAYER && eLeaderLoop != NO_PLAYER)

	mov	ecx, ebx
	mov	esi, eax
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	cmp	eax, -1
	je	SHORT $LN14@GetTeamVot
	cmp	esi, -1
	je	SHORT $LN14@GetTeamVot

; 2028 : 				{
; 2029 : 					int kiBase = 10000;
; 2030 : 					
; 2031 : 					// What is our leader's opinion of the other team's leader? Remember, bad opinion is positive, good opinion is negative.
; 2032 : 					int iOpinion = GET_PLAYER(getLeaderID()).GetDiplomacyAI()->GetMajorCivOpinionWeight(eLeaderLoop);

	mov	ecx, ebx
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinionWeight@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinionWeight

; 2033 : 					if (isAtWar(eTeamLoop))

	cmp	BYTE PTR [edi+ebx+1928], 0
	je	SHORT $LN159@GetTeamVot

; 2034 : 						iOpinion = kiBase; // Don't vote for someone we are at war with, if we can help it

	mov	eax, 10000				; 00002710H
$LN159@GetTeamVot:

; 2035 : 
; 2036 : 					// Weight cannot be negative. This calculation makes good opinions > 10000 and bad opinions < 10000.
; 2037 : 					int iWeight = kiBase - iOpinion;

	mov	ecx, 10000				; 00002710H
	sub	ecx, eax

; 2038 : 					if (iWeight < 0)

	jns	SHORT $LN9@GetTeamVot

; 2039 : 						iWeight = 0;

	xor	ecx, ecx
$LN9@GetTeamVot:

; 2040 : 
; 2041 : 					veVoteCandidates.push_back(eTeamLoop, iWeight);

	push	ecx
	lea	edx, DWORD PTR _eTeamLoop$224702[esp+572]
	push	edx
	lea	ecx, DWORD PTR _veVoteCandidates$224697[esp+576]
	call	?push_back@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAEIABW4TeamTypes@@H@Z ; CvWeightedVector<enum TeamTypes,63,1>::push_back
$LN14@GetTeamVot:
	add	ebp, 2984				; 00000ba8H
	inc	edi
	cmp	ebp, 187992				; 0002de58H
	jl	$LL162@GetTeamVot

; 2042 : 				}
; 2043 : 			}
; 2044 : 		}
; 2045 : 
; 2046 : 		if (veVoteCandidates.size() > 0)

	mov	ecx, DWORD PTR _veVoteCandidates$224697[esp+572]
	test	ecx, ecx
	jle	$LN157@GetTeamVot

; 2047 : 		{
; 2048 : 			// Our most favored other team ends up at the top after sorting
; 2049 : 			veVoteCandidates.SortItems();

	mov	eax, DWORD PTR _veVoteCandidates$224697[esp+568]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@0H@Z ; std::_Sort<CvWeightedVector<enum TeamTypes,63,1>::WeightedElement *,int>

; 2050 : 			int iTopWeight = veVoteCandidates.GetWeight(0);

	mov	edi, DWORD PTR _veVoteCandidates$224697[esp+580]
	mov	eax, DWORD PTR [edi]

; 2051 : 
; 2052 : 			// If there is a tie at the top, choose randomly from those that tied
; 2053 : 			int iNumAtTop = 0;
; 2054 : 			for (int iIndex = 0; iIndex < veVoteCandidates.size(); iIndex++)

	mov	esi, DWORD PTR _veVoteCandidates$224697[esp+584]
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _elem$249603[esp+580], eax
	add	esp, 12					; 0000000cH
	xor	edx, edx
	xor	eax, eax
	mov	DWORD PTR _elem$249603[esp+572], ecx
	test	esi, esi
	jle	SHORT $LN158@GetTeamVot

; 2047 : 		{
; 2048 : 			// Our most favored other team ends up at the top after sorting
; 2049 : 			veVoteCandidates.SortItems();

	mov	ecx, edi
	npad	2
$LL7@GetTeamVot:

; 2055 : 			{
; 2056 : 				int iWeight = veVoteCandidates.GetWeight(iIndex);

	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR _elem$249626[esp+568], ebp

; 2057 : 				CvAssertMsg(iWeight <= iTopWeight, "Vote opinion weight should not be higher than the top team's weight! Please send Anton your save file and version.");
; 2058 : 				if (iWeight >= iTopWeight)

	mov	ebp, DWORD PTR _elem$249603[esp+572]
	cmp	DWORD PTR [ecx+4], ebp
	jl	SHORT $LN4@GetTeamVot
	inc	eax

; 2059 : 				{
; 2060 : 					iNumAtTop++;

	inc	edx
	add	ecx, 8
	cmp	eax, esi
	jl	SHORT $LL7@GetTeamVot
$LN4@GetTeamVot:

; 2061 : 				}
; 2062 : 				else
; 2063 : 				{
; 2064 : 					break;
; 2065 : 				}
; 2066 : 			}
; 2067 : 			CvAssertMsg(iNumAtTop > 0, "Should have at least one vote candidate at the top of the list for consideration. Please send Anton your save file and version.");
; 2068 : 			CvAssertMsg(iNumAtTop <= veVoteCandidates.size(), "Should not have more top vote candidates than there are total candidates. Please send Anton your save file and version.");
; 2069 : 			if (iNumAtTop > 0 && iNumAtTop <= veVoteCandidates.size())

	test	edx, edx
	jle	SHORT $LN158@GetTeamVot
	cmp	edx, esi
	jg	SHORT $LN158@GetTeamVot

; 2070 : 			{
; 2071 : 				RandomNumberDelegate randFn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48

; 2072 : 				eVoteTeam = veVoteCandidates.ChooseFromTopChoices(iNumAtTop, &randFn, "Tie for most favored other team to vote for. Rolling to choose.");

	push	OFFSET $SG224877
	lea	ecx, DWORD PTR _randFn$224847[esp+572]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _veVoteCandidates$224697[esp+580]
	mov	DWORD PTR _randFn$224847[esp+584], OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	DWORD PTR _randFn$224847[esp+580], eax
	call	?ChooseFromTopChoices@?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE?AW4TeamTypes@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<enum TeamTypes,63,1>::ChooseFromTopChoices
	mov	DWORD PTR _eVoteTeam$[esp+568], eax
$LN157@GetTeamVot:
	mov	edi, DWORD PTR _veVoteCandidates$224697[esp+568]
$LN158@GetTeamVot:

; 2073 : 			}
; 2074 : 		}
; 2075 : 	}

	lea	edx, DWORD PTR _veVoteCandidates$224697[esp+580]
	mov	DWORD PTR __$EHRec$[esp+576], -1
	cmp	edi, edx
	je	SHORT $LN164@GetTeamVot
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN164@GetTeamVot:
	pop	edi
	pop	ebp
$LN136@GetTeamVot:

; 2076 : 
; 2077 : 	// If all else fails, vote for ourselves
; 2078 : 	if (eVoteTeam == NO_TEAM)

	mov	eax, DWORD PTR _eVoteTeam$[esp+560]
	cmp	eax, -1
	jne	SHORT $LN148@GetTeamVot
$LN154@GetTeamVot:

; 2080 : 
; 2081 : 	return eVoteTeam;

	mov	eax, DWORD PTR [ebx+4]

; 2079 : 		eVoteTeam = GetID();

$LN148@GetTeamVot:

; 2082 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+560]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 552				; 00000228H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ$0:
	lea	ecx, DWORD PTR _veVoteCandidates$224697[ebp]
	jmp	??1?$CvWeightedVector@W4TeamTypes@@$0DP@$00@@QAE@XZ ; CvWeightedVector<enum TeamTypes,63,1>::~CvWeightedVector<enum TeamTypes,63,1>
__ehhandler$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ENDP ; CvTeam::GetTeamVotingForInDiplo
PUBLIC	?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromMinorAllies
; Function compile flags: /Ogtpy
;	COMDAT ?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ PROC	; CvTeam::GetProjectedVotesFromMinorAllies, COMDAT
; _this$ = ecx

; 2087 : {

	push	ebx
	push	ebp
	mov	ebx, ecx

; 2088 : 	int iVotes = 0;

	xor	ebp, ebp

; 2089 : 	if (isAlive())

	cmp	DWORD PTR [ebx+12], ebp
	jle	SHORT $LN28@GetProject@2
	push	esi
	push	edi

; 2090 : 	{
; 2091 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	edi, edi
	npad	1
$LL30@GetProject@2:

; 2092 : 		{
; 2093 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;
; 2094 : 			CvTeam* pTeamLoop = &GET_TEAM(eTeamLoop);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 2095 : 			if (pTeamLoop->isAlive() && pTeamLoop->isMinorCiv() && !pTeamLoop->isBarbarian())

	cmp	DWORD PTR [edi+eax+12], 0
	lea	esi, DWORD PTR [edi+eax]
	jle	SHORT $LN5@GetProject@2
	mov	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	SHORT $LN5@GetProject@2
	cmp	DWORD PTR [esi+4], 63			; 0000003fH
	je	SHORT $LN5@GetProject@2

; 2096 : 			{
; 2097 : 				// Minor civ team votes are definite things, given the situation doesn't change
; 2098 : 				if (GET_TEAM(eTeamLoop).GetTeamVotingForInDiplo() == GetID())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, DWORD PTR [ebx+4]
	add	ecx, edi
	call	?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetTeamVotingForInDiplo
	cmp	eax, esi
	jne	SHORT $LN5@GetProject@2

; 2099 : 				{
; 2100 : 					// Liberated minors are handled elsewhere				
; 2101 : 					if (GetLiberatedByTeam() != GetID())

	mov	edx, DWORD PTR [ebx+140]
	cmp	edx, DWORD PTR [ebx+4]
	je	SHORT $LN5@GetProject@2

; 2102 : 					{
; 2103 : 						iVotes++;

	inc	ebp
$LN5@GetProject@2:

; 2090 : 	{
; 2091 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	edi, 2984				; 00000ba8H
	cmp	edi, 187992				; 0002de58H
	jl	SHORT $LL30@GetProject@2
	pop	edi
	pop	esi
$LN28@GetProject@2:

; 2104 : 					}
; 2105 : 				}
; 2106 : 			}
; 2107 : 		}
; 2108 : 	}
; 2109 : 
; 2110 : 	return iVotes;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2111 : }

	ret	0
?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ ENDP	; CvTeam::GetProjectedVotesFromMinorAllies
_TEXT	ENDS
PUBLIC	?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromLiberatedMinors
; Function compile flags: /Ogtpy
;	COMDAT ?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ PROC ; CvTeam::GetProjectedVotesFromLiberatedMinors, COMDAT
; _this$ = ecx

; 2116 : {

	push	ebx
	push	ebp
	mov	ebx, ecx

; 2117 : 	int iVotes = 0;

	xor	ebp, ebp

; 2118 : 	if (isAlive())

	cmp	DWORD PTR [ebx+12], ebp
	jle	SHORT $LN28@GetProject@3
	push	esi
	push	edi

; 2119 : 	{
; 2120 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	xor	edi, edi
	npad	1
$LL30@GetProject@3:

; 2121 : 		{
; 2122 : 			TeamTypes eTeamLoop = (TeamTypes) iTeamLoop;
; 2123 : 			CvTeam* pTeamLoop = &GET_TEAM(eTeamLoop);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 2124 : 			if (pTeamLoop->isAlive() && pTeamLoop->isMinorCiv() && !pTeamLoop->isBarbarian())

	cmp	DWORD PTR [edi+eax+12], 0
	lea	esi, DWORD PTR [edi+eax]
	jle	SHORT $LN5@GetProject@3
	mov	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	SHORT $LN5@GetProject@3
	cmp	DWORD PTR [esi+4], 63			; 0000003fH
	je	SHORT $LN5@GetProject@3

; 2125 : 			{
; 2126 : 				// Minor civ team votes are definite things, given the situation doesn't change
; 2127 : 				if (GET_TEAM(eTeamLoop).GetTeamVotingForInDiplo() == GetID())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, DWORD PTR [ebx+4]
	add	ecx, edi
	call	?GetTeamVotingForInDiplo@CvTeam@@QBE?AW4TeamTypes@@XZ ; CvTeam::GetTeamVotingForInDiplo
	cmp	eax, esi
	jne	SHORT $LN5@GetProject@3

; 2128 : 				{
; 2129 : 					// Liberated by us?
; 2130 : 					if (GetLiberatedByTeam() == GetID())

	mov	edx, DWORD PTR [ebx+140]
	cmp	edx, DWORD PTR [ebx+4]
	jne	SHORT $LN5@GetProject@3

; 2131 : 					{
; 2132 : 						iVotes++;

	inc	ebp
$LN5@GetProject@3:

; 2119 : 	{
; 2120 : 		for (int iTeamLoop = 0; iTeamLoop < MAX_CIV_TEAMS; iTeamLoop++)

	add	edi, 2984				; 00000ba8H
	cmp	edi, 187992				; 0002de58H
	jl	SHORT $LL30@GetProject@3
	pop	edi
	pop	esi
$LN28@GetProject@3:

; 2133 : 					}
; 2134 : 				}
; 2135 : 			}
; 2136 : 		}
; 2137 : 	}
; 2138 : 
; 2139 : 	return iVotes;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2140 : }

	ret	0
?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ ENDP ; CvTeam::GetProjectedVotesFromLiberatedMinors
_TEXT	ENDS
PUBLIC	?GetTotalProjectedVotes@CvTeam@@QBEHXZ		; CvTeam::GetTotalProjectedVotes
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalProjectedVotes@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetTotalProjectedVotes@CvTeam@@QBEHXZ PROC		; CvTeam::GetTotalProjectedVotes, COMDAT
; _this$ = ecx

; 2169 : {

	push	esi
	mov	esi, ecx

; 2170 : 	int iVotes = 0;

	xor	eax, eax

; 2171 : 
; 2172 : 	if (isAlive())

	cmp	DWORD PTR [esi+12], eax
	jle	SHORT $LN1@GetTotalPr
	push	edi

; 2173 : 	{
; 2174 : 		// Majors
; 2175 : 		iVotes += GetProjectedVotesFromCivs();

	call	?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromCivs

; 2176 : 
; 2177 : 		// Minor Allies
; 2178 : 		iVotes += GetProjectedVotesFromMinorAllies();

	mov	ecx, esi
	mov	edi, eax
	call	?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromMinorAllies

; 2179 : 
; 2180 : 		// Liberated Minors
; 2181 : 		iVotes += GetProjectedVotesFromLiberatedMinors();

	mov	ecx, esi
	add	edi, eax
	call	?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromLiberatedMinors
	add	edi, eax

; 2182 : 
; 2183 : 		// UN
; 2184 : 		if (IsHomeOfUnitedNations())

	cmp	BYTE PTR [esi+130], 0
	je	SHORT $LN11@GetTotalPr

; 2185 : 		{
; 2186 : 			int iVotesFromUN = /*1*/ GC.getOWN_UNITED_NATIONS_VOTE_BONUS();
; 2187 : 			iVotes += iVotesFromUN;

	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7728
$LN11@GetTotalPr:

; 2188 : 		}
; 2189 : 	}
; 2190 : 
; 2191 : 	return iVotes;

	mov	eax, edi
	pop	edi
$LN1@GetTotalPr:
	pop	esi

; 2192 : }

	ret	0
?GetTotalProjectedVotes@CvTeam@@QBEHXZ ENDP		; CvTeam::GetTotalProjectedVotes
_TEXT	ENDS
PUBLIC	?GetTotalSecuredVotes@CvTeam@@QBEHXZ		; CvTeam::GetTotalSecuredVotes
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalSecuredVotes@CvTeam@@QBEHXZ
_TEXT	SEGMENT
?GetTotalSecuredVotes@CvTeam@@QBEHXZ PROC		; CvTeam::GetTotalSecuredVotes, COMDAT
; _this$ = ecx

; 2198 : {

	push	esi
	mov	esi, ecx

; 2199 : 	return GetTotalProjectedVotes();

	xor	eax, eax
	cmp	DWORD PTR [esi+12], eax
	jle	SHORT $LN3@GetTotalSe
	push	edi
	call	?GetProjectedVotesFromCivs@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromCivs
	mov	ecx, esi
	mov	edi, eax
	call	?GetProjectedVotesFromMinorAllies@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromMinorAllies
	mov	ecx, esi
	add	edi, eax
	call	?GetProjectedVotesFromLiberatedMinors@CvTeam@@QBEHXZ ; CvTeam::GetProjectedVotesFromLiberatedMinors
	add	edi, eax
	cmp	BYTE PTR [esi+130], 0
	je	SHORT $LN13@GetTotalSe
	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7728
$LN13@GetTotalSe:
	mov	eax, edi
	pop	edi
$LN3@GetTotalSe:
	pop	esi

; 2200 : }

	ret	0
?GetTotalSecuredVotes@CvTeam@@QBEHXZ ENDP		; CvTeam::GetTotalSecuredVotes
_TEXT	ENDS
PUBLIC	?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z ; CvTeam::setForceRevealedResource
; Function compile flags: /Ogtpy
;	COMDAT ?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
_bRevealed$ = 12					; size = 1
?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z PROC ; CvTeam::setForceRevealedResource, COMDAT
; _this$ = ecx

; 6944 : {

	push	ebp

; 6945 : 	if(isForceRevealedResource(eResource) == bRevealed)

	mov	ebp, DWORD PTR _eResource$[esp]
	push	esi
	mov	esi, DWORD PTR [ecx+2972]
	push	edi
	mov	edi, DWORD PTR [ecx+2968]
	mov	eax, edi
	cmp	eax, esi
	je	SHORT $LN15@setForceRe@2
	npad	7
$LL26@setForceRe@2:
	cmp	DWORD PTR [eax], ebp
	je	SHORT $LN97@setForceRe@2
	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL26@setForceRe@2
$LN15@setForceRe@2:
	xor	al, al
$LN18@setForceRe@2:
	mov	dl, BYTE PTR _bRevealed$[esp+8]
	cmp	al, dl
	je	$LN2@setForceRe@2

; 6946 : 	{
; 6947 : 		return;
; 6948 : 	}
; 6949 : 
; 6950 : 	if(bRevealed)

	test	dl, dl
	je	SHORT $LN10@setForceRe@2

; 6951 : 	{
; 6952 : 		m_aeRevealedResources.push_back(eResource);

	lea	eax, DWORD PTR _eResource$[esp+8]
	push	eax
	add	ecx, 2964				; 00000b94H
	call	?push_back@?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAEXABW4ResourceTypes@@@Z ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::push_back

; 6953 : 	}
; 6954 : 	else

	jmp	SHORT $LN6@setForceRe@2
$LN97@setForceRe@2:

; 6945 : 	if(isForceRevealedResource(eResource) == bRevealed)

	mov	al, 1
	jmp	SHORT $LN18@setForceRe@2
$LN10@setForceRe@2:

; 6955 : 	{
; 6956 : 		std::vector<ResourceTypes>::iterator it;
; 6957 : 
; 6958 : 		for(it = m_aeRevealedResources.begin(); it != m_aeRevealedResources.end(); ++it)

	mov	edx, edi
	cmp	edx, esi
	je	SHORT $LN6@setForceRe@2
	npad	7
$LL50@setForceRe@2:

; 6959 : 		{
; 6960 : 			if(*it == eResource)

	cmp	DWORD PTR [edx], ebp
	je	SHORT $LN98@setForceRe@2
	add	edx, 4
	cmp	edx, esi
	jne	SHORT $LL50@setForceRe@2
	jmp	SHORT $LN6@setForceRe@2
$LN98@setForceRe@2:

; 6961 : 			{
; 6962 : 				m_aeRevealedResources.erase(it);

	lea	eax, DWORD PTR [edx+4]
	cmp	eax, esi
	je	SHORT $LN74@setForceRe@2
	sub	edx, eax
$LL76@setForceRe@2:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx+eax], edi
	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL76@setForceRe@2
$LN74@setForceRe@2:
	add	DWORD PTR [ecx+2972], -4		; fffffffcH
$LN6@setForceRe@2:

; 6963 : 				break;
; 6964 : 			}
; 6965 : 		}
; 6966 : 	}
; 6967 : 
; 6968 : #ifdef AUI_WARNING_FIXES
; 6969 : 	for (uint iI = 0; iI < GC.getMap().numPlots(); ++iI)
; 6970 : #else
; 6971 : 	for(int iI = 0; iI < GC.getMap().numPlots(); ++iI)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [eax+4028], ebx
	jle	SHORT $LN104@setForceRe@2
	xor	edi, edi
	npad	5
$LL4@setForceRe@2:

; 6972 : #endif
; 6973 : 	{
; 6974 : 		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [eax+4068]
	add	esi, edi

; 6975 : 
; 6976 : 		if(pLoopPlot->getResourceType() == eResource)

	push	-1
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, ebp
	jne	SHORT $LN3@setForceRe@2

; 6977 : 		{
; 6978 : 			pLoopPlot->updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6979 : 			pLoopPlot->setLayoutDirty(true);

	push	1
	mov	ecx, esi
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN3@setForceRe@2:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	ebx
	add	edi, 484				; 000001e4H
	cmp	ebx, DWORD PTR [eax+4028]
	jl	SHORT $LL4@setForceRe@2
$LN104@setForceRe@2:
	pop	ebx
$LN2@setForceRe@2:
	pop	edi
	pop	esi
	pop	ebp

; 6980 : 		}
; 6981 : 	}
; 6982 : }

	ret	8
?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z ENDP ; CvTeam::setForceRevealedResource
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+4]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [edi*4+4]
	lea	ebx, DWORD PTR [ebx*4+4]
	lea	eax, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [ebx+edi]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > >::Alloc
	sub	eax, ebx
	mov	ecx, eax
	and	ecx, 3
	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi+12]
	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	edx, eax
	and	edx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx
	mov	edx, DWORD PTR [esi]
	pop	edi
	add	ecx, 4
	pop	esi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z		; CvTeam::shareItems
EXTRN	?processBuilding@CvPlayer@@QAEXW4BuildingTypes@@H_NPAVCvArea@@@Z:PROC ; CvPlayer::processBuilding
EXTRN	?area@CvCity@@QBEPAVCvArea@@XZ:PROC		; CvCity::area
EXTRN	?IsTeamShare@CvBuildingEntry@@QBE_NXZ:PROC	; CvBuildingEntry::IsTeamShare
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv524 = -12						; size = 4
_kPlayer$223691 = -8					; size = 4
_iLoop$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z PROC		; CvTeam::shareItems, COMDAT
; _this$ = ecx

; 628  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 629  : 	CvCity* pLoopCity;
; 630  : 	int iLoop;
; 631  : #ifdef AUI_WARNING_FIXES
; 632  : 	uint iI, iJ;
; 633  : 	int iK;
; 634  : #else
; 635  : 	int iI, iJ, iK;
; 636  : #endif
; 637  : 
; 638  : 	CvAssert(eTeam != NO_TEAM);
; 639  : 	CvAssert(eTeam != GetID());
; 640  : 
; 641  : 	CvTeam& kTeam = GET_TEAM(eTeam);

	mov	edi, DWORD PTR _eTeam$[esp+28]
	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ebp, ecx

; 642  : 
; 643  : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+32], ebp
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN25@shareItems
	npad	3
$LL27@shareItems:

; 644  : 	{
; 645  : 		if(kTeam.GetTeamTechs()->HasTech((TechTypes)iI))

	mov	ecx, DWORD PTR [edi+2980]
	push	esi
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN26@shareItems

; 646  : 		{
; 647  : 			setHasTech(((TechTypes)iI), true, NO_PLAYER, true, false);

	push	0
	push	1
	push	-1
	push	1
	push	esi
	mov	ecx, ebp
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech
$LN26@shareItems:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	SHORT $LL27@shareItems
$LN25@shareItems:

; 648  : 		}
; 649  : 	}
; 650  : 
; 651  : 	for(iI = 0; iI < GC.getNumResourceInfos(); ++iI)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN21@shareItems
	npad	1
$LL23@shareItems:

; 652  : 	{
; 653  : 		if(kTeam.isForceRevealedResource((ResourceTypes)iI))

	mov	eax, DWORD PTR [edi+2968]
	mov	ecx, DWORD PTR [edi+2972]
	cmp	eax, ecx
	je	SHORT $LN22@shareItems
$LL46@shareItems:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN107@shareItems
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL46@shareItems
	jmp	SHORT $LN22@shareItems
$LN107@shareItems:

; 654  : 		{
; 655  : 			setForceRevealedResource((ResourceTypes)iI, true);

	push	1
	push	esi
	mov	ecx, ebp
	call	?setForceRevealedResource@CvTeam@@QAEXW4ResourceTypes@@_N@Z ; CvTeam::setForceRevealedResource
$LN22@shareItems:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL23@shareItems
$LN21@shareItems:

; 656  : 		}
; 657  : 	}
; 658  : 
; 659  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	esi, esi
	mov	DWORD PTR tv524[esp+32], esi
	npad	4
$LL114@shareItems:

; 660  : 	{
; 661  : 		CvPlayerAI& kPlayer = GET_PLAYER(static_cast<PlayerTypes>(iI));

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 662  : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	edi, DWORD PTR [esi+eax]
	mov	DWORD PTR _kPlayer$223691[esp+32], edi
	je	$LN18@shareItems

; 663  : 		{
; 664  : 			if(kPlayer.getTeam() == eTeam)

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN68@shareItems
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN69@shareItems
$LN68@shareItems:
	or	eax, -1
$LN69@shareItems:
	cmp	eax, DWORD PTR _eTeam$[esp+28]
	jne	$LN18@shareItems

; 665  : 			{
; 666  : 				for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+36]
	push	eax
	mov	ecx, edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN18@shareItems
	npad	11
$LL113@shareItems:

; 667  : 				{
; 668  : 					for(iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN13@shareItems
$LL111@shareItems:

; 669  : 					{
; 670  : 						const BuildingTypes eBuilding = static_cast<BuildingTypes>(iJ);
; 671  : 						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	edi, eax

; 672  : 						if(pkBuildingInfo)

	test	edi, edi
	je	$LN10@shareItems

; 673  : 						{
; 674  : 							if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	push	esi
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	$LN10@shareItems

; 675  : 							{
; 676  : 								if(!isObsoleteBuilding(eBuilding))

	mov	ecx, DWORD PTR [ebp+2936]
	cmp	DWORD PTR [ecx+esi*4], 0
	jg	$LN10@shareItems

; 677  : 								{
; 678  : 									if(pkBuildingInfo->IsTeamShare())

	mov	ecx, edi
	call	?IsTeamShare@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsTeamShare
	test	al, al
	je	SHORT $LN2@shareItems

; 679  : 									{
; 680  : 										for(iK = 0; iK < MAX_PLAYERS; iK++)

	xor	ebp, ebp
	npad	3
$LL4@shareItems:

; 681  : 										{
; 682  : 											CvPlayerAI& kOtherPlayer = GET_PLAYER(static_cast<PlayerTypes>(iK));

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 683  : 											if(kOtherPlayer.isAlive() && kOtherPlayer.getTeam() == m_eID)

	cmp	BYTE PTR [edx+ebp+2256], 0
	lea	edi, DWORD PTR [edx+ebp]
	je	SHORT $LN3@shareItems
	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN87@shareItems
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN88@shareItems
$LN87@shareItems:
	or	eax, -1
$LN88@shareItems:
	mov	ecx, DWORD PTR _this$[esp+32]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN3@shareItems

; 684  : 											{
; 685  : 												kOtherPlayer.processBuilding(eBuilding, pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding), /*bFirst*/ false, pLoopCity->area());

	mov	ecx, ebx
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	push	eax
	push	0
	push	esi
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	push	eax
	push	esi
	mov	ecx, edi
	call	?processBuilding@CvPlayer@@QAEXW4BuildingTypes@@H_NPAVCvArea@@@Z ; CvPlayer::processBuilding
$LN3@shareItems:
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 4047104				; 003dc100H
	jl	SHORT $LL4@shareItems

; 679  : 									{
; 680  : 										for(iK = 0; iK < MAX_PLAYERS; iK++)

	mov	ebp, DWORD PTR _this$[esp+32]
$LN2@shareItems:

; 686  : 											}
; 687  : 										}
; 688  : 									}
; 689  : 
; 690  : 									processBuilding(eBuilding, pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding), /*bFirst*/ false);

	push	0
	push	esi
	mov	ecx, ebx
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	push	eax
	push	esi
	mov	ecx, ebp
	call	?processBuilding@CvTeam@@QAEXW4BuildingTypes@@H_N@Z ; CvTeam::processBuilding
$LN10@shareItems:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	esi, eax
	jl	$LL111@shareItems

; 667  : 				{
; 668  : 					for(iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)

	mov	edi, DWORD PTR _kPlayer$223691[esp+32]
$LN13@shareItems:

; 665  : 			{
; 666  : 				for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+36]
	push	edx
	mov	ecx, edi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL113@shareItems
	mov	esi, DWORD PTR tv524[esp+32]
$LN18@shareItems:

; 656  : 		}
; 657  : 	}
; 658  : 
; 659  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	mov	DWORD PTR tv524[esp+32], esi
	jl	$LL114@shareItems
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 691  : 								}
; 692  : 							}
; 693  : 						}
; 694  : 					}
; 695  : 				}
; 696  : 			}
; 697  : 		}
; 698  : 	}
; 699  : 
; 700  : }

	add	esp, 16					; 00000010H
	ret	4
?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z ENDP		; CvTeam::shareItems
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);
; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _nBytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pData$[esp]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	edi, DWORD PTR [edi*4+4]
	lea	eax, DWORD PTR [edi+edx]
	push	eax
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	ecx, eax
	and	ecx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	add	edx, 4
	pop	edi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z		; CvTeam::addTeam
EXTRN	?updateScore@CvGame@@QAEX_N@Z:PROC		; CvGame::updateScore
EXTRN	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z:PROC ; CvPlot::changeInvisibleVisibilityCount
EXTRN	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z:PROC ; CvPlot::getInvisibleVisibilityCount
EXTRN	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z:PROC ; CvPlot::changeVisibilityCount
EXTRN	?setTeam@CvPlayer@@QAEXW4TeamTypes@@@Z:PROC	; CvPlayer::setTeam
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv1431 = -136						; size = 4
tv1113 = -136						; size = 4
_iI$ = -136						; size = 4
_uiOffset$251553 = -132					; size = 4
$T250861 = -132						; size = 4
$T250854 = -132						; size = 4
tv1256 = -128						; size = 4
$T250859 = -128						; size = 4
$T250856 = -128						; size = 4
_strBuffer$ = -124					; size = 28
$T250860 = -96						; size = 28
$T250858 = -96						; size = 28
$T250862 = -68						; size = 28
$T250857 = -68						; size = 28
$T250863 = -40						; size = 28
$T250855 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z PROC		; CvTeam::addTeam, COMDAT
; _this$ = ecx

; 410  : {

	push	-1
	push	__ehhandler$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 411  : 	CvPlot* pLoopPlot;
; 412  : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebp, DWORD PTR _eTeam$[esp+148]
	mov	esi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+160], ebx
	mov	DWORD PTR tv1431[esp+152], ebx
$LL460@addTeam:

; 424  : 	{
; 425  : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	eax, DWORD PTR tv1431[esp+152]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [eax+ecx+2256], 0
	je	$LN73@addTeam

; 426  : 		{
; 427  : 			if((GET_PLAYER((PlayerTypes)iI).getTeam() != GetID()) && (GET_PLAYER((PlayerTypes)iI).getTeam() != eTeam))

	mov	edx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR [edx+eax+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN99@addTeam
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN100@addTeam
$LN99@addTeam:
	or	eax, -1
$LN100@addTeam:
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, edx
	je	$LN73@addTeam
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN112@addTeam
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN113@addTeam
$LN112@addTeam:
	or	eax, -1
$LN113@addTeam:
	cmp	eax, ebp
	je	$LN73@addTeam

; 428  : 			{
; 429  : 				if(GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).isHasMet(GetID()) && GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).isHasMet(eTeam))

	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN125@addTeam
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN126@addTeam
$LN125@addTeam:
	or	eax, -1
$LN126@addTeam:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [eax+edx+1848], 0
	je	$LN73@addTeam
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN142@addTeam
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN143@addTeam
$LN142@addTeam:
	or	eax, -1
$LN143@addTeam:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	BYTE PTR [eax+ebp+1848], 0
	je	$LN73@addTeam

; 430  : 				{
; 431  : 					if(iI == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebx, eax
	jne	$LN455@addTeam

; 432  : 					{
; 433  : 						strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYER_PERMANENT_ALLIANCE", getName().GetCString(), GET_TEAM(eTeam).getName().GetCString());

	mov	ecx, ebp
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	eax, DWORD PTR $T250855[esp+152]
	push	eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+160], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR $T250857[esp+152]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T250854[esp+156], eax
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+160], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	edx, DWORD PTR $T250854[esp+152]
	push	edx
	mov	DWORD PTR $T250856[esp+156], eax
	lea	eax, DWORD PTR $T250856[esp+156]
	push	eax
	lea	ecx, DWORD PTR $T250858[esp+160]
	push	OFFSET $SG223545
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 3
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T250858[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T250857[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T250855[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 434  : 						DLLUI->AddMessage(0, ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_THEIRALLIANCE", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_HIGHLIGHT_TEXT")*/);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	lea	ecx, DWORD PTR _strBuffer$[esp+152]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	0
	mov	edx, DWORD PTR [esi]
	push	0
	mov	edx, DWORD PTR [edx+160]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	ebx
	push	0
	mov	ecx, esi
	call	edx
$LN455@addTeam:
	mov	esi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
$LN73@addTeam:

; 413  : #ifdef AUI_WARNING_FIXES
; 414  : 	int iI;
; 415  : 	uint iJ;
; 416  : #else
; 417  : 	int iI, iJ;
; 418  : #endif
; 419  : 
; 420  : 	CvAssert(eTeam != NO_TEAM);
; 421  : 	CvAssert(eTeam != GetID());
; 422  : 
; 423  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	eax, DWORD PTR tv1431[esp+152]
	add	eax, 63236				; 0000f704H
	inc	ebx
	cmp	eax, 4047104				; 003dc100H
	mov	DWORD PTR tv1431[esp+152], eax
	jl	$LL460@addTeam

; 435  : 					}
; 436  : 				}
; 437  : 			}
; 438  : 		}
; 439  : 	}
; 440  : 
; 441  : 	strBuffer = GetLocalizedText("TXT_KEY_MISC_PLAYER_PERMANENT_ALLIANCE", getName().GetCString(), GET_TEAM(eTeam).getName().GetCString());

	mov	ebp, DWORD PTR _eTeam$[esp+148]
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	esi, ebp
	imul	esi, 2984				; 00000ba8H
	lea	edx, DWORD PTR $T250860[esp+152]
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	mov	DWORD PTR tv1113[esp+156], esi
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+160], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T250859[esp+152], eax
	lea	eax, DWORD PTR $T250862[esp+152]
	push	eax
	mov	ecx, edi
	call	?getName@CvTeam@@QBE?AVCvString@@XZ	; CvTeam::getName
	mov	bl, 5
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+160], bl
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR $T250859[esp+152]
	push	ecx
	lea	edx, DWORD PTR $T250861[esp+156]
	push	edx
	mov	DWORD PTR $T250861[esp+160], eax
	lea	eax, DWORD PTR $T250863[esp+160]
	push	OFFSET $SG223552
	push	eax
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T250863[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T250862[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T250860[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 442  : 	GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, getLeaderID(), strBuffer, -1, -1);

	push	-1
	push	-1
	lea	ecx, DWORD PTR _strBuffer$[esp+160]
	push	ecx
	mov	ecx, edi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	0
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage

; 443  : 
; 444  : 	// To be replaced with new diplomatic code
; 445  : 
; 446  : 	shareItems(eTeam);

	push	ebp
	mov	ecx, edi
	call	?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::shareItems

; 447  : 	GET_TEAM(eTeam).shareItems(GetID());

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	lea	ecx, DWORD PTR [esi+edx]
	call	?shareItems@CvTeam@@QAEXW4TeamTypes@@@Z	; CvTeam::shareItems
	mov	ebx, DWORD PTR tv1113[esp+152]

; 448  : 
; 449  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	esi, esi
	xor	ebp, ebp
$LL67@addTeam:

; 450  : 	{
; 451  : 		if((iI != GetID()) && (iI != eTeam))

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN66@addTeam
	cmp	esi, DWORD PTR _eTeam$[esp+148]
	je	SHORT $LN66@addTeam

; 452  : 		{
; 453  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [eax+ebp+12], 0
	jle	SHORT $LN66@addTeam

; 454  : 			{
; 455  : 				if(GET_TEAM(eTeam).isHasMet((TeamTypes)iI))

	lea	ecx, DWORD PTR [ebx+eax]
	cmp	BYTE PTR [ecx+esi+1848], 0
	je	SHORT $LN62@addTeam

; 456  : 				{
; 457  : 					meet(((TeamTypes)iI), false);

	mov	ecx, edi
	jmp	SHORT $LN466@addTeam
$LN62@addTeam:

; 458  : 				}
; 459  : 				else if(isHasMet((TeamTypes)iI))

	cmp	BYTE PTR [esi+edi+1848], 0
	je	SHORT $LN66@addTeam
$LN466@addTeam:

; 460  : 				{
; 461  : 					GET_TEAM(eTeam).meet((TeamTypes)iI, false);

	push	0
	push	esi
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
$LN66@addTeam:
	add	ebp, 2984				; 00000ba8H
	inc	esi
	cmp	ebp, 190976				; 0002ea00H
	jl	SHORT $LL67@addTeam

; 462  : 				}
; 463  : 			}
; 464  : 		}
; 465  : 	}
; 466  : 
; 467  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	esi, esi
	xor	ebp, ebp
$LL461@addTeam:

; 468  : 	{
; 469  : 		if((iI != GetID()) && (iI != eTeam))

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN58@addTeam
	cmp	esi, DWORD PTR _eTeam$[esp+148]
	je	SHORT $LN58@addTeam

; 470  : 		{
; 471  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [eax+ebp+12], 0
	jle	SHORT $LN58@addTeam

; 472  : 			{
; 473  : 				if(GET_TEAM(eTeam).isAtWar((TeamTypes)iI))

	lea	ecx, DWORD PTR [ebx+eax]
	cmp	BYTE PTR [ecx+esi+1928], 0
	je	SHORT $LN54@addTeam

; 474  : 				{
; 475  : 					declareWar(((TeamTypes)iI));

	mov	ecx, edi
	jmp	SHORT $LN467@addTeam
$LN54@addTeam:

; 476  : 				}
; 477  : 				else if(isAtWar((TeamTypes)iI))

	cmp	BYTE PTR [esi+edi+1928], 0
	je	SHORT $LN58@addTeam
$LN467@addTeam:

; 478  : 				{
; 479  : 					GET_TEAM(eTeam).declareWar(((TeamTypes)iI));

	push	0
	push	0
	push	esi
	call	?DoDeclareWar@CvTeam@@IAEXW4TeamTypes@@_N1@Z ; CvTeam::DoDeclareWar
	call	?RefreshDangerPlots@CvPlayerManager@@SAXXZ ; CvPlayerManager::RefreshDangerPlots
$LN58@addTeam:
	add	ebp, 2984				; 00000ba8H
	inc	esi
	cmp	ebp, 190976				; 0002ea00H
	jl	SHORT $LL461@addTeam

; 480  : 				}
; 481  : 			}
; 482  : 		}
; 483  : 	}
; 484  : 
; 485  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	mov	esi, DWORD PTR _eTeam$[esp+148]
	xor	eax, eax
	xor	edx, edx
$LL51@addTeam:

; 486  : 	{
; 487  : 		if((iI != GetID()) && (iI != eTeam))

	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN50@addTeam
	cmp	eax, esi
	je	SHORT $LN50@addTeam

; 488  : 		{
; 489  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [edx+ecx+12], 0
	jle	SHORT $LN50@addTeam

; 490  : 			{
; 491  : 				if(GET_TEAM(eTeam).isPermanentWarPeace((TeamTypes)iI))

	add	ecx, ebx
	cmp	BYTE PTR [ecx+eax+2008], 0
	je	SHORT $LN46@addTeam

; 492  : 				{
; 493  : 					setPermanentWarPeace(((TeamTypes)iI), true);

	mov	BYTE PTR [eax+edi+2008], 1
	jmp	SHORT $LN50@addTeam
$LN46@addTeam:

; 494  : 				}
; 495  : 				else if(isPermanentWarPeace((TeamTypes)iI))

	cmp	BYTE PTR [eax+edi+2008], 0
	je	SHORT $LN50@addTeam

; 496  : 				{
; 497  : 					GET_TEAM(eTeam).setPermanentWarPeace(((TeamTypes)iI), true);

	mov	BYTE PTR [ecx+eax+2008], 1
$LN50@addTeam:

; 480  : 				}
; 481  : 			}
; 482  : 		}
; 483  : 	}
; 484  : 
; 485  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	add	edx, 2984				; 00000ba8H
	inc	eax
	cmp	edx, 190976				; 0002ea00H
	jl	SHORT $LL51@addTeam

; 498  : 				}
; 499  : 			}
; 500  : 		}
; 501  : 	}
; 502  : 
; 503  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	esi, esi
	xor	ebp, ebp
$LL462@addTeam:

; 504  : 	{
; 505  : 		if((iI != GetID()) && (iI != eTeam))

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN42@addTeam
	cmp	esi, DWORD PTR _eTeam$[esp+148]
	je	SHORT $LN42@addTeam

; 506  : 		{
; 507  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [eax+ebp+12], 0
	jle	SHORT $LN42@addTeam

; 508  : 			{
; 509  : 				if(GET_TEAM(eTeam).HasEmbassyAtTeam((TeamTypes)iI))

	lea	ecx, DWORD PTR [ebx+eax]
	cmp	BYTE PTR [ecx+esi+2088], 0
	je	SHORT $LN38@addTeam

; 510  : 				{
; 511  : 					SetHasEmbassyAtTeam(((TeamTypes)iI), true);

	mov	ecx, edi
	jmp	SHORT $LN468@addTeam
$LN38@addTeam:

; 512  : 				}
; 513  : 				else if(HasEmbassyAtTeam((TeamTypes)iI))

	cmp	BYTE PTR [esi+edi+2088], 0
	je	SHORT $LN42@addTeam
$LN468@addTeam:

; 514  : 				{
; 515  : 					GET_TEAM(eTeam).SetHasEmbassyAtTeam(((TeamTypes)iI), true);

	push	1
	push	esi
	call	?SetHasEmbassyAtTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasEmbassyAtTeam
$LN42@addTeam:
	add	ebp, 2984				; 00000ba8H
	inc	esi
	cmp	ebp, 190976				; 0002ea00H
	jl	SHORT $LL462@addTeam

; 516  : 				}
; 517  : 			}
; 518  : 		}
; 519  : 	}
; 520  : 
; 521  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	esi, esi
	xor	ebp, ebp
$LL463@addTeam:

; 522  : 	{
; 523  : 		if((iI != GetID()) && (iI != eTeam))

	cmp	esi, DWORD PTR [edi+4]
	je	$LN34@addTeam
	cmp	esi, DWORD PTR _eTeam$[esp+148]
	je	$LN34@addTeam

; 524  : 		{
; 525  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [eax+ebp+12], 0
	jle	SHORT $LN34@addTeam

; 526  : 			{
; 527  : 				if(GET_TEAM(eTeam).IsAllowsOpenBordersToTeam((TeamTypes)iI))

	cmp	DWORD PTR [ebx+eax+140], esi
	lea	ecx, DWORD PTR [ebx+eax]
	jne	SHORT $LN293@addTeam
	cmp	BYTE PTR [ecx+esi+1928], 0
	je	SHORT $LN453@addTeam
$LN293@addTeam:
	cmp	BYTE PTR [ecx+esi+2168], 0
	je	SHORT $LN30@addTeam
$LN453@addTeam:

; 528  : 				{
; 529  : 					SetAllowsOpenBordersToTeam(((TeamTypes)iI), true);

	push	1
	push	esi
	mov	ecx, edi
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 530  : 					GET_TEAM((TeamTypes)iI).SetAllowsOpenBordersToTeam(GetID(), true);

	mov	eax, DWORD PTR [edi+4]
	push	1
	push	eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [eax+ebp]
	jmp	SHORT $LN469@addTeam
$LN30@addTeam:

; 531  : 				}
; 532  : 				else if(IsAllowsOpenBordersToTeam((TeamTypes)iI))

	cmp	DWORD PTR [edi+140], esi
	jne	SHORT $LN308@addTeam
	cmp	BYTE PTR [esi+edi+1928], 0
	je	SHORT $LN454@addTeam
$LN308@addTeam:
	cmp	BYTE PTR [esi+edi+2168], 0
	je	SHORT $LN34@addTeam
$LN454@addTeam:

; 533  : 				{
; 534  : 					GET_TEAM(eTeam).SetAllowsOpenBordersToTeam(((TeamTypes)iI), true);

	push	1
	push	esi
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam

; 535  : 					GET_TEAM((TeamTypes)iI).SetAllowsOpenBordersToTeam(eTeam, true);

	mov	ecx, DWORD PTR _eTeam$[esp+148]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	ecx
	lea	ecx, DWORD PTR [edx+ebp]
$LN469@addTeam:
	call	?SetAllowsOpenBordersToTeam@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetAllowsOpenBordersToTeam
$LN34@addTeam:

; 516  : 				}
; 517  : 			}
; 518  : 		}
; 519  : 	}
; 520  : 
; 521  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	add	ebp, 2984				; 00000ba8H
	inc	esi
	cmp	ebp, 190976				; 0002ea00H
	jl	$LL463@addTeam

; 536  : 				}
; 537  : 			}
; 538  : 		}
; 539  : 	}
; 540  : 
; 541  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	esi, esi
	xor	ebp, ebp
$LL464@addTeam:

; 542  : 	{
; 543  : 		if((iI != GetID()) && (iI != eTeam))

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN26@addTeam
	cmp	esi, DWORD PTR _eTeam$[esp+148]
	je	SHORT $LN26@addTeam

; 544  : 		{
; 545  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [eax+ebp+12], 0
	jle	SHORT $LN26@addTeam

; 546  : 			{
; 547  : 				if(GET_TEAM(eTeam).IsHasDefensivePact((TeamTypes)iI))

	lea	ecx, DWORD PTR [ebx+eax]
	cmp	BYTE PTR [ecx+esi+2248], 0
	je	SHORT $LN22@addTeam

; 548  : 				{
; 549  : 					SetHasDefensivePact(((TeamTypes)iI), true);

	push	1
	push	esi
	mov	ecx, edi
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 550  : 					GET_TEAM((TeamTypes)iI).SetHasDefensivePact(GetID(), true);

	mov	eax, DWORD PTR [edi+4]
	push	1
	push	eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [eax+ebp]
	jmp	SHORT $LN470@addTeam
$LN22@addTeam:

; 551  : 				}
; 552  : 				else if(IsHasDefensivePact((TeamTypes)iI))

	cmp	BYTE PTR [esi+edi+2248], 0
	je	SHORT $LN26@addTeam

; 553  : 				{
; 554  : 					GET_TEAM(eTeam).SetHasDefensivePact(((TeamTypes)iI), true);

	push	1
	push	esi
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact

; 555  : 					GET_TEAM((TeamTypes)iI).SetHasDefensivePact(eTeam, true);

	mov	ecx, DWORD PTR _eTeam$[esp+148]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	ecx
	lea	ecx, DWORD PTR [edx+ebp]
$LN470@addTeam:
	call	?SetHasDefensivePact@CvTeam@@QAEXW4TeamTypes@@_N@Z ; CvTeam::SetHasDefensivePact
$LN26@addTeam:

; 536  : 				}
; 537  : 			}
; 538  : 		}
; 539  : 	}
; 540  : 
; 541  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	add	ebp, 2984				; 00000ba8H
	inc	esi
	cmp	ebp, 190976				; 0002ea00H
	jl	SHORT $LL464@addTeam

; 556  : 				}
; 557  : 			}
; 558  : 		}
; 559  : 	}
; 560  : 
; 561  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	xor	eax, eax
	xor	ecx, ecx
	npad	2
$LL19@addTeam:

; 562  : 	{
; 563  : 		if((iI != GetID()) && (iI != eTeam))

	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN18@addTeam
	cmp	eax, DWORD PTR _eTeam$[esp+148]
	je	SHORT $LN18@addTeam

; 564  : 		{
; 565  : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [ecx+edx+12], 0
	jle	SHORT $LN18@addTeam

; 566  : 			{
; 567  : 				if(GET_TEAM(eTeam).isForcePeace((TeamTypes)iI))

	add	edx, ebx
	cmp	BYTE PTR [edx+eax+2488], 0
	je	SHORT $LN14@addTeam

; 568  : 				{
; 569  : 					setForcePeace(((TeamTypes)iI), true);

	mov	BYTE PTR [eax+edi+2488], 1

; 570  : 					GET_TEAM((TeamTypes)iI).setForcePeace(GetID(), true);

	mov	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR [edi+4]
	add	esi, ecx
	jmp	SHORT $LN471@addTeam
$LN14@addTeam:

; 571  : 				}
; 572  : 				else if(isForcePeace((TeamTypes)iI))

	cmp	BYTE PTR [eax+edi+2488], 0
	je	SHORT $LN18@addTeam

; 573  : 				{
; 574  : 					GET_TEAM(eTeam).setForcePeace(((TeamTypes)iI), true);
; 575  : 					GET_TEAM((TeamTypes)iI).setForcePeace(eTeam, true);

	mov	esi, DWORD PTR _eTeam$[esp+148]
	mov	BYTE PTR [edx+eax+2488], 1
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	edx, ecx
$LN471@addTeam:
	mov	BYTE PTR [edx+esi+2488], 1
$LN18@addTeam:

; 556  : 				}
; 557  : 			}
; 558  : 		}
; 559  : 	}
; 560  : 
; 561  : 	for(iI = 0; iI < MAX_TEAMS; iI++)

	add	ecx, 2984				; 00000ba8H
	inc	eax
	cmp	ecx, 190976				; 0002ea00H
	jl	SHORT $LL19@addTeam

; 576  : 				}
; 577  : 			}
; 578  : 		}
; 579  : 	}
; 580  : 
; 581  : 	shareCounters(eTeam);

	mov	ebp, DWORD PTR _eTeam$[esp+148]
	push	ebp
	mov	ecx, edi
	call	?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::shareCounters

; 582  : 	GET_TEAM(eTeam).shareCounters(GetID());

	mov	eax, DWORD PTR [edi+4]
	push	eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [ebx+eax]
	call	?shareCounters@CvTeam@@QAEXW4TeamTypes@@@Z ; CvTeam::shareCounters
	xor	esi, esi
	npad	10
$LL11@addTeam:

; 583  : 
; 584  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)
; 585  : 	{
; 586  : 		if(GET_PLAYER((PlayerTypes)iI).getTeam() == eTeam)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+esi+44]
	add	ecx, esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN397@addTeam
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN398@addTeam
$LN397@addTeam:
	or	eax, -1
$LN398@addTeam:
	cmp	eax, ebp
	jne	SHORT $LN10@addTeam

; 587  : 		{
; 588  : 			GET_PLAYER((PlayerTypes)iI).setTeam(GetID());

	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	?setTeam@CvPlayer@@QAEXW4TeamTypes@@@Z	; CvPlayer::setTeam
$LN10@addTeam:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL11@addTeam

; 589  : 		}
; 590  : 	}
; 591  : 
; 592  : 	const int iNumInvisibleInfos = NUM_INVISIBLE_TYPES;
; 593  : #ifdef AUI_WARNING_FIXES
; 594  : 	for (iJ = 0; iJ < GC.getMap().numPlots(); iJ++)
; 595  : 	{
; 596  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iJ);
; 597  : #else
; 598  : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [eax+4028], 0
	mov	DWORD PTR _iI$[esp+152], 0
	jle	$LN457@addTeam
	mov	ecx, ebp
	mov	edx, ecx
	shr	edx, 5
	mov	DWORD PTR _uiOffset$251553[esp+152], edx

; 599  : 	{
; 600  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
; 601  : #endif
; 602  : 
; 603  : 		pLoopPlot->changeVisibilityCount(GetID(), pLoopPlot->getVisibilityCount(eTeam), NO_INVISIBLE, true, false);
; 604  : 
; 605  : #ifdef AUI_WARNING_FIXES
; 606  : 		for (iI = 0; iI < iNumInvisibleInfos; iI++)
; 607  : 		{
; 608  : 			pLoopPlot->changeInvisibleVisibilityCount(GetID(), ((InvisibleTypes)iI), pLoopPlot->getInvisibleVisibilityCount(eTeam, ((InvisibleTypes)iI)));
; 609  : #else
; 610  : 		for(iJ = 0; iJ < iNumInvisibleInfos; iJ++)
; 611  : 		{
; 612  : 			pLoopPlot->changeInvisibleVisibilityCount(GetID(), ((InvisibleTypes)iJ), pLoopPlot->getInvisibleVisibilityCount(eTeam, ((InvisibleTypes)iJ)));
; 613  : #endif
; 614  : 		}
; 615  : 
; 616  : 		if(pLoopPlot->isRevealed(eTeam))

	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	xor	ebx, ebx
	mov	DWORD PTR tv1256[esp+152], edx
	npad	12
$LL7@addTeam:
	mov	esi, DWORD PTR [eax+4068]
	mov	ecx, DWORD PTR [esi+ebx+156]
	mov	edx, DWORD PTR _eTeam$[esp+148]
	movsx	ecx, WORD PTR [ecx+edx*2]
	mov	eax, DWORD PTR [edi+4]
	push	0
	add	esi, ebx
	push	1
	push	-1
	push	ecx
	push	eax
	mov	ecx, esi
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
	mov	edx, DWORD PTR _eTeam$[esp+148]
	mov	ebp, DWORD PTR [edi+4]
	push	0
	push	edx
	mov	ecx, esi
	call	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::getInvisibleVisibilityCount
	push	eax
	push	0
	push	ebp
	mov	ecx, esi
	call	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
	mov	eax, DWORD PTR tv1256[esp+152]
	mov	ecx, DWORD PTR _uiOffset$251553[esp+152]
	test	DWORD PTR [esi+ecx*4+8], eax
	je	SHORT $LN6@addTeam

; 617  : 		{
; 618  : 			pLoopPlot->setRevealed(GetID(), true, false, eTeam);

	mov	edx, DWORD PTR _eTeam$[esp+148]
	mov	eax, DWORD PTR [edi+4]
	push	edx
	push	0
	push	1
	push	eax
	mov	ecx, esi
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
$LN6@addTeam:
	mov	ecx, DWORD PTR _iI$[esp+152]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	ecx
	add	ebx, 484				; 000001e4H
	cmp	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iI$[esp+152], ecx
	jl	$LL7@addTeam
$LN457@addTeam:

; 619  : 		}
; 620  : 	}
; 621  : 
; 622  : 	GC.getGame().updateScore(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	1
	call	?updateScore@CvGame@@QAEX_N@Z		; CvGame::updateScore

; 623  : }

	lea	ecx, DWORD PTR _strBuffer$[esp+152]
	mov	DWORD PTR __$EHRec$[esp+160], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 136				; 00000088H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR $T250855[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$2:
	lea	ecx, DWORD PTR $T250857[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$3:
	lea	ecx, DWORD PTR $T250858[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$4:
	lea	ecx, DWORD PTR $T250860[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$5:
	lea	ecx, DWORD PTR $T250862[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z$6:
	lea	ecx, DWORD PTR $T250863[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addTeam@CvTeam@@QAEXW4TeamTypes@@@Z ENDP		; CvTeam::addTeam
PUBLIC	?Free@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Free@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+4]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [edi*4+4]
	lea	ebx, DWORD PTR [ebx*4+4]
	lea	eax, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [ebx+edi]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > >::Alloc
	sub	eax, ebx
	mov	ecx, eax
	and	ecx, 3
	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi+12]
	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	edx, eax
	and	edx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx
	mov	edx, DWORD PTR [esi]
	pop	edi
	add	ecx, 4
	pop	esi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);
; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _nBytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pData$[esp]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	edi, DWORD PTR [edi*4+4]
	lea	eax, DWORD PTR [edi+edx]
	push	eax
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	ecx, eax
	and	ecx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	add	edx, 4
	pop	edi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+4]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [edi*4+4]
	lea	ebx, DWORD PTR [ebx*4+4]
	lea	eax, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [ebx+edi]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > >::Alloc
	sub	eax, ebx
	mov	ecx, eax
	and	ecx, 3
	mov	edx, eax
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi+12]
	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, edi

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	edx, eax
	and	edx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	ecx, eax
	sub	ecx, edx
	mov	edx, DWORD PTR [esi]
	pop	edi
	add	ecx, 4
	pop	esi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?Free@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ
_TEXT	SEGMENT
?Free@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Free, COMDAT
; _this$ = ecx

; 81   : 	{

	push	esi
	mov	esi, ecx

; 82   : 		BASE::Free();

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi], 0
	pop	esi

; 83   : 	}

	ret	0
?Free@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEXXZ ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);
; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	edx, DWORD PTR _nBytes$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pData$[esp+4]
	mov	esi, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [edi+12]
	push	eax
	inc	esi
	lea	eax, DWORD PTR [esi+edx]
	push	eax
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;
; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);
; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, DWORD PTR [edi]
	sub	eax, esi
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [edx], ecx
	pop	esi

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?uninit@CvTeam@@QAEXXZ				; CvTeam::uninit
EXTRN	?Uninit@CvTeamTechs@@QAEXXZ:PROC		; CvTeamTechs::Uninit
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?uninit@CvTeam@@QAEXXZ
_TEXT	SEGMENT
?uninit@CvTeam@@QAEXXZ PROC				; CvTeam::uninit, COMDAT
; _this$ = ecx

; 115  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 116  : 
; 117  : 	//Free the batch-allocated memory
; 118  : 	m_BatchData.Free();

	mov	eax, DWORD PTR [esi+2888]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+2888], ebx

; 119  : 
; 120  : 	//Set the ptrs to null
; 121  : 	m_abCanLaunch = NULL;
; 122  : 	m_abVictoryAchieved = NULL;
; 123  : 	m_abSmallAwardAchieved = NULL;
; 124  : 
; 125  : 	m_paiRouteChange = NULL;
; 126  : 	m_paiBuildTimeChange = NULL;
; 127  : 	m_paiProjectCount = NULL;
; 128  : 	m_paiProjectDefaultArtTypes = NULL;
; 129  : 	m_pavProjectArtTypes = NULL;
; 130  : 	m_paiProjectMaking = NULL;
; 131  : 	m_paiUnitClassCount = NULL;
; 132  : 	m_paiBuildingClassCount = NULL;
; 133  : 	m_paiObsoleteBuildingCount = NULL;
; 134  : 	m_paiTerrainTradeCount = NULL;
; 135  : 	m_aiVictoryCountdown = NULL;
; 136  : 	m_aiForceTeamVoteEligibilityCount = NULL;
; 137  : 
; 138  : 	m_ppaaiImprovementYieldChange = NULL;
; 139  : 	m_ppaaiImprovementNoFreshWaterYieldChange = NULL;
; 140  : 	m_ppaaiImprovementFreshWaterYieldChange = NULL;
; 141  : 
; 142  : 	m_pTeamTechs->Uninit();

	mov	ecx, DWORD PTR [esi+2980]
	add	esp, 4
	mov	DWORD PTR [esi+2896], ebx
	mov	DWORD PTR [esi+2900], ebx
	mov	DWORD PTR [esi+2904], ebx
	mov	DWORD PTR [esi+2908], ebx
	mov	DWORD PTR [esi+2912], ebx
	mov	DWORD PTR [esi+2916], ebx
	mov	DWORD PTR [esi+2920], ebx
	mov	DWORD PTR [esi+2960], ebx
	mov	DWORD PTR [esi+2924], ebx
	mov	DWORD PTR [esi+2928], ebx
	mov	DWORD PTR [esi+2932], ebx
	mov	DWORD PTR [esi+2936], ebx
	mov	DWORD PTR [esi+2940], ebx
	mov	DWORD PTR [esi+2944], ebx
	mov	DWORD PTR [esi+2892], ebx
	mov	DWORD PTR [esi+2948], ebx
	mov	DWORD PTR [esi+2952], ebx
	mov	DWORD PTR [esi+2956], ebx
	call	?Uninit@CvTeamTechs@@QAEXXZ		; CvTeamTechs::Uninit

; 143  : 
; 144  : 	m_iNumMembers = 0;

	mov	DWORD PTR [esi+8], ebx

; 145  : 	m_iAliveCount = 0;

	mov	DWORD PTR [esi+12], ebx

; 146  : 	m_iEverAliveCount = 0;

	mov	DWORD PTR [esi+16], ebx

; 147  : 	m_iNumCities = 0;

	mov	DWORD PTR [esi+20], ebx

; 148  : 	m_iTotalPopulation = 0;

	mov	DWORD PTR [esi+24], ebx

; 149  : 	m_iTotalLand = 0;

	mov	DWORD PTR [esi+28], ebx

; 150  : 	m_iNukeInterception = 0;

	mov	DWORD PTR [esi+32], ebx

; 151  : 	m_iExtraWaterSeeFromCount = 0;

	mov	DWORD PTR [esi+36], ebx

; 152  : 	m_iMapTradingCount = 0;

	mov	DWORD PTR [esi+40], ebx

; 153  : 	m_iTechTradingCount = 0;

	mov	DWORD PTR [esi+44], ebx

; 154  : 	m_iGoldTradingCount = 0;

	mov	DWORD PTR [esi+48], ebx

; 155  : 	m_iAllowEmbassyTradingAllowedCount = 0;

	mov	DWORD PTR [esi+52], ebx

; 156  : 	m_iOpenBordersTradingAllowedCount = 0;

	mov	DWORD PTR [esi+56], ebx

; 157  : 	m_iDefensivePactTradingAllowedCount = 0;

	mov	DWORD PTR [esi+60], ebx

; 158  : 	m_iResearchAgreementTradingAllowedCount = 0;

	mov	DWORD PTR [esi+64], ebx

; 159  : 	m_iTradeAgreementTradingAllowedCount = 0;

	mov	DWORD PTR [esi+68], ebx

; 160  : 	m_iPermanentAllianceTradingCount = 0;

	mov	DWORD PTR [esi+72], ebx

; 161  : 	m_iBridgeBuildingCount = 0;

	mov	DWORD PTR [esi+76], ebx

; 162  : 	m_iWaterWorkCount = 0;

	mov	DWORD PTR [esi+80], ebx

; 163  : 	m_iRiverTradeCount = 0;

	mov	DWORD PTR [esi+84], ebx

; 164  : 	m_iBorderObstacleCount = 0;

	mov	DWORD PTR [esi+88], ebx

; 165  : 	m_iVictoryPoints = 0;

	mov	DWORD PTR [esi+92], ebx

; 166  : 	m_iEmbarkedExtraMoves = 0;

	mov	DWORD PTR [esi+96], ebx

; 167  : 	//EAP: Extra embarked visibility on tech
; 168  : 	m_iEmbarkedExtraSight = 0;

	mov	DWORD PTR [esi+100], ebx

; 169  : 	m_iCanEmbarkCount = 0;

	mov	DWORD PTR [esi+104], ebx

; 170  : 	m_iDefensiveEmbarkCount = 0;

	mov	DWORD PTR [esi+108], ebx

; 171  : 	m_iEmbarkedAllWaterPassageCount = 0;

	mov	DWORD PTR [esi+112], ebx

; 172  : 	m_iNumNaturalWondersDiscovered = 0;

	mov	DWORD PTR [esi+116], ebx

; 173  : 	m_iBestPossibleRoute = NO_ROUTE;

	or	edi, -1
	mov	DWORD PTR [esi+120], edi

; 174  : 	m_iNumMinorCivsAttacked = 0;

	mov	DWORD PTR [esi+124], ebx

; 175  : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 176  : 	m_iBestRouteFlatCostMultiplier = 0;
; 177  : 	m_iBestRouteNormalCostMultiplier = 1;
; 178  : 	m_iUseFlatCostIfBelowThis = -1;
; 179  : #endif
; 180  : 
; 181  : 	m_bMapCentering = false;

	mov	BYTE PTR [esi+128], bl

; 182  : 	m_bHasBrokenPeaceTreaty = false;

	mov	BYTE PTR [esi+129], bl

; 183  : 	m_bHomeOfUnitedNations = false;

	mov	BYTE PTR [esi+130], bl

; 184  : 	m_bHasTechForWorldCongress = false;

	mov	BYTE PTR [esi+131], bl

; 185  : 
; 186  : 	m_bBrokenMilitaryPromise = false;

	mov	BYTE PTR [esi+132], bl

; 187  : 	m_bBrokenExpansionPromise = false;

	mov	BYTE PTR [esi+133], bl

; 188  : 	m_bBrokenBorderPromise = false;

	mov	BYTE PTR [esi+134], bl

; 189  : 	m_bBrokenCityStatePromise = false;

	mov	BYTE PTR [esi+135], bl

; 190  : 
; 191  : 	m_eCurrentEra = ((EraTypes) 0);

	mov	DWORD PTR [esi+136], ebx

; 192  : 
; 193  : 	m_eLiberatedByTeam = NO_TEAM;

	mov	DWORD PTR [esi+140], edi

; 194  : 	m_eKilledByTeam = NO_TEAM;

	mov	DWORD PTR [esi+144], edi

; 195  : 
; 196  : 	for(int i = 0; i < NUM_DOMAIN_TYPES; i++)
; 197  : 	{
; 198  : 		m_aiExtraMoves[i] = 0;

	mov	DWORD PTR [esi+1108], ebx
	mov	DWORD PTR [esi+1112], ebx
	mov	DWORD PTR [esi+1116], ebx
	mov	DWORD PTR [esi+1120], ebx
	mov	DWORD PTR [esi+1124], ebx
	lea	eax, DWORD PTR [esi+1928]
	lea	ecx, DWORD PTR [esi+1128]
	lea	edx, DWORD PTR [ebx+64]
	npad	1
$LL6@uninit:

; 199  : 	}
; 200  : 
; 201  : 	for(int i = 0; i < MAX_TEAMS; i++)
; 202  : 	{
; 203  : 		m_aiTechShareCount[i] = 0;

	mov	DWORD PTR [ecx-980], ebx

; 204  : 		m_paiTurnMadePeaceTreatyWithTeam[i] = -1;

	mov	DWORD PTR [ecx], edi

; 205  : 		m_aiIgnoreWarningCount[i] = 0;

	mov	DWORD PTR [ecx+320], ebx

; 206  : 		m_abHasMet[i] = false;

	mov	BYTE PTR [eax-80], bl

; 207  : 		m_abAtWar[i] = false;

	mov	BYTE PTR [eax], bl

; 208  : 		m_abPermanentWarPeace[i] = false;

	mov	BYTE PTR [eax+80], bl

; 209  : 		m_abEmbassy[i] = false;

	mov	BYTE PTR [eax+160], bl

; 210  : 		m_abOpenBorders[i] = false;

	mov	BYTE PTR [eax+240], bl

; 211  : 		m_abDefensivePact[i] = false;

	mov	BYTE PTR [eax+320], bl

; 212  : 		m_abResearchAgreement[i] = false;

	mov	BYTE PTR [eax+400], bl

; 213  : 		m_abTradeAgreement[i] = false;

	mov	BYTE PTR [eax+480], bl

; 214  : 		m_abForcePeace[i] = false;

	mov	BYTE PTR [eax+560], bl
	add	ecx, 4
	inc	eax
	sub	edx, 1
	jne	SHORT $LL6@uninit

; 215  : 	}
; 216  : 
; 217  : 	for(int i = 0; i < MAX_PLAYERS; i++)
; 218  : 	{
; 219  : 		m_abHasFoundPlayersTerritory[i] = false;

	push	64					; 00000040H
	lea	eax, DWORD PTR [esi+1768]
	push	ebx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 220  : 	}
; 221  : 
; 222  : 	m_eID = NO_TEAM;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi
	pop	ebx

; 223  : }

	ret	0
?uninit@CvTeam@@QAEXXZ ENDP				; CvTeam::uninit
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+4]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	inc	edi
	inc	ebx
	lea	eax, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [ebx+edi]
	add	edx, DWORD PTR _nBytes$[esp+8]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
	mov	edx, DWORD PTR [esi+12]
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;
; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);
; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, DWORD PTR [esi]
	sub	eax, edi
	pop	edi
	lea	ecx, DWORD PTR [eax+1]
	pop	esi
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::~FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	ebp
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+8]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+16]
	mov	ebp, DWORD PTR [esi+28]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	inc	ebx
	inc	ebp
	inc	edi
	lea	edx, DWORD PTR [ebx+ebp]
	add	edx, edi
	add	edx, DWORD PTR _nBytes$[esp+12]
	lea	eax, DWORD PTR [esi+36]
	push	eax
	push	edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
	mov	edx, DWORD PTR [esi+24]
	sub	eax, ebp
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR [esi+12]
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;
; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);
; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, DWORD PTR [esi]
	sub	eax, edi
	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [eax+1]
	pop	ebp
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??0?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAE@XZ ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::~FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >
_TEXT	ENDS
PUBLIC	??_7CvTeam@@6B@					; CvTeam::`vftable'
PUBLIC	??1CvTeam@@QAE@XZ				; CvTeam::~CvTeam
PUBLIC	??_R4CvTeam@@6B@				; CvTeam::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTeam@@@8				; CvTeam `RTTI Type Descriptor'
PUBLIC	??_R3CvTeam@@8					; CvTeam::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTeam@@8					; CvTeam::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTeam@@8				; CvTeam::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Read@CvTeam@@UAEXAAVFDataStream@@@Z		; CvTeam::Read
;	COMDAT ??_R1A@?0A@EA@CvTeam@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTeam@@8 DD FLAT:??_R0?AVCvTeam@@@8	; CvTeam::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTeam@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTeam@@8
rdata$r	SEGMENT
??_R2CvTeam@@8 DD FLAT:??_R1A@?0A@EA@CvTeam@@8		; CvTeam::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvTeam@@8
rdata$r	SEGMENT
??_R3CvTeam@@8 DD 00H					; CvTeam::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvTeam@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTeam@@@8
_DATA	SEGMENT
??_R0?AVCvTeam@@@8 DD FLAT:??_7type_info@@6B@		; CvTeam `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTeam@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTeam@@6B@
rdata$r	SEGMENT
??_R4CvTeam@@6B@ DD 00H					; CvTeam::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTeam@@@8
	DD	FLAT:??_R3CvTeam@@8
rdata$r	ENDS
;	COMDAT ??_7CvTeam@@6B@
CONST	SEGMENT
??_7CvTeam@@6B@ DD FLAT:??_R4CvTeam@@6B@		; CvTeam::`vftable'
	DD	FLAT:?Read@CvTeam@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvTeam@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvTeam@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTeam@@QAE@XZ$0
__ehfuncinfo$??1CvTeam@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTeam@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ??1CvTeam@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTeam@@QAE@XZ PROC					; CvTeam::~CvTeam, COMDAT
; _this$ = ecx

; 91   : {

	push	-1
	push	__ehhandler$??1CvTeam@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvTeam@@6B@
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+36], ebx

; 92   : 	uninit();

	call	?uninit@CvTeam@@QAEXXZ			; CvTeam::uninit

; 93   : 
; 94   : 	delete m_pTeamTechs;

	mov	edi, DWORD PTR [esi+2980]
	cmp	edi, ebx
	je	SHORT $LN3@CvTeam
	mov	ecx, edi
	call	??1CvTeamTechs@@QAE@XZ			; CvTeamTechs::~CvTeamTechs
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN3@CvTeam:

; 95   : }

	mov	eax, DWORD PTR [esi+2968]
	cmp	eax, ebx
	je	SHORT $LN14@CvTeam
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN14@CvTeam:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+2968], ebx
	mov	DWORD PTR [esi+2972], ebx
	mov	DWORD PTR [esi+2976], ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTeam@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	jmp	??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
__ehhandler$??1CvTeam@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTeam@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTeam@@QAE@XZ ENDP					; CvTeam::~CvTeam
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nLocalBytes$ = 12					; size = 4
_pData$ = 12						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebx
	push	ebp
	push	esi

; 70   : 		unsigned int nLocalBytes = sizeof(TYPE) * (pData->nX + 1);

	mov	esi, DWORD PTR _pData$[esp+8]

; 71   : 		void* pRet = BASE::Alloc( nBytes + nLocalBytes, pData+1 );

	mov	ebx, DWORD PTR [esi+28]
	mov	ebp, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [esi+48]
	push	edx
	inc	ebx
	inc	ebp
	lea	eax, DWORD PTR [eax*4+4]
	inc	edi
	lea	edx, DWORD PTR [ebx+ebp]
	add	edx, edi
	add	edx, eax
	add	edx, DWORD PTR _nBytes$[esp+16]
	mov	DWORD PTR _nLocalBytes$[esp+16], eax
	push	edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > >::Alloc
	mov	edx, DWORD PTR [esi+36]
	sub	eax, ebp
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR [esi+24]
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR [esi+12]
	sub	eax, edi
	lea	ecx, DWORD PTR [eax+1]

; 72   : 		unsigned char* pLocMemStart = static_cast< unsigned char* > ( pRet ) - nLocalBytes;

	sub	eax, DWORD PTR _nLocalBytes$[esp+12]
	mov	DWORD PTR [edx], ecx

; 73   : 
; 74   : 		unsigned int iAlignmentFix = sizeof(TYPE) - reinterpret_cast< unsigned int >(pLocMemStart) % sizeof(TYPE);

	mov	ecx, eax
	and	ecx, 3

; 75   : 		(*static_cast< TYPE** >(pData->pOut)) = (TYPE*)( pLocMemStart + iAlignmentFix );

	mov	edx, eax
	pop	edi
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi]
	pop	esi
	add	edx, 4
	pop	ebp
	mov	DWORD PTR [ecx], edx
	pop	ebx

; 76   : 
; 77   : 		return static_cast< void* >( pLocMemStart );
; 78   : 	}

	ret	8
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	??_ECvTeam@@QAEPAXI@Z				; CvTeam::`vector deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvTeam@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvTeam@@QAEPAXI@Z PROC				; CvTeam::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@4
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvTeam@@QAE@XZ		; CvTeam::~CvTeam
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	2984					; 00000ba8H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@4
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@4:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@4:
	call	??1CvTeam@@QAE@XZ			; CvTeam::~CvTeam
	test	bl, 1
	je	SHORT $LN1@vector@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvTeam@@QAEPAXI@Z ENDP				; CvTeam::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?freeStatics@CvTeam@@SAXXZ			; CvTeam::freeStatics
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
;	COMDAT ?freeStatics@CvTeam@@SAXXZ
_TEXT	SEGMENT
?freeStatics@CvTeam@@SAXXZ PROC				; CvTeam::freeStatics, COMDAT

; 54   : 	delete[] m_aTeams;

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	test	eax, eax
	je	SHORT $LN10@freeStatic
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1CvTeam@@QAE@XZ		; CvTeam::~CvTeam
	push	ecx
	push	2984					; 00000ba8H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN10@freeStatic:

; 55   : 	m_aTeams = NULL;

	mov	DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A, 0	; CvTeam::m_aTeams

; 56   : }

	ret	0
?freeStatics@CvTeam@@SAXXZ ENDP				; CvTeam::freeStatics
_TEXT	ENDS
PUBLIC	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fbatchallocate.h
;	COMDAT ?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXPAUAllocData@@@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXPAUAllocData@@@Z PROC ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc, COMDAT
; _this$ = ecx

; 66   : 		return Alloc( 0, pData );

	mov	eax, DWORD PTR _pData$[esp-4]
	push	eax
	push	0
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc

; 67   : 	}

	ret	4
?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXPAUAllocData@@@Z ENDP ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc
_TEXT	ENDS
PUBLIC	?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z		; CvTeam::reset
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z:PROC ; CvTeamTechs::Init
EXTRN	?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ:PROC ; CvGlobals::GetGameTechs
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z$0
__ehfuncinfo$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_numUnitClassInfos$223437 = -252			; size = 4
_numBuildingClassInfos$223438 = -248			; size = 4
_numSmallAwardInfos$223433 = -244			; size = 4
_numBuildingInfos$223439 = -240				; size = 4
_numBuildInfos$223435 = -236				; size = 4
_numTerrainInfos$223440 = -232				; size = 4
_numRouteInfos$223434 = -228				; size = 4
$T254400 = -224						; size = 4
_numImprovementInfos$223441 = -224			; size = 4
_numVoteSourceInfos$223431 = -220			; size = 4
_aData$223442 = -216					; size = 204
__$EHRec$ = -12						; size = 12
_eID$ = 8						; size = 4
_bConstructorCall$ = 12					; size = 1
?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z PROC		; CvTeam::reset, COMDAT
; _this$ = ecx

; 230  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	mov	esi, ecx

; 231  : 	//--------------------------------
; 232  : 	// Uninit class
; 233  : 	uninit();

	call	?uninit@CvTeam@@QAEXXZ			; CvTeam::uninit

; 234  : 
; 235  : 	m_eID = eID;

	mov	eax, DWORD PTR _eID$[esp+256]

; 236  : 
; 237  : 	if(!bConstructorCall)

	xor	ebx, ebx
	mov	DWORD PTR [esi+4], eax
	cmp	BYTE PTR _bConstructorCall$[esp+256], bl
	jne	$LN68@reset
	push	ebp
	push	edi

; 238  : 	{
; 239  : 		//Collect sizes
; 240  : #ifdef AUI_WARNING_FIXES
; 241  : 		uint numVoteSourceInfos = GC.getNumVoteSourceInfos();
; 242  : 		uint numVictoryInfos = GC.getNumVictoryInfos();
; 243  : 		uint numSmallAwardInfos = GC.getNumSmallAwardInfos();
; 244  : 		uint numRouteInfos = GC.getNumRouteInfos();
; 245  : 		uint numBuildInfos = GC.getNumBuildInfos();
; 246  : 		uint numProjectInfos = GC.getNumProjectInfos();
; 247  : 		uint numUnitClassInfos = GC.getNumUnitClassInfos();
; 248  : 		uint numBuildingClassInfos = GC.getNumBuildingClassInfos();
; 249  : 		uint numBuildingInfos = GC.getNumBuildingInfos();
; 250  : 		uint numTerrainInfos = GC.getNumTerrainInfos();
; 251  : 		uint numImprovementInfos = GC.getNumImprovementInfos();
; 252  : #else
; 253  : 		int numVoteSourceInfos = GC.getNumVoteSourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumVoteSourceInfos

; 254  : 		int numVictoryInfos = GC.getNumVictoryInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numVoteSourceInfos$223431[esp+268], eax
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos

; 255  : 		int numSmallAwardInfos = GC.getNumSmallAwardInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos

; 256  : 		int numRouteInfos = GC.getNumRouteInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numSmallAwardInfos$223433[esp+268], eax
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos

; 257  : 		int numBuildInfos = GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numRouteInfos$223434[esp+268], eax
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos

; 258  : 		int numProjectInfos = GC.getNumProjectInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numBuildInfos$223435[esp+268], eax
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos

; 259  : 		int numUnitClassInfos = GC.getNumUnitClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos

; 260  : 		int numBuildingClassInfos = GC.getNumBuildingClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numUnitClassInfos$223437[esp+268], eax
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos

; 261  : 		int numBuildingInfos = GC.getNumBuildingInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numBuildingClassInfos$223438[esp+268], eax
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos

; 262  : 		int numTerrainInfos = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numBuildingInfos$223439[esp+268], eax
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos

; 263  : 		int numImprovementInfos = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _numTerrainInfos$223440[esp+268], eax
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos

; 264  : #endif
; 265  : 
; 266  : 		//Perform batch allocation
; 267  : 		AllocData aData[] =
; 268  : 		{
; 269  : 			{&m_aiForceTeamVoteEligibilityCount,	numVoteSourceInfos, 0},

	lea	ecx, DWORD PTR [esi+2892]
	mov	DWORD PTR _aData$223442[esp+268], ecx
	mov	ecx, DWORD PTR _numVoteSourceInfos$223431[esp+268]
	mov	DWORD PTR _aData$223442[esp+272], ecx

; 270  : 
; 271  : 			{&m_abCanLaunch,						numVictoryInfos, 0},
; 272  : 			{&m_abVictoryAchieved,					numVictoryInfos, 0},
; 273  : 			{&m_abSmallAwardAchieved,				numSmallAwardInfos, 0},

	mov	edx, DWORD PTR _numSmallAwardInfos$223433[esp+268]
	lea	ecx, DWORD PTR [esi+2896]
	mov	DWORD PTR _aData$223442[esp+280], ecx
	lea	ecx, DWORD PTR [esi+2900]
	mov	DWORD PTR _aData$223442[esp+292], ecx
	lea	ecx, DWORD PTR [esi+2904]
	mov	DWORD PTR _aData$223442[esp+304], ecx

; 274  : 
; 275  : 			{&m_paiRouteChange,						numRouteInfos, 0},

	lea	ecx, DWORD PTR [esi+2908]
	mov	DWORD PTR _aData$223442[esp+316], ecx
	mov	ecx, DWORD PTR _numRouteInfos$223434[esp+268]
	mov	DWORD PTR _aData$223442[esp+320], ecx

; 276  : 			{&m_paiBuildTimeChange,					numBuildInfos, 0},

	lea	ecx, DWORD PTR [esi+2912]
	mov	DWORD PTR _aData$223442[esp+328], ecx

; 277  : 
; 278  : 			{&m_paiProjectCount,					numProjectInfos, 0},

	lea	ecx, DWORD PTR [esi+2916]
	mov	DWORD PTR _aData$223442[esp+340], ecx

; 279  : 			{&m_paiProjectDefaultArtTypes,			numProjectInfos, 0},

	lea	ecx, DWORD PTR [esi+2920]
	mov	DWORD PTR _aData$223442[esp+352], ecx

; 280  : 			{&m_paiProjectMaking,					numProjectInfos, 0},

	lea	ecx, DWORD PTR [esi+2924]
	mov	DWORD PTR _aData$223442[esp+364], ecx

; 281  : 
; 282  : 			{&m_paiUnitClassCount,					numUnitClassInfos, 0},

	lea	ecx, DWORD PTR [esi+2928]
	mov	DWORD PTR _aData$223442[esp+376], ecx
	mov	ecx, DWORD PTR _numUnitClassInfos$223437[esp+268]
	mov	DWORD PTR _aData$223442[esp+308], edx
	mov	edx, DWORD PTR _numBuildInfos$223435[esp+268]
	mov	DWORD PTR _aData$223442[esp+380], ecx
	mov	DWORD PTR _numImprovementInfos$223441[esp+268], eax
	mov	DWORD PTR _aData$223442[esp+276], ebx
	mov	DWORD PTR _aData$223442[esp+284], edi
	mov	DWORD PTR _aData$223442[esp+288], ebx
	mov	DWORD PTR _aData$223442[esp+296], edi
	mov	DWORD PTR _aData$223442[esp+300], ebx
	mov	DWORD PTR _aData$223442[esp+312], ebx
	mov	DWORD PTR _aData$223442[esp+324], ebx
	mov	DWORD PTR _aData$223442[esp+332], edx
	mov	DWORD PTR _aData$223442[esp+336], ebx
	mov	DWORD PTR _aData$223442[esp+344], ebp
	mov	DWORD PTR _aData$223442[esp+348], ebx
	mov	DWORD PTR _aData$223442[esp+356], ebp
	mov	DWORD PTR _aData$223442[esp+360], ebx
	mov	DWORD PTR _aData$223442[esp+368], ebp
	mov	DWORD PTR _aData$223442[esp+372], ebx
	mov	DWORD PTR _aData$223442[esp+384], ebx

; 283  : 			{&m_paiBuildingClassCount,				numBuildingClassInfos, 0},

	lea	ecx, DWORD PTR [esi+2932]
	mov	edx, DWORD PTR _numBuildingClassInfos$223438[esp+268]
	mov	DWORD PTR _aData$223442[esp+388], ecx

; 284  : 			{&m_paiObsoleteBuildingCount,			numBuildingInfos, 0},

	lea	ecx, DWORD PTR [esi+2936]
	mov	DWORD PTR _aData$223442[esp+400], ecx
	mov	ecx, DWORD PTR _numBuildingInfos$223439[esp+268]
	mov	DWORD PTR _aData$223442[esp+404], ecx

; 285  : 			{&m_paiTerrainTradeCount,				numTerrainInfos, 0},

	lea	ecx, DWORD PTR [esi+2940]
	mov	DWORD PTR _aData$223442[esp+412], ecx

; 286  : 			{&m_aiVictoryCountdown,					numVictoryInfos, 0},

	lea	ecx, DWORD PTR [esi+2944]
	mov	DWORD PTR _aData$223442[esp+424], ecx

; 287  : 
; 288  : 			{&m_ppaaiImprovementYieldChange,		numImprovementInfos, NUM_YIELD_TYPES},

	lea	ecx, DWORD PTR [esi+2948]
	mov	DWORD PTR _aData$223442[esp+436], ecx
	mov	DWORD PTR _aData$223442[esp+392], edx
	mov	edx, DWORD PTR _numTerrainInfos$223440[esp+268]

; 289  : 			{&m_ppaaiImprovementNoFreshWaterYieldChange,numImprovementInfos, NUM_YIELD_TYPES},

	lea	ecx, DWORD PTR [esi+2952]
	mov	DWORD PTR _aData$223442[esp+440], eax
	mov	DWORD PTR _aData$223442[esp+448], ecx
	mov	DWORD PTR _aData$223442[esp+452], eax

; 290  : 			{&m_ppaaiImprovementFreshWaterYieldChange,numImprovementInfos, NUM_YIELD_TYPES}

	mov	DWORD PTR _aData$223442[esp+464], eax

; 291  : 		};
; 292  : 		m_BatchData.Alloc(aData);

	lea	eax, DWORD PTR _aData$223442[esp+268]
	lea	ecx, DWORD PTR [esi+2956]
	mov	DWORD PTR _aData$223442[esp+416], edx
	mov	edx, 6
	push	eax
	mov	DWORD PTR _aData$223442[esp+464], ecx
	push	ebx
	lea	ecx, DWORD PTR [esi+2888]
	mov	DWORD PTR _aData$223442[esp+404], ebx
	mov	DWORD PTR _aData$223442[esp+416], ebx
	mov	DWORD PTR _aData$223442[esp+428], ebx
	mov	DWORD PTR _aData$223442[esp+436], edi
	mov	DWORD PTR _aData$223442[esp+440], ebx
	mov	DWORD PTR _aData$223442[esp+452], edx
	mov	DWORD PTR _aData$223442[esp+464], edx
	mov	DWORD PTR _aData$223442[esp+476], edx
	call	?Alloc@?$FAllocArrayType@HU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@_NU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArrayType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocArray2DType@HU?$FAllocBase@$0A@$0A@$0A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@QAEPAXIPAUAllocData@@@Z ; FAllocArrayType<int,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<bool,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArrayType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocArray2DType<int,FAllocBase<0,0,0> > > > > > > > > > > > > > > > > >::Alloc

; 293  : 
; 294  : 		//Init the data - it is valid now
; 295  : #ifdef AUI_WARNING_FIXES
; 296  : 		for (uint i = 0; i < numVoteSourceInfos; i++)
; 297  : #else
; 298  : 		for(int i = 0; i < numVoteSourceInfos; i++)

	mov	ecx, DWORD PTR _numVoteSourceInfos$223431[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN37@reset
	npad	9
$LL39@reset:

; 299  : #endif
; 300  : 		{
; 301  : 			m_aiForceTeamVoteEligibilityCount[i] = 0;

	mov	edx, DWORD PTR [esi+2892]
	mov	DWORD PTR [edx+eax*4], ebx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL39@reset
$LN37@reset:

; 302  : 		}
; 303  : #ifdef AUI_WARNING_FIXES
; 304  : 		for (uint i = 0; i < numVictoryInfos; i++)
; 305  : #else
; 306  : 		for(int i = 0; i < numVictoryInfos; i++)

	xor	eax, eax
	or	edx, -1
	cmp	edi, ebx
	jle	SHORT $LN34@reset
	npad	9
$LL36@reset:

; 307  : #endif
; 308  : 		{
; 309  : 			m_abCanLaunch[i] = false;

	mov	ecx, DWORD PTR [esi+2896]
	mov	BYTE PTR [eax+ecx], bl

; 310  : 			m_abVictoryAchieved[i] = false;

	mov	ecx, DWORD PTR [esi+2900]
	mov	BYTE PTR [eax+ecx], bl

; 311  : 			m_aiVictoryCountdown[i] = -1;

	mov	ecx, DWORD PTR [esi+2944]
	mov	DWORD PTR [ecx+eax*4], edx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL36@reset
$LN34@reset:

; 312  : 		}
; 313  : #ifdef AUI_WARNING_FIXES
; 314  : 		for (uint i = 0; i < numSmallAwardInfos; i++)
; 315  : #else
; 316  : 		for(int i = 0; i < numSmallAwardInfos; i++)

	mov	ecx, DWORD PTR _numSmallAwardInfos$223433[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN31@reset
	npad	6
$LL33@reset:

; 317  : #endif
; 318  : 		{
; 319  : 			m_abSmallAwardAchieved[i] = false;

	mov	edi, DWORD PTR [esi+2904]
	mov	BYTE PTR [eax+edi], bl
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL33@reset
$LN31@reset:

; 320  : 		}
; 321  : #ifdef AUI_WARNING_FIXES
; 322  : 		for (uint i = 0; i < numRouteInfos; i++)
; 323  : #else
; 324  : 		for(int i = 0; i < numRouteInfos; i++)

	mov	ecx, DWORD PTR _numRouteInfos$223434[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN28@reset
	npad	8
$LL30@reset:

; 325  : #endif
; 326  : 		{
; 327  : 			m_paiRouteChange[i] = 0;

	mov	edi, DWORD PTR [esi+2908]
	mov	DWORD PTR [edi+eax*4], ebx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL30@reset
$LN28@reset:

; 328  : 		}
; 329  : #ifdef AUI_WARNING_FIXES
; 330  : 		for (uint i = 0; i < numBuildInfos; i++)
; 331  : #else
; 332  : 		for (int i = 0; i < numBuildInfos; i++)

	mov	ecx, DWORD PTR _numBuildInfos$223435[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN25@reset
	npad	8
$LL27@reset:

; 333  : #endif
; 334  : 		{
; 335  : 			m_paiBuildTimeChange[i] = 0;

	mov	edi, DWORD PTR [esi+2912]
	mov	DWORD PTR [edi+eax*4], ebx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL27@reset
$LN25@reset:

; 336  : 		}
; 337  : #ifdef AUI_WARNING_FIXES
; 338  : 		for (uint i = 0; i < numProjectInfos; i++)
; 339  : #else
; 340  : 		for(int i = 0; i < numProjectInfos; i++)

	xor	eax, eax
	cmp	ebp, ebx
	jle	SHORT $LN22@reset
	npad	12
$LL24@reset:

; 341  : #endif
; 342  : 		{
; 343  : 			m_paiProjectCount[i] = 0;

	mov	ecx, DWORD PTR [esi+2916]
	mov	DWORD PTR [ecx+eax*4], ebx

; 344  : 			m_paiProjectDefaultArtTypes[i] = 0;

	mov	ecx, DWORD PTR [esi+2920]
	mov	DWORD PTR [ecx+eax*4], ebx

; 345  : 			m_paiProjectMaking[i] = 0;

	mov	ecx, DWORD PTR [esi+2924]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, ebp
	jl	SHORT $LL24@reset
$LN22@reset:

; 346  : 		}
; 347  : #ifdef AUI_WARNING_FIXES
; 348  : 		for (uint i = 0; i < numUnitClassInfos; i++)
; 349  : #else
; 350  : 		for(int i = 0; i < numUnitClassInfos; i++)

	mov	ecx, DWORD PTR _numUnitClassInfos$223437[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN19@reset
	npad	6
$LL21@reset:

; 351  : #endif
; 352  : 		{
; 353  : 			m_paiUnitClassCount[i] = 0;

	mov	edi, DWORD PTR [esi+2928]
	mov	DWORD PTR [edi+eax*4], ebx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL21@reset
$LN19@reset:

; 354  : 		}
; 355  : #ifdef AUI_WARNING_FIXES
; 356  : 		for (uint i = 0; i < numBuildingClassInfos; i++)
; 357  : #else
; 358  : 		for(int i = 0; i < numBuildingClassInfos; i++)

	mov	ecx, DWORD PTR _numBuildingClassInfos$223438[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN16@reset
	npad	8
$LL18@reset:

; 359  : #endif
; 360  : 		{
; 361  : 			m_paiBuildingClassCount[i] = 0;

	mov	edi, DWORD PTR [esi+2932]
	mov	DWORD PTR [edi+eax*4], ebx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL18@reset
$LN16@reset:

; 362  : 		}
; 363  : #ifdef AUI_WARNING_FIXES
; 364  : 		for (uint i = 0; i < numBuildingInfos; i++)
; 365  : #else
; 366  : 		for(int i = 0; i < numBuildingInfos; i++)

	mov	ecx, DWORD PTR _numBuildingInfos$223439[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN13@reset
	npad	8
$LL15@reset:

; 367  : #endif
; 368  : 		{
; 369  : 			m_paiObsoleteBuildingCount[i] = 0;

	mov	edi, DWORD PTR [esi+2936]
	mov	DWORD PTR [edi+eax*4], ebx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL15@reset
$LN13@reset:

; 370  : 		}
; 371  : #ifdef AUI_WARNING_FIXES
; 372  : 		for (uint i = 0; i < numTerrainInfos; i++)
; 373  : #else
; 374  : 		for(int i = 0; i < numTerrainInfos; i++)

	mov	ecx, DWORD PTR _numTerrainInfos$223440[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	SHORT $LN10@reset
	npad	8
$LL12@reset:

; 375  : #endif
; 376  : 		{
; 377  : 			m_paiTerrainTradeCount[i] = 0;

	mov	edi, DWORD PTR [esi+2940]
	mov	DWORD PTR [edi+eax*4], ebx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL12@reset
$LN10@reset:

; 378  : 		}
; 379  : 
; 380  : 		for(int i = 0; i < MAX_TEAMS; i++)

	lea	eax, DWORD PTR [esi+468]
	mov	ecx, 64					; 00000040H
	npad	7
$LL9@reset:

; 381  : 		{
; 382  : 			m_aiTurnTeamMet[i] = -1;

	mov	DWORD PTR [eax+2100], edx

; 383  : 			m_aiNumTurnsAtWar[i] = 0;

	mov	DWORD PTR [eax], ebx

; 384  : 			m_aiNumTurnsLockedIntoWar[i] = 0;

	mov	DWORD PTR [eax+320], ebx
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL9@reset

; 385  : 		}
; 386  : 
; 387  : #ifdef AUI_WARNING_FIXES
; 388  : 		for (uint i = 0; i < numImprovementInfos; i++)
; 389  : #else
; 390  : 		for(int i = 0; i < numImprovementInfos; i++)

	mov	ecx, DWORD PTR _numImprovementInfos$223441[esp+268]
	xor	eax, eax
	cmp	ecx, ebx
	jle	$LN4@reset
$LL6@reset:

; 391  : #endif
; 392  : 		{
; 393  : 			for(int j = 0; j < NUM_YIELD_TYPES; j++)
; 394  : 			{
; 395  : 				m_ppaaiImprovementYieldChange[i][j] = 0;

	mov	edx, DWORD PTR [esi+2948]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx], ebx

; 396  : 				m_ppaaiImprovementNoFreshWaterYieldChange[i][j] = 0;

	mov	edx, DWORD PTR [esi+2952]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx], ebx

; 397  : 				m_ppaaiImprovementFreshWaterYieldChange[i][j] = 0;

	mov	edx, DWORD PTR [esi+2956]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [esi+2948]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+4], ebx
	mov	edx, DWORD PTR [esi+2952]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+4], ebx
	mov	edx, DWORD PTR [esi+2956]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+4], ebx
	mov	edx, DWORD PTR [esi+2948]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+8], ebx
	mov	edx, DWORD PTR [esi+2952]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+8], ebx
	mov	edx, DWORD PTR [esi+2956]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+8], ebx
	mov	edx, DWORD PTR [esi+2948]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+12], ebx
	mov	edx, DWORD PTR [esi+2952]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+12], ebx
	mov	edx, DWORD PTR [esi+2956]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+12], ebx
	mov	edx, DWORD PTR [esi+2948]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+16], ebx
	mov	edx, DWORD PTR [esi+2952]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+16], ebx
	mov	edx, DWORD PTR [esi+2956]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+16], ebx
	mov	edx, DWORD PTR [esi+2948]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+20], ebx
	mov	edx, DWORD PTR [esi+2952]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+20], ebx
	mov	edx, DWORD PTR [esi+2956]
	mov	edx, DWORD PTR [edx+eax*4]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR [edx+20], ebx
	jl	$LL6@reset
$LN4@reset:

; 398  : 			}
; 399  : 		}
; 400  : 
; 401  : 		m_pTeamTechs->Init(GC.GetGameTechs(), this);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameTechs@CvGlobals@@QBEPAVCvTechXMLEntries@@XZ ; CvGlobals::GetGameTechs
	mov	ecx, DWORD PTR [esi+2980]
	push	eax
	call	?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z ; CvTeamTechs::Init

; 402  : 		m_pavProjectArtTypes = FNEW(std::vector<int> [GC.getNumProjectInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	edi, eax
	xor	ecx, ecx
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T254400[esp+268], eax
	mov	DWORD PTR __$EHRec$[esp+276], ebx
	cmp	eax, ebx
	je	SHORT $LN43@reset
	push	OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	push	OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	push	16					; 00000010H
	push	ebx
	mov	DWORD PTR [eax], edi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN43@reset:
	mov	DWORD PTR [esi+2960], ebx

; 403  : 		m_aeRevealedResources.clear();

	mov	edx, DWORD PTR [esi+2968]
	mov	ecx, DWORD PTR [esi+2972]
	cmp	edx, ecx
	je	SHORT $LN133@reset
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN93@reset
	npad	3
$LL95@reset:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL95@reset
$LN93@reset:
	mov	DWORD PTR [esi+2972], edx
$LN133@reset:
	pop	edi
	pop	ebp
$LN68@reset:

; 404  : 	}
; 405  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+260]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 252				; 000000fcH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z$0:
	mov	eax, DWORD PTR $T254400[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z ENDP		; CvTeam::reset
EXTRN	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z:PROC ; ImprovementArrayHelpers::ReadYieldArray
EXTRN	?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z:PROC	; CvTeamTechs::Read
EXTRN	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; BuildingArrayHelpers::Read
EXTRN	?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; BuildingClassArrayHelpers::Read
EXTRN	?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; UnitClassArrayHelpers::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvTeam@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_j$227961 = -32						; size = 4
_i$227955 = -28						; size = 4
_iNumProjects$ = -24					; size = 4
tv858 = -20						; size = 4
_iType$227959 = -16					; size = 4
_uiVersion$ = -12					; size = 4
_temp$227971 = -8					; size = 4
_kForcePeaceWrapper$ = -8				; size = 8
_kTradeAgreementWrapper$ = -8				; size = 8
_kResearchAgreementWrapper$ = -8			; size = 8
_kDefensivePactWrapper$ = -8				; size = 8
_kOpenBordersWrapper$ = -8				; size = 8
_kEmbassyWrapper$ = -8					; size = 8
_kPermanentWarWrapper$ = -8				; size = 8
_kAtWarWrapper$ = -8					; size = 8
_kHasFoundPlayerWrapper$ = -8				; size = 8
_kHasMetWrapper$ = -8					; size = 8
tv532 = 8						; size = 4
_temp$227965 = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvTeam@@UAEXAAVFDataStream@@@Z PROC		; CvTeam::Read, COMDAT
; _this$ = ecx

; 7527 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 7528 : 	// Init data before load
; 7529 : 	reset();

	push	0
	push	0
	mov	edi, ecx
	call	?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::reset

; 7530 : 
; 7531 : 	// Version number to maintain backwards compatibility
; 7532 : 	uint uiVersion;
; 7533 : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+44]
	lea	eax, DWORD PTR _uiVersion$[esp+48]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 7534 : 
; 7535 : 	kStream >> m_iNumMembers;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7536 : 	kStream >> m_iAliveCount;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7537 : 	kStream >> m_iEverAliveCount;

	lea	eax, DWORD PTR [edi+16]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7538 : 	kStream >> m_iNumCities;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7539 : 	kStream >> m_iTotalPopulation;

	lea	edx, DWORD PTR [edi+24]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7540 : 	kStream >> m_iTotalLand;

	lea	eax, DWORD PTR [edi+28]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7541 : 	kStream >> m_iNukeInterception;

	lea	ecx, DWORD PTR [edi+32]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7542 : 	kStream >> m_iExtraWaterSeeFromCount;

	lea	edx, DWORD PTR [edi+36]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7543 : 	kStream >> m_iMapTradingCount;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7544 : 	kStream >> m_iTechTradingCount;

	lea	ecx, DWORD PTR [edi+44]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7545 : 	kStream >> m_iGoldTradingCount;

	lea	edx, DWORD PTR [edi+48]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7546 : 	kStream >> m_iAllowEmbassyTradingAllowedCount;

	lea	eax, DWORD PTR [edi+52]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7547 : 	kStream >> m_iOpenBordersTradingAllowedCount;

	lea	ecx, DWORD PTR [edi+56]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7548 : 	kStream >> m_iDefensivePactTradingAllowedCount;

	lea	edx, DWORD PTR [edi+60]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7549 : 	kStream >> m_iResearchAgreementTradingAllowedCount;

	lea	eax, DWORD PTR [edi+64]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7550 : 	kStream >> m_iTradeAgreementTradingAllowedCount;

	lea	ecx, DWORD PTR [edi+68]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7551 : 	kStream >> m_iPermanentAllianceTradingCount;

	lea	edx, DWORD PTR [edi+72]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7552 : 	kStream >> m_iBridgeBuildingCount;

	lea	eax, DWORD PTR [edi+76]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7553 : 	kStream >> m_iWaterWorkCount;

	lea	ecx, DWORD PTR [edi+80]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7554 : 	kStream >> m_iRiverTradeCount;

	lea	edx, DWORD PTR [edi+84]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7555 : 	kStream >> m_iBorderObstacleCount;

	lea	eax, DWORD PTR [edi+88]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7556 : 	kStream >> m_iVictoryPoints;

	lea	ecx, DWORD PTR [edi+92]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7557 : 	kStream >> m_iEmbarkedExtraMoves;

	lea	edx, DWORD PTR [edi+96]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7558 : 	//EAP: Extra embarked visiblity on tech
; 7559 : 	kStream >> m_iEmbarkedExtraSight;

	lea	eax, DWORD PTR [edi+100]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7560 : 	kStream >> m_iCanEmbarkCount;

	lea	ecx, DWORD PTR [edi+104]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7561 : 	kStream >> m_iDefensiveEmbarkCount;

	lea	edx, DWORD PTR [edi+108]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7562 : 	kStream >> m_iEmbarkedAllWaterPassageCount;

	lea	eax, DWORD PTR [edi+112]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7563 : 	kStream >> m_iNumNaturalWondersDiscovered;

	lea	ecx, DWORD PTR [edi+116]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7564 : 	kStream >> m_iBestPossibleRoute;

	lea	edx, DWORD PTR [edi+120]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7565 : 	kStream >> m_iNumMinorCivsAttacked;

	lea	eax, DWORD PTR [edi+124]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7566 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 7567 : 	kStream >> m_iBestRouteFlatCostMultiplier;
; 7568 : 	kStream >> m_iBestRouteNormalCostMultiplier;
; 7569 : 	kStream >> m_iUseFlatCostIfBelowThis;
; 7570 : #endif
; 7571 : 
; 7572 : 	kStream >> m_bMapCentering;

	lea	ecx, DWORD PTR [edi+128]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7573 : 	kStream >> m_bHasBrokenPeaceTreaty;

	lea	edx, DWORD PTR [edi+129]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7574 : 	kStream >> m_bHomeOfUnitedNations;

	lea	eax, DWORD PTR [edi+130]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7575 : 	kStream >> m_bHasTechForWorldCongress;

	lea	ecx, DWORD PTR [edi+131]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7576 : 
; 7577 : 	kStream >> m_bBrokenMilitaryPromise;

	lea	edx, DWORD PTR [edi+132]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7578 : 	kStream >> m_bBrokenExpansionPromise;

	lea	eax, DWORD PTR [edi+133]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7579 : 	kStream >> m_bBrokenBorderPromise;

	lea	ecx, DWORD PTR [edi+134]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7580 : 	kStream >> m_bBrokenCityStatePromise;

	lea	edx, DWORD PTR [edi+135]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 7581 : 
; 7582 : 	kStream >> m_eID;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z ; operator>>

; 7583 : 
; 7584 : 	kStream >> m_eCurrentEra;

	lea	eax, DWORD PTR [edi+136]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>

; 7585 : 	kStream >> m_eLiberatedByTeam;

	lea	ecx, DWORD PTR [edi+140]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z ; operator>>

; 7586 : 	kStream >> m_eKilledByTeam;

	lea	edx, DWORD PTR [edi+144]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4TeamTypes@@@Z ; operator>>
	add	esp, 32					; 00000020H

; 7587 : 
; 7588 : 	ArrayWrapper<int> kTechShareCountWrapper(MAX_TEAMS, &m_aiTechShareCount[0]);

	lea	ebx, DWORD PTR [edi+148]
	mov	ebp, 64					; 00000040H
	npad	5

; 7589 : 	kStream >> kTechShareCountWrapper;

$LL99@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL99@Read

; 7590 : 
; 7591 : 	ArrayWrapper<int> kNumTurnsAtWarWrapper(MAX_TEAMS, &m_aiNumTurnsAtWar[0]);

	lea	ebx, DWORD PTR [edi+468]
	mov	ebp, 64					; 00000040H
	npad	5

; 7592 : 	kStream >> kNumTurnsAtWarWrapper;

$LL114@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL114@Read

; 7593 : 
; 7594 : 	ArrayWrapper<int> kNumTurnsLockedIntoWarWrapper(MAX_TEAMS, &m_aiNumTurnsLockedIntoWar[0]);

	lea	ebx, DWORD PTR [edi+788]
	mov	ebp, 64					; 00000040H
	npad	5

; 7595 : 	kStream >> kNumTurnsLockedIntoWarWrapper;

$LL129@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL129@Read

; 7596 : 
; 7597 : 	ArrayWrapper<int> kExtraMovesWrapper(NUM_DOMAIN_TYPES, &m_aiExtraMoves[0]);

	lea	ebx, DWORD PTR [edi+1108]
	mov	ebp, 5
	npad	5

; 7598 : 	kStream >> kExtraMovesWrapper;

$LL144@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL144@Read

; 7599 : 
; 7600 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiForceTeamVoteEligibilityCount, GC.getNumVoteSourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVoteSourceInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumVoteSourceInfos
	push	eax
	mov	eax, DWORD PTR [edi+2892]
	push	eax
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7601 : 
; 7602 : 	ArrayWrapper<int> kTurnMadePeaceWrapper(MAX_TEAMS, &m_paiTurnMadePeaceTreatyWithTeam[0]);

	lea	ebx, DWORD PTR [edi+1128]
	mov	ebp, 64					; 00000040H

; 7603 : 	kStream >> kTurnMadePeaceWrapper;

$LL159@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL159@Read

; 7604 : 
; 7605 : 	ArrayWrapper<int> kIgnoreWarningWrapper(MAX_TEAMS, &m_aiIgnoreWarningCount[0]);

	mov	ebp, 64					; 00000040H
	lea	ebx, DWORD PTR [edi+1448]
	mov	DWORD PTR tv532[esp+44], ebp

; 7606 : 	kStream >> kIgnoreWarningWrapper;

$LL174@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	DWORD PTR tv532[esp+44], 1
	jne	SHORT $LL174@Read

; 7607 : 
; 7608 : 	ArrayWrapper<bool> kHasMetWrapper(MAX_TEAMS, &m_abHasMet[0]);
; 7609 : 	kStream >> kHasMetWrapper;

	lea	edx, DWORD PTR _kHasMetWrapper$[esp+48]
	push	edx
	lea	ecx, DWORD PTR [edi+1848]
	push	esi
	mov	DWORD PTR _kHasMetWrapper$[esp+56], ecx
	mov	DWORD PTR _kHasMetWrapper$[esp+60], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7610 : 
; 7611 : 	ArrayWrapper<bool> kHasFoundPlayerWrapper(MAX_PLAYERS, &m_abHasFoundPlayersTerritory[0]);
; 7612 : 	kStream >> kHasFoundPlayerWrapper;

	lea	ecx, DWORD PTR _kHasFoundPlayerWrapper$[esp+56]
	push	ecx
	lea	eax, DWORD PTR [edi+1768]
	push	esi
	mov	DWORD PTR _kHasFoundPlayerWrapper$[esp+64], eax
	mov	DWORD PTR _kHasFoundPlayerWrapper$[esp+68], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7613 : 
; 7614 : 	ArrayWrapper<bool> kAtWarWrapper(MAX_TEAMS, &m_abAtWar[0]);
; 7615 : 	kStream >> kAtWarWrapper;

	lea	eax, DWORD PTR _kAtWarWrapper$[esp+64]
	push	eax
	lea	edx, DWORD PTR [edi+1928]
	push	esi
	mov	DWORD PTR _kAtWarWrapper$[esp+72], edx
	mov	DWORD PTR _kAtWarWrapper$[esp+76], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7616 : 
; 7617 : 	ArrayWrapper<bool> kPermanentWarWrapper(MAX_TEAMS, &m_abPermanentWarPeace[0]);
; 7618 : 	kStream >> kPermanentWarWrapper;

	lea	edx, DWORD PTR _kPermanentWarWrapper$[esp+72]
	push	edx
	lea	ecx, DWORD PTR [edi+2008]
	push	esi
	mov	DWORD PTR _kPermanentWarWrapper$[esp+80], ecx
	mov	DWORD PTR _kPermanentWarWrapper$[esp+84], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7619 : 
; 7620 : 	ArrayWrapper<bool> kEmbassyWrapper(MAX_TEAMS, &m_abEmbassy[0]);
; 7621 : 	kStream >> kEmbassyWrapper;

	lea	ecx, DWORD PTR _kEmbassyWrapper$[esp+80]
	push	ecx
	lea	eax, DWORD PTR [edi+2088]
	push	esi
	mov	DWORD PTR _kEmbassyWrapper$[esp+88], eax
	mov	DWORD PTR _kEmbassyWrapper$[esp+92], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7622 : 
; 7623 : 	ArrayWrapper<bool> kOpenBordersWrapper(MAX_TEAMS, &m_abOpenBorders[0]);
; 7624 : 	kStream >> kOpenBordersWrapper;

	lea	eax, DWORD PTR _kOpenBordersWrapper$[esp+88]
	push	eax
	lea	edx, DWORD PTR [edi+2168]
	push	esi
	mov	DWORD PTR _kOpenBordersWrapper$[esp+96], edx
	mov	DWORD PTR _kOpenBordersWrapper$[esp+100], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7625 : 
; 7626 : 	ArrayWrapper<bool> kDefensivePactWrapper(MAX_TEAMS, &m_abDefensivePact[0]);
; 7627 : 	kStream >> kDefensivePactWrapper;

	lea	edx, DWORD PTR _kDefensivePactWrapper$[esp+96]
	push	edx
	lea	ecx, DWORD PTR [edi+2248]
	push	esi
	mov	DWORD PTR _kDefensivePactWrapper$[esp+104], ecx
	mov	DWORD PTR _kDefensivePactWrapper$[esp+108], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7628 : 
; 7629 : 	ArrayWrapper<bool> kResearchAgreementWrapper(MAX_TEAMS, &m_abResearchAgreement[0]);
; 7630 : 	kStream >> kResearchAgreementWrapper;

	lea	ecx, DWORD PTR _kResearchAgreementWrapper$[esp+104]
	push	ecx
	lea	eax, DWORD PTR [edi+2328]
	push	esi
	mov	DWORD PTR _kResearchAgreementWrapper$[esp+112], eax
	mov	DWORD PTR _kResearchAgreementWrapper$[esp+116], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 64					; 00000040H

; 7631 : 
; 7632 : 	ArrayWrapper<bool> kTradeAgreementWrapper(MAX_TEAMS, &m_abTradeAgreement[0]);
; 7633 : 	kStream >> kTradeAgreementWrapper;

	lea	eax, DWORD PTR _kTradeAgreementWrapper$[esp+48]
	push	eax
	lea	edx, DWORD PTR [edi+2408]
	push	esi
	mov	DWORD PTR _kTradeAgreementWrapper$[esp+56], edx
	mov	DWORD PTR _kTradeAgreementWrapper$[esp+60], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 7634 : 
; 7635 : 	ArrayWrapper<bool> kForcePeaceWrapper(MAX_TEAMS, &m_abForcePeace[0]);
; 7636 : 	kStream >> kForcePeaceWrapper;

	lea	edx, DWORD PTR _kForcePeaceWrapper$[esp+56]
	push	edx
	lea	ecx, DWORD PTR [edi+2488]
	push	esi
	mov	DWORD PTR _kForcePeaceWrapper$[esp+64], ecx
	mov	DWORD PTR _kForcePeaceWrapper$[esp+68], ebp
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 16					; 00000010H

; 7637 : 
; 7638 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_abCanLaunch, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	eax, DWORD PTR [edi+2896]
	push	eax
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 7639 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_abVictoryAchieved, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	mov	ecx, DWORD PTR [edi+2900]
	push	eax
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 7640 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_abSmallAwardAchieved, GC.getNumSmallAwardInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSmallAwardInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSmallAwardInfos
	mov	edx, DWORD PTR [edi+2904]
	push	eax
	push	edx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 7641 : 
; 7642 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiRouteChange, GC.getNumRouteInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	push	eax
	mov	eax, DWORD PTR [edi+2908]
	push	eax
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7643 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiBuildTimeChange, GC.getNumBuildInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	ecx, DWORD PTR [edi+2912]
	push	eax
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7644 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiProjectCount, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	edx, DWORD PTR [edi+2916]
	push	eax
	push	edx
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7645 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiProjectDefaultArtTypes, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	push	eax
	mov	eax, DWORD PTR [edi+2920]
	push	eax
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7646 : 
; 7647 : 	//project art types
; 7648 : 
; 7649 : #ifdef AUI_WARNING_FIXES
; 7650 : 	uint iNumProjects;
; 7651 : 	kStream >> iNumProjects;
; 7652 : 	for (uint i = 0; i<iNumProjects; i++)
; 7653 : #else
; 7654 : 	int iNumProjects;
; 7655 : 	kStream >> iNumProjects;

	lea	ecx, DWORD PTR _iNumProjects$[esp+48]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7656 : 	for(int i=0; i<iNumProjects; i++)

	xor	ebp, ebp
	cmp	DWORD PTR _iNumProjects$[esp+48], ebp
	mov	DWORD PTR _i$227955[esp+48], ebp
	jle	$LN10@Read
	jmp	SHORT $LN12@Read
$LL333@Read:
	xor	ebp, ebp
$LN12@Read:

; 7657 : #endif
; 7658 : 	{
; 7659 : 		int iType = CvInfosSerializationHelper::ReadHashed(kStream);

	push	ebp
	push	esi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$227959[esp+48], eax

; 7660 : 		if (iType != -1)

	cmp	eax, -1
	je	$LN9@Read

; 7661 : 		{
; 7662 : 			for(int j=0; j<m_paiProjectCount[iType]; j++)

	mov	edx, DWORD PTR [edi+2916]
	cmp	DWORD PTR [edx+eax*4], ebp
	mov	DWORD PTR _j$227961[esp+48], ebp
	jle	$LN11@Read
	mov	ebx, eax
	shl	ebx, 4
	mov	DWORD PTR tv858[esp+48], ebx
	jmp	SHORT $LN8@Read
	npad	7
$LL331@Read:
	mov	ebx, DWORD PTR tv858[esp+48]
$LN8@Read:

; 7663 : 			{
; 7664 : 				int temp;
; 7665 : 				kStream >> temp;

	lea	eax, DWORD PTR _temp$227965[esp+44]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 7666 : 				m_pavProjectArtTypes[iType].push_back(temp);

	mov	ecx, DWORD PTR [edi+2960]
	mov	edx, DWORD PTR [ecx+ebx+4]
	add	ecx, ebx
	test	edx, edx
	jne	SHORT $LN235@Read
	xor	eax, eax
	jmp	SHORT $LN236@Read
$LN235@Read:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2
$LN236@Read:
	mov	ebp, DWORD PTR [ecx+8]
	mov	ebx, ebp
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, eax
	jae	SHORT $LN228@Read
	mov	edx, DWORD PTR _temp$227965[esp+44]
	mov	DWORD PTR [ebp], edx
	add	ebp, 4
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN7@Read
$LN228@Read:
	lea	eax, DWORD PTR _temp$227965[esp+44]
	push	eax
	push	1
	push	ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN7@Read:
	mov	eax, DWORD PTR _j$227961[esp+48]
	mov	ecx, DWORD PTR [edi+2916]
	mov	edx, DWORD PTR _iType$227959[esp+48]
	inc	eax
	cmp	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _j$227961[esp+48], eax
	jl	SHORT $LL331@Read

; 7667 : 			}
; 7668 : 		}
; 7669 : 		else

	jmp	SHORT $LN11@Read
$LN9@Read:

; 7670 : 		{
; 7671 : 			for(int j=0; j<m_paiProjectCount[iType]; j++)

	mov	eax, DWORD PTR [edi+2916]
	xor	ebx, ebx
	cmp	DWORD PTR [eax-4], ebp
	jle	SHORT $LN2@Read
	npad	3
$LL4@Read:

; 7672 : 			{
; 7673 : 				int temp;
; 7674 : 				kStream >> temp;

	lea	ecx, DWORD PTR _temp$227971[esp+48]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	edx, DWORD PTR [edi+2916]
	inc	ebx
	cmp	ebx, DWORD PTR [edx-4]
	jl	SHORT $LL4@Read
$LN2@Read:

; 7675 : 			}
; 7676 : 			m_paiProjectCount[iType] = 0;

	mov	eax, DWORD PTR [edi+2916]
	mov	DWORD PTR [eax-4], ebp
$LN11@Read:
	mov	eax, DWORD PTR _i$227955[esp+48]
	inc	eax
	cmp	eax, DWORD PTR _iNumProjects$[esp+48]
	mov	DWORD PTR _i$227955[esp+48], eax
	jl	$LL333@Read
$LN10@Read:

; 7677 : 		}
; 7678 : 	}
; 7679 : 
; 7680 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiProjectMaking, GC.getNumProjectInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	mov	ecx, DWORD PTR [edi+2924]
	push	eax
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>

; 7681 : 
; 7682 : 	UnitClassArrayHelpers::Read(kStream, m_paiUnitClassCount);

	mov	edx, DWORD PTR [edi+2928]
	push	edx
	push	esi
	call	?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; UnitClassArrayHelpers::Read

; 7683 : 
; 7684 : 	BuildingClassArrayHelpers::Read(kStream, m_paiBuildingClassCount);

	mov	eax, DWORD PTR [edi+2932]
	push	eax
	push	esi
	call	?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingClassArrayHelpers::Read

; 7685 : 	BuildingArrayHelpers::Read(kStream, m_paiObsoleteBuildingCount);

	mov	ecx, DWORD PTR [edi+2936]
	push	ecx
	push	esi
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 36					; 00000024H

; 7686 : 
; 7687 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiTerrainTradeCount, GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	edx, DWORD PTR [edi+2940]
	push	eax
	push	edx
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7688 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiVictoryCountdown, GC.getNumVictoryInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	push	eax
	mov	eax, DWORD PTR [edi+2944]
	push	eax
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 7689 : 
; 7690 : 	ArrayWrapper<int> kTurnTeamMetWrapper(MAX_CIV_TEAMS, &m_aiTurnTeamMet[0]);

	lea	ebx, DWORD PTR [edi+2568]
	mov	ebp, 63					; 0000003fH

; 7691 : 	kStream >> kTurnTeamMetWrapper;

$LL296@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL296@Read

; 7692 : 
; 7693 : 	m_pTeamTechs->Read(kStream);

	mov	ecx, DWORD PTR [edi+2980]
	push	esi
	call	?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z ; CvTeamTechs::Read

; 7694 : 
; 7695 : 	ImprovementArrayHelpers::ReadYieldArray(kStream, m_ppaaiImprovementYieldChange, NUM_YIELD_TYPES);

	mov	ecx, DWORD PTR [edi+2948]
	push	6
	push	ecx
	push	esi
	call	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray

; 7696 : 	ImprovementArrayHelpers::ReadYieldArray(kStream, m_ppaaiImprovementNoFreshWaterYieldChange, NUM_YIELD_TYPES);

	mov	edx, DWORD PTR [edi+2952]
	push	6
	push	edx
	push	esi
	call	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray

; 7697 : 	ImprovementArrayHelpers::ReadYieldArray(kStream, m_ppaaiImprovementFreshWaterYieldChange, NUM_YIELD_TYPES);

	mov	eax, DWORD PTR [edi+2956]
	push	6
	push	eax
	push	esi
	call	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray

; 7698 : 
; 7699 : 	CvInfosSerializationHelper::ReadHashedTypeArray(kStream, m_aeRevealedResources);

	lea	ecx, DWORD PTR [edi+2964]
	push	ecx
	push	esi
	call	??$ReadHashedTypeArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum ResourceTypes>

; 7700 : 
; 7701 : 	// Fix bad 'at war' flags where we are at war with ourselves.  Not a good thing.
; 7702 : 	if(m_eID >= 0 && m_eID < MAX_TEAMS)

	mov	eax, DWORD PTR [edi+4]
	add	esp, 44					; 0000002cH
	test	eax, eax
	jl	SHORT $LN1@Read
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@Read

; 7703 : 	{
; 7704 : 		m_abAtWar[m_eID] = false;

	mov	BYTE PTR [eax+edi+1928], 0

; 7705 : 		m_aiNumTurnsAtWar[m_eID] = 0;

	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+edx*4+468], ebp
$LN1@Read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 7706 : 	}
; 7707 : }

	add	esp, 32					; 00000020H
	ret	4
?Read@CvTeam@@UAEXAAVFDataStream@@@Z ENDP		; CvTeam::Read
_TEXT	ENDS
PUBLIC	??0CvTeam@@QAE@XZ				; CvTeam::CvTeam
EXTRN	??0CvTeamTechs@@QAE@XZ:PROC			; CvTeamTechs::CvTeamTechs
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0CvTeam@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTeam@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTeam@@QAE@XZ$1
	DD	00H
	DD	00H
__ehfuncinfo$??0CvTeam@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvTeam@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.cpp
xdata$x	ENDS
;	COMDAT ??0CvTeam@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T255426 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTeam@@QAE@XZ PROC					; CvTeam::CvTeam, COMDAT
; _this$ = ecx

; 61   : {

	push	-1
	push	__ehhandler$??0CvTeam@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvTeam@@6B@
	mov	DWORD PTR [esi+2888], ebx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi+2968], ebx
	mov	DWORD PTR [esi+2972], ebx
	mov	DWORD PTR [esi+2976], ebx

; 62   : 	m_abCanLaunch = NULL;
; 63   : 	m_abVictoryAchieved = NULL;
; 64   : 	m_abSmallAwardAchieved = NULL;
; 65   : 
; 66   : 	m_paiRouteChange = NULL;
; 67   : 	m_paiBuildTimeChange = NULL;
; 68   : 	m_paiProjectCount = NULL;
; 69   : 	m_paiProjectDefaultArtTypes = NULL;
; 70   : 	m_pavProjectArtTypes = NULL;
; 71   : 	m_paiProjectMaking = NULL;
; 72   : 	m_paiUnitClassCount = NULL;
; 73   : 	m_paiBuildingClassCount = NULL;
; 74   : 	m_paiObsoleteBuildingCount = NULL;
; 75   : 	m_paiTerrainTradeCount = NULL;
; 76   : 	m_aiVictoryCountdown = NULL;
; 77   : 	m_aiForceTeamVoteEligibilityCount = NULL;
; 78   : 
; 79   : 	m_pTeamTechs = FNEW(CvTeamTechs, c_eCiv5GameplayDLL, 0);

	push	28					; 0000001cH
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	mov	DWORD PTR [esi+2896], ebx
	mov	DWORD PTR [esi+2900], ebx
	mov	DWORD PTR [esi+2904], ebx
	mov	DWORD PTR [esi+2908], ebx
	mov	DWORD PTR [esi+2912], ebx
	mov	DWORD PTR [esi+2916], ebx
	mov	DWORD PTR [esi+2920], ebx
	mov	DWORD PTR [esi+2960], ebx
	mov	DWORD PTR [esi+2924], ebx
	mov	DWORD PTR [esi+2928], ebx
	mov	DWORD PTR [esi+2932], ebx
	mov	DWORD PTR [esi+2936], ebx
	mov	DWORD PTR [esi+2940], ebx
	mov	DWORD PTR [esi+2944], ebx
	mov	DWORD PTR [esi+2892], ebx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T255426[esp+28], eax
	mov	BYTE PTR __$EHRec$[esp+36], 1
	cmp	eax, ebx
	je	SHORT $LN3@CvTeam@2
	mov	ecx, eax
	call	??0CvTeamTechs@@QAE@XZ			; CvTeamTechs::CvTeamTechs
	jmp	SHORT $LN4@CvTeam@2
$LN3@CvTeam@2:
	xor	eax, eax
$LN4@CvTeam@2:

; 80   : 
; 81   : 	m_ppaaiImprovementYieldChange = NULL;
; 82   : 	m_ppaaiImprovementNoFreshWaterYieldChange = NULL;
; 83   : 	m_ppaaiImprovementFreshWaterYieldChange = NULL;
; 84   : 
; 85   : 	reset((TeamTypes)0, true);

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+36], bl
	mov	DWORD PTR [esi+2980], eax
	mov	DWORD PTR [esi+2948], ebx
	mov	DWORD PTR [esi+2952], ebx
	mov	DWORD PTR [esi+2956], ebx
	call	?uninit@CvTeam@@QAEXXZ			; CvTeam::uninit

; 86   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTeam@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2964				; 00000b94H
	jmp	??1?$vector@W4ResourceTypes@@V?$allocator@W4ResourceTypes@@@std@@@std@@QAE@XZ ; std::vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >::~vector<enum ResourceTypes,std::allocator<enum ResourceTypes> >
__unwindfunclet$??0CvTeam@@QAE@XZ$1:
	mov	eax, DWORD PTR $T255426[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0CvTeam@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTeam@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTeam@@QAE@XZ ENDP					; CvTeam::CvTeam
PUBLIC	?init@CvTeam@@QAEXW4TeamTypes@@@Z		; CvTeam::init
; Function compile flags: /Ogtpy
;	COMDAT ?init@CvTeam@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eID$ = 8						; size = 4
?init@CvTeam@@QAEXW4TeamTypes@@@Z PROC			; CvTeam::init, COMDAT
; _this$ = ecx

; 101  : 	//--------------------------------
; 102  : 	// Init saved data
; 103  : 	reset(eID);

	mov	eax, DWORD PTR _eID$[esp-4]
	push	0
	push	eax
	call	?reset@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::reset

; 104  : 
; 105  : 	//--------------------------------
; 106  : 	// Init non-saved data
; 107  : 
; 108  : 	//--------------------------------
; 109  : 	// Init other game data
; 110  : }

	ret	4
?init@CvTeam@@QAEXW4TeamTypes@@@Z ENDP			; CvTeam::init
_TEXT	ENDS
PUBLIC	?initStatics@CvTeam@@SAXXZ			; CvTeam::initStatics
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?initStatics@CvTeam@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initStatics@CvTeam@@SAXXZ$0
__ehfuncinfo$?initStatics@CvTeam@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?initStatics@CvTeam@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?initStatics@CvTeam@@SAXXZ
_TEXT	SEGMENT
$T256342 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?initStatics@CvTeam@@SAXXZ PROC				; CvTeam::initStatics, COMDAT

; 42   : {

	push	-1
	push	__ehhandler$?initStatics@CvTeam@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi

; 43   : 	m_aTeams = FNEW(CvTeam[REALLY_MAX_TEAMS], c_eCiv5GameplayDLL, 0);

	push	238724					; 0003a484H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T256342[esp+20], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	eax, eax
	je	SHORT $LN6@initStatic
	push	OFFSET ??1CvTeam@@QAE@XZ		; CvTeam::~CvTeam
	push	OFFSET ??0CvTeam@@QAE@XZ		; CvTeam::CvTeam
	push	80					; 00000050H
	lea	esi, DWORD PTR [eax+4]
	push	2984					; 00000ba8H
	push	esi
	mov	DWORD PTR [eax], 80			; 00000050H
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $LN7@initStatic
$LN6@initStatic:
	xor	esi, esi
$LN7@initStatic:
	mov	DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A, esi ; CvTeam::m_aTeams

; 44   : 
; 45   : 	for(int i = 0; i < REALLY_MAX_TEAMS; ++i)

	xor	ecx, ecx
	xor	eax, eax
	pop	esi
	npad	13
$LL11@initStatic:

; 46   : 	{
; 47   : 		m_aTeams[i].m_eID = (TeamTypes)i;

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR [eax+edx+4], ecx
	add	eax, 2984				; 00000ba8H
	inc	ecx
	cmp	eax, 238720				; 0003a480H
	jl	SHORT $LL11@initStatic

; 48   : 	}
; 49   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initStatics@CvTeam@@SAXXZ$0:
	mov	eax, DWORD PTR $T256342[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?initStatics@CvTeam@@SAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?initStatics@CvTeam@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?initStatics@CvTeam@@SAXXZ ENDP				; CvTeam::initStatics
END
