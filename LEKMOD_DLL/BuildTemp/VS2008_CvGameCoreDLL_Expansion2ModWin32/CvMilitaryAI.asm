; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvMilitaryAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG225636 DB	'NoMinorCivs', 00H
$SG225637 DB	'OnlyMinorCivs', 00H
	ORG $+2
$SG225638 DB	'UpdateCitySpecializations', 00H
	ORG $+2
$SG225639 DB	'CheckTriggerTurnCount', 00H
	ORG $+2
$SG225640 DB	'FirstTurnExecuted', 00H
	ORG $+2
$SG225641 DB	'MinimumNumTurnsExecuted', 00H
$SG225642 DB	'WeightThreshold', 00H
$SG225644 DB	'Advisor', 00H
$SG225647 DB	'MILITARY', 00H
	ORG $+3
$SG225650 DB	'ECONOMIC', 00H
	ORG $+3
$SG225653 DB	'FOREIGN', 00H
$SG225656 DB	'SCIENCE', 00H
$SG225657 DB	'AdvisorCounsel', 00H
	ORG $+1
$SG225659 DB	'TechObsolete', 00H
	ORG $+3
$SG225660 DB	'TechPrereq', 00H
	ORG $+1
$SG225662 DB	'AIMilitaryStrategyType', 00H
	ORG $+1
$SG225663 DB	'AIMilitaryStrategy_Player_Flavors', 00H
	ORG $+2
$SG225664 DB	'AIMilitaryStrategyType', 00H
	ORG $+1
$SG225665 DB	'AIMilitaryStrategy_City_Flavors', 00H
$SG225666 DB	'AIMilitaryStrategyType', 00H
	ORG $+1
$SG225667 DB	'AIMilitaryStrategy_PersonalityFlavorThresholdMods', 00H
	ORG $+2
$SG226214 DB	'FLAVOR_NAVAL', 00H
	ORG $+3
$SG226286 DB	'Emergency Unit Purchased: %s, ', 00H
	ORG $+1
$SG226296 DB	'Emergency Faith Unit Purchase: %s, ', 00H
$SG226321 DB	'Emergency Building Purchased: %s, ', 00H
	ORG $+1
$SG226787 DB	'Choosing attack target from top 25%% of choices', 00H
$SG227195 DB	'.csv', 00H
	ORG $+3
$SG227196 DB	'OperationalAILog_', 00H
	ORG $+2
$SG227198 DB	'OperationalAILog.csv', 00H
	ORG $+3
$SG227199 DB	'%03d, ', 00H
	ORG $+1
$SG227201 DB	', ', 00H
	ORG $+1
$SG227203 DB	'Basic Attack, ', 00H
	ORG $+1
$SG227206 DB	'Sneak Attack, ', 00H
	ORG $+1
$SG227209 DB	'Pure Naval Attack, ', 00H
$SG227211 DB	'City State Attack, ', 00H
$SG227212 DB	', ', 00H
	ORG $+1
$SG227221 DB	'Target: %s, Muster: %s, %d, Distance: %d', 00H
	ORG $+3
$SG227224 DB	', Sea', 00H
	ORG $+2
$SG227226 DB	', Land', 00H
	ORG $+1
$SG227243 DB	'.csv', 00H
	ORG $+3
$SG227244 DB	'OperationalAILog_', 00H
	ORG $+2
$SG227246 DB	'OperationalAILog.csv', 00H
	ORG $+3
$SG227247 DB	'%03d, ', 00H
	ORG $+1
$SG227249 DB	', ', 00H
	ORG $+1
$SG227251 DB	'Basic Attack, ', 00H
	ORG $+1
$SG227254 DB	'Sneak Attack, ', 00H
	ORG $+1
$SG227257 DB	'Pure Naval Attack, ', 00H
$SG227259 DB	'City State Attack, ', 00H
$SG227260 DB	', ', 00H
	ORG $+1
$SG227263 DB	'CHOSEN: %s, Muster: %s', 00H
	ORG $+1
$SG227266 DB	', Sea', 00H
	ORG $+2
$SG227268 DB	', Land', 00H
	ORG $+1
$SG227281 DB	'%03d, ', 00H
	ORG $+1
$SG227283 DB	', ', 00H
	ORG $+1
$SG227284 DB	'Declared War on: %s', 00H
$SG227296 DB	'%03d, ', 00H
	ORG $+1
$SG227298 DB	', ', 00H
	ORG $+1
$SG227299 DB	'DESTROYED!', 00H
	ORG $+1
$SG227316 DB	'%03d, ', 00H
	ORG $+1
$SG227318 DB	', ', 00H
	ORG $+1
$SG227321 DB	', ', 00H
	ORG $+1
$SG227322 DB	'Captured: ', 00H
	ORG $+1
$SG227324 DB	'From: ', 00H
	ORG $+1
$SG227341 DB	'%03d, ', 00H
	ORG $+1
$SG227343 DB	', ', 00H
	ORG $+1
$SG227346 DB	', ', 00H
	ORG $+1
$SG227347 DB	'Razed: ', 00H
$SG227349 DB	'From: ', 00H
	ORG $+1
$SG227363 DB	'%03d, ', 00H
	ORG $+1
$SG227365 DB	', ', 00H
	ORG $+1
$SG227366 DB	'Made peace with: %s', 00H
$SG227380 DB	'%03d, ', 00H
	ORG $+1
$SG227382 DB	', ', 00H
	ORG $+1
$SG227391 DB	', ', 00H
	ORG $+1
$SG227393 DB	'Made peace with team: %d (%s)', 00H
	ORG $+2
$SG227405 DB	'%03d, ', 00H
	ORG $+1
$SG227407 DB	', ', 00H
	ORG $+1
$SG227408 DB	'Scrapping %s, X: %d, Y: %d, ', 00H
	ORG $+3
$SG227409 DB	'by DoDeficit(), , ', 00H
	ORG $+1
$SG227411 DB	'Num Land Units: %d, In Armies %d, Rec Size: %d, ', 00H
	ORG $+3
$SG227413 DB	'Num Naval Units: %d, In Armies %d, ', 00H
$SG227442 DB	'ECONOMICAISTRATEGY_NAVAL_MAP', 00H
	ORG $+3
$SG227446 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG227449 DB	'FLAVOR_DEFENSE', 00H
	ORG $+1
$SG227467 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG227606 DB	'MILITARYAISTRATEGY_ENOUGH_MILITARY_UNITS', 00H
	ORG $+3
$SG227609 DB	'MILITARYAISTRATEGY_EMPIRE_DEFENSE', 00H
	ORG $+2
$SG227612 DB	'MILITARYAISTRATEGY_EMPIRE_DEFENSE_CRITICAL', 00H
	ORG $+1
$SG227615 DB	'MILITARYAISTRATEGY_ENOUGH_NAVAL_UNITS', 00H
	ORG $+2
$SG227618 DB	'MILITARYAISTRATEGY_NEED_NAVAL_UNITS', 00H
$SG227621 DB	'MILITARYAISTRATEGY_NEED_NAVAL_UNITS_CRITICAL', 00H
	ORG $+3
$SG227624 DB	'MILITARYAISTRATEGY_WAR_MOBILIZATION', 00H
$SG227627 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG227630 DB	'MILITARYAISTRATEGY_MINOR_CIV_GENERAL_DEFENSE', 00H
	ORG $+3
$SG227633 DB	'MILITARYAISTRATEGY_MINOR_CIV_THREAT_ELEVATED', 00H
	ORG $+3
$SG227636 DB	'MILITARYAISTRATEGY_MINOR_CIV_THREAT_CRITICAL', 00H
	ORG $+3
$SG227639 DB	'MILITARYAISTRATEGY_ERADICATE_BARBARIANS', 00H
$SG227642 DB	'MILITARYAISTRATEGY_WINNING_WARS', 00H
$SG227645 DB	'MILITARYAISTRATEGY_LOSING_WARS', 00H
	ORG $+1
$SG227648 DB	'MILITARYAISTRATEGY_NEED_RANGED', 00H
	ORG $+1
$SG227651 DB	'MILITARYAISTRATEGY_ENOUGH_RANGED', 00H
	ORG $+3
$SG227654 DB	'MILITARYAISTRATEGY_NEED_RANGED_EARLY', 00H
	ORG $+3
$SG227657 DB	'MILITARYAISTRATEGY_NEED_MOBILE', 00H
	ORG $+1
$SG227660 DB	'MILITARYAISTRATEGY_ENOUGH_MOBILE', 00H
	ORG $+3
$SG227663 DB	'MILITARYAISTRATEGY_NEED_AIR', 00H
$SG227666 DB	'MILITARYAISTRATEGY_ENOUGH_AIR', 00H
	ORG $+2
$SG227669 DB	'MILITARYAISTRATEGY_NEED_NUKE', 00H
	ORG $+3
$SG227672 DB	'MILITARYAISTRATEGY_NEED_ANTIAIR', 00H
$SG227675 DB	'MILITARYAISTRATEGY_ENOUGH_ANTIAIR', 00H
	ORG $+2
$SG227678 DB	'MILITARYAISTRATEGY_NEED_AIR_CARRIER', 00H
$SG227685 DB	'MilitaryStrategyCanActivate', 00H
$SG227729 DB	'MILITARYAISTRATEGY_ERADICATE_BARBARIANS', 00H
$SG227732 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG227735 DB	'MILITARYAISTRATEGY_EMPIRE_DEFENSE_CRITICAL', 00H
	ORG $+1
$SG227831 DB	'FLAVOR_USE_NUKE', 00H
$SG227833 DB	'Roll to see if we''re going to nuke!', 00H
$SG227835 DB	'Second roll to see if we''re going to nuke!', 00H
	ORG $+1
$SG227881 DB	'Choosing attack target by weight', 00H
	ORG $+3
$SG227892 DB	'FLAVOR_NAVAL', 00H
	ORG $+3
$SG227912 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG227928 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG227933 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG227972 DB	'ECONOMICAISTRATEGY_LOSING_MONEY', 00H
$SG227979 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG228209 DB	'.csv', 00H
	ORG $+3
$SG228210 DB	'FlavorAILog_', 00H
	ORG $+3
$SG228212 DB	'FlavorAILog.csv', 00H
$SG228213 DB	'%03d, ', 00H
	ORG $+1
$SG228215 DB	', ', 00H
	ORG $+1
$SG228218 DB	'%s, %d', 00H
	ORG $+1
$SG228223 DB	'.csv', 00H
	ORG $+3
$SG228224 DB	'TechAILog_', 00H
	ORG $+1
$SG228236 DB	'.csv', 00H
	ORG $+3
$SG228237 DB	'_', 00H
	ORG $+2
$SG228238 DB	'CityStrategyAILog_', 00H
	ORG $+1
$SG228240 DB	'CityStrategyAILog.csv', 00H
	ORG $+2
$SG228241 DB	'TechAILog.csv', 00H
	ORG $+6
$SG228255 DB	'Turn, Player, Cities, Settlers, Civ Threat, Barb Threat,'
	DB	' Land Units, Land In Armies, Rec Land Size, Land Reserve, Nav'
	DB	'al Units, Naval In Armies, Rec Naval Size, Most Threatened, D'
	DB	'anger', 00H
$SG228256 DB	'%03d, ', 00H
	ORG $+1
$SG228258 DB	', ', 00H
	ORG $+1
$SG228259 DB	'%d, %d, ', 00H
	ORG $+3
$SG228261 DB	'%d, %d, ', 00H
	ORG $+3
$SG228263 DB	'%d, %d, %d, %d, %d, %d, %d, ', 00H
	ORG $+3
$SG228266 DB	', %d', 00H
	ORG $+3
$SG228281 DB	'%03d, ', 00H
	ORG $+1
$SG228283 DB	', ', 00H
	ORG $+1
$SG228285 DB	'Land Army Under Construction', 00H
	ORG $+3
$SG228287 DB	'Naval Invasion Under Construction', 00H
	ORG $+2
$SG228303 DB	'%s, Damage=%d, ArmyID=%d, X=%d, Y=%d, DistFromCap=%d', 00H
	ORG $+3
$SG228319 DB	'%03d, ', 00H
	ORG $+1
$SG228323 DB	', New War State: ', 00H
	ORG $+2
$SG228324 DB	', vs. ', 00H
	ORG $+1
$SG228330 DB	'Calm', 00H
	ORG $+3
$SG228332 DB	'Nearly Won', 00H
	ORG $+1
$SG228334 DB	'Offensive', 00H
	ORG $+2
$SG228336 DB	'Stalemate', 00H
	ORG $+2
$SG228338 DB	'Defensive', 00H
	ORG $+2
$SG228340 DB	'Nearly Defeated', 00H
$SG228342 DB	'XXX', 00H
$SG228345 DB	', Old War State: ', 00H
	ORG $+2
$SG228351 DB	'Calm', 00H
	ORG $+3
$SG228353 DB	'Nearly Won', 00H
	ORG $+1
$SG228355 DB	'Offensive', 00H
	ORG $+2
$SG228357 DB	'Stalemate', 00H
	ORG $+2
$SG228359 DB	'Defensive', 00H
	ORG $+2
$SG228361 DB	'Nearly Defeated', 00H
$SG228363 DB	'XXX', 00H
$SG228376 DB	'%03d, ', 00H
	ORG $+1
$SG228378 DB	', ', 00H
	ORG $+1
$SG228379 DB	'Scrapping %s, X: %d, Y: %d, ', 00H
	ORG $+3
$SG228381 DB	'IN DEFICIT, ', 00H
	ORG $+3
$SG228383 DB	'Finances ok, ', 00H
	ORG $+2
$SG228385 DB	'CONQUEST, ', 00H
	ORG $+1
$SG228387 DB	'Other GS, ', 00H
	ORG $+1
$SG228389 DB	'Num Land Units: %d, In Armies %d, Rec Size: %d, ', 00H
	ORG $+3
$SG228391 DB	'Num Naval Units: %d, In Armies %d, ', 00H
$SG228402 DB	'%03d, ', 00H
	ORG $+1
$SG228404 DB	', ', 00H
	ORG $+1
$SG228414 DB	'MilitarySummary.csv', 00H
$SG228419 DB	'.csv', 00H
	ORG $+3
$SG228420 DB	'MilitaryAILog_', 00H
	ORG $+1
$SG228422 DB	'MilitaryAILog.csv', 00H
	ORG $+2
$SG228445 DB	'ECONOMICAISTRATEGY_LOSING_MONEY', 00H
$SG228449 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG228483 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG228488 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG228532 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG228576 DB	'FLAVOR_RANGED', 00H
	ORG $+2
$SG228587 DB	'FLAVOR_RANGED', 00H
	ORG $+2
$SG228596 DB	'MILITARYAISTRATEGY_WAR_MOBILIZATION', 00H
$SG228606 DB	'FLAVOR_MOBILE', 00H
	ORG $+2
$SG228617 DB	'FLAVOR_MOBILE', 00H
	ORG $+2
$SG228628 DB	'FLAVOR_AIR', 00H
	ORG $+1
$SG228639 DB	'FLAVOR_AIR', 00H
	ORG $+1
$SG228649 DB	'FLAVOR_NUKE', 00H
$SG228698 DB	'SPECIALUNIT_FIGHTER', 00H
$SG228718 DB	'FLAVOR_NAVAL', 00H
	ORG $+3
$SG228737 DB	'ECONOMICAISTRATEGY_NAVAL_MAP', 00H
	ORG $+3
$SG228740 DB	'ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS', 00H
	ORG $+2
$SG228748 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??0CvMilitaryTarget@@QAE@XZ			; CvMilitaryTarget::CvMilitaryTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.h
;	COMDAT ??0CvMilitaryTarget@@QAE@XZ
_TEXT	SEGMENT
??0CvMilitaryTarget@@QAE@XZ PROC			; CvMilitaryTarget::CvMilitaryTarget, COMDAT
; _this$ = ecx

; 130  : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], cl

; 131  : 	}

	ret	0
??0CvMilitaryTarget@@QAE@XZ ENDP			; CvMilitaryTarget::CvMilitaryTarget
_TEXT	ENDS
PUBLIC	?GetLandDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ ; CvMilitaryAI::GetLandDefenseState
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ
_TEXT	SEGMENT
?GetLandDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ PROC ; CvMilitaryAI::GetLandDefenseState, COMDAT
; _this$ = ecx

; 189  : 		return m_eLandDefenseState;

	mov	eax, DWORD PTR [ecx+112]

; 190  : 	};

	ret	0
?GetLandDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ ENDP ; CvMilitaryAI::GetLandDefenseState
_TEXT	ENDS
PUBLIC	?GetNavalDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ ; CvMilitaryAI::GetNavalDefenseState
; Function compile flags: /Ogtpy
;	COMDAT ?GetNavalDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ
_TEXT	SEGMENT
?GetNavalDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ PROC ; CvMilitaryAI::GetNavalDefenseState, COMDAT
; _this$ = ecx

; 193  : 		return m_eNavalDefenseState;

	mov	eax, DWORD PTR [ecx+116]

; 194  : 	};

	ret	0
?GetNavalDefenseState@CvMilitaryAI@@QBE?AW4DefenseState@@XZ ENDP ; CvMilitaryAI::GetNavalDefenseState
_TEXT	ENDS
PUBLIC	?GetMandatoryReserveSize@CvMilitaryAI@@QBEHXZ	; CvMilitaryAI::GetMandatoryReserveSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetMandatoryReserveSize@CvMilitaryAI@@QBEHXZ
_TEXT	SEGMENT
?GetMandatoryReserveSize@CvMilitaryAI@@QBEHXZ PROC	; CvMilitaryAI::GetMandatoryReserveSize, COMDAT
; _this$ = ecx

; 239  : 		return m_iMandatoryReserveSize;

	mov	eax, DWORD PTR [ecx+100]

; 240  : 	};

	ret	0
?GetMandatoryReserveSize@CvMilitaryAI@@QBEHXZ ENDP	; CvMilitaryAI::GetMandatoryReserveSize
_TEXT	ENDS
PUBLIC	?GetLandReservesAvailable@CvMilitaryAI@@QBEHXZ	; CvMilitaryAI::GetLandReservesAvailable
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandReservesAvailable@CvMilitaryAI@@QBEHXZ
_TEXT	SEGMENT
?GetLandReservesAvailable@CvMilitaryAI@@QBEHXZ PROC	; CvMilitaryAI::GetLandReservesAvailable, COMDAT
; _this$ = ecx

; 243  : 		return (m_iNumLandUnits - m_iNumLandUnitsInArmies - GetMandatoryReserveSize());

	mov	eax, DWORD PTR [ecx+52]
	sub	eax, DWORD PTR [ecx+100]
	sub	eax, DWORD PTR [ecx+72]

; 244  : 	};

	ret	0
?GetLandReservesAvailable@CvMilitaryAI@@QBEHXZ ENDP	; CvMilitaryAI::GetLandReservesAvailable
_TEXT	ENDS
PUBLIC	?HasAirforce@CvMilitaryAI@@QBE_NXZ		; CvMilitaryAI::HasAirforce
; Function compile flags: /Ogtpy
;	COMDAT ?HasAirforce@CvMilitaryAI@@QBE_NXZ
_TEXT	SEGMENT
?HasAirforce@CvMilitaryAI@@QBE_NXZ PROC			; CvMilitaryAI::HasAirforce, COMDAT
; _this$ = ecx

; 250  : 		return m_iNumAirUnits > 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+80], eax
	setg	al

; 251  : 	};

	ret	0
?HasAirforce@CvMilitaryAI@@QBE_NXZ ENDP			; CvMilitaryAI::HasAirforce
_TEXT	ENDS
PUBLIC	?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ ; CvMilitaryAI::GetArmyBeingBuilt
; Function compile flags: /Ogtpy
;	COMDAT ?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ
_TEXT	SEGMENT
?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ PROC ; CvMilitaryAI::GetArmyBeingBuilt, COMDAT
; _this$ = ecx

; 255  : 		return m_eArmyTypeBeingBuilt;

	mov	eax, DWORD PTR [ecx+44]

; 256  : 	};

	ret	0
?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ ENDP ; CvMilitaryAI::GetArmyBeingBuilt
_TEXT	ENDS
PUBLIC	?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
;	COMDAT ?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z PROC ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue, COMDAT
; _this$ = ecx

; 112  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 113  : 	FAssertMsg(i > -1, "Index out of bounds");
; 114  : 	return m_piPlayerFlavorValue ? m_piPlayerFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+260]
	test	eax, eax
	je	SHORT $LN3@GetPlayerF
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 115  : }

	ret	4
$LN3@GetPlayerF:

; 112  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 113  : 	FAssertMsg(i > -1, "Index out of bounds");
; 114  : 	return m_piPlayerFlavorValue ? m_piPlayerFlavorValue[i] : -1;

	or	eax, -1

; 115  : }

	ret	4
?GetPlayerFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvMilitaryAIStrategyXMLEntry::GetPlayerFlavorValue
_TEXT	ENDS
PUBLIC	?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z PROC ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue, COMDAT
; _this$ = ecx

; 120  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 121  : 	FAssertMsg(i > -1, "Index out of bounds");
; 122  : 	return m_piCityFlavorValue ? m_piCityFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+264]
	test	eax, eax
	je	SHORT $LN3@GetCityFla
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 123  : }

	ret	4
$LN3@GetCityFla:

; 120  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 121  : 	FAssertMsg(i > -1, "Index out of bounds");
; 122  : 	return m_piCityFlavorValue ? m_piCityFlavorValue[i] : -1;

	or	eax, -1

; 123  : }

	ret	4
?GetCityFlavorValue@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvMilitaryAIStrategyXMLEntry::GetCityFlavorValue
_TEXT	ENDS
PUBLIC	?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold, COMDAT
; _this$ = ecx

; 128  : 	return m_iWeightThreshold;

	mov	eax, DWORD PTR [ecx+268]

; 129  : }

	ret	0
?GetWeightThreshold@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetWeightThreshold
_TEXT	ENDS
PUBLIC	?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ; CvMilitaryAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z PROC ; CvMilitaryAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod, COMDAT
; _this$ = ecx

; 134  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 135  : 	FAssertMsg(i > -1, "Index out of bounds");
; 136  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	mov	eax, DWORD PTR [ecx+272]
	test	eax, eax
	je	SHORT $LN3@GetPersona
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 137  : }

	ret	4
$LN3@GetPersona:

; 134  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 135  : 	FAssertMsg(i > -1, "Index out of bounds");
; 136  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	or	eax, -1

; 137  : }

	ret	4
?GetPersonalityFlavorThresholdMod@CvMilitaryAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvMilitaryAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
_TEXT	ENDS
PUBLIC	?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::IsNoMinorCivs
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ PROC ; CvMilitaryAIStrategyXMLEntry::IsNoMinorCivs, COMDAT
; _this$ = ecx

; 142  : 	return m_bNoMinorCivs;

	mov	al, BYTE PTR [ecx+276]

; 143  : }

	ret	0
?IsNoMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvMilitaryAIStrategyXMLEntry::IsNoMinorCivs
_TEXT	ENDS
PUBLIC	?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::IsOnlyMinorCivs
; Function compile flags: /Ogtpy
;	COMDAT ?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ PROC ; CvMilitaryAIStrategyXMLEntry::IsOnlyMinorCivs, COMDAT
; _this$ = ecx

; 148  : 	return m_bOnlyMinorCivs;

	mov	al, BYTE PTR [ecx+277]

; 149  : }

	ret	0
?IsOnlyMinorCivs@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvMilitaryAIStrategyXMLEntry::IsOnlyMinorCivs
_TEXT	ENDS
PUBLIC	?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate
; Function compile flags: /Ogtpy
;	COMDAT ?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ PROC ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate, COMDAT
; _this$ = ecx

; 154  : 	return m_bUpdateCitySpecializations;

	mov	al, BYTE PTR [ecx+278]

; 155  : }

	ret	0
?RequiresCitySpecializationUpdate@CvMilitaryAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvMilitaryAIStrategyXMLEntry::RequiresCitySpecializationUpdate
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 160  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+280]

; 161  : }

	ret	0
?GetTechPrereq@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete, COMDAT
; _this$ = ecx

; 166  : 	return m_iTechObsolete;

	mov	eax, DWORD PTR [ecx+284]

; 167  : }

	ret	0
?GetTechObsolete@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetTechObsolete
_TEXT	ENDS
PUBLIC	?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted, COMDAT
; _this$ = ecx

; 172  : 	return m_iMinimumNumTurnsExecuted;

	mov	eax, DWORD PTR [ecx+288]

; 173  : }

	ret	0
?GetMinimumNumTurnsExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
_TEXT	ENDS
PUBLIC	?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount, COMDAT
; _this$ = ecx

; 178  : 	return m_iCheckTriggerTurnCount;

	mov	eax, DWORD PTR [ecx+292]

; 179  : }

	ret	0
?GetCheckTriggerTurnCount@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetCheckTriggerTurnCount
_TEXT	ENDS
PUBLIC	?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetFirstTurnExecuted
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetFirstTurnExecuted, COMDAT
; _this$ = ecx

; 184  : 	return m_iFirstTurnExecuted;

	mov	eax, DWORD PTR [ecx+296]

; 185  : }

	ret	0
?GetFirstTurnExecuted@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetFirstTurnExecuted
_TEXT	ENDS
PUBLIC	?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ; CvMilitaryAIStrategyXMLEntry::GetAdvisor
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ
_TEXT	SEGMENT
?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ PROC ; CvMilitaryAIStrategyXMLEntry::GetAdvisor, COMDAT
; _this$ = ecx

; 189  : 	return m_eAdvisor;

	mov	eax, DWORD PTR [ecx+300]

; 190  : }

	ret	0
?GetAdvisor@CvMilitaryAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetAdvisor
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselText
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselText, COMDAT
; _this$ = ecx

; 194  : 	return m_strAdvisorCounselText.c_str();

	add	ecx, 304				; 00000130H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetAdvisorCounselText@CvMilitaryAIStrategyXMLEntry@@QBEPBDXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselText
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselImportance
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ PROC ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselImportance, COMDAT
; _this$ = ecx

; 199  : 	return m_iAdvisorCounselImportance;

	mov	eax, DWORD PTR [ecx+332]

; 200  : }

	ret	0
?GetAdvisorCounselImportance@CvMilitaryAIStrategyXMLEntry@@QBEHXZ ENDP ; CvMilitaryAIStrategyXMLEntry::GetAdvisorCounselImportance
_TEXT	ENDS
PUBLIC	?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries, COMDAT
; _this$ = ecx

; 219  : {

	mov	eax, ecx

; 220  : 	return m_paAIStrategyEntries;
; 221  : }

	ret	0
?GetMilitaryAIStrategyEntries@CvMilitaryAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvMilitaryAIStrategyXMLEntries::GetMilitaryAIStrategyEntries
_TEXT	ENDS
PUBLIC	??0CvMilitaryAI@@QAE@XZ				; CvMilitaryAI::CvMilitaryAI
; Function compile flags: /Ogtpy
;	COMDAT ??0CvMilitaryAI@@QAE@XZ
_TEXT	SEGMENT
??0CvMilitaryAI@@QAE@XZ PROC				; CvMilitaryAI::CvMilitaryAI, COMDAT
; _this$ = ecx

; 263  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], 1
	mov	DWORD PTR [eax+44], -1
	mov	DWORD PTR [eax+48], ecx

; 264  : }

	ret	0
??0CvMilitaryAI@@QAE@XZ ENDP				; CvMilitaryAI::CvMilitaryAI
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ	; CvMilitaryAI::GetPlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
;	COMDAT ?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ PROC	; CvMilitaryAI::GetPlayer, COMDAT
; _this$ = ecx

; 420  : 	return m_pPlayer;

	mov	eax, DWORD PTR [ecx]

; 421  : }

	ret	0
?GetPlayer@CvMilitaryAI@@QAEPAVCvPlayer@@XZ ENDP	; CvMilitaryAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ; CvMilitaryAI::GetMilitaryAIStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ
_TEXT	SEGMENT
?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ PROC ; CvMilitaryAI::GetMilitaryAIStrategies, COMDAT
; _this$ = ecx

; 426  : 	return m_pAIStrategies;

	mov	eax, DWORD PTR [ecx+8]

; 427  : }

	ret	0
?GetMilitaryAIStrategies@CvMilitaryAI@@QAEPAVCvMilitaryAIStrategyXMLEntries@@XZ ENDP ; CvMilitaryAI::GetMilitaryAIStrategies
_TEXT	ENDS
PUBLIC	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z PROC ; CvMilitaryAI::IsUsingStrategy, COMDAT
; _this$ = ecx

; 432  : 	return m_pabUsingStrategy[(int) eStrategy];

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 433  : }

	ret	4
?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ENDP ; CvMilitaryAI::IsUsingStrategy
_TEXT	ENDS
PUBLIC	?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::GetTurnStrategyAdopted
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z PROC ; CvMilitaryAI::GetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 458  : 	return m_paiTurnStrategyAdopted[(int) eStrategy];

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 459  : }

	ret	4
?GetTurnStrategyAdopted@CvMilitaryAI@@QAEHW4MilitaryAIStrategyTypes@@@Z ENDP ; CvMilitaryAI::GetTurnStrategyAdopted
_TEXT	ENDS
PUBLIC	?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z ; CvMilitaryAI::SetTurnStrategyAdopted
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z PROC ; CvMilitaryAI::SetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 464  : 	if(m_paiTurnStrategyAdopted[(int) eStrategy] != iValue)

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _iValue$[esp-4]
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1@SetTurnStr

; 465  : 	{
; 466  : 		m_paiTurnStrategyAdopted[(int) eStrategy] = iValue;

	mov	DWORD PTR [eax], ecx
$LN1@SetTurnStr:

; 467  : 	}
; 468  : }

	ret	8
?SetTurnStrategyAdopted@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@H@Z ENDP ; CvMilitaryAI::SetTurnStrategyAdopted
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetSneakAttackOperation
EXTRN	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z:PROC ; CvPlayer::getAIOperation
EXTRN	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::haveAIOperationOfType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
;	COMDAT ?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iOperationID$ = 8					; size = 4
_eEnemy$ = 8						; size = 4
?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetSneakAttackOperation, COMDAT
; _this$ = ecx

; 752  : {

	push	esi
	push	edi

; 753  : 	int iOperationID;
; 754  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_SNEAK_CITY_ATTACK, &iOperationID, eEnemy);

	mov	edi, DWORD PTR _eEnemy$[esp+4]
	push	0
	push	edi
	lea	eax, DWORD PTR _iOperationID$[esp+12]
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	6
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 755  : 
; 756  : 	if(bHasOperationUnderway)

	test	al, al
	je	SHORT $LN3@GetSneakAt

; 757  : 	{
; 758  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	edi
	pop	esi

; 771  : }

	ret	4
$LN3@GetSneakAt:

; 759  : 	}
; 760  : 	else
; 761  : 	{
; 762  : 		bool bHasOperationOfType = m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_SNEAK_ATTACK, &iOperationID, eEnemy);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	edi
	lea	edx, DWORD PTR _iOperationID$[esp+12]
	push	edx
	push	14					; 0000000eH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 763  : 
; 764  : 		if(bHasOperationOfType)

	test	al, al
	je	SHORT $LN1@GetSneakAt

; 765  : 		{
; 766  : 			return m_pPlayer->getAIOperation(iOperationID);

	mov	eax, DWORD PTR _iOperationID$[esp+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	edi
	pop	esi

; 771  : }

	ret	4
$LN1@GetSneakAt:
	pop	edi

; 767  : 		}
; 768  : 	}
; 769  : 
; 770  : 	return NULL;

	xor	eax, eax
	pop	esi

; 771  : }

	ret	4
?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetSneakAttackOperation
_TEXT	ENDS
PUBLIC	?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetShowOfForceOperation
; Function compile flags: /Ogtpy
;	COMDAT ?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iOperationID$ = 8					; size = 4
_eEnemy$ = 8						; size = 4
?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetShowOfForceOperation, COMDAT
; _this$ = ecx

; 776  : 	int iOperationID;
; 777  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_SMALL_CITY_ATTACK, &iOperationID, eEnemy);

	mov	eax, DWORD PTR _eEnemy$[esp-4]
	push	esi
	push	0
	mov	esi, ecx
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	7
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 778  : 
; 779  : 	if(bHasOperationUnderway)

	test	al, al
	je	SHORT $LN1@GetShowOfF

; 780  : 	{
; 781  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	edx, DWORD PTR _iOperationID$[esp]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	esi

; 785  : }

	ret	4
$LN1@GetShowOfF:

; 782  : 	}
; 783  : 
; 784  : 	return NULL;

	xor	eax, eax
	pop	esi

; 785  : }

	ret	4
?GetShowOfForceOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetShowOfForceOperation
_TEXT	ENDS
PUBLIC	?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetBasicAttackOperation
; Function compile flags: /Ogtpy
;	COMDAT ?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iOperationID$ = 8					; size = 4
_eEnemy$ = 8						; size = 4
?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetBasicAttackOperation, COMDAT
; _this$ = ecx

; 789  : {

	push	esi
	push	edi

; 790  : 	int iOperationID;
; 791  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID, eEnemy);

	mov	edi, DWORD PTR _eEnemy$[esp+4]
	push	0
	push	edi
	lea	eax, DWORD PTR _iOperationID$[esp+12]
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	2
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 792  : 
; 793  : 	if(bHasOperationUnderway)

	test	al, al
	je	SHORT $LN3@GetBasicAt

; 794  : 	{
; 795  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	edi
	pop	esi

; 808  : }

	ret	4
$LN3@GetBasicAt:

; 796  : 	}
; 797  : 	else
; 798  : 	{
; 799  : 		bool bHasOperationOfType = m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID, eEnemy);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	edi
	lea	edx, DWORD PTR _iOperationID$[esp+12]
	push	edx
	push	13					; 0000000dH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 800  : 
; 801  : 		if(bHasOperationOfType)

	test	al, al
	je	SHORT $LN1@GetBasicAt

; 802  : 		{
; 803  : 			return m_pPlayer->getAIOperation(iOperationID);

	mov	eax, DWORD PTR _iOperationID$[esp+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	edi
	pop	esi

; 808  : }

	ret	4
$LN1@GetBasicAt:
	pop	edi

; 804  : 		}
; 805  : 	}
; 806  : 
; 807  : 	return NULL;

	xor	eax, eax
	pop	esi

; 808  : }

	ret	4
?GetBasicAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetBasicAttackOperation
_TEXT	ENDS
PUBLIC	?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetCityStateAttackOperation
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iOperationID$ = 8					; size = 4
_eEnemy$ = 8						; size = 4
?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetCityStateAttackOperation, COMDAT
; _this$ = ecx

; 812  : {

	push	esi
	push	edi

; 813  : 	int iOperationID;
; 814  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_STATE_ATTACK, &iOperationID, eEnemy);

	mov	edi, DWORD PTR _eEnemy$[esp+4]
	push	0
	push	edi
	lea	eax, DWORD PTR _iOperationID$[esp+12]
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	15					; 0000000fH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 815  : 
; 816  : 	if(bHasOperationUnderway)

	test	al, al
	je	SHORT $LN3@GetCitySta

; 817  : 	{
; 818  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	edi
	pop	esi

; 831  : }

	ret	4
$LN3@GetCitySta:

; 819  : 	}
; 820  : 	else
; 821  : 	{
; 822  : 		bool bHasOperationOfType = m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_STATE_NAVAL_ATTACK, &iOperationID, eEnemy);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	edi
	lea	edx, DWORD PTR _iOperationID$[esp+12]
	push	edx
	push	16					; 00000010H
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 823  : 
; 824  : 		if(bHasOperationOfType)

	test	al, al
	je	SHORT $LN1@GetCitySta

; 825  : 		{
; 826  : 			return m_pPlayer->getAIOperation(iOperationID);

	mov	eax, DWORD PTR _iOperationID$[esp+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	edi
	pop	esi

; 831  : }

	ret	4
$LN1@GetCitySta:
	pop	edi

; 827  : 		}
; 828  : 	}
; 829  : 
; 830  : 	return NULL;

	xor	eax, eax
	pop	esi

; 831  : }

	ret	4
?GetCityStateAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetCityStateAttackOperation
_TEXT	ENDS
PUBLIC	?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetPureNavalAttackOperation
; Function compile flags: /Ogtpy
;	COMDAT ?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iOperationID$ = 8					; size = 4
_eEnemy$ = 8						; size = 4
?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetPureNavalAttackOperation, COMDAT
; _this$ = ecx

; 836  : 	int iOperationID;
; 837  : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, &iOperationID, eEnemy);

	mov	eax, DWORD PTR _eEnemy$[esp-4]
	push	esi
	push	0
	mov	esi, ecx
	push	eax
	lea	ecx, DWORD PTR _iOperationID$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	18					; 00000012H
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 838  : 
; 839  : 	if(bHasOperationUnderway)

	test	al, al
	je	SHORT $LN1@GetPureNav

; 840  : 	{
; 841  : 		return m_pPlayer->getAIOperation(iOperationID);

	mov	edx, DWORD PTR _iOperationID$[esp]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	pop	esi

; 845  : }

	ret	4
$LN1@GetPureNav:

; 842  : 	}
; 843  : 
; 844  : 	return NULL;

	xor	eax, eax
	pop	esi

; 845  : }

	ret	4
?GetPureNavalAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetPureNavalAttackOperation
_TEXT	ENDS
PUBLIC	?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize
; Function compile flags: /Ogtpy
;	COMDAT ?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ
_TEXT	SEGMENT
?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ PROC ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize, COMDAT
; _this$ = ecx

; 1698 : {

	push	esi

; 1699 : 	if(m_iRecommendedMilitarySize <= 0)

	mov	esi, DWORD PTR [ecx+96]
	test	esi, esi
	jg	SHORT $LN2@GetPercent

; 1700 : 	{
; 1701 : 		return 100;

	mov	eax, 100				; 00000064H
	pop	esi

; 1706 : 	}
; 1707 : }

	ret	0
$LN2@GetPercent:

; 1702 : 	}
; 1703 : 	else
; 1704 : 	{
; 1705 : 		return m_iNumLandUnits * 100 / m_iRecommendedMilitarySize;

	mov	eax, DWORD PTR [ecx+52]
	imul	eax, 100				; 00000064H
	cdq
	idiv	esi
	pop	esi

; 1706 : 	}
; 1707 : }

	ret	0
?GetPercentOfRecommendedMilitarySize@CvMilitaryAI@@QBEHXZ ENDP ; CvMilitaryAI::GetPercentOfRecommendedMilitarySize
_TEXT	ENDS
PUBLIC	?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::MakeEmergencyPurchases
EXTRN	?getNextAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ:PROC ; CvPlayer::getNextAIOperation
EXTRN	?BuyFinalUnit@CvAIOperation@@QAE_NXZ:PROC	; CvAIOperation::BuyFinalUnit
EXTRN	?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ:PROC ; CvAIOperation::HasOneMoreSlotToFill
EXTRN	?getFirstAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ:PROC ; CvPlayer::getFirstAIOperation
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ PROC	; CvMilitaryAI::MakeEmergencyPurchases, COMDAT
; _this$ = ecx

; 3279 : {

	push	edi

; 3280 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("MakeEmergencyPurchases, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3281 : 
; 3282 : 	CvAIOperation* nextOp;
; 3283 : 
; 3284 : 	// Are we winning all the wars we are in?
; 3285 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	mov	edi, ecx
	push	OFFSET $SG227912
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3286 : 	if(!IsUsingStrategy(eStrategyAtWar) || m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, DWORD PTR [edi+12]
	cmp	BYTE PTR [eax+ecx], 0
	je	SHORT $LN5@MakeEmerge@2
	mov	ecx, DWORD PTR [edi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	SHORT $LN12@MakeEmerge@2
$LN5@MakeEmerge@2:

; 3287 : 	{
; 3288 : 		// Is there an operation waiting for one more unit?
; 3289 : 		nextOp = m_pPlayer->getFirstAIOperation();

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?getFirstAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getFirstAIOperation
	mov	esi, eax

; 3290 : 		while(nextOp != NULL)

	test	esi, esi
	je	SHORT $LN14@MakeEmerge@2
	npad	2
$LL4@MakeEmerge@2:

; 3291 : 		{
; 3292 : 			if(nextOp->HasOneMoreSlotToFill())

	mov	ecx, esi
	call	?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ ; CvAIOperation::HasOneMoreSlotToFill
	test	al, al
	je	SHORT $LN1@MakeEmerge@2

; 3293 : 			{
; 3294 : 				// Can we buy a unit to fill that slot?
; 3295 : 				if(nextOp->BuyFinalUnit())

	mov	ecx, esi
	call	?BuyFinalUnit@CvAIOperation@@QAE_NXZ	; CvAIOperation::BuyFinalUnit
	test	al, al
	jne	SHORT $LN14@MakeEmerge@2
$LN1@MakeEmerge@2:

; 3296 : 				{
; 3297 : 					break;
; 3298 : 				}
; 3299 : 			}
; 3300 : 			nextOp = m_pPlayer->getNextAIOperation();

	mov	ecx, DWORD PTR [edi]
	call	?getNextAIOperation@CvPlayer@@QAEPAVCvAIOperation@@XZ ; CvPlayer::getNextAIOperation
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL4@MakeEmerge@2
$LN14@MakeEmerge@2:
	pop	esi
$LN12@MakeEmerge@2:
	pop	edi

; 3301 : 		}
; 3302 : 	}
; 3303 : }

	ret	0
?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ ENDP	; CvMilitaryAI::MakeEmergencyPurchases
_TEXT	ENDS
PUBLIC	?RequestImprovements@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::RequestImprovements
; Function compile flags: /Ogtpy
;	COMDAT ?RequestImprovements@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
?RequestImprovements@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::RequestImprovements, COMDAT
; _this$ = ecx

; 3393 : 
; 3394 : }

	ret	0
?RequestImprovements@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::RequestImprovements
_TEXT	ENDS
PUBLIC	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
EXTRN	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z:PROC ; CvPlayer::canTrain
EXTRN	?GetPower@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetPower
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getNumUnitInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumUnitInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_eDomain$ = 8						; size = 4
?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z PROC ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit, COMDAT
; _this$ = ecx

; 3915 : {

	push	ebx
	push	ebp
	mov	ebp, ecx
	push	edi

; 3916 : 	int iRtnValue = 0;
; 3917 : #ifdef AUI_WARNING_FIXES
; 3918 : 	for (uint iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 3919 : #else
; 3920 : 	for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	xor	edi, edi
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	test	eax, eax
	jle	SHORT $LN11@GetPowerOf
	push	esi
	npad	8
$LL12@GetPowerOf:

; 3921 : #endif
; 3922 : 	{
; 3923 : 		const UnitTypes eUnit = static_cast<UnitTypes>(iI);
; 3924 : 		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	esi, eax

; 3925 : 		if(pkUnitEntry != NULL && pkUnitEntry->GetDomainType() == eDomain)

	test	esi, esi
	je	SHORT $LN5@GetPowerOf
	mov	ecx, esi
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	cmp	eax, DWORD PTR _eDomain$[esp+12]
	jne	SHORT $LN5@GetPowerOf

; 3926 : 		{
; 3927 : 			int iThisPower = pkUnitEntry->GetPower();		// Test the power first, it is much less costly than testing canTrain

	mov	ecx, esi
	call	?GetPower@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPower
	mov	esi, eax

; 3928 : 			if(iThisPower > iRtnValue)

	cmp	esi, ebx
	jle	SHORT $LN5@GetPowerOf

; 3929 : 			{
; 3930 : 				if(m_pPlayer->canTrain(eUnit, false /*bContinue*/, false /*bTestVisible*/, true /*bIgnoreCost*/))

	mov	ecx, DWORD PTR [ebp]
	push	0
	push	0
	push	1
	push	0
	push	0
	push	edi
	call	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvPlayer::canTrain
	test	al, al
	je	SHORT $LN5@GetPowerOf

; 3931 : 				{
; 3932 : 					iRtnValue = iThisPower;

	mov	ebx, esi
$LN5@GetPowerOf:

; 3916 : 	int iRtnValue = 0;
; 3917 : #ifdef AUI_WARNING_FIXES
; 3918 : 	for (uint iI = 0; iI < GC.getNumUnitInfos(); iI++)
; 3919 : #else
; 3920 : 	for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	cmp	edi, eax
	jl	SHORT $LL12@GetPowerOf
	pop	esi
$LN11@GetPowerOf:
	pop	edi
	pop	ebp

; 3933 : 				}
; 3934 : 			}
; 3935 : 		}
; 3936 : 	}
; 3937 : 
; 3938 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 3939 : }

	ret	4
?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ENDP ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z:PROC ; CvEconomicAI::IsUsingStrategy
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits, COMDAT

; 4336 : {

	push	ebx
	push	esi
	push	edi

; 4337 : 	// Are we running at a deficit?
; 4338 : 	EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");

	push	0
	push	OFFSET $SG228445
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4339 : 	bool bInDeficit = pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	edi, DWORD PTR _pPlayer$[esp+8]
	push	eax
	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy

; 4340 : 
; 4341 : 	// Are we running anything other than the Conquest Grand Strategy?
; 4342 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET $SG228449
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	bl, al
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4343 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	esi, -1
	je	SHORT $LN2@IsTestStra

; 4344 : 	{
; 4345 : 		if(bInDeficit || pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() != eConquestGrandStrategy || pPlayer->GetMilitaryAI()->GetPercentOfRecommendedMilitarySize() > 125)

	test	bl, bl
	jne	SHORT $LN3@IsTestStra
	mov	ecx, edi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, esi
	jne	SHORT $LN3@IsTestStra
	mov	ecx, edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, DWORD PTR [eax+96]
	test	ecx, ecx
	jle	SHORT $LN2@IsTestStra
	mov	eax, DWORD PTR [eax+52]
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
	cmp	eax, 125				; 0000007dH

; 4350 : 			}
; 4351 : 		}
; 4352 : 		else
; 4353 : 		{
; 4354 : 			return false;

	jle	SHORT $LN2@IsTestStra
$LN3@IsTestStra:

; 4346 : 		{
; 4347 : 			if(pPlayer->GetMilitaryAI()->GetLandDefenseState() == DEFENSE_STATE_ENOUGH)

	mov	ecx, edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+112], 0
	jne	SHORT $LN2@IsTestStra
	pop	edi
	pop	esi

; 4348 : 			{
; 4349 : 				return true;

	mov	al, 1
	pop	ebx

; 4359 : }

	ret	0
$LN2@IsTestStra:
	pop	edi
	pop	esi

; 4355 : 		}
; 4356 : 	}
; 4357 : 
; 4358 : 	return false;

	xor	al, al
	pop	ebx

; 4359 : }

	ret	0
?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EmpireDefense
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EmpireDefense, COMDAT

; 4364 : 	if(pPlayer->GetMilitaryAI()->GetLandDefenseState() == DEFENSE_STATE_NEEDED)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+112], 2
	sete	al

; 4365 : 	{
; 4366 : 		return true;
; 4367 : 	}
; 4368 : 
; 4369 : 	return false;
; 4370 : }

	ret	0
?IsTestStrategy_EmpireDefense@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EmpireDefense
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical, COMDAT

; 4375 : 	if(pPlayer->GetMilitaryAI()->GetLandDefenseState() == DEFENSE_STATE_CRITICAL)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+112], 3
	sete	al

; 4376 : 	{
; 4377 : 		return true;
; 4378 : 	}
; 4379 : 
; 4380 : 	return false;
; 4381 : }

	ret	0
?IsTestStrategy_EmpireDefenseCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits, COMDAT

; 4386 : 	if(pPlayer->GetMilitaryAI()->GetNavalDefenseState() == DEFENSE_STATE_ENOUGH)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+116], 0
	sete	al

; 4387 : 	{
; 4388 : 		return true;
; 4389 : 	}
; 4390 : 
; 4391 : 	return false;
; 4392 : }

	ret	0
?IsTestStrategy_EnoughNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits, COMDAT

; 4397 : 	if(pPlayer->GetMilitaryAI()->GetNavalDefenseState() == DEFENSE_STATE_NEEDED)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+116], 2
	sete	al

; 4398 : 	{
; 4399 : 		return true;
; 4400 : 	}
; 4401 : 
; 4402 : 	return false;
; 4403 : }

	ret	0
?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical, COMDAT

; 4408 : 	if(pPlayer->GetMilitaryAI()->GetNavalDefenseState() == DEFENSE_STATE_CRITICAL)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+116], 3
	sete	al

; 4409 : 	{
; 4410 : 		return true;
; 4411 : 	}
; 4412 : 
; 4413 : 	return false;
; 4414 : }

	ret	0
?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical
_TEXT	ENDS
PUBLIC	?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ ; MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ
_TEXT	SEGMENT
?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ PROC ; MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense, COMDAT

; 4494 : 	return true;

	mov	al, 1

; 4495 : }

	ret	0
?IsTestStrategy_MinorCivGeneralDefense@MilitaryAIHelpers@@YA_NXZ ENDP ; MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense
_TEXT	ENDS
PUBLIC	?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated
EXTRN	?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ:PROC ; CvMinorCivAI::GetStatus
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated, COMDAT

; 4500 : 	if(pPlayer->GetMinorCivAI()->GetStatus() == MINOR_CIV_STATUS_ELEVATED)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ ; CvMinorCivAI::GetStatus
	cmp	eax, 1
	sete	al

; 4501 : 	{
; 4502 : 		return true;
; 4503 : 	}
; 4504 : 
; 4505 : 	return false;
; 4506 : }

	ret	0
?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated
_TEXT	ENDS
PUBLIC	?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical, COMDAT

; 4511 : 	if(pPlayer->GetMinorCivAI()->GetStatus() == MINOR_CIV_STATUS_CRITICAL)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetStatus@CvMinorCivAI@@QBE?AW4MinorCivStatusTypes@@XZ ; CvMinorCivAI::GetStatus
	cmp	eax, 2
	sete	al

; 4512 : 	{
; 4513 : 		return true;
; 4514 : 	}
; 4515 : 
; 4516 : 	return false;
; 4517 : }

	ret	0
?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical
_TEXT	ENDS
PUBLIC	?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WinningWars
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_WinningWars, COMDAT

; 4590 : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	sete	al

; 4591 : 	{
; 4592 : 		return true;
; 4593 : 	}
; 4594 : 	return false;
; 4595 : }

	ret	0
?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_WinningWars
_TEXT	ENDS
PUBLIC	?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_LosingWars
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_LosingWars, COMDAT

; 4600 : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	sete	al

; 4601 : 	{
; 4602 : 		return true;
; 4603 : 	}
; 4604 : 	return false;
; 4605 : }

	ret	0
?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_LosingWars
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack, COMDAT

; 4625 : {

	push	esi

; 4626 : 	MilitaryAIStrategyTypes eStrategyWarMob = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_WAR_MOBILIZATION");

	push	0
	push	OFFSET $SG228596
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4627 : 	if(eStrategyWarMob != NO_MILITARYAISTRATEGY)

	cmp	esi, -1
	je	SHORT $LN1@IsTestStra@2

; 4628 : 	{
; 4629 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyWarMob))

	mov	ecx, DWORD PTR _pPlayer$[esp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	eax, DWORD PTR [eax+12]
	cmp	BYTE PTR [esi+eax], 0
	je	SHORT $LN1@IsTestStra@2

; 4630 : 		{
; 4631 : 			return true;

	mov	al, 1
	pop	esi

; 4635 : }

	ret	0
$LN1@IsTestStra@2:

; 4632 : 		}
; 4633 : 	}
; 4634 : 	return false;

	xor	al, al
	pop	esi

; 4635 : }

	ret	0
?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::getSpecialUnitType
EXTRN	?domainCargo@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::domainCargo
EXTRN	?specialCargo@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::specialCargo
EXTRN	?cargoSpace@CvUnit@@QBEHXZ:PROC			; CvUnit::cargoSpace
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iNumTotalCargoSpace$ = -8				; size = 4
_iLoop$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers, COMDAT

; 4743 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4744 : 	int iNumLoadableAirUnits = 0;

	xor	ebp, ebp

; 4745 : 	int iNumTotalCargoSpace = 0;
; 4746 : 	CvUnit* pLoopUnit;
; 4747 : 	int iLoop;
; 4748 : 	SpecialUnitTypes eSpecialUnitPlane = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_FIGHTER");

	push	ebp
	push	OFFSET $SG228698
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iNumTotalCargoSpace$[esp+32], ebp
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4749 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	mov	ebx, DWORD PTR _pPlayer$[esp+20]
	mov	edi, eax
	push	ebp
	lea	eax, DWORD PTR _iLoop$[esp+28]
	push	eax
	mov	ecx, ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN2@IsTestStra@3
	npad	6
$LL13@IsTestStra@3:

; 4750 : 	{
; 4751 : 		// Don't count civilians or exploration units
; 4752 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN12@IsTestStra@3
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	SHORT $LN12@IsTestStra@3

; 4753 : 		{
; 4754 : 			if(pLoopUnit->cargoSpace() > 0)

	mov	ecx, esi
	call	?cargoSpace@CvUnit@@QBEHXZ		; CvUnit::cargoSpace

; 4755 : 			{
; 4756 : 				if(pLoopUnit->specialCargo() != NO_SPECIALUNIT)

	mov	ecx, esi
	test	eax, eax
	jle	SHORT $LN9@IsTestStra@3
	call	?specialCargo@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::specialCargo
	cmp	eax, -1
	je	SHORT $LN7@IsTestStra@3

; 4757 : 				{
; 4758 : 					if(pLoopUnit->specialCargo() != eSpecialUnitPlane)

	mov	ecx, esi
	call	?specialCargo@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::specialCargo
	cmp	eax, edi
	jne	SHORT $LN12@IsTestStra@3
$LN7@IsTestStra@3:

; 4759 : 					{
; 4760 : 						continue;
; 4761 : 					}
; 4762 : 				}
; 4763 : 
; 4764 : 				if (pLoopUnit->domainCargo() != NO_DOMAIN)

	mov	ecx, esi
	call	?domainCargo@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::domainCargo
	cmp	eax, -1
	je	SHORT $LN5@IsTestStra@3

; 4765 : 				{
; 4766 : 					if (pLoopUnit->domainCargo() != DOMAIN_AIR)

	mov	ecx, esi
	call	?domainCargo@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::domainCargo
	cmp	eax, 1
	jne	SHORT $LN12@IsTestStra@3
$LN5@IsTestStra@3:

; 4767 : 					{
; 4768 : 						continue;
; 4769 : 					}
; 4770 : 				}
; 4771 : 				iNumTotalCargoSpace += pLoopUnit->cargoSpace();

	mov	ecx, esi
	call	?cargoSpace@CvUnit@@QBEHXZ		; CvUnit::cargoSpace
	add	DWORD PTR _iNumTotalCargoSpace$[esp+24], eax
	jmp	SHORT $LN12@IsTestStra@3
$LN9@IsTestStra@3:

; 4772 : 			}
; 4773 : 			else if (pLoopUnit->getSpecialUnitType() == eSpecialUnitPlane)

	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, edi
	jne	SHORT $LN12@IsTestStra@3

; 4774 : 			{
; 4775 : 				iNumLoadableAirUnits += 1;

	inc	ebp
$LN12@IsTestStra@3:

; 4749 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+28]
	push	ecx
	mov	ecx, ebx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL13@IsTestStra@3

; 4776 : 			}
; 4777 : 		}
; 4778 : 	}
; 4779 : 
; 4780 : 	if (iNumLoadableAirUnits > iNumTotalCargoSpace)

	cmp	ebp, DWORD PTR _iNumTotalCargoSpace$[esp+24]
	jle	SHORT $LN2@IsTestStra@3
	pop	edi
	pop	esi
	pop	ebp

; 4781 : 	{
; 4782 : 		return true;

	mov	al, 1
	pop	ebx

; 4787 : 	}
; 4788 : }

	add	esp, 8
	ret	0
$LN2@IsTestStra@3:
	pop	edi
	pop	esi
	pop	ebp

; 4783 : 	}
; 4784 : 	else
; 4785 : 	{
; 4786 : 		return false;

	xor	al, al
	pop	ebx

; 4787 : 	}
; 4788 : }

	add	esp, 8
	ret	0
?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@_N@@QAE@HPA_N@Z		; ArrayWrapper<bool>::ArrayWrapper<bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@_N@@QAE@HPA_N@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z PROC			; ArrayWrapper<bool>::ArrayWrapper<bool>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z ENDP			; ArrayWrapper<bool>::ArrayWrapper<bool>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z ; BaseVector<CvCity *,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z PROC ; BaseVector<CvCity *,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvCity@@$0A@@@QAEAAPAVCvCity@@I@Z ENDP ; BaseVector<CvCity *,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ	; BaseVector<CvCity *,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ PROC		; BaseVector<CvCity *,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvCity@@$0A@@@QBEIXZ ENDP		; BaseVector<CvCity *,0>::size
_TEXT	ENDS
PUBLIC	?erase@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEXPAVCvFormationSlotEntry@@@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEXPAVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
_it$ = 8						; size = 4
?erase@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEXPAVCvFormationSlotEntry@@@Z PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::erase, COMDAT
; _this$ = ecx

; 703  : 		m_bIsResized = false;
; 704  : 
; 705  : 		unsigned int uIndex = it - m_pData;

	mov	eax, DWORD PTR _it$[esp-4]
	sub	eax, DWORD PTR [ecx]
	push	esi
	sar	eax, 4

; 706  : 
; 707  :         for(unsigned int i = uIndex; i + 1< m_uiCurrSize; ++i)

	lea	esi, DWORD PTR [eax+1]
	mov	BYTE PTR [ecx+172], 0
	cmp	esi, DWORD PTR [ecx+4]
	jae	SHORT $LN8@erase
	shl	eax, 4
	mov	edx, eax
	push	edi
	npad	1
$LL3@erase:

; 708  :         {
; 709  :             m_pData[i] = m_pData[i+1];

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edx+16]
	add	eax, edx
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+4], edi
	mov	edi, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+8], edi
	mov	edi, DWORD PTR [eax+28]
	inc	esi
	mov	DWORD PTR [eax+12], edi
	add	edx, 16					; 00000010H
	cmp	esi, DWORD PTR [ecx+4]
	jb	SHORT $LL3@erase
	pop	edi
$LN8@erase:

; 710  :         }
; 711  : 		
; 712  : 		--m_uiCurrSize;

	dec	DWORD PTR [ecx+4]
	pop	esi

; 713  : 	}

	ret	4
?erase@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEXPAVCvFormationSlotEntry@@@Z ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::erase
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEAAVCvFormationSlotEntry@@I@Z ; BaseVector<CvFormationSlotEntry,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEAAVCvFormationSlotEntry@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEAAVCvFormationSlotEntry@@I@Z PROC ; BaseVector<CvFormationSlotEntry,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEAAVCvFormationSlotEntry@@I@Z ENDP ; BaseVector<CvFormationSlotEntry,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QBEIXZ ; BaseVector<CvFormationSlotEntry,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QBEIXZ PROC ; BaseVector<CvFormationSlotEntry,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QBEIXZ ENDP ; BaseVector<CvFormationSlotEntry,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ ; BaseVector<CvFormationSlotEntry,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ PROC ; BaseVector<CvFormationSlotEntry,0>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ ENDP ; BaseVector<CvFormationSlotEntry,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ ; BaseVector<CvFormationSlotEntry,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ PROC ; BaseVector<CvFormationSlotEntry,0>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAEPAVCvFormationSlotEntry@@XZ ENDP ; BaseVector<CvFormationSlotEntry,0>::end
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@XZ ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocator<CvMilitaryAIStrategyXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@XZ PROC ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocator<CvMilitaryAIStrategyXMLEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocator<CvMilitaryAIStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvMilitaryAIStrategyXMLEntry@@XZ ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvMilitaryAIStrategyXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvMilitaryAIStrategyXMLEntry@@XZ PROC ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvMilitaryAIStrategyXMLEntry@@XZ ENDP ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], cl
	mov	DWORD PTR [eax+24], ecx

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@ABU01@@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ PROC		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvCity@@$0A@@@QAE@XZ ENDP		; BaseVector<CvCity *,0>::~BaseVector<CvCity *,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ		; BaseVector<CvCity *,0>::BaseVector<CvCity *,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ PROC		; BaseVector<CvCity *,0>::BaseVector<CvCity *,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvCity@@$0A@@@IAE@XZ ENDP		; BaseVector<CvCity *,0>::BaseVector<CvCity *,0>
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEPAVCvFormationSlotEntry@@I@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEPAVCvFormationSlotEntry@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEPAVCvFormationSlotEntry@@I@Z PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 10					; 0000000aH
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	mov	eax, edi
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 10			; 0000000aH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEPAVCvFormationSlotEntry@@I@Z ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ PROC ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvFormationSlotEntry@@$0A@@@QAE@XZ ENDP ; BaseVector<CvFormationSlotEntry,0>::~BaseVector<CvFormationSlotEntry,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAE@XZ ; BaseVector<CvFormationSlotEntry,0>::BaseVector<CvFormationSlotEntry,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAE@XZ PROC ; BaseVector<CvFormationSlotEntry,0>::BaseVector<CvFormationSlotEntry,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAE@XZ ENDP ; BaseVector<CvFormationSlotEntry,0>::BaseVector<CvFormationSlotEntry,0>
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231131 = -80						; size = 28
$T231130 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231131[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231130[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231131[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231130[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231130[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231130[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231130[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231131[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231130[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocator<CvMilitaryAIStrategyXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocator<CvMilitaryAIStrategyXMLEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocator<CvMilitaryAIStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEXPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEXPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEXPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z PROC ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEXPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ENDP ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z PROC ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z ENDP ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 640				; 00000280H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 640			; 00000280H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ
_TEXT	SEGMENT
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis, COMDAT
; _this$ = ecx

; 701  : 	inline GenericClass *GetClosureThis() const { return m_pthis; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
_TEXT	ENDS
PUBLIC	?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ
_TEXT	SEGMENT
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr, COMDAT
; _this$ = ecx

; 702  : 	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z ; BaseVector<CvCity *,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z PROC ; BaseVector<CvCity *,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvCity@@$0A@@@IAEXPAPAVCvCity@@I@Z ENDP ; BaseVector<CvCity *,0>::Destroy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z ; BaseVector<CvFormationSlotEntry,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z PROC ; BaseVector<CvFormationSlotEntry,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvFormationSlotEntry@@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z ENDP ; BaseVector<CvFormationSlotEntry,0>::Destroy
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAPAXIIII@Z ; BaseVector<CvCity *,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAPAXIIII@Z PROC ; BaseVector<CvCity *,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAPAXIIII@Z ENDP ; BaseVector<CvCity *,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAXPAX@Z ; BaseVector<CvCity *,0>::FDefaultFastVectorAllocator::FreeAligned
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAXPAX@Z PROC ; BaseVector<CvCity *,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@SAXPAX@Z ENDP ; BaseVector<CvCity *,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QBEIXZ ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QBEIXZ PROC ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntry@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntry@@@Z ; SAFE_DELETE<CvMilitaryAIStrategyXMLEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntry@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntry@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntry@@@Z PROC ; SAFE_DELETE<CvMilitaryAIStrategyXMLEntry>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvMilitaryAIStrategyXMLEntry@@@@YAXAAPAVCvMilitaryAIStrategyXMLEntry@@@Z ENDP ; SAFE_DELETE<CvMilitaryAIStrategyXMLEntry>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T231238 = -12						; size = 12
$T231242 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231242[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231238[esp+16]
	mov	DWORD PTR $T231242[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231238[esp+16]
	push	ecx
	mov	DWORD PTR $T231238[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ		; ArrayWrapper<bool>::getArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ PROC		; ArrayWrapper<bool>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ ENDP		; ArrayWrapper<bool>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ		; ArrayWrapper<bool>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ PROC		; ArrayWrapper<bool>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ ENDP		; ArrayWrapper<bool>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@_N@@QBEHXZ		; ArrayWrapper<bool>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@_N@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@_N@@QBEHXZ PROC		; ArrayWrapper<bool>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@_N@@QBEHXZ ENDP		; ArrayWrapper<bool>::getCount
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QBEPBHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QBEPBHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QBEPBHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMilitaryAIStrategyXMLEntry@@0@Z ; std::_Iter_random<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMilitaryAIStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMilitaryAIStrategyXMLEntry@@0@Z PROC ; std::_Iter_random<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvMilitaryAIStrategyXMLEntry@@0@Z ENDP ; std::_Iter_random<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z ; std::_Ptr_cat<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z PROC ; std::_Ptr_cat<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z ENDP ; std::_Ptr_cat<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z PROC ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>, COMDAT

; 153  : 	return input;

	mov	eax, DWORD PTR _input$[esp-4]

; 154  : }

	ret	0
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ENDP ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBE_NABU01@@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+24]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::pair<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>::pair<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::pair<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>::pair<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::pair<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>::pair<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
_bound_func$ = 16					; size = 4
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z PROC ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>, COMDAT

; 306  : 			GenericMemFuncType &bound_func) {
; 307  : #if defined __DMC__  
; 308  : 		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
; 309  : 		// even though the standard says you can. The 32-bit compiler lets you
; 310  : 		// static_cast through an int, but the DOS compiler doesn't.
; 311  : 		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
; 312  : #else 
; 313  :         bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);

	mov	eax, DWORD PTR _bound_func$[esp-4]
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax], ecx

; 314  : #endif
; 315  :         return reinterpret_cast<GenericClass *>(pthis);

	mov	eax, DWORD PTR _pthis$[esp-4]

; 316  : 	}

	ret	0
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ENDP ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; std::_Dist_type<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__Tmp$229951 = -28					; size = 28
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Right$[esp-4]
	sub	esp, 28					; 0000001cH
	push	edi
	mov	edi, DWORD PTR __Left$[esp+28]
	cmp	edi, eax
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$229951[esp+32], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __Tmp$229951[esp+40], ecx
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __Tmp$229951[esp+48], ecx
	mov	ecx, DWORD PTR [edi+24]
	push	esi
	mov	DWORD PTR __Tmp$229951[esp+40], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$229951[esp+60], ecx
	mov	DWORD PTR __Tmp$229951[esp+48], edx
	mov	edx, DWORD PTR [edi+20]

; 21   : 
; 22   : 		_Left = _Right;

	mov	ecx, 7
	mov	esi, eax
	rep movsd

; 23   : 		_Right = _Tmp;

	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$229951[esp+36]
	mov	edi, eax
	mov	DWORD PTR __Tmp$229951[esp+56], edx
	rep movsd
	pop	esi
$LN1@swap:
	pop	edi

; 24   : 		}
; 25   : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 28
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __First$[esp]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	ebp
	mov	ebp, DWORD PTR __Top$[esp+4]
	sub	eax, edx
	push	esi
	sar	eax, 1
	cmp	ebp, ecx
	push	edi
	jge	SHORT $LN1@Push_heap
	npad	4
$LL3@Push_heap:
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	lea	esi, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR __Val$[esp+36]
	cmp	DWORD PTR [esi+24], edx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	lea	edi, DWORD PTR [ebx+edx*4]
	mov	ecx, 7
	rep movsd

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ebp, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	edi, DWORD PTR [ebx+eax*4]
	mov	ecx, 7
	lea	esi, DWORD PTR __Val$[esp+12]
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Iter_random<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN1@Copy_backw
	push	esi
	push	edi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	sub	edx, 28					; 0000001cH
	sub	eax, 28					; 0000001cH
	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL2@Copy_backw
	pop	edi
	pop	esi
$LN1@Copy_backw:
	pop	ebx

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?GetLength@CvString@@QBEHXZ			; CvString::GetLength
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetLength@CvString@@QBEHXZ
_TEXT	SEGMENT
?GetLength@CvString@@QBEHXZ PROC			; CvString::GetLength, COMDAT
; _this$ = ecx

; 46   : 	int GetLength() const { return (int) size(); }

	jmp	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
?GetLength@CvString@@QBEHXZ ENDP			; CvString::GetLength
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getAI_GOLD_PRIORITY_UNIT@CvGlobals@@QAEHXZ	; CvGlobals::getAI_GOLD_PRIORITY_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GOLD_PRIORITY_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GOLD_PRIORITY_UNIT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_GOLD_PRIORITY_UNIT, COMDAT
; _this$ = ecx

; 1157 : 		return m_iAI_GOLD_PRIORITY_UNIT;

	mov	eax, DWORD PTR [ecx+2092]

; 1158 : 	}

	ret	0
?getAI_GOLD_PRIORITY_UNIT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_GOLD_PRIORITY_UNIT
_TEXT	ENDS
PUBLIC	?getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING, COMDAT
; _this$ = ecx

; 1161 : 		return m_iAI_GOLD_PRIORITY_DEFENSIVE_BUILDING;

	mov	eax, DWORD PTR [ecx+2096]

; 1162 : 	}

	ret	0
?getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_THREAT_WEIGHT_MINOR@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_MINOR
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_THREAT_WEIGHT_MINOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_THREAT_WEIGHT_MINOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_MINOR, COMDAT
; _this$ = ecx

; 1229 : 		return m_iAI_MILITARY_THREAT_WEIGHT_MINOR;

	mov	eax, DWORD PTR [ecx+2164]

; 1230 : 	}

	ret	0
?getAI_MILITARY_THREAT_WEIGHT_MINOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_MINOR
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_THREAT_WEIGHT_MAJOR@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_MAJOR
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_THREAT_WEIGHT_MAJOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_THREAT_WEIGHT_MAJOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_MAJOR, COMDAT
; _this$ = ecx

; 1233 : 		return m_iAI_MILITARY_THREAT_WEIGHT_MAJOR;

	mov	eax, DWORD PTR [ecx+2168]

; 1234 : 	}

	ret	0
?getAI_MILITARY_THREAT_WEIGHT_MAJOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_MAJOR
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_THREAT_WEIGHT_SEVERE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_SEVERE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_THREAT_WEIGHT_SEVERE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_THREAT_WEIGHT_SEVERE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_SEVERE, COMDAT
; _this$ = ecx

; 1237 : 		return m_iAI_MILITARY_THREAT_WEIGHT_SEVERE;

	mov	eax, DWORD PTR [ecx+2172]

; 1238 : 	}

	ret	0
?getAI_MILITARY_THREAT_WEIGHT_SEVERE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_SEVERE
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_THREAT_WEIGHT_CRITICAL@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_CRITICAL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_THREAT_WEIGHT_CRITICAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_THREAT_WEIGHT_CRITICAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_CRITICAL, COMDAT
; _this$ = ecx

; 1241 : 		return m_iAI_MILITARY_THREAT_WEIGHT_CRITICAL;

	mov	eax, DWORD PTR [ecx+2176]

; 1242 : 	}

	ret	0
?getAI_MILITARY_THREAT_WEIGHT_CRITICAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_THREAT_WEIGHT_CRITICAL
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS, COMDAT
; _this$ = ecx

; 1245 : 		return m_iAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS;

	mov	eax, DWORD PTR [ecx+2180]

; 1246 : 	}

	ret	0
?getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL, COMDAT
; _this$ = ecx

; 1253 : 		return m_iAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL;

	mov	eax, DWORD PTR [ecx+2188]

; 1254 : 	}

	ret	0
?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT, COMDAT
; _this$ = ecx

; 1257 : 		return m_iAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT;

	mov	eax, DWORD PTR [ecx+2192]

; 1258 : 	}

	ret	0
?getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_IGNORE_BAD_ODDS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_IGNORE_BAD_ODDS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_IGNORE_BAD_ODDS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_IGNORE_BAD_ODDS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_MILITARY_IGNORE_BAD_ODDS, COMDAT
; _this$ = ecx

; 1261 : 		return m_iAI_MILITARY_IGNORE_BAD_ODDS;

	mov	eax, DWORD PTR [ecx+2196]

; 1262 : 	}

	ret	0
?getAI_MILITARY_IGNORE_BAD_ODDS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_MILITARY_IGNORE_BAD_ODDS
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_RECAPTURING_OWN_CITY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_RECAPTURING_OWN_CITY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_RECAPTURING_OWN_CITY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_RECAPTURING_OWN_CITY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_RECAPTURING_OWN_CITY, COMDAT
; _this$ = ecx

; 1265 : 		return m_iAI_MILITARY_RECAPTURING_OWN_CITY;

	mov	eax, DWORD PTR [ecx+2200]

; 1266 : 	}

	ret	0
?getAI_MILITARY_RECAPTURING_OWN_CITY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_RECAPTURING_OWN_CITY
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL, COMDAT
; _this$ = ecx

; 1269 : 		return m_iAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL;

	mov	eax, DWORD PTR [ecx+2204]

; 1270 : 	}

	ret	0
?getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION, COMDAT
; _this$ = ecx

; 1501 : 		return m_iAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION;

	mov	eax, DWORD PTR [ecx+2436]

; 1502 : 	}

	ret	0
?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS, COMDAT
; _this$ = ecx

; 1517 : 		return m_iAI_TACTICAL_MAP_TEMP_ZONE_TURNS;

	mov	eax, DWORD PTR [ecx+2452]

; 1518 : 	}

	ret	0
?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS
_TEXT	ENDS
PUBLIC	?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ	; CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN
; Function compile flags: /Ogtpy
;	COMDAT ?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN, COMDAT
; _this$ = ecx

; 5952 : 		return m_iMIN_WATER_SIZE_FOR_OCEAN;

	mov	eax, DWORD PTR [ecx+6876]

; 5953 : 	}

	ret	0
?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN
_TEXT	ENDS
PUBLIC	?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ		; CvGlobals::getMAX_HIT_POINTS
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMAX_HIT_POINTS, COMDAT
; _this$ = ecx

; 6497 : 		return m_iMAX_HIT_POINTS;

	mov	eax, DWORD PTR [ecx+7368]

; 6498 : 	}

	ret	0
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMAX_HIT_POINTS
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY@CvGlobals@@QAEMXZ ; CvGlobals::getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY, COMDAT
; _this$ = ecx

; 7116 : 		return m_fAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY;

	fld	DWORD PTR [ecx+8104]

; 7117 : 	}

	ret	0
?getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_NAVAL_UNITS_PER_CITY@CvGlobals@@QAEMXZ ; CvGlobals::getAI_STRATEGY_NAVAL_UNITS_PER_CITY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_NAVAL_UNITS_PER_CITY@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_STRATEGY_NAVAL_UNITS_PER_CITY@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_STRATEGY_NAVAL_UNITS_PER_CITY, COMDAT
; _this$ = ecx

; 7120 : 		return m_fAI_STRATEGY_NAVAL_UNITS_PER_CITY;

	fld	DWORD PTR [ecx+8108]

; 7121 : 	}

	ret	0
?getAI_STRATEGY_NAVAL_UNITS_PER_CITY@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_STRATEGY_NAVAL_UNITS_PER_CITY
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT, COMDAT
; _this$ = ecx

; 7355 : 		return m_iBARBARIAN_CAMP_IMPROVEMENT;

	mov	eax, DWORD PTR [ecx+8548]

; 7356 : 	}

	ret	0
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7738 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8596]

; 7739 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetOperationState@CvAIOperation@@QAE?AW4AIOperationState@@XZ ; CvAIOperation::GetOperationState
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
;	COMDAT ?GetOperationState@CvAIOperation@@QAE?AW4AIOperationState@@XZ
_TEXT	SEGMENT
?GetOperationState@CvAIOperation@@QAE?AW4AIOperationState@@XZ PROC ; CvAIOperation::GetOperationState, COMDAT
; _this$ = ecx

; 148  : 	AIOperationState GetOperationState() {return m_eCurrentState;};

	mov	eax, DWORD PTR [ecx+56]
	ret	0
?GetOperationState@CvAIOperation@@QAE?AW4AIOperationState@@XZ ENDP ; CvAIOperation::GetOperationState
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ ; CvTreasury::GetExpensePerTurnUnitMaintenance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.h
;	COMDAT ?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ PROC ; CvTreasury::GetExpensePerTurnUnitMaintenance, COMDAT
; _this$ = ecx

; 91   : 		return m_iExpensePerTurnUnitMaintenance;

	mov	eax, DWORD PTR [ecx+16]

; 92   : 	}

	ret	0
?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ ENDP ; CvTreasury::GetExpensePerTurnUnitMaintenance
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetLandBarbarianConversionPercent
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetLandBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 503  : 		return m_iLandBarbarianConversionPercent;

	mov	eax, DWORD PTR [ecx+100]

; 504  : 	};

	ret	0
?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetLandBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ		; CvPlayerTraits::IsNoAnnexing
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ PROC		; CvPlayerTraits::IsNoAnnexing, COMDAT
; _this$ = ecx

; 841  : 		return m_bNoAnnexing;

	mov	al, BYTE PTR [ecx+351]

; 842  : 	};

	ret	0
?IsNoAnnexing@CvPlayerTraits@@QBE_NXZ ENDP		; CvPlayerTraits::IsNoAnnexing
_TEXT	ENDS
PUBLIC	??0DelegateMemento@fastdelegate@@QAE@XZ		; fastdelegate::DelegateMemento::DelegateMemento
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0DelegateMemento@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0DelegateMemento@fastdelegate@@QAE@XZ PROC		; fastdelegate::DelegateMemento::DelegateMemento, COMDAT
; _this$ = ecx

; 579  : 	DelegateMemento() : m_pthis(0), m_pFunction(0) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0DelegateMemento@fastdelegate@@QAE@XZ ENDP		; fastdelegate::DelegateMemento::DelegateMemento
_TEXT	ENDS
PUBLIC	?clear@DelegateMemento@fastdelegate@@QAEXXZ	; fastdelegate::DelegateMemento::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@DelegateMemento@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@DelegateMemento@fastdelegate@@QAEXXZ PROC	; fastdelegate::DelegateMemento::clear, COMDAT
; _this$ = ecx

; 580  : 	void clear() {	m_pthis=0; m_pFunction=0;	}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@DelegateMemento@fastdelegate@@QAEXXZ ENDP	; fastdelegate::DelegateMemento::clear
_TEXT	ENDS
PUBLIC	?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ; fastdelegate::DelegateMemento::SetMementoFrom
; Function compile flags: /Ogtpy
;	COMDAT ?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z
_TEXT	SEGMENT
_right$ = 8						; size = 4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z PROC ; fastdelegate::DelegateMemento::SetMementoFrom, COMDAT
; _this$ = ecx

; 637  : 		m_pFunction = right.m_pFunction;

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 638  : 		m_pthis = right.m_pthis;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 639  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 640  : 		m_pStaticFunction = right.m_pStaticFunction;
; 641  : #endif
; 642  : 	}

	ret	4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ENDP ; fastdelegate::DelegateMemento::SetMementoFrom
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovector.h
;	COMDAT ??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z PROC ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[], COMDAT
; _this$ = ecx

; 329  : 	return m_value[index];

	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _index$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 330  : }

	ret	4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ENDP ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDY$ = -12						; size = 4
tv320 = -8						; size = 4
tv357 = -4						; size = 4
_iX1$ = 8						; size = 4
_iDX$ = 12						; size = 4
_iY1$ = 12						; size = 4
$T231741 = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	sub	esp, 12					; 0000000cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	ecx, DWORD PTR _iX2$[esp+8]
	sub	ecx, DWORD PTR _iX1$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	edx, DWORD PTR [edi+4020]
	mov	DWORD PTR tv320[esp+28], ecx
	je	SHORT $LN18@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN20@plotDistan
	sub	ecx, edx
	jmp	SHORT $LN18@plotDistan
$LN20@plotDistan:
	neg	eax
	cmp	ecx, eax
	jge	SHORT $LN18@plotDistan
	add	ecx, edx
$LN18@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ebp, DWORD PTR _iY2$[esp+24]
	sub	ebp, DWORD PTR _iY1$[esp+24]
	cmp	BYTE PTR [edi+4057], 0
	mov	eax, DWORD PTR [edi+4024]
	je	SHORT $LN32@plotDistan
	mov	edx, eax
	shr	edx, 1
	cmp	ebp, edx
	jle	SHORT $LN34@plotDistan
	mov	ebx, ebp
	sub	ebx, eax
	mov	DWORD PTR $T231741[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN34@plotDistan:
	neg	edx
	cmp	ebp, edx
	jge	SHORT $LN32@plotDistan
	lea	ebx, DWORD PTR [eax+ebp]
	mov	DWORD PTR $T231741[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN32@plotDistan:
	mov	ebx, ebp
	mov	DWORD PTR $T231741[esp+24], ebp
$LN36@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 149  : 
; 150  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 151  : 	const CvMap& kMap = GC.getMap();
; 152  : 	// equidistant column joint fix (on X-wrapped maps):
; 153  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (iDY % 2 != 0) && ((iY1 % 2 == 0) == (iWrappedDX > (kMap.getGridWidth() >> 2))))

	cmp	BYTE PTR [edi+4056], 0
	mov	DWORD PTR _iDY$[esp+28], esi
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4020]
	xor	ebx, edx
	sub	ebx, edx
	cmp	ebx, eax
	jne	SHORT $LN73@plotDistan
	mov	edx, esi
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN79@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN79@plotDistan:
	je	SHORT $LN73@plotDistan
	sar	eax, 2
	xor	edx, edx
	cmp	ecx, eax
	mov	eax, DWORD PTR _iY1$[esp+24]
	setg	dl
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN80@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN80@plotDistan:

; 154  : 	{
; 155  : 		iWrappedDX *= -1;  // change polarity

	mov	ebx, DWORD PTR $T231741[esp+24]
	neg	eax
	sbb	eax, eax
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN5@plotDistan
	neg	ecx
	jmp	SHORT $LN5@plotDistan
$LN73@plotDistan:
	mov	ebx, DWORD PTR $T231741[esp+24]
$LN5@plotDistan:

; 156  : 	}
; 157  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (abs(iWrappedDY) < abs(iY2 - iY1)) && (iDY % 2 == 0) && (iX2 - iX1 < 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR [edi+4020]
	jne	SHORT $LN75@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN75@plotDistan
	mov	edx, DWORD PTR _iDY$[esp+28]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN81@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN81@plotDistan:
	jne	SHORT $LN75@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jge	SHORT $LN75@plotDistan

; 158  : 	{
; 159  : 		iWrappedDX *= -1;  // change polarity

	neg	ecx
$LN75@plotDistan:

; 160  : 	}
; 161  : 	// special case when map is toroidal AND map height is odd
; 162  : 	// TODO works but ugly
; 163  : 	if ((kMap.isWrapX()) && (kMap.getGridHeight() % 2 != 0) && (iY1 % 2 == kMap.getGridWidth() % 2) && (iY2 % 2 == 0) &&
; 164  : 		(abs(iWrappedDY) < abs(iY2 - iY1)) && (abs(iX2 - iX1) == kMap.getGridWidth() / 2 + ((kMap.getGridWidth() % 2 == 1) && (iX2 - iX1 > 0)) ? 1 : 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	mov	eax, DWORD PTR [edi+4024]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN82@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN82@plotDistan:
	je	$LN77@plotDistan
	mov	edi, DWORD PTR [edi+4020]
	mov	DWORD PTR tv357[esp+28], edi
	and	edi, -2147483647			; 80000001H
	jns	SHORT $LN83@plotDistan
	dec	edi
	or	edi, -2					; fffffffeH
	inc	edi
$LN83@plotDistan:
	mov	edx, DWORD PTR _iY1$[esp+24]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN84@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN84@plotDistan:
	cmp	edx, edi
	jne	SHORT $LN77@plotDistan
	mov	eax, DWORD PTR _iY2$[esp+24]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN85@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN85@plotDistan:
	jne	SHORT $LN77@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN77@plotDistan
	cmp	edi, 1
	jne	SHORT $LN76@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jle	SHORT $LN76@plotDistan
	mov	esi, edi
	jmp	SHORT $LN9@plotDistan
$LN76@plotDistan:
	xor	esi, esi
$LN9@plotDistan:
	mov	eax, DWORD PTR tv320[esp+28]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv357[esp+28]
	xor	edi, edx
	sub	edi, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, esi
	cmp	edi, eax
	jne	SHORT $LN77@plotDistan

; 165  : 	{
; 166  : 		iWrappedDX -= (iWrappedDX > 0) - (iWrappedDX < 0);  // decrease regardless of polarity

	xor	edx, edx
	test	ecx, ecx
	setl	dl
	xor	eax, eax
	test	ecx, ecx
	setg	al
	sub	edx, eax
	add	ecx, edx
$LN77@plotDistan:

; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 171  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	mov	eax, DWORD PTR _iY1$[esp+24]
	test	eax, eax
	jge	SHORT $LN88@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN88@plotDistan:
	mov	edi, DWORD PTR _iX1$[esp+24]

; 172  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	edx, DWORD PTR _iY1$[esp+24]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	lea	eax, DWORD PTR [ebx+edx]
	test	eax, eax
	jge	SHORT $LN89@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN89@plotDistan:
	sar	eax, 1
	sub	ecx, eax
	add	ecx, edi

; 173  : 
; 174  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 175  : 	// obvious bug
; 176  : 	iDX = abs(iHX2 - iHX1);

	sub	ecx, esi
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 177  : #else
; 178  : 	iDX = abs(dxWrap(iHX2 - iHX1));
; 179  : #endif
; 180  : 
; 181  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 182  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 183  : #else
; 184  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp+12], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 185  : #endif
; 186  : 	{
; 187  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp+12]
	add	eax, edx

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@plotDistan:

; 188  : 	}
; 189  : 	else
; 190  : 	{
; 191  : #ifdef NQM_FAST_COMP
; 192  : 		return (MAX(iDX, iDY));
; 193  : #else
; 194  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp+12]
	lea	eax, DWORD PTR _iDY$[esp+12]
	jl	SHORT $LN71@plotDistan
	lea	eax, DWORD PTR _iDX$[esp+8]
$LN71@plotDistan:
	mov	eax, DWORD PTR [eax]

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvMilitaryAIStrategyXMLEntry@@6B@		; CvMilitaryAIStrategyXMLEntry::`vftable'
PUBLIC	??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ		; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry
PUBLIC	??_R4CvMilitaryAIStrategyXMLEntry@@6B@		; CvMilitaryAIStrategyXMLEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvMilitaryAIStrategyXMLEntry@@@8	; CvMilitaryAIStrategyXMLEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvMilitaryAIStrategyXMLEntry@@8		; CvMilitaryAIStrategyXMLEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvMilitaryAIStrategyXMLEntry@@8		; CvMilitaryAIStrategyXMLEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvMilitaryAIStrategyXMLEntry@@8	; CvMilitaryAIStrategyXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvMilitaryAIStrategyXMLEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z:PROC ; CvMilitaryAIStrategyXMLEntry::`vector deleting destructor'
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvMilitaryAIStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvMilitaryAIStrategyXMLEntry@@8 DD FLAT:??_R0?AVCvMilitaryAIStrategyXMLEntry@@@8 ; CvMilitaryAIStrategyXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvMilitaryAIStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvMilitaryAIStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R2CvMilitaryAIStrategyXMLEntry@@8 DD FLAT:??_R1A@?0A@EA@CvMilitaryAIStrategyXMLEntry@@8 ; CvMilitaryAIStrategyXMLEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvMilitaryAIStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R3CvMilitaryAIStrategyXMLEntry@@8 DD 00H		; CvMilitaryAIStrategyXMLEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvMilitaryAIStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvMilitaryAIStrategyXMLEntry@@@8
_DATA	SEGMENT
??_R0?AVCvMilitaryAIStrategyXMLEntry@@@8 DD FLAT:??_7type_info@@6B@ ; CvMilitaryAIStrategyXMLEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvMilitaryAIStrategyXMLEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvMilitaryAIStrategyXMLEntry@@6B@
rdata$r	SEGMENT
??_R4CvMilitaryAIStrategyXMLEntry@@6B@ DD 00H		; CvMilitaryAIStrategyXMLEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvMilitaryAIStrategyXMLEntry@@@8
	DD	FLAT:??_R3CvMilitaryAIStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvMilitaryAIStrategyXMLEntry@@6B@
CONST	SEGMENT
??_7CvMilitaryAIStrategyXMLEntry@@6B@ DD FLAT:??_R4CvMilitaryAIStrategyXMLEntry@@6B@ ; CvMilitaryAIStrategyXMLEntry::`vftable'
	DD	FLAT:?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ$0
__ehfuncinfo$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ PROC		; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 42   : {

	push	-1
	push	__ehhandler$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvMilitaryAIStrategyXMLEntry@@6B@

; 43   : 	SAFE_DELETE_ARRAY(m_piPlayerFlavorValue);

	mov	eax, DWORD PTR [esi+260]
	xor	edi, edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+260], edi

; 44   : 	SAFE_DELETE_ARRAY(m_piCityFlavorValue);

	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+264], edi

; 45   : 	SAFE_DELETE_ARRAY(m_piPersonalityFlavorThresholdMod);

	mov	eax, DWORD PTR [esi+272]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 46   : }

	lea	ecx, DWORD PTR [esi+304]
	mov	DWORD PTR [esi+272], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvMilitaryAIStrategyXMLEntry::CacheResults, COMDAT
; _this$ = ecx

; 50   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _kResults$[esp]
	push	esi
	push	eax
	push	ebx
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN9@CacheResul
	pop	esi
	pop	ebx

; 107  : }

	ret	8
$LN9@CacheResul:
	push	ebp
	push	edi

; 51   : 		return false;
; 52   : 
; 53   : 	//Basic Properties
; 54   : 	m_bNoMinorCivs				 = kResults.GetBool("NoMinorCivs");

	mov	edi, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG225636
	mov	ecx, ebx
	call	edi

; 55   : 	m_bOnlyMinorCivs		     = kResults.GetBool("OnlyMinorCivs");

	push	OFFSET $SG225637
	mov	ecx, ebx
	mov	BYTE PTR [esi+276], al
	call	edi

; 56   : 	m_bUpdateCitySpecializations = kResults.GetBool("UpdateCitySpecializations");

	push	OFFSET $SG225638
	mov	ecx, ebx
	mov	BYTE PTR [esi+277], al
	call	edi

; 57   : 	m_iCheckTriggerTurnCount	 = kResults.GetInt("CheckTriggerTurnCount");

	mov	edi, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG225639
	mov	ecx, ebx
	mov	BYTE PTR [esi+278], al
	call	edi

; 58   : 	m_iFirstTurnExecuted            = kResults.GetInt("FirstTurnExecuted");

	push	OFFSET $SG225640
	mov	ecx, ebx
	mov	DWORD PTR [esi+292], eax
	call	edi

; 59   : 	m_iMinimumNumTurnsExecuted	 = kResults.GetInt("MinimumNumTurnsExecuted");

	push	OFFSET $SG225641
	mov	ecx, ebx
	mov	DWORD PTR [esi+296], eax
	call	edi

; 60   : 	m_iWeightThreshold			 = kResults.GetInt("WeightThreshold");

	push	OFFSET $SG225642
	mov	ecx, ebx
	mov	DWORD PTR [esi+288], eax
	call	edi

; 61   : 
; 62   : 	const char* strAdvisor = kResults.GetText("Advisor");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG225644
	mov	ecx, ebx
	mov	DWORD PTR [esi+268], eax
	call	ebp

; 63   : 	m_eAdvisor = NO_ADVISOR_TYPE;

	mov	DWORD PTR [esi+300], -1

; 64   : 	if(strAdvisor)

	test	eax, eax
	je	$LN34@CacheResul

; 65   : 	{
; 66   : 		if(strcmp(strAdvisor, "MILITARY") == 0)

	mov	edi, OFFSET $SG225647
	mov	ecx, eax
	npad	5
$LL18@CacheResul:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [edi]
	jne	SHORT $LN19@CacheResul
	test	dl, dl
	je	SHORT $LN20@CacheResul
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [edi+1]
	jne	SHORT $LN19@CacheResul
	add	ecx, 2
	add	edi, 2
	test	dl, dl
	jne	SHORT $LL18@CacheResul
$LN20@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN21@CacheResul
$LN19@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN21@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN7@CacheResul

; 67   : 		{
; 68   : 			m_eAdvisor = ADVISOR_MILITARY;

	mov	DWORD PTR [esi+300], ecx
	jmp	$LN34@CacheResul
$LN7@CacheResul:

; 69   : 		}
; 70   : 		else if(strcmp(strAdvisor, "ECONOMIC") == 0)

	mov	edi, OFFSET $SG225650
	mov	ecx, eax
	npad	5
$LL22@CacheResul:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [edi]
	jne	SHORT $LN23@CacheResul
	test	dl, dl
	je	SHORT $LN24@CacheResul
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [edi+1]
	jne	SHORT $LN23@CacheResul
	add	ecx, 2
	add	edi, 2
	test	dl, dl
	jne	SHORT $LL22@CacheResul
$LN24@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN25@CacheResul
$LN23@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN25@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN5@CacheResul

; 71   : 		{
; 72   : 			m_eAdvisor = ADVISOR_ECONOMIC;

	mov	DWORD PTR [esi+300], 1
	jmp	SHORT $LN34@CacheResul
$LN5@CacheResul:

; 73   : 		}
; 74   : 		else if(strcmp(strAdvisor, "FOREIGN") == 0)

	mov	edi, OFFSET $SG225653
	mov	ecx, eax
	npad	4
$LL26@CacheResul:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [edi]
	jne	SHORT $LN27@CacheResul
	test	dl, dl
	je	SHORT $LN28@CacheResul
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [edi+1]
	jne	SHORT $LN27@CacheResul
	add	ecx, 2
	add	edi, 2
	test	dl, dl
	jne	SHORT $LL26@CacheResul
$LN28@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN29@CacheResul
$LN27@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN29@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN3@CacheResul

; 75   : 		{
; 76   : 			m_eAdvisor = ADVISOR_FOREIGN;

	mov	DWORD PTR [esi+300], 2
	jmp	SHORT $LN34@CacheResul
$LN3@CacheResul:

; 77   : 		}
; 78   : 		else if(strcmp(strAdvisor, "SCIENCE") == 0)

	mov	edi, OFFSET $SG225656
	npad	6
$LL30@CacheResul:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN31@CacheResul
	test	cl, cl
	je	SHORT $LN32@CacheResul
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN31@CacheResul
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL30@CacheResul
$LN32@CacheResul:
	xor	eax, eax
	jmp	SHORT $LN33@CacheResul
$LN31@CacheResul:
	sbb	eax, eax
	sbb	eax, -1
$LN33@CacheResul:
	test	eax, eax
	jne	SHORT $LN34@CacheResul

; 79   : 		{
; 80   : 			m_eAdvisor = ADVISOR_SCIENCE;

	mov	DWORD PTR [esi+300], 3
$LN34@CacheResul:

; 81   : 		}
; 82   : 	}
; 83   : 
; 84   : 	m_strAdvisorCounselText = kResults.GetText("AdvisorCounsel");

	push	OFFSET $SG225657
	mov	ecx, ebx
	call	ebp
	lea	ecx, DWORD PTR [esi+304]
	test	eax, eax
	je	SHORT $LN13@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN12@CacheResul
$LN13@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN12@CacheResul:

; 85   : 
; 86   : 	//References
; 87   : 	const char* szTextVal = NULL;
; 88   : 	szTextVal = kResults.GetText("TechObsolete");

	push	OFFSET $SG225659
	mov	ecx, ebx
	call	ebp

; 89   : 	m_iTechObsolete = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 90   : 
; 91   : 	szTextVal = kResults.GetText("TechPrereq");

	push	OFFSET $SG225660
	mov	ecx, ebx
	mov	DWORD PTR [esi+284], eax
	call	ebp

; 92   : 	m_iTechPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 93   : 
; 94   : 	//Arrays
; 95   : 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+280], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 96   : 	kUtility.SetFlavors(m_piPlayerFlavorValue, "AIMilitaryStrategy_Player_Flavors",
; 97   : 	                    "AIMilitaryStrategyType", szType);

	mov	ebx, DWORD PTR _kUtility$[esp+12]
	push	0
	mov	edi, eax
	push	edi
	push	OFFSET $SG225662
	push	OFFSET $SG225663
	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 98   : 	kUtility.SetFlavors(m_piCityFlavorValue, "AIMilitaryStrategy_City_Flavors",
; 99   : 		"AIMilitaryStrategyType", szType);

	push	0
	push	edi
	push	OFFSET $SG225664
	push	OFFSET $SG225665
	lea	edx, DWORD PTR [esi+264]
	push	edx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 100  : 
; 101  : 
; 102  : 	kUtility.SetFlavors(m_piPersonalityFlavorThresholdMod,
; 103  : 	                    "AIMilitaryStrategy_PersonalityFlavorThresholdMods",
; 104  : 	                    "AIMilitaryStrategyType", szType);

	push	0
	push	edi
	push	OFFSET $SG225666
	push	OFFSET $SG225667
	add	esi, 272				; 00000110H
	push	esi
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors
	pop	edi
	pop	ebp
	pop	esi

; 105  : 
; 106  : 	return true;

	mov	al, 1
	pop	ebx

; 107  : }

	ret	8
?CacheResults@CvMilitaryAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvMilitaryAIStrategyXMLEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ PROC ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies, COMDAT
; _this$ = ecx

; 226  : 	return m_paAIStrategyEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 227  : }

	ret	0
?GetNumMilitaryAIStrategies@CvMilitaryAIStrategyXMLEntries@@QAEHXZ ENDP ; CvMilitaryAIStrategyXMLEntries::GetNumMilitaryAIStrategies
_TEXT	ENDS
PUBLIC	?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ; CvMilitaryAIStrategyXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z PROC ; CvMilitaryAIStrategyXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 243  : 	return m_paAIStrategyEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 244  : }

	ret	4
?GetEntry@CvMilitaryAIStrategyXMLEntries@@QAEPAVCvMilitaryAIStrategyXMLEntry@@H@Z ENDP ; CvMilitaryAIStrategyXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Uninit@CvMilitaryAI@@QAEXXZ			; CvMilitaryAI::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvMilitaryAI@@QAEXXZ PROC			; CvMilitaryAI::Uninit, COMDAT
; _this$ = ecx

; 307  : {

	push	esi
	mov	esi, ecx

; 308  : 	SAFE_DELETE_ARRAY(m_pabUsingStrategy);

	mov	eax, DWORD PTR [esi+12]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+12], edi

; 309  : 	SAFE_DELETE_ARRAY(m_paiTurnStrategyAdopted);

	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+16], edi

; 310  : 	SAFE_DELETE_ARRAY(m_aiTempFlavors);

	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+20], edi

; 311  : 	SAFE_DELETE_ARRAY(m_paeLastTurnWarState);

	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+24], edi

; 312  : 	SAFE_DELETE_ARRAY(m_paeLastTurnMilitaryThreat);

	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+28], edi

; 313  : 	SAFE_DELETE_ARRAY(m_paeLastTurnMilitaryStrength);

	mov	edx, DWORD PTR [esi+32]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+32], edi

; 314  : 	SAFE_DELETE_ARRAY(m_paeLastTurnTargetValue);

	mov	eax, DWORD PTR [esi+36]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi+36], edi
	pop	edi
	pop	esi

; 315  : }

	ret	0
?Uninit@CvMilitaryAI@@QAEXXZ ENDP			; CvMilitaryAI::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvMilitaryAI@@QAEXXZ			; CvMilitaryAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvMilitaryAI@@QAEXXZ PROC			; CvMilitaryAI::Reset, COMDAT
; _this$ = ecx

; 320  : 	int iI;
; 321  : 
; 322  : 	m_iTotalThreatWeight = 1;  // Don't ever assume there is no threat at all
; 323  : 	m_eArmyTypeBeingBuilt = NO_ARMY_TYPE;
; 324  : 
; 325  : 	m_iNumLandUnits = 0;

	xor	edx, edx
	push	ebx
	push	esi

; 326  : 	m_iNumRangedLandUnits = 0;
; 327  : 	m_iNumMobileLandUnits = 0;
; 328  : 	m_iNumAirUnits = 0;
; 329  : 	m_iNumAntiAirUnits = 0;
; 330  : 	m_iNumMeleeLandUnits = 0;
; 331  : 	m_iNumNavalUnits = 0;
; 332  : 	m_iNumLandUnitsInArmies = 0;
; 333  : 	m_iNumNavalUnitsInArmies = 0;
; 334  : 	m_iBarbarianCampCount = 0;
; 335  : 	m_iVisibleBarbarianCount = 0;
; 336  : 	m_iRecommendedMilitarySize = 0;
; 337  : 	m_iMandatoryReserveSize = 0;
; 338  : 	m_eLandDefenseState = NO_DEFENSE_STATE;
; 339  : 	m_eNavalDefenseState = NO_DEFENSE_STATE;
; 340  : 	m_iNumberOfTimesOpsBuildSkippedOver = 0;
; 341  : 
; 342  : 	for(iI = 0; iI < m_pAIStrategies->GetNumMilitaryAIStrategies(); iI++)

	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+40], 1
	mov	DWORD PTR [ecx+44], -1
	mov	DWORD PTR [ecx+52], edx
	mov	DWORD PTR [ecx+56], edx
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+80], edx
	mov	DWORD PTR [ecx+84], edx
	mov	DWORD PTR [ecx+64], edx
	mov	DWORD PTR [ecx+68], edx
	mov	DWORD PTR [ecx+72], edx
	mov	DWORD PTR [ecx+76], edx
	mov	DWORD PTR [ecx+88], edx
	mov	DWORD PTR [ecx+92], edx
	mov	DWORD PTR [ecx+96], edx
	mov	DWORD PTR [ecx+100], edx
	mov	DWORD PTR [ecx+112], -1
	mov	DWORD PTR [ecx+116], -1
	mov	DWORD PTR [ecx+48], edx
	mov	ebx, DWORD PTR [esi+8]
	sub	ebx, DWORD PTR [esi+4]
	xor	eax, eax
	test	ebx, -4					; fffffffcH
	jle	SHORT $LN1@Reset
	npad	3
$LL3@Reset:

; 343  : 	{
; 344  : 		m_pabUsingStrategy[iI] = false;

	mov	esi, DWORD PTR [ecx+12]
	mov	BYTE PTR [eax+esi], dl

; 345  : 		m_paiTurnStrategyAdopted[iI] = -1;

	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+eax*4], -1

; 346  : 		m_paeLastTurnWarState[iI] = NO_WAR_STATE_TYPE;

	mov	esi, DWORD PTR [ecx+24]
	mov	DWORD PTR [esi+eax*4], -1

; 347  : 		m_paeLastTurnMilitaryThreat[iI] = NO_THREAT_VALUE;

	mov	esi, DWORD PTR [ecx+28]
	mov	DWORD PTR [esi+eax*4], -1

; 348  : 		m_paeLastTurnMilitaryStrength[iI] = NO_STRENGTH_VALUE;

	mov	esi, DWORD PTR [ecx+32]
	mov	DWORD PTR [esi+eax*4], -1

; 349  : 		m_paeLastTurnTargetValue[iI] = NO_TARGET_VALUE;

	mov	esi, DWORD PTR [ecx+36]
	mov	DWORD PTR [esi+eax*4], -1
	mov	esi, DWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [esi+8]
	sub	ebx, DWORD PTR [esi+4]
	inc	eax
	sar	ebx, 2
	cmp	eax, ebx
	jl	SHORT $LL3@Reset
$LN1@Reset:
	pop	esi
	pop	ebx

; 350  : 	}
; 351  : }

	ret	0
?Reset@CvMilitaryAI@@QAEXXZ ENDP			; CvMilitaryAI::Reset
_TEXT	ENDS
PUBLIC	?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestNukeAttack
EXTRN	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z:PROC ; CvPlayer::addAIOperation
EXTRN	?getNumNukeUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumNukeUnits
; Function compile flags: /Ogtpy
;	COMDAT ?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eEnemy$ = 8						; size = 4
?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestNukeAttack, COMDAT
; _this$ = ecx

; 587  : {

	push	esi
	mov	esi, ecx

; 588  : 	if(m_pPlayer->getNumNukeUnits() > 0)

	mov	ecx, DWORD PTR [esi]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	test	eax, eax
	jle	SHORT $LN1@RequestNuk

; 589  : 	{
; 590  : 		CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NUKE_ATTACK, eEnemy);

	mov	eax, DWORD PTR _eEnemy$[esp]
	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	push	-1
	push	eax
	push	17					; 00000011H
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 591  : 		if(pOperation != NULL && pOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)

	test	eax, eax
	je	SHORT $LN1@RequestNuk
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN1@RequestNuk

; 592  : 		{
; 593  : 			return true;

	mov	al, 1
	pop	esi

; 598  : }

	ret	4
$LN1@RequestNuk:

; 594  : 		}
; 595  : 	}
; 596  : 
; 597  : 	return false;

	xor	al, al
	pop	esi

; 598  : }

	ret	4
?RequestNukeAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestNukeAttack
_TEXT	ENDS
PUBLIC	?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyBuilding
EXTRN	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z:PROC ; CvTacticalAI::LogTacticalMessage
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?CreateBuilding@CvCity@@QAE_NW4BuildingTypes@@@Z:PROC ; CvCity::CreateBuilding
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z:PROC ; CvTreasury::LogExpenditure
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?GetText@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetText
EXTRN	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z:PROC ; CvEconomicAI::CanWithdrawMoneyForPurchase
EXTRN	?GetPurchaseCost@CvCity@@QAEHW4BuildingTypes@@@Z:PROC ; CvCity::GetPurchaseCost
EXTRN	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z:PROC ; CvCity::IsCanPurchase
EXTRN	?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetDefensePerCitizen
EXTRN	?GetDefenseModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetDefenseModifier
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ:PROC ; CvBuildingXMLEntries::GetNumBuildings
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$2
__ehfuncinfo$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
_TEXT	SEGMENT
$T232051 = -72						; size = 4
_szMsg$226320 = -68					; size = 28
$T232052 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pkBuildingInfo$226309 = 8				; size = 4
_pCity$ = 8						; size = 4
?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z PROC ; CvMilitaryAI::BuyEmergencyBuilding, COMDAT
; _this$ = ecx

; 929  : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 930  : 	// Loop through adding the available buildings
; 931  : #ifdef AUI_WARNING_FIXES
; 932  : 	for (uint iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)
; 933  : #else
; 934  : 	for(int iBldgLoop = 0; iBldgLoop < GC.GetGameBuildings()->GetNumBuildings(); iBldgLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	test	eax, eax
	jle	$LN34@BuyEmergen
	mov	ebx, DWORD PTR _pCity$[esp+84]
$LN8@BuyEmergen:

; 935  : #endif
; 936  : 	{
; 937  : 		const BuildingTypes eBldg = static_cast<BuildingTypes>(iBldgLoop);
; 938  : 		CvBuildingEntry* pkBuildingInfo = GC.GetGameBuildings()->GetEntry(eBldg);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	esi, eax
	mov	DWORD PTR _pkBuildingInfo$226309[esp+84], esi

; 939  : 		if(pkBuildingInfo)

	test	esi, esi
	je	$LN7@BuyEmergen

; 940  : 		{
; 941  : 			// Make sure this building can be built now
; 942  : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 943  : 			if(pCity->canConstruct(eBldg) && (pkBuildingInfo->GetDefenseModifier() > 0 || pkBuildingInfo->GetDefensePerCitizen() > 0))

	push	0
	push	0
	push	0
	push	0
	push	ebp
	mov	ecx, ebx
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	test	al, al
	je	$LN7@BuyEmergen
	mov	ecx, esi
	call	?GetDefenseModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetDefenseModifier
	test	eax, eax
	jg	SHORT $LN3@BuyEmergen
	mov	ecx, esi
	call	?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetDefensePerCitizen
	test	eax, eax
	jle	$LN7@BuyEmergen
$LN3@BuyEmergen:

; 944  : #else
; 945  : 			if(pCity->canConstruct(eBldg) && pkBuildingInfo->GetDefenseModifier() > 0)
; 946  : #endif
; 947  : 			{
; 948  : 				if(pCity->IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, NO_UNIT, eBldg, NO_PROJECT, YIELD_GOLD))

	push	2
	push	-1
	push	ebp
	push	-1
	push	1
	push	1
	mov	ecx, ebx
	call	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z ; CvCity::IsCanPurchase
	test	al, al
	je	$LN7@BuyEmergen

; 949  : 				{
; 950  : 					int iGoldCost = pCity->GetPurchaseCost(eBldg);

	push	ebp
	mov	ecx, ebx
	call	?GetPurchaseCost@CvCity@@QAEHW4BuildingTypes@@@Z ; CvCity::GetPurchaseCost

; 951  : 					int iPriority = GC.getAI_GOLD_PRIORITY_DEFENSIVE_BUILDING();
; 952  : 					if(m_pPlayer->GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_BUILDING, iGoldCost, iPriority))

	mov	ecx, DWORD PTR [edi]
	mov	esi, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2096
	push	eax
	push	esi
	push	5
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
	test	al, al
	je	$LN7@BuyEmergen

; 953  : 					{
; 954  : 						m_pPlayer->GetTreasury()->LogExpenditure((CvString)pkBuildingInfo->GetText(), iGoldCost, 8);

	mov	ecx, DWORD PTR _pkBuildingInfo$226309[esp+84]
	push	8
	push	esi
	call	?GetText@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetText
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T232051[esp+124], esp
	mov	ecx, esp
	test	eax, eax
	jne	SHORT $LN19@BuyEmergen
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN19@BuyEmergen:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[esp+132], 0
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 955  : 						m_pPlayer->GetTreasury()->ChangeGold(-iGoldCost);

	mov	ecx, DWORD PTR [edi]
	neg	esi
	push	esi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 956  : #ifdef CVASSERT_ENABLE
; 957  : 						int iResult = pCity->CreateBuilding(eBldg);
; 958  : 
; 959  : 						DEBUG_VARIABLE(iResult);
; 960  : 						CvAssertMsg(iResult != FFreeList::INVALID_INDEX, "Unable to create building");
; 961  : #else
; 962  : 						pCity->CreateBuilding(eBldg);

	push	ebp
	mov	ecx, ebx
	call	?CreateBuilding@CvCity@@QAE_NW4BuildingTypes@@@Z ; CvCity::CreateBuilding

; 963  : #endif
; 964  : 
; 965  : 						CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$226320[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 966  : 						szMsg.Format("Emergency Building Purchased: %s, ", pkBuildingInfo->GetDescription());

	mov	ecx, DWORD PTR _pkBuildingInfo$226309[esp+84]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR __$EHRec$[esp+96], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _szMsg$226320[esp+92]
	push	OFFSET $SG226321
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 967  : 						szMsg += pCity->getName();

	lea	ecx, DWORD PTR $T232052[esp+88]
	push	ecx
	mov	ecx, ebx
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _szMsg$226320[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 2
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232052[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 968  : 						m_pPlayer->GetTacticalAI()->LogTacticalMessage(szMsg);

	mov	ecx, DWORD PTR [edi]
	push	1
	lea	edx, DWORD PTR _szMsg$226320[esp+92]
	push	edx
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 969  : 					}

	lea	ecx, DWORD PTR _szMsg$226320[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@BuyEmergen:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	ebp, eax
	jl	$LN8@BuyEmergen
$LN34@BuyEmergen:

; 970  : 				}
; 971  : 			}
; 972  : 		}
; 973  : 	}
; 974  : 	return false;
; 975  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 72					; 00000048H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$0:
	mov	ecx, DWORD PTR $T232051[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$1:
	lea	ecx, DWORD PTR _szMsg$226320[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z$2:
	lea	ecx, DWORD PTR $T232052[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuyEmergencyBuilding@CvMilitaryAI@@QAE_NPAVCvCity@@@Z ENDP ; CvMilitaryAI::BuyEmergencyBuilding
PUBLIC	?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ; CvMilitaryAI::GetThreatWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z
_TEXT	SEGMENT
_eThreat$ = 8						; size = 4
?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z PROC ; CvMilitaryAI::GetThreatWeight, COMDAT
; _this$ = ecx

; 1589 : 	int iRtnValue = 0;
; 1590 : 
; 1591 : 	switch(eThreat)

	mov	ecx, DWORD PTR _eThreat$[esp-4]
	dec	ecx
	xor	eax, eax
	cmp	ecx, 3
	ja	SHORT $LN5@GetThreatW
	jmp	DWORD PTR $LN17@GetThreatW[ecx*4]
$LN4@GetThreatW:

; 1592 : 	{
; 1593 : 	case THREAT_MINOR:
; 1594 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_MINOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2164

; 1604 : 		break;
; 1605 : 	}
; 1606 : 
; 1607 : 	return iRtnValue;
; 1608 : }

	ret	4
$LN3@GetThreatW:

; 1595 : 		break;
; 1596 : 	case THREAT_MAJOR:
; 1597 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_MAJOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168

; 1604 : 		break;
; 1605 : 	}
; 1606 : 
; 1607 : 	return iRtnValue;
; 1608 : }

	ret	4
$LN2@GetThreatW:

; 1598 : 		break;
; 1599 : 	case THREAT_SEVERE:
; 1600 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_SEVERE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2172

; 1604 : 		break;
; 1605 : 	}
; 1606 : 
; 1607 : 	return iRtnValue;
; 1608 : }

	ret	4
$LN1@GetThreatW:

; 1601 : 		break;
; 1602 : 	case THREAT_CRITICAL:
; 1603 : 		iRtnValue = GC.getAI_MILITARY_THREAT_WEIGHT_CRITICAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2176
$LN5@GetThreatW:

; 1604 : 		break;
; 1605 : 	}
; 1606 : 
; 1607 : 	return iRtnValue;
; 1608 : }

	ret	4
	npad	1
$LN17@GetThreatW:
	DD	$LN4@GetThreatW
	DD	$LN3@GetThreatW
	DD	$LN2@GetThreatW
	DD	$LN1@GetThreatW
?GetThreatWeight@CvMilitaryAI@@QAEHW4ThreatTypes@@@Z ENDP ; CvMilitaryAI::GetThreatWeight
_TEXT	ENDS
PUBLIC	?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::LogChosenTarget
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$9
	DD	04H
	DD	FLAT:__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
_TEXT	SEGMENT
_pLog$227239 = -212					; size = 4
_strBaseString$227235 = -208				; size = 28
$T232120 = -180						; size = 28
$T232119 = -180						; size = 28
$T232117 = -180						; size = 28
$T232115 = -180						; size = 28
_strOutBuf$227234 = -152				; size = 28
_playerName$227237 = -124				; size = 28
_strLogName$227238 = -96				; size = 28
_strTemp$227236 = -68					; size = 28
$T232118 = -40						; size = 28
$T232116 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eAIOperationType$ = 8					; size = 4
_eEnemy$ = 12						; size = 4
_target$ = 16						; size = 4
?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z PROC ; CvMilitaryAI::LogChosenTarget, COMDAT
; _this$ = ecx

; 1779 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 200				; 000000c8H
	push	esi
	mov	esi, ecx

; 1780 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN11@LogChosenT
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN11@LogChosenT
	push	ebx
	push	ebp
	push	edi

; 1781 : 	{
; 1782 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227234[esp+228]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1783 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227235[esp+228]
	mov	DWORD PTR __$EHRec$[esp+236], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1784 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227236[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1785 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227237[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1786 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$227238[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1787 : 
; 1788 : 		// Find the name of this civ and city
; 1789 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+236], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$227237[esp+228]
	test	eax, eax
	je	SHORT $LN41@LogChosenT
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN40@LogChosenT
$LN41@LogChosenT:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN40@LogChosenT:

; 1790 : 
; 1791 : 		// Open the log file
; 1792 : 		FILogFile* pLog;
; 1793 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	test	al, al
	je	SHORT $LN10@LogChosenT

; 1794 : 		{
; 1795 : 			strLogName = "OperationalAILog_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$227237[esp+228]
	push	eax
	lea	ecx, DWORD PTR $T232115[esp+232]
	push	OFFSET $SG227244
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG227243
	push	eax
	lea	edx, DWORD PTR $T232116[esp+248]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	edi
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+236], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227238[esp+232]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232116[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232115[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1796 : 		}
; 1797 : 		else

	jmp	SHORT $LN46@LogChosenT
$LN10@LogChosenT:

; 1798 : 		{
; 1799 : 			strLogName = "OperationalAILog.csv";

	push	OFFSET $SG227246
	lea	ecx, DWORD PTR _strLogName$227238[esp+232]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN46@LogChosenT:

; 1800 : 		}
; 1801 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$227238[esp+228]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 1802 : 
; 1803 : 		// Get the leading info for this line
; 1804 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _pLog$227239[esp+228], eax
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227235[esp+232]
	push	OFFSET $SG227247
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1805 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG227249
	lea	edx, DWORD PTR _playerName$227237[esp+244]
	push	edx
	lea	eax, DWORD PTR $T232117[esp+248]
	push	eax
	call	edi
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227235[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 7
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232117[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1806 : 		if(eAIOperationType == AI_OPERATION_BASIC_CITY_ATTACK)

	mov	eax, DWORD PTR _eAIOperationType$[esp+224]
	cmp	eax, 2
	jne	SHORT $LN8@LogChosenT

; 1807 : 		{
; 1808 : 			strBaseString += "Basic Attack, ";

	push	OFFSET $SG227251
	jmp	SHORT $LN86@LogChosenT
$LN8@LogChosenT:

; 1809 : 		}
; 1810 : 		else if(eAIOperationType == AI_OPERATION_SNEAK_CITY_ATTACK)

	cmp	eax, 6
	jne	SHORT $LN6@LogChosenT

; 1811 : 		{
; 1812 : 			strBaseString += "Sneak Attack, ";

	push	OFFSET $SG227254
	jmp	SHORT $LN86@LogChosenT
$LN6@LogChosenT:

; 1813 : 		}
; 1814 : 		else if(eAIOperationType == AI_OPERATION_PURE_NAVAL_CITY_ATTACK)

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN4@LogChosenT

; 1815 : 		{
; 1816 : 			strBaseString += "Pure Naval Attack, ";

	push	OFFSET $SG227257

; 1817 : 		}
; 1818 : 		else

	jmp	SHORT $LN86@LogChosenT
$LN4@LogChosenT:

; 1819 : 		{
; 1820 : 			strBaseString += "City State Attack, ";

	push	OFFSET $SG227259
$LN86@LogChosenT:
	lea	ecx, DWORD PTR _strBaseString$227235[esp+232]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1821 : 		}
; 1822 : 		strBaseString += GET_PLAYER(eEnemy).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eEnemy$[esp+224]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227235[esp+232]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1823 : 		strBaseString += ", ";

	push	OFFSET $SG227260
	lea	ecx, DWORD PTR _strBaseString$227235[esp+232]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1824 : 
; 1825 : 		strTemp.Format("CHOSEN: %s, Muster: %s", target.m_pTargetCity->getName().GetCString(), target.m_pMusterCity->getName().GetCString());

	mov	esi, DWORD PTR _target$[esp+224]
	lea	ecx, DWORD PTR $T232118[esp+228]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	edi, eax
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR $T232119[esp+228]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+240], 8
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ebp, eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+236], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strTemp$227236[esp+236]
	push	OFFSET $SG227263
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T232119[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232118[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1826 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$227236[esp+228]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$227235[esp+232]
	push	edx
	lea	eax, DWORD PTR $T232120[esp+236]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+236], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227234[esp+232]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232120[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1827 : 		if(target.m_bAttackBySea)

	cmp	BYTE PTR [esi+20], 0
	pop	edi
	pop	ebp
	pop	ebx

; 1828 : 		{
; 1829 : 			strOutBuf += ", Sea";

	lea	ecx, DWORD PTR _strOutBuf$227234[esp+216]
	je	SHORT $LN2@LogChosenT
	push	OFFSET $SG227266

; 1830 : 		}
; 1831 : 		else

	jmp	SHORT $LN87@LogChosenT
$LN2@LogChosenT:

; 1832 : 		{
; 1833 : 			strOutBuf += ", Land";

	push	OFFSET $SG227268
$LN87@LogChosenT:
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1834 : 		}
; 1835 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227234[esp+216]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$227239[esp+216]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax
	add	esp, 8

; 1836 : 	}

	lea	ecx, DWORD PTR _strLogName$227238[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$227237[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$227236[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227235[esp+216]
	mov	BYTE PTR __$EHRec$[esp+224], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227234[esp+216]
	mov	DWORD PTR __$EHRec$[esp+224], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@LogChosenT:

; 1837 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+216]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 212				; 000000d4H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227234[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227235[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$227236[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$3:
	lea	ecx, DWORD PTR _playerName$227237[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$4:
	lea	ecx, DWORD PTR _strLogName$227238[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$5:
	lea	ecx, DWORD PTR $T232115[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$6:
	lea	ecx, DWORD PTR $T232116[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$7:
	lea	ecx, DWORD PTR $T232117[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$8:
	lea	ecx, DWORD PTR $T232118[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$9:
	lea	ecx, DWORD PTR $T232119[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z$10:
	lea	ecx, DWORD PTR $T232120[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ENDP ; CvMilitaryAI::LogChosenTarget
PUBLIC	?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatIncrease
; Function compile flags: /Ogtpy
;	COMDAT ?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z
_TEXT	SEGMENT
_eNewThreat$ = 8					; size = 4
_eOldThreat$ = 12					; size = 4
?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z PROC ; CvMilitaryAI::ThreatIncrease, COMDAT
; _this$ = ecx

; 2367 : 	// Subtract off old threat
; 2368 : 	m_iTotalThreatWeight -= GetThreatWeight(eOldThreat);

	mov	edx, DWORD PTR _eOldThreat$[esp-4]
	dec	edx
	xor	eax, eax
	cmp	edx, 3
	ja	SHORT $LN17@ThreatIncr
	jmp	DWORD PTR $LN35@ThreatIncr[edx*4]
$LN6@ThreatIncr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2164
	jmp	SHORT $LN17@ThreatIncr
$LN5@ThreatIncr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	jmp	SHORT $LN17@ThreatIncr
$LN4@ThreatIncr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2172
	jmp	SHORT $LN17@ThreatIncr
$LN3@ThreatIncr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2176
$LN17@ThreatIncr:
	sub	DWORD PTR [ecx+40], eax

; 2369 : 
; 2370 : 	// Add on new threat
; 2371 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

	mov	eax, DWORD PTR _eNewThreat$[esp-4]
	dec	eax
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR [ecx+40]
	cmp	eax, 3
	ja	SHORT $LN33@ThreatIncr
	jmp	DWORD PTR $LN36@ThreatIncr[eax*4]
$LN22@ThreatIncr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2164
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2372 : 
; 2373 : 	// FUTURE: Add anything else we'd like to do to individually handle new threats from a single power
; 2374 : }

	ret	8

; 2369 : 
; 2370 : 	// Add on new threat
; 2371 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

$LN21@ThreatIncr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2372 : 
; 2373 : 	// FUTURE: Add anything else we'd like to do to individually handle new threats from a single power
; 2374 : }

	ret	8

; 2369 : 
; 2370 : 	// Add on new threat
; 2371 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

$LN20@ThreatIncr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2172
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2372 : 
; 2373 : 	// FUTURE: Add anything else we'd like to do to individually handle new threats from a single power
; 2374 : }

	ret	8

; 2369 : 
; 2370 : 	// Add on new threat
; 2371 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

$LN19@ThreatIncr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2176
$LN33@ThreatIncr:
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2372 : 
; 2373 : 	// FUTURE: Add anything else we'd like to do to individually handle new threats from a single power
; 2374 : }

	ret	8
	npad	1
$LN35@ThreatIncr:
	DD	$LN6@ThreatIncr
	DD	$LN5@ThreatIncr
	DD	$LN4@ThreatIncr
	DD	$LN3@ThreatIncr
$LN36@ThreatIncr:
	DD	$LN22@ThreatIncr
	DD	$LN21@ThreatIncr
	DD	$LN20@ThreatIncr
	DD	$LN19@ThreatIncr
?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ENDP ; CvMilitaryAI::ThreatIncrease
_TEXT	ENDS
PUBLIC	?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatDecrease
; Function compile flags: /Ogtpy
;	COMDAT ?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z
_TEXT	SEGMENT
_eNewThreat$ = 8					; size = 4
_eOldThreat$ = 12					; size = 4
?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z PROC ; CvMilitaryAI::ThreatDecrease, COMDAT
; _this$ = ecx

; 2379 : 	// Subtract off old threat
; 2380 : 	m_iTotalThreatWeight -= GetThreatWeight(eOldThreat);

	mov	edx, DWORD PTR _eOldThreat$[esp-4]
	dec	edx
	xor	eax, eax
	cmp	edx, 3
	ja	SHORT $LN17@ThreatDecr
	jmp	DWORD PTR $LN35@ThreatDecr[edx*4]
$LN6@ThreatDecr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2164
	jmp	SHORT $LN17@ThreatDecr
$LN5@ThreatDecr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	jmp	SHORT $LN17@ThreatDecr
$LN4@ThreatDecr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2172
	jmp	SHORT $LN17@ThreatDecr
$LN3@ThreatDecr:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2176
$LN17@ThreatDecr:
	sub	DWORD PTR [ecx+40], eax

; 2381 : 
; 2382 : 	// Add on new threat
; 2383 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

	mov	eax, DWORD PTR _eNewThreat$[esp-4]
	dec	eax
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR [ecx+40]
	cmp	eax, 3
	ja	SHORT $LN33@ThreatDecr
	jmp	DWORD PTR $LN36@ThreatDecr[eax*4]
$LN22@ThreatDecr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2164
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2384 : 
; 2385 : 	// FUTURE: Add anything else we'd like to do to individually handle diminishing threats from a single power
; 2386 : }

	ret	8

; 2381 : 
; 2382 : 	// Add on new threat
; 2383 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

$LN21@ThreatDecr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2384 : 
; 2385 : 	// FUTURE: Add anything else we'd like to do to individually handle diminishing threats from a single power
; 2386 : }

	ret	8

; 2381 : 
; 2382 : 	// Add on new threat
; 2383 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

$LN20@ThreatDecr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2172
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2384 : 
; 2385 : 	// FUTURE: Add anything else we'd like to do to individually handle diminishing threats from a single power
; 2386 : }

	ret	8

; 2381 : 
; 2382 : 	// Add on new threat
; 2383 : 	m_iTotalThreatWeight += GetThreatWeight(eNewThreat);

$LN19@ThreatDecr:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2176
$LN33@ThreatDecr:
	add	esi, edx
	mov	DWORD PTR [ecx+40], esi
	pop	esi

; 2384 : 
; 2385 : 	// FUTURE: Add anything else we'd like to do to individually handle diminishing threats from a single power
; 2386 : }

	ret	8
	npad	1
$LN35@ThreatDecr:
	DD	$LN6@ThreatDecr
	DD	$LN5@ThreatDecr
	DD	$LN4@ThreatDecr
	DD	$LN3@ThreatDecr
$LN36@ThreatDecr:
	DD	$LN22@ThreatDecr
	DD	$LN21@ThreatDecr
	DD	$LN20@ThreatDecr
	DD	$LN19@ThreatDecr
?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ENDP ; CvMilitaryAI::ThreatDecrease
_TEXT	ENDS
PUBLIC	?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::LogStrategy
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z:PROC ; CvGlobals::getMilitaryAIStrategyInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$16
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
_iLoop$228227 = -296					; size = 4
$T232376 = -292						; size = 28
$T232372 = -292						; size = 28
$T232370 = -292						; size = 28
$T232367 = -292						; size = 28
$T232365 = -292						; size = 28
_strLogName$228204 = -264				; size = 28
_playerName$228203 = -236				; size = 28
_strOutBuf$228200 = -208				; size = 28
_cityName$228225 = -180					; size = 28
$T232366 = -180						; size = 28
$T232377 = -152						; size = 28
$T232373 = -152						; size = 28
$T232371 = -152						; size = 28
_strBaseString$228201 = -124				; size = 28
_strTemp$228202 = -96					; size = 28
$T232375 = -68						; size = 28
$T232374 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z PROC ; CvMilitaryAI::LogStrategy, COMDAT
; _this$ = ecx

; 3943 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	mov	ebx, ecx

; 3944 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN8@LogStrateg
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN8@LogStrateg

; 3945 : 	{
; 3946 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228200[esp+300]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3947 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$228201[esp+300]
	mov	DWORD PTR __$EHRec$[esp+308], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3948 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228202[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3949 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$228203[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3950 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$228204[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3951 : 		FILogFile* pLog;
; 3952 : 
; 3953 : 		// Open the right file - strategies are logged to the flavor log, not the military one
; 3954 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [ebx]
	mov	BYTE PTR __$EHRec$[esp+308], 4
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$228203[esp+300]
	test	eax, eax
	je	SHORT $LN48@LogStrateg
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN47@LogStrateg
$LN48@LogStrateg:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN47@LogStrateg:
	push	ebp
	push	esi
	push	edi

; 3955 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	test	al, al
	je	SHORT $LN7@LogStrateg

; 3956 : 		{
; 3957 : 			strLogName = "FlavorAILog_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$228203[esp+312]
	push	eax
	lea	ecx, DWORD PTR $T232365[esp+316]
	push	OFFSET $SG228210
	push	ecx
	call	ebp
	push	OFFSET $SG228209
	push	eax
	lea	edx, DWORD PTR $T232366[esp+332]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+344], 5
	call	edi
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$228204[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232366[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232365[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3958 : 		}
; 3959 : 		else

	jmp	SHORT $LN53@LogStrateg
$LN7@LogStrateg:

; 3960 : 		{
; 3961 : 			strLogName = "FlavorAILog.csv";

	push	OFFSET $SG228212
	lea	ecx, DWORD PTR _strLogName$228204[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN53@LogStrateg:

; 3962 : 		}
; 3963 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$228204[esp+312]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 3964 : 
; 3965 : 		// Get the leading info for this line
; 3966 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228201[esp+316]
	push	OFFSET $SG228213
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3967 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG228215
	lea	edx, DWORD PTR _playerName$228203[esp+328]
	push	edx
	lea	eax, DWORD PTR $T232367[esp+332]
	push	eax
	call	edi
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228201[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 7
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232367[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3968 : 
; 3969 : 		// Strategy Info
; 3970 : 		CvMilitaryAIStrategyXMLEntry* pEntry = GC.getMilitaryAIStrategyInfo(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$[esp+308]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMilitaryAIStrategyInfo@CvGlobals@@QAEPAVCvMilitaryAIStrategyXMLEntry@@W4MilitaryAIStrategyTypes@@@Z ; CvGlobals::getMilitaryAIStrategyInfo

; 3971 : 		const char* szType = (pEntry != NULL)? pEntry->GetType() : NULL;

	test	eax, eax
	je	SHORT $LN11@LogStrateg
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN12@LogStrateg
$LN11@LogStrateg:
	xor	eax, eax
$LN12@LogStrateg:

; 3972 : 
; 3973 : 		strTemp.Format("%s, %d", szType, bValue);

	movzx	edx, BYTE PTR _bValue$[esp+308]
	push	edx
	push	eax
	lea	eax, DWORD PTR _strTemp$228202[esp+320]
	push	OFFSET $SG228218
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3974 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$228202[esp+328]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$228201[esp+332]
	push	edx
	lea	eax, DWORD PTR $T232370[esp+336]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+320], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228200[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232370[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3975 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228200[esp+312]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 3976 : 
; 3977 : 		// Also - write to Other Logs, so that we know what the player is doing in there as well
; 3978 : 
; 3979 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	$LN5@LogStrateg

; 3980 : 		{
; 3981 : 			strLogName = "TechAILog_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$228203[esp+312]
	push	eax
	lea	ecx, DWORD PTR $T232371[esp+316]
	push	OFFSET $SG228224
	push	ecx
	call	ebp
	push	OFFSET $SG228223
	push	eax
	lea	edx, DWORD PTR $T232372[esp+332]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+344], 9
	call	edi
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+320], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$228204[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232372[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232371[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3982 : 			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$228204[esp+312]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 3983 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228200[esp+312]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 3984 : 
; 3985 : 			CvString cityName;

	lea	ecx, DWORD PTR _cityName$228225[esp+312]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3986 : 
; 3987 : 			CvCity* pLoopCity;
; 3988 : 			int iLoop;
; 3989 : 
; 3990 : 			for(pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebx]
	push	0
	lea	eax, DWORD PTR _iLoop$228227[esp+316]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+328], 11		; 0000000bH
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	$LN2@LogStrateg
	npad	3
$LL115@LogStrateg:

; 3991 : 			{
; 3992 : 				cityName = pLoopCity->getName();

	lea	ecx, DWORD PTR $T232373[esp+312]
	push	ecx
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _cityName$228225[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 12		; 0000000cH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232373[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3993 : 				strLogName= "CityStrategyAILog_" + playerName + "_" + cityName + ".csv";

	lea	edx, DWORD PTR _playerName$228203[esp+312]
	push	edx
	lea	eax, DWORD PTR $T232374[esp+316]
	push	OFFSET $SG228238
	push	eax
	call	ebp
	push	OFFSET $SG228237
	push	eax
	lea	ecx, DWORD PTR $T232375[esp+332]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+344], 13		; 0000000dH
	call	edi
	lea	edx, DWORD PTR _cityName$228225[esp+336]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T232376[esp+344]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+356], 14		; 0000000eH
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG228236
	push	eax
	lea	ecx, DWORD PTR $T232377[esp+356]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+368], 15		; 0000000fH
	call	edi
	add	esp, 48					; 00000030H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+320], 16		; 00000010H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$228204[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232377[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232376[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 14		; 0000000eH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232375[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232374[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3994 : 				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$228204[esp+312]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 3995 : 				pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228200[esp+312]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	mov	ecx, DWORD PTR [ebx]
	add	esp, 8
	push	0
	lea	eax, DWORD PTR _iLoop$228227[esp+316]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	$LL115@LogStrateg
$LN2@LogStrateg:

; 3996 : 			}
; 3997 : 		}

	lea	ecx, DWORD PTR _cityName$228225[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3998 : 		else

	jmp	SHORT $LN1@LogStrateg
$LN5@LogStrateg:

; 3999 : 		{
; 4000 : 			pLog = LOGFILEMGR.GetLog("CityStrategyAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	0
	push	1
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	OFFSET $SG228240
	call	eax

; 4001 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228200[esp+312]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 4002 : 			pLog = LOGFILEMGR.GetLog("TechAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	0
	push	1
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	OFFSET $SG228241
	call	eax

; 4003 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228200[esp+312]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8
$LN1@LogStrateg:

; 4004 : 		}
; 4005 : 	}

	lea	ecx, DWORD PTR _strLogName$228204[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$228203[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228202[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$228201[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$228200[esp+312]
	mov	DWORD PTR __$EHRec$[esp+320], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
$LN8@LogStrateg:

; 4006 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+300]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 296				; 00000128H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$228200[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strBaseString$228201[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$2:
	lea	ecx, DWORD PTR _strTemp$228202[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$3:
	lea	ecx, DWORD PTR _playerName$228203[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$4:
	lea	ecx, DWORD PTR _strLogName$228204[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T232365[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$6:
	lea	ecx, DWORD PTR $T232366[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$7:
	lea	ecx, DWORD PTR $T232367[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T232370[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$9:
	lea	ecx, DWORD PTR $T232371[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$10:
	lea	ecx, DWORD PTR $T232372[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$11:
	lea	ecx, DWORD PTR _cityName$228225[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T232373[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T232374[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T232375[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T232376[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z$16:
	lea	ecx, DWORD PTR $T232377[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ENDP ; CvMilitaryAI::LogStrategy
PUBLIC	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$2
__ehfuncinfo$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
_TEXT	SEGMENT
$T232544 = -72						; size = 4
$T232542 = -68						; size = 28
$T232541 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
_bSummary$ = 16						; size = 1
?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z PROC ; CvMilitaryAI::GetLogFileName, COMDAT
; _this$ = ecx

; 4280 : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T232544[esp+80], ebx

; 4281 : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4296 : 		}
; 4297 : 	}
; 4298 : 
; 4299 : 	return strLogName;

	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	DWORD PTR $T232544[esp+80], 1
	cmp	BYTE PTR _bSummary$[esp+76], bl
	je	SHORT $LN4@GetLogFile

; 4282 : 
; 4283 : 	if (bSummary)
; 4284 : 	{
; 4285 : 		strLogName = "MilitarySummary.csv";

	push	OFFSET $SG228414

; 4286 : 	}
; 4287 : 	else

	jmp	$LN25@GetLogFile
$LN4@GetLogFile:

; 4288 : 	{
; 4289 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN2@GetLogFile

; 4290 : 		{
; 4291 : 			strLogName = "MilitaryAILog_" + playerName + ".csv";

	mov	eax, DWORD PTR _playerName$[esp+76]
	push	eax
	lea	ecx, DWORD PTR $T232541[esp+84]
	push	OFFSET $SG228420
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG228419
	push	eax
	lea	edx, DWORD PTR $T232542[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+88], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232542[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232541[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4296 : 		}
; 4297 : 	}
; 4298 : 
; 4299 : 	return strLogName;

	mov	eax, esi
	pop	esi
	pop	ebx

; 4300 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	12					; 0000000cH
$LN2@GetLogFile:

; 4292 : 		}
; 4293 : 		else
; 4294 : 		{
; 4295 : 			strLogName = "MilitaryAILog.csv";

	push	OFFSET $SG228422
$LN25@GetLogFile:
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 4300 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$0:
	mov	eax, DWORD PTR $T232544[ebp]
	and	eax, 1
	je	$LN8@GetLogFile
	and	DWORD PTR $T232544[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN8@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$1:
	lea	ecx, DWORD PTR $T232541[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z$2:
	lea	ecx, DWORD PTR $T232542[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ENDP ; CvMilitaryAI::GetLogFileName
PUBLIC	?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::GetWeightThresholdModifier
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iWeightThresholdModifier$ = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::GetWeightThresholdModifier, COMDAT

; 4311 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 4312 : 	int iWeightThresholdModifier = 0;
; 4313 : 
; 4314 : 	CvMilitaryAIStrategyXMLEntries* pkAIStrategies = pPlayer->GetMilitaryAI()->GetMilitaryAIStrategies();

	mov	esi, DWORD PTR _pPlayer$[esp+12]
	xor	ebp, ebp
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _iWeightThresholdModifier$[esp+20], ebp
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	edi, DWORD PTR [eax+8]

; 4315 : 	CvFlavorManager* pkFlavorManager = pPlayer->GetFlavorManager();

	mov	ecx, esi
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager

; 4316 : 	// Look at all Flavors for the Player & this Strategy
; 4317 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	mov	ebx, eax
	jle	SHORT $LN21@GetWeightT
	mov	ebp, DWORD PTR _eStrategy$[esp+16]
$LL4@GetWeightT:

; 4318 : 	{
; 4319 : 		FlavorTypes eFlavor = (FlavorTypes) iFlavorLoop;
; 4320 : 		int iPersonalityFlavor = pkFlavorManager->GetPersonalityIndividualFlavor(eFlavor);

	push	esi
	mov	ecx, ebx
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 4321 : 		CvMilitaryAIStrategyXMLEntry* pkEntry = pkAIStrategies->GetEntry(eStrategy);

	mov	ecx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+ebp*4]

; 4322 : 		CvAssert(pkEntry != NULL);
; 4323 : 		if(pkEntry)

	test	ecx, ecx
	je	SHORT $LN3@GetWeightT

; 4324 : 		{
; 4325 : 			int iStrategyFlavorMod = pkEntry->GetPersonalityFlavorThresholdMod(eFlavor);

	mov	ecx, DWORD PTR [ecx+272]
	test	ecx, ecx
	je	SHORT $LN17@GetWeightT
	mov	ecx, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN18@GetWeightT
$LN17@GetWeightT:
	or	ecx, -1
$LN18@GetWeightT:

; 4326 : 
; 4327 : 			iWeightThresholdModifier += (iPersonalityFlavor * iStrategyFlavorMod);

	imul	ecx, eax
	add	DWORD PTR _iWeightThresholdModifier$[esp+20], ecx
$LN3@GetWeightT:
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL4@GetWeightT

; 4328 : 		}
; 4329 : 	}
; 4330 : 
; 4331 : 	return iWeightThresholdModifier;

	mov	eax, DWORD PTR _iWeightThresholdModifier$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4332 : }

	pop	ecx
	ret	0
$LN21@GetWeightT:
	pop	edi
	pop	esi

; 4328 : 		}
; 4329 : 	}
; 4330 : 
; 4331 : 	return iWeightThresholdModifier;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 4332 : }

	pop	ecx
	ret	0
?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::GetWeightThresholdModifier
_TEXT	ENDS
PUBLIC	?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WarMobilization
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarGoal
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_WarMobilization, COMDAT

; 4418 : {

	push	ebx
	push	ebp
	push	esi

; 4419 : 	int iCurrentWeight = 0;

	xor	ebp, ebp

; 4420 : 	PlayerTypes eOtherPlayer;
; 4421 : 
; 4422 : 	// If we're at war don't bother with this Strategy
; 4423 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	ebp
	push	OFFSET $SG228483
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4424 : 
; 4425 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	mov	ebx, DWORD PTR _pPlayer$[esp+8]
	mov	esi, eax
	cmp	esi, -1
	je	SHORT $LN16@IsTestStra@4

; 4426 : 	{
; 4427 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	ecx, ebx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	eax, DWORD PTR [eax+12]
	cmp	BYTE PTR [esi+eax], 0

; 4428 : 		{
; 4429 : 			return false;

	jne	$LN1@IsTestStra@4
$LN16@IsTestStra@4:

; 4430 : 		}
; 4431 : 	}
; 4432 : 
; 4433 : 	// Are we running the Conquest Grand Strategy?
; 4434 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET $SG228488
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4435 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	esi, -1
	je	SHORT $LN14@IsTestStra@4

; 4436 : 	{
; 4437 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	ecx, ebx
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, esi
	jne	SHORT $LN14@IsTestStra@4

; 4438 : 		{
; 4439 : 			iCurrentWeight += 25;

	mov	ebp, 25					; 00000019H
$LN14@IsTestStra@4:
	push	edi

; 4440 : 		}
; 4441 : 	}
; 4442 : 
; 4443 : 	CvDiplomacyAI* pkDiplomacyAI = pPlayer->GetDiplomacyAI();

	mov	ecx, ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	edi, eax

; 4444 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	esi, esi
	npad	1
$LL13@IsTestStra@4:

; 4445 : 	{
; 4446 : 		eOtherPlayer = (PlayerTypes) iMajorLoop;
; 4447 : 
; 4448 : 		// Mobilize for war is automatic if we are preparing a sneak attack
; 4449 : 		if(pkDiplomacyAI->GetWarGoal(eOtherPlayer) == WAR_GOAL_PREPARE || pPlayer->GetMilitaryAI()->GetArmyBeingBuilt() != NO_ARMY_TYPE)

	push	esi
	mov	ecx, edi
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, 1
	je	SHORT $LN34@IsTestStra@4
	mov	ecx, ebx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+44], -1
	jne	SHORT $LN34@IsTestStra@4

; 4452 : 		}
; 4453 : 
; 4454 : 		// Add in weight for each civ we're on really bad terms with
; 4455 : 		else if(pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_WAR ||
; 4456 : 		        pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_HOSTILE ||
; 4457 : 		        pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_AFRAID)

	push	0
	push	esi
	mov	ecx, edi
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	test	eax, eax
	je	SHORT $LN6@IsTestStra@4
	push	0
	push	esi
	mov	ecx, edi
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 1
	je	SHORT $LN6@IsTestStra@4
	push	0
	push	esi
	mov	ecx, edi
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 4
	je	SHORT $LN6@IsTestStra@4

; 4465 : 		        pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_DECEPTIVE)

	push	0
	push	esi
	mov	ecx, edi
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 3
	je	SHORT $LN3@IsTestStra@4
	push	0
	push	esi
	mov	ecx, edi
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 2
	jne	SHORT $LN12@IsTestStra@4
$LN3@IsTestStra@4:

; 4466 : 		{
; 4467 : 			iCurrentWeight += 25;

	add	ebp, 25					; 00000019H
	jmp	SHORT $LN12@IsTestStra@4
$LN6@IsTestStra@4:

; 4458 : 		{
; 4459 : 			iCurrentWeight += 50;

	add	ebp, 50					; 00000032H

; 4460 : 		}
; 4461 : 
; 4462 : 		// And some if on fairly bad terms
; 4463 : 		// Add in weight for each civ we're on really bad terms with
; 4464 : 		else if(pkDiplomacyAI->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false) == MAJOR_CIV_APPROACH_GUARDED ||

	jmp	SHORT $LN12@IsTestStra@4
$LN34@IsTestStra@4:

; 4450 : 		{
; 4451 : 			iCurrentWeight += 100;

	add	ebp, 100				; 00000064H
$LN12@IsTestStra@4:

; 4444 : 	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL13@IsTestStra@4

; 4468 : 		}
; 4469 : 	}
; 4470 : 
; 4471 : 	CvMilitaryAIStrategyXMLEntry* pStrategy = pPlayer->GetMilitaryAI()->GetMilitaryAIStrategies()->GetEntry(eStrategy);

	mov	ecx, ebx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _eStrategy$[esp+12]
	mov	eax, DWORD PTR [edx+eax*4]
	pop	edi

; 4472 : 	CvAssert(pStrategy != NULL);
; 4473 : 	if(pStrategy)

	test	eax, eax
	je	SHORT $LN1@IsTestStra@4

; 4474 : 	{
; 4475 : 		int iWeightThreshold = pStrategy->GetWeightThreshold();	// 100
; 4476 : 		if(iCurrentWeight >= iWeightThreshold)

	cmp	ebp, DWORD PTR [eax+268]
	jl	SHORT $LN1@IsTestStra@4
	pop	esi
	pop	ebp

; 4477 : 		{
; 4478 : 			return true;

	mov	al, 1
	pop	ebx

; 4483 : }

	ret	0
$LN1@IsTestStra@4:
	pop	esi
	pop	ebp

; 4479 : 		}
; 4480 : 	}
; 4481 : 
; 4482 : 	return false;

	xor	al, al
	pop	ebx

; 4483 : }

	ret	0
?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_WarMobilization
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
$T232639 = 12						; size = 4
_iNumRanged$ = 12					; size = 4
$T232640 = 16						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits, COMDAT

; 4609 : {

	push	esi

; 4610 : 	int iFlavorRange = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RANGED"));

	push	0
	push	OFFSET $SG228576
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _pPlayer$[esp]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4611 : 	int iRatio = iNumRanged * 10 / max(1,iNumMelee+iNumRanged);

	mov	ecx, DWORD PTR _iNumMelee$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR _iNumRanged$[esp]
	add	ecx, eax
	mov	DWORD PTR $T232639[esp], ecx
	cmp	ecx, 1
	mov	DWORD PTR $T232640[esp], 1
	lea	ecx, DWORD PTR $T232639[esp]
	jg	SHORT $LN6@IsTestStra@5
	lea	ecx, DWORD PTR $T232640[esp]
$LN6@IsTestStra@5:
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [ecx]

; 4612 : 	return (iRatio >= iFlavorRange);

	xor	edx, edx
	cmp	eax, esi
	setge	dl
	mov	al, dl
	pop	esi

; 4613 : }

	ret	0
?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
$T232653 = 12						; size = 4
_iNumRanged$ = 12					; size = 4
$T232654 = 16						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits, COMDAT

; 4617 : {

	push	esi

; 4618 : 	int iFlavorRange = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RANGED"));

	push	0
	push	OFFSET $SG228587
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _pPlayer$[esp]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4619 : 	int iRatio = iNumRanged * 10 / max(1,iNumMelee+iNumRanged);

	mov	ecx, DWORD PTR _iNumMelee$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR _iNumRanged$[esp]
	add	ecx, eax
	mov	DWORD PTR $T232653[esp], ecx
	cmp	ecx, 1
	mov	DWORD PTR $T232654[esp], 1
	lea	ecx, DWORD PTR $T232653[esp]
	jg	SHORT $LN6@IsTestStra@6
	lea	ecx, DWORD PTR $T232654[esp]
$LN6@IsTestStra@6:
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [ecx]
	mov	ecx, eax

; 4620 : 	return (iRatio <= iFlavorRange / 2);

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	edx, edx
	cmp	ecx, eax
	setle	dl
	mov	al, dl
	pop	esi

; 4621 : }

	ret	0
?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
$T232667 = 12						; size = 4
_iNumMobile$ = 12					; size = 4
$T232668 = 16						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits, COMDAT

; 4639 : {

	push	esi

; 4640 : 	int iFlavorMobile = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_MOBILE"));

	push	0
	push	OFFSET $SG228606
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _pPlayer$[esp]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4641 : 	int iRatio = iNumMobile * 10 / max(1,iNumMelee+iNumMobile);

	mov	ecx, DWORD PTR _iNumMelee$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR _iNumMobile$[esp]
	add	ecx, eax
	mov	DWORD PTR $T232667[esp], ecx
	cmp	ecx, 1
	mov	DWORD PTR $T232668[esp], 1
	lea	ecx, DWORD PTR $T232667[esp]
	jg	SHORT $LN6@IsTestStra@7
	lea	ecx, DWORD PTR $T232668[esp]
$LN6@IsTestStra@7:
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [ecx]

; 4642 : 	return (iRatio >= iFlavorMobile);

	xor	edx, edx
	cmp	eax, esi
	setge	dl
	mov	al, dl
	pop	esi

; 4643 : }

	ret	0
?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
$T232681 = 12						; size = 4
_iNumMobile$ = 12					; size = 4
$T232682 = 16						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits, COMDAT

; 4647 : {

	push	esi

; 4648 : 	int iFlavorMobile = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_MOBILE"));

	push	0
	push	OFFSET $SG228617
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _pPlayer$[esp]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4649 : 	int iRatio = iNumMobile * 10 / max(1,iNumMelee+iNumMobile);

	mov	ecx, DWORD PTR _iNumMelee$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR _iNumMobile$[esp]
	add	ecx, eax
	mov	DWORD PTR $T232681[esp], ecx
	cmp	ecx, 1
	mov	DWORD PTR $T232682[esp], 1
	lea	ecx, DWORD PTR $T232681[esp]
	jg	SHORT $LN6@IsTestStra@8
	lea	ecx, DWORD PTR $T232682[esp]
$LN6@IsTestStra@8:
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [ecx]
	mov	ecx, eax

; 4650 : 	return (iRatio <= iFlavorMobile / 2);

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	edx, edx
	cmp	ecx, eax
	setle	dl
	mov	al, dl
	pop	esi

; 4651 : }

	ret	0
?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
$T232695 = 12						; size = 4
_iNumAir$ = 12						; size = 4
$T232696 = 16						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits, COMDAT

; 4655 : {

	push	esi

; 4656 : 	int iFlavorAir = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_AIR"));

	push	0
	push	OFFSET $SG228628
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _pPlayer$[esp]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4657 : 	int iRatio = iNumAir * 10 / max(1,iNumMelee+iNumAir);

	mov	ecx, DWORD PTR _iNumMelee$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR _iNumAir$[esp]
	add	ecx, eax
	mov	DWORD PTR $T232695[esp], ecx
	cmp	ecx, 1
	mov	DWORD PTR $T232696[esp], 1
	lea	ecx, DWORD PTR $T232695[esp]
	jg	SHORT $LN6@IsTestStra@9
	lea	ecx, DWORD PTR $T232696[esp]
$LN6@IsTestStra@9:
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [ecx]

; 4658 : 	return (iRatio >= iFlavorAir);

	xor	edx, edx
	cmp	eax, esi
	setge	dl
	mov	al, dl
	pop	esi

; 4659 : }

	ret	0
?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
$T232709 = 12						; size = 4
_iNumAir$ = 12						; size = 4
$T232710 = 16						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits, COMDAT

; 4663 : {

	push	esi

; 4664 : 	int iFlavorAir = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_AIR"));

	push	0
	push	OFFSET $SG228639
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _pPlayer$[esp]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4665 : 	int iRatio = iNumAir * 10 / max(1,iNumMelee+iNumAir);

	mov	ecx, DWORD PTR _iNumMelee$[esp]
	mov	esi, eax
	mov	eax, DWORD PTR _iNumAir$[esp]
	add	ecx, eax
	mov	DWORD PTR $T232709[esp], ecx
	cmp	ecx, 1
	mov	DWORD PTR $T232710[esp], 1
	lea	ecx, DWORD PTR $T232709[esp]
	jg	SHORT $LN6@IsTestStra@10
	lea	ecx, DWORD PTR $T232710[esp]
$LN6@IsTestStra@10:
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [ecx]
	mov	ecx, eax

; 4666 : 	return (iRatio <= iFlavorAir / 2);

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	edx, edx
	cmp	ecx, eax
	setle	dl
	mov	al, dl
	pop	esi

; 4667 : }

	ret	0
?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedANuke
EXTRN	?isNoNukes@CvGame@@QBE_NXZ:PROC			; CvGame::isNoNukes
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedANuke, COMDAT

; 4672 : 	if(GC.getGame().isNoNukes())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNoNukes@CvGame@@QBE_NXZ		; CvGame::isNoNukes
	test	al, al
	je	SHORT $LN1@IsTestStra@11

; 4673 : 	{
; 4674 : 		return false;

	xor	al, al

; 4681 : }

	ret	0
$LN1@IsTestStra@11:
	push	esi
	push	edi

; 4675 : 	}
; 4676 : 
; 4677 : 	int iFlavorNuke = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NUKE"));

	push	0
	push	OFFSET $SG228649
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, DWORD PTR _pPlayer$[esp+4]
	push	eax
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4678 : 	int iNumNukes = pPlayer->getNumNukeUnits();

	mov	ecx, esi
	mov	edi, eax
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	mov	ecx, eax

; 4679 : 
; 4680 : 	return (iNumNukes < iFlavorNuke / 3);

	mov	eax, 1431655766				; 55555556H
	imul	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	edx, edx
	cmp	ecx, eax
	setl	dl
	pop	edi
	mov	al, dl
	pop	esi

; 4681 : }

	ret	0
?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedANuke
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@2

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@2:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@2

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@2:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z	; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z PROC	; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 195  : 	{

	push	esi
	push	edi

; 196  : 		if(&rhs != this)

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	edi, esi
	je	SHORT $LN11@operator@3

; 197  : 		{
; 198  : 			OBJECT_HANDLE_STACK;
; 199  : 			if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@operator@3

; 200  : 			{
; 201  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@operator@3:

; 202  : 			}
; 203  : 			const_cast<FObjectHandle *>(this)->m_target = rhs.m_target;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 204  : 			if(m_target)

	test	ecx, ecx
	je	SHORT $LN11@operator@3

; 205  : 			{
; 206  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@operator@3:
	pop	edi

; 207  : 			}
; 208  : 		}
; 209  : 		return *this;

	mov	eax, esi
	pop	esi

; 210  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z ENDP	; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvMilitaryAIStrategyXMLEntry@@XZ ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvMilitaryAIStrategyXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvMilitaryAIStrategyXMLEntry@@XZ PROC ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvMilitaryAIStrategyXMLEntry@@XZ ENDP ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEABUCvMilitaryTarget@@I@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEABUCvMilitaryTarget@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEABUCvMilitaryTarget@@I@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR _iIndex$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEABUCvMilitaryTarget@@I@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::GetElement
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEHI@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -28						; size = 28
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEHI@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::GetWeight, COMDAT
; _this$ = ecx

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	sub	esp, 28					; 0000001cH
	push	esi
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	push	edi
	lea	esi, DWORD PTR [eax+edx*4]
	mov	ecx, 7
	lea	edi, DWORD PTR _elem$[esp+36]
	rep movsd

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR _elem$[esp+60]
	pop	edi
	pop	esi

; 75   : 	}

	add	esp, 28					; 0000001cH
	ret	4
?GetWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QBEHI@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::GetWeight
_TEXT	ENDS
PUBLIC	?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR [ecx+4]
	push	ebp
	push	esi
	push	edi

; 90   : 		int rtnValue = 0;

	xor	edx, edx
	xor	esi, esi
	xor	edi, edi

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	xor	ebp, ebp
	cmp	ebx, 2
	mov	DWORD PTR _rtnValue$[esp+20], edx
	jl	SHORT $LC15@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ebx-2]
	shr	edx, 1
	add	eax, 52					; 00000034H
	inc	edx
	lea	ebp, DWORD PTR [edx+edx]
$LL16@GetTotalWe:
	add	esi, DWORD PTR [eax-28]
	add	edi, DWORD PTR [eax]
	add	eax, 56					; 00000038H
	sub	edx, 1
	jne	SHORT $LL16@GetTotalWe
	mov	edx, DWORD PTR _rtnValue$[esp+20]
$LC15@GetTotalWe:

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	cmp	ebp, ebx
	jae	SHORT $LN14@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ebp*8]
	sub	eax, ebp
	mov	edx, DWORD PTR [ecx+eax*4+24]
$LN14@GetTotalWe:
	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	pop	ebp

; 96   : 		}
; 97   : 
; 98   : 		return rtnValue;

	add	eax, edx
	pop	ebx

; 99   : 	};

	pop	ecx
	ret	0
?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ; CvWeightedVector<CvMilitaryTarget,640,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::size
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 10			; 0000000aH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::FStaticVector<CvFormationSlotEntry,10,0,297,0>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z PROC ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@1@@Z ENDP ; std::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_val<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z PROC ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvMilitaryAIStrategyXMLEntry@@@Z ENDP ; std::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Vector_iterator<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 640			; 00000280H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z PROC	; fastdelegate::FastDelegate2<int,char const *,int>::operator(), COMDAT
; _this$ = ecx

; 1080 : 	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	eax
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::operator()
_TEXT	ENDS
PUBLIC	?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ; fastdelegate::FastDelegate2<int,char const *,int>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::clear, COMDAT
; _this$ = ecx

; 1101 : 	void clear() { m_Closure.clear();}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::clear
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEPAPAVCvCity@@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEPAPAVCvCity@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEPAPAVCvCity@@I@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@3

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@3:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEPAPAVCvCity@@I@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXPAPAVCvCity@@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXPAPAVCvCity@@I@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXPAPAVCvCity@@I@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXPAVCvFormationSlotEntry@@I@Z ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z PROC ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@QAEPAPAVCvMilitaryAIStrategyXMLEntry@@I@Z ENDP ; std::allocator<CvMilitaryAIStrategyXMLEntry *>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z PROC ; operator>><bool>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 518  : 	ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@4
	push	ebp
	mov	ebp, DWORD PTR _loadFrom$[esp+12]
$LL3@operator@4:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@4

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
$LN14@operator@4:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ENDP ; operator>><bool>
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@5
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@5:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@5

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@5:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 505  : 	const ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@6
	push	ebp
	mov	ebp, DWORD PTR _saveTo$[esp+12]
$LL3@operator@6:

; 507  : 	{
; 508  : 		saveTo << values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@6

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
$LN14@operator@6:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 505  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@7
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@7:

; 507  : 	{
; 508  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@7

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 511  : }

	ret	0
$LN14@operator@7:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 511  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z
_TEXT	SEGMENT
_pParent$ = 8						; size = 4
_right$ = 12						; size = 4
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >, COMDAT
; _this$ = ecx

; 763  : #endif
; 764  : 		SetMementoFrom(right);

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 765  : 	}

	ret	8
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvMilitaryAIStrategyXMLEntry * *,CvMilitaryAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvMilitaryAIStrategyXMLEntry@@0AAV?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>, COMDAT
; _this$ = ecx

; 673  : 		m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
; 674  : 			::Convert(pthis, function_to_bind, m_pFunction);

	mov	eax, DWORD PTR _function_to_bind$[esp-4]
	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx

; 675  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 676  : 		m_pStaticFunction = 0;
; 677  : #endif
; 678  : 	}

	ret	8
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::iter_swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	jmp	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	esi

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	esi, DWORD PTR __Mid$[esp]
	mov	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	eax, DWORD PTR [edi+24]
	jle	SHORT $LN8@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	push	edi
	push	esi
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN8@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	eax, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR [esi+24]
	jle	SHORT $LN12@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	push	esi
	push	eax
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN12@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [esi+24]
	cmp	edx, DWORD PTR [edi+24]
	jle	SHORT $LN16@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	push	edi
	push	esi
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN16@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 28
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	ecx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	edx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Bottom$[esp]
	push	ebp
	lea	eax, DWORD PTR [ecx+ecx+2]
	cmp	eax, ebx
	push	esi
	push	edi
	mov	ebp, ecx
	jge	SHORT $LN14@Adjust_hea
	npad	6
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	mov	edi, DWORD PTR [edx+esi*4+24]
	cmp	edi, DWORD PTR [edx+esi*4-4]
	lea	esi, DWORD PTR [edx+esi*4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	lea	edi, DWORD PTR [ecx*8]
	sub	edi, ecx
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	lea	esi, DWORD PTR [edx+esi*4]
	lea	edi, DWORD PTR [edx+edi*4]
	mov	ecx, 7
	rep movsd
	mov	ecx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, ebx
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	lea	eax, DWORD PTR [ebx*8]
	sub	eax, ebx
	lea	esi, DWORD PTR [edx+eax*4-28]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	edi, DWORD PTR [edx+eax*4]
	mov	ecx, 7
	rep movsd

; 2069 : 		_Hole = _Bottom - 1;

	lea	ecx, DWORD PTR [ebx-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+12]
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+44]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR __Val$[esp+48]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR __Val$[esp+52]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR __Val$[esp+56]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR __Val$[esp+60]
	push	ebp
	mov	DWORD PTR [eax+20], esi
	mov	esi, DWORD PTR __Val$[esp+68]
	push	ecx
	push	edx
	mov	DWORD PTR [eax+24], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 40					; 00000028H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN7@unchecked_@2
	push	esi
	push	edi
$LL8@unchecked_@2:
	sub	edx, 28					; 0000001cH
	sub	eax, 28					; 0000001cH
	mov	ecx, 7
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL8@unchecked_@2
	pop	edi
	pop	esi
$LN7@unchecked_@2:
	pop	ebx

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 28
___formal$ = 48						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2079 : 	{	// pop *_First to *_Dest and reheap, using operator<

	push	ebx

; 2080 : 	*_Dest = *_First;

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	ecx, 7
	mov	esi, ebx
	rep movsd
	mov	ecx, DWORD PTR __Val$[esp+36]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$[esp+40]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$[esp+44]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$[esp+48]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR __Val$[esp+52]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Val$[esp+56]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR __Val$[esp+60]
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, DWORD PTR __Last$[esp+36]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	0
	push	ebx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 40					; 00000028H

; 2082 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?GetDeployFromOperationTurn@CvUnit@@QBEHXZ	; CvUnit::GetDeployFromOperationTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployFromOperationTurn@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetDeployFromOperationTurn@CvUnit@@QBEHXZ PROC		; CvUnit::GetDeployFromOperationTurn, COMDAT
; _this$ = ecx

; 697  : 		return m_iDeployFromOperationTurn;

	mov	eax, DWORD PTR [ecx+124]

; 698  : 	};

	ret	0
?GetDeployFromOperationTurn@CvUnit@@QBEHXZ ENDP		; CvUnit::GetDeployFromOperationTurn
_TEXT	ENDS
PUBLIC	?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ; CvUnit::isTerrainImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z PROC ; CvUnit::isTerrainImpassable, COMDAT
; _this$ = ecx

; 1125 : 		return m_terrainImpassableCount[eIndex] > 0;

	mov	eax, DWORD PTR [ecx+1996]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+edx*4], ecx
	setg	cl
	mov	al, cl

; 1126 : 	}

	ret	4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ENDP ; CvUnit::isTerrainImpassable
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1096 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1097 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1172 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1173 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 219  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 220  : 	{
; 221  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
$LN2@plotDirect:

; 222  : 	}
; 223  : 	else
; 224  : 	{
; 225  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 226  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 227  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 228  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 229  : 
; 230  : 		// convert from hex-space coordinates to the storage array
; 231  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ		; CvMilitaryAIStrategyXMLEntry::CvMilitaryAIStrategyXMLEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ$0
__ehfuncinfo$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ PROC		; CvMilitaryAIStrategyXMLEntry::CvMilitaryAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 38   : {

	push	-1
	push	__ehhandler$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	or	ecx, -1
	mov	DWORD PTR [esi+280], ecx
	mov	DWORD PTR [esi+284], ecx
	mov	DWORD PTR [esi+300], ecx
	lea	ecx, DWORD PTR [esi+304]
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvMilitaryAIStrategyXMLEntry@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	BYTE PTR [esi+276], al
	mov	BYTE PTR [esi+277], al
	mov	BYTE PTR [esi+278], al
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 39   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [esi+332], 1
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvMilitaryAIStrategyXMLEntry@@QAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntry::CvMilitaryAIStrategyXMLEntry
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z PROC	; CvMilitaryAIStrategyXMLEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvMilitaryAIStrategyXMLEntry@@UAE@XZ	; CvMilitaryAIStrategyXMLEntry::~CvMilitaryAIStrategyXMLEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMilitaryAIStrategyXMLEntry@@UAEPAXI@Z ENDP	; CvMilitaryAIStrategyXMLEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvMilitaryAI@@QAE@XZ				; CvMilitaryAI::~CvMilitaryAI
; Function compile flags: /Ogtpy
;	COMDAT ??1CvMilitaryAI@@QAE@XZ
_TEXT	SEGMENT
??1CvMilitaryAI@@QAE@XZ PROC				; CvMilitaryAI::~CvMilitaryAI, COMDAT
; _this$ = ecx

; 269  : 	Uninit();

	jmp	?Uninit@CvMilitaryAI@@QAEXXZ		; CvMilitaryAI::Uninit
??1CvMilitaryAI@@QAE@XZ ENDP				; CvMilitaryAI::~CvMilitaryAI
_TEXT	ENDS
PUBLIC	?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z ; CvMilitaryAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z
_TEXT	SEGMENT
_pAIStrategies$ = 8					; size = 4
_pPlayer$ = 12						; size = 4
_pDiplomacyAI$ = 16					; size = 4
?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z PROC ; CvMilitaryAI::Init, COMDAT
; _this$ = ecx

; 275  : 	// Store off the pointer to the AIStrategies active for this game
; 276  : 	m_pAIStrategies = pAIStrategies;
; 277  : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]

; 278  : 	m_pDiplomacyAI = pDiplomacyAI;

	mov	edx, DWORD PTR _pDiplomacyAI$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _pAIStrategies$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+4], edx

; 279  : 
; 280  : 	// Initialize arrays
; 281  : 	CvAssertMsg(m_pabUsingStrategy==NULL, "about to leak memory, CvMilitaryAI::m_pabUsingStrategy");
; 282  : 	m_pabUsingStrategy = FNEW(bool[m_pAIStrategies->GetNumMilitaryAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 283  : 
; 284  : 	CvAssertMsg(m_paiTurnStrategyAdopted==NULL, "about to leak memory, CvMilitaryAI::m_paiTurnStrategyAdopted");
; 285  : 	m_paiTurnStrategyAdopted = FNEW(int[m_pAIStrategies->GetNumMilitaryAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+16], eax

; 286  : 
; 287  : 	CvAssertMsg(m_aiTempFlavors==NULL, "about to leak memory, CvMilitaryAI::m_aiTempFlavors");
; 288  : 	m_aiTempFlavors = FNEW(int[GC.getNumFlavorTypes()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 289  : 
; 290  : 	CvAssertMsg(m_paeLastTurnWarState==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnWarState");
; 291  : 	m_paeLastTurnWarState = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	mov	DWORD PTR [esi+20], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 292  : 
; 293  : 	CvAssertMsg(m_paeLastTurnMilitaryThreat==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnMilitaryThreat");
; 294  : 	m_paeLastTurnMilitaryThreat = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	mov	DWORD PTR [esi+24], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 295  : 
; 296  : 	CvAssertMsg(m_paeLastTurnMilitaryStrength==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnMilitaryStrength");
; 297  : 	m_paeLastTurnMilitaryStrength = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	mov	DWORD PTR [esi+28], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 298  : 
; 299  : 	CvAssertMsg(m_paeLastTurnTargetValue==NULL, "about to leak memory, CvMilitaryAI::m_paeLastTurnTargetValue");
; 300  : 	m_paeLastTurnTargetValue = FNEW(int[MAX_CIV_PLAYERS], c_eCiv5GameplayDLL, 0);

	push	252					; 000000fcH
	mov	DWORD PTR [esi+32], eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 28					; 0000001cH

; 301  : 
; 302  : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR [esi+36], eax
	call	?Reset@CvMilitaryAI@@QAEXXZ		; CvMilitaryAI::Reset
	pop	esi

; 303  : }

	ret	12					; 0000000cH
?Init@CvMilitaryAI@@QAEXPAVCvMilitaryAIStrategyXMLEntries@@PAVCvPlayer@@PAVCvDiplomacyAI@@@Z ENDP ; CvMilitaryAI::Init
_TEXT	ENDS
PUBLIC	?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z	; CvMilitaryAI::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_temp$ = -16						; size = 4
_uiVersion$ = -12					; size = 4
_wrapm_pabUsingStrategy$ = -8				; size = 8
_iNumStrategies$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z PROC		; CvMilitaryAI::Read, COMDAT
; _this$ = ecx

; 355  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 356  : 	// Version number to maintain backwards compatibility
; 357  : 	uint uiVersion;
; 358  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+24]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+32]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 359  : 
; 360  : 	FAssertMsg(m_pAIStrategies != NULL && m_pAIStrategies->GetNumMilitaryAIStrategies() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 361  : 	kStream >> m_iTotalThreatWeight;

	lea	ecx, DWORD PTR [edi+40]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 362  : 
; 363  : 	int temp;
; 364  : 	kStream >> temp;

	lea	edx, DWORD PTR _temp$[esp+32]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 365  : 	m_eArmyTypeBeingBuilt = (ArmyType)temp;

	mov	eax, DWORD PTR _temp$[esp+32]

; 366  : 
; 367  : 	kStream >> m_iNumberOfTimesOpsBuildSkippedOver;

	lea	ecx, DWORD PTR [edi+48]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [edi+44], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 368  : 
; 369  : 	int iNumStrategies;
; 370  : 	kStream >> iNumStrategies;

	lea	edx, DWORD PTR _iNumStrategies$[esp+28]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 371  : #ifdef _MSC_VER
; 372  : #pragma warning ( push )
; 373  : #pragma warning ( disable : 6011 ) // dereferencing null : no recovery during load, go ahead and crash here.
; 374  : #endif//_MSC_VER
; 375  : 	ArrayWrapper<bool> wrapm_pabUsingStrategy(iNumStrategies, m_pabUsingStrategy);

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR _iNumStrategies$[esp+28]

; 376  : #ifdef _MSC_VER
; 377  : #pragma warning ( pop )
; 378  : #endif//_MSC_VER
; 379  : 	kStream >> wrapm_pabUsingStrategy;

	lea	edx, DWORD PTR _wrapm_pabUsingStrategy$[esp+32]
	push	edx
	push	esi
	mov	DWORD PTR _wrapm_pabUsingStrategy$[esp+40], eax
	mov	DWORD PTR _wrapm_pabUsingStrategy$[esp+44], ecx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 380  : 
; 381  : 	ArrayWrapper<int> wrapm_paiTurnStrategyAdopted(iNumStrategies, m_paiTurnStrategyAdopted);
; 382  : 	kStream >> wrapm_paiTurnStrategyAdopted;

	mov	ebp, DWORD PTR _iNumStrategies$[esp+36]
	mov	ebx, DWORD PTR [edi+16]
	add	esp, 8
	test	ebp, ebp
	jle	SHORT $LN17@Read
$LL19@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL19@Read
$LN17@Read:

; 383  : 
; 384  : 	ArrayWrapper<int> wrapm_paeLastTurnWarState(MAX_CIV_PLAYERS, m_paeLastTurnWarState);

	mov	ebx, DWORD PTR [edi+24]
	mov	ebp, 63					; 0000003fH
	npad	2

; 385  : 	kStream >> wrapm_paeLastTurnWarState;

$LL32@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL32@Read

; 386  : 
; 387  : 	ArrayWrapper<int> wrapm_paeLastTurnMilitaryThreat(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryThreat);

	mov	ebx, DWORD PTR [edi+28]
	mov	ebp, 63					; 0000003fH

; 388  : 	kStream >> wrapm_paeLastTurnMilitaryThreat;

$LL45@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL45@Read

; 389  : 
; 390  : 	ArrayWrapper<int> wrapm_paeLastTurnMilitaryStrength(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryStrength);

	mov	ebx, DWORD PTR [edi+32]
	mov	ebp, 63					; 0000003fH

; 391  : 	kStream >> wrapm_paeLastTurnMilitaryStrength;

$LL58@Read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL58@Read

; 392  : 
; 393  : 	ArrayWrapper<int> wrapm_paeLastTurnTargetValue(MAX_CIV_PLAYERS, m_paeLastTurnTargetValue);

	mov	edi, DWORD PTR [edi+36]
	lea	ebx, DWORD PTR [ebp+63]

; 394  : 	kStream >> wrapm_paeLastTurnTargetValue;

$LL71@Read:
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL71@Read
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : }

	add	esp, 16					; 00000010H
	ret	4
?Read@CvMilitaryAI@@QAEXAAVFDataStream@@@Z ENDP		; CvMilitaryAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z	; CvMilitaryAI::Write
EXTRN	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumMilitaryAIStrategyInfos
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -12					; size = 4
$T233837 = -8						; size = 8
$T233836 = 8						; size = 4
$T233835 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z PROC	; CvMilitaryAI::Write, COMDAT
; _this$ = ecx

; 399  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 402  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+20]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+32], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 403  : 
; 404  : 	FAssertMsg(GC.getNumMilitaryAIStrategyInfos() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 405  : 	kStream << m_iTotalThreatWeight;

	lea	ecx, DWORD PTR [edi+40]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 406  : 	kStream << (int)m_eArmyTypeBeingBuilt;

	mov	edx, DWORD PTR [edi+44]
	lea	eax, DWORD PTR $T233835[esp+24]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T233835[esp+28], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 407  : 	kStream << m_iNumberOfTimesOpsBuildSkippedOver;

	lea	ecx, DWORD PTR [edi+48]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 408  : 	kStream << GC.getNumMilitaryAIStrategyInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumMilitaryAIStrategyInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumMilitaryAIStrategyInfos
	lea	edx, DWORD PTR $T233836[esp+24]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T233836[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 409  : 	kStream << ArrayWrapper<bool>(m_pAIStrategies->GetNumMilitaryAIStrategies(), m_pabUsingStrategy);

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR $T233837[esp+28]
	push	eax
	sar	edx, 2
	push	esi
	mov	DWORD PTR $T233837[esp+36], ecx
	mov	DWORD PTR $T233837[esp+40], edx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>

; 410  : 	kStream << ArrayWrapper<int>(m_pAIStrategies->GetNumMilitaryAIStrategies(), m_paiTurnStrategyAdopted);

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [edi+16]
	sar	eax, 2
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN25@Write

; 400  : 	// Current version number
; 401  : 	uint uiVersion = 1;

	mov	ebp, eax
	npad	2

; 410  : 	kStream << ArrayWrapper<int>(m_pAIStrategies->GetNumMilitaryAIStrategies(), m_paiTurnStrategyAdopted);

$LL27@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL27@Write
$LN25@Write:

; 411  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnWarState);

	mov	ebx, DWORD PTR [edi+24]
	mov	ebp, 63					; 0000003fH
$LL40@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL40@Write

; 412  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryThreat);

	mov	ebx, DWORD PTR [edi+28]
	mov	ebp, 63					; 0000003fH
$LL53@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL53@Write

; 413  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnMilitaryStrength);

	mov	ebx, DWORD PTR [edi+32]
	mov	ebp, 63					; 0000003fH
$LL66@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL66@Write

; 414  : 	kStream << ArrayWrapper<int>(MAX_CIV_PLAYERS, m_paeLastTurnTargetValue);

	mov	edi, DWORD PTR [edi+36]
	lea	ebx, DWORD PTR [ebp+63]
	npad	2
$LL79@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL79@Write
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 415  : }

	add	esp, 12					; 0000000cH
	ret	4
?Write@CvMilitaryAI@@QAEXAAVFDataStream@@@Z ENDP	; CvMilitaryAI::Write
_TEXT	ENDS
PUBLIC	?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::SetUsingStrategy
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Ogtpy
;	COMDAT ?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z PROC ; CvMilitaryAI::SetUsingStrategy, COMDAT
; _this$ = ecx

; 437  : {

	push	ebx

; 438  : 	if(m_pabUsingStrategy[eStrategy] != bValue)

	mov	ebx, DWORD PTR _bValue$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR _eStrategy$[esp+8]
	add	eax, edi
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN3@SetUsingSt

; 439  : 	{
; 440  : 		m_pabUsingStrategy[eStrategy] = bValue;

	mov	BYTE PTR [eax], bl

; 441  : 
; 442  : 		if(bValue)

	test	bl, bl
	je	SHORT $LN2@SetUsingSt

; 443  : 		{
; 444  : 			SetTurnStrategyAdopted(eStrategy, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx+edi*4], eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	je	SHORT $LN11@SetUsingSt

; 449  : 		}
; 450  : 
; 451  : 		LogStrategy(eStrategy, bValue);

	push	ebx
	mov	DWORD PTR [ecx], eax
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::LogStrategy
	pop	edi
	pop	esi
	pop	ebx

; 452  : 	}
; 453  : }

	ret	8
$LN2@SetUsingSt:

; 445  : 		}
; 446  : 		else
; 447  : 		{
; 448  : 			SetTurnStrategyAdopted(eStrategy, -1);

	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+edi*4], -1
	lea	eax, DWORD PTR [edx+edi*4]
	je	SHORT $LN11@SetUsingSt
	mov	DWORD PTR [eax], -1
$LN11@SetUsingSt:

; 449  : 		}
; 450  : 
; 451  : 		LogStrategy(eStrategy, bValue);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::LogStrategy
$LN3@SetUsingSt:
	pop	edi
	pop	esi
	pop	ebx

; 452  : 	}
; 453  : }

	ret	8
?SetUsingStrategy@CvMilitaryAI@@QAEXW4MilitaryAIStrategyTypes@@_N@Z ENDP ; CvMilitaryAI::SetUsingStrategy
_TEXT	ENDS
PUBLIC	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
EXTRN	?ChangeFaith@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::ChangeFaith
EXTRN	?GetFaithPurchaseCost@CvCity@@QAEHW4UnitTypes@@_N@Z:PROC ; CvCity::GetFaithPurchaseCost
EXTRN	?setMoves@CvUnit@@QAEXH@Z:PROC			; CvUnit::setMoves
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	?CreateUnit@CvCity@@QAEHW4UnitTypes@@W4UnitAITypes@@_N@Z:PROC ; CvCity::CreateUnit
EXTRN	?GetPurchaseCost@CvCity@@QAEHW4UnitTypes@@@Z:PROC ; CvCity::GetPurchaseCost
EXTRN	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z:PROC ; CvUnitProductionAI::RecommendUnit
EXTRN	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ:PROC ; CvCityStrategyAI::GetUnitProductionAI
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?IsPuppet@CvCity@@QBE_NXZ:PROC			; CvCity::IsPuppet
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T234051 = -128						; size = 4
_szMsg$226285 = -124					; size = 28
_szMsg$226295 = -96					; size = 28
$T234052 = -68						; size = 28
$T234054 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eUnitType$ = 8						; size = 4
_pCity$ = 12						; size = 4
?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z PROC ; CvMilitaryAI::BuyEmergencyUnit, COMDAT
; _this$ = ecx

; 849  : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 850  : 	bool bIsVenice = m_pPlayer->GetPlayerTraits()->IsNoAnnexing();

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 851  : 
; 852  : 	// No units in puppet cities except for Venice!
; 853  : 	if(pCity->IsPuppet() && !bIsVenice)

	mov	edi, DWORD PTR _pCity$[esp+140]
	mov	bl, BYTE PTR [eax+351]
	mov	ecx, edi
	call	?IsPuppet@CvCity@@QBE_NXZ		; CvCity::IsPuppet
	test	al, al
	je	SHORT $LN9@BuyEmergen@2
	test	bl, bl

; 854  : 	{
; 855  : 		return NULL;

	je	$LN1@BuyEmergen@2
$LN9@BuyEmergen@2:

; 856  : 	}
; 857  : 
; 858  : 	// Get best unit with this AI type
; 859  : 	UnitTypes eType = pCity->GetCityStrategyAI()->GetUnitProductionAI()->RecommendUnit(eUnitType);

	mov	eax, DWORD PTR _eUnitType$[esp+140]
	push	eax
	mov	ecx, edi
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
	mov	ecx, eax
	call	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ; CvUnitProductionAI::RecommendUnit
	mov	ebp, eax

; 860  : 	if(eType != NO_UNIT)

	cmp	ebp, -1
	je	$LN1@BuyEmergen@2

; 861  : 	{
; 862  : 		// Can we buy the primary unit type at the start city?
; 863  : 		if(pCity->IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eType, NO_BUILDING, NO_PROJECT, YIELD_GOLD))

	push	2
	push	-1
	push	-1
	push	ebp
	push	1
	push	1
	mov	ecx, edi
	call	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z ; CvCity::IsCanPurchase
	test	al, al
	je	$LN3@BuyEmergen@2

; 864  : 		{
; 865  : 			int iGoldCost = pCity->GetPurchaseCost(eType);

	push	ebp
	mov	ecx, edi
	call	?GetPurchaseCost@CvCity@@QAEHW4UnitTypes@@@Z ; CvCity::GetPurchaseCost

; 866  : 			int iPriority = GC.getAI_GOLD_PRIORITY_UNIT();
; 867  : 			if(m_pPlayer->GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_UNIT, iGoldCost, iPriority))

	mov	ecx, DWORD PTR [esi]
	mov	ebx, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2092
	push	eax
	push	ebx
	push	4
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
	test	al, al
	je	$LN3@BuyEmergen@2

; 868  : 			{
; 869  : 				if(pCity->getOwner() == m_pPlayer->GetID())		// Player must own the city or this will create a unit for another player

	mov	eax, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx+44]
	jne	$LN3@BuyEmergen@2

; 870  : 				{
; 871  : 					// This is an EXTRA build for the operation beyond any that are already assigned to this city, so pass in the right flag to CreateUnit()
; 872  : 					int iResult = pCity->CreateUnit(eType, NO_UNITAI, false /*bUseToSatisfyOperation*/);

	push	0
	push	-1
	push	ebp
	mov	ecx, edi
	call	?CreateUnit@CvCity@@QAEHW4UnitTypes@@W4UnitAITypes@@_N@Z ; CvCity::CreateUnit

; 873  : 
; 874  : 					CvAssertMsg(iResult != FFreeList::INVALID_INDEX, "Unable to create unit");
; 875  : 
; 876  : 					if (iResult != FFreeList::INVALID_INDEX)

	cmp	eax, -1
	je	$LN1@BuyEmergen@2

; 877  : 					{
; 878  : 						CvUnit* pUnit = m_pPlayer->getUnit(iResult);

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax

; 879  : 						m_pPlayer->GetTreasury()->LogExpenditure((CvString)pUnit->getUnitInfo().GetText(), iGoldCost, 7);

	push	7
	push	ebx
	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetText@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetText
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234051[esp+180], esp
	push	eax
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+188], 0
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+188], -1
	call	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ; CvTreasury::LogExpenditure

; 880  : 						m_pPlayer->GetTreasury()->ChangeGold(-iGoldCost);

	mov	ecx, DWORD PTR [esi]
	neg	ebx
	push	ebx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 881  : 
; 882  : 						pUnit->setMoves(0);

	push	0
	mov	ecx, ebp
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves

; 883  : 
; 884  : 						CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$226285[esp+144]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 885  : 						szMsg.Format("Emergency Unit Purchased: %s, ", pUnit->getUnitInfo().GetDescription());

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+152], 1
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _szMsg$226285[esp+148]
	push	OFFSET $SG226286
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 886  : 						szMsg += pCity->getName();

	lea	eax, DWORD PTR $T234052[esp+144]
	push	eax
	mov	ecx, edi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _szMsg$226285[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 2
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234052[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 887  : 						m_pPlayer->GetTacticalAI()->LogTacticalMessage(szMsg);

	push	1
	lea	ecx, DWORD PTR _szMsg$226285[esp+148]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 888  : 
; 889  : 						return pUnit;

	lea	ecx, DWORD PTR _szMsg$226285[esp+144]

; 890  : 					}
; 891  : 					else
; 892  : 					{
; 893  : 						return NULL;

	jmp	$LN61@BuyEmergen@2
$LN3@BuyEmergen@2:

; 894  : 					}
; 895  : 				}
; 896  : 			}
; 897  : 		}
; 898  : 
; 899  : 		// Try again with Faith
; 900  : 		if(pCity->IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eType, NO_BUILDING, NO_PROJECT, YIELD_FAITH))

	push	5
	push	-1
	push	-1
	push	ebp
	push	1
	push	1
	mov	ecx, edi
	call	?IsCanPurchase@CvCity@@QAE_N_N0W4UnitTypes@@W4BuildingTypes@@W4ProjectTypes@@W4YieldTypes@@@Z ; CvCity::IsCanPurchase
	test	al, al
	je	$LN1@BuyEmergen@2

; 901  : 		{
; 902  : 			int iFaithCost = pCity->GetFaithPurchaseCost(eType, false /*bIncludeBeliefDiscounts*/);

	push	0
	push	ebp
	mov	ecx, edi
	call	?GetFaithPurchaseCost@CvCity@@QAEHW4UnitTypes@@_N@Z ; CvCity::GetFaithPurchaseCost

; 903  : 
; 904  : 			if(pCity->getOwner() == m_pPlayer->GetID())		// Player must own the city or this will create a unit for another player

	mov	edx, DWORD PTR [edi+84]
	mov	ecx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ecx+44]
	jne	$LN1@BuyEmergen@2

; 905  : 			{
; 906  : 				m_pPlayer->ChangeFaith(-iFaithCost);

	neg	eax
	push	eax
	call	?ChangeFaith@CvPlayer@@QAEXH@Z		; CvPlayer::ChangeFaith

; 907  : 
; 908  : 				// This is an EXTRA build for the operation beyond any that are already assigned to this city, so pass in the right flag to CreateUnit()
; 909  : 				int iResult = pCity->CreateUnit(eType, NO_UNITAI, false /*bUseToSatisfyOperation*/);

	push	0
	push	-1
	push	ebp
	mov	ecx, edi
	call	?CreateUnit@CvCity@@QAEHW4UnitTypes@@W4UnitAITypes@@_N@Z ; CvCity::CreateUnit

; 910  : 
; 911  : 				CvAssertMsg(iResult != FFreeList::INVALID_INDEX, "Unable to create unit");
; 912  : 				CvUnit* pUnit = m_pPlayer->getUnit(iResult);

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax

; 913  : 				pUnit->setMoves(0);

	push	0
	mov	ecx, ebp
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves

; 914  : 
; 915  : 				CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$226295[esp+144]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, 3

; 916  : 				szMsg.Format("Emergency Faith Unit Purchase: %s, ", pUnit->getUnitInfo().GetDescription());

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+152], ebx
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _szMsg$226295[esp+148]
	push	OFFSET $SG226296
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 917  : 				szMsg += pCity->getName();

	lea	eax, DWORD PTR $T234054[esp+144]
	push	eax
	mov	ecx, edi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _szMsg$226295[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234054[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 918  : 				m_pPlayer->GetTacticalAI()->LogTacticalMessage(szMsg);

	push	1
	lea	ecx, DWORD PTR _szMsg$226295[esp+148]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 919  : 
; 920  : 				return pUnit;

	lea	ecx, DWORD PTR _szMsg$226295[esp+144]
$LN61@BuyEmergen@2:
	mov	DWORD PTR __$EHRec$[esp+152], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, ebp
	jmp	SHORT $LN10@BuyEmergen@2
$LN1@BuyEmergen@2:

; 921  : 			}
; 922  : 		}
; 923  : 	}
; 924  : 	return NULL;

	xor	eax, eax
$LN10@BuyEmergen@2:

; 925  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 128				; 00000080H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$0:
	mov	ecx, DWORD PTR $T234051[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$1:
	lea	ecx, DWORD PTR _szMsg$226285[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$2:
	lea	ecx, DWORD PTR $T234052[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$3:
	lea	ecx, DWORD PTR _szMsg$226295[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z$4:
	lea	ecx, DWORD PTR $T234054[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ENDP ; CvMilitaryAI::BuyEmergencyUnit
PUBLIC	?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::ShouldAttackBySea
EXTRN	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z:PROC ; CvStepPathFinder::DoesPathExist
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?canEmbark@CvTeam@@QBE_NXZ:PROC			; CvTeam::canEmbark
; Function compile flags: /Ogtpy
;	COMDAT ?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z
_TEXT	SEGMENT
_iPathLength$ = -4					; size = 4
_eEnemy$ = 8						; size = 4
_target$ = 12						; size = 4
?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z PROC ; CvMilitaryAI::ShouldAttackBySea, COMDAT
; _this$ = ecx

; 1181 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 1182 : 	CvAStarNode* pPathfinderNode;
; 1183 : 	int iPathLength = 0;
; 1184 : 	int iPlotDistance = plotDistance(target.m_pMusterCity->getX(), target.m_pMusterCity->getY(), target.m_pTargetCity->getX(), target.m_pTargetCity->getY());

	mov	esi, DWORD PTR _target$[esp+12]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	edi
	push	edx
	mov	edi, ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+108]
	push	eax
	mov	eax, DWORD PTR [ecx+96]
	push	edx
	xor	ebp, ebp
	push	eax
	mov	DWORD PTR _iPathLength$[esp+36], ebp
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 1185 : 
; 1186 : 	// Can embark
; 1187 : 	if(GET_TEAM(m_pPlayer->getTeam()).canEmbark())

	mov	ecx, DWORD PTR [edi]
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx+44]
	add	esp, 16					; 00000010H
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN32@ShouldAtta
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN33@ShouldAtta
$LN32@ShouldAtta:
	or	eax, -1
$LN33@ShouldAtta:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?canEmbark@CvTeam@@QBE_NXZ		; CvTeam::canEmbark

; 1188 : 	{
; 1189 : 		// On different landmasses?
; 1190 : 		if(target.m_pMusterCity->getArea() != target.m_pTargetCity->getArea())

	mov	ecx, DWORD PTR [esi]
	test	al, al
	je	SHORT $LN9@ShouldAtta
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, DWORD PTR [esi+4]
	mov	ebp, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	eax, ebp

; 1191 : 		{
; 1192 : 			target.m_bAttackBySea = true;
; 1193 : 			target.m_iPathLength = iPlotDistance;
; 1194 : 			return;

	jne	SHORT $LN52@ShouldAtta

; 1195 : 		}
; 1196 : 
; 1197 : 		// No step path between muster point and target?
; 1198 : 		if(!GC.getStepFinder().DoesPathExist(m_pPlayer->GetID(), eEnemy, target.m_pMusterCity->plot(), target.m_pTargetCity->plot()))

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+44]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	eax, DWORD PTR _eEnemy$[esp+24]
	push	eax
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
	test	al, al

; 1199 : 		{
; 1200 : 			target.m_bAttackBySea = true;
; 1201 : 			target.m_iPathLength = iPlotDistance;
; 1202 : 			return;

	je	SHORT $LN52@ShouldAtta

; 1203 : 		}
; 1204 : 
; 1205 : 		// Land path is over twice as long as direct path
; 1206 : 		pPathfinderNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	eax, DWORD PTR [eax+96]

; 1207 : 		if(pPathfinderNode != NULL)

	test	eax, eax
	je	SHORT $LN51@ShouldAtta

; 1208 : 		{
; 1209 : 			iPathLength = pPathfinderNode->m_iData1;

	mov	ebp, DWORD PTR [eax+12]

; 1210 : 			if(iPathLength > (2 * iPlotDistance))

	lea	ecx, DWORD PTR [ebx+ebx]
	cmp	ebp, ecx
	jle	SHORT $LN1@ShouldAtta
$LN52@ShouldAtta:
	pop	edi

; 1211 : 			{
; 1212 : 				target.m_bAttackBySea = true;
; 1213 : 				target.m_iPathLength = iPlotDistance;

	mov	DWORD PTR [esi+16], ebx
	mov	BYTE PTR [esi+20], 1
	pop	esi
	pop	ebp
	pop	ebx

; 1240 : }

	pop	ecx
	ret	8
$LN9@ShouldAtta:

; 1214 : 				return;
; 1215 : 			}
; 1216 : 		}
; 1217 : 	}
; 1218 : 
; 1219 : 	// Can't embark yet
; 1220 : 	else
; 1221 : 	{
; 1222 : 		if(!GC.getStepFinder().DoesPathExist(m_pPlayer->GetID(), eEnemy, target.m_pMusterCity->plot(), target.m_pTargetCity->plot()))

	mov	edx, DWORD PTR [edi]
	mov	edi, DWORD PTR [edx+44]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	eax, DWORD PTR _eEnemy$[esp+24]
	push	eax
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
	test	al, al
	jne	SHORT $LN3@ShouldAtta
	pop	edi

; 1223 : 		{
; 1224 : 			target.m_iPathLength = -1;  // Call off attack, no path

	mov	DWORD PTR [esi+16], -1
	pop	esi
	pop	ebp
	pop	ebx

; 1240 : }

	pop	ecx
	ret	8
$LN3@ShouldAtta:

; 1225 : 			return;
; 1226 : 		}
; 1227 : 
; 1228 : 		else
; 1229 : 		{
; 1230 : 			pPathfinderNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	eax, DWORD PTR [eax+96]

; 1231 : 			if(pPathfinderNode != NULL)

	test	eax, eax
	je	SHORT $LN1@ShouldAtta

; 1232 : 			{
; 1233 : 				iPathLength = pPathfinderNode->m_iData1;

	mov	ebp, DWORD PTR [eax+12]
	pop	edi

; 1234 : 			}
; 1235 : 		}
; 1236 : 	}
; 1237 : 
; 1238 : 	target.m_bAttackBySea = false;
; 1239 : 	target.m_iPathLength = iPathLength;

	mov	DWORD PTR [esi+16], ebp
	mov	BYTE PTR [esi+20], 0
	pop	esi
	pop	ebp
	pop	ebx

; 1240 : }

	pop	ecx
	ret	8
$LN51@ShouldAtta:

; 1232 : 			{
; 1233 : 				iPathLength = pPathfinderNode->m_iData1;

	mov	ebp, DWORD PTR _iPathLength$[esp+20]
$LN1@ShouldAtta:
	pop	edi

; 1234 : 			}
; 1235 : 		}
; 1236 : 	}
; 1237 : 
; 1238 : 	target.m_bAttackBySea = false;
; 1239 : 	target.m_iPathLength = iPathLength;

	mov	DWORD PTR [esi+16], ebp
	mov	BYTE PTR [esi+20], 0
	pop	esi
	pop	ebp
	pop	ebx

; 1240 : }

	pop	ecx
	ret	8
?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z ENDP ; CvMilitaryAI::ShouldAttackBySea
_TEXT	ENDS
PUBLIC	?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z ; CvMilitaryAI::EvaluateMilitaryApproaches
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
; Function compile flags: /Ogtpy
;	COMDAT ?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z
_TEXT	SEGMENT
_eRtnValue$ = -4					; size = 4
_pCity$ = 8						; size = 4
_bAttackByLand$ = 12					; size = 1
_bAttackBySea$ = 16					; size = 1
?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z PROC ; CvMilitaryAI::EvaluateMilitaryApproaches, COMDAT
; _this$ = ecx

; 1393 : {

	push	ecx
	push	ebx

; 1394 : 	CvPlot* pLoopPlot;
; 1395 : 	CityAttackApproaches eRtnValue = ATTACK_APPROACH_UNRESTRICTED;
; 1396 : 	int iNumBlocked = 0;
; 1397 : 
; 1398 : 	// Look at each of the six plots around the city
; 1399 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	ebx, DWORD PTR _pCity$[esp+4]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR _eRtnValue$[esp+20], 5
	xor	ebp, ebp
$LL22@EvaluateMi:

; 1400 : 	{
; 1401 : 		pLoopPlot = plotDirection(pCity->getX(), pCity->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1402 : 
; 1403 : 		// Blocked if edge of map
; 1404 : 		if(pLoopPlot == NULL)

	test	esi, esi

; 1405 : 		{
; 1406 : 			iNumBlocked++;
; 1407 : 		}
; 1408 : 		else

	je	SHORT $LN9@EvaluateMi

; 1409 : 		{
; 1410 : 			// For now, assume no one coming in over a lake
; 1411 : 			if(pLoopPlot->isLake())

	mov	ecx, esi
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	test	al, al

; 1412 : 			{
; 1413 : 				iNumBlocked++;

	jne	SHORT $LN9@EvaluateMi

; 1414 : 			}
; 1415 : 			// Coast but attack is not by sea?
; 1416 : 			else if(pLoopPlot->isWater() && !bAttackBySea)

	mov	al, BYTE PTR [esi+5]
	cmp	al, 3
	jne	SHORT $LN46@EvaluateMi
	cmp	BYTE PTR _bAttackBySea$[esp+16], 0

; 1417 : 			{
; 1418 : 				iNumBlocked++;

	je	SHORT $LN9@EvaluateMi

; 1419 : 			}
; 1420 : 			// Land
; 1421 : 			else if(!pLoopPlot->isWater())

	cmp	al, al
	je	SHORT $LN21@EvaluateMi
$LN46@EvaluateMi:

; 1422 : 			{
; 1423 : 				if(!bAttackByLand)

	cmp	BYTE PTR _bAttackByLand$[esp+16], 0

; 1424 : 				{
; 1425 : 					iNumBlocked++;
; 1426 : 				}
; 1427 : 				else

	je	SHORT $LN9@EvaluateMi

; 1428 : 				{
; 1429 : 					if(pLoopPlot->isImpassable() || pLoopPlot->isMountain())

	test	BYTE PTR [esi+462], 128			; 00000080H
	jne	SHORT $LN9@EvaluateMi
	test	al, al
	jne	SHORT $LN21@EvaluateMi
$LN9@EvaluateMi:

; 1430 : 					{
; 1431 : 						iNumBlocked++;

	inc	edi
$LN21@EvaluateMi:

; 1394 : 	CvPlot* pLoopPlot;
; 1395 : 	CityAttackApproaches eRtnValue = ATTACK_APPROACH_UNRESTRICTED;
; 1396 : 	int iNumBlocked = 0;
; 1397 : 
; 1398 : 	// Look at each of the six plots around the city
; 1399 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL22@EvaluateMi

; 1432 : 					}
; 1433 : 				}
; 1434 : 			}
; 1435 : 		}
; 1436 : 	}
; 1437 : 
; 1438 : 	switch(iNumBlocked)

	cmp	edi, 6
	ja	SHORT $LN44@EvaluateMi
	jmp	DWORD PTR $LN47@EvaluateMi[edi*4]
$LN6@EvaluateMi:
	pop	edi
	pop	esi

; 1439 : 	{
; 1440 : 	case 0:
; 1441 : 		eRtnValue = ATTACK_APPROACH_UNRESTRICTED;

	mov	DWORD PTR _eRtnValue$[esp+12], 5

; 1458 : 		break;
; 1459 : 	}
; 1460 : 
; 1461 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+12]
	pop	ebp
	pop	ebx

; 1462 : }

	pop	ecx
	ret	12					; 0000000cH
$LN5@EvaluateMi:
	pop	edi
	pop	esi

; 1442 : 		break;
; 1443 : 	case 1:
; 1444 : 	case 2:
; 1445 : 		eRtnValue = ATTACK_APPROACH_OPEN;

	mov	DWORD PTR _eRtnValue$[esp+12], 4

; 1458 : 		break;
; 1459 : 	}
; 1460 : 
; 1461 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+12]
	pop	ebp
	pop	ebx

; 1462 : }

	pop	ecx
	ret	12					; 0000000cH
$LN4@EvaluateMi:
	pop	edi
	pop	esi

; 1446 : 		break;
; 1447 : 	case 3:
; 1448 : 		eRtnValue = ATTACK_APPROACH_NEUTRAL;

	mov	DWORD PTR _eRtnValue$[esp+12], 3

; 1458 : 		break;
; 1459 : 	}
; 1460 : 
; 1461 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+12]
	pop	ebp
	pop	ebx

; 1462 : }

	pop	ecx
	ret	12					; 0000000cH
$LN3@EvaluateMi:
	pop	edi
	pop	esi

; 1449 : 		break;
; 1450 : 	case 4:
; 1451 : 		eRtnValue = ATTACK_APPROACH_LIMITED;

	mov	DWORD PTR _eRtnValue$[esp+12], 2

; 1458 : 		break;
; 1459 : 	}
; 1460 : 
; 1461 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+12]
	pop	ebp
	pop	ebx

; 1462 : }

	pop	ecx
	ret	12					; 0000000cH
$LN2@EvaluateMi:
	pop	edi
	pop	esi

; 1452 : 		break;
; 1453 : 	case 5:
; 1454 : 		eRtnValue = ATTACK_APPROACH_RESTRICTED;

	mov	DWORD PTR _eRtnValue$[esp+12], 1

; 1458 : 		break;
; 1459 : 	}
; 1460 : 
; 1461 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+12]
	pop	ebp
	pop	ebx

; 1462 : }

	pop	ecx
	ret	12					; 0000000cH
$LN1@EvaluateMi:

; 1455 : 		break;
; 1456 : 	case 6:
; 1457 : 		eRtnValue = ATTACK_APPROACH_NONE;

	mov	DWORD PTR _eRtnValue$[esp+20], 0
$LN44@EvaluateMi:

; 1458 : 		break;
; 1459 : 	}
; 1460 : 
; 1461 : 	return eRtnValue;

	mov	eax, DWORD PTR _eRtnValue$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1462 : }

	pop	ecx
	ret	12					; 0000000cH
$LN47@EvaluateMi:
	DD	$LN6@EvaluateMi
	DD	$LN5@EvaluateMi
	DD	$LN5@EvaluateMi
	DD	$LN4@EvaluateMi
	DD	$LN3@EvaluateMi
	DD	$LN2@EvaluateMi
	DD	$LN1@EvaluateMi
?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z ENDP ; CvMilitaryAI::EvaluateMilitaryApproaches
_TEXT	ENDS
PUBLIC	?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetNearestCoastalCity
EXTRN	?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z:PROC	; OnSameBodyOfWater
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Ogtpy
;	COMDAT ?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iBestDistance$ = -24					; size = 4
_this$ = -20						; size = 4
_pBestCoastalCity$ = -16				; size = 4
tv268 = -12						; size = 4
_iEnemyLoop$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_eEnemy$ = 8						; size = 4
?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::GetNearestCoastalCity, COMDAT
; _this$ = ecx

; 1466 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi

; 1467 : 	CvCity* pBestCoastalCity = NULL;

	xor	esi, esi
	mov	edi, ecx

; 1468 : 	CvCity* pLoopCity, *pEnemyCity;
; 1469 : 	int iLoop, iEnemyLoop;
; 1470 : 	int iBestDistance = MAX_INT;
; 1471 : 
; 1472 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [edi]
	push	esi
	lea	eax, DWORD PTR _iLoop$[esp+40]
	push	eax
	mov	DWORD PTR _this$[esp+44], edi
	mov	DWORD PTR _pBestCoastalCity$[esp+44], esi
	mov	DWORD PTR _iBestDistance$[esp+44], 2147483647 ; 7fffffffH
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN50@GetNearest
	push	ebp
$LL10@GetNearest:

; 1473 : 	{
; 1474 : 		if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, ebx
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN9@GetNearest

; 1475 : 		{
; 1476 : 			for(pEnemyCity = GET_PLAYER(eEnemy).firstCity(&iEnemyLoop); pEnemyCity != NULL; pEnemyCity = GET_PLAYER(eEnemy).nextCity(&iEnemyLoop))

	mov	ebp, DWORD PTR _eEnemy$[esp+36]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebp, 63236				; 0000f704H
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[esp+44]
	add	ecx, ebp
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN9@GetNearest
	npad	5
$LL6@GetNearest:

; 1477 : 			{
; 1478 : 				// Check all revealed enemy cities
; 1479 : 				if(pEnemyCity->isCoastal() && pEnemyCity->plot()->isRevealed(m_pPlayer->getTeam()))

	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN5@GetNearest
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@GetNearest
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN22@GetNearest
$LN21@GetNearest:
	or	edi, -1
$LN22@GetNearest:
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, edi
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv268[esp+40], ecx
	mov	ecx, edi
	mov	edi, DWORD PTR tv268[esp+40]
	sub	ecx, edi
	mov	edi, 1
	shl	edi, cl
	test	edi, DWORD PTR [eax+edx*4+8]
	je	SHORT $LN5@GetNearest

; 1480 : 				{
; 1481 : 					// On same body of water?
; 1482 : 					if(OnSameBodyOfWater(pLoopCity, pEnemyCity))

	push	esi
	push	ebx
	call	?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z	; OnSameBodyOfWater
	add	esp, 8
	test	al, al
	je	SHORT $LN5@GetNearest

; 1483 : 					{
; 1484 : 						int iDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), pEnemyCity->getX(), pEnemyCity->getY());

	mov	edx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [ebx+108]
	push	edx
	mov	edx, DWORD PTR [ebx+96]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1485 : 						if(iDistance < iBestDistance)

	cmp	eax, DWORD PTR _iBestDistance$[esp+40]
	jge	SHORT $LN5@GetNearest

; 1486 : 						{
; 1487 : 							iBestDistance = iDistance;

	mov	DWORD PTR _iBestDistance$[esp+40], eax

; 1488 : 							pBestCoastalCity = pLoopCity;

	mov	DWORD PTR _pBestCoastalCity$[esp+40], ebx
$LN5@GetNearest:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[esp+44]
	lea	ecx, DWORD PTR [eax+ebp]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, DWORD PTR _this$[esp+40]
	mov	esi, eax
	test	esi, esi
	jne	$LL6@GetNearest
$LN9@GetNearest:

; 1468 : 	CvCity* pLoopCity, *pEnemyCity;
; 1469 : 	int iLoop, iEnemyLoop;
; 1470 : 	int iBestDistance = MAX_INT;
; 1471 : 
; 1472 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+44]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL10@GetNearest

; 1489 : 						}
; 1490 : 					}
; 1491 : 				}
; 1492 : 			}
; 1493 : 		}
; 1494 : 	}
; 1495 : 
; 1496 : 	return pBestCoastalCity;

	mov	eax, DWORD PTR _pBestCoastalCity$[esp+40]
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 1497 : }

	add	esp, 24					; 00000018H
	ret	4
$LN50@GetNearest:
	pop	edi

; 1489 : 						}
; 1490 : 					}
; 1491 : 				}
; 1492 : 			}
; 1493 : 		}
; 1494 : 	}
; 1495 : 
; 1496 : 	return pBestCoastalCity;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1497 : }

	add	esp, 24					; 00000018H
	ret	4
?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::GetNearestCoastalCity
_TEXT	ENDS
PUBLIC	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?GetFirstUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetFirstUnitID
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z$0
__ehfuncinfo$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pCoastalPlot$ = -24					; size = 4
_pInitialUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
$T234372 = 8						; size = 4
_pTarget$ = 8						; size = 4
_iDirectionLoop$226930 = 12				; size = 4
_pArmy$ = 12						; size = 4
?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z PROC ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget, COMDAT
; _this$ = ecx

; 1500 : {

	push	-1
	push	__ehhandler$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 1501 : 	CvPlot *pCoastalPlot = NULL;

	xor	ebp, ebp

; 1502 : 	UnitHandle pInitialUnit;

	xor	esi, esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _pCoastalPlot$[esp+40], ebp
	mov	DWORD PTR _pInitialUnit$[esp+40], esi
	mov	BYTE PTR _pInitialUnit$[esp+44], 0

; 1503 : 	int iBestDistance = MAX_INT;
; 1504 : 	int iUnitID = -1;
; 1505 : 	if (pArmy)

	mov	ecx, DWORD PTR _pArmy$[esp+36]
	mov	DWORD PTR __$EHRec$[esp+48], ebp
	mov	ebx, 2147483647				; 7fffffffH
	cmp	ecx, ebp
	je	SHORT $LN22@GetCoastal

; 1506 : 	{
; 1507 : 		iUnitID = pArmy->GetFirstUnitID();

	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 1508 : 		pInitialUnit = m_pPlayer->getUnit(iUnitID);

	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pInitialUnit$[esp+40], esi
	cmp	eax, ebp
	je	SHORT $LN22@GetCoastal
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN22@GetCoastal:

; 1509 : 	}
; 1510 : 
; 1511 : 	// Find a coastal water tile adjacent to enemy city
; 1512 : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$226930[esp+36], ebp
	mov	ebp, DWORD PTR _pTarget$[esp+36]
$LN8@GetCoastal:

; 1513 : 	{
; 1514 : 		CvPlot* pAdjacentPlot = plotDirection(pTarget->getX(), pTarget->getY(), ((DirectionTypes)iDirectionLoop));

	mov	eax, DWORD PTR _iDirectionLoop$226930[esp+36]
	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1515 : 		if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	test	edi, edi
	je	SHORT $LN7@GetCoastal
	cmp	BYTE PTR [edi+5], 3
	jne	SHORT $LN7@GetCoastal
	mov	ecx, edi
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	je	SHORT $LN7@GetCoastal

; 1516 : 		{
; 1517 : 			// Check for path if we have a unit, otherwise don't worry about it
; 1518 : 			if(pInitialUnit)

	test	esi, esi
	je	$LN4@GetCoastal

; 1519 : 			{
; 1520 : 				if (TurnsToReachTarget(pInitialUnit, pAdjacentPlot, false /*bReusePaths*/, true /*bIgnoreUnits*/, true /*bIgnoreStacking*/) < MAX_INT)

	push	1
	push	1
	push	0
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T234372[esp+60], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN7@GetCoastal

; 1521 : 				{
; 1522 : 					int iDistance = plotDistance(pInitialUnit->getX(), pInitialUnit->getY(), pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [ebp+2]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [ebp]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1523 : 					if (iDistance < iBestDistance)

	cmp	eax, ebx
	jge	SHORT $LN7@GetCoastal

; 1524 : 					{
; 1525 : 						iBestDistance = iDistance;

	mov	ebx, eax

; 1526 : 						pCoastalPlot = pAdjacentPlot;

	mov	DWORD PTR _pCoastalPlot$[esp+40], edi
$LN7@GetCoastal:
	mov	eax, DWORD PTR _iDirectionLoop$226930[esp+36]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iDirectionLoop$226930[esp+36], eax
	jl	$LN8@GetCoastal

; 1527 : 					}
; 1528 : 				}
; 1529 : 			}
; 1530 : 			else
; 1531 : 			{
; 1532 : 				return pAdjacentPlot;
; 1533 : 			}
; 1534 : 		}
; 1535 : 	}
; 1536 : 
; 1537 : 	return pCoastalPlot;

	mov	DWORD PTR __$EHRec$[esp+48], -1
	test	esi, esi
	je	SHORT $LN61@GetCoastal
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN61@GetCoastal:
	mov	eax, DWORD PTR _pCoastalPlot$[esp+40]

; 1538 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	8
$LN4@GetCoastal:
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 24					; 00000018H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _pInitialUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ENDP ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
PUBLIC	?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ; CvMilitaryAI::GetHighestThreat
EXTRN	?GetMilitaryThreat@CvDiplomacyAI@@QBE?AW4ThreatTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMilitaryThreat
EXTRN	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::IsPlayerValid
; Function compile flags: /Ogtpy
;	COMDAT ?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ
_TEXT	SEGMENT
?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ PROC ; CvMilitaryAI::GetHighestThreat, COMDAT
; _this$ = ecx

; 1544 : {

	push	ebx
	push	esi
	push	edi

; 1545 : 	ThreatTypes eHighestThreat = THREAT_NONE;

	xor	ebx, ebx
	mov	edi, ecx

; 1546 : 	ThreatTypes eMilitaryThreatType;
; 1547 : 
; 1548 : 	PlayerTypes eLoopPlayer;
; 1549 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	npad	7
$LL5@GetHighest:

; 1550 : 	{
; 1551 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 1552 : 
; 1553 : 		// Is this a player we have relations with?
; 1554 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pDiplomacyAI->IsPlayerValid(eLoopPlayer))

	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+44]
	je	SHORT $LN4@GetHighest
	mov	ecx, DWORD PTR [edi+4]
	push	0
	push	esi
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN4@GetHighest

; 1555 : 		{
; 1556 : 			eMilitaryThreatType = m_pDiplomacyAI->GetMilitaryThreat(eLoopPlayer);

	mov	ecx, DWORD PTR [edi+4]
	push	esi
	call	?GetMilitaryThreat@CvDiplomacyAI@@QBE?AW4ThreatTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMilitaryThreat

; 1557 : 			if((int)eMilitaryThreatType > (int)eHighestThreat)

	cmp	eax, ebx
	jle	SHORT $LN4@GetHighest

; 1558 : 			{
; 1559 : 				eHighestThreat = eMilitaryThreatType;

	mov	ebx, eax
$LN4@GetHighest:

; 1546 : 	ThreatTypes eMilitaryThreatType;
; 1547 : 
; 1548 : 	PlayerTypes eLoopPlayer;
; 1549 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL5@GetHighest
	pop	edi
	pop	esi

; 1560 : 			}
; 1561 : 		}
; 1562 : 	}
; 1563 : 	return eHighestThreat;

	mov	eax, ebx
	pop	ebx

; 1564 : }

	ret	0
?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ENDP ; CvMilitaryAI::GetHighestThreat
_TEXT	ENDS
PUBLIC	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ	; CvMilitaryAI::GetNumberCivsAtWarWith
EXTRN	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarState
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ
_TEXT	SEGMENT
?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ PROC	; CvMilitaryAI::GetNumberCivsAtWarWith, COMDAT
; _this$ = ecx

; 1612 : {

	push	ebx
	push	esi
	push	edi

; 1613 : 	PlayerTypes eLoopPlayer;
; 1614 : 	WarStateTypes eWarState;
; 1615 : 	int iRtnValue = 0;

	xor	ebx, ebx
	mov	edi, ecx

; 1616 : 
; 1617 : 	// Let's figure out if we're at war
; 1618 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
	npad	7
$LL5@GetNumberC:

; 1619 : 	{
; 1620 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 1621 : 
; 1622 : 		// Is this a player we have relations with?
; 1623 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [edi]
	cmp	esi, DWORD PTR [ecx+44]
	je	SHORT $LN4@GetNumberC
	push	0
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN4@GetNumberC

; 1624 : 		{
; 1625 : 			eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState

; 1626 : 			if(eWarState != NO_WAR_STATE_TYPE)

	cmp	eax, -1
	je	SHORT $LN4@GetNumberC

; 1627 : 			{
; 1628 : 				iRtnValue++;

	inc	ebx
$LN4@GetNumberC:

; 1616 : 
; 1617 : 	// Let's figure out if we're at war
; 1618 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL5@GetNumberC
	pop	edi
	pop	esi

; 1629 : 			}
; 1630 : 		}
; 1631 : 	}
; 1632 : 
; 1633 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 1634 : }

	ret	0
?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ENDP	; CvMilitaryAI::GetNumberCivsAtWarWith
_TEXT	ENDS
PUBLIC	?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; CvMilitaryAI::LogAttackTargets
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$9
	DD	04H
	DD	FLAT:__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
_TEXT	SEGMENT
tv621 = -276						; size = 4
_iI$227213 = -272					; size = 4
_pLog$227191 = -268					; size = 4
_strBaseString$227187 = -264				; size = 28
_playerName$227189 = -236				; size = 28
_strOutBuf$227186 = -208				; size = 28
_target$227217 = -180					; size = 24
$T234508 = -180						; size = 28
_elem$234608 = -152					; size = 28
$T234509 = -152						; size = 28
$T234507 = -152						; size = 28
_strLogName$227190 = -124				; size = 28
_strTemp$227188 = -96					; size = 28
$T234512 = -68						; size = 28
$T234510 = -68						; size = 28
$T234511 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eAIOperationType$ = 8					; size = 4
_eEnemy$ = 12						; size = 4
_weightedTargetList$ = 16				; size = 4
?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z PROC ; CvMilitaryAI::LogAttackTargets, COMDAT
; _this$ = ecx

; 1711 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 264				; 00000108H
	push	esi
	mov	esi, ecx

; 1712 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN14@LogAttackT
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN14@LogAttackT
	push	ebx
	push	ebp
	push	edi

; 1713 : 	{
; 1714 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227186[esp+292]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebp, ebp

; 1715 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227187[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], ebp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1716 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227188[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1717 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227189[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1718 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$227190[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1719 : 
; 1720 : 		// Find the name of this civ
; 1721 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR __$EHRec$[esp+300], 4
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$227189[esp+292]
	cmp	eax, ebp
	je	SHORT $LN44@LogAttackT
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@LogAttackT
$LN44@LogAttackT:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@LogAttackT:

; 1722 : 
; 1723 : 		// Open the log file
; 1724 : 		FILogFile* pLog;
; 1725 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	test	al, al
	je	SHORT $LN13@LogAttackT

; 1726 : 		{
; 1727 : 			strLogName = "OperationalAILog_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$227189[esp+292]
	push	eax
	lea	ecx, DWORD PTR $T234507[esp+296]
	push	OFFSET $SG227196
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG227195
	push	eax
	lea	edx, DWORD PTR $T234508[esp+312]
	mov	bl, 5
	push	edx
	mov	BYTE PTR __$EHRec$[esp+324], bl
	call	edi
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+300], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227190[esp+296]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234508[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234507[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1728 : 		}
; 1729 : 		else

	jmp	SHORT $LN49@LogAttackT
$LN13@LogAttackT:

; 1730 : 		{
; 1731 : 			strLogName = "OperationalAILog.csv";

	push	OFFSET $SG227198
	lea	ecx, DWORD PTR _strLogName$227190[esp+296]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN49@LogAttackT:

; 1732 : 		}
; 1733 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$227190[esp+292]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	ebp
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 1734 : 
; 1735 : 		// Get the leading info for this line
; 1736 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _pLog$227191[esp+292], eax
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227187[esp+296]
	push	OFFSET $SG227199
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1737 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG227201
	lea	edx, DWORD PTR _playerName$227189[esp+308]
	push	edx
	lea	eax, DWORD PTR $T234509[esp+312]
	push	eax
	call	edi
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227187[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 7
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234509[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1738 : 		if(eAIOperationType == AI_OPERATION_BASIC_CITY_ATTACK)

	mov	eax, DWORD PTR _eAIOperationType$[esp+288]
	cmp	eax, 2
	jne	SHORT $LN11@LogAttackT

; 1739 : 		{
; 1740 : 			strBaseString += "Basic Attack, ";

	push	OFFSET $SG227203
	jmp	SHORT $LN108@LogAttackT
$LN11@LogAttackT:

; 1741 : 		}
; 1742 : 		else if(eAIOperationType == AI_OPERATION_SNEAK_CITY_ATTACK)

	cmp	eax, 6
	jne	SHORT $LN9@LogAttackT

; 1743 : 		{
; 1744 : 			strBaseString += "Sneak Attack, ";

	push	OFFSET $SG227206
	jmp	SHORT $LN108@LogAttackT
$LN9@LogAttackT:

; 1745 : 		}
; 1746 : 		else if(eAIOperationType == AI_OPERATION_PURE_NAVAL_CITY_ATTACK)

	cmp	eax, 18					; 00000012H
	jne	SHORT $LN7@LogAttackT

; 1747 : 		{
; 1748 : 			strBaseString += "Pure Naval Attack, ";

	push	OFFSET $SG227209

; 1749 : 		}
; 1750 : 		else

	jmp	SHORT $LN108@LogAttackT
$LN7@LogAttackT:

; 1751 : 		{
; 1752 : 			strBaseString += "City State Attack, ";

	push	OFFSET $SG227211
$LN108@LogAttackT:
	lea	ecx, DWORD PTR _strBaseString$227187[esp+296]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1753 : 		}
; 1754 : 		strBaseString += GET_PLAYER(eEnemy).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eEnemy$[esp+288]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227187[esp+296]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1755 : 		strBaseString += ", ";

	push	OFFSET $SG227212
	lea	ecx, DWORD PTR _strBaseString$227187[esp+296]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1756 : 
; 1757 : 		// Dump out the weight of each buildable item
; 1758 : 		for(int iI = 0; iI < weightedTargetList.size(); iI++)

	mov	ecx, DWORD PTR _weightedTargetList$[esp+288]
	cmp	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR _iI$227213[esp+292], ebp
	jle	$LN3@LogAttackT

; 1753 : 		}
; 1754 : 		strBaseString += GET_PLAYER(eEnemy).getCivilizationShortDescription();

	mov	DWORD PTR tv621[esp+292], ebp
	npad	9
$LL106@LogAttackT:

; 1759 : 		{
; 1760 : 			CvMilitaryTarget target = weightedTargetList.GetElement(iI);

	mov	edx, DWORD PTR _weightedTargetList$[esp+288]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv621[esp+292]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	ebp, DWORD PTR [ecx+eax]
	mov	ebx, DWORD PTR [ecx+eax+16]
	lea	esi, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _target$227217[esp+304], ecx
	mov	DWORD PTR _target$227217[esp+300], edx
	mov	edx, DWORD PTR [esi+20]

; 1761 : 			int iWeight = weightedTargetList.GetWeight(iI);

	mov	ecx, 7
	lea	edi, DWORD PTR _elem$234608[esp+292]
	rep movsd

; 1762 : 			strTemp.Format("Target: %s, Muster: %s, %d, Distance: %d", target.m_pTargetCity->getName().GetCString(), target.m_pMusterCity->getName().GetCString(), iWeight, target.m_iPathLength);

	lea	ecx, DWORD PTR $T234510[esp+292]
	push	ecx
	mov	ecx, eax
	mov	DWORD PTR _target$227217[esp+316], edx
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	esi, eax
	lea	edx, DWORD PTR $T234511[esp+292]
	push	edx
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+304], 8
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	edi, eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+300], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _elem$234608[esp+316]
	push	ebx
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strTemp$227188[esp+308]
	push	OFFSET $SG227221
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR $T234511[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234510[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1763 : 			strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$227188[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227187[esp+296]
	push	ecx
	lea	edx, DWORD PTR $T234512[esp+300]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+300], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227186[esp+296]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234512[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1764 : 			if(target.m_bAttackBySea)

	cmp	BYTE PTR _target$227217[esp+312], 0

; 1765 : 			{
; 1766 : 				strOutBuf += ", Sea";

	lea	ecx, DWORD PTR _strOutBuf$227186[esp+292]
	je	SHORT $LN2@LogAttackT
	push	OFFSET $SG227224

; 1767 : 			}
; 1768 : 			else

	jmp	SHORT $LN109@LogAttackT
$LN2@LogAttackT:

; 1769 : 			{
; 1770 : 				strOutBuf += ", Land";

	push	OFFSET $SG227226
$LN109@LogAttackT:
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1771 : 			}
; 1772 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227186[esp+292]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$227191[esp+292]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax
	mov	eax, DWORD PTR _iI$227213[esp+300]
	mov	ecx, DWORD PTR _weightedTargetList$[esp+296]
	add	DWORD PTR tv621[esp+300], 28		; 0000001cH
	inc	eax
	add	esp, 8
	cmp	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _iI$227213[esp+292], eax
	jl	$LL106@LogAttackT
$LN3@LogAttackT:

; 1773 : 		}
; 1774 : 	}

	lea	ecx, DWORD PTR _strLogName$227190[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$227189[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$227188[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227187[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227186[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebp
	pop	ebx
$LN14@LogAttackT:

; 1775 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+280]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 276				; 00000114H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227186[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227187[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$227188[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$3:
	lea	ecx, DWORD PTR _playerName$227189[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$4:
	lea	ecx, DWORD PTR _strLogName$227190[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$5:
	lea	ecx, DWORD PTR $T234507[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$6:
	lea	ecx, DWORD PTR $T234508[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$7:
	lea	ecx, DWORD PTR $T234509[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$8:
	lea	ecx, DWORD PTR $T234510[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$9:
	lea	ecx, DWORD PTR $T234511[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z$10:
	lea	ecx, DWORD PTR $T234512[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ENDP ; CvMilitaryAI::LogAttackTargets
PUBLIC	?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvMilitaryAI::LogDeficitScrapUnit
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_strOutBuf$227400 = -152				; size = 28
_strTemp$227401 = -124					; size = 28
_playerName$227402 = -96				; size = 28
$T234668 = -68						; size = 28
$T234669 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvMilitaryAI::LogDeficitScrapUnit, COMDAT
; _this$ = ecx

; 2037 : {

	push	-1
	push	__ehhandler$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 140				; 0000008cH
	push	ebp
	mov	ebp, ecx

; 2038 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+164], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@LogDeficit
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@LogDeficit

; 2039 : 	{
; 2040 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227400[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2041 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227401[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2042 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227402[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2043 : 		FILogFile* pLog;
; 2044 : 
; 2045 : 		// Open the right file
; 2046 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+164], 3
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$227402[esp+156]
	test	eax, eax
	je	SHORT $LN22@LogDeficit
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN21@LogDeficit
$LN22@LogDeficit:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN21@LogDeficit:
	push	ebx
	push	esi
	push	edi

; 2047 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	0
	lea	eax, DWORD PTR _playerName$227402[esp+172]
	push	eax
	lea	ecx, DWORD PTR $T234668[esp+176]
	push	ecx
	mov	ecx, ebp
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+176], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T234668[esp+168]
	mov	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+176], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2048 : 
; 2049 : 		strOutBuf.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227400[esp+172]
	push	OFFSET $SG227405
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2050 : 		strOutBuf += playerName + ", ";

	push	OFFSET $SG227407
	lea	edx, DWORD PTR _playerName$227402[esp+184]
	push	edx
	lea	eax, DWORD PTR $T234669[esp+188]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227400[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234669[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2051 : 		strTemp.Format("Scrapping %s, X: %d, Y: %d, ", pUnit->getUnitInfo().GetDescription(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$[esp+164]
	mov	esi, DWORD PTR [ecx+88]
	mov	edi, DWORD PTR [ecx+76]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$227401[esp+180]
	push	OFFSET $SG227408
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2052 : 		strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$227401[esp+168]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$227400[esp+172]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2053 : 		strOutBuf += "by DoDeficit(), , ";   //extra space so format is consistent with LogScrapUnit()

	push	OFFSET $SG227409
	lea	ecx, DWORD PTR _strOutBuf$227400[esp+172]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2054 : 		if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pUnit$[esp+164]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN2@LogDeficit

; 2055 : 		{
; 2056 : 			strTemp.Format("Num Land Units: %d, In Armies %d, Rec Size: %d, ", m_iNumLandUnits, m_iNumLandUnitsInArmies, m_iRecommendedMilitarySize);

	mov	eax, DWORD PTR [ebp+96]
	mov	ecx, DWORD PTR [ebp+72]
	mov	edx, DWORD PTR [ebp+52]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strTemp$227401[esp+180]
	push	OFFSET $SG227411
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2057 : 		}
; 2058 : 		else

	jmp	SHORT $LN1@LogDeficit
$LN2@LogDeficit:

; 2059 : 		{
; 2060 : 			strTemp.Format("Num Naval Units: %d, In Armies %d, ", m_iNumNavalUnits, m_iNumNavalUnitsInArmies);

	mov	ecx, DWORD PTR [ebp+76]
	mov	edx, DWORD PTR [ebp+68]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strTemp$227401[esp+176]
	push	OFFSET $SG227413
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN1@LogDeficit:

; 2061 : 		}
; 2062 : 		strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$227401[esp+168]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$227400[esp+172]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2063 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227400[esp+168]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ebx
	call	eax
	add	esp, 8

; 2064 : 	}

	lea	ecx, DWORD PTR _playerName$227402[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$227401[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227400[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
$LN3@LogDeficit:

; 2065 : }

	mov	ecx, DWORD PTR _pUnit$[esp+152]
	mov	DWORD PTR __$EHRec$[esp+164], -1
	pop	ebp
	test	ecx, ecx
	je	SHORT $LN64@LogDeficit
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@LogDeficit:
	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	mov	DWORD PTR fs:0, ecx
	add	esp, 152				; 00000098H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$227400[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$227401[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _playerName$227402[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$4:
	lea	ecx, DWORD PTR $T234668[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$5:
	lea	ecx, DWORD PTR $T234669[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDeficitScrapUnit@CvMilitaryAI@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvMilitaryAI::LogDeficitScrapUnit
PUBLIC	__real@3ecccccd
PUBLIC	__real@42c80000
PUBLIC	?UpdateBaseData@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateBaseData
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z:PROC ; CvPlayer::GetNumUnitsWithUnitAI
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetMoves@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetMoves
EXTRN	?getExtraIntercept@CvUnit@@QBEHXZ:PROC		; CvUnit::getExtraIntercept
EXTRN	?IsCanAttackRanged@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttackRanged
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT __real@3ecccccd
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?UpdateBaseData@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_bNavalMap$ = -17					; size = 1
tv501 = -16						; size = 4
$T234780 = -16						; size = 4
_iDifficulty$ = -16					; size = 4
_iNumUnitsWanted$ = -16					; size = 4
tv508 = -12						; size = 4
_fMultiplier$ = -12					; size = 4
$T234783 = -8						; size = 4
_iLoop$ = -8						; size = 4
tv477 = -4						; size = 4
$T234792 = -4						; size = 4
$T234784 = -4						; size = 4
$T234782 = -4						; size = 4
$T234781 = -4						; size = 4
$T234779 = -4						; size = 4
?UpdateBaseData@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateBaseData, COMDAT
; _this$ = ecx

; 2071 : {

	sub	esp, 20					; 00000014H
	push	ebx

; 2072 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateBaseData, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2073 : 
; 2074 : 	// Count how many Military Units I have right now
; 2075 : 	CvUnit* pLoopUnit;
; 2076 : 	int iLoop;
; 2077 : 
; 2078 : 	m_iNumLandUnits = 0;

	xor	ebx, ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2079 : 	m_iNumRangedLandUnits = 0;
; 2080 : 	m_iNumMobileLandUnits = 0;
; 2081 : 	m_iNumAirUnits = 0;
; 2082 : 	m_iNumAntiAirUnits = 0;
; 2083 : 	m_iNumMeleeLandUnits = 0;
; 2084 : 	m_iNumNavalUnits = 0;
; 2085 : 	m_iNumLandUnitsInArmies = 0;
; 2086 : 	m_iNumNavalUnitsInArmies = 0;
; 2087 : 
; 2088 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	ebx
	lea	eax, DWORD PTR _iLoop$[esp+40]
	push	eax
	mov	DWORD PTR [esi+52], ebx
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [esi+60], ebx
	mov	DWORD PTR [esi+80], ebx
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+64], ebx
	mov	DWORD PTR [esi+68], ebx
	mov	DWORD PTR [esi+72], ebx
	mov	DWORD PTR [esi+76], ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	cmp	edi, ebx
	je	$LN22@UpdateBase
	npad	3
$LL24@UpdateBase:

; 2089 : 	{
; 2090 : 		// Don't count civilians or exploration units
; 2091 : 		if(pLoopUnit->IsCanAttack() && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, edi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	je	$LN23@UpdateBase
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN23@UpdateBase
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN23@UpdateBase

; 2092 : 		{
; 2093 : 			if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 2094 : 			{
; 2095 : 				m_iNumLandUnits++;
; 2096 : 
; 2097 : 				if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, edi
	cmp	eax, 2
	jne	SHORT $LN20@UpdateBase
	mov	ebp, 1
	add	DWORD PTR [esi+52], ebp
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN19@UpdateBase

; 2098 : 				{
; 2099 : 					m_iNumLandUnitsInArmies++;

	add	DWORD PTR [esi+72], ebp
$LN19@UpdateBase:

; 2100 : 				}
; 2101 : 
; 2102 : 				if(pLoopUnit->IsCanAttackRanged())

	mov	ecx, edi
	call	?IsCanAttackRanged@CvUnit@@QBE_NXZ	; CvUnit::IsCanAttackRanged
	test	al, al
	je	SHORT $LN18@UpdateBase

; 2103 : 				{
; 2104 : 					m_iNumRangedLandUnits++;

	add	DWORD PTR [esi+56], ebp
	jmp	SHORT $LN23@UpdateBase
$LN18@UpdateBase:

; 2105 : 				}
; 2106 : 				else if(pLoopUnit->getExtraIntercept() > 0)

	mov	ecx, edi
	call	?getExtraIntercept@CvUnit@@QBEHXZ	; CvUnit::getExtraIntercept
	test	eax, eax
	jle	SHORT $LN16@UpdateBase

; 2107 : 				{
; 2108 : 					// I'm an anti-air unit
; 2109 : 					m_iNumAntiAirUnits++;

	add	DWORD PTR [esi+84], ebp
	jmp	SHORT $LN23@UpdateBase
$LN16@UpdateBase:

; 2110 : 				}
; 2111 : 				else if(pLoopUnit->getUnitInfo().GetMoves() > 2)

	mov	ecx, edi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetMoves@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMoves
	cmp	eax, 2
	jle	SHORT $LN14@UpdateBase

; 2112 : 				{
; 2113 : 					m_iNumMobileLandUnits++;

	add	DWORD PTR [esi+60], ebp

; 2114 : 				}
; 2115 : 				else

	jmp	SHORT $LN23@UpdateBase
$LN14@UpdateBase:

; 2116 : 				{
; 2117 : 					m_iNumMeleeLandUnits++;

	add	DWORD PTR [esi+64], ebp

; 2118 : 				}

	jmp	SHORT $LN23@UpdateBase
$LN20@UpdateBase:

; 2119 : 			}
; 2120 : 			else if(pLoopUnit->getDomainType() == DOMAIN_SEA)

	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 2121 : 			{
; 2122 : 				m_iNumNavalUnits++;
; 2123 : 
; 2124 : 				if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, edi
	test	eax, eax
	jne	SHORT $LN11@UpdateBase
	inc	DWORD PTR [esi+68]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN23@UpdateBase

; 2125 : 				{
; 2126 : 					m_iNumNavalUnitsInArmies++;

	inc	DWORD PTR [esi+76]

; 2127 : 				}
; 2128 : 			}

	jmp	SHORT $LN23@UpdateBase
$LN11@UpdateBase:

; 2129 : 			else if(pLoopUnit->getDomainType() == DOMAIN_AIR)

	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN23@UpdateBase

; 2130 : 			{
; 2131 : 				m_iNumAirUnits++;

	inc	DWORD PTR [esi+80]
$LN23@UpdateBase:

; 2079 : 	m_iNumRangedLandUnits = 0;
; 2080 : 	m_iNumMobileLandUnits = 0;
; 2081 : 	m_iNumAirUnits = 0;
; 2082 : 	m_iNumAntiAirUnits = 0;
; 2083 : 	m_iNumMeleeLandUnits = 0;
; 2084 : 	m_iNumNavalUnits = 0;
; 2085 : 	m_iNumLandUnitsInArmies = 0;
; 2086 : 	m_iNumNavalUnitsInArmies = 0;
; 2087 : 
; 2088 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	ebx
	lea	ecx, DWORD PTR _iLoop$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	cmp	edi, ebx
	jne	$LL24@UpdateBase
$LN22@UpdateBase:

; 2132 : 			}
; 2133 : 		}
; 2134 : 	}
; 2135 : 
; 2136 : 	float fMultiplier;
; 2137 : 	int iNumUnitsWanted = 0;
; 2138 : 	bool bNavalMap = false;
; 2139 : 	EconomicAIStrategyTypes eStrategyNavalMap = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NAVAL_MAP");

	push	ebx
	push	OFFSET $SG227442
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bNavalMap$[esp+44], bl
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2140 : 	if (m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyNavalMap))

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	test	al, al
	je	SHORT $LN7@UpdateBase

; 2141 : 	{
; 2142 : 		bNavalMap = true;

	mov	BYTE PTR _bNavalMap$[esp+36], 1
$LN7@UpdateBase:

; 2143 : 	}
; 2144 : 	int iFlavorOffense = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE"));

	push	ebx
	push	OFFSET $SG227446
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 2145 : 	int iFlavorDefense = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_DEFENSE"));

	push	ebx
	push	OFFSET $SG227449
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 2146 : 
; 2147 : 	// Scale up or down based on true threat level and a bit by flavors (multiplier should range from about 0.5 to about 1.5)
; 2148 : 	fMultiplier = (float)0.40 + (((float)(m_pPlayer->GetMilitaryAI()->GetHighestThreat() + iFlavorOffense + iFlavorDefense)) / (float)100.0);

	mov	ecx, DWORD PTR [esi]
	mov	ebp, eax
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ; CvMilitaryAI::GetHighestThreat
	add	eax, ebp
	add	eax, edi
	mov	DWORD PTR tv508[esp+36], eax
	fild	DWORD PTR tv508[esp+36]

; 2149 : 
; 2150 : 	// first get the number of defenders that we think we need
; 2151 : 
; 2152 : 	// Start with 3, to protect the capital
; 2153 : 	iNumUnitsWanted = GC.getAI_STRATEGY_DEFEND_MY_LANDS_BASE_UNITS();
; 2154 : 
; 2155 : 	// 1 Unit per City & 1 per Settler
; 2156 : 	iNumUnitsWanted += (int)(m_pPlayer->getNumCities() * /*1.0*/ GC.getAI_STRATEGY_DEFEND_MY_LANDS_UNITS_PER_CITY());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8104
	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2180
	fdiv	DWORD PTR __real@42c80000
	mov	DWORD PTR $T234792[esp+36], edx
	fadd	DWORD PTR __real@3ecccccd
	fstp	DWORD PTR _fMultiplier$[esp+36]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR tv501[esp+36], eax
	fild	DWORD PTR tv501[esp+36]
	fmul	DWORD PTR $T234792[esp+36]
	call	__ftol2_sse_excpt

; 2157 : 	iNumUnitsWanted += m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	mov	ecx, DWORD PTR [esi]
	mov	ebp, 1
	push	ebp
	push	ebp
	push	ebp
	add	edi, eax
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	add	edi, eax
	mov	DWORD PTR _iNumUnitsWanted$[esp+36], edi

; 2158 : 
; 2159 : 	m_iMandatoryReserveSize = (int)((float)iNumUnitsWanted * fMultiplier);

	fild	DWORD PTR _iNumUnitsWanted$[esp+36]
	lea	edi, DWORD PTR [esi+100]
	fmul	DWORD PTR _fMultiplier$[esp+36]
	call	__ftol2_sse_excpt
	mov	DWORD PTR [edi], eax

; 2160 : 
; 2161 : 	// add in a few for the difficulty level (all above Chieftain are boosted)
; 2162 : 	int iDifficulty = max(0,GC.getGame().getHandicapInfo().GetID() - 1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	eax, DWORD PTR [eax+4]
	sub	eax, ebp
	mov	DWORD PTR $T234779[esp+36], eax
	cmp	eax, ebx
	mov	DWORD PTR $T234780[esp+36], ebx
	lea	eax, DWORD PTR $T234779[esp+36]
	jg	SHORT $LN38@UpdateBase
	lea	eax, DWORD PTR $T234780[esp+36]
$LN38@UpdateBase:
	mov	eax, DWORD PTR [eax]

; 2163 : 	m_iMandatoryReserveSize += iDifficulty;

	add	DWORD PTR [edi], eax

; 2164 : 
; 2165 : 	m_iMandatoryReserveSize = max(1,m_iMandatoryReserveSize);

	cmp	DWORD PTR [edi], ebp
	mov	DWORD PTR _iDifficulty$[esp+36], eax
	mov	DWORD PTR $T234781[esp+36], ebp
	mov	eax, edi
	jg	SHORT $LN42@UpdateBase
	lea	eax, DWORD PTR $T234781[esp+36]
$LN42@UpdateBase:
	mov	eax, DWORD PTR [eax]

; 2166 : 
; 2167 : 	// now we add in the strike forces we think we will need
; 2168 : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN6@UpdateBase

; 2169 : 	{
; 2170 : 		m_iMandatoryReserveSize = max(1,m_iMandatoryReserveSize/2);

	mov	eax, DWORD PTR [edi]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T234782[esp+36], eax
	cmp	eax, ebp
	mov	DWORD PTR $T234783[esp+36], ebp
	lea	eax, DWORD PTR $T234782[esp+36]
	jg	SHORT $LN46@UpdateBase
	lea	eax, DWORD PTR $T234783[esp+36]
$LN46@UpdateBase:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi], ecx

; 2171 : 		iNumUnitsWanted = 0;

	xor	ebp, ebp

; 2172 : 	}
; 2173 : 	else

	jmp	SHORT $LN5@UpdateBase
$LN6@UpdateBase:

; 2174 : 	{
; 2175 : 		iNumUnitsWanted = 7; // size of a basic attack
; 2176 : 
; 2177 : 		// if we are going for conquest we want at least one more task force
; 2178 : 		bool bConquestGrandStrategy = false;
; 2179 : 		AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET $SG227467
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, 7
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebp, eax

; 2180 : 		if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	ebp, -1
	je	SHORT $LN2@UpdateBase

; 2181 : 		{
; 2182 : 			if(m_pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	ecx, DWORD PTR [esi]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, ebp
	jne	SHORT $LN2@UpdateBase

; 2183 : 			{
; 2184 : 				bConquestGrandStrategy = true;
; 2185 : 			}
; 2186 : 		}
; 2187 : 		if(bConquestGrandStrategy)
; 2188 : 		{
; 2189 : 			iNumUnitsWanted *= 2;

	mov	ebx, 14					; 0000000eH
$LN2@UpdateBase:

; 2190 : 		}
; 2191 : 
; 2192 : 		// add in a few more if the player is bold
; 2193 : 		iNumUnitsWanted += m_pPlayer->GetDiplomacyAI()->GetBoldness();

	mov	ecx, DWORD PTR [esi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	add	eax, DWORD PTR _iDifficulty$[esp+36]

; 2194 : 
; 2195 : 		// add in more if we are playing on a high difficulty
; 2196 : 		iNumUnitsWanted += iDifficulty;
; 2197 : 
; 2198 : 		iNumUnitsWanted = (int)((float)iNumUnitsWanted * fMultiplier);

	add	eax, ebx
	mov	DWORD PTR tv477[esp+36], eax
	fild	DWORD PTR tv477[esp+36]
	fmul	DWORD PTR _fMultiplier$[esp+36]
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iNumUnitsWanted$[esp+36], eax

; 2199 : 
; 2200 : 		iNumUnitsWanted = max(1,iNumUnitsWanted);

	cmp	eax, 1
	mov	DWORD PTR $T234784[esp+36], 1
	lea	eax, DWORD PTR _iNumUnitsWanted$[esp+36]
	jg	SHORT $LN50@UpdateBase
	lea	eax, DWORD PTR $T234784[esp+36]
$LN50@UpdateBase:
	mov	ebp, DWORD PTR [eax]
$LN5@UpdateBase:

; 2201 : 	}
; 2202 : 
; 2203 : 	if (bNavalMap)

	cmp	BYTE PTR _bNavalMap$[esp+36], 0
	je	SHORT $LN1@UpdateBase

; 2204 : 	{
; 2205 : 		iNumUnitsWanted *= 2;

	lea	ecx, DWORD PTR [ebp+ebp]

; 2206 : 		iNumUnitsWanted /= 3;

	mov	eax, 1431655766				; 55555556H
	imul	ecx

; 2207 : 		m_iMandatoryReserveSize *= 2;

	mov	ecx, DWORD PTR [edi]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	ecx, ecx
	mov	ebp, eax

; 2208 : 		m_iMandatoryReserveSize /= 3;

	mov	eax, 1431655766				; 55555556H
	imul	ecx
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR [edi], ecx
$LN1@UpdateBase:

; 2209 : 	}
; 2210 : 
; 2211 : 	m_iRecommendedMilitarySize = m_iMandatoryReserveSize + iNumUnitsWanted;

	mov	edx, DWORD PTR [edi]
	add	edx, ebp
	pop	edi
	mov	DWORD PTR [esi+96], edx
	pop	esi
	pop	ebp
	pop	ebx

; 2212 : }

	add	esp, 20					; 00000014H
	ret	0
?UpdateBaseData@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateBaseData
_TEXT	ENDS
PUBLIC	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::ScanForBarbarians
EXTRN	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z:PROC ; CvPlot::plotCount
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?ScanForBarbarians@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
$T234864 = -20						; size = 4
tv405 = -16						; size = 4
_iPlotLoop$ = -12					; size = 4
tv376 = -8						; size = 4
_iCityLoop$227509 = -4					; size = 4
?ScanForBarbarians@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::ScanForBarbarians, COMDAT
; _this$ = ecx

; 2265 : {

	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	edi, ecx

; 2266 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("ScanForBarbarians, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2267 : 
; 2268 : #ifdef AUI_WARNING_FIXES
; 2269 : 	uint iPlotLoop;
; 2270 : #else
; 2271 : 	int iPlotLoop;
; 2272 : #endif
; 2273 : 	CvPlot* pPlot;
; 2274 : 
; 2275 : 	m_iBarbarianCampCount = 0;
; 2276 : 	m_iVisibleBarbarianCount = 0;
; 2277 : 
; 2278 : 	TeamTypes eTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR [edi]
	xor	esi, esi
	mov	DWORD PTR [edi+88], esi
	mov	DWORD PTR [edi+92], esi
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN21@ScanForBar
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T234864[esp+28], eax
	jmp	SHORT $LN22@ScanForBar
$LN21@ScanForBar:
	mov	DWORD PTR $T234864[esp+28], -1
$LN22@ScanForBar:

; 2279 : 
; 2280 : 	// Look at revealed Barbarian camps and visible units
; 2281 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [edx+4028], esi
	mov	DWORD PTR _iPlotLoop$[esp+28], esi
	jle	$LN12@ScanForBar
	mov	ecx, DWORD PTR $T234864[esp+28]
	push	ebx
	mov	ebx, ecx
	shr	ebx, 5

; 2284 : 
; 2285 : 		if(pPlot->isRevealed(eTeam))

	mov	eax, ebx
	shl	eax, 5
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	push	ebp
	mov	DWORD PTR tv405[esp+36], esi
	mov	DWORD PTR tv376[esp+36], eax
	jmp	SHORT $LN14@ScanForBar
	npad	4
$LL70@ScanForBar:

; 2279 : 
; 2280 : 	// Look at revealed Barbarian camps and visible units
; 2281 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR tv376[esp+36]
$LN14@ScanForBar:

; 2282 : 	{
; 2283 : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	esi, DWORD PTR [edx+4068]
	add	esi, DWORD PTR tv405[esp+36]

; 2284 : 
; 2285 : 		if(pPlot->isRevealed(eTeam))

	test	DWORD PTR [esi+ebx*4+8], eax
	je	SHORT $LN68@ScanForBar

; 2286 : 		{
; 2287 : 			if(pPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, ebp
	jne	SHORT $LN68@ScanForBar

; 2288 : 			{
; 2289 : 				m_iBarbarianCampCount++;

	inc	DWORD PTR [edi+88]

; 2290 : 
; 2291 : 				// Count it as 10 camps if sitting inside our territory, that is annoying!
; 2292 : 				if(pPlot->getOwner() == m_pPlayer->GetID())

	movsx	edx, BYTE PTR [esi+4]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+88]
	cmp	edx, DWORD PTR [ecx+44]
	jne	SHORT $LN9@ScanForBar

; 2293 : 				{
; 2294 : 					m_iBarbarianCampCount += 9;

	add	eax, 9
	mov	DWORD PTR [edi+88], eax

; 2295 : 				}
; 2296 : 
; 2297 : 				// See how close it is to each of our cities, if less than 10 tiles, treat it as 5 camps
; 2298 : 				else

	jmp	SHORT $LN68@ScanForBar
$LN9@ScanForBar:

; 2299 : 				{
; 2300 : 					int iTolerableDistance = 10;
; 2301 : 					int iCityLoop;
; 2302 : 					CvCity *pLoopCity;
; 2303 : 					for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	eax, DWORD PTR _iCityLoop$227509[esp+40]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN68@ScanForBar
$LN73@ScanForBar:

; 2304 : 					{
; 2305 : 						if (pLoopCity)
; 2306 : 						{
; 2307 : 							int iDist = plotDistance(pLoopCity->getX(), pLoopCity->getY(), pPlot->getX(), pPlot->getY());
; 2308 : 							if (iDist < iTolerableDistance)

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR [eax+108]
	push	edx
	mov	edx, DWORD PTR [eax+96]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN65@ScanForBar
	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iCityLoop$227509[esp+40]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LN73@ScanForBar
	jmp	SHORT $LN68@ScanForBar
$LN65@ScanForBar:

; 2309 : 							{
; 2310 : 								m_iBarbarianCampCount += 4;

	add	DWORD PTR [edi+88], 4
$LN68@ScanForBar:

; 2311 : 								break;
; 2312 : 							}
; 2313 : 						}
; 2314 : 					}
; 2315 : 				}
; 2316 : 			}
; 2317 : 		}
; 2318 : 
; 2319 : 		if(pPlot->isVisible(eTeam))

	mov	eax, DWORD PTR $T234864[esp+36]
	cmp	eax, -1
	je	SHORT $LN13@ScanForBar
	mov	ecx, DWORD PTR [esi+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	je	SHORT $LN13@ScanForBar

; 2320 : 		{
; 2321 : 			if(pPlot->plotCount(NULL, -1, -1, BARBARIAN_PLAYER, BARBARIAN_TEAM))

	push	-1
	push	-1
	push	0
	push	63					; 0000003fH
	push	63					; 0000003fH
	push	-1
	push	-1
	push	0
	mov	ecx, esi
	call	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
	test	eax, eax
	je	SHORT $LN13@ScanForBar

; 2322 : 			{
; 2323 : 				m_iVisibleBarbarianCount++;

	inc	DWORD PTR [edi+92]
$LN13@ScanForBar:

; 2279 : 
; 2280 : 	// Look at revealed Barbarian camps and visible units
; 2281 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR _iPlotLoop$[esp+36]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv405[esp+36], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iPlotLoop$[esp+36], eax
	jl	$LL70@ScanForBar
	pop	ebp
	pop	ebx
$LN12@ScanForBar:
	pop	edi
	pop	esi

; 2324 : 			}
; 2325 : 		}
; 2326 : 	}
; 2327 : }

	add	esp, 20					; 00000014H
	ret	0
?ScanForBarbarians@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::ScanForBarbarians
_TEXT	ENDS
PUBLIC	?UpdateThreats@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateThreats
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateThreats@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
?UpdateThreats@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateThreats, COMDAT
; _this$ = ecx

; 2331 : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 2332 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateThreats, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2333 : 
; 2334 : 	ThreatTypes eMilitaryThreatType;
; 2335 : 
; 2336 : 	PlayerTypes eLoopPlayer;
; 2337 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
$LL7@UpdateThre:

; 2338 : 	{
; 2339 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 2340 : 
; 2341 : 		// Is this a player we have relations with?
; 2342 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pDiplomacyAI->IsPlayerValid(eLoopPlayer))

	mov	eax, DWORD PTR [esi]
	cmp	edi, DWORD PTR [eax+44]
	je	SHORT $LN6@UpdateThre
	mov	ecx, DWORD PTR [esi+4]
	push	0
	push	edi
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN6@UpdateThre

; 2343 : 		{
; 2344 : 			eMilitaryThreatType = m_pDiplomacyAI->GetMilitaryThreat(eLoopPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	?GetMilitaryThreat@CvDiplomacyAI@@QBE?AW4ThreatTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMilitaryThreat

; 2345 : 			if(eMilitaryThreatType != m_paeLastTurnMilitaryThreat[eLoopPlayer])

	mov	ecx, DWORD PTR [esi+28]
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx+edi*4]
	cmp	ebx, eax
	je	SHORT $LN6@UpdateThre

; 2346 : 			{
; 2347 : 				// Change in threat level
; 2348 : 				if(eMilitaryThreatType > m_paeLastTurnMilitaryThreat[eLoopPlayer])
; 2349 : 				{
; 2350 : 					ThreatIncrease(eMilitaryThreatType, (ThreatTypes)m_paeLastTurnMilitaryThreat[eLoopPlayer]);

	push	eax
	mov	ecx, esi
	push	ebx
	jle	SHORT $LN2@UpdateThre
	call	?ThreatIncrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatIncrease

; 2351 : 				}
; 2352 : 				else

	jmp	SHORT $LN1@UpdateThre
$LN2@UpdateThre:

; 2353 : 				{
; 2354 : 					ThreatDecrease(eMilitaryThreatType, (ThreatTypes)m_paeLastTurnMilitaryThreat[eLoopPlayer]);

	call	?ThreatDecrease@CvMilitaryAI@@AAEXW4ThreatTypes@@0@Z ; CvMilitaryAI::ThreatDecrease
$LN1@UpdateThre:

; 2355 : 				}
; 2356 : 
; 2357 : 				// Save off new value
; 2358 : 				m_paeLastTurnMilitaryThreat[eLoopPlayer] = eMilitaryThreatType;

	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [edx+edi*4], ebx
$LN6@UpdateThre:
	inc	edi
	cmp	edi, 22					; 00000016H
	jl	SHORT $LL7@UpdateThre
	pop	edi
	pop	esi
	pop	ebx

; 2359 : 			}
; 2360 : 		}
; 2361 : 	}
; 2362 : }

	ret	0
?UpdateThreats@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateThreats
_TEXT	ENDS
PUBLIC	?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::MakeOffensivePurchases
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_iCityLoop$227942 = -4					; size = 4
?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ PROC	; CvMilitaryAI::MakeOffensivePurchases, COMDAT
; _this$ = ecx

; 3307 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 3308 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("MakeOffensivePurchases, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3309 : 
; 3310 : 	CvUnit *pUnit;
; 3311 : 
; 3312 : 	if (m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [esi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN1@MakeOffens

; 3313 : 	{
; 3314 : 		return;
; 3315 : 	}
; 3316 : 
; 3317 : 	// Are we winning all the wars we are in?
; 3318 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET $SG227928
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3319 : 	if(!IsUsingStrategy(eStrategyAtWar) || m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, DWORD PTR [esi+12]
	cmp	BYTE PTR [eax+ecx], 0
	je	SHORT $LN19@MakeOffens
	mov	ecx, DWORD PTR [esi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	$LN1@MakeOffens
$LN19@MakeOffens:

; 3320 : 	{
; 3321 : 		// Do we have a high offensive personality flavor and our military could be larger?
; 3322 : 		if (m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE")) >= 7 &&
; 3323 : 			(GetPercentOfRecommendedMilitarySize() < 100 || m_eNavalDefenseState > DEFENSE_STATE_ENOUGH))

	push	0
	push	OFFSET $SG227933
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	cmp	eax, 7
	jl	$LN1@MakeOffens
	mov	ecx, DWORD PTR [esi+96]
	test	ecx, ecx
	jle	SHORT $LN35@MakeOffens
	mov	eax, DWORD PTR [esi+52]
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN17@MakeOffens
$LN35@MakeOffens:
	cmp	DWORD PTR [esi+116], 0
	jle	$LN1@MakeOffens
$LN17@MakeOffens:

; 3324 : 		{
; 3325 : 			// Do we have operations running (if so let them recruit the units)?
; 3326 : 			if (GetArmyBeingBuilt() == NO_ARMY_TYPE)

	cmp	DWORD PTR [esi+44], -1
	jne	$LN1@MakeOffens

; 3327 : 			{
; 3328 : 				CvCity *pCity = m_pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ebp, eax

; 3329 : 				if (pCity == NULL)

	test	ebp, ebp
	je	$LN36@MakeOffens

; 3330 : 				{
; 3331 : 					return;
; 3332 : 				}
; 3333 : 
; 3334 : 				// Do we need naval units most?
; 3335 : 				bool bNeedNaval = m_eNavalDefenseState > m_eLandDefenseState;

	mov	edx, DWORD PTR [esi+116]
	cmp	edx, DWORD PTR [esi+112]
	push	ebx
	setg	bl
	push	edi

; 3336 : 				if (bNeedNaval)

	test	bl, bl
	je	SHORT $LN8@MakeOffens

; 3337 : 				{
; 3338 : 					// Get a different city if capital is not coastal
; 3339 : 					if (!pCity->isCoastal())

	push	-1
	mov	ecx, ebp
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	jne	SHORT $LN10@MakeOffens

; 3340 : 					{
; 3341 : 						CvCity* pLoopCity;
; 3342 : 						int iCityLoop;
; 3343 : 						bNeedNaval = false;
; 3344 : 						for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL && !bNeedNaval; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [esi]
	push	0
	lea	eax, DWORD PTR _iCityLoop$227942[esp+24]
	push	eax
	xor	bl, bl
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN8@MakeOffens
	npad	6
$LL12@MakeOffens:
	test	bl, bl
	jne	SHORT $LN34@MakeOffens

; 3345 : 						{
; 3346 : 							if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, edi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN11@MakeOffens

; 3347 : 							{
; 3348 : 								bNeedNaval = true;

	mov	bl, 1

; 3349 : 								pCity = pLoopCity;

	mov	ebp, edi
$LN11@MakeOffens:
	push	0
	lea	ecx, DWORD PTR _iCityLoop$227942[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL12@MakeOffens
$LN10@MakeOffens:

; 3350 : 							}
; 3351 : 						}
; 3352 : 					}
; 3353 : 				}
; 3354 : 
; 3355 : 				if (bNeedNaval)

	test	bl, bl
	je	SHORT $LN8@MakeOffens
$LN34@MakeOffens:

; 3356 : 				{
; 3357 : 					pUnit = BuyEmergencyUnit(UNITAI_ASSAULT_SEA, pCity);

	push	ebp
	push	22					; 00000016H
	mov	ecx, esi
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit

; 3358 : 					if (!pUnit)

	test	eax, eax
	jne	SHORT $LN37@MakeOffens

; 3359 : 					{
; 3360 : 						pUnit = BuyEmergencyUnit(UNITAI_ATTACK_SEA, pCity);

	push	ebp
	push	18					; 00000012H

; 3381 : 						{
; 3382 : 							pUnit = BuyEmergencyUnit(UNITAI_RANGED, pCity);

	mov	ecx, esi
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi

; 3383 : 						}
; 3384 : 					}
; 3385 : 				}
; 3386 : 			}
; 3387 : 		}
; 3388 : 	}
; 3389 : }

	pop	ecx
	ret	0
$LN8@MakeOffens:

; 3361 : 					}
; 3362 : 				}
; 3363 : 				else
; 3364 : 				{
; 3365 : 					if (m_iNumMeleeLandUnits <= m_iNumRangedLandUnits)

	mov	edx, DWORD PTR [esi+64]
	cmp	edx, DWORD PTR [esi+56]

; 3366 : 					{
; 3367 : 						pUnit = BuyEmergencyUnit(UNITAI_FAST_ATTACK, pCity);

	push	ebp
	mov	ecx, esi
	jg	SHORT $LN5@MakeOffens
	push	5
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit

; 3368 : 						if (!pUnit)

	test	eax, eax
	jne	SHORT $LN37@MakeOffens

; 3369 : 						{
; 3370 : 							pUnit = BuyEmergencyUnit(UNITAI_ATTACK, pCity);

	push	ebp
	push	3
	mov	ecx, esi
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit

; 3371 : 							if (!pUnit)

	test	eax, eax
	jne	SHORT $LN37@MakeOffens

; 3372 : 							{
; 3373 : 								pUnit = BuyEmergencyUnit(UNITAI_DEFENSE, pCity);

	push	ebp
	push	6

; 3381 : 						{
; 3382 : 							pUnit = BuyEmergencyUnit(UNITAI_RANGED, pCity);

	mov	ecx, esi
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	pop	edi
	pop	ebx
	pop	ebp
	pop	esi

; 3383 : 						}
; 3384 : 					}
; 3385 : 				}
; 3386 : 			}
; 3387 : 		}
; 3388 : 	}
; 3389 : }

	pop	ecx
	ret	0
$LN5@MakeOffens:

; 3374 : 							}
; 3375 : 						}
; 3376 : 					}
; 3377 : 					else
; 3378 : 					{
; 3379 : 						pUnit = BuyEmergencyUnit(UNITAI_CITY_BOMBARD, pCity);

	push	4
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit

; 3380 : 						if (!pUnit)

	test	eax, eax
	jne	SHORT $LN37@MakeOffens

; 3381 : 						{
; 3382 : 							pUnit = BuyEmergencyUnit(UNITAI_RANGED, pCity);

	push	ebp
	push	8
	mov	ecx, esi
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
$LN37@MakeOffens:
	pop	edi
	pop	ebx
$LN36@MakeOffens:
	pop	ebp
$LN1@MakeOffens:
	pop	esi

; 3383 : 						}
; 3384 : 					}
; 3385 : 				}
; 3386 : 			}
; 3387 : 		}
; 3388 : 	}
; 3389 : }

	pop	ecx
	ret	0
?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ ENDP	; CvMilitaryAI::MakeOffensivePurchases
_TEXT	ENDS
PUBLIC	?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ; CvMilitaryAI::FindBestUnitToScrap
EXTRN	?GetPower@CvUnit@@QBEHXZ:PROC			; CvUnit::GetPower
EXTRN	?canScrap@CvUnit@@QBE_N_N@Z:PROC		; CvUnit::canScrap
EXTRN	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceTotal
EXTRN	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z:PROC ; CvUnitEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ:PROC ; CvUnit::GetUpgradeUnitType
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetObsoleteTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetObsoleteTech
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z$0
__ehfuncinfo$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
_TEXT	SEGMENT
_bSkipThisOne$228028 = -25				; size = 1
_iBestScore$ = -24					; size = 4
$T235003 = -20						; size = 4
_iUnitLoop$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_bLand$ = 12						; size = 1
_bDeficitForcedDisband$ = 16				; size = 1
_iReturnedScore$ = 20					; size = 4
?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z PROC ; CvMilitaryAI::FindBestUnitToScrap, COMDAT
; _this$ = ecx

; 3508 : {

	push	-1
	push	__ehhandler$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	DWORD PTR $T235003[esp+36], 0
	push	esi

; 3509 : 	CvUnit* pLoopUnit;
; 3510 : 	int iUnitLoop;
; 3511 : 	UnitHandle pBestUnit;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	ebx, ecx
	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 0

; 3621 : 			}
; 3622 : 		}
; 3623 : 	}
; 3624 : 
; 3625 : 	return pBestUnit;

	mov	ecx, DWORD PTR [ebx]
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+44]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+56], 0
	mov	DWORD PTR $T235003[esp+48], 1
	mov	DWORD PTR _iBestScore$[esp+48], 2147483647 ; 7fffffffH
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	ebp, eax
	test	ebp, ebp
	je	$LN65@FindBestUn
	push	edi
$LL70@FindBestUn:

; 3516 : 	{
; 3517 : 		bool bSkipThisOne = false;
; 3518 : 
; 3519 : 		if(!pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [ebp+1044], 0
	mov	BYTE PTR _bSkipThisOne$228028[esp+44], 0
	jle	$LN26@FindBestUn

; 3520 : 		{
; 3521 : 			continue;
; 3522 : 		}
; 3523 : 
; 3524 : 		if(bLand && pLoopUnit->getDomainType() != DOMAIN_LAND)

	mov	ecx, ebp
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	BYTE PTR _bLand$[esp+40], 0
	je	SHORT $LN63@FindBestUn
	cmp	eax, 2

; 3525 : 		{
; 3526 : 			continue;
; 3527 : 		}
; 3528 : 
; 3529 : 		if(!bLand && pLoopUnit->getDomainType() != DOMAIN_SEA)

	jmp	SHORT $LN72@FindBestUn
$LN63@FindBestUn:
	test	eax, eax
$LN72@FindBestUn:
	jne	$LN26@FindBestUn

; 3530 : 		{
; 3531 : 			continue;
; 3532 : 		}
; 3533 : 
; 3534 : 		// Following checks are for the case where the AI is trying to decide if it is a good idea to disband this unit (as opposed to when the game is FORCING the player to disband one)
; 3535 : 		if(!bDeficitForcedDisband)

	cmp	BYTE PTR _bDeficitForcedDisband$[esp+40], 0
	jne	$LN64@FindBestUn

; 3536 : 		{
; 3537 : 			if(bLand && m_eLandDefenseState == DEFENSE_STATE_CRITICAL)

	cmp	BYTE PTR _bLand$[esp+40], 0
	je	SHORT $LN62@FindBestUn
	cmp	DWORD PTR [ebx+112], 3

; 3538 : 			{
; 3539 : 				continue;
; 3540 : 			}
; 3541 : 			else if(!bLand && m_eNavalDefenseState == DEFENSE_STATE_CRITICAL)

	jmp	SHORT $LN73@FindBestUn
$LN62@FindBestUn:
	cmp	DWORD PTR [ebx+116], 3
$LN73@FindBestUn:
	je	$LN26@FindBestUn

; 3542 : 			{
; 3543 : 				continue;
; 3544 : 			}
; 3545 : 
; 3546 : 			// Is it in an army?
; 3547 : 			if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, ebp
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN26@FindBestUn

; 3548 : 			{
; 3549 : 				continue;
; 3550 : 			}
; 3551 : 
; 3552 : 			// Can I still build this unit? If so too new to scrap
; 3553 : 			if(bLand && m_pPlayer->canTrain(pLoopUnit->getUnitType(), false /*bContinue*/, false /*bTestVisible*/, true /*bIgnoreCost*/))

	cmp	BYTE PTR _bLand$[esp+40], 0
	je	SHORT $LN16@FindBestUn
	push	0
	push	0
	push	1
	push	0
	push	0
	mov	ecx, ebp
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvPlayer::canTrain
	test	al, al
	jne	$LN26@FindBestUn
$LN16@FindBestUn:

; 3554 : 			{
; 3555 : 				continue;
; 3556 : 			}
; 3557 : 
; 3558 : 			// Is this a unit who has an obsolete tech that I have researched?
; 3559 : 			CvUnitEntry& pUnitInfo = pLoopUnit->getUnitInfo();

	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	edi, eax

; 3560 : 			if((TechTypes)pUnitInfo.GetObsoleteTech() == NO_TECH)

	mov	ecx, edi
	call	?GetObsoleteTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetObsoleteTech
	cmp	eax, -1
	je	$LN26@FindBestUn

; 3561 : 			{
; 3562 : 				continue;
; 3563 : 			}
; 3564 : 
; 3565 : 			if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN42@FindBestUn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN43@FindBestUn
$LN42@FindBestUn:
	or	eax, -1
$LN43@FindBestUn:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, edi
	mov	esi, eax
	call	?GetObsoleteTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetObsoleteTech
	push	eax
	mov	ecx, esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN68@FindBestUn

; 3566 : 			{
; 3567 : 				continue;
; 3568 : 			}
; 3569 : 
; 3570 : 			// Is this unit's INTRINSIC power less than half that of the best unit I can build for this domain?
; 3571 : 			if((pLoopUnit->getUnitInfo().GetPower() * 2) >= GetPowerOfStrongestBuildableUnit(pLoopUnit->getDomainType()))

	mov	ecx, ebp
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	push	eax
	mov	ecx, ebx
	call	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
	mov	ecx, ebp
	mov	esi, eax
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetPower@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPower
	add	eax, eax
	cmp	eax, esi
	jge	$LN68@FindBestUn

; 3572 : 			{
; 3573 : 				continue;
; 3574 : 			}
; 3575 : 
; 3576 : 			// Does this unit's upgrade require a resource?
; 3577 : 			UnitTypes eUpgradeUnit = pLoopUnit->GetUpgradeUnitType();

	mov	ecx, ebp
	call	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ ; CvUnit::GetUpgradeUnitType

; 3578 : 			if(eUpgradeUnit != NO_UNIT)

	cmp	eax, -1
	je	$LN67@FindBestUn

; 3579 : 			{
; 3580 : 				CvUnitEntry* pUpgradeUnitInfo = GC.GetGameUnits()->GetEntry(eUpgradeUnit);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	edi, eax

; 3581 : 				if(pUpgradeUnitInfo != NULL)

	test	edi, edi
	je	SHORT $LN67@FindBestUn

; 3582 : 				{
; 3583 : #ifdef AUI_WARNING_FIXES
; 3584 : 					for(uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bSkipThisOne; iResourceLoop++)
; 3585 : #else
; 3586 : 					for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bSkipThisOne; iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN67@FindBestUn
	npad	4
$LL10@FindBestUn:
	cmp	BYTE PTR _bSkipThisOne$228028[esp+44], 0
	jne	$LN68@FindBestUn

; 3587 : #endif
; 3588 : 					{
; 3589 : 						ResourceTypes eResource = (ResourceTypes) iResourceLoop;
; 3590 : 						int iNumResourceNeeded = pUpgradeUnitInfo->GetResourceQuantityRequirement(eResource);

	push	esi
	mov	ecx, edi
	call	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ; CvUnitEntry::GetResourceQuantityRequirement

; 3591 : 
; 3592 : 						if(iNumResourceNeeded > 0)

	test	eax, eax
	jle	SHORT $LN9@FindBestUn

; 3593 : 						{
; 3594 : 							if(m_pPlayer->getNumResourceTotal(eResource) > 0)

	mov	ecx, DWORD PTR [ebx]
	push	1
	push	esi
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jle	SHORT $LN9@FindBestUn

; 3595 : 							{
; 3596 : 								if(bLand && m_eLandDefenseState > DEFENSE_STATE_NEUTRAL)

	cmp	BYTE PTR _bLand$[esp+40], 0
	je	SHORT $LN61@FindBestUn
	cmp	DWORD PTR [ebx+112], 1

; 3597 : 								{
; 3598 : 									bSkipThisOne  = true;    // We'll wait and try to upgrade this one, our unit count isn't that bad

	jmp	SHORT $LN74@FindBestUn
$LN61@FindBestUn:

; 3599 : 								}
; 3600 : 								else if(!bLand && m_eNavalDefenseState > DEFENSE_STATE_NEUTRAL)

	cmp	DWORD PTR [ebx+116], 1
$LN74@FindBestUn:
	jle	SHORT $LN9@FindBestUn

; 3601 : 								{
; 3602 : 									bSkipThisOne  = true;    // We'll wait and try to upgrade this one, our unit count isn't that bad

	mov	BYTE PTR _bSkipThisOne$228028[esp+44], 1
$LN9@FindBestUn:

; 3582 : 				{
; 3583 : #ifdef AUI_WARNING_FIXES
; 3584 : 					for(uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bSkipThisOne; iResourceLoop++)
; 3585 : #else
; 3586 : 					for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bSkipThisOne; iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL10@FindBestUn

; 3603 : 								}
; 3604 : 							}
; 3605 : 						}
; 3606 : 					}
; 3607 : 				}
; 3608 : 			}
; 3609 : 		}
; 3610 : 
; 3611 : 		// Can I scrap this unit?
; 3612 : 		if(!bSkipThisOne && pLoopUnit->canScrap())

	cmp	BYTE PTR _bSkipThisOne$228028[esp+44], 0
	jne	SHORT $LN68@FindBestUn
$LN67@FindBestUn:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+40]
$LN64@FindBestUn:
	push	0
	mov	ecx, ebp
	call	?canScrap@CvUnit@@QBE_N_N@Z		; CvUnit::canScrap
	test	al, al
	je	SHORT $LN26@FindBestUn

; 3613 : 		{
; 3614 : 			iScore = pLoopUnit->GetPower();

	mov	ecx, ebp
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower

; 3615 : 
; 3616 : 			if(iScore < iBestScore)

	cmp	eax, DWORD PTR _iBestScore$[esp+44]
	jge	SHORT $LN26@FindBestUn

; 3617 : 			{
; 3618 : 				iBestScore = iScore;
; 3619 : 				iReturnedScore = iBestScore;

	mov	edx, DWORD PTR _iReturnedScore$[esp+40]
	mov	DWORD PTR [edx], eax

; 3620 : 				pBestUnit = pLoopUnit;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _iBestScore$[esp+44], eax
	test	ecx, ecx
	je	SHORT $LN53@FindBestUn
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@FindBestUn:
	mov	ecx, ebp
	mov	DWORD PTR [esi], ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	SHORT $LN26@FindBestUn
$LN68@FindBestUn:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+40]
$LN26@FindBestUn:

; 3512 : 	int iScore;
; 3513 : 	int iBestScore = MAX_INT;
; 3514 : 
; 3515 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [ebx]
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+48]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL70@FindBestUn
	pop	edi
$LN65@FindBestUn:

; 3626 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z$0:
	mov	eax, DWORD PTR $T235003[ebp]
	and	eax, 1
	je	$LN31@FindBestUn
	and	DWORD PTR $T235003[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
$LN31@FindBestUn:
	ret	0
__ehhandler$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ENDP ; CvMilitaryAI::FindBestUnitToScrap
PUBLIC	?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z ; CvMilitaryAI::GetNumEnemyAirUnitsInRange
EXTRN	?canAirDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canAirDefend
EXTRN	?IsAirSweepCapable@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAirSweepCapable
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z
_TEXT	SEGMENT
_iRtnValue$ = -8					; size = 4
_this$ = -4						; size = 4
_iLoopUnit$228134 = 8					; size = 4
_pCenterPlot$ = 8					; size = 4
___formal$ = 12						; size = 4
_bCountFighters$ = 16					; size = 1
_bCountBombers$ = 20					; size = 1
?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z PROC ; CvMilitaryAI::GetNumEnemyAirUnitsInRange, COMDAT
; _this$ = ecx

; 3788 : {

	sub	esp, 8
	push	ebx
	push	ebp

; 3789 : 	int iRtnValue = 0;

	mov	ebp, DWORD PTR _pCenterPlot$[esp+12]
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _this$[esp+24], ecx
	mov	DWORD PTR _iRtnValue$[esp+24], ebx
	npad	11
$LL68@GetNumEnem:

; 3793 : 	{
; 3794 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3795 : 		if(kPlayer.isAlive() && kPlayer.GetID() != m_pPlayer->GetID())

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	edi, DWORD PTR [ebx+eax]
	je	$LN14@GetNumEnem
	mov	ecx, DWORD PTR _this$[esp+24]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [edi+44]
	cmp	ecx, eax
	je	$LN14@GetNumEnem

; 3796 : 		{
; 3797 : 			if (atWar(kPlayer.getTeam(), m_pPlayer->getTeam()))

	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN36@GetNumEnem
	mov	esi, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN37@GetNumEnem
$LN36@GetNumEnem:
	or	eax, -1
$LN37@GetNumEnem:
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN45@GetNumEnem
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN46@GetNumEnem
$LN45@GetNumEnem:
	or	ecx, -1
$LN46@GetNumEnem:
	push	eax
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN14@GetNumEnem

; 3798 : 			{
; 3799 : 				// Loop through their units looking for bombers (this will allow us to find bombers on carriers also
; 3800 : 				int iLoopUnit = 0;
; 3801 : 				for(CvUnit* pLoopUnit = kPlayer.firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoopUnit))

	push	0
	lea	eax, DWORD PTR _iLoopUnit$228134[esp+24]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _iLoopUnit$228134[esp+28], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN14@GetNumEnem
	npad	2
$LL10@GetNumEnem:

; 3802 : 				{
; 3803 : 					if (pLoopUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN9@GetNumEnem

; 3804 : 					{
; 3805 : 						if ( plotDistance(pCenterPlot->getX(), pCenterPlot->getY(), pLoopUnit->getX(), pLoopUnit->getY()) <= 10 )

	mov	ecx, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [esi+76]
	movsx	eax, WORD PTR [ebp+2]
	push	ecx
	movsx	ecx, WORD PTR [ebp]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 10					; 0000000aH
	jg	SHORT $LN9@GetNumEnem

; 3806 : 						{
; 3807 : 							// Let's not factor in revealed or visible - As a human I can remember past attacks and intuit whether a bomber could be in range of the city, AIs don't have great intuition...
; 3808 : 							if (pLoopUnit->IsAirSweepCapable() || pLoopUnit->canAirDefend())

	mov	ecx, esi
	call	?IsAirSweepCapable@CvUnit@@QBE_NXZ	; CvUnit::IsAirSweepCapable
	test	al, al
	jne	SHORT $LN4@GetNumEnem
	push	0
	mov	ecx, esi
	call	?canAirDefend@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirDefend
	test	al, al
	jne	SHORT $LN4@GetNumEnem

; 3811 : 							}
; 3812 : 							else
; 3813 : 							{
; 3814 : 								if (bCountBombers) iRtnValue++;

	cmp	BYTE PTR _bCountBombers$[esp+20], al
	jmp	SHORT $LN69@GetNumEnem
$LN4@GetNumEnem:

; 3809 : 							{
; 3810 : 								if (bCountFighters) iRtnValue++;

	cmp	BYTE PTR _bCountFighters$[esp+20], 0
$LN69@GetNumEnem:
	je	SHORT $LN9@GetNumEnem
	inc	DWORD PTR _iRtnValue$[esp+24]
$LN9@GetNumEnem:

; 3798 : 			{
; 3799 : 				// Loop through their units looking for bombers (this will allow us to find bombers on carriers also
; 3800 : 				int iLoopUnit = 0;
; 3801 : 				for(CvUnit* pLoopUnit = kPlayer.firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoopUnit))

	push	0
	lea	edx, DWORD PTR _iLoopUnit$228134[esp+24]
	push	edx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL10@GetNumEnem
$LN14@GetNumEnem:

; 3790 : 
; 3791 : 	// Loop through all the players
; 3792 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	ebx, 63236				; 0000f704H
	cmp	ebx, 4047104				; 003dc100H
	jl	$LL68@GetNumEnem

; 3815 : 							}
; 3816 : 						}
; 3817 : 					}
; 3818 : 				}
; 3819 : 
; 3820 : 				// Loop through each of their cities
; 3821 : 				//int iLoop;
; 3822 : 				//CvCity* pLoopCity;
; 3823 : 				//for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
; 3824 : 				//{
; 3825 : 				//	CvPlot *pCityPlot = pLoopCity->plot();
; 3826 : 				//	if (pCityPlot->isRevealed(m_pPlayer->getTeam()) && plotDistance(pCenterPlot->getX(), pCenterPlot->getY(), pLoopCity->getX(), pLoopCity->getY()) <= iRange)
; 3827 : 				//	{
; 3828 : 				//		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
; 3829 : 				//		{
; 3830 : 				//			CvUnit *pUnit = pCityPlot->getUnitByIndex(iUnitLoop);
; 3831 : 				//			{
; 3832 : 				//				if (pUnit->getDomainType() == DOMAIN_AIR)
; 3833 : 				//				{
; 3834 : 				//					if (pUnit->IsAirSweepCapable() || pUnit->canAirDefend())
; 3835 : 				//					{
; 3836 : 				//						if (bCountFighters) iRtnValue++;
; 3837 : 				//					}
; 3838 : 				//					else
; 3839 : 				//					{
; 3840 : 				//						if (bCountBombers) iRtnValue++;
; 3841 : 				//					}
; 3842 : 				//				}
; 3843 : 				//			}
; 3844 : 				//		}
; 3845 : 				//	}
; 3846 : 				//}
; 3847 : 			}
; 3848 : 		}
; 3849 : 	}
; 3850 : 
; 3851 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3852 : }

	add	esp, 8
	ret	16					; 00000010H
?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z ENDP ; CvMilitaryAI::GetNumEnemyAirUnitsInRange
_TEXT	ENDS
PUBLIC	?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ; CvMilitaryAI::GetBestAirSweepTarget
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?canAirSweepAt@CvUnit@@QBE_NHH@Z:PROC		; CvUnit::canAirSweepAt
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_iBestCount$ = -20					; size = 4
_kPlayer$228156 = -16					; size = 4
tv433 = -12						; size = 4
_pBestTarget$ = -8					; size = 4
_iLoop$228160 = -4					; size = 4
_pFighter$ = 8						; size = 4
?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvMilitaryAI::GetBestAirSweepTarget, COMDAT
; _this$ = ecx

; 3856 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 3857 : 	CvPlot *pBestTarget = NULL;

	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+40], ecx
	mov	DWORD PTR _pBestTarget$[esp+40], 0

; 3858 : 	int iBestCount = 0;

	mov	DWORD PTR _iBestCount$[esp+40], 0
	mov	DWORD PTR tv433[esp+40], esi
	npad	15
$LL98@GetBestAir:

; 3862 : 	{
; 3863 : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3864 : 		if(kPlayer.isAlive() && kPlayer.GetID() != m_pPlayer->GetID())

	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ebp, DWORD PTR [esi+eax]
	mov	DWORD PTR _kPlayer$228156[esp+40], ebp
	je	$LN16@GetBestAir
	mov	ecx, DWORD PTR _this$[esp+40]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ebp+44]
	cmp	ecx, eax
	je	$LN16@GetBestAir

; 3865 : 		{
; 3866 : 			if (atWar(kPlayer.getTeam(), m_pPlayer->getTeam()))

	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN38@GetBestAir
	mov	edi, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edi+eax*4]
	jmp	SHORT $LN39@GetBestAir
$LN38@GetBestAir:
	or	eax, -1
$LN39@GetBestAir:
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN47@GetBestAir
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN48@GetBestAir
$LN47@GetBestAir:
	or	ecx, -1
$LN48@GetBestAir:
	push	eax
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN16@GetBestAir

; 3867 : 			{
; 3868 : 				// Loop through each of their cities
; 3869 : 				int iLoop;
; 3870 : 				CvCity* pLoopCity;
; 3871 : 				for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$228160[esp+44]
	push	eax
	mov	ecx, ebp
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	$LN16@GetBestAir
	npad	2
$LL97@GetBestAir:

; 3872 : 				{
; 3873 : 					CvPlot *pCityPlot = pLoopCity->plot();

	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 3874 : 					if (pCityPlot->isVisible(m_pPlayer->getTeam()) && plotDistance(pFighter->getX(), pFighter->getY(), pLoopCity->getX(), pLoopCity->getY()) <= pFighter->GetRange())

	mov	ecx, DWORD PTR _this$[esp+40]
	mov	edx, DWORD PTR [ecx]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	$LN11@GetBestAir
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	cmp	eax, -1
	je	$LN11@GetBestAir
	mov	ecx, DWORD PTR [esi+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	je	$LN11@GetBestAir
	mov	eax, DWORD PTR [edi+108]
	mov	ebx, DWORD PTR _pFighter$[esp+36]
	mov	edi, DWORD PTR [edi+96]
	mov	ecx, DWORD PTR [ebx+88]
	mov	edx, DWORD PTR [ebx+76]
	push	eax
	push	edi
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ecx, ebx
	mov	edi, eax
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	edi, eax
	jg	SHORT $LN11@GetBestAir

; 3875 : 					{
; 3876 : 						if (pFighter->canAirSweepAt(pCityPlot->getX(), pCityPlot->getY()))

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?canAirSweepAt@CvUnit@@QBE_NHH@Z	; CvUnit::canAirSweepAt
	test	al, al
	je	SHORT $LN11@GetBestAir

; 3877 : 						{
; 3878 : 							int iCountFighters = 0;
; 3879 : 
; 3880 : #ifdef AUI_WARNING_FIXES
; 3881 : 							for (uint iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
; 3882 : #else
; 3883 : 							for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, esi
	xor	ebp, ebp
	xor	ebx, ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN5@GetBestAir
$LL7@GetBestAir:

; 3884 : #endif
; 3885 : 							{
; 3886 : 								CvUnit *pUnit = pCityPlot->getUnitByIndex(iUnitLoop);

	push	ebx
	mov	ecx, esi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	edi, eax

; 3887 : 								{
; 3888 : 									if (pUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN6@GetBestAir

; 3889 : 									{
; 3890 : 										if (pUnit->IsAirSweepCapable() || pUnit->canAirDefend())

	mov	ecx, edi
	call	?IsAirSweepCapable@CvUnit@@QBE_NXZ	; CvUnit::IsAirSweepCapable
	test	al, al
	jne	SHORT $LN2@GetBestAir
	push	0
	mov	ecx, edi
	call	?canAirDefend@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirDefend
	test	al, al
	je	SHORT $LN6@GetBestAir
$LN2@GetBestAir:

; 3891 : 										{
; 3892 : 											iCountFighters++;

	inc	ebp
$LN6@GetBestAir:

; 3877 : 						{
; 3878 : 							int iCountFighters = 0;
; 3879 : 
; 3880 : #ifdef AUI_WARNING_FIXES
; 3881 : 							for (uint iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
; 3882 : #else
; 3883 : 							for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, esi
	inc	ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebx, eax
	jl	SHORT $LL7@GetBestAir
$LN5@GetBestAir:

; 3893 : 										}
; 3894 : 									}
; 3895 : 								}
; 3896 : 							}
; 3897 : 
; 3898 : 							if (iCountFighters > iBestCount)

	cmp	ebp, DWORD PTR _iBestCount$[esp+40]
	jle	SHORT $LN95@GetBestAir

; 3899 : 							{
; 3900 : 								iBestCount = iCountFighters;

	mov	DWORD PTR _iBestCount$[esp+40], ebp

; 3901 : 								pBestTarget = pCityPlot;

	mov	DWORD PTR _pBestTarget$[esp+40], esi
$LN95@GetBestAir:
	mov	ebp, DWORD PTR _kPlayer$228156[esp+40]
$LN11@GetBestAir:

; 3867 : 			{
; 3868 : 				// Loop through each of their cities
; 3869 : 				int iLoop;
; 3870 : 				CvCity* pLoopCity;
; 3871 : 				for(pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$228160[esp+44]
	push	edx
	mov	ecx, ebp
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	$LL97@GetBestAir
	mov	esi, DWORD PTR tv433[esp+40]
$LN16@GetBestAir:

; 3859 : 
; 3860 : 	// Loop through all the players
; 3861 : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	mov	DWORD PTR tv433[esp+40], esi
	jl	$LL98@GetBestAir

; 3902 : 							}
; 3903 : 						}
; 3904 : 					}
; 3905 : 				}
; 3906 : 			}
; 3907 : 		}
; 3908 : 	}
; 3909 : 
; 3910 : 	return pBestTarget;

	mov	eax, DWORD PTR _pBestTarget$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3911 : }

	add	esp, 24					; 00000018H
	ret	4
?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvMilitaryAI::GetBestAirSweepTarget
_TEXT	ENDS
PUBLIC	?LogAvailableForces@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::LogAvailableForces
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?IsGreatAdmiral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatAdmiral
EXTRN	?IsGreatGeneral@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGreatGeneral
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
EXTRN	?TurnProcessed@CvUnit@@QBE_NXZ:PROC		; CvUnit::TurnProcessed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogAvailableForces@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogAvailableForces@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogAvailableForces@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$7
	DD	03H
	DD	FLAT:__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogAvailableForces@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
$T235512 = -208						; size = 4
$T235481 = -208						; size = 4
_iCapitalX$228276 = -204				; size = 4
_iCapitalY$228277 = -200				; size = 4
_iLoop$228290 = -196					; size = 4
$T235521 = -192						; size = 4
$T235526 = -188						; size = 4
_this$ = -184						; size = 4
$T235374 = -180						; size = 28
$T235373 = -180						; size = 28
$T235372 = -180						; size = 28
$T235371 = -180						; size = 28
_strTemp$228274 = -152					; size = 28
_playerName$228273 = -124				; size = 28
_strBaseString$228272 = -96				; size = 28
_strOutBuf$228271 = -68					; size = 28
$T235370 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogAvailableForces@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::LogAvailableForces, COMDAT
; _this$ = ecx

; 4065 : {

	push	-1
	push	__ehhandler$?LogAvailableForces@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	mov	ebx, ecx

; 4066 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+212], ebx
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN13@LogAvailab
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN13@LogAvailab

; 4067 : 	{
; 4068 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228271[esp+212]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4069 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$228272[esp+212]
	mov	DWORD PTR __$EHRec$[esp+220], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4070 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$228273[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4071 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228274[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4072 : 		FILogFile* pLog;
; 4073 : 		int iCapitalX = 0;
; 4074 : 		int iCapitalY = 0;
; 4075 : 		CvCity* pCapital = GetPlayer()->getCapitalCity();

	mov	ecx, DWORD PTR [ebx]
	mov	BYTE PTR __$EHRec$[esp+220], 3
	mov	DWORD PTR _iCapitalX$228276[esp+212], 0
	mov	DWORD PTR _iCapitalY$228277[esp+212], 0
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 4076 : 		if(pCapital)

	test	eax, eax
	je	SHORT $LN43@LogAvailab

; 4077 : 		{
; 4078 : 			iCapitalX = pCapital->getX();

	mov	ecx, DWORD PTR [eax+96]

; 4079 : 			iCapitalY = pCapital->getY();

	mov	edx, DWORD PTR [eax+108]
	mov	DWORD PTR _iCapitalX$228276[esp+212], ecx
	mov	DWORD PTR _iCapitalY$228277[esp+212], edx
$LN43@LogAvailab:

; 4080 : 		}
; 4081 : 
; 4082 : 		// Open the right file
; 4083 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [ebx]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$228273[esp+212]
	test	eax, eax
	je	SHORT $LN50@LogAvailab
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN49@LogAvailab
$LN50@LogAvailab:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN49@LogAvailab:
	push	esi
	push	edi

; 4084 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	0
	lea	eax, DWORD PTR _playerName$228273[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T235370[esp+228]
	push	ecx
	mov	ecx, ebx
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T235370[esp+220]
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4085 : 
; 4086 : 		// Get the leading info for this line
; 4087 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228272[esp+224]
	push	OFFSET $SG228281
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4088 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG228283
	lea	edx, DWORD PTR _playerName$228273[esp+236]
	push	edx
	lea	eax, DWORD PTR $T235371[esp+240]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228272[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235371[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4089 : 
; 4090 : 		if(m_eArmyTypeBeingBuilt == ARMY_TYPE_LAND)

	cmp	DWORD PTR [ebx+44], 0

; 4091 : 		{
; 4092 : 			strTemp = "Land Army Under Construction";

	lea	ecx, DWORD PTR _strTemp$228274[esp+220]
	jne	SHORT $LN11@LogAvailab
	push	OFFSET $SG228285

; 4093 : 		}
; 4094 : 		else

	jmp	SHORT $LN123@LogAvailab
$LN11@LogAvailab:

; 4095 : 		{
; 4096 : 			strTemp = "Naval Invasion Under Construction";

	push	OFFSET $SG228287
$LN123@LogAvailab:
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 4097 : 		}
; 4098 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$228274[esp+220]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$228272[esp+224]
	push	edx
	lea	eax, DWORD PTR $T235372[esp+228]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228271[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235372[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4099 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228271[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx

; 4100 : 
; 4101 : 		// Loop through our units
; 4102 : 		CvUnit* pLoopUnit;
; 4103 : 		int iLoop;
; 4104 : 		for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [ebx]
	add	esp, 8
	push	0
	lea	eax, DWORD PTR _iLoop$228290[esp+224]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN7@LogAvailab
	push	ebp
$LL9@LogAvailab:

; 4105 : 		{
; 4106 : 			// Never want immobile/dead units, explorers, ones that have already moved or automated human units
; 4107 : 			if(pLoopUnit->TurnProcessed() || pLoopUnit->isDelayedDeath() || pLoopUnit->AI_getUnitAIType() == UNITAI_UNKNOWN ||  pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE || !pLoopUnit->canMove() || pLoopUnit->isHuman())

	mov	ecx, esi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN8@LogAvailab
	mov	ecx, esi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN8@LogAvailab
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	test	eax, eax
	je	$LN8@LogAvailab
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN8@LogAvailab
	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN8@LogAvailab
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	$LN8@LogAvailab

; 4108 : 			{
; 4109 : 				continue;
; 4110 : 			}
; 4111 : 
; 4112 : 			// Now down to land and sea units ... in these groups our unit must have a base combat strength ... or be a great general/admiral
; 4113 : 			else if(!pLoopUnit->IsCombatUnit() && !(pLoopUnit->IsGreatGeneral() || pLoopUnit->IsGreatAdmiral()))

	cmp	DWORD PTR [esi+1044], 0
	jg	SHORT $LN3@LogAvailab
	mov	ecx, esi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	jne	SHORT $LN3@LogAvailab
	mov	ecx, esi
	call	?IsGreatAdmiral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatAdmiral
	test	al, al
	je	$LN8@LogAvailab
$LN3@LogAvailab:

; 4114 : 			{
; 4115 : 				continue;
; 4116 : 			}
; 4117 : 
; 4118 : 			// No units finishing up operations
; 4119 : 			else if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() >= GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	ebp, DWORD PTR [esi+124]
	mov	DWORD PTR $T235481[esp+224], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	edx, DWORD PTR $T235481[esp+224]
	add	edx, ebp
	cmp	edx, eax
	jge	$LN8@LogAvailab

; 4120 : 			{
; 4121 : 				continue;
; 4122 : 			}
; 4123 : 
; 4124 : 			int iArmyID = pLoopUnit->getArmyID();

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID

; 4125 : 			int iDist = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iCapitalX, iCapitalY);

	mov	edx, DWORD PTR _iCapitalY$228277[esp+224]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	mov	edx, DWORD PTR _iCapitalX$228276[esp+228]
	mov	ebp, eax
	mov	eax, DWORD PTR [esi+88]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 4126 : 			strTemp.Format("%s, Damage=%d, ArmyID=%d, X=%d, Y=%d, DistFromCap=%d", pLoopUnit->getName().GetCString(), pLoopUnit->getDamage(), iArmyID, pLoopUnit->getX(), pLoopUnit->getY(), iDist);

	lea	eax, DWORD PTR $T235373[esp+224]
	push	eax
	mov	ecx, esi
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [esi+76]
	mov	DWORD PTR $T235512[esp+224], ecx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+232], 7
	mov	DWORD PTR $T235521[esp+224], edx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T235521[esp+224]
	push	ebx
	mov	DWORD PTR $T235526[esp+228], eax
	mov	eax, DWORD PTR $T235512[esp+228]
	push	eax
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	edx, DWORD PTR $T235526[esp+240]
	push	eax
	push	edx
	lea	eax, DWORD PTR _strTemp$228274[esp+248]
	push	OFFSET $SG228303
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T235373[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4127 : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$228274[esp+224]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$228272[esp+228]
	push	edx
	lea	eax, DWORD PTR $T235374[esp+232]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228271[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 8
	call	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
	lea	ecx, DWORD PTR $T235374[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4128 : 
; 4129 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228271[esp+224]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	mov	ebx, DWORD PTR _this$[esp+232]
	add	esp, 8
$LN8@LogAvailab:
	mov	ecx, DWORD PTR [ebx]
	push	0
	lea	eax, DWORD PTR _iLoop$228290[esp+228]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	$LL9@LogAvailab
	pop	ebp
$LN7@LogAvailab:

; 4130 : 		}
; 4131 : 	}

	lea	ecx, DWORD PTR _strTemp$228274[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$228273[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$228272[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$228271[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
$LN13@LogAvailab:

; 4132 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$228271[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$228272[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _playerName$228273[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp$228274[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T235370[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T235371[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T235372[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T235373[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogAvailableForces@CvMilitaryAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T235374[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogAvailableForces@CvMilitaryAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogAvailableForces@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogAvailableForces@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::LogAvailableForces
PUBLIC	?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::LogWarStateChange
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
_TEXT	SEGMENT
_strTemp$228314 = -264					; size = 28
_playerName$228315 = -236				; size = 28
_strOutBuf$228312 = -208				; size = 28
_opponentName$228316 = -180				; size = 28
_strBaseString$228313 = -152				; size = 28
$T235569 = -124						; size = 28
$T235565 = -124						; size = 28
$T235568 = -96						; size = 28
$T235566 = -96						; size = 28
$T235564 = -68						; size = 28
$T235567 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
_eNewWarState$ = 12					; size = 4
_eOldWarState$ = 16					; size = 4
?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z PROC ; CvMilitaryAI::LogWarStateChange, COMDAT
; _this$ = ecx

; 4136 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 252				; 000000fcH
	push	edi
	mov	edi, ecx

; 4137 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN19@LogWarStat
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN19@LogWarStat
	push	ebx
	push	ebp
	push	esi

; 4138 : 	{
; 4139 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228312[esp+280]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4140 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$228313[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4141 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228314[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4142 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$228315[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4143 : 		CvString opponentName;

	lea	ecx, DWORD PTR _opponentName$228316[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4144 : 		FILogFile* pLog;
; 4145 : 
; 4146 : 		// Open the right file
; 4147 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$228315[esp+280]
	test	eax, eax
	je	SHORT $LN51@LogWarStat
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN50@LogWarStat
$LN51@LogWarStat:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN50@LogWarStat:

; 4148 : 		opponentName = GET_PLAYER(ePlayer).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _ePlayer$[esp+276]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _opponentName$228316[esp+280]
	test	eax, eax
	je	SHORT $LN57@LogWarStat
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN56@LogWarStat
$LN57@LogWarStat:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN56@LogWarStat:

; 4149 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	0
	lea	eax, DWORD PTR _playerName$228315[esp+284]
	push	eax
	lea	ecx, DWORD PTR $T235564[esp+288]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T235564[esp+280]
	mov	ebp, eax
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4150 : 
; 4151 : 		// Get the leading info for this line
; 4152 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228313[esp+284]
	push	OFFSET $SG228319
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4153 : 		strBaseString += playerName + ", vs. " + opponentName + ", New War State: ";

	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG228324
	lea	edx, DWORD PTR _playerName$228315[esp+296]
	push	edx
	lea	eax, DWORD PTR $T235565[esp+300]
	push	eax
	call	esi
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	lea	ecx, DWORD PTR _opponentName$228316[esp+304]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T235566[esp+312]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+324], 6
	call	edi
	push	OFFSET $SG228323
	push	eax
	lea	eax, DWORD PTR $T235567[esp+324]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+336], 7
	call	esi
	add	esp, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228313[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 8
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235567[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235566[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235565[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4154 : 
; 4155 : 		// New War State
; 4156 : 		switch(eNewWarState)

	mov	eax, DWORD PTR _eNewWarState$[esp+276]
	cmp	eax, 5
	ja	SHORT $LN10@LogWarStat
	jmp	DWORD PTR $LN91@LogWarStat[eax*4]
$LN16@LogWarStat:

; 4157 : 		{
; 4158 : 		case WAR_STATE_CALM:
; 4159 : 			strTemp.Format("Calm");

	push	OFFSET $SG228330

; 4160 : 			break;

	jmp	SHORT $LN87@LogWarStat
$LN15@LogWarStat:

; 4161 : 		case WAR_STATE_NEARLY_WON:
; 4162 : 			strTemp.Format("Nearly Won");

	push	OFFSET $SG228332
	lea	edx, DWORD PTR _strTemp$228314[esp+284]
	push	edx

; 4163 : 			break;

	jmp	SHORT $LN88@LogWarStat
$LN14@LogWarStat:

; 4164 : 		case WAR_STATE_OFFENSIVE:
; 4165 : 			strTemp.Format("Offensive");

	push	OFFSET $SG228334
	lea	eax, DWORD PTR _strTemp$228314[esp+284]
	push	eax

; 4166 : 			break;

	jmp	SHORT $LN88@LogWarStat
$LN13@LogWarStat:

; 4167 : 		case WAR_STATE_STALEMATE:
; 4168 : 			strTemp.Format("Stalemate");

	push	OFFSET $SG228336

; 4169 : 			break;

	jmp	SHORT $LN87@LogWarStat
$LN12@LogWarStat:

; 4170 : 		case WAR_STATE_DEFENSIVE:
; 4171 : 			strTemp.Format("Defensive");

	push	OFFSET $SG228338
	lea	edx, DWORD PTR _strTemp$228314[esp+284]
	push	edx

; 4172 : 			break;

	jmp	SHORT $LN88@LogWarStat
$LN11@LogWarStat:

; 4173 : 		case WAR_STATE_NEARLY_DEFEATED:
; 4174 : 			strTemp.Format("Nearly Defeated");

	push	OFFSET $SG228340
	lea	eax, DWORD PTR _strTemp$228314[esp+284]
	push	eax

; 4175 : 			break;

	jmp	SHORT $LN88@LogWarStat
$LN10@LogWarStat:

; 4176 : 		default:
; 4177 : 			strTemp.Format("XXX");

	push	OFFSET $SG228342
$LN87@LogWarStat:
	lea	ecx, DWORD PTR _strTemp$228314[esp+284]
	push	ecx
$LN88@LogWarStat:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4178 : 			break;
; 4179 : 		}
; 4180 : 		strOutBuf = strBaseString + strTemp + ", Old War State: ";

	lea	edx, DWORD PTR _strTemp$228314[esp+280]
	push	edx
	lea	eax, DWORD PTR _strBaseString$228313[esp+284]
	push	eax
	lea	ecx, DWORD PTR $T235568[esp+288]
	push	ecx
	call	edi
	push	OFFSET $SG228345
	push	eax
	lea	edx, DWORD PTR $T235569[esp+300]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+312], 9
	call	esi
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228312[esp+284]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235569[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235568[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4181 : 
; 4182 : 		// Old War State
; 4183 : 		switch(eOldWarState)

	mov	eax, DWORD PTR _eOldWarState$[esp+276]
	cmp	eax, 5
	ja	SHORT $LN1@LogWarStat
	jmp	DWORD PTR $LN92@LogWarStat[eax*4]
$LN7@LogWarStat:

; 4184 : 		{
; 4185 : 		case WAR_STATE_CALM:
; 4186 : 			strTemp.Format("Calm");

	push	OFFSET $SG228351

; 4187 : 			break;

	jmp	SHORT $LN89@LogWarStat
$LN6@LogWarStat:

; 4188 : 		case WAR_STATE_NEARLY_WON:
; 4189 : 			strTemp.Format("Nearly Won");

	push	OFFSET $SG228353
	lea	ecx, DWORD PTR _strTemp$228314[esp+284]
	push	ecx

; 4190 : 			break;

	jmp	SHORT $LN90@LogWarStat
$LN5@LogWarStat:

; 4191 : 		case WAR_STATE_OFFENSIVE:
; 4192 : 			strTemp.Format("Offensive");

	push	OFFSET $SG228355
	lea	edx, DWORD PTR _strTemp$228314[esp+284]
	push	edx

; 4193 : 			break;

	jmp	SHORT $LN90@LogWarStat
$LN4@LogWarStat:

; 4194 : 		case WAR_STATE_STALEMATE:
; 4195 : 			strTemp.Format("Stalemate");

	push	OFFSET $SG228357

; 4196 : 			break;

	jmp	SHORT $LN89@LogWarStat
$LN3@LogWarStat:

; 4197 : 		case WAR_STATE_DEFENSIVE:
; 4198 : 			strTemp.Format("Defensive");

	push	OFFSET $SG228359
	lea	ecx, DWORD PTR _strTemp$228314[esp+284]
	push	ecx

; 4199 : 			break;

	jmp	SHORT $LN90@LogWarStat
$LN2@LogWarStat:

; 4200 : 		case WAR_STATE_NEARLY_DEFEATED:
; 4201 : 			strTemp.Format("Nearly Defeated");

	push	OFFSET $SG228361
	lea	edx, DWORD PTR _strTemp$228314[esp+284]
	push	edx

; 4202 : 			break;

	jmp	SHORT $LN90@LogWarStat
$LN1@LogWarStat:

; 4203 : 		default:
; 4204 : 			strTemp.Format("XXX");

	push	OFFSET $SG228363
$LN89@LogWarStat:
	lea	eax, DWORD PTR _strTemp$228314[esp+284]
	push	eax
$LN90@LogWarStat:
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4205 : 			break;
; 4206 : 		}
; 4207 : 		strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$228314[esp+280]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$228312[esp+284]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4208 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228312[esp+280]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ebp
	call	eax
	add	esp, 8

; 4209 : 	}

	lea	ecx, DWORD PTR _opponentName$228316[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$228315[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228314[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$228313[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$228312[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebp
	pop	ebx
$LN19@LogWarStat:

; 4210 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+268]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 264				; 00000108H
	ret	12					; 0000000cH
	npad	3
$LN91@LogWarStat:
	DD	$LN11@LogWarStat
	DD	$LN12@LogWarStat
	DD	$LN13@LogWarStat
	DD	$LN16@LogWarStat
	DD	$LN14@LogWarStat
	DD	$LN15@LogWarStat
$LN92@LogWarStat:
	DD	$LN2@LogWarStat
	DD	$LN3@LogWarStat
	DD	$LN4@LogWarStat
	DD	$LN7@LogWarStat
	DD	$LN5@LogWarStat
	DD	$LN6@LogWarStat
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$228312[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$1:
	lea	ecx, DWORD PTR _strBaseString$228313[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$2:
	lea	ecx, DWORD PTR _strTemp$228314[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$3:
	lea	ecx, DWORD PTR _playerName$228315[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$4:
	lea	ecx, DWORD PTR _opponentName$228316[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$5:
	lea	ecx, DWORD PTR $T235564[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$6:
	lea	ecx, DWORD PTR $T235565[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$7:
	lea	ecx, DWORD PTR $T235566[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$8:
	lea	ecx, DWORD PTR $T235567[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$9:
	lea	ecx, DWORD PTR $T235568[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z$10:
	lea	ecx, DWORD PTR $T235569[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ENDP ; CvMilitaryAI::LogWarStateChange
PUBLIC	?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z ; CvMilitaryAI::LogScrapUnit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
_TEXT	SEGMENT
_strOutBuf$228371 = -152				; size = 28
_strTemp$228372 = -124					; size = 28
_playerName$228373 = -96				; size = 28
$T235677 = -68						; size = 28
$T235678 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_bDeficit$ = 16						; size = 1
_bConquest$ = 20					; size = 1
?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z PROC ; CvMilitaryAI::LogScrapUnit, COMDAT
; _this$ = ecx

; 4214 : {

	push	-1
	push	__ehhandler$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 140				; 0000008cH
	push	ebp
	mov	ebp, ecx

; 4215 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+164], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN7@LogScrapUn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN7@LogScrapUn

; 4216 : 	{
; 4217 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228371[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4218 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228372[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4219 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$228373[esp+156]
	mov	BYTE PTR __$EHRec$[esp+164], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4220 : 		FILogFile* pLog;
; 4221 : 
; 4222 : 		// Open the right file
; 4223 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+164], 3
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$228373[esp+156]
	test	eax, eax
	je	SHORT $LN26@LogScrapUn
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@LogScrapUn
$LN26@LogScrapUn:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@LogScrapUn:
	push	ebx
	push	esi
	push	edi

; 4224 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	0
	lea	eax, DWORD PTR _playerName$228373[esp+172]
	push	eax
	lea	ecx, DWORD PTR $T235677[esp+176]
	push	ecx
	mov	ecx, ebp
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+176], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T235677[esp+168]
	mov	ebx, eax
	mov	BYTE PTR __$EHRec$[esp+176], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4225 : 
; 4226 : 		strOutBuf.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228371[esp+172]
	push	OFFSET $SG228376
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4227 : 		strOutBuf += playerName + ", ";

	push	OFFSET $SG228378
	lea	edx, DWORD PTR _playerName$228373[esp+184]
	push	edx
	lea	eax, DWORD PTR $T235678[esp+188]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228371[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235678[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4228 : 
; 4229 : 		strTemp.Format("Scrapping %s, X: %d, Y: %d, ", pUnit->getUnitInfo().GetDescription(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$[esp+164]
	mov	esi, DWORD PTR [ecx+88]
	mov	edi, DWORD PTR [ecx+76]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$228372[esp+180]
	push	OFFSET $SG228379
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4230 : 		strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$228372[esp+168]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$228371[esp+172]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4231 : 		if(bDeficit)

	cmp	BYTE PTR _bDeficit$[esp+164], 0

; 4232 : 		{
; 4233 : 			strOutBuf += "IN DEFICIT, ";

	lea	ecx, DWORD PTR _strOutBuf$228371[esp+168]
	je	SHORT $LN6@LogScrapUn
	push	OFFSET $SG228381

; 4234 : 		}
; 4235 : 		else

	jmp	SHORT $LN71@LogScrapUn
$LN6@LogScrapUn:

; 4236 : 		{
; 4237 : 			strOutBuf += "Finances ok, ";

	push	OFFSET $SG228383
$LN71@LogScrapUn:
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4238 : 		}
; 4239 : 		if(bConquest)

	cmp	BYTE PTR _bConquest$[esp+164], 0

; 4240 : 		{
; 4241 : 			strOutBuf += "CONQUEST, ";

	lea	ecx, DWORD PTR _strOutBuf$228371[esp+168]
	je	SHORT $LN4@LogScrapUn
	push	OFFSET $SG228385

; 4242 : 		}
; 4243 : 		else

	jmp	SHORT $LN72@LogScrapUn
$LN4@LogScrapUn:

; 4244 : 		{
; 4245 : 			strOutBuf += "Other GS, ";

	push	OFFSET $SG228387
$LN72@LogScrapUn:
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4246 : 		}
; 4247 : 		if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pUnit$[esp+164]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN2@LogScrapUn

; 4248 : 		{
; 4249 : 			strTemp.Format("Num Land Units: %d, In Armies %d, Rec Size: %d, ", m_iNumLandUnits, m_iNumLandUnitsInArmies, m_iRecommendedMilitarySize);

	mov	eax, DWORD PTR [ebp+96]
	mov	ecx, DWORD PTR [ebp+72]
	mov	edx, DWORD PTR [ebp+52]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strTemp$228372[esp+180]
	push	OFFSET $SG228389
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4250 : 		}
; 4251 : 		else

	jmp	SHORT $LN1@LogScrapUn
$LN2@LogScrapUn:

; 4252 : 		{
; 4253 : 			strTemp.Format("Num Naval Units: %d, In Armies %d, ", m_iNumNavalUnits, m_iNumNavalUnitsInArmies);

	mov	ecx, DWORD PTR [ebp+76]
	mov	edx, DWORD PTR [ebp+68]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strTemp$228372[esp+176]
	push	OFFSET $SG228391
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN1@LogScrapUn:

; 4254 : 		}
; 4255 : 		strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$228372[esp+168]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$228371[esp+172]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4256 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228371[esp+168]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ebx
	call	eax
	add	esp, 8

; 4257 : 	}

	lea	ecx, DWORD PTR _playerName$228373[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228372[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$228371[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
$LN7@LogScrapUn:

; 4258 : }

	mov	ecx, DWORD PTR _pUnit$[esp+152]
	mov	DWORD PTR __$EHRec$[esp+164], -1
	pop	ebp
	test	ecx, ecx
	je	SHORT $LN68@LogScrapUn
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN68@LogScrapUn:
	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	mov	DWORD PTR fs:0, ecx
	add	esp, 152				; 00000098H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$228371[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$2:
	lea	ecx, DWORD PTR _strTemp$228372[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$3:
	lea	ecx, DWORD PTR _playerName$228373[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$4:
	lea	ecx, DWORD PTR $T235677[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z$5:
	lea	ecx, DWORD PTR $T235678[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z ENDP ; CvMilitaryAI::LogScrapUnit
PUBLIC	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
_strBaseString$228398 = -152				; size = 28
_strOutBuf$228397 = -124				; size = 28
$T235792 = -96						; size = 28
$T235791 = -96						; size = 28
_strPlayerName$228399 = -68				; size = 28
$T235790 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z PROC ; CvMilitaryAI::LogMilitarySummaryMessage, COMDAT
; _this$ = ecx

; 4262 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 140				; 0000008cH
	push	edi
	mov	edi, ecx

; 4263 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogMilitar
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogMilitar

; 4264 : 	{
; 4265 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228397[esp+156]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4266 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$228398[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4267 : 		CvString strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+164], 1
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN19@LogMilitar
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN19@LogMilitar:
	push	ebx
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$228399[esp+168]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	bl, 2
	mov	BYTE PTR __$EHRec$[esp+172], bl

; 4268 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName, true/*bSummary*/), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	1
	lea	eax, DWORD PTR _strPlayerName$228399[esp+168]
	push	eax
	lea	ecx, DWORD PTR $T235790[esp+172]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+172], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T235790[esp+164]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+172], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4269 : 
; 4270 : 		// Get the leading info for this line
; 4271 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228398[esp+168]
	push	OFFSET $SG228402
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4272 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET $SG228404
	lea	edx, DWORD PTR _strPlayerName$228399[esp+180]
	push	edx
	lea	eax, DWORD PTR $T235791[esp+184]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228398[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235791[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4273 : 		strOutBuf = strBaseString + strMsg;

	mov	ecx, DWORD PTR _strMsg$[esp+160]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$228398[esp+168]
	push	edx
	lea	eax, DWORD PTR $T235792[esp+172]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+172], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228397[esp+168]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235792[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4274 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228397[esp+164]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 4275 : 	}

	mov	BYTE PTR __$EHRec$[esp+172], 1
	lea	ecx, DWORD PTR _strPlayerName$228399[esp+164]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$228398[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$228397[esp+164]
	mov	DWORD PTR __$EHRec$[esp+172], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogMilitar:

; 4276 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+156]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 152				; 00000098H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$228397[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$228398[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$228399[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$3:
	lea	ecx, DWORD PTR $T235790[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$4:
	lea	ecx, DWORD PTR $T235791[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z$5:
	lea	ecx, DWORD PTR $T235792[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ENDP ; CvMilitaryAI::LogMilitarySummaryMessage
PUBLIC	?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_AtWar
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::IsTestStrategy_AtWar, COMDAT

; 4488 : 	return (pPlayer->GetMilitaryAI()->GetNumberCivsAtWarWith() > 0);

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetNumberCivsAtWarWith
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 4489 : }

	ret	0
?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_AtWar
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians
EXTRN	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ:PROC ; CvUnit::GetOriginalOwner
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_iBarbarianCampCount$ = 16				; size = 4
_iVisibleBarbarianCount$ = 20				; size = 4
?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians, COMDAT

; 4521 : {

	push	ecx
	push	esi
	push	edi

; 4522 : 	int iStrategyWeight;
; 4523 : 	PlayerTypes eOtherPlayer;
; 4524 : 
; 4525 : 	// If we're at war don't bother with this Strategy (unless it is clear we are already winning)
; 4526 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET $SG228532
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4527 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	mov	edi, DWORD PTR _pPlayer$[esp+8]
	mov	esi, eax
	cmp	esi, -1
	je	SHORT $LN16@IsTestStra@12

; 4528 : 	{
; 4529 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	ecx, edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	eax, DWORD PTR [eax+12]
	cmp	BYTE PTR [esi+eax], 0
	je	SHORT $LN16@IsTestStra@12

; 4530 : 		{
; 4531 : 			if(!pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	test	eax, eax
	jne	SHORT $LN16@IsTestStra@12
	pop	edi

; 4532 : 			{
; 4533 : 				return false;

	xor	al, al
	pop	esi

; 4585 : }

	pop	ecx
	ret	0
$LN16@IsTestStra@12:
	push	ebx
	push	ebp

; 4534 : 			}
; 4535 : 		}
; 4536 : 	}
; 4537 : 
; 4538 : 	// We ARE getting our guys back
; 4539 : 	CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 4540 : 	CvUnit* pLoopUnit = NULL;
; 4541 : 	int iLoop;
; 4542 : 	for (pLoopUnit = BarbPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+24]
	add	ebp, 3983868				; 003cc9fcH
	push	ecx
	mov	ecx, ebp
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN13@IsTestStra@12
	npad	7
$LL15@IsTestStra@12:

; 4543 : 	{
; 4544 : 		if (pLoopUnit->GetOriginalOwner() == pPlayer->GetID() && (pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER))

	mov	ebx, DWORD PTR [edi+44]
	mov	ecx, esi
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	cmp	eax, ebx
	jne	SHORT $LN14@IsTestStra@12
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	$LN45@IsTestStra@12
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN45@IsTestStra@12
$LN14@IsTestStra@12:

; 4540 : 	CvUnit* pLoopUnit = NULL;
; 4541 : 	int iLoop;
; 4542 : 	for (pLoopUnit = BarbPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+24]
	push	edx
	mov	ecx, ebp
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL15@IsTestStra@12
$LN13@IsTestStra@12:

; 4545 : 		{
; 4546 : 			return true;
; 4547 : 		}
; 4548 : 	}
; 4549 : 
; 4550 : 	CvMilitaryAIStrategyXMLEntry* pStrategy = pPlayer->GetMilitaryAI()->GetMilitaryAIStrategies()->GetEntry(eStrategy);

	mov	ecx, edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _eStrategy$[esp+16]
	mov	ebx, DWORD PTR [ecx+eax*4]

; 4551 : 	CvAssert(pStrategy != NULL);
; 4552 : 	if(pStrategy)

	test	ebx, ebx
	je	SHORT $LN1@IsTestStra@12

; 4553 : 	{
; 4554 : 		iStrategyWeight = iBarbarianCampCount * 50 + iVisibleBarbarianCount * 25;   // Two visible camps or 3 roving Barbarians will trigger this

	mov	edx, DWORD PTR _iBarbarianCampCount$[esp+16]
	mov	ebp, DWORD PTR _iVisibleBarbarianCount$[esp+16]
	lea	esi, DWORD PTR [ebp+edx*2]

; 4555 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);

	push	edi
	imul	esi, 25					; 00000019H
	push	eax
	call	?GetWeightThresholdModifier@MilitaryAIHelpers@@YAHW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::GetWeightThresholdModifier

; 4556 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;

	mov	ecx, DWORD PTR [ebx+268]
	add	ecx, eax

; 4557 : 
; 4558 : 		if(iStrategyWeight >= iWeightThreshold * 2 && iVisibleBarbarianCount > 0) // barbs are a big threat, our sneak attack plan can wait

	lea	eax, DWORD PTR [ecx+ecx]
	add	esp, 8
	cmp	esi, eax
	jl	SHORT $LN42@IsTestStra@12
	test	ebp, ebp

; 4559 : 		{
; 4560 : 			return true;

	jg	SHORT $LN45@IsTestStra@12
$LN42@IsTestStra@12:

; 4561 : 		}
; 4562 : 		else if(iStrategyWeight >= iWeightThreshold)

	cmp	esi, ecx

; 4563 : 		{
; 4564 : 			// Also don't bother if we're building up for a sneak attack
; 4565 : 			CvDiplomacyAI* pkDiplomacyAI = pPlayer->GetDiplomacyAI();

	mov	ecx, edi
	jl	SHORT $LN7@IsTestStra@12
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	edi, eax

; 4566 : 			for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)

	xor	esi, esi
$LL6@IsTestStra@12:

; 4567 : 			{
; 4568 : 				eOtherPlayer = (PlayerTypes) iMajorLoop;
; 4569 : 				if(pkDiplomacyAI->GetWarGoal(eOtherPlayer) == WAR_GOAL_PREPARE)

	push	esi
	mov	ecx, edi
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, 1
	je	SHORT $LN1@IsTestStra@12
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL6@IsTestStra@12
$LN45@IsTestStra@12:
	pop	ebp
	pop	ebx
	pop	edi

; 4570 : 				{
; 4571 : 					return false;
; 4572 : 				}
; 4573 : 			}
; 4574 : 
; 4575 : 			return true;

	mov	al, 1
	pop	esi

; 4585 : }

	pop	ecx
	ret	0
$LN7@IsTestStra@12:

; 4576 : 		}
; 4577 : 		// If we have an operation of this type running, we don't want to turn this strategy off
; 4578 : 		else if(pPlayer->haveAIOperationOfType(AI_OPERATION_DESTROY_BARBARIAN_CAMP))

	push	0
	push	-1
	push	0
	push	3
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al

; 4579 : 		{
; 4580 : 			return true;

	jne	SHORT $LN45@IsTestStra@12
$LN1@IsTestStra@12:
	pop	ebp
	pop	ebx
	pop	edi

; 4581 : 		}
; 4582 : 	}
; 4583 : 
; 4584 : 	return false;

	xor	al, al
	pop	esi

; 4585 : }

	pop	ecx
	ret	0
?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
$T235907 = -8						; size = 4
$T235908 = -4						; size = 4
_pPlayer$ = 8						; size = 4
_iNumAA$ = 12						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits, COMDAT

; 4685 : {

	sub	esp, 8
	push	ebx

; 4686 : 	bool bAnyAirforce = false;
; 4687 : 	PlayerTypes eLoopPlayer;
; 4688 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	ebx, DWORD PTR _pPlayer$[esp+8]
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	npad	2
$LL7@IsTestStra@13:

; 4689 : 	{
; 4690 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 4691 : 		if(eLoopPlayer != pPlayer->GetID() && pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	cmp	edi, DWORD PTR [ebx+44]
	je	SHORT $LN6@IsTestStra@13
	push	0
	push	edi
	mov	ecx, ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN6@IsTestStra@13

; 4692 : 		{
; 4693 : 			if(GET_PLAYER(eLoopPlayer).GetMilitaryAI()->HasAirforce())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+80], 0
	jg	SHORT $LN23@IsTestStra@13
$LN6@IsTestStra@13:

; 4686 : 	bool bAnyAirforce = false;
; 4687 : 	PlayerTypes eLoopPlayer;
; 4688 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL7@IsTestStra@13
	pop	edi
	pop	esi

; 4705 : 	}
; 4706 : 	else
; 4707 : 	{
; 4708 : 		return true;

	mov	al, 1
	pop	ebx

; 4709 : 	}
; 4710 : }

	add	esp, 8
	ret	0
$LN23@IsTestStra@13:

; 4694 : 			{
; 4695 : 				bAnyAirforce = true;
; 4696 : 				break;
; 4697 : 			}
; 4698 : 		}
; 4699 : 	}
; 4700 : 
; 4701 : 	if(bAnyAirforce)
; 4702 : 	{
; 4703 : 		int iRatio = (iNumAA * 10) / max(1,iNumMelee+iNumAA);

	mov	ecx, DWORD PTR _iNumAA$[esp+16]
	mov	edx, DWORD PTR _iNumMelee$[esp+16]
	lea	eax, DWORD PTR [ecx+edx]
	cmp	eax, 1
	mov	DWORD PTR $T235907[esp+20], eax
	mov	DWORD PTR $T235908[esp+20], 1
	lea	esi, DWORD PTR $T235907[esp+20]
	jg	SHORT $LN21@IsTestStra@13
	lea	esi, DWORD PTR $T235908[esp+20]
$LN21@IsTestStra@13:
	lea	eax, DWORD PTR [ecx+ecx*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [esi]

; 4704 : 		return (iRatio > 2);

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	cmp	eax, 2
	setg	cl
	mov	al, cl

; 4709 : 	}
; 4710 : }

	add	esp, 8
	ret	0
?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z
_TEXT	SEGMENT
$T235942 = -8						; size = 4
$T235943 = -4						; size = 4
_pPlayer$ = 8						; size = 4
_iNumAA$ = 12						; size = 4
_iNumMelee$ = 16					; size = 4
?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z PROC ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits, COMDAT

; 4714 : {

	sub	esp, 8
	push	ebx

; 4715 : 	bool bAnyAirforce = false;
; 4716 : 	PlayerTypes eLoopPlayer;
; 4717 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	ebx, DWORD PTR _pPlayer$[esp+8]
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	npad	2
$LL7@IsTestStra@14:

; 4718 : 	{
; 4719 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 4720 : 		if(eLoopPlayer != pPlayer->GetID() && pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	cmp	edi, DWORD PTR [ebx+44]
	je	SHORT $LN6@IsTestStra@14
	push	0
	push	edi
	mov	ecx, ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN6@IsTestStra@14

; 4721 : 		{
; 4722 : 			if(GET_PLAYER(eLoopPlayer).GetMilitaryAI()->HasAirforce())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+80], 0
	jg	SHORT $LN23@IsTestStra@14
$LN6@IsTestStra@14:

; 4715 : 	bool bAnyAirforce = false;
; 4716 : 	PlayerTypes eLoopPlayer;
; 4717 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL7@IsTestStra@14
	pop	edi
	pop	esi

; 4734 : 	}
; 4735 : 	else
; 4736 : 	{
; 4737 : 		return false;

	xor	al, al
	pop	ebx

; 4738 : 	}
; 4739 : }

	add	esp, 8
	ret	0
$LN23@IsTestStra@14:

; 4723 : 			{
; 4724 : 				bAnyAirforce = true;
; 4725 : 				break;
; 4726 : 			}
; 4727 : 		}
; 4728 : 	}
; 4729 : 
; 4730 : 	if(bAnyAirforce)
; 4731 : 	{
; 4732 : 		int iRatio = (iNumAA * 10) / max(1,iNumMelee+iNumAA);

	mov	ecx, DWORD PTR _iNumAA$[esp+16]
	mov	edx, DWORD PTR _iNumMelee$[esp+16]
	lea	eax, DWORD PTR [ecx+edx]
	cmp	eax, 1
	mov	DWORD PTR $T235942[esp+20], eax
	mov	DWORD PTR $T235943[esp+20], 1
	lea	esi, DWORD PTR $T235942[esp+20]
	jg	SHORT $LN21@IsTestStra@14
	lea	esi, DWORD PTR $T235943[esp+20]
$LN21@IsTestStra@14:
	lea	eax, DWORD PTR [ecx+ecx*4]
	add	eax, eax
	cdq
	idiv	DWORD PTR [esi]

; 4733 : 		return (iRatio <= 2);

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	cmp	eax, 2
	setle	cl
	mov	al, cl

; 4738 : 	}
; 4739 : }

	add	esp, 8
	ret	0
?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ENDP ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits
_TEXT	ENDS
PUBLIC	__real@4044000000000000
PUBLIC	__real@3fe8000000000000
PUBLIC	__real@4010000000000000
PUBLIC	?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ; MilitaryAIHelpers::ComputeRecommendedNavySize
EXTRN	?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ:PROC	; CvCivilizationInfo::isCoastalCiv
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
;	COMDAT __real@4044000000000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@3fe8000000000000
CONST	SEGMENT
__real@3fe8000000000000 DQ 03fe8000000000000r	; 0.75
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
CONST	ENDS
;	COMDAT ?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iLoop$ = -16						; size = 4
tv269 = -12						; size = 4
_iGT$ = -12						; size = 4
$T235977 = -12						; size = 4
_dMultiplier$ = -12					; size = 8
tv266 = -4						; size = 4
$T235978 = -4						; size = 4
_iFlavorNaval$ = -4					; size = 4
_iNumUnitsWanted$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z PROC ; MilitaryAIHelpers::ComputeRecommendedNavySize, COMDAT

; 4794 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4795 : 	int iNumUnitsWanted = 0;
; 4796 : 	int iFlavorNaval = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL"));

	push	0
	push	OFFSET $SG228718
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, DWORD PTR _pPlayer$[esp+28]
	push	eax
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorNaval$[esp+32], eax

; 4797 : 	// cap at 10?
; 4798 : 
; 4799 : 	double dMultiplier;
; 4800 : 
; 4801 : 	// Start with 1
; 4802 : 	iNumUnitsWanted = 1;
; 4803 : 
; 4804 : 	int iNumCoastalCities = 0;

	xor	edi, edi

; 4805 : 	int iLoop;
; 4806 : 	CvCity* pCity;
; 4807 : 	for(pCity = pPlayer->firstCity(&iLoop); pCity != NULL; pCity = pPlayer->nextCity(&iLoop))

	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+36]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN7@ComputeRec
$LL9@ComputeRec:

; 4808 : 	{
; 4809 : 		if(pCity->isCoastal(-1))

	push	-1
	mov	ecx, eax
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN8@ComputeRec

; 4810 : 		{
; 4811 : 			iNumCoastalCities++;

	inc	edi
$LN8@ComputeRec:

; 4805 : 	int iLoop;
; 4806 : 	CvCity* pCity;
; 4807 : 	for(pCity = pPlayer->firstCity(&iLoop); pCity != NULL; pCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+36]
	push	ecx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL9@ComputeRec
$LN7@ComputeRec:

; 4812 : 		}
; 4813 : 	}
; 4814 : 
; 4815 : 	iNumUnitsWanted += iNumCoastalCities;
; 4816 : 	// Scale up or down based on true threat level and a bit by flavors (multiplier should range from about 0.75 to 2.0)
; 4817 : 	dMultiplier = (double)0.75 + ((double)pPlayer->GetMilitaryAI()->GetHighestThreat() / (double)4.0) + ((double)(iFlavorNaval) / (double)40.0);

	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetHighestThreat@CvMilitaryAI@@QAE?AW4ThreatTypes@@XZ ; CvMilitaryAI::GetHighestThreat
	mov	DWORD PTR tv269[esp+32], eax
	fild	DWORD PTR tv269[esp+32]
	inc	edi
	fdiv	QWORD PTR __real@4010000000000000
	fadd	QWORD PTR __real@3fe8000000000000
	fild	DWORD PTR _iFlavorNaval$[esp+32]

; 4818 : 	iNumUnitsWanted = (int)((double)iNumUnitsWanted * dMultiplier* /*0.67*/ GC.getAI_STRATEGY_NAVAL_UNITS_PER_CITY());

	mov	DWORD PTR tv266[esp+32], edi
	fdiv	QWORD PTR __real@4044000000000000
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dMultiplier$[esp+32]
	fild	DWORD PTR tv266[esp+32]
	fmul	QWORD PTR _dMultiplier$[esp+32]
	fmul	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8108
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iNumUnitsWanted$[esp+32], eax

; 4819 : 
; 4820 : 	iNumUnitsWanted = max(1,iNumUnitsWanted);

	cmp	eax, 1
	mov	DWORD PTR $T235977[esp+32], 1
	lea	eax, DWORD PTR _iNumUnitsWanted$[esp+32]
	jg	SHORT $LN17@ComputeRec
	lea	eax, DWORD PTR $T235977[esp+32]
$LN17@ComputeRec:
	mov	edi, DWORD PTR [eax]

; 4821 : 
; 4822 : 	EconomicAIStrategyTypes eStrategyNavalMap = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_NAVAL_MAP");

	push	0
	push	OFFSET $SG228737
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4823 : 	EconomicAIStrategyTypes eExpandOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");

	push	0
	push	OFFSET $SG228740
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4824 : 	if (pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyNavalMap) || pPlayer->GetEconomicAI()->IsUsingStrategy(eExpandOtherContinents))

	push	ebx
	mov	ecx, esi
	mov	ebp, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	test	al, al
	jne	SHORT $LN4@ComputeRec
	push	ebp
	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	test	al, al
	je	SHORT $LN5@ComputeRec
$LN4@ComputeRec:

; 4825 : 	{
; 4826 : 		iNumUnitsWanted *= 3;

	lea	eax, DWORD PTR [edi+edi*2]

; 4827 : 		iNumUnitsWanted /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
$LN5@ComputeRec:

; 4828 : 	}
; 4829 : 
; 4830 : 	if (pPlayer->getCivilizationInfo().isCoastalCiv())

	mov	ecx, esi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ ; CvCivilizationInfo::isCoastalCiv
	test	al, al
	je	SHORT $LN3@ComputeRec

; 4831 : 	{
; 4832 : 		iNumUnitsWanted *= 3;

	lea	eax, DWORD PTR [edi+edi*2]

; 4833 : 		iNumUnitsWanted /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
$LN3@ComputeRec:

; 4834 : 	}
; 4835 : 
; 4836 : 	// if we are going for conquest we want at least one more task force
; 4837 : 	int iGT = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGT$[esp+32], eax

; 4838 : 	iGT = min(iGT,200);

	cmp	eax, 200				; 000000c8H
	mov	DWORD PTR $T235978[esp+32], 200		; 000000c8H
	lea	eax, DWORD PTR $T235978[esp+32]
	jg	SHORT $LN23@ComputeRec
	lea	eax, DWORD PTR _iGT$[esp+32]
$LN23@ComputeRec:
	mov	ebp, DWORD PTR [eax]

; 4839 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET $SG228748
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ebx, eax

; 4840 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	ebx, -1
	je	SHORT $LN27@ComputeRec

; 4841 : 	{
; 4842 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, ebx
	jne	SHORT $LN27@ComputeRec

; 4843 : 		{
; 4844 : 			iNumUnitsWanted += (10 * iGT) / 200;

	lea	ecx, DWORD PTR [ebp+ebp*4]
	add	ecx, ecx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	edi, eax
$LN27@ComputeRec:

; 4845 : 		}
; 4846 : 	}
; 4847 : 
; 4848 : 	return iNumUnitsWanted;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4849 : }

	add	esp, 16					; 00000010H
	ret	0
?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ENDP ; MilitaryAIHelpers::ComputeRecommendedNavySize
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::end
_TEXT	ENDS
PUBLIC	?clear@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ ; CvWeightedVector<CvMilitaryTarget,640,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::clear
_TEXT	ENDS
PUBLIC	?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_elem$ = -28						; size = 28
___$ReturnUdt$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight, COMDAT
; _this$ = ecx

; 197  : 	{

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp

; 198  : 		WeightedElement elem;

	xor	ebx, ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _elem$[esp+44], ebx
	mov	DWORD PTR _elem$[esp+48], ebx
	mov	DWORD PTR _elem$[esp+52], ebx
	mov	DWORD PTR _elem$[esp+56], ebx
	mov	DWORD PTR _elem$[esp+60], ebx
	mov	BYTE PTR _elem$[esp+64], bl

; 199  : 		int iChoice;
; 200  : 
; 201  : 		// Random roll up to total weight
; 202  : 		iChoice = (*rndFcn)(GetTotalWeight(), szRollName);

	call	?GetTotalWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEHXZ ; CvWeightedVector<CvMilitaryTarget,640,1>::GetTotalWeight
	mov	ecx, DWORD PTR _rndFcn$[esp+40]
	mov	edi, DWORD PTR _szRollName$[esp+40]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	push	edi
	push	eax
	call	edx
	mov	edx, DWORD PTR [esi+4]

; 203  : 
; 204  : 		// Loop through until we find the item that is in the range for this roll
; 205  : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	cmp	edx, ebx
	jbe	SHORT $LN2@ChooseByWe

; 198  : 		WeightedElement elem;

	mov	ebp, DWORD PTR [esi]
$LL4@ChooseByWe:

; 206  : 		{
; 207  : 			elem = m_pItems[i];

	mov	ecx, 7
	mov	esi, ebp
	lea	edi, DWORD PTR _elem$[esp+44]
	rep movsd

; 208  : 			iChoice -= elem.m_iWeight;

	sub	eax, DWORD PTR _elem$[esp+68]

; 209  : 			if (iChoice < 0)

	js	SHORT $LN2@ChooseByWe
	inc	ebx
	add	ebp, 28					; 0000001cH
	cmp	ebx, edx
	jb	SHORT $LL4@ChooseByWe
$LN2@ChooseByWe:

; 210  : 			{
; 211  : 				return elem.m_Element;
; 212  : 			}
; 213  : 		}
; 214  : 
; 215  : 		// We should have found something, so reaching here is an error
; 216  : 		//    Just return last thing accessed
; 217  : 		FAssertMsg (true, "Internal error in CvWeightedVector.");
; 218  : 		return elem.m_Element;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+40]
	mov	ecx, DWORD PTR _elem$[esp+44]
	mov	edx, DWORD PTR _elem$[esp+48]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _elem$[esp+52]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _elem$[esp+56]
	pop	edi
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _elem$[esp+56]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR _elem$[esp+60]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
	pop	ebx

; 219  : 	};

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight
_TEXT	ENDS
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
_elem$ = -28						; size = 28
___$ReturnUdt$ = 8					; size = 4
_iNumChoices$ = 12					; size = 4
_rndFcn$ = 16						; size = 4
_szRollName$ = 20					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	sub	esp, 32					; 00000020H
	push	ebx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	ebx, DWORD PTR _iNumChoices$[esp+32]
	push	ebp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	cmp	ebx, eax
	push	edi
	mov	DWORD PTR _this$[esp+48], esi
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	ebx, eax
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	xor	edi, edi

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	xor	eax, eax

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	cmp	ebx, edi
	mov	DWORD PTR _elem$[esp+48], edi
	mov	DWORD PTR _elem$[esp+52], edi
	mov	DWORD PTR _elem$[esp+56], edi
	mov	DWORD PTR _elem$[esp+60], edi
	mov	DWORD PTR _elem$[esp+64], edi
	mov	BYTE PTR _elem$[esp+68], 0
	jle	SHORT $LN5@ChooseFrom
	mov	edx, DWORD PTR [esi]
	mov	ebp, ebx
	npad	1
$LL7@ChooseFrom:

; 237  : 		{
; 238  : 			elem = m_pItems[i];

	mov	esi, edx
	mov	ecx, 7
	lea	edi, DWORD PTR _elem$[esp+48]
	rep movsd

; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	add	eax, DWORD PTR _elem$[esp+72]
	add	edx, 28					; 0000001cH
	sub	ebp, 1
	jne	SHORT $LL7@ChooseFrom
	mov	esi, DWORD PTR _this$[esp+48]
	xor	edi, edi
$LN5@ChooseFrom:

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	ecx, DWORD PTR _szRollName$[esp+44]
	push	ecx
	push	eax
	mov	eax, DWORD PTR _rndFcn$[esp+52]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	xor	edx, edx
	cmp	ebx, edi
	jle	SHORT $LN2@ChooseFrom

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	ebp, DWORD PTR [esi]
	npad	8
$LL4@ChooseFrom:

; 247  : 		{
; 248  : 			elem = m_pItems[i];

	mov	ecx, 7
	mov	esi, ebp
	lea	edi, DWORD PTR _elem$[esp+48]
	rep movsd

; 249  : 			iChoice -= elem.m_iWeight;

	sub	eax, DWORD PTR _elem$[esp+72]

; 250  : 			if (iChoice < 0)

	js	SHORT $LN2@ChooseFrom
	inc	edx
	add	ebp, 28					; 0000001cH
	cmp	edx, ebx
	jl	SHORT $LL4@ChooseFrom
$LN2@ChooseFrom:

; 251  : 			{
; 252  : 				return elem.m_Element;
; 253  : 			}
; 254  : 		}
; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+44]
	mov	ecx, DWORD PTR _elem$[esp+48]
	mov	edx, DWORD PTR _elem$[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _elem$[esp+56]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _elem$[esp+60]
	pop	edi
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _elem$[esp+60]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR _elem$[esp+64]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], edx
	pop	ebx

; 260  : 	};

	add	esp, 32					; 00000020H
	ret	16					; 00000010H
?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>, COMDAT
; _this$ = ecx

; 1041 : 	FastDelegate2() { clear(); }

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
_TEXT	ENDS
PUBLIC	??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::operator=, COMDAT
; _this$ = ecx

; 1045 : 		m_Closure.CopyFrom(this, x.m_Closure); }

	mov	eax, DWORD PTR _x$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	ret	4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
_TEXT	ENDS
PUBLIC	??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvMilitaryAIStrategyXMLEntry@@@std@@YAPAPAVCvMilitaryAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvMilitaryAIStrategyXMLEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::~FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize
	npad	1
$LL10@GrowSize:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize
$LN37@GrowSize:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN2@GrowSize
	mov	ecx, ebx
$LL4@GrowSize:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN3@GrowSize
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN3@GrowSize:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL4@GrowSize
$LN2@GrowSize:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	5
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN33@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 10					; 0000000aH
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	mov	eax, edi
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 10			; 0000000aH
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN1@GrowSize@2
	xor	edx, edx
	mov	ecx, ebp
	push	ebx
$LL38@GrowSize@2:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN2@GrowSize@2
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+edx]
	add	eax, edx
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], ebx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
$LN2@GrowSize@2:
	inc	edi
	add	edx, 16					; 00000010H
	add	ecx, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL38@GrowSize@2
	pop	ebx
$LN1@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN37@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN37@GrowSize@2:
	pop	edi

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+172], 1
	pop	esi
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvMilitaryAIStrategyXMLEntry@@0@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
	npad	6
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN34@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 640				; 00000280H
	jbe	SHORT $LN16@GrowSize@3
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp*8]
	sub	eax, ebp
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@3
$LN16@GrowSize@3:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 640			; 00000280H
$LN15@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+17932], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>, COMDAT
; _this$ = ecx

; 1057 : 		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	ret	8
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
tv360 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebx

; 3010 : 	if (40 < _Last - _First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	ecx, ebx
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	lea	ebx, DWORD PTR [eax*8]
	sub	ebx, eax
	add	esi, esi
	add	ebx, ebx
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi+24]
	push	ebp
	lea	ebp, DWORD PTR [esi+edi]
	add	ebx, ebx
	add	ebx, ebx
	cmp	eax, DWORD PTR [edi+24]
	mov	DWORD PTR tv360[esp+12], ebp
	jle	SHORT $LN12@Median
	push	edi
	push	ebp
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN12@Median:
	mov	ecx, DWORD PTR [ebx+edi+24]
	cmp	ecx, DWORD PTR [ebp+24]
	lea	eax, DWORD PTR [ebx+edi]
	jle	SHORT $LN16@Median
	push	ebp
	push	eax
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN16@Median:
	mov	edx, DWORD PTR [ebp+24]
	cmp	edx, DWORD PTR [edi+24]
	jle	SHORT $LN20@Median
	push	edi
	push	ebp
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN20@Median:

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+12]
	mov	eax, DWORD PTR [ebp+24]
	mov	edi, ebp
	sub	edi, esi
	cmp	eax, DWORD PTR [edi+24]
	jle	SHORT $LN29@Median
	push	edi
	push	ebp
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN29@Median:
	mov	ecx, DWORD PTR [esi+ebp+24]
	cmp	ecx, DWORD PTR [ebp+24]
	lea	eax, DWORD PTR [esi+ebp]
	jle	SHORT $LN33@Median
	push	ebp
	push	eax
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN33@Median:
	mov	edx, DWORD PTR [ebp+24]
	cmp	edx, DWORD PTR [edi+24]
	jle	SHORT $LN37@Median
	push	edi
	push	ebp
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN37@Median:

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, DWORD PTR __Last$[esp+12]
	mov	edi, eax
	sub	edi, esi
	mov	ecx, DWORD PTR [edi+24]
	mov	esi, eax
	sub	esi, ebx
	cmp	ecx, DWORD PTR [esi+24]
	jle	SHORT $LN46@Median
	push	esi
	push	edi
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	mov	eax, DWORD PTR __Last$[esp+20]
	add	esp, 8
$LN46@Median:
	mov	edx, DWORD PTR [eax+24]
	cmp	edx, DWORD PTR [edi+24]
	jle	SHORT $LN50@Median
	push	edi
	push	eax
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN50@Median:
	mov	eax, DWORD PTR [edi+24]
	cmp	eax, DWORD PTR [esi+24]
	jle	SHORT $LN54@Median
	push	esi
	push	edi
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN54@Median:

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR [ebp+24]
	mov	esi, DWORD PTR tv360[esp+12]
	cmp	ecx, DWORD PTR [esi+24]
	jle	SHORT $LN63@Median
	push	esi
	push	ebp
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN63@Median:
	mov	edx, DWORD PTR [edi+24]
	cmp	edx, DWORD PTR [ebp+24]
	jle	SHORT $LN67@Median
	push	ebp
	push	edi
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN67@Median:
	mov	eax, DWORD PTR [ebp+24]
	cmp	eax, DWORD PTR [esi+24]
	jle	SHORT $LN90@Median
	push	esi
	push	ebp
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN90@Median:
	pop	ebp

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

$LN88@Median:
	pop	edi
	pop	esi
	pop	ebx

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	esi, DWORD PTR __Mid$[esp+8]
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, DWORD PTR [edi+24]
	jle	SHORT $LN80@Median
	push	edi
	push	esi
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN80@Median:
	mov	edx, DWORD PTR [ebx+24]
	cmp	edx, DWORD PTR [esi+24]
	jle	SHORT $LN84@Median
	push	esi
	push	ebx
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
$LN84@Median:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, DWORD PTR [edi+24]
	jle	SHORT $LN88@Median
	push	edi
	push	esi
	call	??$swap@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::swap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __First$[esp+4]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	push	esi
	sub	eax, edx
	push	edi
	mov	edi, eax
	sar	edi, 1
	test	edi, edi
	jle	SHORT $LN1@Make_heap
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	lea	esi, DWORD PTR [ebp+eax*4]
	npad	5
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [esi-28]
	sub	esi, 28					; 0000001cH
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [esi+20]
	push	ebx
	dec	edi
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [esi+24]
	push	edi
	push	ebp
	mov	DWORD PTR [eax+24], ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 40					; 00000028H
	test	edi, edi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
__Val$229931 = -28					; size = 28
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 28					; 0000001cH
	push	ebp
	mov	ebp, DWORD PTR __First$[esp+28]
	cmp	ebp, eax
	je	$LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [ebp+28]
	cmp	edx, eax
	je	$LN6@Insertion_
	push	ebx
	push	esi
	push	edi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edx+24]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	ebx, DWORD PTR [ebp+24]
	mov	DWORD PTR __Val$229931[esp+44], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$229931[esp+48], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Val$229931[esp+52], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Val$229931[esp+56], ecx
	mov	ecx, DWORD PTR [edx+20]
	mov	edi, edx
	mov	DWORD PTR __Val$229931[esp+60], eax
	mov	DWORD PTR __Val$229931[esp+64], ecx
	mov	DWORD PTR __Val$229931[esp+68], ebx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	ebp, edx
	je	SHORT $LN21@Insertion_
	npad	1
$LL22@Insertion_:
	sub	eax, 28					; 0000001cH
	lea	edi, DWORD PTR [eax+28]
	mov	ecx, 7
	mov	esi, eax
	rep movsd
	cmp	eax, ebp
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	edi, ebp

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN1@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	ebx, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-28]
	jle	SHORT $LN1@Insertion_
	npad	1
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	esi, eax
	mov	ecx, 7
	rep movsd
	mov	edi, eax
	sub	eax, 28					; 0000001cH
	cmp	ebx, DWORD PTR [eax+24]
	jg	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	edx, 28					; 0000001cH

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, 7
	lea	esi, DWORD PTR __Val$229931[esp+44]
	rep movsd
	cmp	edx, DWORD PTR __Last$[esp+40]
	jne	$LL7@Insertion_
	pop	edi
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [eax-28]
	add	eax, -28				; ffffffe4H
	push	0
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [eax+20]
	push	eax
	mov	DWORD PTR [ecx+20], edx
	mov	edx, DWORD PTR [eax+24]
	push	eax
	mov	eax, DWORD PTR __First$[esp+36]
	push	eax
	mov	DWORD PTR [ecx+24], edx
	call	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 44					; 0000002cH

; 2090 : 	}

	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ; CvMilitaryAI::ScoreTarget
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?IsCityAlreadyTargeted@CvPlayer@@QBE_NPAVCvCity@@W4DomainTypes@@HH@Z:PROC ; CvPlayer::IsCityAlreadyTargeted
EXTRN	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ:PROC ; CvCity::getOriginalOwner
EXTRN	?IsOriginalCapital@CvCity@@QBE_NXZ:PROC		; CvCity::IsOriginalCapital
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ:PROC	; CvCity::IsRouteToCapitalConnected
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?CanAirlift@CvCity@@QBE_NXZ:PROC		; CvCity::CanAirlift
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
;	COMDAT ?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z
_TEXT	SEGMENT
_iEnemyStrength$ = -4					; size = 4
$T236757 = 8						; size = 4
_iRatio$ = 8						; size = 4
$T236755 = 8						; size = 4
_iFriendlyStrength$ = 8					; size = 4
_target$ = 8						; size = 4
$T236758 = 12						; size = 4
$T236756 = 12						; size = 4
$T236754 = 12						; size = 4
_eAIOperationType$ = 12					; size = 4
?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z PROC ; CvMilitaryAI::ScoreTarget, COMDAT
; _this$ = ecx

; 1244 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 1245 : 	unsigned long int uliRtnValue = 1;  // Start with a high base number since divide into it later
; 1246 : 
; 1247 : 	// Take into account distance to target (and use higher multipliers for land paths)
; 1248 : 	if(!target.m_bAttackBySea)

	mov	esi, DWORD PTR _target$[esp+12]
	cmp	BYTE PTR [esi+20], 0

; 1249 : 	{
; 1250 : 		if(target.m_iPathLength < 10)

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	ebp, ecx
	mov	ebx, 1
	jne	SHORT $LN29@ScoreTarge
	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN28@ScoreTarge

; 1251 : 		{
; 1252 : 			uliRtnValue *= 16;

	mov	ebx, 16					; 00000010H
	jmp	SHORT $LN24@ScoreTarge
$LN28@ScoreTarge:

; 1253 : 		}
; 1254 : 		else if(target.m_iPathLength < 15)

	cmp	eax, 15					; 0000000fH
	jge	SHORT $LN26@ScoreTarge

; 1255 : 		{
; 1256 : 			uliRtnValue *= 8;

	mov	ebx, 8
	jmp	SHORT $LN24@ScoreTarge
$LN26@ScoreTarge:

; 1257 : 		}
; 1258 : 		else if(target.m_iPathLength < 20)

	xor	ebx, ebx
	cmp	eax, 20					; 00000014H
	setl	bl
	lea	ebx, DWORD PTR [ebx+ebx+2]
$LN24@ScoreTarge:

; 1259 : 		{
; 1260 : 			uliRtnValue *= 4;
; 1261 : 		}
; 1262 : 		else
; 1263 : 		{
; 1264 : 			uliRtnValue *= 2;
; 1265 : 		}
; 1266 : 
; 1267 : 		// Double if we can assemble troops in muster city with airlifts
; 1268 : 		if (target.m_pMusterCity->CanAirlift())

	mov	ecx, DWORD PTR [esi+4]
	call	?CanAirlift@CvCity@@QBE_NXZ		; CvCity::CanAirlift
	test	al, al
	je	SHORT $LN15@ScoreTarge

; 1269 : 		{
; 1270 : 			uliRtnValue *= 2;

	add	ebx, ebx

; 1271 : 		}
; 1272 : 	}
; 1273 : 	else

	jmp	SHORT $LN15@ScoreTarge
$LN29@ScoreTarge:

; 1274 : 	{
; 1275 : 		if(target.m_iPathLength < 12)

	cmp	eax, 12					; 0000000cH
	jge	SHORT $LN20@ScoreTarge

; 1276 : 		{
; 1277 : 			uliRtnValue *= 5;

	mov	ebx, 5
	jmp	SHORT $LN16@ScoreTarge
$LN20@ScoreTarge:

; 1278 : 		}
; 1279 : 		else if(target.m_iPathLength < 20)

	cmp	eax, 20					; 00000014H
	jge	SHORT $LN18@ScoreTarge

; 1280 : 		{
; 1281 : 			uliRtnValue *= 3;

	mov	ebx, 3
	jmp	SHORT $LN16@ScoreTarge
$LN18@ScoreTarge:

; 1282 : 		}
; 1283 : 		else if(target.m_iPathLength < 30)

	cmp	eax, 30					; 0000001eH
	jge	SHORT $LN16@ScoreTarge

; 1284 : 		{
; 1285 : 			uliRtnValue *= 2;

	mov	ebx, 2
$LN16@ScoreTarge:

; 1286 : 		}
; 1287 : 
; 1288 : 		// If coming over sea, inland cities are trickier
; 1289 : 		if(!target.m_pTargetCity->plot()->isCoastalLand())

	mov	ecx, DWORD PTR [esi]
	push	-1
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	jne	SHORT $LN15@ScoreTarge

; 1290 : 		{
; 1291 : 			uliRtnValue /= 2;

	shr	ebx, 1
$LN15@ScoreTarge:

; 1292 : 		}
; 1293 : 	}
; 1294 : 
; 1295 : 	// Is this a sneak attack?  If so distance is REALLY important (want to target spaces on edge of empire)
; 1296 : 	// So let's cube what we have so far
; 1297 : 	if (eAIOperationType == AI_OPERATION_SNEAK_CITY_ATTACK || eAIOperationType == AI_OPERATION_NAVAL_SNEAK_ATTACK)

	mov	eax, DWORD PTR _eAIOperationType$[esp+16]
	cmp	eax, 6
	je	SHORT $LN13@ScoreTarge
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN14@ScoreTarge
$LN13@ScoreTarge:

; 1298 : 	{
; 1299 : 		uliRtnValue = uliRtnValue * uliRtnValue * uliRtnValue;

	mov	eax, ebx
	imul	eax, ebx
	imul	ebx, eax
$LN14@ScoreTarge:

; 1300 : 	}
; 1301 : 
; 1302 : 	CityAttackApproaches eApproaches;
; 1303 : 	int iApproachMultiplier = 0;
; 1304 : 	eApproaches = EvaluateMilitaryApproaches(target.m_pTargetCity, true /* Assume units coming by sea can disembark */, target.m_bAttackBySea);

	movzx	ecx, BYTE PTR [esi+20]
	mov	edx, DWORD PTR [esi]
	push	ecx
	push	1
	push	edx
	mov	ecx, ebp
	xor	edi, edi
	call	?EvaluateMilitaryApproaches@CvMilitaryAI@@QAE?AW4CityAttackApproaches@@PAVCvCity@@_N1@Z ; CvMilitaryAI::EvaluateMilitaryApproaches

; 1305 : 	switch(eApproaches)

	cmp	eax, 5
	ja	SHORT $LN11@ScoreTarge
	jmp	DWORD PTR $LN57@ScoreTarge[eax*4]
$LN10@ScoreTarge:

; 1306 : 	{
; 1307 : 	case ATTACK_APPROACH_UNRESTRICTED:
; 1308 : 		iApproachMultiplier = 10;

	mov	edi, 10					; 0000000aH

; 1309 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN9@ScoreTarge:

; 1310 : 
; 1311 : 	case ATTACK_APPROACH_OPEN:
; 1312 : 		iApproachMultiplier = 8;

	mov	edi, 8

; 1313 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN8@ScoreTarge:

; 1314 : 
; 1315 : 	case ATTACK_APPROACH_NEUTRAL:
; 1316 : 		iApproachMultiplier = 4;

	mov	edi, 4

; 1317 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN7@ScoreTarge:

; 1318 : 
; 1319 : 	case ATTACK_APPROACH_LIMITED:
; 1320 : 		iApproachMultiplier = 2;

	mov	edi, 2

; 1321 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN6@ScoreTarge:

; 1322 : 
; 1323 : 	case ATTACK_APPROACH_RESTRICTED:
; 1324 : 		iApproachMultiplier = 1;

	mov	edi, 1

; 1325 : 		break;

	jmp	SHORT $LN11@ScoreTarge
$LN5@ScoreTarge:

; 1326 : 
; 1327 : 	case ATTACK_APPROACH_NONE:
; 1328 : 		iApproachMultiplier = 0;

	xor	edi, edi
$LN11@ScoreTarge:

; 1329 : 		break;
; 1330 : 	}
; 1331 : 
; 1332 : 	uliRtnValue *= iApproachMultiplier;
; 1333 : 
; 1334 : 	// should probably give a bonus if these cities are adjacent
; 1335 : 
; 1336 : 	// Don't want to start at a city that isn't connected to our capital
; 1337 : 	if (!target.m_pMusterCity->IsRouteToCapitalConnected() && !target.m_pMusterCity->isCapital())

	mov	ecx, DWORD PTR [esi+4]
	imul	edi, ebx
	call	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ ; CvCity::IsRouteToCapitalConnected
	test	al, al
	jne	SHORT $LN4@ScoreTarge
	mov	ecx, DWORD PTR [esi+4]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN4@ScoreTarge

; 1338 : 	{
; 1339 : 		uliRtnValue /= 4;

	shr	edi, 2
$LN4@ScoreTarge:

; 1340 : 	}
; 1341 : 
; 1342 : 	// this won't work if we are "just checking" as the zone are only built for actual war war opponents
; 1343 : 	// TODO come up with a better way to do this that is always correct
; 1344 : 
; 1345 : 	int iFriendlyStrength = target.iMusterNearbyUnitPower;

	mov	ebx, DWORD PTR [esi+12]

; 1346 : 	int iEnemyStrength = target.iTargetNearbyUnitPower + (target.m_pTargetCity->getStrengthValue() / 50);

	mov	ecx, DWORD PTR [esi]
	push	0
	mov	DWORD PTR _iFriendlyStrength$[esp+20], ebx
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ecx, DWORD PTR [esi+8]

; 1347 : 	iFriendlyStrength = max(1, iFriendlyStrength);

	mov	edx, 1
	cmp	ebx, edx
	mov	DWORD PTR _iEnemyStrength$[esp+20], ecx
	mov	DWORD PTR $T236754[esp+16], edx
	lea	eax, DWORD PTR _iFriendlyStrength$[esp+16]
	jg	SHORT $LN35@ScoreTarge
	lea	eax, DWORD PTR $T236754[esp+16]
$LN35@ScoreTarge:
	mov	eax, DWORD PTR [eax]

; 1348 : 	iEnemyStrength = max(1, iEnemyStrength);

	cmp	ecx, edx
	mov	DWORD PTR $T236755[esp+16], edx
	lea	ecx, DWORD PTR _iEnemyStrength$[esp+20]
	jg	SHORT $LN39@ScoreTarge
	lea	ecx, DWORD PTR $T236755[esp+16]
$LN39@ScoreTarge:
	mov	ecx, DWORD PTR [ecx]

; 1349 : 	int iRatio = 1;
; 1350 : 	iRatio = (iFriendlyStrength * 100) / iEnemyStrength;

	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx

; 1351 : 	iRatio = min(1000, iRatio);

	mov	DWORD PTR $T236756[esp+16], 1000	; 000003e8H
	mov	DWORD PTR _iRatio$[esp+16], eax
	cmp	eax, 1000				; 000003e8H
	lea	eax, DWORD PTR _iRatio$[esp+16]
	jl	SHORT $LN43@ScoreTarge
	lea	eax, DWORD PTR $T236756[esp+16]
$LN43@ScoreTarge:
	mov	ebx, DWORD PTR [eax]

; 1352 : 	uliRtnValue *= iRatio;
; 1353 : 
; 1354 : 	if (target.m_pTargetCity->IsOriginalCapital())

	mov	ecx, DWORD PTR [esi]
	imul	ebx, edi
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	test	al, al
	je	SHORT $LN3@ScoreTarge

; 1355 : 	{
; 1356 : 		uliRtnValue *= GC.getAI_MILITARY_CAPTURING_ORIGINAL_CAPITAL();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2204
	imul	ecx, ebx

; 1357 : 		uliRtnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	mul	ecx
	shr	edx, 5
	mov	ebx, edx
$LN3@ScoreTarge:

; 1358 : 	}
; 1359 : 
; 1360 : 	if (target.m_pTargetCity->getOriginalOwner() == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+44]
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner
	cmp	eax, edi
	jne	SHORT $LN2@ScoreTarge

; 1361 : 	{
; 1362 : 		uliRtnValue *= GC.getAI_MILITARY_RECAPTURING_OWN_CITY();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2200
	imul	ecx, ebx

; 1363 : 		uliRtnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	mul	ecx
	shr	edx, 5
	mov	ebx, edx
$LN2@ScoreTarge:

; 1364 : 	}
; 1365 : 
; 1366 : 	// Don't want it to already be targeted by an operation that's not well on its way
; 1367 : 	if(m_pPlayer->IsCityAlreadyTargeted(target.m_pTargetCity, NO_DOMAIN, 50))

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebp]
	push	-1
	push	50					; 00000032H
	push	-1
	push	edx
	call	?IsCityAlreadyTargeted@CvPlayer@@QBE_NPAVCvCity@@W4DomainTypes@@HH@Z ; CvPlayer::IsCityAlreadyTargeted
	test	al, al
	je	SHORT $LN1@ScoreTarge

; 1368 : 	{
; 1369 : 		uliRtnValue /= 10;

	mov	eax, -858993459				; cccccccdH
	mul	ebx
	shr	edx, 3
	mov	ebx, edx
$LN1@ScoreTarge:

; 1370 : 	}
; 1371 : 
; 1372 : 	uliRtnValue /= 1000;
; 1373 : 
; 1374 : 	// Economic value of target
; 1375 : 	unsigned long int iEconomicValue = 1 + (target.m_pTargetCity->getPopulation() / 3);

	mov	ecx, DWORD PTR [esi]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ecx, eax
	mov	eax, 1431655766				; 55555556H
	imul	ecx

; 1376 : 	// TODO: unhardcode this
; 1377 : 	// filter out all but the most productive
; 1378 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_FOOD, false) / 10;

	mov	ecx, DWORD PTR [esi]
	mov	eax, edx
	push	0
	shr	eax, 31					; 0000001fH
	push	0
	lea	edi, DWORD PTR [edx+eax+1]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1379 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_PRODUCTION, false) / 10;

	push	0
	add	edi, ecx
	mov	ecx, DWORD PTR [esi]
	push	1
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx

; 1380 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_SCIENCE, false) / 10;

	mov	ecx, DWORD PTR [esi]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	0
	add	eax, edx
	push	3
	add	edi, eax
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1381 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_GOLD, false) / 10;

	push	0
	add	edi, ecx
	mov	ecx, DWORD PTR [esi]
	push	2
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx

; 1382 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_CULTURE, false) / 10;

	mov	ecx, DWORD PTR [esi]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	0
	add	eax, edx
	push	4
	add	edi, eax
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1383 : 	iEconomicValue += target.m_pTargetCity->getYieldRateTimes100(YIELD_FAITH, false) / 10;

	push	0
	add	edi, ecx
	mov	ecx, DWORD PTR [esi]
	push	5
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ecx, edi
	mov	eax, 274877907				; 10624dd3H
	mul	ebx
	shr	edx, 6

; 1384 : 	uliRtnValue *= iEconomicValue;

	imul	ecx, edx

; 1385 : 
; 1386 : 	uliRtnValue /= 10;

	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	pop	edi
	mov	eax, edx

; 1387 : 
; 1388 : 	return min(10000000, (int)uliRtnValue & 0x7fffffff);

	and	eax, 2147483647				; 7fffffffH
	pop	esi
	pop	ebp
	mov	DWORD PTR $T236757[esp+4], eax
	cmp	eax, 10000000				; 00989680H
	mov	DWORD PTR $T236758[esp+4], 10000000	; 00989680H
	pop	ebx
	lea	eax, DWORD PTR $T236757[esp]
	jl	SHORT $LN56@ScoreTarge
	lea	eax, DWORD PTR $T236758[esp]
$LN56@ScoreTarge:
	mov	eax, DWORD PTR [eax]

; 1389 : }

	pop	ecx
	ret	8
	npad	3
$LN57@ScoreTarge:
	DD	$LN5@ScoreTarge
	DD	$LN6@ScoreTarge
	DD	$LN7@ScoreTarge
	DD	$LN8@ScoreTarge
	DD	$LN9@ScoreTarge
	DD	$LN10@ScoreTarge
?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ENDP ; CvMilitaryAI::ScoreTarget
_TEXT	ENDS
PUBLIC	?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ	; CvMilitaryAI::GetBarbarianThreatTotal
; Function compile flags: /Ogtpy
;	COMDAT ?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ
_TEXT	SEGMENT
?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ PROC	; CvMilitaryAI::GetBarbarianThreatTotal, COMDAT
; _this$ = ecx

; 1568 : {

	push	esi
	mov	esi, ecx

; 1569 : 	int iRtnValue = 0;
; 1570 : 
; 1571 : 	ScanForBarbarians();

	call	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::ScanForBarbarians

; 1572 : 
; 1573 : 	// Major threat for each camp seen
; 1574 : 	iRtnValue += GC.getAI_MILITARY_THREAT_WEIGHT_MAJOR() * m_iBarbarianCampCount;
; 1575 : 
; 1576 : 	// One minor threat for every X barbarians
; 1577 : #ifdef AUI_MILITARY_FIX_BARBARIAN_THREAT
; 1578 : 	iRtnValue += m_iVisibleBarbarianCount * GC.getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT();
; 1579 : #else
; 1580 : 	iRtnValue += m_iVisibleBarbarianCount / GC.getAI_MILITARY_BARBARIANS_FOR_MINOR_THREAT();

	mov	eax, DWORD PTR [esi+92]
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2192
	mov	ecx, DWORD PTR [esi+88]
	imul	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	pop	esi
	add	eax, ecx

; 1581 : #endif
; 1582 : 
; 1583 : 	return iRtnValue;
; 1584 : }

	ret	0
?GetBarbarianThreatTotal@CvMilitaryAI@@QAEHXZ ENDP	; CvMilitaryAI::GetBarbarianThreatTotal
_TEXT	ENDS
PUBLIC	?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z ; CvMilitaryAI::LogDeclarationOfWar
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_playerName$227277 = -208				; size = 28
_strBaseString$227275 = -180				; size = 28
_opponentName$227276 = -152				; size = 28
_strTemp$227278 = -124					; size = 28
_strOutBuf$227274 = -96					; size = 28
$T236830 = -68						; size = 28
$T236829 = -68						; size = 28
$T236828 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eOpponent$ = 8						; size = 4
?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z PROC ; CvMilitaryAI::LogDeclarationOfWar, COMDAT
; _this$ = ecx

; 1841 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	edi
	mov	edi, ecx

; 1842 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogDeclara
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogDeclara
	push	ebx
	push	esi

; 1843 : 	{
; 1844 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227274[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1845 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227275[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1846 : 		CvString opponentName;

	lea	ecx, DWORD PTR _opponentName$227276[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1847 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227277[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1848 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227278[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1849 : 		FILogFile* pLog;
; 1850 : 
; 1851 : 		// Open the right file
; 1852 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$227277[esp+220]
	test	eax, eax
	je	SHORT $LN30@LogDeclara
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogDeclara
$LN30@LogDeclara:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogDeclara:

; 1853 : 		opponentName = GET_PLAYER(eOpponent).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eOpponent$[esp+216]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _opponentName$227276[esp+220]
	test	eax, eax
	je	SHORT $LN36@LogDeclara
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@LogDeclara
$LN36@LogDeclara:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@LogDeclara:

; 1854 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	0
	lea	eax, DWORD PTR _playerName$227277[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T236828[esp+228]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T236828[esp+220]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1855 : 
; 1856 : 		// Get the leading info for this line
; 1857 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227275[esp+224]
	push	OFFSET $SG227281
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1858 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG227283
	lea	edx, DWORD PTR _playerName$227277[esp+236]
	push	edx
	lea	eax, DWORD PTR $T236829[esp+240]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227275[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236829[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1859 : 
; 1860 : 		// Strategy Info
; 1861 : 		strTemp.Format("Declared War on: %s", opponentName.GetCString());

	lea	ecx, DWORD PTR _opponentName$227276[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$227278[esp+224]
	push	OFFSET $SG227284
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1862 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$227278[esp+232]
	push	edx
	lea	eax, DWORD PTR _strBaseString$227275[esp+236]
	push	eax
	lea	ecx, DWORD PTR $T236830[esp+240]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227274[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T236830[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1863 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227274[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 1864 : 
; 1865 : 		LogMilitarySummaryMessage(strTemp);

	lea	ecx, DWORD PTR _strTemp$227278[esp+220]
	push	ecx
	mov	ecx, edi
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1866 : 	}

	lea	ecx, DWORD PTR _strTemp$227278[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$227277[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _opponentName$227276[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227275[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227274[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogDeclara:

; 1867 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227274[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227275[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _opponentName$227276[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$227277[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strTemp$227278[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR $T236828[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T236829[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T236830[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDeclarationOfWar@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::LogDeclarationOfWar
PUBLIC	?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ	; CvMilitaryAI::LogCivilizationDestroyed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
_playerName$227292 = -180				; size = 28
_strBaseString$227291 = -152				; size = 28
_strTemp$227293 = -124					; size = 28
_strOutBuf$227290 = -96					; size = 28
$T236934 = -68						; size = 28
$T236933 = -68						; size = 28
$T236932 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ PROC	; CvMilitaryAI::LogCivilizationDestroyed, COMDAT
; _this$ = ecx

; 1871 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	edi
	mov	edi, ecx

; 1872 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogCiviliz
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogCiviliz
	push	ebx
	push	esi

; 1873 : 	{
; 1874 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227290[esp+192]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1875 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227291[esp+192]
	mov	DWORD PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1876 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$227292[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1877 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227293[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1878 : 		FILogFile* pLog;
; 1879 : 
; 1880 : 		// Open the right file
; 1881 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 3
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$227292[esp+192]
	test	eax, eax
	je	SHORT $LN26@LogCiviliz
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@LogCiviliz
$LN26@LogCiviliz:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@LogCiviliz:

; 1882 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	0
	lea	eax, DWORD PTR _playerName$227292[esp+196]
	push	eax
	lea	ecx, DWORD PTR $T236932[esp+200]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+200], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T236932[esp+192]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1883 : 
; 1884 : 		// Get the leading info for this line
; 1885 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227291[esp+196]
	push	OFFSET $SG227296
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1886 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG227298
	lea	edx, DWORD PTR _playerName$227292[esp+208]
	push	edx
	lea	eax, DWORD PTR $T236933[esp+212]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227291[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236933[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1887 : 
; 1888 : 		// Strategy Info
; 1889 : 		strTemp.Format("DESTROYED!");

	lea	ecx, DWORD PTR _strTemp$227293[esp+192]
	push	OFFSET $SG227299
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1890 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$227293[esp+200]
	push	edx
	lea	eax, DWORD PTR _strBaseString$227291[esp+204]
	push	eax
	lea	ecx, DWORD PTR $T236934[esp+208]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 20					; 00000014H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+200], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227290[esp+196]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T236934[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1891 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227290[esp+192]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 1892 : 
; 1893 : 		LogMilitarySummaryMessage(strTemp);

	lea	ecx, DWORD PTR _strTemp$227293[esp+192]
	push	ecx
	mov	ecx, edi
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1894 : 	}

	mov	BYTE PTR __$EHRec$[esp+200], 2
	lea	ecx, DWORD PTR _strTemp$227293[esp+192]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$227292[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227291[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227290[esp+192]
	mov	DWORD PTR __$EHRec$[esp+200], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogCiviliz:

; 1895 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+184]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 180				; 000000b4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$227290[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$227291[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _playerName$227292[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp$227293[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T236932[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T236933[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T236934[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCivilizationDestroyed@CvMilitaryAI@@QAEXXZ ENDP	; CvMilitaryAI::LogCivilizationDestroyed
PUBLIC	?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::LogCityCaptured
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_strPlayerName$227309 = -264				; size = 28
_strTemp$227312 = -236					; size = 28
$T237020 = -208						; size = 28
$T237019 = -208						; size = 28
$T237017 = -208						; size = 28
_strOldOwnerName$227310 = -180				; size = 28
_strBaseString$227308 = -152				; size = 28
_strCityName$227311 = -124				; size = 28
$T237018 = -96						; size = 28
$T237016 = -96						; size = 28
$T237015 = -68						; size = 28
$T237014 = -68						; size = 28
_strOutBuf$227307 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
_eOldOwner$ = 12					; size = 4
?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::LogCityCaptured, COMDAT
; _this$ = ecx

; 1899 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 252				; 000000fcH
	push	edi
	mov	edi, ecx

; 1900 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogCityCap
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogCityCap
	push	ebx
	push	ebp
	push	esi

; 1901 : 	{
; 1902 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227307[esp+280]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1903 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227308[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1904 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227309[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1905 : 		CvString strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$227310[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1906 : 		CvString strCityName;

	lea	ecx, DWORD PTR _strCityName$227311[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1907 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227312[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1908 : 		FILogFile* pLog;
; 1909 : 
; 1910 : 		// Open the right file
; 1911 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 5
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$227309[esp+280]
	test	eax, eax
	je	SHORT $LN38@LogCityCap
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@LogCityCap
$LN38@LogCityCap:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@LogCityCap:

; 1912 : 		strOldOwnerName = GET_PLAYER(eOldOwner).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eOldOwner$[esp+276]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strOldOwnerName$227310[esp+280]
	test	eax, eax
	je	SHORT $LN44@LogCityCap
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@LogCityCap
$LN44@LogCityCap:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@LogCityCap:

; 1913 : 		strCityName = pCity->getName();

	mov	ecx, DWORD PTR _pCity$[esp+276]
	lea	eax, DWORD PTR $T237014[esp+280]
	push	eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strCityName$227311[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237014[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1914 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	push	0
	lea	ecx, DWORD PTR _strPlayerName$227309[esp+284]
	push	ecx
	lea	edx, DWORD PTR $T237015[esp+288]
	push	edx
	mov	ecx, edi
	mov	esi, eax
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T237015[esp+280]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1915 : 
; 1916 : 		// Get the leading info for this line
; 1917 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227308[esp+284]
	push	OFFSET $SG227316
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1918 : 		strBaseString += strPlayerName + ", ";

	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG227318
	lea	edx, DWORD PTR _strPlayerName$227309[esp+296]
	push	edx
	lea	eax, DWORD PTR $T237016[esp+300]
	push	eax
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227308[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 8
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237016[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1919 : 
; 1920 : 		// Strategy Info
; 1921 : 		strTemp = "Captured: " + strCityName + ", ";

	lea	ecx, DWORD PTR _strCityName$227311[esp+280]
	push	ecx
	lea	edx, DWORD PTR $T237017[esp+284]
	push	OFFSET $SG227322
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG227321
	push	eax
	lea	eax, DWORD PTR $T237018[esp+300]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+312], 9
	call	ebp
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$227312[esp+284]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+288], 9
	lea	ecx, DWORD PTR $T237018[esp+280]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237017[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1922 : 		strTemp += "From: " + strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$227310[esp+280]
	push	ecx
	lea	edx, DWORD PTR $T237019[esp+284]
	push	OFFSET $SG227324
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strTemp$227312[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 11		; 0000000bH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237019[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1923 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$227312[esp+280]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227308[esp+284]
	push	ecx
	lea	edx, DWORD PTR $T237020[esp+288]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227307[esp+284]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T237020[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1924 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227307[esp+280]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 1925 : 
; 1926 : 		LogMilitarySummaryMessage(strTemp);

	lea	eax, DWORD PTR _strTemp$227312[esp+280]
	push	eax
	mov	ecx, edi
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1927 : 	}

	lea	ecx, DWORD PTR _strTemp$227312[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strCityName$227311[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOldOwnerName$227310[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$227309[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227308[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227307[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebp
	pop	ebx
$LN1@LogCityCap:

; 1928 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+268]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 264				; 00000108H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227307[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227308[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$227309[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strOldOwnerName$227310[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strCityName$227311[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR _strTemp$227312[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T237014[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T237015[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8:
	lea	ecx, DWORD PTR $T237016[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9:
	lea	ecx, DWORD PTR $T237017[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10:
	lea	ecx, DWORD PTR $T237018[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11:
	lea	ecx, DWORD PTR $T237019[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12:
	lea	ecx, DWORD PTR $T237020[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityCaptured@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::LogCityCaptured
PUBLIC	?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::LogCityRazed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_strPlayerName$227334 = -264				; size = 28
_strTemp$227337 = -236					; size = 28
$T237150 = -208						; size = 28
$T237149 = -208						; size = 28
$T237147 = -208						; size = 28
_strOldOwnerName$227335 = -180				; size = 28
_strBaseString$227333 = -152				; size = 28
_strCityName$227336 = -124				; size = 28
$T237148 = -96						; size = 28
$T237146 = -96						; size = 28
$T237145 = -68						; size = 28
$T237144 = -68						; size = 28
_strOutBuf$227332 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
_eOldOwner$ = 12					; size = 4
?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvMilitaryAI::LogCityRazed, COMDAT
; _this$ = ecx

; 1932 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 252				; 000000fcH
	push	edi
	mov	edi, ecx

; 1933 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogCityRaz
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogCityRaz
	push	ebx
	push	ebp
	push	esi

; 1934 : 	{
; 1935 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227332[esp+280]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1936 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227333[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1937 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227334[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1938 : 		CvString strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$227335[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1939 : 		CvString strCityName;

	lea	ecx, DWORD PTR _strCityName$227336[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1940 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227337[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1941 : 		FILogFile* pLog;
; 1942 : 
; 1943 : 		// Open the right file
; 1944 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 5
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$227334[esp+280]
	test	eax, eax
	je	SHORT $LN38@LogCityRaz
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@LogCityRaz
$LN38@LogCityRaz:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@LogCityRaz:

; 1945 : 		strOldOwnerName = GET_PLAYER(eOldOwner).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eOldOwner$[esp+276]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strOldOwnerName$227335[esp+280]
	test	eax, eax
	je	SHORT $LN44@LogCityRaz
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@LogCityRaz
$LN44@LogCityRaz:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@LogCityRaz:

; 1946 : 		strCityName = pCity->getName();

	mov	ecx, DWORD PTR _pCity$[esp+276]
	lea	eax, DWORD PTR $T237144[esp+280]
	push	eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strCityName$227336[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237144[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1947 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	push	0
	lea	ecx, DWORD PTR _strPlayerName$227334[esp+284]
	push	ecx
	lea	edx, DWORD PTR $T237145[esp+288]
	push	edx
	mov	ecx, edi
	mov	esi, eax
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T237145[esp+280]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1948 : 
; 1949 : 		// Get the leading info for this line
; 1950 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227333[esp+284]
	push	OFFSET $SG227341
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1951 : 		strBaseString += strPlayerName + ", ";

	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG227343
	lea	edx, DWORD PTR _strPlayerName$227334[esp+296]
	push	edx
	lea	eax, DWORD PTR $T237146[esp+300]
	push	eax
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227333[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 8
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237146[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1952 : 
; 1953 : 		// Strategy Info
; 1954 : 		strTemp = "Razed: " + strCityName + ", ";

	lea	ecx, DWORD PTR _strCityName$227336[esp+280]
	push	ecx
	lea	edx, DWORD PTR $T237147[esp+284]
	push	OFFSET $SG227347
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG227346
	push	eax
	lea	eax, DWORD PTR $T237148[esp+300]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+312], 9
	call	ebp
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$227337[esp+284]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+288], 9
	lea	ecx, DWORD PTR $T237148[esp+280]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T237147[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1955 : 		strTemp += "From: " + strOldOwnerName;

	lea	ecx, DWORD PTR _strOldOwnerName$227335[esp+280]
	push	ecx
	lea	edx, DWORD PTR $T237149[esp+284]
	push	OFFSET $SG227349
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strTemp$227337[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 11		; 0000000bH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237149[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1956 : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$227337[esp+280]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227333[esp+284]
	push	ecx
	lea	edx, DWORD PTR $T237150[esp+288]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+288], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227332[esp+284]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T237150[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1957 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227332[esp+280]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 1958 : 
; 1959 : 		LogMilitarySummaryMessage(strTemp);

	lea	eax, DWORD PTR _strTemp$227337[esp+280]
	push	eax
	mov	ecx, edi
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1960 : 	}

	lea	ecx, DWORD PTR _strTemp$227337[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strCityName$227336[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOldOwnerName$227335[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$227334[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227333[esp+280]
	mov	BYTE PTR __$EHRec$[esp+288], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227332[esp+280]
	mov	DWORD PTR __$EHRec$[esp+288], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebp
	pop	ebx
$LN1@LogCityRaz:

; 1961 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+268]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 264				; 00000108H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227332[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227333[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$227334[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strOldOwnerName$227335[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strCityName$227336[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR _strTemp$227337[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T237144[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T237145[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$8:
	lea	ecx, DWORD PTR $T237146[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$9:
	lea	ecx, DWORD PTR $T237147[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$10:
	lea	ecx, DWORD PTR $T237148[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$11:
	lea	ecx, DWORD PTR $T237149[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z$12:
	lea	ecx, DWORD PTR $T237150[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityRazed@CvMilitaryAI@@QAEXPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvMilitaryAI::LogCityRazed
PUBLIC	?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z	; CvMilitaryAI::LogPeace
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_strPlayerName$227359 = -208				; size = 28
_strBaseString$227357 = -180				; size = 28
_strOpponentName$227358 = -152				; size = 28
_strTemp$227360 = -124					; size = 28
_strOutBuf$227356 = -96					; size = 28
$T237276 = -68						; size = 28
$T237275 = -68						; size = 28
$T237274 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eOpponent$ = 8						; size = 4
?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z PROC	; CvMilitaryAI::LogPeace, COMDAT
; _this$ = ecx

; 1965 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	edi
	mov	edi, ecx

; 1966 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogPeace
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogPeace
	push	ebx
	push	esi

; 1967 : 	{
; 1968 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227356[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1969 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227357[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1970 : 		CvString strOpponentName;

	lea	ecx, DWORD PTR _strOpponentName$227358[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1971 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227359[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1972 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227360[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1973 : 		FILogFile* pLog;
; 1974 : 
; 1975 : 		// Open the right file
; 1976 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$227359[esp+220]
	test	eax, eax
	je	SHORT $LN30@LogPeace
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogPeace
$LN30@LogPeace:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogPeace:

; 1977 : 		strOpponentName = GET_PLAYER(eOpponent).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _eOpponent$[esp+216]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strOpponentName$227358[esp+220]
	test	eax, eax
	je	SHORT $LN36@LogPeace
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@LogPeace
$LN36@LogPeace:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@LogPeace:

; 1978 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	0
	lea	eax, DWORD PTR _strPlayerName$227359[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T237274[esp+228]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T237274[esp+220]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1979 : 
; 1980 : 		// Get the leading info for this line
; 1981 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227357[esp+224]
	push	OFFSET $SG227363
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1982 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET $SG227365
	lea	edx, DWORD PTR _strPlayerName$227359[esp+236]
	push	edx
	lea	eax, DWORD PTR $T237275[esp+240]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227357[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237275[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1983 : 
; 1984 : 		// Strategy Info
; 1985 : 		strTemp.Format("Made peace with: %s", strOpponentName.GetCString());

	lea	ecx, DWORD PTR _strOpponentName$227358[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$227360[esp+224]
	push	OFFSET $SG227366
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1986 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$227360[esp+232]
	push	edx
	lea	eax, DWORD PTR _strBaseString$227357[esp+236]
	push	eax
	lea	ecx, DWORD PTR $T237276[esp+240]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227356[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T237276[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1987 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227356[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 1988 : 
; 1989 : 		LogMilitarySummaryMessage(strTemp);

	lea	ecx, DWORD PTR _strTemp$227360[esp+220]
	push	ecx
	mov	ecx, edi
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 1990 : 	}

	lea	ecx, DWORD PTR _strTemp$227360[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$227359[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOpponentName$227358[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227357[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227356[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogPeace:

; 1991 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227356[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227357[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _strOpponentName$227358[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$227359[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strTemp$227360[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR $T237274[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T237275[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR $T237276[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPeace@CvMilitaryAI@@QAEXW4PlayerTypes@@@Z ENDP	; CvMilitaryAI::LogPeace
PUBLIC	?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z	; CvMilitaryAI::LogPeace
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_strPlayerName$227376 = -208				; size = 28
_strOpponentName$227375 = -180				; size = 28
_strBaseString$227374 = -152				; size = 28
_strTemp$227377 = -124					; size = 28
_strOutBuf$227373 = -96					; size = 28
$T237380 = -68						; size = 28
$T237379 = -68						; size = 28
$T237378 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eOpponentTeam$ = 8					; size = 4
?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z PROC	; CvMilitaryAI::LogPeace, COMDAT
; _this$ = ecx

; 1995 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	mov	ebx, ecx

; 1996 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@LogPeace@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@LogPeace@2
	push	ebp
	push	esi
	push	edi

; 1997 : 	{
; 1998 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$227373[esp+224]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edi, edi

; 1999 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227374[esp+224]
	mov	DWORD PTR __$EHRec$[esp+232], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2000 : 		CvString strOpponentName;

	lea	ecx, DWORD PTR _strOpponentName$227375[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2001 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227376[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2002 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227377[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2003 : 		FILogFile* pLog;
; 2004 : 
; 2005 : 		// Open the right file
; 2006 : 		strPlayerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [ebx]
	mov	BYTE PTR __$EHRec$[esp+232], 4
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$227376[esp+224]
	cmp	eax, edi
	je	SHORT $LN35@LogPeace@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN34@LogPeace@2
$LN35@LogPeace@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN34@LogPeace@2:

; 2007 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	push	edi
	lea	eax, DWORD PTR _strPlayerName$227376[esp+228]
	push	eax
	lea	ecx, DWORD PTR $T237378[esp+232]
	push	ecx
	mov	ecx, ebx
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+232], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	edi
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T237378[esp+224]
	mov	ebp, eax
	mov	BYTE PTR __$EHRec$[esp+232], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2008 : 
; 2009 : 		// Get the leading info for this line
; 2010 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227374[esp+228]
	push	OFFSET $SG227380
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2011 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET $SG227382
	lea	edx, DWORD PTR _strPlayerName$227376[esp+240]
	push	edx
	lea	eax, DWORD PTR $T237379[esp+244]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227374[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T237379[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	npad	1
$LL5@LogPeace@2:

; 2012 : 
; 2013 : 		// Collect the names of the players on the team
; 2014 : 		for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
; 2015 : 		{
; 2016 : 			CvPlayer& kPlayer = GET_PLAYER((PlayerTypes) iPlayer);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2017 : 			if(kPlayer.isAlive() && kPlayer.getTeam() == eOpponentTeam)

	cmp	BYTE PTR [edi+ecx+2256], 0
	lea	esi, DWORD PTR [edi+ecx]
	je	SHORT $LN4@LogPeace@2
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN55@LogPeace@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN56@LogPeace@2
$LN55@LogPeace@2:
	or	eax, -1
$LN56@LogPeace@2:
	cmp	eax, DWORD PTR _eOpponentTeam$[esp+220]
	jne	SHORT $LN4@LogPeace@2

; 2018 : 			{
; 2019 : 				if(strOpponentName.GetLength() != 0)

	lea	ecx, DWORD PTR _strOpponentName$227375[esp+224]
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	je	SHORT $LN1@LogPeace@2

; 2020 : 					strOpponentName += ", ";

	push	OFFSET $SG227391
	lea	ecx, DWORD PTR _strOpponentName$227375[esp+228]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@LogPeace@2:

; 2021 : 
; 2022 : 				strOpponentName += kPlayer.getCivilizationShortDescription();

	mov	ecx, esi
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strOpponentName$227375[esp+228]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN4@LogPeace@2:
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL5@LogPeace@2

; 2023 : 			}
; 2024 : 		}
; 2025 : 		// Strategy Info
; 2026 : 		strTemp.Format("Made peace with team: %d (%s)", (int)eOpponentTeam, strOpponentName.GetCString());

	lea	ecx, DWORD PTR _strOpponentName$227375[esp+224]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR _eOpponentTeam$[esp+220]
	push	eax
	push	edx
	lea	eax, DWORD PTR _strTemp$227377[esp+232]
	push	OFFSET $SG227393
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2027 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$227377[esp+240]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$227374[esp+244]
	push	edx
	lea	eax, DWORD PTR $T237380[esp+248]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+232], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$227373[esp+228]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T237380[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2028 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227373[esp+224]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	add	esp, 8

; 2029 : 
; 2030 : 		LogMilitarySummaryMessage(strTemp);

	lea	eax, DWORD PTR _strTemp$227377[esp+224]
	push	eax
	mov	ecx, ebx
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage

; 2031 : 	}

	lea	ecx, DWORD PTR _strTemp$227377[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$227376[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOpponentName$227375[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227374[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$227373[esp+224]
	mov	DWORD PTR __$EHRec$[esp+232], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
$LN6@LogPeace@2:

; 2032 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$227373[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$227374[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$2:
	lea	ecx, DWORD PTR _strOpponentName$227375[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$227376[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$4:
	lea	ecx, DWORD PTR _strTemp$227377[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$5:
	lea	ecx, DWORD PTR $T237378[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$6:
	lea	ecx, DWORD PTR $T237379[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z$7:
	lea	ecx, DWORD PTR $T237380[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPeace@CvMilitaryAI@@QAEXW4TeamTypes@@@Z ENDP	; CvMilitaryAI::LogPeace
PUBLIC	?UpdateDefenseState@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateDefenseState
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateDefenseState@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
?UpdateDefenseState@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateDefenseState, COMDAT
; _this$ = ecx

; 2216 : {

	push	esi
	mov	esi, ecx

; 2217 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateDefenseState, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2218 : 
; 2219 : 	int iLandUnitsNotInArmies;
; 2220 : 	int iNavalUnitsNotInArmies;
; 2221 : 
; 2222 : 	// Derive data we'll need
; 2223 : 	iLandUnitsNotInArmies = m_iNumLandUnits;

	mov	ecx, DWORD PTR [esi+52]

; 2224 : 	iNavalUnitsNotInArmies = m_iNumNavalUnits;
; 2225 : 
; 2226 : 	if(iLandUnitsNotInArmies < m_iMandatoryReserveSize)

	cmp	ecx, DWORD PTR [esi+100]
	push	edi
	mov	edi, DWORD PTR [esi+68]
	jge	SHORT $LN12@UpdateDefe

; 2227 : 	{
; 2228 : 		m_eLandDefenseState = DEFENSE_STATE_CRITICAL;

	mov	DWORD PTR [esi+112], 3
	jmp	SHORT $LN8@UpdateDefe
$LN12@UpdateDefe:

; 2229 : 	}
; 2230 : 	else if(iLandUnitsNotInArmies < m_iRecommendedMilitarySize)

	mov	eax, DWORD PTR [esi+96]
	cmp	ecx, eax
	jge	SHORT $LN10@UpdateDefe

; 2231 : 	{
; 2232 : 		m_eLandDefenseState = DEFENSE_STATE_NEEDED;

	mov	DWORD PTR [esi+112], 2
	jmp	SHORT $LN8@UpdateDefe
$LN10@UpdateDefe:

; 2233 : 	}
; 2234 : 	else if(iLandUnitsNotInArmies < m_iRecommendedMilitarySize * 5 / 4)

	lea	eax, DWORD PTR [eax+eax*4]
	cdq
	and	edx, 3
	add	eax, edx
	xor	edx, edx
	sar	eax, 2
	cmp	ecx, eax
	setl	dl
	mov	DWORD PTR [esi+112], edx
$LN8@UpdateDefe:

; 2235 : 	{
; 2236 : 		m_eLandDefenseState = DEFENSE_STATE_NEUTRAL;
; 2237 : 	}
; 2238 : 	else
; 2239 : 	{
; 2240 : 		m_eLandDefenseState = DEFENSE_STATE_ENOUGH;
; 2241 : 	}
; 2242 : 
; 2243 : 	int iNavySize = MilitaryAIHelpers::ComputeRecommendedNavySize(m_pPlayer);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ; MilitaryAIHelpers::ComputeRecommendedNavySize
	mov	ecx, eax

; 2244 : 
; 2245 : 	if(iNavalUnitsNotInArmies <= (iNavySize / 2))

	cdq
	sub	eax, edx
	sar	eax, 1
	add	esp, 4
	cmp	edi, eax
	jg	SHORT $LN6@UpdateDefe
	pop	edi

; 2246 : 	{
; 2247 : 		m_eNavalDefenseState = DEFENSE_STATE_CRITICAL;

	mov	DWORD PTR [esi+116], 3
	pop	esi

; 2254 : 	{
; 2255 : 		m_eNavalDefenseState = DEFENSE_STATE_NEUTRAL;
; 2256 : 	}
; 2257 : 	else
; 2258 : 	{
; 2259 : 		m_eNavalDefenseState = DEFENSE_STATE_ENOUGH;
; 2260 : 	}
; 2261 : }

	ret	0
$LN6@UpdateDefe:

; 2248 : 	}
; 2249 : 	else if(iNavalUnitsNotInArmies <= iNavySize)

	cmp	edi, ecx
	jg	SHORT $LN4@UpdateDefe
	pop	edi

; 2250 : 	{
; 2251 : 		m_eNavalDefenseState = DEFENSE_STATE_NEEDED;

	mov	DWORD PTR [esi+116], 2
	pop	esi

; 2254 : 	{
; 2255 : 		m_eNavalDefenseState = DEFENSE_STATE_NEUTRAL;
; 2256 : 	}
; 2257 : 	else
; 2258 : 	{
; 2259 : 		m_eNavalDefenseState = DEFENSE_STATE_ENOUGH;
; 2260 : 	}
; 2261 : }

	ret	0
$LN4@UpdateDefe:

; 2252 : 	}
; 2253 : 	else if(iNavalUnitsNotInArmies <= iNavySize * 5 / 4)

	lea	eax, DWORD PTR [ecx+ecx*4]
	cdq
	and	edx, 3
	add	eax, edx
	xor	ecx, ecx
	sar	eax, 2
	cmp	edi, eax
	setle	cl
	pop	edi
	mov	DWORD PTR [esi+116], ecx
	pop	esi

; 2254 : 	{
; 2255 : 		m_eNavalDefenseState = DEFENSE_STATE_NEUTRAL;
; 2256 : 	}
; 2257 : 	else
; 2258 : 	{
; 2259 : 		m_eNavalDefenseState = DEFENSE_STATE_ENOUGH;
; 2260 : 	}
; 2261 : }

	ret	0
?UpdateDefenseState@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateDefenseState
_TEXT	ENDS
PUBLIC	?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::WarStateChange
; Function compile flags: /Ogtpy
;	COMDAT ?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eNewWarState$ = 12					; size = 4
_eOldWarState$ = 16					; size = 4
?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z PROC ; CvMilitaryAI::WarStateChange, COMDAT
; _this$ = ecx

; 2418 : 	LogWarStateChange(ePlayer, eNewWarState, eOldWarState);

	jmp	?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::LogWarStateChange
?WarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ENDP ; CvMilitaryAI::WarStateChange
_TEXT	ENDS
PUBLIC	?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateMilitaryStrategies
EXTRN	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z:PROC ; CvCitySpecializationAI::SetSpecializationsDirty
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z:PROC ; CvFlavorManager::ChangeFlavors
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$1
__ehfuncinfo$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_bTestStrategyStart$227582 = -51			; size = 1
_bTestStrategyEnd$227590 = -50				; size = 1
_bResult$227683 = -49					; size = 1
_iStrategiesLoop$ = -48					; size = 4
_args$227682 = -44					; size = 4
_strStrategyName$227602 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ PROC	; CvMilitaryAI::UpdateMilitaryStrategies, COMDAT
; _this$ = ecx

; 2423 : {

	push	-1
	push	__ehhandler$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	esi
	mov	esi, ecx

; 2424 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateMilitaryStrategies, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2425 : 
; 2426 : 	int iStrategiesLoop = 0;
; 2427 : 
; 2428 : 	// Loop through all strategies
; 2429 : 	for(iStrategiesLoop = 0; iStrategiesLoop < GetMilitaryAIStrategies()->GetNumMilitaryAIStrategies(); iStrategiesLoop++)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _iStrategiesLoop$[esp+56], 0
	test	ecx, -4					; fffffffcH
	jle	$LN97@UpdateMili
	push	ebx
	push	ebp
	push	edi
	npad	5
$LL323@UpdateMili:

; 2430 : 	{
; 2431 : 		MilitaryAIStrategyTypes eStrategy = (MilitaryAIStrategyTypes) iStrategiesLoop;
; 2432 : 		CvMilitaryAIStrategyXMLEntry* pStrategy = GetMilitaryAIStrategies()->GetEntry(iStrategiesLoop);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _iStrategiesLoop$[esp+68]
	mov	ebp, DWORD PTR [edx+eax*4]

; 2433 : 
; 2434 : 		if(pStrategy == NULL)	// Can have holes in the list

	test	ebp, ebp
	je	$LN320@UpdateMili

; 2435 : 			continue;
; 2436 : 
; 2437 : 		// Minor Civs can't run some Strategies
; 2438 : 		if(GetPlayer()->isMinorCiv() && pStrategy->IsNoMinorCivs())

	mov	ecx, DWORD PTR [esi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN95@UpdateMili
	cmp	BYTE PTR [ebp+276], 0
	jne	$LN320@UpdateMili
$LN95@UpdateMili:

; 2439 : 			continue;
; 2440 : 
; 2441 : 		// Some strategies ONLY for Minor Civs
; 2442 : 		if(!GetPlayer()->isMinorCiv() && pStrategy->IsOnlyMinorCivs())

	mov	ecx, DWORD PTR [esi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN94@UpdateMili
	cmp	BYTE PTR [ebp+277], al
	jne	$LN320@UpdateMili
$LN94@UpdateMili:

; 2443 : 			continue;
; 2444 : 
; 2445 : 		bool bTestStrategyStart = true;
; 2446 : 
; 2447 : 		// Do we already have this Strategy adopted?
; 2448 : 		if(IsUsingStrategy(eStrategy))

	mov	ecx, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR _iStrategiesLoop$[esp+68]
	cmp	BYTE PTR [ebx+ecx], 0
	mov	BYTE PTR _bTestStrategyStart$227582[esp+68], 1

; 2449 : 			bTestStrategyStart = false;
; 2450 : 
; 2451 : 		else

	jne	$LN329@UpdateMili

; 2452 : 		{
; 2453 : 			// Has the prereq Tech necessary?
; 2454 : 			if(pStrategy->GetTechPrereq() != NO_TECH && !GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechPrereq()))

	mov	ecx, DWORD PTR [ebp+280]
	cmp	ecx, -1
	je	SHORT $LN324@UpdateMili
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN136@UpdateMili
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN137@UpdateMili
$LN136@UpdateMili:
	or	eax, -1
$LN137@UpdateMili:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al

; 2455 : 			{
; 2456 : 				bTestStrategyStart = false;
; 2457 : 			}
; 2458 : 
; 2459 : 			// Has the Tech which obsoletes this Strategy?
; 2460 : 			if(bTestStrategyStart && pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	je	SHORT $LN330@UpdateMili
$LN324@UpdateMili:
	mov	ecx, DWORD PTR [ebp+284]
	cmp	ecx, -1
	je	SHORT $LN90@UpdateMili
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN153@UpdateMili
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN154@UpdateMili
$LN153@UpdateMili:
	or	eax, -1
$LN154@UpdateMili:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN90@UpdateMili
$LN330@UpdateMili:

; 2461 : 			{
; 2462 : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$227582[esp+68], 0
$LN90@UpdateMili:

; 2463 : 			}
; 2464 : 
; 2465 : 			// Not time to check this yet?
; 2466 : 			if(GC.getGame().getGameTurn() < pStrategy->GetFirstTurnExecuted())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [ebp+296]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, edi
	jge	SHORT $LN89@UpdateMili
$LN329@UpdateMili:

; 2467 : 			{
; 2468 : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$227582[esp+68], 0
$LN89@UpdateMili:

; 2469 : 			}
; 2470 : 		}
; 2471 : 
; 2472 : 		bool bTestStrategyEnd = false;
; 2473 : 
; 2474 : 		// Strategy is active, check to see if we should even try to disable it
; 2475 : 		if(IsUsingStrategy(eStrategy))

	mov	eax, DWORD PTR [esi+12]
	cmp	BYTE PTR [ebx+eax], 0
	mov	BYTE PTR _bTestStrategyEnd$227590[esp+68], 0
	je	SHORT $LN321@UpdateMili

; 2476 : 		{
; 2477 : 			if(pStrategy->GetCheckTriggerTurnCount() > 0)

	mov	edi, DWORD PTR [ebp+292]
	test	edi, edi
	jle	SHORT $LN321@UpdateMili

; 2478 : 			{
; 2479 : 				// Is it a turn where we want to check to see if this Strategy is maintained?
; 2480 : 				if((GC.getGame().getGameTurn() - GetTurnStrategyAdopted(eStrategy)) % pStrategy->GetCheckTriggerTurnCount() == 0)

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR _iStrategiesLoop$[esp+68]
	mov	ebx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, ebx
	cdq
	idiv	edi
	test	edx, edx
	jne	SHORT $LN321@UpdateMili

; 2481 : 					bTestStrategyEnd = true;
; 2482 : 			}
; 2483 : 
; 2484 : 			if(bTestStrategyEnd && pStrategy->GetMinimumNumTurnsExecuted() > 0)

	mov	edi, DWORD PTR [ebp+288]
	mov	BYTE PTR _bTestStrategyEnd$227590[esp+68], 1
	test	edi, edi
	jle	SHORT $LN321@UpdateMili

; 2485 : 			{
; 2486 : 				// Has the minimum # of turns passed for this Strategy?
; 2487 : 				if(GC.getGame().getGameTurn() < GetTurnStrategyAdopted(eStrategy) + pStrategy->GetMinimumNumTurnsExecuted())

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _iStrategiesLoop$[esp+68]
	mov	ebx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebx, edi
	cmp	eax, ebx
	jge	SHORT $LN321@UpdateMili

; 2488 : 					bTestStrategyEnd = false;

	mov	BYTE PTR _bTestStrategyEnd$227590[esp+68], 0
$LN321@UpdateMili:

; 2489 : 			}
; 2490 : 		}
; 2491 : 
; 2492 : 		// Check Strategy Triggers
; 2493 : 		// Functionality and existence of specific Strategies is hardcoded here, but data is stored in XML so it's easier to modify
; 2494 : 
; 2495 : 		if(bTestStrategyStart || bTestStrategyEnd)

	cmp	BYTE PTR _bTestStrategyStart$227582[esp+68], 0
	jne	SHORT $LN82@UpdateMili
	cmp	BYTE PTR _bTestStrategyEnd$227590[esp+68], 0
	je	$LN320@UpdateMili
$LN82@UpdateMili:

; 2496 : 		{
; 2497 : 			bool bStrategyShouldBeActive = false;
; 2498 : 
; 2499 : 			// Has the Tech which obsoletes this Strategy? If so, Strategy should be deactivated regardless of other factors
; 2500 : 			if(pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	mov	ecx, DWORD PTR [ebp+284]
	cmp	ecx, -1
	je	SHORT $LN81@UpdateMili
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN192@UpdateMili
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN193@UpdateMili
$LN192@UpdateMili:
	or	eax, -1
$LN193@UpdateMili:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al

; 2501 : 			{
; 2502 : 				bStrategyShouldBeActive = false;
; 2503 : 			}
; 2504 : 
; 2505 : 			// Strategy isn't obsolete, so test triggers as normal
; 2506 : 			else

	jne	$LN318@UpdateMili
$LN81@UpdateMili:

; 2507 : 			{
; 2508 : 				CvString strStrategyName = (CvString) pStrategy->GetType();

	lea	ecx, DWORD PTR [ebp+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN204@UpdateMili
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN204@UpdateMili:
	push	eax
	lea	ecx, DWORD PTR _strStrategyName$227602[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2509 : 
; 2510 : 				// Check all of the Strategy Triggers
; 2511 : 				if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_MILITARY_UNITS")

	mov	edi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227606
	push	eax
	mov	DWORD PTR __$EHRec$[esp+84], 0
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN79@UpdateMili

; 2512 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	?IsTestStrategy_EnoughMilitaryUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMilitaryUnits
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN79@UpdateMili:

; 2513 : 				else if(strStrategyName == "MILITARYAISTRATEGY_EMPIRE_DEFENSE")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227609
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN77@UpdateMili

; 2514 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EmpireDefense(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+112], 2
	sete	bl
	jmp	$LN30@UpdateMili
$LN77@UpdateMili:

; 2515 : 				else if(strStrategyName == "MILITARYAISTRATEGY_EMPIRE_DEFENSE_CRITICAL")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227612
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN75@UpdateMili

; 2516 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EmpireDefenseCritical(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+112], 3
	sete	bl
	jmp	$LN30@UpdateMili
$LN75@UpdateMili:

; 2517 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_NAVAL_UNITS")

	lea	ecx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227615
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN73@UpdateMili

; 2518 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughNavalUnits(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	cmp	DWORD PTR [eax+116], 0
	sete	bl
	jmp	$LN30@UpdateMili
$LN73@UpdateMili:

; 2519 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_NAVAL_UNITS")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227618
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN71@UpdateMili

; 2520 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits(m_pPlayer);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?IsTestStrategy_NeedNavalUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnits
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN71@UpdateMili:

; 2521 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_NAVAL_UNITS_CRITICAL")

	lea	ecx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227621
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN69@UpdateMili

; 2522 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical(m_pPlayer);

	mov	edx, DWORD PTR [esi]
	push	edx
	call	?IsTestStrategy_NeedNavalUnitsCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedNavalUnitsCritical
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN69@UpdateMili:

; 2523 : 				else if(strStrategyName == "MILITARYAISTRATEGY_WAR_MOBILIZATION")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227624
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN67@UpdateMili

; 2524 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_WarMobilization(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _iStrategiesLoop$[esp+68]
	push	ecx
	push	edx
	call	?IsTestStrategy_WarMobilization@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WarMobilization
	add	esp, 8
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN67@UpdateMili:

; 2525 : 				else if(strStrategyName == "MILITARYAISTRATEGY_AT_WAR")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227627
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN65@UpdateMili

; 2526 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_AtWar(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	?IsTestStrategy_AtWar@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_AtWar
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN65@UpdateMili:

; 2527 : 				else if(strStrategyName == "MILITARYAISTRATEGY_MINOR_CIV_GENERAL_DEFENSE")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227630
	push	edx
	call	edi
	add	esp, 8
	test	al, al

; 2528 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_MinorCivGeneralDefense();

	jne	$LN31@UpdateMili

; 2529 : 				else if(strStrategyName == "MILITARYAISTRATEGY_MINOR_CIV_THREAT_ELEVATED")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227633
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN61@UpdateMili

; 2530 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	?IsTestStrategy_MinorCivThreatElevated@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatElevated
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN61@UpdateMili:

; 2531 : 				else if(strStrategyName == "MILITARYAISTRATEGY_MINOR_CIV_THREAT_CRITICAL")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227636
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN59@UpdateMili

; 2532 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical(m_pPlayer);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?IsTestStrategy_MinorCivThreatCritical@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_MinorCivThreatCritical
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN59@UpdateMili:

; 2533 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ERADICATE_BARBARIANS")

	lea	ecx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227639
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN57@UpdateMili

; 2534 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians(eStrategy, m_pPlayer, m_iBarbarianCampCount, m_iVisibleBarbarianCount);

	mov	edx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR _iStrategiesLoop$[esp+72]
	push	eax
	push	ecx
	push	edx
	call	?IsTestStrategy_EradicateBarbarians@MilitaryAIHelpers@@YA_NW4MilitaryAIStrategyTypes@@PAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EradicateBarbarians
	add	esp, 16					; 00000010H
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN57@UpdateMili:

; 2535 : 				else if(strStrategyName == "MILITARYAISTRATEGY_WINNING_WARS")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227642
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN55@UpdateMili

; 2536 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_WinningWars(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	?IsTestStrategy_WinningWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_WinningWars
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN55@UpdateMili:

; 2537 : 				else if(strStrategyName == "MILITARYAISTRATEGY_LOSING_WARS")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227645
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN53@UpdateMili

; 2538 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_LosingWars(m_pPlayer);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?IsTestStrategy_LosingWars@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_LosingWars
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN53@UpdateMili:

; 2539 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_RANGED")

	lea	ecx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227648
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN51@UpdateMili

; 2540 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits(m_pPlayer, m_iNumRangedLandUnits, m_iNumMeleeLandUnits);

	mov	edx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?IsTestStrategy_NeedRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN51@UpdateMili:

; 2541 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_RANGED")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227651
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN49@UpdateMili

; 2542 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits(m_pPlayer, m_iNumRangedLandUnits, m_iNumMeleeLandUnits);

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	call	?IsTestStrategy_EnoughRangedUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughRangedUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN49@UpdateMili:

; 2543 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_RANGED_EARLY")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227654
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN47@UpdateMili

; 2544 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	?IsTestStrategy_NeedRangedDueToEarlySneakAttack@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedRangedDueToEarlySneakAttack
	add	esp, 4
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN47@UpdateMili:

; 2545 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_MOBILE")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227657
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN45@UpdateMili

; 2546 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits(m_pPlayer, m_iNumMobileLandUnits, m_iNumMeleeLandUnits);

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+60]
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	call	?IsTestStrategy_NeedMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedMobileUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN45@UpdateMili:

; 2547 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_MOBILE")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227660
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN43@UpdateMili

; 2548 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits(m_pPlayer, m_iNumMobileLandUnits, m_iNumMeleeLandUnits);

	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	edx
	push	eax
	call	?IsTestStrategy_EnoughMobileUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughMobileUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN43@UpdateMili:

; 2549 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_AIR")

	lea	ecx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227663
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN41@UpdateMili

; 2550 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedAirUnits(m_pPlayer, m_iNumAirUnits, m_iNumMeleeLandUnits);

	mov	edx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [esi+80]
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?IsTestStrategy_NeedAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN41@UpdateMili:

; 2551 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_AIR")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227666
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN39@UpdateMili

; 2552 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits(m_pPlayer, m_iNumAirUnits, m_iNumMeleeLandUnits);

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+80]
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	call	?IsTestStrategy_EnoughAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAirUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	$LN30@UpdateMili
$LN39@UpdateMili:

; 2553 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_NUKE")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227669
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN37@UpdateMili

; 2554 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedANuke(m_pPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	?IsTestStrategy_NeedANuke@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedANuke
	add	esp, 4
	mov	bl, al
	jmp	SHORT $LN30@UpdateMili
$LN37@UpdateMili:

; 2555 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_ANTIAIR")

	lea	edx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227672
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN35@UpdateMili

; 2556 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits(m_pPlayer, m_iNumAntiAirUnits, m_iNumMeleeLandUnits);

	mov	eax, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+84]
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	call	?IsTestStrategy_NeedAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAntiAirUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	SHORT $LN30@UpdateMili
$LN35@UpdateMili:

; 2557 : 				else if(strStrategyName == "MILITARYAISTRATEGY_ENOUGH_ANTIAIR")

	lea	eax, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227675
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN33@UpdateMili

; 2558 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits(m_pPlayer, m_iNumAntiAirUnits, m_iNumMeleeLandUnits);

	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR [esi+84]
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	edx
	push	eax
	call	?IsTestStrategy_EnoughAntiAirUnits@MilitaryAIHelpers@@YA_NPAVCvPlayer@@HH@Z ; MilitaryAIHelpers::IsTestStrategy_EnoughAntiAirUnits
	add	esp, 12					; 0000000cH
	mov	bl, al
	jmp	SHORT $LN30@UpdateMili
$LN33@UpdateMili:

; 2559 : 				else if(strStrategyName == "MILITARYAISTRATEGY_NEED_AIR_CARRIER")

	lea	ecx, DWORD PTR _strStrategyName$227602[esp+68]
	push	OFFSET $SG227678
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN31@UpdateMili

; 2560 : 					bStrategyShouldBeActive = MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers(m_pPlayer);

	mov	edx, DWORD PTR [esi]
	push	edx
	call	?IsTestStrategy_NeedAirCarriers@MilitaryAIHelpers@@YA_NPAVCvPlayer@@@Z ; MilitaryAIHelpers::IsTestStrategy_NeedAirCarriers
	add	esp, 4
	mov	bl, al

; 2561 : 
; 2562 : 				// Never found it?  Assume it is scenario-specific and should be on unless disabled by Lua hook
; 2563 : 				else

	jmp	SHORT $LN30@UpdateMili
$LN31@UpdateMili:

; 2564 : 				{
; 2565 : 					bStrategyShouldBeActive = true;

	mov	bl, 1
$LN30@UpdateMili:

; 2566 : 				}
; 2567 : 
; 2568 : 				// Check Lua hook
; 2569 : 				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	edi, eax

; 2570 : 				if(pkScriptSystem && bStrategyShouldBeActive)

	test	edi, edi
	je	SHORT $LN29@UpdateMili
	test	bl, bl
	je	SHORT $LN29@UpdateMili

; 2571 : 				{
; 2572 : 					CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$227682[esp+68]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 2573 : 					args->Push(iStrategiesLoop);

	mov	ecx, DWORD PTR _args$227682[esp+68]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _iStrategiesLoop$[esp+68]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+80], 1
	call	eax

; 2574 : 					args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$227682[esp+68]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2575 : 
; 2576 : 					// Attempt to execute the game events.
; 2577 : 					// Will return false if there are no registered listeners.
; 2578 : 					bool bResult = false;
; 2579 : 					if(LuaSupport::CallTestAll(pkScriptSystem, "MilitaryStrategyCanActivate", args.get(), bResult))

	mov	edx, DWORD PTR _args$227682[esp+68]
	lea	ecx, DWORD PTR _bResult$227683[esp+68]
	push	ecx
	push	edx
	push	OFFSET $SG227685
	push	edi
	mov	BYTE PTR _bResult$227683[esp+84], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN27@UpdateMili

; 2580 : 					{
; 2581 : 						// Check the result.
; 2582 : 						if(bResult == false)

	cmp	BYTE PTR _bResult$227683[esp+68], 0
	jne	SHORT $LN27@UpdateMili

; 2583 : 						{
; 2584 : 							bStrategyShouldBeActive = false;

	xor	bl, bl
$LN27@UpdateMili:

; 2585 : 						}
; 2586 : 					}
; 2587 : 				}

	lea	ecx, DWORD PTR _args$227682[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN29@UpdateMili:

; 2588 : 			}

	lea	ecx, DWORD PTR _strStrategyName$227602[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2589 : 
; 2590 : 			// This variable keeps track of whether or not we should be doing something (i.e. Strategy is active now but should be turned off, OR Strategy is inactive and should be enabled)
; 2591 : 			bool bAdoptOrEndStrategy = false;
; 2592 : 
; 2593 : 			// Strategy should be on, and if it's not, turn it on
; 2594 : 			if(bStrategyShouldBeActive)

	test	bl, bl
	je	SHORT $LN318@UpdateMili

; 2595 : 			{
; 2596 : 				if(bTestStrategyStart)

	cmp	BYTE PTR _bTestStrategyStart$227582[esp+68], 0

; 2597 : 					bAdoptOrEndStrategy = true;
; 2598 : 				else if(bTestStrategyEnd)
; 2599 : 					bAdoptOrEndStrategy = false;
; 2600 : 			}
; 2601 : 			// Strategy should be off, and if it's not, turn it off
; 2602 : 			else

	mov	edi, DWORD PTR _iStrategiesLoop$[esp+68]
	je	$LN98@UpdateMili

; 2607 : 					bAdoptOrEndStrategy = true;
; 2608 : 			}
; 2609 : 
; 2610 : 			// Flavor propagation
; 2611 : 			if(bAdoptOrEndStrategy)
; 2612 : 			{
; 2613 : 				int iFlavorLoop;
; 2614 : 
; 2615 : 				// We should adopt this Strategy
; 2616 : 				if(bTestStrategyStart)
; 2617 : 				{
; 2618 : 					SetUsingStrategy(eStrategy, true);

	mov	eax, DWORD PTR [esi+12]
	add	eax, edi
	cmp	BYTE PTR [eax], 1
	je	SHORT $LN319@UpdateMili
	mov	BYTE PTR [eax], 1
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx+edi*4], eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	je	SHORT $LN245@UpdateMili
	mov	DWORD PTR [ecx], eax
$LN245@UpdateMili:
	push	1
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::LogStrategy
$LN319@UpdateMili:

; 2619 : 
; 2620 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	eax, eax
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, eax
	jle	$LN326@UpdateMili
	npad	8
$LL16@UpdateMili:

; 2621 : 					{
; 2622 : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR [ebp+260]
	test	ecx, ecx
	je	SHORT $LN255@UpdateMili
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN256@UpdateMili
$LN318@UpdateMili:

; 2603 : 			{
; 2604 : 				if(bTestStrategyStart)

	cmp	BYTE PTR _bTestStrategyStart$227582[esp+68], 0

; 2605 : 					bAdoptOrEndStrategy = false;

	jne	$LN320@UpdateMili

; 2606 : 				else if(bTestStrategyEnd)

	cmp	BYTE PTR _bTestStrategyEnd$227590[esp+68], 0
	je	$LN320@UpdateMili

; 2637 : 				// End the Strategy
; 2638 : 				else if(bTestStrategyEnd)
; 2639 : 				{
; 2640 : 					SetUsingStrategy(eStrategy, false);

	mov	ecx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR _iStrategiesLoop$[esp+68]
	cmp	BYTE PTR [edi+ecx], 0
	lea	eax, DWORD PTR [edi+ecx]
	je	SHORT $LN325@UpdateMili
	mov	BYTE PTR [eax], 0
	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+edi*4], -1
	lea	eax, DWORD PTR [edx+edi*4]
	je	SHORT $LN281@UpdateMili
	mov	DWORD PTR [eax], -1
$LN281@UpdateMili:
	push	0
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvMilitaryAI@@AAEXW4MilitaryAIStrategyTypes@@_N@Z ; CvMilitaryAI::LogStrategy
$LN325@UpdateMili:

; 2641 : 
; 2642 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	ecx, ecx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, ecx
	jle	$LN327@UpdateMili
$LL7@UpdateMili:

; 2643 : 					{
; 2644 : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR [ebp+260]
	test	eax, eax
	je	$LN288@UpdateMili
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	$LN289@UpdateMili

; 2621 : 					{
; 2622 : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetPlayerFlavorValue(iFlavorLoop);

$LN255@UpdateMili:
	or	ecx, -1
$LN256@UpdateMili:
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx+eax*4], ecx
	inc	eax
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL16@UpdateMili
$LN326@UpdateMili:

; 2623 : 					}
; 2624 : 
; 2625 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	push	1
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2626 : 
; 2627 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	eax, eax
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, eax
	jle	SHORT $LN11@UpdateMili
	npad	4
$LL13@UpdateMili:

; 2628 : 					{
; 2629 : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR [ebp+264]
	test	ecx, ecx
	je	SHORT $LN263@UpdateMili
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN264@UpdateMili
$LN263@UpdateMili:
	or	ecx, -1
$LN264@UpdateMili:
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx+eax*4], ecx
	inc	eax
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL13@UpdateMili
$LN11@UpdateMili:

; 2630 : 					}
; 2631 : 
; 2632 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	push	0
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2633 : 
; 2634 : 					if(pStrategy->RequiresCitySpecializationUpdate())

	cmp	BYTE PTR [ebp+278], 0
	je	$LN98@UpdateMili

; 2635 : 						GetPlayer()->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_STRATEGY_NOW_ON);

	mov	ecx, DWORD PTR [esi]
	push	5
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z ; CvCitySpecializationAI::SetSpecializationsDirty

; 2636 : 				}

	jmp	$LN98@UpdateMili

; 2643 : 					{
; 2644 : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetPlayerFlavorValue(iFlavorLoop);

$LN288@UpdateMili:
	or	eax, -1
$LN289@UpdateMili:
	mov	edx, DWORD PTR [esi+20]
	neg	eax
	mov	DWORD PTR [edx+ecx*4], eax
	inc	ecx
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL7@UpdateMili
$LN327@UpdateMili:

; 2645 : 					}
; 2646 : 
; 2647 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	push	1
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2648 : 
; 2649 : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	ecx, ecx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, ecx
	jle	SHORT $LN2@UpdateMili
	npad	3
$LL4@UpdateMili:

; 2650 : 					{
; 2651 : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR [ebp+264]
	test	eax, eax
	je	SHORT $LN296@UpdateMili
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN297@UpdateMili
$LN296@UpdateMili:
	or	eax, -1
$LN297@UpdateMili:
	mov	edx, DWORD PTR [esi+20]
	neg	eax
	mov	DWORD PTR [edx+ecx*4], eax
	inc	ecx
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL4@UpdateMili
$LN2@UpdateMili:

; 2652 : 					}
; 2653 : 
; 2654 : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	push	0
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 2655 : 
; 2656 : 					if(pStrategy->RequiresCitySpecializationUpdate())

	cmp	BYTE PTR [ebp+278], 0
	je	SHORT $LN320@UpdateMili

; 2657 : 						GetPlayer()->GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_STRATEGY_NOW_OFF);

	mov	ecx, DWORD PTR [esi]
	push	6
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z ; CvCitySpecializationAI::SetSpecializationsDirty
	jmp	SHORT $LN98@UpdateMili
$LN320@UpdateMili:
	mov	edi, DWORD PTR _iStrategiesLoop$[esp+68]
$LN98@UpdateMili:

; 2424 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateMilitaryStrategies, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2425 : 
; 2426 : 	int iStrategiesLoop = 0;
; 2427 : 
; 2428 : 	// Loop through all strategies
; 2429 : 	for(iStrategiesLoop = 0; iStrategiesLoop < GetMilitaryAIStrategies()->GetNumMilitaryAIStrategies(); iStrategiesLoop++)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	edi
	sar	ecx, 2
	cmp	edi, ecx
	mov	DWORD PTR _iStrategiesLoop$[esp+68], edi
	jl	$LL323@UpdateMili
	pop	edi
	pop	ebp
	pop	ebx
$LN97@UpdateMili:

; 2658 : 				}
; 2659 : 			}
; 2660 : 		}
; 2661 : 	}
; 2662 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strStrategyName$227602[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _args$227682[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ ENDP	; CvMilitaryAI::UpdateMilitaryStrategies
PUBLIC	?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::DisbandObsoleteUnits
EXTRN	?scrap@CvUnit@@QAEXXZ:PROC			; CvUnit::scrap
EXTRN	?getNumUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumUnits
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$3
__ehfuncinfo$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_bConquestGrandStrategy$ = -60				; size = 1
_iNavalScore$ = -56					; size = 4
_bInDeficit$ = -52					; size = 1
$T237973 = -52						; size = 4
_iLandScore$ = -48					; size = 4
$T237980 = -44						; size = 4
$T237977 = -44						; size = 8
$T237974 = -44						; size = 4
_pLandUnit$ = -36					; size = 8
_pNavalUnit$ = -28					; size = 8
$T237978 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::DisbandObsoleteUnits, COMDAT
; _this$ = ecx

; 3398 : {

	push	-1
	push	__ehhandler$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi

; 3399 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("DisbandObsoleteUnits, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3400 : 
; 3401 : 	bool bInDeficit = false;
; 3402 : 	bool bConquestGrandStrategy = false;
; 3403 : 	UnitHandle pNavalUnit;

	xor	edi, edi
	mov	esi, ecx
	mov	BYTE PTR _bConquestGrandStrategy$[esp+72], 0
	mov	DWORD PTR _pNavalUnit$[esp+72], edi
	mov	BYTE PTR _pNavalUnit$[esp+76], 0
	mov	DWORD PTR __$EHRec$[esp+80], edi

; 3404 : 	UnitHandle pLandUnit;

	mov	DWORD PTR _pLandUnit$[esp+72], edi
	mov	BYTE PTR _pLandUnit$[esp+76], 0

; 3405 : 	int iNavalScore = MAX_INT;

	mov	eax, 2147483647				; 7fffffffH
	mov	BYTE PTR __$EHRec$[esp+80], 1
	mov	DWORD PTR _iNavalScore$[esp+72], eax

; 3406 : 	int iLandScore = MAX_INT;

	mov	DWORD PTR _iLandScore$[esp+72], eax

; 3407 : 
; 3408 : 	// Don't do this if at war
; 3409 : 	if(GetNumberCivsAtWarWith() > 0)

	call	?GetNumberCivsAtWarWith@CvMilitaryAI@@QBEHXZ ; CvMilitaryAI::GetNumberCivsAtWarWith
	test	eax, eax

; 3410 : 	{
; 3411 : 		return;

	jg	$LN99@DisbandObs

; 3412 : 	}
; 3413 : 
; 3414 : 	// Don't do this if we're a minor civ
; 3415 : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [esi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 3416 : 	{
; 3417 : 		return;

	jne	$LN99@DisbandObs

; 3418 : 	}
; 3419 : 
; 3420 : 	// Are we running at a deficit?
; 3421 : 	EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");

	push	edi
	push	OFFSET $SG227972
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3422 : 	bInDeficit = m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy

; 3423 : 
; 3424 : 	int iGoldSpentOnUnits = m_pPlayer->GetTreasury()->GetExpensePerTurnUnitMaintenance();

	mov	ecx, DWORD PTR [esi]
	mov	bl, al
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury

; 3425 : 	int iAverageGoldPerUnit = iGoldSpentOnUnits / (max(1,m_pPlayer->getNumUnits()));

	mov	ecx, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+16]
	call	?getNumUnits@CvPlayer@@QBEHXZ		; CvPlayer::getNumUnits
	cmp	eax, 1
	mov	DWORD PTR $T237973[esp+72], eax
	mov	DWORD PTR $T237974[esp+72], 1
	lea	ecx, DWORD PTR $T237973[esp+72]
	jg	SHORT $LN54@DisbandObs
	lea	ecx, DWORD PTR $T237974[esp+72]
$LN54@DisbandObs:
	mov	eax, edi
	cdq
	idiv	DWORD PTR [ecx]

; 3426 : 
; 3427 : 	// if our units maintenance cost is high we may want to scrap some obsolete stuff
; 3428 : 	bInDeficit = bInDeficit || iAverageGoldPerUnit > 5;

	test	bl, bl
	jne	SHORT $LN17@DisbandObs
	cmp	eax, 5
	jle	SHORT $LN112@DisbandObs
$LN17@DisbandObs:
	mov	bl, 1
$LN112@DisbandObs:

; 3429 : 
; 3430 : 	// Are we running anything other than the Conquest Grand Strategy?
; 3431 : 	AIGrandStrategyTypes eConquestGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET $SG227979
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bInDeficit$[esp+80], bl
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 3432 : 	if(eConquestGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	edi, -1
	je	SHORT $LN11@DisbandObs

; 3433 : 	{
; 3434 : 		if(m_pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eConquestGrandStrategy)

	mov	ecx, DWORD PTR [esi]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, edi
	jne	SHORT $LN11@DisbandObs

; 3435 : 		{
; 3436 : 			bConquestGrandStrategy = true;

	mov	BYTE PTR _bConquestGrandStrategy$[esp+72], 1
$LN11@DisbandObs:

; 3437 : 		}
; 3438 : 	}
; 3439 : 
; 3440 : 	// Look for obsolete land units if in deficit or have sufficient units
; 3441 : 	if(bInDeficit || (m_eLandDefenseState <= DEFENSE_STATE_NEUTRAL && !bConquestGrandStrategy))

	test	bl, bl
	jne	SHORT $LN9@DisbandObs
	cmp	DWORD PTR [esi+112], 1
	jg	SHORT $LN107@DisbandObs
	cmp	BYTE PTR _bConquestGrandStrategy$[esp+72], bl
	jne	SHORT $LN107@DisbandObs
$LN9@DisbandObs:

; 3442 : 	{
; 3443 : 		pLandUnit = FindBestUnitToScrap(true /*bLand*/, false /*bDeficitForcedDisband*/, iLandScore);

	lea	eax, DWORD PTR _iLandScore$[esp+72]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR $T237977[esp+84]
	push	ecx
	mov	ecx, esi
	call	?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ; CvMilitaryAI::FindBestUnitToScrap
	lea	edx, DWORD PTR _pLandUnit$[esp+72]
	mov	BYTE PTR __$EHRec$[esp+80], 2
	cmp	eax, edx
	je	SHORT $LN106@DisbandObs
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _pLandUnit$[esp+72], edi
	test	edi, edi
	je	SHORT $LN62@DisbandObs
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	SHORT $LN62@DisbandObs
$LN106@DisbandObs:
	mov	edi, DWORD PTR _pLandUnit$[esp+72]
$LN62@DisbandObs:
	mov	ecx, DWORD PTR $T237977[esp+72]
	mov	BYTE PTR __$EHRec$[esp+80], 1
	test	ecx, ecx
	je	SHORT $LN67@DisbandObs
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@DisbandObs:

; 3444 : 	}
; 3445 : 
; 3446 : 	// Look for obsolete naval units if in deficit or have sufficient units
; 3447 : 	if(bInDeficit || (m_eNavalDefenseState <= DEFENSE_STATE_NEUTRAL && !bConquestGrandStrategy))

	test	bl, bl
	jne	SHORT $LN7@DisbandObs
	jmp	SHORT $LN101@DisbandObs
$LN107@DisbandObs:
	mov	edi, DWORD PTR _pLandUnit$[esp+72]
$LN101@DisbandObs:
	cmp	DWORD PTR [esi+116], 1
	jg	SHORT $LN109@DisbandObs
	cmp	BYTE PTR _bConquestGrandStrategy$[esp+72], 0
	jne	SHORT $LN109@DisbandObs
$LN7@DisbandObs:

; 3448 : 	{
; 3449 : 		pNavalUnit = FindBestUnitToScrap(false/*bNaval*/, false /*bDeficitForcedDisband*/, iNavalScore);

	lea	eax, DWORD PTR _iNavalScore$[esp+72]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR $T237978[esp+84]
	push	ecx
	mov	ecx, esi
	call	?FindBestUnitToScrap@CvMilitaryAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@_N0AAH@Z ; CvMilitaryAI::FindBestUnitToScrap
	lea	edx, DWORD PTR _pNavalUnit$[esp+72]
	mov	BYTE PTR __$EHRec$[esp+80], 3
	cmp	eax, edx
	je	SHORT $LN108@DisbandObs
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _pNavalUnit$[esp+72], ebx
	test	ebx, ebx
	je	SHORT $LN76@DisbandObs
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	SHORT $LN76@DisbandObs
$LN108@DisbandObs:
	mov	ebx, DWORD PTR _pNavalUnit$[esp+72]
$LN76@DisbandObs:
	mov	ecx, DWORD PTR $T237978[esp+72]
	mov	BYTE PTR __$EHRec$[esp+80], 1
	test	ecx, ecx
	je	SHORT $LN81@DisbandObs
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	SHORT $LN81@DisbandObs
$LN109@DisbandObs:
	mov	ebx, DWORD PTR _pNavalUnit$[esp+72]
$LN81@DisbandObs:

; 3450 : 	}
; 3451 : 
; 3452 : 	if(iLandScore < MAX_INT && (m_eLandDefenseState <= m_eNavalDefenseState || iLandScore <= iNavalScore))

	mov	eax, DWORD PTR _iLandScore$[esp+72]
	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN6@DisbandObs
	mov	ecx, DWORD PTR [esi+112]
	cmp	ecx, DWORD PTR [esi+116]
	jle	SHORT $LN5@DisbandObs
	cmp	eax, DWORD PTR _iNavalScore$[esp+72]
	jg	SHORT $LN6@DisbandObs
$LN5@DisbandObs:

; 3453 : 	{
; 3454 : 		if(pLandUnit)

	test	edi, edi
	je	SHORT $LN1@DisbandObs

; 3455 : 		{
; 3456 : 			pLandUnit->scrap();

	mov	ecx, edi
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 3457 : 			LogScrapUnit(pLandUnit, bInDeficit, bConquestGrandStrategy);

	mov	edx, DWORD PTR _bConquestGrandStrategy$[esp+72]
	mov	eax, DWORD PTR _bInDeficit$[esp+72]
	push	edx
	push	eax
	lea	edx, DWORD PTR _pLandUnit$[esp+80]

; 3458 : 		}
; 3459 : 	}

	jmp	SHORT $LN113@DisbandObs
$LN6@DisbandObs:

; 3460 : 	else if(iNavalScore < MAX_INT)

	cmp	DWORD PTR _iNavalScore$[esp+72], 2147483647 ; 7fffffffH
	jge	SHORT $LN1@DisbandObs

; 3461 : 	{
; 3462 : 		if(pNavalUnit)

	test	ebx, ebx
	je	SHORT $LN1@DisbandObs

; 3463 : 		{
; 3464 : 			pNavalUnit->scrap();

	mov	ecx, ebx
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 3465 : 			LogScrapUnit(pNavalUnit, bInDeficit, bConquestGrandStrategy);

	mov	eax, DWORD PTR _bConquestGrandStrategy$[esp+72]
	mov	ecx, DWORD PTR _bInDeficit$[esp+72]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _pNavalUnit$[esp+80]
$LN113@DisbandObs:
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T237980[esp+88], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, esi
	call	?LogScrapUnit@CvMilitaryAI@@AAEXV?$FObjectHandle@VCvUnit@@@@_N1@Z ; CvMilitaryAI::LogScrapUnit
$LN1@DisbandObs:

; 3466 : 		}
; 3467 : 	}
; 3468 : }

	mov	BYTE PTR __$EHRec$[esp+80], 0
	test	edi, edi
	je	SHORT $LN94@DisbandObs
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN94@DisbandObs:
	mov	DWORD PTR __$EHRec$[esp+80], -1
	test	ebx, ebx
	je	SHORT $LN99@DisbandObs
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN99@DisbandObs:
	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pNavalUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pLandUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR $T237977[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T237978[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::DisbandObsoleteUnits
PUBLIC	?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z ; CvMilitaryAI::WillAirUnitRebase
EXTRN	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z:PROC ; CvUnit::canLoadUnit
EXTRN	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canRebaseAt
EXTRN	?canAirSweep@CvUnit@@QBE_NXZ:PROC		; CvUnit::canAirSweep
EXTRN	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canAirPatrol
EXTRN	?getTransportUnit@CvUnit@@QAEPAV1@XZ:PROC	; CvUnit::getTransportUnit
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Ogtpy
;	COMDAT ?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
_bNeedsToMove$ = -13					; size = 1
_this$ = -12						; size = 4
_iLoopUnit$ = -8					; size = 4
_iLoopCity$ = -4					; size = 4
_pUnit$ = 8						; size = 4
?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z PROC ; CvMilitaryAI::WillAirUnitRebase, COMDAT
; _this$ = ecx

; 3658 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3659 : 	CvPlot* pUnitPlot = pUnit->plot();

	mov	edi, DWORD PTR _pUnit$[esp+28]
	mov	ebp, ecx
	mov	ecx, edi
	mov	DWORD PTR _this$[esp+32], ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebx, eax

; 3660 : 
; 3661 : 	CvPlot* pBestPlot = NULL;
; 3662 : 
; 3663 : 	// Is this unit in a base in danger?
; 3664 : 	bool bNeedsToMove = false;
; 3665 : 	if (pUnitPlot->isCity())

	mov	eax, DWORD PTR [ebx+104]
	mov	BYTE PTR _bNeedsToMove$[esp+32], 0
	test	eax, eax
	jl	$LN28@WillAirUni
	cmp	eax, 64					; 00000040H
	jge	$LN28@WillAirUni
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN28@WillAirUni

; 3666 : 	{
; 3667 : 		if (pUnitPlot->getPlotCity()->getDamage() > (pUnitPlot->getPlotCity()->GetMaxHitPoints() / 5))

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN36@WillAirUni
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN36@WillAirUni
	mov	edx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax
	jmp	SHORT $LN37@WillAirUni
$LN36@WillAirUni:
	xor	edi, edi
$LN37@WillAirUni:
	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN41@WillAirUni
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN41@WillAirUni
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN42@WillAirUni
$LN41@WillAirUni:
	xor	eax, eax
$LN42@WillAirUni:
	mov	ecx, eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	mov	ecx, edi
	add	esi, edx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage

; 3668 : 		{
; 3669 : 			bNeedsToMove = true;
; 3670 : 		}
; 3671 : 	}
; 3672 : 	else

	mov	edi, DWORD PTR _pUnit$[esp+28]
	cmp	eax, esi
	jmp	SHORT $LN72@WillAirUni
$LN28@WillAirUni:

; 3673 : 	{
; 3674 : 		CvUnit *pCarrier = pUnit->getTransportUnit();

	mov	ecx, edi
	call	?getTransportUnit@CvUnit@@QAEPAV1@XZ	; CvUnit::getTransportUnit

; 3675 : 		if (pCarrier)

	test	eax, eax
	je	SHORT $LN71@WillAirUni

; 3676 : 		{
; 3677 : 			if (pCarrier->getDamage() > (GC.getMAX_HIT_POINTS() / 5))

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	esi
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
$LN72@WillAirUni:
	jle	SHORT $LN71@WillAirUni

; 3678 : 			{
; 3679 : 				bNeedsToMove = true;

	mov	BYTE PTR _bNeedsToMove$[esp+32], 1
$LN71@WillAirUni:

; 3680 : 			}
; 3681 : 		}
; 3682 : 	}
; 3683 : 
; 3684 : 	// Is this a fighter that doesn't have any useful missions nearby
; 3685 : 	if (pUnit->canAirPatrol(NULL) || pUnit->canAirSweep())

	push	0
	mov	ecx, edi
	call	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirPatrol
	test	al, al
	jne	SHORT $LN22@WillAirUni
	mov	ecx, edi
	call	?canAirSweep@CvUnit@@QBE_NXZ		; CvUnit::canAirSweep
	test	al, al
	je	SHORT $LN21@WillAirUni
$LN22@WillAirUni:

; 3686 : 	{
; 3687 : 		int iNumNearbyEnemyAirUnits = GetNumEnemyAirUnitsInRange(pUnitPlot, pUnit->GetRange(), true /*bCountFighters*/, true /*bCountBombers*/);

	push	1
	push	1
	mov	ecx, edi
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	push	eax
	push	ebx
	mov	ecx, ebp
	call	?GetNumEnemyAirUnitsInRange@CvMilitaryAI@@QBEHPAVCvPlot@@H_N1@Z ; CvMilitaryAI::GetNumEnemyAirUnitsInRange

; 3688 : 		if (iNumNearbyEnemyAirUnits == 0 && !GetBestAirSweepTarget(pUnit))

	test	eax, eax
	jne	SHORT $LN21@WillAirUni
	push	edi
	mov	ecx, ebp
	call	?GetBestAirSweepTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAVCvUnit@@@Z ; CvMilitaryAI::GetBestAirSweepTarget
	test	eax, eax

; 3689 : 		{
; 3690 : 			bNeedsToMove = true;
; 3691 : 		}
; 3692 : 	}
; 3693 : 
; 3694 : 	if (!bNeedsToMove)

	je	SHORT $LN20@WillAirUni
$LN21@WillAirUni:
	cmp	BYTE PTR _bNeedsToMove$[esp+32], 0

; 3695 : 	{
; 3696 : 		return false;

	je	$LN3@WillAirUni
$LN20@WillAirUni:

; 3697 : 	}
; 3698 : 
; 3699 : 	// first look for open carrier slots in carriers within operations
; 3700 : 	int iLoopUnit = 0;
; 3701 : 	for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	ecx, DWORD PTR _iLoopUnit$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _iLoopUnit$[esp+40], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN17@WillAirUni
$LL19@WillAirUni:

; 3702 : 	{
; 3703 : 		CvPlot* pLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 3704 : 
; 3705 : 		if(pLoopUnit->getDamage() > (GC.getMAX_HIT_POINTS() / 5))  // this might not be a good place to land

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	mov	edi, eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ebp
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jg	SHORT $LN18@WillAirUni

; 3706 : 		{
; 3707 : 			continue;
; 3708 : 		}
; 3709 : 
; 3710 : 		if (pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN18@WillAirUni

; 3711 : 		{
; 3712 : 			continue;
; 3713 : 		}
; 3714 : 
; 3715 : 		if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pLoopUnitPlot->getX(),pLoopUnitPlot->getY()))

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	ebp, DWORD PTR _pUnit$[esp+28]
	push	eax
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	test	al, al
	je	SHORT $LN18@WillAirUni

; 3716 : 		{
; 3717 : 			continue;
; 3718 : 		}
; 3719 : 
; 3720 : 		if(!pUnit->canLoadUnit(*pLoopUnit, *pLoopUnitPlot))

	push	edi
	push	esi
	mov	ecx, ebp
	call	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z ; CvUnit::canLoadUnit
	test	al, al
	jne	$LN13@WillAirUni
$LN18@WillAirUni:

; 3697 : 	}
; 3698 : 
; 3699 : 	// first look for open carrier slots in carriers within operations
; 3700 : 	int iLoopUnit = 0;
; 3701 : 	for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	mov	edx, DWORD PTR _this$[esp+32]
	push	0
	lea	ecx, DWORD PTR _iLoopUnit$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL19@WillAirUni
	mov	ebp, DWORD PTR _this$[esp+32]
$LN17@WillAirUni:

; 3727 : 	}
; 3728 : 
; 3729 : 	// then look for open carrier slots in carriers NOT in operations
; 3730 : 	for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	eax, DWORD PTR _iLoopUnit$[esp+36]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN10@WillAirUni
$LL12@WillAirUni:

; 3731 : 	{
; 3732 : 		CvPlot* pLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 3733 : 
; 3734 : 		if(pLoopUnit->getDamage() > (GC.getMAX_HIT_POINTS() / 5))  // this might not be a good place to land

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	mov	edi, eax
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ebp
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jg	SHORT $LN11@WillAirUni

; 3735 : 		{
; 3736 : 			continue;
; 3737 : 		}
; 3738 : 
; 3739 : 		if (pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN11@WillAirUni

; 3740 : 		{
; 3741 : 			continue;
; 3742 : 		}
; 3743 : 
; 3744 : 		if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pLoopUnitPlot->getX(),pLoopUnitPlot->getY()))

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	ebp, DWORD PTR _pUnit$[esp+28]
	push	eax
	push	ecx
	push	ebx
	mov	ecx, ebp
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	test	al, al
	je	SHORT $LN11@WillAirUni

; 3745 : 		{
; 3746 : 			continue;
; 3747 : 		}
; 3748 : 
; 3749 : 		if(!pUnit->canLoadUnit(*pLoopUnit, *pLoopUnitPlot))

	push	edi
	push	esi
	mov	ecx, ebp
	call	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z ; CvUnit::canLoadUnit
	test	al, al
	jne	$LN13@WillAirUni
$LN11@WillAirUni:

; 3727 : 	}
; 3728 : 
; 3729 : 	// then look for open carrier slots in carriers NOT in operations
; 3730 : 	for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	mov	edx, DWORD PTR _this$[esp+32]
	push	0
	lea	ecx, DWORD PTR _iLoopUnit$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL12@WillAirUni

; 3697 : 	}
; 3698 : 
; 3699 : 	// first look for open carrier slots in carriers within operations
; 3700 : 	int iLoopUnit = 0;
; 3701 : 	for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	mov	ebp, DWORD PTR _this$[esp+32]
$LN10@WillAirUni:

; 3750 : 		{
; 3751 : 			continue;
; 3752 : 		}
; 3753 : 
; 3754 : 		// Found somewhere to rebase to
; 3755 : 		return true;
; 3756 : 	}
; 3757 : 
; 3758 : 	CvCity* pLoopCity;
; 3759 : 	int iLoopCity = 0;
; 3760 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	eax, DWORD PTR _iLoopCity$[esp+36]
	push	eax
	mov	DWORD PTR _iLoopCity$[esp+40], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN3@WillAirUni
$LL5@WillAirUni:

; 3761 : 	{
; 3762 : 		CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 3763 : 
; 3764 : #ifdef AUI_WARNING_FIXES
; 3765 : 		if (!pTarget)
; 3766 : 			continue;
; 3767 : #endif
; 3768 : 
; 3769 : 		if(pLoopCity->getDamage() > (pLoopCity->GetMaxHitPoints() / 5))

	mov	ecx, edi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	mov	ecx, edi
	add	esi, edx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	cmp	eax, esi
	jg	SHORT $LN4@WillAirUni

; 3770 : 		{
; 3771 : 			continue;
; 3772 : 		}
; 3773 : 
; 3774 : 		if (pTarget != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pTarget->getX(),pTarget->getY()))

	cmp	ebp, ebx
	je	SHORT $LN13@WillAirUni
	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[esp+36]
	push	ebx
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	test	al, al
	jne	SHORT $LN13@WillAirUni
$LN4@WillAirUni:

; 3750 : 		{
; 3751 : 			continue;
; 3752 : 		}
; 3753 : 
; 3754 : 		// Found somewhere to rebase to
; 3755 : 		return true;
; 3756 : 	}
; 3757 : 
; 3758 : 	CvCity* pLoopCity;
; 3759 : 	int iLoopCity = 0;
; 3760 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	edx, DWORD PTR _this$[esp+32]
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL5@WillAirUni
$LN3@WillAirUni:
	pop	edi
	pop	esi
	pop	ebp

; 3775 : 		{
; 3776 : 			continue;
; 3777 : 		}
; 3778 : 
; 3779 : 		// Found somewhere to rebase to
; 3780 : 		return true;
; 3781 : 	}
; 3782 : 
; 3783 : 	return false;

	xor	al, al
	pop	ebx

; 3784 : }

	add	esp, 16					; 00000010H
	ret	4
$LN13@WillAirUni:
	pop	edi
	pop	esi
	pop	ebp

; 3721 : 		{
; 3722 : 			continue;
; 3723 : 		}
; 3724 : 		
; 3725 : 		// Found somewhere to rebase to
; 3726 : 		return true;

	mov	al, 1
	pop	ebx

; 3784 : }

	add	esp, 16					; 00000010H
	ret	4
?WillAirUnitRebase@CvMilitaryAI@@QBE_NPAVCvUnit@@@Z ENDP ; CvMilitaryAI::WillAirUnitRebase
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ; CvWeightedVector<CvMilitaryTarget,640,1>::CvWeightedVector<CvMilitaryTarget,640,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::CvWeightedVector<CvMilitaryTarget,640,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 640			; 00000280H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::CvWeightedVector<CvMilitaryTarget,640,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ; CvWeightedVector<CvMilitaryTarget,640,1>::~CvWeightedVector<CvMilitaryTarget,640,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::~CvWeightedVector<CvMilitaryTarget,640,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE@XZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::~CvWeightedVector<CvMilitaryTarget,640,1>
_TEXT	ENDS
PUBLIC	?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z PROC ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	esi
	push	edi

; 409  : 		uiNum += m_uiCurrSize;

	mov	edi, DWORD PTR _uiNum$[esp+4]
	mov	esi, ecx
	add	edi, DWORD PTR [esi+4]

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN4@push_back_

; 411  : 			GrowSize(uiNum);

	push	edi
	call	?GrowSize@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@IAEXI@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	jae	SHORT $LN13@push_back_
	mov	edx, DWORD PTR _element$[esp+4]
	push	ebx
$LL3@push_back_:
	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 413  : 			new( (void*)&m_pData[i] )T(element);

	test	ecx, ecx
	je	SHORT $LN2@push_back_
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
$LN2@push_back_:
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL3@push_back_
	pop	ebx
$LN13@push_back_:

; 414  : 		}
; 415  : 		m_uiCurrSize = uiNum;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 416  : 	};

	ret	8
?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z ENDP ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z PROC ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+172], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEIABVCvFormationSlotEntry@@@Z ENDP ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+17932], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR _func$[esp-4]
	mov	edx, DWORD PTR _x$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx

; 2032 : }

	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__Plast$ = -32						; size = 4
__Tmp$238726 = -28					; size = 28
__Tmp$238685 = -28					; size = 28
__Tmp$238705 = -28					; size = 28
__Tmp$238664 = -28					; size = 28
__Tmp$238643 = -28					; size = 28
__Tmp$238619 = -28					; size = 28
__Tmp$238591 = -28					; size = 28
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 32					; 00000020H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+36]
	mov	ecx, ebp
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	edx, DWORD PTR [ebp-28]
	push	edx
	lea	edi, DWORD PTR [ebx+ecx*4]
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Median<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;
; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+28]
	mov	edx, edi
	mov	DWORD PTR __Plast$[esp+48], esi

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [edx-4]
	cmp	eax, ecx
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	edx, 28					; 0000001cH
	cmp	ebx, edx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	ecx, DWORD PTR [edx+24]
	npad	4
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+24]
	cmp	ecx, eax
	jl	SHORT $LN115@Unguarded_
	jg	SHORT $LN115@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 28					; 0000001cH
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN115@Unguarded_:
	mov	DWORD PTR __Plast$[esp+48], esi
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebp, edx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+44]
	jae	SHORT $LN103@Unguarded_
	npad	2
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	ecx, DWORD PTR [eax+24]
	mov	edi, DWORD PTR [edx+24]
	cmp	ecx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edi, esi
	add	esi, 28					; 0000001cH
	mov	DWORD PTR __Plast$[esp+48], esi
	cmp	edi, eax
	je	SHORT $LN20@Unguarded_
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$238591[esp+48], ecx
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$238591[esp+52], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __Tmp$238591[esp+56], ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$238591[esp+60], ecx
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __Tmp$238591[esp+64], ecx
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR __Tmp$238591[esp+68], ecx
	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR __Tmp$238591[esp+72], ecx
	mov	ecx, 7
	mov	esi, eax
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238591[esp+48]
	mov	edi, eax
	rep movsd
	mov	esi, DWORD PTR __Plast$[esp+48]
$LN20@Unguarded_:
	add	eax, 28					; 0000001cH
	cmp	eax, DWORD PTR __Last$[esp+44]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebp, DWORD PTR __First$[esp+44]
	jbe	SHORT $LN116@Unguarded_
	lea	ebx, DWORD PTR [ebp-28]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	ecx, DWORD PTR [ebx+24]
	mov	edi, DWORD PTR [edx+24]
	cmp	edi, ecx
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN112@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	edx, 28					; 0000001cH
	cmp	edx, ebx
	je	SHORT $LN13@Unguarded_
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$238619[esp+48], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$238619[esp+52], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$238619[esp+56], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$238619[esp+60], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$238619[esp+64], ecx
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$238619[esp+68], ecx
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Tmp$238619[esp+72], ecx
	mov	ecx, 7
	mov	esi, ebx
	mov	edi, edx
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238619[esp+48]
	mov	edi, ebx
	rep movsd
	mov	esi, DWORD PTR __Plast$[esp+48]
$LN13@Unguarded_:
	sub	ebp, 28					; 0000001cH
	sub	ebx, 28					; 0000001cH
	cmp	DWORD PTR __First$[esp+44], ebp
	jb	SHORT $LL14@Unguarded_
$LN112@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebp, DWORD PTR __First$[esp+44]
$LN116@Unguarded_:
	jne	$LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+44]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	edx, esi
	je	SHORT $LN64@Unguarded_
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$238643[esp+48], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$238643[esp+52], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$238643[esp+56], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$238643[esp+60], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$238643[esp+64], ecx
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$238643[esp+68], ecx
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Tmp$238643[esp+72], ecx
	mov	ecx, 7
	mov	edi, edx
	rep movsd
	mov	edi, DWORD PTR __Plast$[esp+48]
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238643[esp+48]
	rep movsd
	mov	esi, DWORD PTR __Plast$[esp+48]
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	ebx, eax
	mov	edi, edx
	add	esi, 28					; 0000001cH
	add	edx, 28					; 0000001cH
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Plast$[esp+48], esi
	cmp	edi, ebx
	je	$LL23@Unguarded_
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$238664[esp+48], ecx
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$238664[esp+52], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __Tmp$238664[esp+56], ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR __Tmp$238664[esp+60], ecx
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __Tmp$238664[esp+64], ecx
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR __Tmp$238664[esp+68], ecx
	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR __Tmp$238664[esp+72], ecx
	mov	ecx, 7
	mov	esi, ebx
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238664[esp+48]
	mov	edi, ebx
	rep movsd
	mov	esi, DWORD PTR __Plast$[esp+48]
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebp, 28					; 0000001cH
	cmp	eax, DWORD PTR __Last$[esp+44]
	jne	$LN3@Unguarded_
	sub	edx, 28					; 0000001cH
	cmp	ebp, edx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR __Tmp$238685[esp+48], ecx
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR __Tmp$238685[esp+52], ecx
	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR __Tmp$238685[esp+56], ecx
	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR __Tmp$238685[esp+60], ecx
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR __Tmp$238685[esp+64], ecx
	mov	ecx, DWORD PTR [ebp+20]
	mov	DWORD PTR __Tmp$238685[esp+68], ecx
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR __Tmp$238685[esp+72], ecx
	mov	ecx, 7
	mov	esi, edx
	mov	edi, ebp
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238685[esp+48]
	mov	edi, edx
	rep movsd
	mov	esi, DWORD PTR __Plast$[esp+48]
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 28					; 0000001cH
	mov	DWORD PTR __Plast$[esp+48], esi
	cmp	edx, esi
	je	$LL23@Unguarded_
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$238705[esp+48], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$238705[esp+52], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$238705[esp+56], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$238705[esp+60], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$238705[esp+64], ecx
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$238705[esp+68], ecx
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Tmp$238705[esp+72], ecx
	mov	ecx, 7
	mov	edi, edx
	rep movsd
	mov	edi, DWORD PTR __Plast$[esp+48]
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238705[esp+48]
	rep movsd

; 3073 : 			}
; 3074 : 		else

	mov	esi, DWORD PTR __Plast$[esp+48]
	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebp
	je	SHORT $LN92@Unguarded_
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$238726[esp+48], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$238726[esp+52], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$238726[esp+56], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$238726[esp+60], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$238726[esp+64], ecx
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$238726[esp+68], ecx
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Tmp$238726[esp+72], ecx
	mov	ecx, 7
	mov	esi, ebp
	mov	edi, eax
	rep movsd
	mov	ecx, 7
	lea	esi, DWORD PTR __Tmp$238726[esp+48]
	mov	edi, ebp
	rep movsd
	mov	esi, DWORD PTR __Plast$[esp+48]
$LN92@Unguarded_:
	add	eax, 28					; 0000001cH

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+44]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	pop	ebx

; 3077 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 2177 : 	{	// make [_First, _Last) into a heap, using operator<

	push	esi

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	esi
	push	edi
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:
	pop	edi
	pop	esi

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 2094 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	esi

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jle	SHORT $LN6@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	edx, DWORD PTR [esi-28]
	lea	eax, DWORD PTR [esi-28]
	push	0
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR [eax+20]
	push	eax
	mov	DWORD PTR [ecx+20], edx
	mov	edx, DWORD PTR [eax+24]
	push	eax
	push	edi
	mov	DWORD PTR [ecx+24], edx
	call	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 44					; 0000002cH
$LN6@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity
EXTRN	?getThreatValue@CvCity@@QAEHXZ:PROC		; CvCity::getThreatValue
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z$0
__ehfuncinfo$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
_TEXT	SEGMENT
_iHighestThreatValue$227154 = -40			; size = 4
_iLoopCity$227156 = -36					; size = 4
_iCycle$227149 = -32					; size = 4
$T238790 = -32						; size = 4
_this$ = -28						; size = 4
_m_apCities$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
_iOrder$ = 8						; size = 4
?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z PROC ; CvMilitaryAI::GetMostThreatenedCity, COMDAT
; _this$ = ecx

; 1638 : {

	push	-1
	push	__ehhandler$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp

; 1639 : 	// slewis - this is slow, but I did it quickly!
; 1640 : 
; 1641 : 	FFastVector<CvCity*> m_apCities;

	xor	ebp, ebp
	mov	ebx, ecx
	push	esi
	mov	DWORD PTR _this$[esp+52], ebx
	mov	DWORD PTR _m_apCities$[esp+56], ebp
	mov	DWORD PTR _m_apCities$[esp+60], ebp
	mov	DWORD PTR _m_apCities$[esp+52], ebp

; 1642 : 	m_apCities.push_back_copy(NULL, iOrder + 1);

	mov	esi, DWORD PTR _iOrder$[esp+48]
	inc	esi
	push	esi
	lea	eax, DWORD PTR $T238790[esp+56]
	push	eax
	lea	ecx, DWORD PTR _m_apCities$[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], ebp
	mov	DWORD PTR $T238790[esp+60], ebp
	call	?push_back_copy@?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAEXABQAVCvCity@@I@Z ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::push_back_copy

; 1643 : 
; 1644 : 	for(int iCycle = 0; iCycle < iOrder + 1; iCycle++)

	cmp	esi, ebp
	mov	DWORD PTR _iCycle$227149[esp+52], ebp
	jle	$LN64@GetMostThr
	push	edi
	jmp	SHORT $LN15@GetMostThr
	npad	6
$LL65@GetMostThr:
	xor	ebp, ebp
$LN15@GetMostThr:

; 1645 : 	{
; 1646 : 		CvCity* pCity = NULL;
; 1647 : 		int iHighestThreatValue = 0;
; 1648 : 
; 1649 : 		CvCity* pLoopCity;
; 1650 : 		int iLoopCity = 0;
; 1651 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	ebp
	lea	ecx, DWORD PTR _iLoopCity$227156[esp+60]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _iHighestThreatValue$227154[esp+64], ebp
	mov	DWORD PTR _iLoopCity$227156[esp+64], ebp
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	$LN68@GetMostThr
$LL12@GetMostThr:

; 1652 : 		{
; 1653 : 			bool bCityAlreadyExamined = false;
; 1654 : 			for(uint ui = 0; ui < m_apCities.size(); ui++)

	mov	ecx, DWORD PTR _m_apCities$[esp+60]
	xor	eax, eax
	test	ecx, ecx
	jbe	SHORT $LN62@GetMostThr
	npad	5
$LL9@GetMostThr:

; 1655 : 			{
; 1656 : 				if(pLoopCity == m_apCities[ui])

	mov	edx, DWORD PTR _m_apCities$[esp+56]
	cmp	edi, DWORD PTR [edx+eax*4]
	je	SHORT $LN11@GetMostThr
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL9@GetMostThr
$LN62@GetMostThr:

; 1657 : 				{
; 1658 : 					bCityAlreadyExamined = true;
; 1659 : 					break;
; 1660 : 				}
; 1661 : 			}
; 1662 : 			if(bCityAlreadyExamined)
; 1663 : 			{
; 1664 : 				continue;
; 1665 : 			}
; 1666 : 
; 1667 : 			int iThreatValue = pLoopCity->getThreatValue();

	mov	ecx, edi
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue

; 1668 : 			iThreatValue = iThreatValue * pLoopCity->getPopulation();

	mov	ecx, edi
	mov	ebx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	esi, eax

; 1669 : 
; 1670 : 			if(pLoopCity->isCapital())

	mov	ecx, edi
	imul	esi, ebx
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN4@GetMostThr

; 1671 : 			{
; 1672 : 				iThreatValue = (iThreatValue * GC.getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL()) / 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2188
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN4@GetMostThr:

; 1673 : 			}
; 1674 : 
; 1675 : 			if(iThreatValue > iHighestThreatValue)

	cmp	esi, DWORD PTR _iHighestThreatValue$227154[esp+56]
	jle	SHORT $LN11@GetMostThr

; 1676 : 			{
; 1677 : 				pCity = pLoopCity;

	mov	ebp, edi

; 1678 : 				iHighestThreatValue = iThreatValue;

	mov	DWORD PTR _iHighestThreatValue$227154[esp+56], esi
$LN11@GetMostThr:
	mov	ebx, DWORD PTR _this$[esp+56]
	push	0
	lea	ecx, DWORD PTR _iLoopCity$227156[esp+60]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL12@GetMostThr

; 1679 : 			}
; 1680 : 		}
; 1681 : 
; 1682 : 		if(pCity)

	test	ebp, ebp
	je	SHORT $LN68@GetMostThr

; 1683 : 		{
; 1684 : 			m_apCities[iCycle] = pCity;

	mov	ecx, DWORD PTR _iCycle$227149[esp+56]
	mov	edx, DWORD PTR _m_apCities$[esp+56]
	mov	eax, DWORD PTR _iOrder$[esp+52]
	mov	DWORD PTR [edx+ecx*4], ebp
	inc	ecx
	inc	eax
	cmp	ecx, eax
	mov	DWORD PTR _iCycle$227149[esp+56], ecx
	jl	$LL65@GetMostThr
$LN68@GetMostThr:
	pop	edi
$LN64@GetMostThr:

; 1685 : 		}
; 1686 : 		else
; 1687 : 		{
; 1688 : 			// we didn't find a city, so bail
; 1689 : 			break;
; 1690 : 		}
; 1691 : 	}
; 1692 : 
; 1693 : 	return m_apCities[iOrder];

	mov	eax, DWORD PTR _m_apCities$[esp+52]
	mov	ecx, DWORD PTR _iOrder$[esp+48]
	mov	esi, DWORD PTR [eax+ecx*4]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 1694 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	add	esp, 4
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z$0:
	lea	ecx, DWORD PTR _m_apCities$[ebp]
	jmp	??1?$FFastVector@PAVCvCity@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvCity@@$0A@@@@@QAE@XZ ; FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvCity *,0,0,0,BaseVector<CvCity *,0>::FDefaultFastVectorAllocator>
__ehhandler$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ENDP ; CvMilitaryAI::GetMostThreatenedCity
PUBLIC	?UpdateWars@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateWars
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateWars@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
?UpdateWars@CvMilitaryAI@@AAEXXZ PROC			; CvMilitaryAI::UpdateWars, COMDAT
; _this$ = ecx

; 2390 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 2391 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateWars, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2392 : 
; 2393 : 	WarStateTypes eWarState;
; 2394 : 
; 2395 : 	PlayerTypes eLoopPlayer;
; 2396 : 	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	esi, esi
$LL5@UpdateWars:

; 2397 : 	{
; 2398 : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 2399 : 
; 2400 : 		// Is this a player we have relations with?
; 2401 : 		if(eLoopPlayer != m_pPlayer->GetID() && m_pDiplomacyAI->IsPlayerValid(eLoopPlayer))

	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+44]
	je	SHORT $LN4@UpdateWars
	mov	ecx, DWORD PTR [edi+4]
	push	0
	push	esi
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN4@UpdateWars

; 2402 : 		{
; 2403 : 			eWarState = m_pDiplomacyAI->GetWarState(eLoopPlayer);

	mov	ecx, DWORD PTR [edi+4]
	push	esi
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState

; 2404 : 			if(eWarState != m_paeLastTurnWarState[eLoopPlayer])

	mov	ecx, DWORD PTR [edi+24]
	mov	ebx, eax
	mov	eax, DWORD PTR [ecx+esi*4]
	cmp	ebx, eax
	je	SHORT $LN4@UpdateWars

; 2405 : 			{
; 2406 : 				WarStateChange(eLoopPlayer, eWarState, (WarStateTypes)m_paeLastTurnWarState[eLoopPlayer]);

	push	eax
	push	ebx
	push	esi
	mov	ecx, edi
	call	?LogWarStateChange@CvMilitaryAI@@AAEXW4PlayerTypes@@W4WarStateTypes@@1@Z ; CvMilitaryAI::LogWarStateChange

; 2407 : 
; 2408 : 				// Save off new value
; 2409 : 				m_paeLastTurnWarState[eLoopPlayer] = eWarState;

	mov	edx, DWORD PTR [edi+24]
	mov	DWORD PTR [edx+esi*4], ebx
$LN4@UpdateWars:
	inc	esi
	cmp	esi, 22					; 00000016H
	jl	SHORT $LL5@UpdateWars
	pop	edi
	pop	esi
	pop	ebx

; 2410 : 			}
; 2411 : 		}
; 2412 : 	}
; 2413 : }

	ret	0
?UpdateWars@CvMilitaryAI@@AAEXXZ ENDP			; CvMilitaryAI::UpdateWars
_TEXT	ENDS
PUBLIC	?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::LogMilitaryStatus
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$7
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_strTemp$228248 = -208					; size = 28
_strOutBuf$228246 = -180				; size = 28
_playerName$228249 = -152				; size = 28
$T238926 = -124						; size = 28
$T238925 = -124						; size = 28
$T238924 = -124						; size = 28
_strBaseString$228247 = -96				; size = 28
_cityName$228251 = -68					; size = 28
$T238923 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::LogMilitaryStatus, COMDAT
; _this$ = ecx

; 4010 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	esi
	mov	esi, ecx

; 4011 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@LogMilitar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@LogMilitar@2
	push	ebx
	push	edi

; 4012 : 	{
; 4013 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228246[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4014 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$228247[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4015 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228248[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4016 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$228249[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4017 : 		CvCity* pCity;
; 4018 : 		CvString cityName;

	lea	ecx, DWORD PTR _cityName$228251[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4019 : 		FILogFile* pLog;
; 4020 : 
; 4021 : 		// Open the right file
; 4022 : 		playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$228249[esp+220]
	test	eax, eax
	je	SHORT $LN33@LogMilitar@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN32@LogMilitar@2
$LN33@LogMilitar@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN32@LogMilitar@2:

; 4023 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edi, eax
	push	0
	lea	eax, DWORD PTR _playerName$228249[esp+224]
	push	eax
	lea	ecx, DWORD PTR $T238923[esp+228]
	push	ecx
	mov	ecx, esi
	call	?GetLogFileName@CvMilitaryAI@@ABE?AVCvString@@AAV2@_N@Z ; CvMilitaryAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T238923[esp+220]
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4024 : 
; 4025 : 		// Very first update (to write header row?)
; 4026 : 		if(GC.getGame().getGameTurn() == 1 && m_pPlayer->GetID() == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 1
	jne	SHORT $LN2@LogMilitar@2
	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN2@LogMilitar@2

; 4027 : 		{
; 4028 : 			strTemp.Format("Turn, Player, Cities, Settlers, Civ Threat, Barb Threat, Land Units, Land In Armies, Rec Land Size, Land Reserve, Naval Units, Naval In Armies, Rec Naval Size, Most Threatened, Danger");

	lea	edx, DWORD PTR _strTemp$228248[esp+220]
	push	OFFSET $SG228255
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4029 : 			pLog->Msg(strTemp);

	lea	ecx, DWORD PTR _strTemp$228248[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8
$LN2@LogMilitar@2:

; 4030 : 		}
; 4031 : 
; 4032 : 		// Get the leading info for this line
; 4033 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	eax, DWORD PTR _strBaseString$228247[esp+224]
	push	OFFSET $SG228256
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4034 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG228258
	lea	ecx, DWORD PTR _playerName$228249[esp+236]
	push	ecx
	lea	edx, DWORD PTR $T238924[esp+240]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228247[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238924[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4035 : 
; 4036 : 		// City info
; 4037 : 		strTemp.Format("%d, %d, ", m_pPlayer->getNumCities(), m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true));

	mov	ecx, DWORD PTR [esi]
	push	1
	push	1
	push	1
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	push	eax
	lea	eax, DWORD PTR _strTemp$228248[esp+228]
	push	OFFSET $SG228259
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4038 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$228248[esp+236]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$228247[esp+240]
	push	edx
	lea	eax, DWORD PTR $T238925[esp+244]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228246[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T238925[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4039 : 
; 4040 : 		//Threat Info
; 4041 : 		strTemp.Format("%d, %d, ", m_iTotalThreatWeight, GetBarbarianThreatTotal());

	mov	ecx, esi
	call	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::ScanForBarbarians
	mov	eax, DWORD PTR [esi+92]
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2192
	mov	ecx, DWORD PTR [esi+88]
	imul	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	mov	edx, DWORD PTR [esi+40]
	add	eax, ecx
	push	eax
	push	edx
	lea	eax, DWORD PTR _strTemp$228248[esp+228]
	push	OFFSET $SG228261
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4042 : 		strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$228248[esp+220]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$228246[esp+224]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4043 : 
; 4044 : 		// Military size Info
; 4045 : 		int iNavalSize = MilitaryAIHelpers::ComputeRecommendedNavySize(m_pPlayer);

	mov	edx, DWORD PTR [esi]
	push	edx
	call	?ComputeRecommendedNavySize@MilitaryAIHelpers@@YAHPAVCvPlayer@@@Z ; MilitaryAIHelpers::ComputeRecommendedNavySize

; 4046 : 		strTemp.Format("%d, %d, %d, %d, %d, %d, %d, ", m_iNumLandUnits, m_iNumLandUnitsInArmies, m_iRecommendedMilitarySize, m_iMandatoryReserveSize, m_iNumNavalUnits, m_iNumNavalUnitsInArmies, iNavalSize);

	mov	ecx, DWORD PTR [esi+68]
	push	eax
	mov	eax, DWORD PTR [esi+76]
	push	eax
	push	ecx
	mov	edx, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+72]
	push	edx
	mov	edx, DWORD PTR [esi+52]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strTemp$228248[esp+252]
	push	OFFSET $SG228263
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 40					; 00000028H

; 4047 : 		strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$228248[esp+220]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$228246[esp+224]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4048 : 
; 4049 : 		// Most threatened city
; 4050 : 		pCity = GetMostThreatenedCity();

	push	0
	mov	ecx, esi
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity
	mov	esi, eax

; 4051 : 		if(pCity != NULL)

	test	esi, esi
	je	SHORT $LN1@LogMilitar@2

; 4052 : 		{
; 4053 : 			cityName = pCity->getName();

	lea	edx, DWORD PTR $T238926[esp+220]
	push	edx
	mov	ecx, esi
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _cityName$228251[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 8
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238926[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4054 : 			strOutBuf += cityName;

	lea	eax, DWORD PTR _cityName$228251[esp+220]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228246[esp+224]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 4055 : 			strTemp.Format(", %d", pCity->getThreatValue());

	mov	ecx, esi
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	push	eax
	lea	ecx, DWORD PTR _strTemp$228248[esp+224]
	push	OFFSET $SG228266
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 4056 : 			strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$228248[esp+220]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$228246[esp+224]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN1@LogMilitar@2:

; 4057 : 		}
; 4058 : 
; 4059 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228246[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8

; 4060 : 	}

	lea	ecx, DWORD PTR _cityName$228251[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$228249[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228248[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$228247[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$228246[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebx
$LN3@LogMilitar@2:

; 4061 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$228246[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$228247[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$228248[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$228249[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _cityName$228251[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T238923[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T238924[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T238925[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T238926[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::LogMilitaryStatus
PUBLIC	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ:PROC	; CvUnit::canRecruitFromTacticalAI
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ:PROC ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
EXTRN	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z:PROC ; CvMultiUnitFormationInfo::getFormationSlotEntry
EXTRN	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ:PROC ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
EXTRN	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z:PROC ; CvGlobals::getMultiUnitFormationInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z$0
__ehfuncinfo$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
_TEXT	SEGMENT
_bMustBeDeepWaterNaval$ = -217				; size = 1
_iLandReservesUsed$ = -216				; size = 4
_iWillBeFilled$ = -212					; size = 4
_iLoop$ = -208						; size = 4
_slotEntry$228933 = -204				; size = 16
_slotsToFill$ = -188					; size = 176
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
_formation$ = 12					; size = 4
_bRequiresNavalMoves$ = 16				; size = 1
_piNumberSlotsRequired$ = 20				; size = 4
_piNumberLandReservesUsed$ = 24				; size = 4
?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z PROC ; MilitaryAIHelpers::NumberOfFillableSlots, COMDAT

; 4853 : {

	push	-1
	push	__ehhandler$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4854 : 	CvUnit* pLoopUnit;
; 4855 : 	int iLoop;
; 4856 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL > slotsToFill;

	xor	edi, edi
	lea	eax, DWORD PTR _slotsToFill$[esp+248]
	mov	DWORD PTR _slotsToFill$[esp+240], edi
	mov	DWORD PTR _slotsToFill$[esp+244], 10	; 0000000aH
	mov	DWORD PTR _slotsToFill$[esp+236], eax

; 4857 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL >::iterator it;
; 4858 : 	int iWillBeFilled = 0;
; 4859 : 	int iLandReservesUsed = 0;
; 4860 : 
; 4861 : 	CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(formation);

	mov	ecx, DWORD PTR _formation$[esp+232]
	push	ecx
	xor	ebp, ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+248], edi
	mov	DWORD PTR _iWillBeFilled$[esp+240], ebp
	mov	DWORD PTR _iLandReservesUsed$[esp+240], edi
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	ebx, eax

; 4862 : 	for(int iThisSlotIndex = 0; iThisSlotIndex < thisFormation->getNumFormationSlotEntries(); iThisSlotIndex++)

	mov	ecx, ebx
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	test	eax, eax
	jle	SHORT $LN24@NumberOfFi
$LL26@NumberOfFi:

; 4863 : 	{
; 4864 : 		const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(iThisSlotIndex);

	push	edi
	mov	ecx, ebx
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
	mov	esi, eax

; 4865 : 		slotsToFill.push_back(thisSlotEntry);

	mov	eax, DWORD PTR _slotsToFill$[esp+244]
	mov	BYTE PTR _slotsToFill$[esp+408], 0
	cmp	DWORD PTR _slotsToFill$[esp+240], eax
	jne	SHORT $LN40@NumberOfFi
	push	eax
	lea	ecx, DWORD PTR _slotsToFill$[esp+240]
	call	?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize
$LN40@NumberOfFi:
	mov	eax, DWORD PTR _slotsToFill$[esp+240]
	shl	eax, 4
	add	eax, DWORD PTR _slotsToFill$[esp+236]
	je	SHORT $LN43@NumberOfFi
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], ecx
$LN43@NumberOfFi:
	inc	DWORD PTR _slotsToFill$[esp+240]
	mov	ecx, ebx
	inc	edi
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cmp	edi, eax
	jl	SHORT $LL26@NumberOfFi
$LN24@NumberOfFi:

; 4866 : 	}
; 4867 : 
; 4868 : 	bool bMustBeDeepWaterNaval = GET_TEAM(pPlayer->getTeam()).canEmbarkAllWaterPassage() && thisFormation->IsRequiresNavalUnitConsistency();

	mov	esi, DWORD PTR _pPlayer$[esp+232]
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN51@NumberOfFi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN52@NumberOfFi
$LN51@NumberOfFi:
	or	eax, -1
$LN52@NumberOfFi:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	test	al, al
	je	SHORT $LN29@NumberOfFi
	mov	ecx, ebx
	call	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
	mov	BYTE PTR _bMustBeDeepWaterNaval$[esp+236], 1
	test	al, al
	jne	SHORT $LN30@NumberOfFi
$LN29@NumberOfFi:
	mov	BYTE PTR _bMustBeDeepWaterNaval$[esp+236], 0
$LN30@NumberOfFi:

; 4869 : 
; 4870 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+240]
	push	edx
	mov	ecx, esi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	$LN21@NumberOfFi
$LL23@NumberOfFi:

; 4871 : 	{
; 4872 : 		// Don't count scouts
; 4873 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN22@NumberOfFi
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN22@NumberOfFi

; 4874 : 		{
; 4875 : 			// Don't count units that are damaged too heavily
; 4876 : 			if(pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	ecx, edi
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	mov	ecx, edi
	add	esi, edx
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, esi
	jl	$LN22@NumberOfFi

; 4877 : 			{
; 4878 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX && pLoopUnit->canRecruitFromTacticalAI())

	mov	ecx, edi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN22@NumberOfFi
	mov	ecx, edi
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	test	al, al
	je	$LN22@NumberOfFi

; 4879 : 				{
; 4880 : 					if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+124]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebx, esi
	cmp	ebx, eax
	jge	$LN22@NumberOfFi

; 4881 : 					{
; 4882 : 						if(!bRequiresNavalMoves || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	cmp	BYTE PTR _bRequiresNavalMoves$[esp+232], 0
	je	SHORT $LN15@NumberOfFi
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN15@NumberOfFi
	mov	ecx, edi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	$LN22@NumberOfFi
$LN15@NumberOfFi:

; 4883 : 						{
; 4884 : 							if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	cmp	BYTE PTR _bMustBeDeepWaterNaval$[esp+236], 0
	je	SHORT $LN13@NumberOfFi
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN13@NumberOfFi
	mov	eax, DWORD PTR [edi+1996]
	cmp	DWORD PTR [eax+24], 0
	jg	$LN22@NumberOfFi
$LN13@NumberOfFi:

; 4885 : 							{
; 4886 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 4887 : 								for (it = slotsToFill.begin(); it != slotsToFill.end(); ++it)
; 4888 : #else
; 4889 : 								for(it = slotsToFill.begin(); it != slotsToFill.end(); it++)

	mov	ecx, DWORD PTR _slotsToFill$[esp+240]
	mov	esi, DWORD PTR _slotsToFill$[esp+236]
	shl	ecx, 4
	add	ecx, esi
	cmp	esi, ecx
	je	SHORT $LN22@NumberOfFi
	npad	8
$LL12@NumberOfFi:

; 4890 : #endif
; 4891 : 								{
; 4892 : 									CvFormationSlotEntry slotEntry = *it;

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _slotEntry$228933[esp+248], ecx

; 4893 : 									CvUnitEntry& kUnitInfo = pLoopUnit->getUnitInfo();

	mov	ecx, edi
	mov	DWORD PTR _slotEntry$228933[esp+240], edx
	mov	DWORD PTR _slotEntry$228933[esp+244], eax
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ebp, eax

; 4894 : 									if(kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_primaryUnitType) ||
; 4895 : 										kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_secondaryUnitType))

	push	ebx
	mov	ecx, ebp
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	jne	SHORT $LN101@NumberOfFi
	mov	edx, DWORD PTR _slotEntry$228933[esp+240]
	push	edx
	mov	ecx, ebp
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	jne	SHORT $LN101@NumberOfFi
	mov	eax, DWORD PTR _slotsToFill$[esp+240]
	shl	eax, 4
	add	eax, DWORD PTR _slotsToFill$[esp+236]
	add	esi, 16					; 00000010H
	cmp	esi, eax
	jne	SHORT $LL12@NumberOfFi
	jmp	SHORT $LN22@NumberOfFi
$LN101@NumberOfFi:

; 4896 : 									{
; 4897 : 										slotsToFill.erase(it);

	push	esi
	lea	ecx, DWORD PTR _slotsToFill$[esp+240]
	call	?erase@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEXPAVCvFormationSlotEntry@@@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::erase

; 4898 : 										iWillBeFilled++;

	mov	esi, 1
	add	DWORD PTR _iWillBeFilled$[esp+236], esi

; 4899 : 
; 4900 : 										if(pLoopUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN22@NumberOfFi

; 4901 : 										{
; 4902 : 											iLandReservesUsed++;

	add	DWORD PTR _iLandReservesUsed$[esp+236], esi
$LN22@NumberOfFi:

; 4869 : 
; 4870 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+240]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[esp+240]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	$LL23@NumberOfFi
	mov	ebp, DWORD PTR _iWillBeFilled$[esp+236]
$LN21@NumberOfFi:

; 4903 : 										}
; 4904 : 										break;
; 4905 : 									}
; 4906 : 								}
; 4907 : 							}
; 4908 : 						}
; 4909 : 					}
; 4910 : 				}
; 4911 : 			}
; 4912 : 		}
; 4913 : 	}
; 4914 : 
; 4915 : 	// Now go back through remaining slots and see how many were required, we'll need that many more units
; 4916 : 	if(piNumberSlotsRequired != NULL)

	mov	edx, DWORD PTR _piNumberSlotsRequired$[esp+232]
	mov	esi, DWORD PTR _slotsToFill$[esp+236]
	test	edx, edx
	je	SHORT $LN3@NumberOfFi

; 4919 : 		for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	mov	ecx, DWORD PTR _slotsToFill$[esp+240]
	mov	DWORD PTR [edx], ebp
	test	ecx, ecx
	jle	SHORT $LN3@NumberOfFi

; 4917 : 	{
; 4918 : 		(*piNumberSlotsRequired) = iWillBeFilled;

	lea	eax, DWORD PTR [esi+12]
$LL5@NumberOfFi:

; 4920 : 		{
; 4921 : 			if(slotsToFill[iThisSlotIndex].m_requiredSlot)

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN4@NumberOfFi

; 4922 : 			{
; 4923 : 				(*piNumberSlotsRequired)++;

	inc	DWORD PTR [edx]
$LN4@NumberOfFi:

; 4919 : 		for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	add	eax, 16					; 00000010H
	sub	ecx, 1
	jne	SHORT $LL5@NumberOfFi
$LN3@NumberOfFi:

; 4924 : 			}
; 4925 : 		}
; 4926 : 	}
; 4927 : 
; 4928 : 	if(piNumberLandReservesUsed != NULL)

	mov	eax, DWORD PTR _piNumberLandReservesUsed$[esp+232]
	test	eax, eax
	je	SHORT $LN1@NumberOfFi

; 4929 : 	{
; 4930 : 		*piNumberLandReservesUsed = iLandReservesUsed;

	mov	edx, DWORD PTR _iLandReservesUsed$[esp+236]
	mov	DWORD PTR [eax], edx
$LN1@NumberOfFi:

; 4931 : 	}
; 4932 : 	return iWillBeFilled;

	lea	eax, DWORD PTR _slotsToFill$[esp+248]
	mov	DWORD PTR __$EHRec$[esp+244], -1
	cmp	esi, eax
	je	SHORT $LN107@NumberOfFi
	push	esi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN107@NumberOfFi:

; 4933 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+236]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 220				; 000000dcH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z$0:
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	jmp	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
__ehhandler$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z:
	mov	eax, OFFSET __ehfuncinfo$?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ENDP ; MilitaryAIHelpers::NumberOfFillableSlots
PUBLIC	?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ; MilitaryAIHelpers::FirstSlotCityCanFill
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z$0
__ehfuncinfo$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
_TEXT	SEGMENT
_bMustBeDeepWaterNaval$ = -209				; size = 1
_iLoop$ = -208						; size = 4
_slotEntry$228983 = -204				; size = 16
_slotsToFill$ = -188					; size = 176
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
_formation$ = 12					; size = 4
_bRequiresNavalMoves$ = 16				; size = 1
_bAtCoastalCity$ = 20					; size = 1
_bSecondaryUnit$ = 24					; size = 1
?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z PROC ; MilitaryAIHelpers::FirstSlotCityCanFill, COMDAT

; 4937 : {

	push	-1
	push	__ehhandler$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi

; 4938 : 	CvUnit* pLoopUnit;
; 4939 : 	int iLoop;
; 4940 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL > slotsToFill;

	lea	eax, DWORD PTR _slotsToFill$[esp+232]
	push	edi
	mov	DWORD PTR _slotsToFill$[esp+228], 0
	mov	DWORD PTR _slotsToFill$[esp+232], 10	; 0000000aH
	mov	DWORD PTR _slotsToFill$[esp+224], eax

; 4941 : 	FStaticVector< CvFormationSlotEntry, 10, false, c_eCiv5GameplayDLL >::iterator it;
; 4942 : 
; 4943 : 	CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(formation);

	mov	ecx, DWORD PTR _formation$[esp+220]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+236], 0
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	ebx, eax

; 4944 : 	for(int iThisSlotIndex = 0; iThisSlotIndex < thisFormation->getNumFormationSlotEntries(); iThisSlotIndex++)

	mov	ecx, ebx
	xor	edi, edi
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	test	eax, eax
	jle	SHORT $LN32@FirstSlotC
$LL34@FirstSlotC:

; 4945 : 	{
; 4946 : 		const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(iThisSlotIndex);

	push	edi
	mov	ecx, ebx
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
	mov	esi, eax

; 4947 : 		slotsToFill.push_back(thisSlotEntry);

	mov	eax, DWORD PTR _slotsToFill$[esp+232]
	mov	BYTE PTR _slotsToFill$[esp+396], 0
	cmp	DWORD PTR _slotsToFill$[esp+228], eax
	jne	SHORT $LN48@FirstSlotC
	push	eax
	lea	ecx, DWORD PTR _slotsToFill$[esp+228]
	call	?GrowSize@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::GrowSize
$LN48@FirstSlotC:
	mov	eax, DWORD PTR _slotsToFill$[esp+228]
	shl	eax, 4
	add	eax, DWORD PTR _slotsToFill$[esp+224]
	je	SHORT $LN51@FirstSlotC
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], ecx
$LN51@FirstSlotC:
	inc	DWORD PTR _slotsToFill$[esp+228]
	mov	ecx, ebx
	inc	edi
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cmp	edi, eax
	jl	SHORT $LL34@FirstSlotC
$LN32@FirstSlotC:

; 4948 : 	}
; 4949 : 
; 4950 : 	bool bMustBeDeepWaterNaval = GET_TEAM(pPlayer->getTeam()).canEmbarkAllWaterPassage() && thisFormation->IsRequiresNavalUnitConsistency();

	mov	esi, DWORD PTR _pPlayer$[esp+220]
	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN59@FirstSlotC
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN60@FirstSlotC
$LN59@FirstSlotC:
	or	eax, -1
$LN60@FirstSlotC:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	test	al, al
	je	SHORT $LN37@FirstSlotC
	mov	ecx, ebx
	call	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
	mov	BYTE PTR _bMustBeDeepWaterNaval$[esp+224], 1
	test	al, al
	jne	SHORT $LN38@FirstSlotC
$LN37@FirstSlotC:
	mov	BYTE PTR _bMustBeDeepWaterNaval$[esp+224], 0
$LN38@FirstSlotC:

; 4951 : 
; 4952 : 	for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+228]
	push	edx
	mov	ecx, esi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	$LN29@FirstSlotC
	push	ebp
$LL196@FirstSlotC:

; 4953 : 	{
; 4954 : 		// Don't count scouts
; 4955 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	$LN30@FirstSlotC
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN30@FirstSlotC

; 4956 : 		{
; 4957 : 			// Don't count units that are damaged too heavily
; 4958 : 			if(pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	ecx, edi
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	mov	ecx, edi
	add	esi, edx
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, esi
	jl	$LN30@FirstSlotC

; 4959 : 			{
; 4960 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX && pLoopUnit->canRecruitFromTacticalAI())

	mov	ecx, edi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN30@FirstSlotC
	mov	ecx, edi
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	test	al, al
	je	$LN30@FirstSlotC

; 4961 : 				{
; 4962 : 					if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edi+124]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebx, esi
	cmp	ebx, eax
	jge	$LN30@FirstSlotC

; 4963 : 					{
; 4964 : 						if(!bRequiresNavalMoves || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	cmp	BYTE PTR _bRequiresNavalMoves$[esp+224], 0
	je	SHORT $LN23@FirstSlotC
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN23@FirstSlotC
	mov	ecx, edi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	$LN30@FirstSlotC
$LN23@FirstSlotC:

; 4965 : 						{
; 4966 : 							if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	cmp	BYTE PTR _bMustBeDeepWaterNaval$[esp+228], 0
	je	SHORT $LN21@FirstSlotC
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN21@FirstSlotC
	mov	eax, DWORD PTR [edi+1996]
	cmp	DWORD PTR [eax+24], 0
	jg	SHORT $LN30@FirstSlotC
$LN21@FirstSlotC:

; 4967 : 							{
; 4968 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 4969 : 								for (it = slotsToFill.begin(); it != slotsToFill.end(); ++it)
; 4970 : #else
; 4971 : 								for(it = slotsToFill.begin(); it != slotsToFill.end(); it++)

	mov	ecx, DWORD PTR _slotsToFill$[esp+232]
	mov	esi, DWORD PTR _slotsToFill$[esp+228]
	shl	ecx, 4
	add	ecx, esi
	cmp	esi, ecx
	je	SHORT $LN30@FirstSlotC
$LL20@FirstSlotC:

; 4972 : #endif
; 4973 : 								{
; 4974 : 									CvFormationSlotEntry slotEntry = *it;

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _slotEntry$228983[esp+240], ecx

; 4975 : 									CvUnitEntry& kUnitInfo = pLoopUnit->getUnitInfo();

	mov	ecx, edi
	mov	DWORD PTR _slotEntry$228983[esp+232], edx
	mov	DWORD PTR _slotEntry$228983[esp+236], eax
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ebp, eax

; 4976 : 									if(kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_primaryUnitType) ||
; 4977 : 										kUnitInfo.GetUnitAIType((UnitAITypes)slotEntry.m_secondaryUnitType))

	push	ebx
	mov	ecx, ebp
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	jne	SHORT $LN184@FirstSlotC
	mov	edx, DWORD PTR _slotEntry$228983[esp+232]
	push	edx
	mov	ecx, ebp
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	jne	SHORT $LN184@FirstSlotC
	mov	eax, DWORD PTR _slotsToFill$[esp+232]
	shl	eax, 4
	add	eax, DWORD PTR _slotsToFill$[esp+228]
	add	esi, 16					; 00000010H
	cmp	esi, eax
	jne	SHORT $LL20@FirstSlotC

; 5016 : 	{
; 5017 : 		if(slotsToFill[iThisSlotIndex].m_requiredSlot)

	jmp	SHORT $LN30@FirstSlotC
$LN184@FirstSlotC:

; 4978 : 									{
; 4979 : 										slotsToFill.erase(it);

	push	esi
	lea	ecx, DWORD PTR _slotsToFill$[esp+232]
	call	?erase@?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAEXPAVCvFormationSlotEntry@@@Z ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::erase
$LN30@FirstSlotC:
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+232]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[esp+232]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	$LL196@FirstSlotC
	pop	ebp
$LN29@FirstSlotC:

; 4980 : 										break;
; 4981 : 									}
; 4982 : 								}
; 4983 : 							}
; 4984 : 						}
; 4985 : 					}
; 4986 : 				}
; 4987 : 			}
; 4988 : 		}
; 4989 : 	}
; 4990 : 
; 4991 : 	// If coastal city, try to find the first one that is a naval AI type
; 4992 : 	if(bAtCoastalCity)

	cmp	BYTE PTR _bAtCoastalCity$[esp+220], 0
	mov	esi, DWORD PTR _slotsToFill$[esp+224]
	mov	edi, DWORD PTR _slotsToFill$[esp+228]
	je	SHORT $LN12@FirstSlotC

; 4993 : 	{
; 4994 : 		for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN12@FirstSlotC
	mov	edx, esi
$LL14@FirstSlotC:

; 4995 : 		{
; 4996 : 			if(slotsToFill[iThisSlotIndex].m_requiredSlot)

	cmp	BYTE PTR [edx+12], 0
	je	SHORT $LN13@FirstSlotC

; 4997 : 			{
; 4998 : 				UnitAITypes eType = (UnitAITypes)slotsToFill[iThisSlotIndex].m_primaryUnitType;

	mov	ecx, DWORD PTR [edx]

; 4999 : 				if(eType == UNITAI_ASSAULT_SEA || eType == UNITAI_ATTACK_SEA || eType == UNITAI_RESERVE_SEA || eType == UNITAI_ESCORT_SEA)

	cmp	ecx, 22					; 00000016H
	je	SHORT $LN9@FirstSlotC
	cmp	ecx, 18					; 00000012H
	je	SHORT $LN9@FirstSlotC
	cmp	ecx, 19					; 00000013H
	je	SHORT $LN9@FirstSlotC
	cmp	ecx, 20					; 00000014H
	je	SHORT $LN9@FirstSlotC
$LN13@FirstSlotC:

; 4993 : 	{
; 4994 : 		for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	inc	eax
	add	edx, 16					; 00000010H
	cmp	eax, edi
	jl	SHORT $LL14@FirstSlotC
$LN12@FirstSlotC:

; 5008 : 					}
; 5009 : 				}
; 5010 : 			}
; 5011 : 		}
; 5012 : 	}
; 5013 : 
; 5014 : 	// Now go back through remaining slots and find first required one
; 5015 : 	for(int iThisSlotIndex = 0; iThisSlotIndex < (int)slotsToFill.size(); iThisSlotIndex++)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN4@FirstSlotC
	lea	ecx, DWORD PTR [esi+12]
$LL6@FirstSlotC:

; 5016 : 	{
; 5017 : 		if(slotsToFill[iThisSlotIndex].m_requiredSlot)

	cmp	BYTE PTR [ecx], 0
	jne	$LN185@FirstSlotC
	inc	eax
	add	ecx, 16					; 00000010H
	cmp	eax, edi
	jl	SHORT $LL6@FirstSlotC
$LN4@FirstSlotC:

; 5026 : 			}
; 5027 : 		}
; 5028 : 	}
; 5029 : 
; 5030 : 	return NO_UNITAI;

	lea	eax, DWORD PTR _slotsToFill$[esp+236]
	mov	DWORD PTR __$EHRec$[esp+232], -1
	cmp	esi, eax
	je	SHORT $LN162@FirstSlotC
	push	esi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN162@FirstSlotC:
	pop	edi
	pop	esi
	or	eax, -1
	pop	ebx

; 5031 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	mov	DWORD PTR fs:0, ecx
	add	esp, 212				; 000000d4H
	ret	0
$LN9@FirstSlotC:

; 5000 : 				{
; 5001 : 					if(!bSecondaryUnit)
; 5002 : 					{
; 5003 : 						return (UnitAITypes)slotsToFill[iThisSlotIndex].m_primaryUnitType;

	shl	eax, 4
	cmp	BYTE PTR _bSecondaryUnit$[esp+220], 0
	mov	DWORD PTR __$EHRec$[esp+232], -1
	jne	SHORT $LN8@FirstSlotC
	mov	edi, DWORD PTR [eax+esi]
$LN199@FirstSlotC:
	lea	edx, DWORD PTR _slotsToFill$[esp+236]
	cmp	esi, edx
$LN198@FirstSlotC:
	je	SHORT $LN96@FirstSlotC
	push	esi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN96@FirstSlotC:

; 5031 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+224]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 212				; 000000d4H
	ret	0
$LN8@FirstSlotC:

; 5004 : 					}
; 5005 : 					else
; 5006 : 					{
; 5007 : 						return (UnitAITypes)slotsToFill[iThisSlotIndex].m_secondaryUnitType;

	mov	edi, DWORD PTR [eax+esi+4]
	lea	eax, DWORD PTR _slotsToFill$[esp+236]
	cmp	esi, eax
	jmp	SHORT $LN198@FirstSlotC
$LN185@FirstSlotC:

; 5018 : 		{
; 5019 : 			if(!bSecondaryUnit)
; 5020 : 			{
; 5021 : 				return (UnitAITypes)slotsToFill[iThisSlotIndex].m_primaryUnitType;

	shl	eax, 4
	cmp	BYTE PTR _bSecondaryUnit$[esp+220], 0
	mov	DWORD PTR __$EHRec$[esp+232], -1
	jne	SHORT $LN2@FirstSlotC
	mov	edi, DWORD PTR [eax+esi]
	lea	ecx, DWORD PTR _slotsToFill$[esp+236]
	cmp	esi, ecx
	jmp	SHORT $LN198@FirstSlotC
$LN2@FirstSlotC:

; 5022 : 			}
; 5023 : 			else
; 5024 : 			{
; 5025 : 				return (UnitAITypes)slotsToFill[iThisSlotIndex].m_secondaryUnitType;

	mov	edi, DWORD PTR [eax+esi+4]
	jmp	SHORT $LN199@FirstSlotC
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z$0:
	lea	ecx, DWORD PTR _slotsToFill$[ebp]
	jmp	??1?$FStaticVector@VCvFormationSlotEntry@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvFormationSlotEntry,10,0,297,0>::~FStaticVector<CvFormationSlotEntry,10,0,297,0>
__ehhandler$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z:
	mov	eax, OFFSET __ehfuncinfo$?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ENDP ; MilitaryAIHelpers::FirstSlotCityCanFill
PUBLIC	??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEXXZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z
_TEXT	SEGMENT
_weightedElem$ = -28					; size = 28
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back, COMDAT
; _this$ = ecx

; 103  : 	{

	sub	esp, 28					; 0000001cH

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp+24]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _weightedElem$[esp+28], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _weightedElem$[esp+32], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _weightedElem$[esp+36], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _weightedElem$[esp+40], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _weightedElem$[esp+48], eax
	mov	DWORD PTR _weightedElem$[esp+44], edx

; 108  : 		weightedElem.m_iWeight = iWeight;

	mov	edx, DWORD PTR _iWeight$[esp+24]

; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	lea	eax, DWORD PTR _weightedElem$[esp+28]
	push	eax
	mov	DWORD PTR _weightedElem$[esp+56], edx
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back

; 111  : 	};

	add	esp, 28					; 0000001cH
	ret	8
?push_back@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEIABUCvMilitaryTarget@@H@Z ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::push_back
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 2214 : 	{	// order heap by repeatedly popping, using operator<

	push	ebx

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	mov	ecx, esi
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	push	edi
	jle	SHORT $LN1@Sort_heap
	mov	edi, 28					; 0000001cH
	add	esi, -28				; ffffffe4H
	sub	edi, ebx

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	jle	SHORT $LN2@Sort_heap
$LN20@Sort_heap:
	mov	ecx, DWORD PTR [esi]
	push	0
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [esi+20]
	push	esi
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [esi+24]
	push	esi
	push	ebx
	mov	DWORD PTR [eax+24], ecx
	call	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 44					; 0000002cH
$LN2@Sort_heap:
	sub	esi, 28					; 0000001cH
	lea	ecx, DWORD PTR [edi+esi]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jg	SHORT $LN20@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ	; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
;	COMDAT ??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ PROC		; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 207  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 208  : 
; 209  : }

	ret	0
??0CvMilitaryAIStrategyXMLEntries@@QAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntries::CvMilitaryAIStrategyXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ ; CvMilitaryAIStrategyXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ PROC ; CvMilitaryAIStrategyXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 231  : {

	push	esi
	push	edi
	mov	edi, ecx

; 232  : 	for(std::vector<CvMilitaryAIStrategyXMLEntry*>::iterator it = m_paAIStrategyEntries.begin(); it != m_paAIStrategyEntries.end(); ++it)

	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@DeleteArra
	npad	4
$LL14@DeleteArra:

; 233  : 	{
; 234  : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@DeleteArra
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 235  : 	}
; 236  : 
; 237  : 	m_paAIStrategyEntries.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@DeleteArra:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@DeleteArra:
	pop	edi
	pop	esi

; 238  : }

	ret	0
?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ ENDP ; CvMilitaryAIStrategyXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestPillageAttack
; Function compile flags: /Ogtpy
;	COMDAT ?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iNumRequiredSlots$ = -8				; size = 4
_iLandReservesUsed$ = -4				; size = 4
_eEnemy$ = 8						; size = 4
?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestPillageAttack, COMDAT
; _this$ = ecx

; 603  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 604  : 	int iNumRequiredSlots = 0;
; 605  : 	int iLandReservesUsed = 0;
; 606  : 	int iFilledSlots = 0;
; 607  : 	iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_FAST_PILLAGERS, false, &iNumRequiredSlots, &iLandReservesUsed);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _iLandReservesUsed$[esp+12]
	push	eax
	lea	ecx, DWORD PTR _iNumRequiredSlots$[esp+16]
	push	ecx
	push	0
	push	2
	push	edx
	mov	DWORD PTR _iNumRequiredSlots$[esp+32], 0
	mov	DWORD PTR _iLandReservesUsed$[esp+32], 0
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H

; 608  : 	if(iFilledSlots >= iNumRequiredSlots && iLandReservesUsed <= GetLandReservesAvailable())

	cmp	eax, DWORD PTR _iNumRequiredSlots$[esp+12]
	jl	SHORT $LN1@RequestPil
	mov	eax, DWORD PTR [esi+52]
	sub	eax, DWORD PTR [esi+100]
	sub	eax, DWORD PTR [esi+72]
	cmp	DWORD PTR _iLandReservesUsed$[esp+12], eax
	jg	SHORT $LN1@RequestPil

; 609  : 	{
; 610  : 		CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_PILLAGE_ENEMY, eEnemy);

	mov	ecx, DWORD PTR _eEnemy$[esp+8]
	push	0
	push	0
	push	-1
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	5
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 611  : 		if(pOperation != NULL && !pOperation->ShouldAbort())

	test	eax, eax
	je	SHORT $LN1@RequestPil
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+72]
	call	eax
	test	al, al
	jne	SHORT $LN1@RequestPil

; 612  : 		{
; 613  : 			return true;

	mov	al, 1
	pop	esi

; 618  : }

	add	esp, 8
	ret	4
$LN1@RequestPil:

; 614  : 		}
; 615  : 	}
; 616  : 
; 617  : 	return false;

	xor	al, al
	pop	esi

; 618  : }

	add	esp, 8
	ret	4
?RequestPillageAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestPillageAttack
_TEXT	ENDS
PUBLIC	?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ; CvMilitaryAI::RequestSpecificAttack
EXTRN	?numOperationsOfType@CvPlayer@@QAEHH@Z:PROC	; CvPlayer::numOperationsOfType
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
; Function compile flags: /Ogtpy
;	COMDAT ?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z
_TEXT	SEGMENT
_iNumRequiredSlots$ = -8				; size = 4
_iLandReservesUsed$ = -4				; size = 4
_kTarget$ = 8						; size = 24
_iNumBombard$226216 = 32				; size = 4
_iNumUnitsWillingToBuild$ = 32				; size = 4
?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z PROC ; CvMilitaryAI::RequestSpecificAttack, COMDAT
; _this$ = ecx

; 704  : {

	sub	esp, 8
	push	ebx
	push	ebp

; 705  : 	CvAIOperation* pOperation = NULL;
; 706  : 	int iNumRequiredSlots = 0;

	xor	ebx, ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _iNumRequiredSlots$[esp+24], ebx

; 707  : 	int iLandReservesUsed = 0;

	mov	DWORD PTR _iLandReservesUsed$[esp+24], ebx

; 708  : 	int iFilledSlots = 0;
; 709  : 
; 710  : 	if(kTarget.m_pTargetCity)

	cmp	DWORD PTR _kTarget$[esp+20], ebx
	je	$LN1@RequestSpe

; 711  : 	{
; 712  : 		if(kTarget.m_bAttackBySea)

	cmp	BYTE PTR _kTarget$[esp+40], bl
	je	SHORT $LN8@RequestSpe

; 713  : 		{
; 714  : 			iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_INVASION, true, &iNumRequiredSlots, &iLandReservesUsed);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _iLandReservesUsed$[esp+24]
	push	eax
	lea	ecx, DWORD PTR _iNumRequiredSlots$[esp+28]
	push	ecx
	push	1
	push	12					; 0000000cH
	push	edx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots

; 715  : 			if((iNumRequiredSlots - iFilledSlots) <= iNumUnitsWillingToBuild && iLandReservesUsed <= GetLandReservesAvailable())

	mov	ecx, DWORD PTR _iNumRequiredSlots$[esp+44]
	sub	ecx, eax
	add	esp, 20					; 00000014H
	cmp	ecx, DWORD PTR _iNumUnitsWillingToBuild$[esp+20]
	jg	$LN1@RequestSpe
	mov	edx, DWORD PTR [esi+52]
	sub	edx, DWORD PTR [esi+100]
	sub	edx, DWORD PTR [esi+72]
	cmp	DWORD PTR _iLandReservesUsed$[esp+24], edx
	jg	$LN1@RequestSpe

; 716  : 			{
; 717  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_ATTACK, kTarget.m_pTargetCity->getOwner(), kTarget.m_pTargetCity->getArea(), kTarget.m_pTargetCity, kTarget.m_pMusterCity);

	mov	eax, DWORD PTR _kTarget$[esp+24]
	mov	ecx, DWORD PTR _kTarget$[esp+20]
	mov	edi, DWORD PTR [ecx+84]
	push	eax
	push	ecx
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	edi
	push	13					; 0000000dH
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	ebp, eax

; 718  : 			}
; 719  : 		}
; 720  : 		else

	jmp	$LN40@RequestSpe
$LN8@RequestSpe:

; 721  : 		{
; 722  : 			iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer,(GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE, false, &iNumRequiredSlots, &iLandReservesUsed);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN12@RequestSpe
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	jne	SHORT $LN12@RequestSpe
	mov	eax, 18					; 00000012H
	jmp	SHORT $LN13@RequestSpe
$LN12@RequestSpe:
	xor	eax, eax
$LN13@RequestSpe:
	lea	ecx, DWORD PTR _iLandReservesUsed$[esp+24]
	push	ecx
	lea	edx, DWORD PTR _iNumRequiredSlots$[esp+28]
	push	edx
	push	ebx
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots

; 723  : 			if((iNumRequiredSlots - iFilledSlots) <= iNumUnitsWillingToBuild && iLandReservesUsed <= GetLandReservesAvailable())

	mov	ecx, DWORD PTR _iNumRequiredSlots$[esp+44]
	sub	ecx, eax
	add	esp, 20					; 00000014H
	cmp	ecx, DWORD PTR _iNumUnitsWillingToBuild$[esp+20]
	jg	$LN1@RequestSpe
	mov	edx, DWORD PTR [esi+52]
	sub	edx, DWORD PTR [esi+100]
	sub	edx, DWORD PTR [esi+72]
	cmp	DWORD PTR _iLandReservesUsed$[esp+24], edx
	jg	$LN1@RequestSpe

; 724  : 			{
; 725  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_BASIC_CITY_ATTACK, kTarget.m_pTargetCity->getOwner(), kTarget.m_pTargetCity->getArea(), kTarget.m_pTargetCity, kTarget.m_pMusterCity);

	mov	eax, DWORD PTR _kTarget$[esp+24]
	mov	ecx, DWORD PTR _kTarget$[esp+20]
	mov	edi, DWORD PTR [ecx+84]
	push	eax
	push	ecx
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	edi
	push	2
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	mov	ebp, eax

; 726  : 				if (pOperation != NULL && !pOperation->ShouldAbort() && kTarget.m_pTargetCity->isCoastal(GC.getMIN_WATER_SIZE_FOR_OCEAN()))

	cmp	ebp, ebx
	je	$LN1@RequestSpe
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, ebp
	call	eax
	test	al, al
	jne	$LN40@RequestSpe
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6876
	push	ecx
	mov	ecx, DWORD PTR _kTarget$[esp+24]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN40@RequestSpe

; 727  : 				{
; 728  : 					int iFlavorNaval = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL"));

	push	ebx
	push	OFFSET $SG226214
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 729  : 					int iNumSuperiority = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_SUPERIORITY);

	mov	ecx, DWORD PTR [esi]
	push	10					; 0000000aH
	mov	edi, eax
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType

; 730  : 					int iNumBombard = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_BOMBARDMENT);

	mov	ecx, DWORD PTR [esi]
	push	9
	mov	ebx, eax
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType

; 731  : 					int iMaxOperations = iFlavorNaval / 2;
; 732  : 					if(GC.getMap().GetAIMapHint() & 1)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _iNumBombard$226216[esp+20], eax
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	je	SHORT $LN3@RequestSpe

; 733  : 					{
; 734  : 						iMaxOperations *= 2;

	add	edi, edi
$LN3@RequestSpe:

; 735  : 					}
; 736  : 					if (iNumSuperiority+iNumBombard <= iMaxOperations)

	mov	edx, DWORD PTR _iNumBombard$226216[esp+20]
	add	edx, ebx
	cmp	edx, edi
	jg	SHORT $LN40@RequestSpe

; 737  : 						m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SUPERIORITY, NO_PLAYER);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	push	-1
	push	-1
	push	10					; 0000000aH
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
$LN40@RequestSpe:

; 738  : 				}
; 739  : 			}
; 740  : 		}
; 741  : 
; 742  : 		if(pOperation != NULL && !pOperation->ShouldAbort())

	test	ebp, ebp
	je	SHORT $LN1@RequestSpe
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+72]
	mov	ecx, ebp
	call	edx
	test	al, al
	jne	SHORT $LN1@RequestSpe
	pop	edi
	pop	esi
	pop	ebp

; 743  : 		{
; 744  : 			return true;

	mov	al, 1
	pop	ebx

; 748  : }

	add	esp, 8
	ret	28					; 0000001cH
$LN1@RequestSpe:
	pop	edi
	pop	esi
	pop	ebp

; 745  : 		}
; 746  : 	}
; 747  : 	return false;

	xor	al, al
	pop	ebx

; 748  : }

	add	esp, 8
	ret	28					; 0000001cH
?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ENDP ; CvMilitaryAI::RequestSpecificAttack
_TEXT	ENDS
PUBLIC	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
; Function compile flags: /Ogtpy
;	COMDAT ?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z
_TEXT	SEGMENT
_iNumRequiredSlots$ = -8				; size = 4
_iOperationID$ = -4					; size = 4
_eFormation$ = 8					; size = 4
_bRequiresNavalMoves$ = 12				; size = 1
_iLandReservesUsed$ = 12				; size = 4
_eOperationType$ = 12					; size = 4
?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z PROC ; CvMilitaryAI::IsAttackReady, COMDAT
; _this$ = ecx

; 3472 : {

	sub	esp, 8
	push	esi

; 3473 : 	int iOperationID;
; 3474 : 
; 3475 : 	// Do we already have an operation of this type that is building units?
; 3476 : 	bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(eOperationType, &iOperationID, NO_PLAYER);

	push	0
	push	-1
	mov	esi, ecx
	mov	ecx, DWORD PTR _eOperationType$[esp+16]
	lea	eax, DWORD PTR _iOperationID$[esp+20]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 3477 : 	if (bHasOperationUnderway)

	test	al, al
	je	SHORT $LN5@IsAttackRe

; 3478 : 	{
; 3479 : 		if (m_pPlayer->getAIOperation(iOperationID)->GetOperationState() != AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	edx, DWORD PTR _iOperationID$[esp+12]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	cmp	DWORD PTR [eax+56], 1
	je	SHORT $LN5@IsAttackRe

; 3480 : 		{
; 3481 : 			return false;

	xor	al, al
	pop	esi

; 3497 : 	{
; 3498 : 		return true;
; 3499 : 	}
; 3500 : 	else
; 3501 : 	{
; 3502 : 		return false;
; 3503 : 	}
; 3504 : }

	add	esp, 8
	ret	8
$LN5@IsAttackRe:

; 3482 : 		}
; 3483 : 	}
; 3484 : 
; 3485 : 	int iNumRequiredSlots = 0;
; 3486 : 	int iLandReservesUsed = 0;
; 3487 : 	int iFilledSlots = 0;
; 3488 : 
; 3489 : 	bool bRequiresNavalMoves = false;
; 3490 : 	if(eFormation == MUFORMATION_NAVAL_INVASION || eFormation == MUFORMATION_NAVAL_SQUADRON || eFormation == MUFORMATION_CITY_STATE_INVASION || eFormation == MUFORMATION_PURE_NAVAL_CITY_ATTACK)

	mov	eax, DWORD PTR _eFormation$[esp+8]
	mov	DWORD PTR _iNumRequiredSlots$[esp+12], 0
	mov	BYTE PTR _bRequiresNavalMoves$[esp+8], 0
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN3@IsAttackRe
	cmp	eax, 9
	je	SHORT $LN3@IsAttackRe
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN3@IsAttackRe
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN4@IsAttackRe
$LN3@IsAttackRe:

; 3491 : 	{
; 3492 : 		bRequiresNavalMoves = true;

	mov	BYTE PTR _bRequiresNavalMoves$[esp+8], 1
$LN4@IsAttackRe:

; 3493 : 	}
; 3494 : 
; 3495 : 	iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, eFormation, bRequiresNavalMoves, &iNumRequiredSlots, &iLandReservesUsed);

	lea	ecx, DWORD PTR _iLandReservesUsed$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _bRequiresNavalMoves$[esp+12]
	lea	edx, DWORD PTR _iNumRequiredSlots$[esp+16]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ecx
	push	eax
	push	edx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H

; 3496 : 	if(iFilledSlots >= iNumRequiredSlots)

	cmp	eax, DWORD PTR _iNumRequiredSlots$[esp+12]
	pop	esi
	setge	al

; 3497 : 	{
; 3498 : 		return true;
; 3499 : 	}
; 3500 : 	else
; 3501 : 	{
; 3502 : 		return false;
; 3503 : 	}
; 3504 : }

	add	esp, 8
	ret	8
?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ENDP ; CvMilitaryAI::IsAttackReady
_TEXT	ENDS
PUBLIC	?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z ; CvMilitaryAI::GetUnitForArmy
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z PROC ; CvMilitaryAI::GetUnitForArmy, COMDAT
; _this$ = ecx

; 3630 : {

	push	esi
	mov	esi, ecx

; 3631 : 	if(m_eArmyTypeBeingBuilt == NO_ARMY_TYPE)

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, -1
	jne	SHORT $LN4@GetUnitFor

; 3632 : 	{
; 3633 : 		return NO_UNIT;

	or	eax, eax
	pop	esi

; 3652 : 	}
; 3653 : 	return eType;
; 3654 : }

	ret	4
$LN4@GetUnitFor:
	push	ebp
	push	edi

; 3634 : 	}
; 3635 : 
; 3636 : 	// Look for required units first
; 3637 : 	MultiunitFormationTypes eFormation;
; 3638 : 	if(m_eArmyTypeBeingBuilt == ARMY_TYPE_NAVAL_INVASION)

	cmp	eax, 1
	jne	SHORT $LN3@GetUnitFor

; 3639 : 	{
; 3640 : 		eFormation = MUFORMATION_NAVAL_INVASION;

	lea	ebp, DWORD PTR [eax+11]

; 3641 : 	}
; 3642 : 	else

	jmp	SHORT $LN8@GetUnitFor
$LN3@GetUnitFor:

; 3643 : 	{
; 3644 : 		eFormation = (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN7@GetUnitFor
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	jne	SHORT $LN7@GetUnitFor
	mov	ebp, 18					; 00000012H
	jmp	SHORT $LN8@GetUnitFor
$LN7@GetUnitFor:
	xor	ebp, ebp
$LN8@GetUnitFor:

; 3645 : 	}
; 3646 : 	UnitAITypes eUnitAIType = MilitaryAIHelpers::FirstSlotCityCanFill(m_pPlayer, eFormation, (m_eArmyTypeBeingBuilt == ARMY_TYPE_NAVAL_INVASION), pCity->isCoastal(), false /*bSecondaryUnit*/);

	mov	edi, DWORD PTR _pCity$[esp+8]
	push	0
	push	-1
	mov	ecx, edi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	cmp	DWORD PTR [esi+44], 1
	movzx	eax, al
	sete	cl
	push	eax
	mov	eax, DWORD PTR [esi]
	movzx	edx, cl
	push	edx
	push	ebp
	push	eax
	call	?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ; MilitaryAIHelpers::FirstSlotCityCanFill
	add	esp, 20					; 00000014H

; 3647 : 	UnitTypes eType = pCity->GetCityStrategyAI()->GetUnitProductionAI()->RecommendUnit(eUnitAIType);

	push	eax
	mov	ecx, edi
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
	mov	ecx, eax
	call	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ; CvUnitProductionAI::RecommendUnit

; 3648 : 	if(eType == NO_UNIT)

	cmp	eax, -1
	jne	SHORT $LN1@GetUnitFor

; 3649 : 	{
; 3650 : 		eUnitAIType = MilitaryAIHelpers::FirstSlotCityCanFill(m_pPlayer, eFormation, (m_eArmyTypeBeingBuilt == ARMY_TYPE_NAVAL_INVASION), pCity->isCoastal(), true /*bSecondaryUnit*/);

	push	1
	push	eax
	mov	ecx, edi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	cmp	DWORD PTR [esi+44], 1
	movzx	ecx, al
	sete	dl
	push	ecx
	mov	ecx, DWORD PTR [esi]
	movzx	eax, dl
	push	eax
	push	ebp
	push	ecx
	call	?FirstSlotCityCanFill@MilitaryAIHelpers@@YA?AW4UnitAITypes@@PAVCvPlayer@@W4MultiunitFormationTypes@@_N22@Z ; MilitaryAIHelpers::FirstSlotCityCanFill
	add	esp, 20					; 00000014H

; 3651 : 		eType = pCity->GetCityStrategyAI()->GetUnitProductionAI()->RecommendUnit(eUnitAIType);

	push	eax
	mov	ecx, edi
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetUnitProductionAI@CvCityStrategyAI@@QAEPAVCvUnitProductionAI@@XZ ; CvCityStrategyAI::GetUnitProductionAI
	mov	ecx, eax
	call	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ; CvUnitProductionAI::RecommendUnit
$LN1@GetUnitFor:
	pop	edi
	pop	ebp
	pop	esi

; 3652 : 	}
; 3653 : 	return eType;
; 3654 : }

	ret	4
?GetUnitForArmy@CvMilitaryAI@@QBE?AW4UnitTypes@@PAVCvCity@@@Z ENDP ; CvMilitaryAI::GetUnitForArmy
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ	; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ PROC		; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 213  : {

	push	-1
	push	__ehhandler$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 214  : 	DeleteArray();

	call	?DeleteArray@CvMilitaryAIStrategyXMLEntries@@QAEXXZ ; CvMilitaryAIStrategyXMLEntries::DeleteArray

; 215  : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvMilitary
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvMilitary:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvMilitaryAIStrategyXMLEntry@@V?$allocator@PAVCvMilitaryAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >::~vector<CvMilitaryAIStrategyXMLEntry *,std::allocator<CvMilitaryAIStrategyXMLEntry *> >
__ehhandler$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMilitaryAIStrategyXMLEntries@@QAE@XZ ENDP		; CvMilitaryAIStrategyXMLEntries::~CvMilitaryAIStrategyXMLEntries
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z
_TEXT	SEGMENT
__Mid$229709 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	ecx, edi
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 32					; 00000020H
	jle	$LN3@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
$LL7@Sort:
	test	esi, esi
	jle	$LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$229709[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, edi
	sub	ecx, DWORD PTR __Mid$229709[esp+40]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	mov	ecx, DWORD PTR __Mid$229709[esp+36]
	sar	edx, 4
	mov	ebp, edx
	sub	ecx, ebx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	esp, 12					; 0000000cH
	add	ecx, edx
	cmp	ecx, ebp

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	mov	edx, DWORD PTR __Mid$229709[esp+28]
	push	edx
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, DWORD PTR __Mid$229709[esp+40]

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN25@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	eax, DWORD PTR __Mid$229709[esp+32]
	push	edi
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$229709[esp+36]
$LN25@Sort:
	mov	ecx, edi
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	$LL7@Sort
$LN3@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	ecx, edi
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, 1
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int,CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ; std::sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z PROC ; std::sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>, COMDAT

; 3113 : 	{	// order [_First, _Last), using operator<

	push	esi

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	esi
	push	edi
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0@Z ENDP ; std::sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ ; CvWeightedVector<CvMilitaryTarget,640,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ PROC ; CvWeightedVector<CvMilitaryTarget,640,1>::SortItems, COMDAT
; _this$ = ecx

; 139  : 	{

	push	esi

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	push	edi
	lea	edi, DWORD PTR [esi+eax*4]
	mov	ecx, edi
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	edi
	push	esi
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAEXXZ ENDP ; CvWeightedVector<CvMilitaryTarget,640,1>::SortItems
_TEXT	ENDS
PUBLIC	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	_atexit:PROC
;	COMDAT ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_BSS	SEGMENT
?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A DB 04610H DUP (?) ; `CvMilitaryAI::FindBestAttackTarget'::`43'::prelimWeightedTargetList
_BSS	ENDS
;	COMDAT ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
_BSS	SEGMENT
?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A DB 04610H DUP (?) ; `CvMilitaryAI::FindBestAttackTarget'::`2'::weightedTargetList
_BSS	ENDS
;	COMDAT ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
_BSS	SEGMENT
?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA DD 01H DUP (?) ; `CvMilitaryAI::FindBestAttackTarget'::`2'::$S1
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$1
__ehfuncinfo$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.cpp
xdata$x	ENDS
;	COMDAT ?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
_TEXT	SEGMENT
_bGeneralInTheVicinity$226583 = -121			; size = 1
_bGeneralInTheVicinity$226564 = -121			; size = 1
_this$ = -120						; size = 4
_fcn$226753 = -116					; size = 8
_pEnemyCity$ = -116					; size = 4
_iPower$226565 = -116					; size = 4
tv1266 = -108						; size = 4
$T240455 = -108						; size = 4
_iTargetsConsidered$ = -108				; size = 4
_kEnemy$ = -108						; size = 4
_iUnitLoop$ = -104					; size = 4
_iEnemyLoop$ = -100					; size = 4
_iFriendlyLoop$ = -96					; size = 4
tv1093 = -92						; size = 4
$T240454 = -92						; size = 4
_iI$226615 = -92					; size = 4
_chosenTarget$ = -88					; size = 24
_target$226619 = -64					; size = 24
_target$226607 = -64					; size = 24
_weightedElem$240952 = -40				; size = 28
$T240456 = -40						; size = 24
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eAIOperationType$ = 12					; size = 4
_eEnemy$ = 16						; size = 4
_piWinningScore$ = 20					; size = 4
?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z PROC ; CvMilitaryAI::FindBestAttackTarget, COMDAT
; _this$ = ecx

; 981  : {

	push	-1
	push	__ehhandler$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 982  : 	int iFriendlyLoop;
; 983  : 	int iEnemyLoop;
; 984  : 	int iUnitLoop;
; 985  : 	CvCity* pFriendlyCity;
; 986  : 	CvCity* pEnemyCity;
; 987  : 	CvUnit* pLoopUnit;
; 988  : 	static CvWeightedVector<CvMilitaryTarget, SAFE_ESTIMATE_NUM_CITIES* 10, true> weightedTargetList;

	xor	edi, edi
	test	BYTE PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, 1
	mov	DWORD PTR _this$[esp+140], esi
	jne	SHORT $LN50@FindBestAt
	or	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, 1
	push	OFFSET ??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ; `CvMilitaryAI::FindBestAttackTarget'::`2'::`dynamic atexit destructor for 'weightedTargetList''
	mov	DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, edi
	mov	DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+8, 640 ; 00000280H
	mov	DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+12
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[esp+148], -1
$LN50@FindBestAt:

; 989  : 	CvMilitaryTarget chosenTarget;
; 990  : 	CvPlayer &kEnemy = GET_PLAYER(eEnemy);

	mov	eax, DWORD PTR _eEnemy$[esp+136]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv1093[esp+140], eax
	add	eax, ecx

; 991  : 
; 992  : 	// Estimate the relative strength of units near our cities and near their cities (can't use TacticalAnalysisMap because we may not be at war - and that it isn't current if we are calling this from the DiploAI)
; 993  : 	for (pFriendlyCity = m_pPlayer->firstCity(&iFriendlyLoop); pFriendlyCity != NULL; pFriendlyCity = m_pPlayer->nextCity(&iFriendlyLoop))

	mov	ecx, DWORD PTR [esi]
	push	edi
	lea	edx, DWORD PTR _iFriendlyLoop$[esp+144]
	push	edx
	mov	DWORD PTR _chosenTarget$[esp+152], edi
	mov	DWORD PTR _chosenTarget$[esp+156], edi
	mov	DWORD PTR _chosenTarget$[esp+160], edi
	mov	DWORD PTR _chosenTarget$[esp+164], edi
	mov	BYTE PTR _chosenTarget$[esp+168], 0
	mov	DWORD PTR _kEnemy$[esp+148], eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	cmp	ebx, edi
	je	$LN47@FindBestAt
	npad	1
$LL49@FindBestAt:

; 994  : 	{
; 995  : 		CvPlot* pPlot = pFriendlyCity->plot();

	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 996  : 		int iX = pPlot->getX();

	movsx	edi, WORD PTR [eax]

; 997  : 		int iY = pPlot->getY();

	movsx	ebp, WORD PTR [eax+2]

; 998  : 		bool bGeneralInTheVicinity = false;
; 999  : 		int iPower = 0;
; 1000 : 		for (pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR _this$[esp+140]
	mov	ecx, DWORD PTR [ecx]
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+144]
	push	eax
	mov	BYTE PTR _bGeneralInTheVicinity$226564[esp+148], 0
	mov	DWORD PTR _iPower$226565[esp+148], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN334@FindBestAt
$LL46@FindBestAt:

; 1001 : 		{
; 1002 : 			if (pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [esi+1044], 0
	jle	SHORT $LN42@FindBestAt

; 1003 : 			{
; 1004 : 				int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	ebp
	push	edi
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1005 : 				if (iDistance <= 5)

	cmp	eax, 5
	jg	SHORT $LN42@FindBestAt

; 1006 : 				{
; 1007 : 					iPower += pLoopUnit->GetPower();

	mov	ecx, esi
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	add	DWORD PTR _iPower$226565[esp+140], eax
$LN42@FindBestAt:

; 1008 : 				}
; 1009 : 			}
; 1010 : 			if (!bGeneralInTheVicinity && pLoopUnit->IsGreatGeneral())

	cmp	BYTE PTR _bGeneralInTheVicinity$226564[esp+140], 0
	jne	SHORT $LN45@FindBestAt
	mov	ecx, esi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	je	SHORT $LN45@FindBestAt

; 1011 : 			{
; 1012 : 				int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	ebp
	push	edi
	push	eax
	push	esi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1013 : 				if (iDistance <= 5)

	cmp	eax, 5
	jg	SHORT $LN45@FindBestAt

; 1014 : 				{
; 1015 : 					bGeneralInTheVicinity = true;

	mov	BYTE PTR _bGeneralInTheVicinity$226564[esp+140], 1
$LN45@FindBestAt:

; 998  : 		bool bGeneralInTheVicinity = false;
; 999  : 		int iPower = 0;
; 1000 : 		for (pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	eax, DWORD PTR _this$[esp+140]
	mov	ecx, DWORD PTR [eax]
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[esp+144]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL46@FindBestAt

; 1016 : 				}
; 1017 : 			}
; 1018 : 		}
; 1019 : 		if (bGeneralInTheVicinity)

	cmp	BYTE PTR _bGeneralInTheVicinity$226564[esp+140], al
	je	SHORT $LN334@FindBestAt

; 1020 : 		{
; 1021 : 			iPower *= 11;

	mov	ecx, DWORD PTR _iPower$226565[esp+140]
	imul	ecx, 11					; 0000000bH

; 1022 : 			iPower /= 10;

	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, ecx
	jmp	SHORT $LN39@FindBestAt
$LN334@FindBestAt:
	mov	eax, DWORD PTR _iPower$226565[esp+140]
$LN39@FindBestAt:

; 1023 : 		}
; 1024 : 		pFriendlyCity->iScratch = iPower;

	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR _this$[esp+140]
	mov	ecx, DWORD PTR [eax]
	push	0
	lea	edx, DWORD PTR _iFriendlyLoop$[esp+144]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL49@FindBestAt
$LN47@FindBestAt:

; 1025 : 	}
; 1026 : 	for(pEnemyCity = kEnemy.firstCity(&iEnemyLoop); pEnemyCity != NULL; pEnemyCity = kEnemy.nextCity(&iEnemyLoop))

	push	0
	lea	ecx, DWORD PTR _iEnemyLoop$[esp+144]
	push	ecx
	mov	ecx, DWORD PTR _kEnemy$[esp+148]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pEnemyCity$[esp+140], eax
	test	eax, eax
	je	$LN335@FindBestAt
	npad	7
$LL38@FindBestAt:

; 1027 : 	{
; 1028 : 		CvPlot* pPlot = pEnemyCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 1029 : 		if(pPlot->isRevealed(m_pPlayer->getTeam()))

	mov	edx, DWORD PTR _this$[esp+140]
	mov	ecx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN98@FindBestAt
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN99@FindBestAt
$LN98@FindBestAt:
	or	ecx, -1
$LN99@FindBestAt:
	mov	edx, ecx
	shr	edx, 5
	mov	esi, edx
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [eax+edx*4+8]
	je	$LN37@FindBestAt

; 1030 : 		{
; 1031 : 			int iX = pPlot->getX();

	movsx	edi, WORD PTR [eax]

; 1032 : 			int iY = pPlot->getY();

	movsx	ebp, WORD PTR [eax+2]

; 1033 : 			bool bGeneralInTheVicinity = false;
; 1034 : 			int iPower = 0;
; 1035 : 			for (pLoopUnit = kEnemy.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kEnemy.nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR _kEnemy$[esp+140]
	xor	ebx, ebx
	push	ebx
	lea	eax, DWORD PTR _iUnitLoop$[esp+144]
	push	eax
	mov	BYTE PTR _bGeneralInTheVicinity$226583[esp+148], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN27@FindBestAt
	npad	6
$LL34@FindBestAt:

; 1036 : 			{
; 1037 : 				if (pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [esi+1044], 0
	jle	SHORT $LN30@FindBestAt

; 1038 : 				{
; 1039 : 					int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	ebp
	push	edi
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1040 : 					if (iDistance <= 5)

	cmp	eax, 5
	jg	SHORT $LN30@FindBestAt

; 1041 : 					{
; 1042 : 						iPower += pLoopUnit->GetPower();

	mov	ecx, esi
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	add	ebx, eax
$LN30@FindBestAt:

; 1043 : 					}
; 1044 : 				}
; 1045 : 				if (!bGeneralInTheVicinity && pLoopUnit->IsGreatGeneral())

	cmp	BYTE PTR _bGeneralInTheVicinity$226583[esp+140], 0
	jne	SHORT $LN33@FindBestAt
	mov	ecx, esi
	call	?IsGreatGeneral@CvUnit@@QBE_NXZ		; CvUnit::IsGreatGeneral
	test	al, al
	je	SHORT $LN33@FindBestAt

; 1046 : 				{
; 1047 : 					int iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iX, iY);

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	ebp
	push	edi
	push	eax
	push	esi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1048 : 					if (iDistance <= 5)

	cmp	eax, 5
	jg	SHORT $LN33@FindBestAt

; 1049 : 					{
; 1050 : 						bGeneralInTheVicinity = true;

	mov	BYTE PTR _bGeneralInTheVicinity$226583[esp+140], 1
$LN33@FindBestAt:

; 1033 : 			bool bGeneralInTheVicinity = false;
; 1034 : 			int iPower = 0;
; 1035 : 			for (pLoopUnit = kEnemy.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kEnemy.nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+144]
	push	ecx
	mov	ecx, DWORD PTR _kEnemy$[esp+148]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL34@FindBestAt

; 1051 : 					}
; 1052 : 				}
; 1053 : 			}
; 1054 : 			if (bGeneralInTheVicinity)

	cmp	BYTE PTR _bGeneralInTheVicinity$226583[esp+140], al
	je	SHORT $LN27@FindBestAt

; 1055 : 			{
; 1056 : 				iPower *= 11;

	mov	ecx, ebx
	imul	ecx, 11					; 0000000bH

; 1057 : 				iPower /= 10;

	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebx, eax
$LN27@FindBestAt:

; 1058 : 			}
; 1059 : 			pEnemyCity->iScratch = iPower;

	mov	ecx, DWORD PTR _pEnemyCity$[esp+140]
	mov	DWORD PTR [ecx+4], ebx
$LN37@FindBestAt:
	mov	ecx, DWORD PTR _kEnemy$[esp+140]
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[esp+144]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pEnemyCity$[esp+140], eax
	test	eax, eax
	jne	$LL38@FindBestAt
$LN335@FindBestAt:

; 1060 : 		}
; 1061 : 	}
; 1062 : 
; 1063 : 	// Build a list of all the possible start city/target city pairs
; 1064 : 	static CvWeightedVector<CvMilitaryTarget, SAFE_ESTIMATE_NUM_CITIES* 10, true> prelimWeightedTargetList;

	mov	eax, 2
	test	BYTE PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, al
	jne	SHORT $LN26@FindBestAt
	or	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, eax
	push	OFFSET ??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ; `CvMilitaryAI::FindBestAttackTarget'::`43'::`dynamic atexit destructor for 'prelimWeightedTargetList''
	mov	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, 0
	mov	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+8, 640 ; 00000280H
	mov	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A, OFFSET ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+12
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[esp+148], -1
$LN26@FindBestAt:

; 1065 : 	prelimWeightedTargetList.clear();
; 1066 : 	for(pFriendlyCity = m_pPlayer->firstCity(&iFriendlyLoop); pFriendlyCity != NULL; pFriendlyCity = m_pPlayer->nextCity(&iFriendlyLoop))

	mov	ecx, DWORD PTR _this$[esp+140]
	push	0
	lea	eax, DWORD PTR _iFriendlyLoop$[esp+144]
	mov	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, 0
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, DWORD PTR _eAIOperationType$[esp+136]
	mov	ebp, eax
	test	ebp, ebp
	je	$LN23@FindBestAt
	npad	12
$LL25@FindBestAt:

; 1067 : 	{
; 1068 : 		for(pEnemyCity = GET_PLAYER(eEnemy).firstCity(&iEnemyLoop); pEnemyCity != NULL; pEnemyCity = GET_PLAYER(eEnemy).nextCity(&iEnemyLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1093[esp+140]
	lea	ecx, DWORD PTR [eax+edx]
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[esp+144]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN24@FindBestAt
$LL22@FindBestAt:

; 1069 : 		{
; 1070 : 			if(pEnemyCity->plot()->isRevealed(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR _this$[esp+140]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN160@FindBestAt
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN161@FindBestAt
$LN160@FindBestAt:
	or	edi, -1
$LN161@FindBestAt:
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, edi
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv1266[esp+140], ecx
	mov	ecx, edi
	mov	edi, DWORD PTR tv1266[esp+140]
	sub	ecx, edi
	mov	edi, 1
	shl	edi, cl
	test	edi, DWORD PTR [eax+edx*4+8]
	je	$LN21@FindBestAt

; 1071 : 			{
; 1072 : 				CvMilitaryTarget target;
; 1073 : 				int iWeight;
; 1074 : 				target.m_pMusterCity = pFriendlyCity;
; 1075 : 				target.m_pTargetCity = pEnemyCity;
; 1076 : 				target.iMusterNearbyUnitPower = pFriendlyCity->iScratch;

	mov	edx, DWORD PTR [ebp+4]

; 1077 : 				target.iTargetNearbyUnitPower = pEnemyCity->iScratch;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _target$226607[esp+156], 0
	mov	BYTE PTR _target$226607[esp+160], 0
	mov	DWORD PTR _target$226607[esp+144], ebp
	mov	DWORD PTR _target$226607[esp+140], esi
	mov	DWORD PTR _target$226607[esp+152], edx
	mov	DWORD PTR _target$226607[esp+148], eax

; 1078 : 
; 1079 : 				if (eAIOperationType == AI_OPERATION_PURE_NAVAL_CITY_ATTACK)

	cmp	ebx, 18					; 00000012H
	jne	SHORT $LN18@FindBestAt

; 1080 : 				{
; 1081 : 					target.m_bAttackBySea = true;
; 1082 : 					if (target.m_pMusterCity->isCoastal() && target.m_pTargetCity->isCoastal())

	push	-1
	mov	ecx, ebp
	mov	BYTE PTR _target$226607[esp+164], 1
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN21@FindBestAt
	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN21@FindBestAt

; 1083 : 					{
; 1084 : 						target.m_iPathLength = plotDistance(target.m_pMusterCity->getX(), target.m_pMusterCity->getY(), target.m_pTargetCity->getX(), target.m_pTargetCity->getY());

	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [ebp+108]
	push	ecx
	mov	ecx, DWORD PTR [ebp+96]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	edi, eax

; 1085 : 					}
; 1086 : 				}
; 1087 : 
; 1088 : 				else

	jmp	SHORT $LN15@FindBestAt
$LN18@FindBestAt:

; 1089 : 				{
; 1090 : 					ShouldAttackBySea(eEnemy, target);

	mov	eax, DWORD PTR _eEnemy$[esp+136]
	mov	ecx, DWORD PTR _this$[esp+140]
	lea	edx, DWORD PTR _target$226607[esp+140]
	push	edx
	push	eax
	call	?ShouldAttackBySea@CvMilitaryAI@@QAEXW4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::ShouldAttackBySea

; 1091 : 
; 1092 : 					if (!pFriendlyCity->isCoastal() && target.m_bAttackBySea)

	push	-1
	mov	ecx, ebp
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	jne	SHORT $LN329@FindBestAt
	cmp	BYTE PTR _target$226607[esp+160], al
	jne	SHORT $LN21@FindBestAt
$LN329@FindBestAt:
	mov	edi, DWORD PTR _target$226607[esp+156]
$LN15@FindBestAt:

; 1093 : 					{
; 1094 : 						continue;
; 1095 : 					}
; 1096 : 				}
; 1097 : 
; 1098 : 				if(target.m_iPathLength > 0)

	test	edi, edi
	jle	SHORT $LN21@FindBestAt

; 1099 : 				{
; 1100 : 					iWeight = (10000 - target.m_iPathLength);   // Start by using the path length as the weight, shorter paths have higher weight
; 1101 : 					prelimWeightedTargetList.push_back(target, iWeight);

	mov	eax, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+8
	mov	esi, 10000				; 00002710H
	sub	esi, edi
	mov	BYTE PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+17932, 0
	cmp	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, eax
	jne	SHORT $LN193@FindBestAt
	push	eax
	mov	ecx, OFFSET ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize
$LN193@FindBestAt:
	mov	eax, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	edx, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN196@FindBestAt
	mov	ecx, DWORD PTR _target$226607[esp+140]
	mov	edx, DWORD PTR _target$226607[esp+144]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _target$226607[esp+148]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _target$226607[esp+152]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _target$226607[esp+160]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edi
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], esi
$LN196@FindBestAt:
	inc	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
$LN21@FindBestAt:

; 1067 : 	{
; 1068 : 		for(pEnemyCity = GET_PLAYER(eEnemy).firstCity(&iEnemyLoop); pEnemyCity != NULL; pEnemyCity = GET_PLAYER(eEnemy).nextCity(&iEnemyLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1093[esp+140]
	lea	ecx, DWORD PTR [eax+edx]
	push	0
	lea	edx, DWORD PTR _iEnemyLoop$[esp+144]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	$LL22@FindBestAt
$LN24@FindBestAt:

; 1065 : 	prelimWeightedTargetList.clear();
; 1066 : 	for(pFriendlyCity = m_pPlayer->firstCity(&iFriendlyLoop); pFriendlyCity != NULL; pFriendlyCity = m_pPlayer->nextCity(&iFriendlyLoop))

	mov	ecx, DWORD PTR _this$[esp+140]
	mov	ecx, DWORD PTR [ecx]
	push	0
	lea	eax, DWORD PTR _iFriendlyLoop$[esp+144]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL25@FindBestAt
$LN23@FindBestAt:

; 1102 : 				}
; 1103 : 			}
; 1104 : 		}
; 1105 : 	}
; 1106 : 
; 1107 : 	// Let's score the 25 shortest paths ... anything more than that means there are too many interior cities from one (or both) sides being considered
; 1108 : 	prelimWeightedTargetList.SortItems();

	mov	eax, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	esi, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	lea	edi, DWORD PTR [esi+edx*4]
	mov	ecx, edi
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	edi
	push	esi
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>

; 1109 : 	weightedTargetList.clear();

	xor	esi, esi
	xor	ecx, ecx
	add	esp, 12					; 0000000cH

; 1110 : 	int iTargetsConsidered = 0;
; 1111 : 	for (int iI = 0; iI < prelimWeightedTargetList.size() && iTargetsConsidered < 25; iI++)

	cmp	DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, esi
	mov	DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, ecx
	mov	DWORD PTR _iTargetsConsidered$[esp+140], esi
	mov	DWORD PTR _iI$226615[esp+140], esi
	jle	$LN328@FindBestAt
$LL333@FindBestAt:
	cmp	DWORD PTR _iTargetsConsidered$[esp+140], 25 ; 00000019H
	jge	$LN337@FindBestAt

; 1112 : 	{
; 1113 : 		CvMilitaryTarget target = prelimWeightedTargetList.GetElement(iI);

	mov	eax, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	ecx, DWORD PTR [esi+eax+8]
	mov	ebx, DWORD PTR [esi+eax+20]
	mov	edi, DWORD PTR [esi+eax]
	mov	ebp, DWORD PTR [esi+eax+4]
	mov	edx, DWORD PTR [esi+eax+12]
	mov	DWORD PTR _target$226619[esp+148], ecx
	mov	ecx, DWORD PTR [esi+eax+16]
	mov	DWORD PTR _target$226619[esp+140], edi
	mov	DWORD PTR _target$226619[esp+144], ebp
	mov	DWORD PTR _target$226619[esp+152], edx
	mov	DWORD PTR _target$226619[esp+156], ecx
	mov	DWORD PTR _target$226619[esp+160], ebx

; 1114 : 		int iWeight;
; 1115 : 
; 1116 : 		// If a sea target, we haven't checked the path yet.  Do that now
; 1117 : 		if (target.m_bAttackBySea)

	test	bl, bl
	je	SHORT $LN7@FindBestAt

; 1118 : 		{
; 1119 : 			if (!target.m_pMusterCity->isCoastal())

	push	-1
	mov	ecx, ebp
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN332@FindBestAt

; 1120 : 			{
; 1121 : 				continue;
; 1122 : 			}
; 1123 : 			if (!target.m_pTargetCity->isCoastal())

	push	-1
	mov	ecx, edi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN332@FindBestAt

; 1124 : 			{
; 1125 : 				continue;
; 1126 : 			}
; 1127 : 			CvPlot *pSeaPlotNearMuster = GetCoastalPlotAdjacentToTarget(target.m_pMusterCity->plot(), NULL);

	push	0
	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR _this$[esp+144]
	push	eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget

; 1128 : 			CvPlot *pSeaPlotNearTarget = GetCoastalPlotAdjacentToTarget(target.m_pTargetCity->plot(), NULL);

	push	0
	mov	ecx, edi
	mov	ebx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR _this$[esp+144]
	push	eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget

; 1129 : 			if(!GC.getStepFinder().DoesPathExist(m_pPlayer->GetID(), eEnemy, pSeaPlotNearMuster, pSeaPlotNearTarget))

	mov	edx, DWORD PTR _this$[esp+140]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _eEnemy$[esp+136]
	mov	ecx, DWORD PTR [ecx+44]
	push	eax
	push	ebx
	push	edx
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
	test	al, al
	je	$LN332@FindBestAt
	mov	ebx, DWORD PTR _target$226619[esp+160]
$LN7@FindBestAt:

; 1130 : 			{
; 1131 : 				continue;
; 1132 : 			}
; 1133 : 		}
; 1134 : 
; 1135 : 		iWeight = ScoreTarget(target, eAIOperationType);

	mov	eax, DWORD PTR _eAIOperationType$[esp+136]
	push	eax
	lea	ecx, DWORD PTR _target$226619[esp+144]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+148]
	call	?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ; CvMilitaryAI::ScoreTarget

; 1136 : 		weightedTargetList.push_back(target, iWeight);

	mov	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR _weightedElem$240952[esp+164], eax
	mov	eax, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+8
	mov	BYTE PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+17932, 0
	cmp	ecx, eax
	jne	SHORT $LN239@FindBestAt
	push	eax
	mov	ecx, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::GrowSize
	mov	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
$LN239@FindBestAt:
	mov	eax, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN242@FindBestAt
	mov	ecx, DWORD PTR _target$226619[esp+148]
	mov	edx, DWORD PTR _target$226619[esp+152]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _target$226619[esp+156]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR _weightedElem$240952[esp+164]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], edx
	mov	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
$LN242@FindBestAt:
	inc	ecx

; 1137 : 		iTargetsConsidered++;

	inc	DWORD PTR _iTargetsConsidered$[esp+140]
	mov	DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, ecx
	jmp	SHORT $LN12@FindBestAt
$LN332@FindBestAt:
	mov	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
$LN12@FindBestAt:

; 1110 : 	int iTargetsConsidered = 0;
; 1111 : 	for (int iI = 0; iI < prelimWeightedTargetList.size() && iTargetsConsidered < 25; iI++)

	mov	eax, DWORD PTR _iI$226615[esp+140]
	inc	eax
	add	esi, 28					; 0000001cH
	cmp	eax, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	mov	DWORD PTR _iI$226615[esp+140], eax
	jl	$LL333@FindBestAt
$LN337@FindBestAt:

; 1138 : 	}
; 1139 : 
; 1140 : 	// Didn't find anything, abort
; 1141 : 	if(weightedTargetList.size() == 0)

	test	ecx, ecx
	jne	SHORT $LN6@FindBestAt
$LN328@FindBestAt:

; 1142 : 	{
; 1143 : 		chosenTarget.m_pTargetCity = NULL;   // Call off the attack
; 1144 : 		if (piWinningScore)

	mov	eax, DWORD PTR _piWinningScore$[esp+136]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN5@FindBestAt

; 1145 : 		{
; 1146 : 			*piWinningScore = -1;

	mov	DWORD PTR [eax], -1
$LN5@FindBestAt:

; 1147 : 		}
; 1148 : 		return chosenTarget;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+136]
	mov	edx, DWORD PTR _chosenTarget$[esp+148]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _chosenTarget$[esp+144]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _chosenTarget$[esp+152]
	pop	edi
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR _chosenTarget$[esp+152]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR _chosenTarget$[esp+156]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+20], ecx
	pop	ebx

; 1177 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	16					; 00000010H
$LN6@FindBestAt:

; 1149 : 	}
; 1150 : 
; 1151 : 	weightedTargetList.SortItems();

	mov	edi, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	lea	esi, DWORD PTR [edi+edx*4]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	esi
	push	edi
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>

; 1152 : 	LogAttackTargets(eAIOperationType, eEnemy, weightedTargetList);

	mov	ebx, DWORD PTR _eEnemy$[esp+148]
	mov	ecx, DWORD PTR _eAIOperationType$[esp+148]
	mov	ebp, DWORD PTR _this$[esp+152]
	add	esp, 12					; 0000000cH
	push	OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	push	ebx
	push	ecx
	mov	ecx, ebp
	call	?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; CvMilitaryAI::LogAttackTargets

; 1153 : 
; 1154 : 	if(weightedTargetList.GetTotalWeight() > 0)

	mov	ecx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	xor	eax, eax
	test	ecx, ecx
	jbe	$LN4@FindBestAt
	mov	edx, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	add	edx, 24					; 00000018H
	mov	esi, ecx
$LL263@FindBestAt:
	add	eax, DWORD PTR [edx]
	add	edx, 28					; 0000001cH
	sub	esi, 1
	jne	SHORT $LL263@FindBestAt
	test	eax, eax
	jle	$LN4@FindBestAt

; 1155 : 	{
; 1156 : 		RandomNumberDelegate fcn;
; 1157 : 		fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48

; 1158 : 		int iNumChoices = max (1, (weightedTargetList.size() * 25 / 100));

	imul	ecx, 25					; 00000019H
	mov	DWORD PTR _fcn$226753[esp+140], edx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR $T240454[esp+140], eax
	cmp	eax, 1
	mov	DWORD PTR _fcn$226753[esp+144], OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	DWORD PTR $T240455[esp+140], 1
	lea	eax, DWORD PTR $T240454[esp+140]
	jg	SHORT $LN311@FindBestAt
	lea	eax, DWORD PTR $T240455[esp+140]
$LN311@FindBestAt:
	mov	eax, DWORD PTR [eax]

; 1159 : 		chosenTarget = weightedTargetList.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing attack target from top 25%% of choices");

	push	OFFSET $SG226787
	lea	ecx, DWORD PTR _fcn$226753[esp+144]
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T240456[esp+152]
	push	edx
	mov	ecx, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	call	?ChooseFromTopChoices@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@HPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseFromTopChoices
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax]

; 1160 : 		// if we need the winning score
; 1161 : 		if (piWinningScore)

	mov	edi, DWORD PTR _piWinningScore$[esp+136]
	mov	DWORD PTR _chosenTarget$[esp+144], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _chosenTarget$[esp+148], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _chosenTarget$[esp+140], esi
	mov	DWORD PTR _chosenTarget$[esp+152], ecx
	mov	DWORD PTR _chosenTarget$[esp+156], edx
	mov	DWORD PTR _chosenTarget$[esp+160], eax
	test	edi, edi
	je	SHORT $LN3@FindBestAt

; 1162 : 		{
; 1163 : 			*piWinningScore = ScoreTarget(chosenTarget, eAIOperationType);

	mov	ecx, DWORD PTR _eAIOperationType$[esp+136]
	push	ecx
	lea	edx, DWORD PTR _chosenTarget$[esp+144]
	push	edx
	mov	ecx, ebp
	call	?ScoreTarget@CvMilitaryAI@@QAEHAAUCvMilitaryTarget@@W4AIOperationTypes@@@Z ; CvMilitaryAI::ScoreTarget
	mov	DWORD PTR [edi], eax
$LN3@FindBestAt:

; 1164 : 		}
; 1165 : 		LogChosenTarget(eAIOperationType, eEnemy, chosenTarget);

	mov	ecx, DWORD PTR _eAIOperationType$[esp+136]
	lea	eax, DWORD PTR _chosenTarget$[esp+140]
	push	eax
	push	ebx
	push	ecx
	mov	ecx, ebp
	call	?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::LogChosenTarget

; 1166 : 	}
; 1167 : 	else

	jmp	SHORT $LN331@FindBestAt
$LN4@FindBestAt:

; 1168 : 	{
; 1169 : 		chosenTarget.m_pTargetCity = NULL;   // Call off the attack
; 1170 : 		if (piWinningScore)

	mov	eax, DWORD PTR _piWinningScore$[esp+136]
	xor	esi, esi
	test	eax, eax
	je	SHORT $LN331@FindBestAt

; 1171 : 		{
; 1172 : 			*piWinningScore = -1;

	mov	DWORD PTR [eax], -1
$LN331@FindBestAt:

; 1173 : 		}
; 1174 : 	}
; 1175 : 
; 1176 : 	return chosenTarget;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+136]
	mov	edx, DWORD PTR _chosenTarget$[esp+144]
	mov	ecx, DWORD PTR _chosenTarget$[esp+148]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _chosenTarget$[esp+152]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _chosenTarget$[esp+156]
	pop	edi
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR _chosenTarget$[esp+156]
	mov	DWORD PTR [eax+16], ecx

; 1177 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+136]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+20], edx
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$0:
	mov	eax, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, eax
	ret	0
__unwindfunclet$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z$1:
	mov	eax, DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ?$S1@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4IA, eax
	ret	0
__ehhandler$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ENDP ; CvMilitaryAI::FindBestAttackTarget
PUBLIC	?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestSneakAttack
; Function compile flags: /Ogtpy
;	COMDAT ?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iOperationID$ = -52					; size = 4
_target$ = -48						; size = 24
$T241154 = -24						; size = 24
_eEnemy$ = 8						; size = 4
?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestSneakAttack, COMDAT
; _this$ = ecx

; 501  : {

	sub	esp, 52					; 00000034H
	push	esi

; 502  : 	CvMilitaryTarget target;
; 503  : 	CvAIOperation* pOperation = 0;
; 504  : 	int iOperationID;
; 505  : 
; 506  : 	// Let's only allow us to be sneak attacking one opponent at a time, so abort if already have one of these operations active against any opponent
; 507  : 	if (m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_SNEAK_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+64]
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	14					; 0000000eH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN11@RequestSne
$LN29@RequestSne:

; 508  : 	{
; 509  : 		return false;

	xor	al, al
	pop	esi

; 553  : }

	add	esp, 52					; 00000034H
	ret	4
$LN11@RequestSne:

; 510  : 	}
; 511  : 	if (m_pPlayer->haveAIOperationOfType(AI_OPERATION_SNEAK_CITY_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	6
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al

; 512  : 	{
; 513  : 		return false;

	jne	SHORT $LN29@RequestSne
	push	ebx

; 514  : 	}
; 515  : 
; 516  : 	target = FindBestAttackTarget(AI_OPERATION_SNEAK_CITY_ATTACK, eEnemy);

	mov	ebx, DWORD PTR _eEnemy$[esp+56]
	push	ebp
	push	edi
	push	0
	push	ebx
	push	6
	lea	edx, DWORD PTR $T241154[esp+80]
	push	edx
	mov	ecx, esi
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	ecx, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+12]
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[esp+76], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[esp+80], edx
	mov	DWORD PTR _target$[esp+84], ecx

; 517  : 	if(target.m_pTargetCity)

	test	edi, edi
	je	$LN1@RequestSne

; 518  : 	{
; 519  : 		if(target.m_bAttackBySea)

	test	al, al
	je	SHORT $LN8@RequestSne

; 520  : 		{
; 521  : 			if(IsAttackReady(MUFORMATION_NAVAL_INVASION, AI_OPERATION_NAVAL_SNEAK_ATTACK))

	push	14					; 0000000eH
	push	12					; 0000000cH
	mov	ecx, esi
	call	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
	test	al, al
	je	SHORT $LN7@RequestSne

; 522  : 			{
; 523  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SNEAK_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	push	ebp
	push	edi
	mov	ecx, edi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	push	ebx
	push	14					; 0000000eH

; 524  : 				if(pOperation != NULL && !pOperation->ShouldAbort())
; 525  : 				{
; 526  : 					return true;

	jmp	SHORT $LN28@RequestSne
$LN7@RequestSne:

; 527  : 				}
; 528  : 			}
; 529  : 			else
; 530  : 			{
; 531  : 				m_iNumNavalAttacksRequested++;

	inc	DWORD PTR [esi+108]
	mov	eax, DWORD PTR [esi+108]

; 532  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	xor	ecx, ecx
	cmp	DWORD PTR [esi+104], eax
	pop	edi

; 548  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	setle	cl
	pop	ebp
	pop	ebx

; 549  : 			}
; 550  : 		}
; 551  : 	}
; 552  : 	return false;

	xor	al, al
	mov	DWORD PTR [esi+44], ecx
	pop	esi

; 553  : }

	add	esp, 52					; 00000034H
	ret	4
$LN8@RequestSne:

; 533  : 			}
; 534  : 		}
; 535  : 		else
; 536  : 		{
; 537  : 			if(IsAttackReady((GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE, AI_OPERATION_SNEAK_CITY_ATTACK))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN14@RequestSne
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	jne	SHORT $LN14@RequestSne
	mov	eax, 18					; 00000012H
	jmp	SHORT $LN15@RequestSne
$LN14@RequestSne:
	xor	eax, eax
$LN15@RequestSne:
	push	6
	push	eax
	mov	ecx, esi
	call	?IsAttackReady@CvMilitaryAI@@ABE_NW4MultiunitFormationTypes@@W4AIOperationTypes@@@Z ; CvMilitaryAI::IsAttackReady
	test	al, al
	je	SHORT $LN3@RequestSne

; 538  : 			{
; 539  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_SNEAK_CITY_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	push	ebp
	push	edi
	mov	ecx, edi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	push	ebx
	push	6
$LN28@RequestSne:
	mov	ecx, DWORD PTR [esi]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 540  : 				if(pOperation != NULL && !pOperation->ShouldAbort())

	test	eax, eax
	je	SHORT $LN1@RequestSne
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+72]
	call	eax
	test	al, al
	jne	SHORT $LN1@RequestSne
	pop	edi
	pop	ebp
	pop	ebx

; 541  : 				{
; 542  : 					return true;

	mov	al, 1
	pop	esi

; 553  : }

	add	esp, 52					; 00000034H
	ret	4
$LN3@RequestSne:

; 543  : 				}
; 544  : 			}
; 545  : 			else
; 546  : 			{
; 547  : 				m_iNumLandAttacksRequested++;

	inc	DWORD PTR [esi+104]
	mov	eax, DWORD PTR [esi+104]

; 548  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+108]
	setle	cl
	mov	DWORD PTR [esi+44], ecx
$LN1@RequestSne:
	pop	edi
	pop	ebp
	pop	ebx

; 549  : 			}
; 550  : 		}
; 551  : 	}
; 552  : 	return false;

	xor	al, al
	pop	esi

; 553  : }

	add	esp, 52					; 00000034H
	ret	4
?RequestSneakAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestSneakAttack
_TEXT	ENDS
PUBLIC	?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestShowOfForce
; Function compile flags: /Ogtpy
;	COMDAT ?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_target$ = -48						; size = 24
$T241182 = -24						; size = 24
_eEnemy$ = 8						; size = 4
?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestShowOfForce, COMDAT
; _this$ = ecx

; 557  : {

	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi

; 558  : 	CvMilitaryTarget target;
; 559  : 
; 560  : 	target = FindBestAttackTarget(AI_OPERATION_SNEAK_CITY_ATTACK, eEnemy);

	mov	edi, DWORD PTR _eEnemy$[esp+56]
	push	0
	push	edi
	push	6
	lea	eax, DWORD PTR $T241182[esp+72]
	push	eax
	mov	esi, ecx
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	ebx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[esp+68], ebx
	mov	ebx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$[esp+72], ebx
	mov	ebx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[esp+76], ebx

; 561  : 	if(target.m_pTargetCity)

	test	ecx, ecx
	je	SHORT $LN1@RequestSho

; 562  : 	{
; 563  : 		if (target.m_bAttackBySea)
; 564  : 		{
; 565  : 			CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SNEAK_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	push	edx
	push	ecx
	test	al, al
	je	SHORT $LN4@RequestSho
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	push	edi
	push	14					; 0000000eH
$LN10@RequestSho:
	mov	ecx, DWORD PTR [esi]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 566  : 			if(pOperation != NULL && !pOperation->ShouldAbort())

	test	eax, eax
	je	SHORT $LN1@RequestSho
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+72]
	call	eax
	test	al, al
	jne	SHORT $LN1@RequestSho
	pop	edi
	pop	esi

; 567  : 			{
; 568  : 				return true;

	mov	al, 1
	pop	ebx

; 582  : }

	add	esp, 48					; 00000030H
	ret	4
$LN4@RequestSho:

; 569  : 			}
; 570  : 		}
; 571  : 		else
; 572  : 		{
; 573  : 			CvAIOperation* pOperation = m_pPlayer->addAIOperation(AI_OPERATION_SMALL_CITY_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	push	edi
	push	7

; 574  : 			if(pOperation != NULL && !pOperation->ShouldAbort())
; 575  : 			{
; 576  : 				return true;

	jmp	SHORT $LN10@RequestSho
$LN1@RequestSho:
	pop	edi
	pop	esi

; 577  : 			}
; 578  : 		}
; 579  : 	}
; 580  : 
; 581  : 	return false;

	xor	al, al
	pop	ebx

; 582  : }

	add	esp, 48					; 00000030H
	ret	4
?RequestShowOfForce@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestShowOfForce
_TEXT	ENDS
PUBLIC	?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ; CvMilitaryAI::RequestBasicAttack
; Function compile flags: /Ogtpy
;	COMDAT ?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
$T241190 = -24						; size = 24
_eEnemy$ = 8						; size = 4
_iNumUnitsWillingBuild$ = 12				; size = 4
?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z PROC ; CvMilitaryAI::RequestBasicAttack, COMDAT
; _this$ = ecx

; 624  : 	CvMilitaryTarget target;
; 625  : 
; 626  : 	target = FindBestAttackTarget(AI_OPERATION_BASIC_CITY_ATTACK, eEnemy);

	mov	eax, DWORD PTR _eEnemy$[esp-4]
	sub	esp, 24					; 00000018H
	push	esi
	push	0
	push	eax
	mov	esi, ecx
	push	2
	lea	ecx, DWORD PTR $T241190[esp+40]
	push	ecx
	mov	ecx, esi
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget

; 627  : 	return RequestSpecificAttack(target, iNumUnitsWillingBuild);

	mov	edx, DWORD PTR _iNumUnitsWillingBuild$[esp+24]
	push	edx
	mov	edx, DWORD PTR [eax]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+16], edx
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, esi
	call	?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ; CvMilitaryAI::RequestSpecificAttack

; 628  : }

	pop	esi
	add	esp, 24					; 00000018H
	ret	8
?RequestBasicAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ENDP ; CvMilitaryAI::RequestBasicAttack
_TEXT	ENDS
PUBLIC	?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ; CvMilitaryAI::RequestPureNavalAttack
; Function compile flags: /Ogtpy
;	COMDAT ?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_iNumRequiredSlots$ = -52				; size = 4
_target$ = -48						; size = 24
$T241197 = -24						; size = 24
_iLandReservesUsed$ = 8					; size = 4
_eEnemy$ = 8						; size = 4
_iNumUnitsWillingBuild$ = 12				; size = 4
?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z PROC ; CvMilitaryAI::RequestPureNavalAttack, COMDAT
; _this$ = ecx

; 632  : {

	sub	esp, 52					; 00000034H
	push	ebx

; 633  : 	CvAIOperation* pOperation = NULL;
; 634  : 	CvMilitaryTarget target;
; 635  : 	int iNumRequiredSlots = 0;
; 636  : 	int iLandReservesUsed = 0;
; 637  : 	int iFilledSlots = 0;
; 638  : 
; 639  : 	target = FindBestAttackTarget(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, eEnemy);

	mov	ebx, DWORD PTR _eEnemy$[esp+52]
	push	ebp
	push	esi
	push	edi
	push	0
	push	ebx
	push	18					; 00000012H
	lea	eax, DWORD PTR $T241197[esp+80]
	push	eax
	mov	edi, ecx
	mov	DWORD PTR _iNumRequiredSlots$[esp+84], 0
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[esp+76], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$[esp+80], edx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[esp+84], ecx
	mov	DWORD PTR _target$[esp+88], edx

; 640  : 	if(target.m_pTargetCity)

	test	esi, esi
	je	SHORT $LN1@RequestPur

; 641  : 	{
; 642  : 		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_PURE_NAVAL_CITY_ATTACK, true, &iNumRequiredSlots, &iLandReservesUsed);

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR _iLandReservesUsed$[esp+64]
	push	eax
	lea	ecx, DWORD PTR _iNumRequiredSlots$[esp+72]
	push	ecx
	push	1
	push	17					; 00000011H
	push	edx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots

; 643  : 		if((iNumRequiredSlots - iFilledSlots) <= iNumUnitsWillingBuild)

	mov	ecx, DWORD PTR _iNumRequiredSlots$[esp+88]
	sub	ecx, eax
	add	esp, 20					; 00000014H
	cmp	ecx, DWORD PTR _iNumUnitsWillingBuild$[esp+64]
	jg	SHORT $LN1@RequestPur

; 644  : 		{
; 645  : 			pOperation = m_pPlayer->addAIOperation(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	push	ebp
	push	esi
	mov	ecx, esi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ebx
	push	18					; 00000012H
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 646  : 		}
; 647  : 
; 648  : 		if(pOperation != NULL && !pOperation->ShouldAbort())

	test	eax, eax
	je	SHORT $LN1@RequestPur
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+72]
	call	eax
	test	al, al
	jne	SHORT $LN1@RequestPur
	pop	edi
	pop	esi
	pop	ebp

; 649  : 		{
; 650  : 			return true;

	mov	al, 1
	pop	ebx

; 654  : }

	add	esp, 52					; 00000034H
	ret	8
$LN1@RequestPur:
	pop	edi
	pop	esi
	pop	ebp

; 651  : 		}
; 652  : 	}
; 653  : 	return false;

	xor	al, al
	pop	ebx

; 654  : }

	add	esp, 52					; 00000034H
	ret	8
?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ENDP ; CvMilitaryAI::RequestPureNavalAttack
_TEXT	ENDS
PUBLIC	?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ; CvMilitaryAI::RequestCityStateAttack
; Function compile flags: /Ogtpy
;	COMDAT ?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iOperationID$241241 = -56				; size = 4
_iOperationID$241218 = -56				; size = 4
_iLandReservesUsed$241246 = -52				; size = 4
_iLandReservesUsed$241223 = -52				; size = 4
_target$ = -48						; size = 24
$T241204 = -24						; size = 24
_iNumRequiredSlots$241245 = 8				; size = 4
_iNumRequiredSlots$241222 = 8				; size = 4
_eEnemy$ = 8						; size = 4
?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z PROC ; CvMilitaryAI::RequestCityStateAttack, COMDAT
; _this$ = ecx

; 658  : {

	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp

; 659  : 	CvMilitaryTarget target;
; 660  : 	CvAIOperation* pOperation = 0;
; 661  : 
; 662  : 	target = FindBestAttackTarget(AI_OPERATION_CITY_STATE_ATTACK, eEnemy);

	mov	ebp, DWORD PTR _eEnemy$[esp+60]
	push	esi
	push	edi
	push	0
	push	ebp
	push	15					; 0000000fH
	lea	eax, DWORD PTR $T241204[esp+84]
	push	eax
	mov	esi, ecx
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	ecx, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _target$[esp+80], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _target$[esp+84], edx
	mov	DWORD PTR _target$[esp+88], ecx

; 663  : 	if(target.m_pTargetCity)

	test	edi, edi
	je	$LN9@RequestCit

; 664  : 	{
; 665  : 		if(target.m_bAttackBySea)
; 666  : 		{
; 667  : 			if(IsAttackReady(MUFORMATION_CITY_STATE_INVASION, AI_OPERATION_CITY_STATE_NAVAL_ATTACK))

	mov	ecx, DWORD PTR [esi]
	push	0
	lea	edx, DWORD PTR _iOperationID$241218[esp+76]
	push	-1
	push	edx
	test	al, al
	je	$LN8@RequestCit
	push	16					; 00000010H
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN36@RequestCit
	mov	eax, DWORD PTR _iOperationID$241218[esp+72]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	cmp	DWORD PTR [eax+56], 1
	jne	SHORT $LN37@RequestCit
$LN36@RequestCit:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _iLandReservesUsed$241223[esp+72]
	push	ecx
	lea	edx, DWORD PTR _iNumRequiredSlots$241222[esp+72]
	push	edx
	push	1
	push	13					; 0000000dH
	push	eax
	mov	DWORD PTR _iNumRequiredSlots$241222[esp+88], 0
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	cmp	eax, DWORD PTR _iNumRequiredSlots$241222[esp+68]
	jl	SHORT $LN37@RequestCit

; 668  : 			{
; 669  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_CITY_STATE_NAVAL_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	push	ebx
	push	edi
	mov	ecx, edi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	push	ebp
	push	16					; 00000010H
$LN41@RequestCit:
	mov	ecx, DWORD PTR [esi]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 670  : 				if(pOperation != NULL && !pOperation->ShouldAbort())

	test	eax, eax
	je	SHORT $LN1@RequestCit
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN1@RequestCit:
	pop	edi
	pop	esi
	pop	ebp

; 671  : 				{
; 672  : 					return true;

	mov	al, 1
	pop	ebx

; 701  : }

	add	esp, 56					; 00000038H
	ret	4
$LN37@RequestCit:

; 673  : 				}
; 674  : 			}
; 675  : 			else
; 676  : 			{
; 677  : 				m_iNumNavalAttacksRequested++;

	inc	DWORD PTR [esi+108]
	mov	eax, DWORD PTR [esi+108]

; 678  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	xor	ecx, ecx
	cmp	DWORD PTR [esi+104], eax
	pop	edi

; 694  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	setle	cl
	mov	al, 1
	mov	DWORD PTR [esi+44], ecx
	pop	esi
	pop	ebp
	pop	ebx

; 701  : }

	add	esp, 56					; 00000038H
	ret	4
$LN8@RequestCit:

; 679  : 			}
; 680  : 		}
; 681  : 		else
; 682  : 		{
; 683  : 			if(IsAttackReady(MUFORMATION_CITY_STATE_ATTACK_FORCE, AI_OPERATION_CITY_STATE_ATTACK))

	push	15					; 0000000fH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN38@RequestCit
	mov	eax, DWORD PTR _iOperationID$241241[esp+72]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	cmp	DWORD PTR [eax+56], 1
	jne	SHORT $LN39@RequestCit
$LN38@RequestCit:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _iLandReservesUsed$241246[esp+72]
	push	ecx
	lea	edx, DWORD PTR _iNumRequiredSlots$241245[esp+72]
	push	edx
	push	0
	push	1
	push	eax
	mov	DWORD PTR _iNumRequiredSlots$241245[esp+88], 0
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H
	cmp	eax, DWORD PTR _iNumRequiredSlots$241245[esp+68]
	jl	SHORT $LN39@RequestCit

; 684  : 			{
; 685  : 				pOperation = m_pPlayer->addAIOperation(AI_OPERATION_CITY_STATE_ATTACK, eEnemy, target.m_pTargetCity->getArea(), target.m_pTargetCity, target.m_pMusterCity);

	push	ebx
	push	edi
	mov	ecx, edi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	push	ebp
	push	15					; 0000000fH

; 686  : 				if(pOperation != NULL && !pOperation->ShouldAbort())
; 687  : 				{
; 688  : 					return true;

	jmp	$LN41@RequestCit
$LN39@RequestCit:

; 689  : 				}
; 690  : 			}
; 691  : 			else
; 692  : 			{
; 693  : 				m_iNumLandAttacksRequested++;

	inc	DWORD PTR [esi+104]
	mov	eax, DWORD PTR [esi+104]

; 694  : 				m_eArmyTypeBeingBuilt = (m_iNumLandAttacksRequested > m_iNumNavalAttacksRequested) ? ARMY_TYPE_LAND : ARMY_TYPE_NAVAL_INVASION;

	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+108]
	pop	edi
	setle	cl
	mov	al, 1
	mov	DWORD PTR [esi+44], ecx
	pop	esi
	pop	ebp
	pop	ebx

; 701  : }

	add	esp, 56					; 00000038H
	ret	4
$LN9@RequestCit:
	pop	edi
	pop	esi
	pop	ebp

; 695  : 			}
; 696  : 		}
; 697  : 
; 698  : 		return true;
; 699  : 	}
; 700  : 	return false;

	xor	al, al
	pop	ebx

; 701  : }

	add	esp, 56					; 00000038H
	ret	4
?RequestCityStateAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@@Z ENDP ; CvMilitaryAI::RequestCityStateAttack
_TEXT	ENDS
PUBLIC	?UpdateOperations@CvMilitaryAI@@AAEXXZ		; CvMilitaryAI::UpdateOperations
EXTRN	?GetPlayerTargetValue@CvDiplomacyAI@@QBE?AW4TargetValueTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetPlayerTargetValue
EXTRN	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs
EXTRN	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarProjection
EXTRN	?GetLastWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetLastWarProjection
EXTRN	?GetNumTimesNuked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetNumTimesNuked
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ:PROC ; CvAIOperation::GetEnemy
EXTRN	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isForcePeace
;	COMDAT ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
_BSS	SEGMENT
?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A DB 04610H DUP (?) ; `CvMilitaryAI::UpdateOperations'::`166'::weightedTargetList
_BSS	ENDS
;	COMDAT ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA
_BSS	SEGMENT
?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA DD 01H DUP (?) ; `CvMilitaryAI::UpdateOperations'::`166'::$S2
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateOperations@CvMilitaryAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateOperations@CvMilitaryAI@@AAEXXZ$0
__ehfuncinfo$?UpdateOperations@CvMilitaryAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateOperations@CvMilitaryAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?UpdateOperations@CvMilitaryAI@@AAEXXZ
_TEXT	SEGMENT
_bWillingToAcceptRisk$ = -109				; size = 1
_iOperationID$ = -108					; size = 4
_iOperationID$241383 = -104				; size = 4
_iNumRequiredSlots$ = -104				; size = 4
_eStrategyFightAWar$ = -100				; size = 4
tv1993 = -96						; size = 4
_iOperationID$241392 = -96				; size = 4
_iLandReservesUsed$ = -96				; size = 4
_eStrategyBarbs$ = -92					; size = 4
_iBarbLoop$ = -88					; size = 4
_iOperationID$241401 = -84				; size = 4
_iOperationID$241407 = -80				; size = 4
_eTargetType$227857 = -76				; size = 4
_iLoop$227801 = -76					; size = 4
_fcn$227877 = -72					; size = 8
_iScore$227863 = -72					; size = 4
_eBuildCriticalDefenses$ = -72				; size = 4
_chosenTarget$227879 = -64				; size = 24
_target$227862 = -64					; size = 24
_weightedElem$241648 = -40				; size = 28
$T241265 = -40						; size = 24
__$EHRec$ = -12						; size = 12
?UpdateOperations@CvMilitaryAI@@AAEXXZ PROC		; CvMilitaryAI::UpdateOperations, COMDAT
; _this$ = ecx

; 2666 : {

	push	-1
	push	__ehhandler$?UpdateOperations@CvMilitaryAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2667 : 	AI_PERF_FORMAT("Military-AI-perf.csv", ("UpdateOperations, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 2668 : 
; 2669 : 	int iOperationID;
; 2670 : 	int iNumRequiredSlots;
; 2671 : 	int iLandReservesUsed;
; 2672 : 	int iFilledSlots;
; 2673 : 
; 2674 : 	int iPlayerLoop;
; 2675 : 	PlayerTypes eLoopPlayer;
; 2676 : 	WarStateTypes eWarState;
; 2677 : 	CvAIOperation* pOperation;
; 2678 : 
; 2679 : 	MilitaryAIStrategyTypes eStrategyBarbs = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_ERADICATE_BARBARIANS");

	push	0
	mov	esi, ecx
	push	OFFSET $SG227729
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2680 : 	MilitaryAIStrategyTypes eStrategyFightAWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET $SG227732
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eStrategyBarbs$[esp+136], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2681 : 	MilitaryAIStrategyTypes eBuildCriticalDefenses = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_EMPIRE_DEFENSE_CRITICAL");

	push	0
	push	OFFSET $SG227735
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eStrategyFightAWar$[esp+136], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2682 : 
; 2683 : 	// SEE IF THERE ARE OPERATIONS THAT NEED TO BE ABORTED
; 2684 : 
; 2685 : 	// Are we willing to risk pressing forward vs. barbarians?
; 2686 : 	bool bWillingToAcceptRisk = (m_iTotalThreatWeight / 2) < GetBarbarianThreatTotal();

	mov	ecx, esi
	mov	DWORD PTR _eBuildCriticalDefenses$[esp+128], eax
	call	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::ScanForBarbarians
	mov	eax, DWORD PTR [esi+92]
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2192
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+88]
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	add	ecx, eax
	mov	eax, DWORD PTR [esi+40]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	eax, ecx

; 2687 : 	if(m_pPlayer->GetPlayerTraits()->GetLandBarbarianConversionPercent() > 0)

	mov	ecx, DWORD PTR [esi]
	setl	BYTE PTR _bWillingToAcceptRisk$[esp+128]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+100]
	test	eax, eax
	jle	SHORT $LN114@UpdateOper

; 2688 : 	{
; 2689 : 		bWillingToAcceptRisk = true;

	mov	BYTE PTR _bWillingToAcceptRisk$[esp+128], 1
$LN114@UpdateOper:

; 2690 : 	}
; 2691 : 
; 2692 : 	// if they have one of our civilians
; 2693 : 	CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

	mov	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2694 : 	CvUnit* pLoopUnit = NULL;
; 2695 : 	int iBarbLoop;
; 2696 : 	for (pLoopUnit = BarbPlayer.firstUnit(&iBarbLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iBarbLoop))

	push	0
	lea	ecx, DWORD PTR _iBarbLoop$[esp+132]
	add	ebp, 3983868				; 003cc9fcH
	push	ecx
	mov	ecx, ebp
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN111@UpdateOper
	npad	2
$LL113@UpdateOper:

; 2697 : 	{
; 2698 : 		if (pLoopUnit->GetOriginalOwner() == m_pPlayer->GetID() && (pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER))

	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR [edx+44]
	mov	ecx, edi
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	cmp	eax, ebx
	jne	SHORT $LN112@UpdateOper
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	SHORT $LN109@UpdateOper
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN109@UpdateOper
$LN112@UpdateOper:

; 2694 : 	CvUnit* pLoopUnit = NULL;
; 2695 : 	int iBarbLoop;
; 2696 : 	for (pLoopUnit = BarbPlayer.firstUnit(&iBarbLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iBarbLoop))

	push	0
	lea	eax, DWORD PTR _iBarbLoop$[esp+132]
	push	eax
	mov	ecx, ebp
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL113@UpdateOper

; 2697 : 	{
; 2698 : 		if (pLoopUnit->GetOriginalOwner() == m_pPlayer->GetID() && (pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER))

	jmp	SHORT $LN111@UpdateOper
$LN109@UpdateOper:

; 2699 : 		{
; 2700 : 			bWillingToAcceptRisk = true;

	mov	BYTE PTR _bWillingToAcceptRisk$[esp+128], 1
$LN111@UpdateOper:

; 2701 : 			break;
; 2702 : 		}
; 2703 : 	}
; 2704 : 
; 2705 : 	//
; 2706 : 	// Operations vs. Barbarians
; 2707 : 	//
; 2708 : 	// If have aborted the eradicate barbarian strategy or if the threat level from civs is significantly higher than from barbs, we better abort all of them
; 2709 : 	if(!IsUsingStrategy(eStrategyBarbs) || IsUsingStrategy(eStrategyFightAWar) || !bWillingToAcceptRisk)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _eStrategyBarbs$[esp+128]
	mov	cl, BYTE PTR [eax+ecx]
	test	cl, cl
	je	SHORT $LL106@UpdateOper
	mov	edx, DWORD PTR _eStrategyFightAWar$[esp+128]
	cmp	BYTE PTR [eax+edx], 0
	jne	SHORT $LL106@UpdateOper
	cmp	BYTE PTR _bWillingToAcceptRisk$[esp+128], 0
	jne	SHORT $LN416@UpdateOper
$LL106@UpdateOper:

; 2710 : 	{
; 2711 : 		bool bFoundOneToDelete = true;
; 2712 : 		while(bFoundOneToDelete)
; 2713 : 		{
; 2714 : 			bFoundOneToDelete = false;
; 2715 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_DESTROY_BARBARIAN_CAMP, &iOperationID))

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	3
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN416@UpdateOper

; 2716 : 			{
; 2717 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	ecx, DWORD PTR _iOperationID$[esp+128]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
	jmp	SHORT $LL106@UpdateOper
$LN416@UpdateOper:

; 2718 : 				bFoundOneToDelete = true;
; 2719 : 			}
; 2720 : 		}
; 2721 : 	}
; 2722 : 
; 2723 : 	//
; 2724 : 	// Operation vs. Other Civs
; 2725 : 	//
; 2726 : 	// Are our wars over?
; 2727 : 	if(!IsUsingStrategy(eStrategyFightAWar))

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR _eStrategyFightAWar$[esp+128]
	mov	al, BYTE PTR [edx+ecx]
	test	al, al
	jne	$LN103@UpdateOper
$LL102@UpdateOper:

; 2731 : 		{
; 2732 : 			bFoundOneToDelete = false;
; 2733 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID))

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	2
	xor	bl, bl
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN100@UpdateOper

; 2734 : 			{
; 2735 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	ecx, DWORD PTR _iOperationID$[esp+128]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax

; 2736 : 				bFoundOneToDelete = true;

	mov	bl, 1
$LN100@UpdateOper:

; 2737 : 			}
; 2738 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_PILLAGE_ENEMY, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	5
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN99@UpdateOper

; 2739 : 			{
; 2740 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax

; 2741 : 				bFoundOneToDelete = true;

	mov	bl, 1
$LN99@UpdateOper:

; 2742 : 			}
; 2743 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_RAPID_RESPONSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	1
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN98@UpdateOper

; 2744 : 			{
; 2745 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax

; 2746 : 				bFoundOneToDelete = true;

	mov	bl, 1
$LN98@UpdateOper:

; 2747 : 			}
; 2748 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	0
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN97@UpdateOper

; 2749 : 			{
; 2750 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax

; 2751 : 				bFoundOneToDelete = true;

	mov	bl, 1
$LN97@UpdateOper:

; 2752 : 			}
; 2753 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	13					; 0000000dH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN96@UpdateOper

; 2754 : 			{
; 2755 : 				m_pPlayer->getAIOperation(iOperationID)->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
	jmp	$LL102@UpdateOper
$LN96@UpdateOper:

; 2728 : 	{
; 2729 : 		bool bFoundOneToDelete = true;
; 2730 : 		while(bFoundOneToDelete)

	test	bl, bl
	jne	$LL102@UpdateOper

; 2756 : 				bFoundOneToDelete = true;
; 2757 : 			}
; 2758 : 		}
; 2759 : 	}
; 2760 : 
; 2761 : 	else

	jmp	$LN56@UpdateOper
$LN103@UpdateOper:

; 2762 : 	{
; 2763 : 		// Are any of our strategies inappropriate given the type of war we are fighting
; 2764 : 		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
	xor	ebp, ebp
$LL94@UpdateOper:

; 2765 : 		{
; 2766 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 2767 : 
; 2768 : 			// Is this a player we have relations with?
; 2769 : 			if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [ecx+44]
	je	$LN93@UpdateOper
	push	0
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	$LN93@UpdateOper

; 2770 : 			{
; 2771 : 				// If we've made peace with this player, abort all operations related to him
; 2772 : 				// slewis - added the check for STATE_ALL_WARS_LOSING so that if the player is losing all wars, that they will cancel scheduled attacks
; 2773 : 				if(GET_TEAM(m_pPlayer->getTeam()).isForcePeace(GET_PLAYER(eLoopPlayer).getTeam()) || m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+ebp+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN150@UpdateOper
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN151@UpdateOper
$LN150@UpdateOper:
	or	ecx, -1
$LN151@UpdateOper:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN159@UpdateOper
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN160@UpdateOper
$LN159@UpdateOper:
	or	eax, -1
$LN160@UpdateOper:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isForcePeace@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isForcePeace
	test	al, al
	jne	SHORT $LN413@UpdateOper
	mov	ecx, DWORD PTR [esi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	$LN85@UpdateOper
$LN413@UpdateOper:

; 2774 : 				{
; 2775 : 					pOperation = GetSneakAttackOperation(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	edi
	lea	eax, DWORD PTR _iOperationID$241383[esp+136]
	push	eax
	push	6
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN168@UpdateOper
	mov	ecx, DWORD PTR _iOperationID$241383[esp+128]
	push	ecx
	jmp	SHORT $LN433@UpdateOper
$LN168@UpdateOper:
	mov	ecx, DWORD PTR [esi]
	push	0
	push	edi
	lea	edx, DWORD PTR _iOperationID$241383[esp+136]
	push	edx
	push	14					; 0000000eH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN417@UpdateOper
	mov	eax, DWORD PTR _iOperationID$241383[esp+128]
	push	eax
$LN433@UpdateOper:
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 2776 : 					if(pOperation)

	test	eax, eax
	je	SHORT $LN417@UpdateOper

; 2777 : 					{
; 2778 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
$LN417@UpdateOper:

; 2779 : 					}
; 2780 : 					pOperation = GetBasicAttackOperation(eLoopPlayer);

	push	0
	push	edi
	lea	ecx, DWORD PTR _iOperationID$241392[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	2
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	mov	ecx, DWORD PTR [esi]
	test	al, al
	je	SHORT $LN173@UpdateOper
	mov	edx, DWORD PTR _iOperationID$241392[esp+128]
	push	edx
	jmp	SHORT $LN434@UpdateOper
$LN173@UpdateOper:
	push	0
	push	edi
	lea	eax, DWORD PTR _iOperationID$241392[esp+136]
	push	eax
	push	13					; 0000000dH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN421@UpdateOper
	mov	ecx, DWORD PTR _iOperationID$241392[esp+128]
	push	ecx
	mov	ecx, DWORD PTR [esi]
$LN434@UpdateOper:
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 2781 : 					if(pOperation)

	test	eax, eax
	je	SHORT $LN421@UpdateOper

; 2782 : 					{
; 2783 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
$LN421@UpdateOper:

; 2784 : 					}
; 2785 : 					pOperation = GetShowOfForceOperation(eLoopPlayer);

	push	0
	push	edi
	lea	ecx, DWORD PTR _iOperationID$241401[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	7
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN423@UpdateOper
	mov	edx, DWORD PTR _iOperationID$241401[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 2786 : 					if(pOperation)

	test	eax, eax
	je	SHORT $LN423@UpdateOper

; 2787 : 					{
; 2788 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
$LN423@UpdateOper:

; 2789 : 					}
; 2790 : 					pOperation = GetPureNavalAttackOperation(eLoopPlayer);

	push	0
	push	edi
	lea	ecx, DWORD PTR _iOperationID$241407[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	18					; 00000012H
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN85@UpdateOper
	mov	edx, DWORD PTR _iOperationID$241407[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 2791 : 					if(pOperation)

	test	eax, eax
	je	SHORT $LN85@UpdateOper

; 2792 : 					{
; 2793 : 						pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
$LN85@UpdateOper:

; 2794 : 					}
; 2795 : 				}
; 2796 : 
; 2797 : 				eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState

; 2798 : 				switch(eWarState)

	cmp	eax, 5
	ja	$LN93@UpdateOper
	jmp	DWORD PTR $LN440@UpdateOper[eax*4]
$LN82@UpdateOper:

; 2799 : 				{
; 2800 : 					// If we are dominant, shouldn't be running a defensive strategy
; 2801 : 				case WAR_STATE_NEARLY_WON:
; 2802 : 				case WAR_STATE_OFFENSIVE:
; 2803 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_RAPID_RESPONSE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	1
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN411@UpdateOper

; 2804 : 					{
; 2805 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	ebx, eax

; 2806 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, ebx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, edi
	jne	SHORT $LN411@UpdateOper

; 2807 : 						{
; 2808 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+80]
	push	12					; 0000000cH
	mov	ecx, ebx
	call	edx
$LN411@UpdateOper:

; 2809 : 						}
; 2810 : 					}
; 2811 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID))

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	0

; 2812 : 					{
; 2813 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);
; 2814 : 						if(pOperation->GetEnemy() == eLoopPlayer)
; 2815 : 						{
; 2816 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);
; 2817 : 						}
; 2818 : 					}
; 2819 : 					break;

	jmp	$LN437@UpdateOper
$LN77@UpdateOper:

; 2820 : 
; 2821 : 					// If we are losing, make sure attacks are not running
; 2822 : 				case WAR_STATE_DEFENSIVE:
; 2823 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	2
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN409@UpdateOper

; 2824 : 					{
; 2825 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	ebx, eax

; 2826 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, ebx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, edi
	jne	SHORT $LN409@UpdateOper

; 2827 : 						{
; 2828 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+80]
	push	12					; 0000000cH
	mov	ecx, ebx
	call	edx
$LN409@UpdateOper:

; 2829 : 						}
; 2830 : 					}
; 2831 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_PILLAGE_ENEMY, &iOperationID))

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	5
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN408@UpdateOper

; 2832 : 					{
; 2833 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+128]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	ebx, eax

; 2834 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, ebx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, edi
	jne	SHORT $LN408@UpdateOper

; 2835 : 						{
; 2836 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	mov	ecx, ebx
	call	eax
$LN408@UpdateOper:

; 2837 : 						}
; 2838 : 					}
; 2839 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	13					; 0000000dH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	$LN93@UpdateOper

; 2840 : 					{
; 2841 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	ebx, eax

; 2842 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, ebx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, edi
	jne	$LN93@UpdateOper

; 2843 : 						{
; 2844 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+80]
	push	12					; 0000000cH
	mov	ecx, ebx
	call	edx

; 2845 : 						}
; 2846 : 					}
; 2847 : 					break;

	jmp	$LN93@UpdateOper
$LN70@UpdateOper:

; 2848 : 
; 2849 : 					// If nearly defeated, call off all operations in enemy territory
; 2850 : 				case WAR_STATE_NEARLY_DEFEATED:
; 2851 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_BASIC_CITY_ATTACK, &iOperationID))

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	2
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN406@UpdateOper

; 2852 : 					{
; 2853 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+128]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	ebx, eax

; 2854 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, ebx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, edi
	jne	SHORT $LN406@UpdateOper

; 2855 : 						{
; 2856 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	mov	ecx, ebx
	call	eax
$LN406@UpdateOper:

; 2857 : 						}
; 2858 : 					}
; 2859 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_PILLAGE_ENEMY, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	5
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN405@UpdateOper

; 2860 : 					{
; 2861 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	edx, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	edx
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	ebx, eax

; 2862 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, ebx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, edi
	jne	SHORT $LN405@UpdateOper

; 2863 : 						{
; 2864 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+80]
	push	12					; 0000000cH
	mov	ecx, ebx
	call	edx
$LN405@UpdateOper:

; 2865 : 						}
; 2866 : 					}
; 2867 : 					if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_NAVAL_ATTACK, &iOperationID))

	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	13					; 0000000dH
$LN437@UpdateOper:
	mov	ecx, DWORD PTR [esi]
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN93@UpdateOper

; 2868 : 					{
; 2869 : 						pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+128]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation
	mov	ebx, eax

; 2870 : 						if(pOperation->GetEnemy() == eLoopPlayer)

	mov	ecx, ebx
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	cmp	eax, edi
	jne	SHORT $LN93@UpdateOper

; 2871 : 						{
; 2872 : 							pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	mov	ecx, ebx
	call	eax
$LN93@UpdateOper:
	add	ebp, 63236				; 0000f704H
	inc	edi
	cmp	ebp, 1391192				; 00153a58H
	jl	$LL94@UpdateOper

; 2873 : 						}
; 2874 : 					}
; 2875 : 					break;
; 2876 : 
; 2877 : 				case WAR_STATE_CALM:
; 2878 : 				case WAR_STATE_STALEMATE:
; 2879 : 				default:
; 2880 : 					break;
; 2881 : 				}
; 2882 : 			}
; 2883 : 		}
; 2884 : 
; 2885 : 		// Are there city defense operations for cities that no longer need defending?
; 2886 : 		CvCity* pLoopCity;
; 2887 : 		int iLoop;
; 2888 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$227801[esp+132]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN418@UpdateOper
	npad	5
$LL62@UpdateOper:

; 2889 : 		{
; 2890 : 			if(pLoopCity->getThreatValue() == 0)

	mov	ecx, edi
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	test	eax, eax
	jne	SHORT $LN61@UpdateOper

; 2891 : 			{
; 2892 : 				if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID, NO_PLAYER, pLoopCity->plot()))

	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	-1
	lea	edx, DWORD PTR _iOperationID$[esp+136]
	push	edx
	push	0
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN61@UpdateOper

; 2893 : 				{
; 2894 : 					pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	eax, DWORD PTR _iOperationID$[esp+128]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 2895 : 					pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
$LN61@UpdateOper:
	push	0
	lea	ecx, DWORD PTR _iLoop$227801[esp+132]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL62@UpdateOper
$LN418@UpdateOper:

; 2896 : 				}
; 2897 : 			}
; 2898 : 		}
; 2899 : 
; 2900 : 		// Are we running a rapid response tactic and the overall threat level is very low?
; 2901 : 		if(m_iTotalThreatWeight <= GC.getAI_MILITARY_THREAT_WEIGHT_MAJOR())

	mov	edx, DWORD PTR [esi+40]
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2168
	jg	SHORT $LN56@UpdateOper

; 2902 : 		{
; 2903 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_RAPID_RESPONSE, &iOperationID))

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	1
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN56@UpdateOper

; 2904 : 			{
; 2905 : 				pOperation = m_pPlayer->getAIOperation(iOperationID);

	mov	ecx, DWORD PTR _iOperationID$[esp+128]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getAIOperation@CvPlayer@@QAEPAVCvAIOperation@@H@Z ; CvPlayer::getAIOperation

; 2906 : 				pOperation->Kill(AI_ABORT_WAR_STATE_CHANGE);

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+80]
	push	12					; 0000000cH
	call	eax
$LN56@UpdateOper:

; 2907 : 			}
; 2908 : 		}
; 2909 : 	}
; 2910 : 
; 2911 : 	// SEE WHAT OPERATIONS WE SHOULD ADD
; 2912 : 	//
; 2913 : 	// Operation vs. Barbarians
; 2914 : 	//
; 2915 : 	// If running the eradicate barbarian strategy, the threat is low (no higher than 1 major threat), we're not at war, /*and we have enough units*/, then launch a new operation.
; 2916 : 	// Which one is based on whether or not we saw any barbarian camps
; 2917 : 	if(IsUsingStrategy(eStrategyBarbs) && !IsUsingStrategy(eStrategyFightAWar) && !IsUsingStrategy(eBuildCriticalDefenses) && !m_pPlayer->haveAIOperationOfType(AI_OPERATION_DESTROY_BARBARIAN_CAMP)
; 2918 : 	        && bWillingToAcceptRisk)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _eStrategyBarbs$[esp+128]
	cmp	BYTE PTR [eax+ecx], 0
	je	SHORT $LN414@UpdateOper
	mov	edx, DWORD PTR _eStrategyFightAWar$[esp+128]
	cmp	BYTE PTR [eax+edx], 0
	jne	SHORT $LN414@UpdateOper
	mov	ecx, DWORD PTR _eBuildCriticalDefenses$[esp+128]
	cmp	BYTE PTR [eax+ecx], 0
	jne	SHORT $LN414@UpdateOper
	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	push	0
	push	3
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	jne	SHORT $LN414@UpdateOper
	cmp	BYTE PTR _bWillingToAcceptRisk$[esp+128], al
	je	SHORT $LN414@UpdateOper

; 2919 : 	{
; 2920 : 		// We should have AI build for this
; 2921 : 		m_pPlayer->addAIOperation(AI_OPERATION_DESTROY_BARBARIAN_CAMP);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	push	-1
	push	-1
	push	3
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
$LN414@UpdateOper:

; 2922 : 	}
; 2923 : 
; 2924 : 	//
; 2925 : 	// Operation vs. Other Civs
; 2926 : 	//
; 2927 : 	// If at war, consider launching an operation
; 2928 : 	if(IsUsingStrategy(eStrategyFightAWar))

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _eStrategyFightAWar$[esp+128]
	mov	al, BYTE PTR [eax+edx]
	test	al, al
	je	$LN415@UpdateOper

; 2929 : 	{
; 2930 : 		// check nuke launches
; 2931 : 		// Loop through each enemy
; 2932 : 		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR tv1993[esp+128], ebp
	npad	1
$LL400@UpdateOper:

; 2933 : 		{
; 2934 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 2935 : 
; 2936 : 			// Is this a player we have relations with?
; 2937 : 			if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [esi]
	cmp	ebx, DWORD PTR [ecx+44]
	je	$LN52@UpdateOper
	push	0
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	$LN52@UpdateOper

; 2938 : 			{
; 2939 : 				bool bLaunchNuke = false;
; 2940 : 				// only evaluate nukes when we have nukes and we've declared war on someone
; 2941 : 				if (m_pPlayer->getNumNukeUnits() > 0 && GET_TEAM(m_pPlayer->getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam())) 

	mov	ecx, DWORD PTR [esi]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	test	eax, eax
	jle	$LN52@UpdateOper
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+ebp+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN202@UpdateOper
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN203@UpdateOper
$LN202@UpdateOper:
	or	ecx, -1
$LN203@UpdateOper:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN211@UpdateOper
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN212@UpdateOper
$LN211@UpdateOper:
	or	eax, -1
$LN212@UpdateOper:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN52@UpdateOper

; 2942 : 				{
; 2943 : 					// they nuked us, so we can nuke them.
; 2944 : 					if (m_pPlayer->GetDiplomacyAI()->GetNumTimesNuked(eLoopPlayer) > 0)

	mov	ecx, DWORD PTR [esi]
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumTimesNuked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumTimesNuked
	test	eax, eax
	jg	$LN373@UpdateOper

; 2945 : 					{	
; 2946 : 						bLaunchNuke = true;
; 2947 : 					}
; 2948 : 					// if we already nuked them, uhhh, keep it up!
; 2949 : 					else if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetNumTimesNuked(m_pPlayer->GetID()) > 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumTimesNuked@CvDiplomacyAI@@QBEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumTimesNuked
	test	eax, eax
	jg	$LN373@UpdateOper

; 2950 : 					{
; 2951 : 						bLaunchNuke = true;
; 2952 : 					}
; 2953 : 					else 
; 2954 : 					{
; 2955 : 						bool bRollForNuke = false;
; 2956 : 						WarProjectionTypes eLastWarProjection = m_pPlayer->GetDiplomacyAI()->GetLastWarProjection(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetLastWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetLastWarProjection

; 2957 : 						WarProjectionTypes eCurrentWarProjection = m_pPlayer->GetDiplomacyAI()->GetWarProjection(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ebx
	mov	edi, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection

; 2958 : 						if (eCurrentWarProjection == WAR_PROJECTION_DESTRUCTION)

	test	eax, eax

; 2959 : 						{
; 2960 : 							// roll every turn
; 2961 : 							bRollForNuke = true;
; 2962 : 						}
; 2963 : 						else if (eCurrentWarProjection != WAR_PROJECTION_UNKNOWN && eCurrentWarProjection != NO_WAR_PROJECTION_TYPE && 

	je	SHORT $LN374@UpdateOper

; 2964 : 							eLastWarProjection != WAR_PROJECTION_UNKNOWN && eLastWarProjection != NO_WAR_PROJECTION_TYPE && 
; 2965 : 							eCurrentWarProjection < eLastWarProjection)

	cmp	eax, 3
	je	$LN52@UpdateOper
	cmp	eax, -1
	je	$LN52@UpdateOper
	cmp	edi, 3
	je	$LN52@UpdateOper
	cmp	edi, -1
	je	SHORT $LN52@UpdateOper
	cmp	eax, edi
	jge	SHORT $LN52@UpdateOper
$LN374@UpdateOper:

; 2966 : 						{
; 2967 : 							// roll for nukes!
; 2968 : 							bRollForNuke = true;
; 2969 : 						}
; 2970 : 
; 2971 : 						if (bRollForNuke)
; 2972 : 						{
; 2973 : 							int iFlavorNuke = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_USE_NUKE"));

	push	0
	push	OFFSET $SG227831
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 2974 : 							int iRoll  = GC.getGame().getJonRandNum(10, "Roll to see if we're going to nuke!");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG227833
	push	10					; 0000000aH
	mov	edi, eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 2975 : 							int iRoll2 = GC.getGame().getJonRandNum(10, "Second roll to see if we're going to nuke!");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG227835
	push	10					; 0000000aH
	mov	ebp, eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 2976 : 							if (iRoll < iFlavorNuke && iRoll2 < iFlavorNuke)

	cmp	ebp, edi
	jge	SHORT $LN412@UpdateOper
	cmp	eax, edi
	jge	SHORT $LN412@UpdateOper
	mov	ebp, DWORD PTR tv1993[esp+128]
$LN373@UpdateOper:

; 2977 : 							{
; 2978 : 								bLaunchNuke = true;
; 2979 : 							}
; 2980 : 						}
; 2981 : 					}
; 2982 : 				}
; 2983 : 
; 2984 : 				if (bLaunchNuke)
; 2985 : 				{
; 2986 : 					RequestNukeAttack(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	call	?getNumNukeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getNumNukeUnits
	test	eax, eax
	jle	SHORT $LN52@UpdateOper
	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	push	-1
	push	ebx
	push	17					; 00000011H
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	jmp	SHORT $LN52@UpdateOper
$LN412@UpdateOper:
	mov	ebp, DWORD PTR tv1993[esp+128]
$LN52@UpdateOper:

; 2929 : 	{
; 2930 : 		// check nuke launches
; 2931 : 		// Loop through each enemy
; 2932 : 		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	add	ebp, 63236				; 0000f704H
	inc	ebx
	cmp	ebp, 1391192				; 00153a58H
	mov	DWORD PTR tv1993[esp+128], ebp
	jl	$LL400@UpdateOper

; 2987 : 				}
; 2988 : 
; 2989 : 			}
; 2990 : 		}
; 2991 : 
; 2992 : 		// if we're not considered to be losing all wars, then consider launching operations against other civs
; 2993 : 		if (m_pPlayer->GetDiplomacyAI()->GetStateAllWars() != STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR [esi]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	je	$LN402@UpdateOper

; 2994 : 		{
; 2995 : 			static CvWeightedVector<CvMilitaryTarget, SAFE_ESTIMATE_NUM_CITIES* 10, true> weightedTargetList;

	test	BYTE PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA, 1
	jne	SHORT $LN401@UpdateOper
	or	DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA, 1
	push	OFFSET ??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ ; `CvMilitaryAI::UpdateOperations'::`166'::`dynamic atexit destructor for 'weightedTargetList''
	mov	DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, 0
	mov	DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+8, 640 ; 00000280H
	mov	DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+12
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[esp+136], -1
$LN401@UpdateOper:

; 2996 : 			weightedTargetList.clear();

	xor	ebp, ebp
	mov	DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4, ebp
$LL36@UpdateOper:

; 2997 : 
; 2998 : 			// make list of scores for each player
; 2999 : 			for (iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 3000 : 			{
; 3001 : 				eLoopPlayer = (PlayerTypes)iPlayerLoop;
; 3002 : 				if (eLoopPlayer == m_pPlayer->GetID() || !m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [esi]
	cmp	ebp, DWORD PTR [ecx+44]
	je	$LN35@UpdateOper
	push	0
	push	ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	$LN35@UpdateOper

; 3003 : 				{
; 3004 : 					continue;
; 3005 : 				}
; 3006 : 
; 3007 : 				eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState

; 3008 : 
; 3009 : 				// if we're not at war
; 3010 : 				if (eWarState == NO_WAR_STATE_TYPE)

	cmp	eax, -1
	je	$LN35@UpdateOper

; 3011 : 				{
; 3012 : 					continue;
; 3013 : 				}
; 3014 : 
; 3015 : 				// don't declare any operations if we are in a defensive or nearly defeated state
; 3016 : 				if (eWarState == WAR_STATE_DEFENSIVE || eWarState == WAR_STATE_NEARLY_DEFEATED)

	cmp	eax, 1
	je	$LN35@UpdateOper
	test	eax, eax
	je	$LN35@UpdateOper

; 3017 : 				{
; 3018 : 					continue;
; 3019 : 				}
; 3020 : 
; 3021 : 				bool bRequestAttack = false;
; 3022 : 
; 3023 : 				StrengthTypes eMilitaryStrength = m_pPlayer->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs

; 3024 : 				TargetValueTypes eTargetType = NO_TARGET_VALUE;
; 3025 : 
; 3026 : 				if(eMilitaryStrength <= STRENGTH_AVERAGE || (GC.getAI_MILITARY_IGNORE_BAD_ODDS() == 1))

	cmp	eax, 3
	jle	SHORT $LN27@UpdateOper
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2196, 1
	jne	$LN35@UpdateOper
$LN27@UpdateOper:

; 3027 : 				{
; 3028 : 					eTargetType = m_pPlayer->GetDiplomacyAI()->GetPlayerTargetValue(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetPlayerTargetValue@CvDiplomacyAI@@QBE?AW4TargetValueTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetPlayerTargetValue
	mov	DWORD PTR _eTargetType$227857[esp+128], eax

; 3029 : 					if(eTargetType > TARGET_VALUE_IMPOSSIBLE)

	test	eax, eax
	jle	$LN35@UpdateOper

; 3030 : 					{
; 3031 : 						bRequestAttack = true;
; 3032 : 					}
; 3033 : 				}
; 3034 : 
; 3035 : 				if (!bRequestAttack)
; 3036 : 				{
; 3037 : 					continue;
; 3038 : 				}
; 3039 : 
; 3040 : 				CvMilitaryTarget target;
; 3041 : 				int iScore;
; 3042 : 				target = FindBestAttackTarget(AI_OPERATION_BASIC_CITY_ATTACK, eLoopPlayer, &iScore);

	lea	edx, DWORD PTR _iScore$227863[esp+128]
	push	edx
	push	ebp
	push	2
	lea	eax, DWORD PTR $T241265[esp+140]
	push	eax
	mov	ecx, esi
	call	?FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z ; CvMilitaryAI::FindBestAttackTarget
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+20]
	mov	DWORD PTR _target$227862[esp+132], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _target$227862[esp+136], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _target$227862[esp+140], ecx
	mov	DWORD PTR _target$227862[esp+144], edx

; 3043 : 				if(target.m_pTargetCity)

	test	edi, edi
	je	$LN35@UpdateOper

; 3044 : 				{
; 3045 : 					int iNumUnitsWillingBuild = 1;
; 3046 : 					if(target.m_bAttackBySea)

	test	bl, bl
	je	SHORT $LN23@UpdateOper

; 3047 : 					{
; 3048 : 						iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_INVASION, true, &iNumRequiredSlots, &iLandReservesUsed);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _iLandReservesUsed$[esp+128]
	push	eax
	lea	ecx, DWORD PTR _iNumRequiredSlots$[esp+132]
	push	ecx
	push	1
	push	12					; 0000000cH
	push	edx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots

; 3049 : 						if((iNumRequiredSlots - iFilledSlots) > iNumUnitsWillingBuild || iLandReservesUsed > GetLandReservesAvailable())

	mov	ecx, DWORD PTR _iNumRequiredSlots$[esp+148]
	sub	ecx, eax
	add	esp, 20					; 00000014H
	cmp	ecx, 1
	jg	$LN35@UpdateOper
	mov	edx, DWORD PTR [esi+52]
	sub	edx, DWORD PTR [esi+100]
	sub	edx, DWORD PTR [esi+72]
	cmp	DWORD PTR _iLandReservesUsed$[esp+128], edx
	jle	SHORT $LN19@UpdateOper

; 3050 : 						{
; 3051 : 							continue;

	jmp	$LN35@UpdateOper
$LN23@UpdateOper:

; 3052 : 						}
; 3053 : 					}
; 3054 : 					else
; 3055 : 					{
; 3056 : 						iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE, false, &iNumRequiredSlots, &iLandReservesUsed);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN117@UpdateOper
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	jne	SHORT $LN117@UpdateOper
	mov	eax, 18					; 00000012H
	jmp	SHORT $LN118@UpdateOper
$LN117@UpdateOper:
	xor	eax, eax
$LN118@UpdateOper:
	lea	ecx, DWORD PTR _iLandReservesUsed$[esp+128]
	push	ecx
	lea	edx, DWORD PTR _iNumRequiredSlots$[esp+132]
	push	edx
	push	0
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots

; 3057 : 						if((iNumRequiredSlots - iFilledSlots) > iNumUnitsWillingBuild || iLandReservesUsed > GetLandReservesAvailable())

	mov	ecx, DWORD PTR _iNumRequiredSlots$[esp+148]
	sub	ecx, eax
	add	esp, 20					; 00000014H
	cmp	ecx, 1
	jg	SHORT $LN35@UpdateOper
	mov	edx, DWORD PTR [esi+52]
	sub	edx, DWORD PTR [esi+100]
	sub	edx, DWORD PTR [esi+72]
	cmp	DWORD PTR _iLandReservesUsed$[esp+128], edx
	jg	SHORT $LN35@UpdateOper
$LN19@UpdateOper:

; 3058 : 						{
; 3059 : 							continue;
; 3060 : 						}
; 3061 : 					}
; 3062 : 				}
; 3063 : 				else
; 3064 : 				{
; 3065 : 					continue;
; 3066 : 				}
; 3067 : 
; 3068 : 				// add logic in here for current war state
; 3069 : 				int iAdjustedByTargetValueScore = iScore * eTargetType;
; 3070 : 				weightedTargetList.push_back(target, iAdjustedByTargetValueScore);

	mov	ecx, DWORD PTR _target$227862[esp+136]
	mov	edx, DWORD PTR _target$227862[esp+140]
	mov	eax, DWORD PTR _target$227862[esp+132]
	mov	DWORD PTR _weightedElem$241648[esp+136], ecx
	mov	ecx, DWORD PTR _iScore$227863[esp+128]
	imul	ecx, DWORD PTR _eTargetType$227857[esp+128]
	mov	DWORD PTR _weightedElem$241648[esp+140], edx
	mov	DWORD PTR _weightedElem$241648[esp+132], eax
	mov	eax, DWORD PTR _target$227862[esp+144]
	lea	edx, DWORD PTR _weightedElem$241648[esp+128]
	mov	DWORD PTR _weightedElem$241648[esp+152], ecx
	push	edx
	mov	ecx, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR _weightedElem$241648[esp+132], edi
	mov	DWORD PTR _weightedElem$241648[esp+148], eax
	mov	DWORD PTR _weightedElem$241648[esp+152], ebx
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@$0CIA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; FStaticVector<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement,640,1,0,0>::push_back
$LN35@UpdateOper:
	inc	ebp
	cmp	ebp, 22					; 00000016H
	jl	$LL36@UpdateOper

; 3071 : 			}
; 3072 : 
; 3073 : 			// roll from list of players
; 3074 : 			// make sure the list has something in it
; 3075 : 			if(weightedTargetList.size() != 0)

	mov	eax, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	test	eax, eax
	je	$LN402@UpdateOper

; 3076 : 			{
; 3077 : 				weightedTargetList.SortItems();

	mov	edi, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	ebx, DWORD PTR [edi+ecx*4]
	mov	ecx, ebx
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	ebx
	push	edi
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvMilitaryTarget,640,1>::WeightedElement *,int>

; 3078 : 				LogAttackTargets(AI_OPERATION_BASIC_CITY_ATTACK, m_pPlayer->GetID(), weightedTargetList);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+44]
	add	esp, 12					; 0000000cH
	push	OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	push	edx
	push	2
	mov	ecx, esi
	call	?LogAttackTargets@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAV?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@@Z ; CvMilitaryAI::LogAttackTargets

; 3079 : 
; 3080 : 				if(weightedTargetList.GetTotalWeight() > 0)

	mov	edx, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+4
	xor	eax, eax
	test	edx, edx
	jbe	$LN402@UpdateOper
	mov	ecx, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	add	ecx, 24					; 00000018H
	npad	4
$LL301@UpdateOper:
	add	eax, DWORD PTR [ecx]
	add	ecx, 28					; 0000001cH
	sub	edx, 1
	jne	SHORT $LL301@UpdateOper
	test	eax, eax
	jle	SHORT $LN402@UpdateOper

; 3081 : 				{
; 3082 : 					RandomNumberDelegate fcn;
; 3083 : 					fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48

; 3084 : 					CvMilitaryTarget chosenTarget = weightedTargetList.ChooseByWeight(&fcn, "Choosing attack target by weight");

	push	OFFSET $SG227881
	lea	ecx, DWORD PTR _fcn$227877[esp+132]
	push	ecx
	lea	edx, DWORD PTR _chosenTarget$227879[esp+136]
	push	edx
	mov	ecx, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	mov	DWORD PTR _fcn$227877[esp+144], OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	DWORD PTR _fcn$227877[esp+140], eax
	call	?ChooseByWeight@?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@QAE?AUCvMilitaryTarget@@PAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<CvMilitaryTarget,640,1>::ChooseByWeight

; 3085 : 
; 3086 : 					// declare that attack
; 3087 : 					RequestSpecificAttack(chosenTarget, 1);

	mov	ecx, DWORD PTR _chosenTarget$227879[esp+128]
	mov	edx, DWORD PTR _chosenTarget$227879[esp+132]
	push	1
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _chosenTarget$227879[esp+164]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _chosenTarget$227879[esp+168]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _chosenTarget$227879[esp+172]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR _chosenTarget$227879[esp+176]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, esi
	mov	DWORD PTR [eax+20], edx
	call	?RequestSpecificAttack@CvMilitaryAI@@QAE_NUCvMilitaryTarget@@H@Z ; CvMilitaryAI::RequestSpecificAttack

; 3088 : 
; 3089 : 					LogChosenTarget(AI_OPERATION_BASIC_CITY_ATTACK, m_pPlayer->GetID(), chosenTarget);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR _chosenTarget$227879[esp+128]
	push	eax
	push	edx
	push	2
	mov	ecx, esi
	call	?LogChosenTarget@CvMilitaryAI@@AAEXW4AIOperationTypes@@W4PlayerTypes@@AAUCvMilitaryTarget@@@Z ; CvMilitaryAI::LogChosenTarget
$LN402@UpdateOper:

; 3090 : 				}
; 3091 : 			}
; 3092 : 
; 3093 : 			/*
; 3094 : 			for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 3095 : 			{
; 3096 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3097 : 
; 3098 : 				// Is this a player we have relations with?
; 3099 : 				if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
; 3100 : 				{
; 3101 : 					eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);
; 3102 : 
; 3103 : 					switch(eWarState)
; 3104 : 					{
; 3105 : 						// If roughly equal in number, let's try to annoy him with raids
; 3106 : 					case WAR_STATE_STALEMATE:
; 3107 : 						//iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_FAST_PILLAGERS, false, &iNumRequiredSlots, &iLandReservesUsed);
; 3108 : 
; 3109 : 						//// Not willing to build units to get this off the ground
; 3110 : 						//if(iFilledSlots >= iNumRequiredSlots && iLandReservesUsed <= GetLandReservesAvailable())
; 3111 : 						//{
; 3112 : 						//	m_pPlayer->addAIOperation(AI_OPERATION_PILLAGE_ENEMY, eLoopPlayer);
; 3113 : 						//}
; 3114 : 						//break;
; 3115 : 
; 3116 : 						// If we are dominant, time to take down one of his cities
; 3117 : 					case WAR_STATE_NEARLY_WON:
; 3118 : 					case WAR_STATE_OFFENSIVE:
; 3119 : 						RequestBasicAttack(eLoopPlayer, 1);
; 3120 : 						break;
; 3121 : 
; 3122 : 						// No one near the other, let's look at a strength comparison before deciding what to do
; 3123 : 					case WAR_STATE_CALM:
; 3124 : 						{
; 3125 : 							bool bRequestAttack = false;
; 3126 : 
; 3127 : 							// slewis - add callbacks here to see if we need to attack anyways
; 3128 : 							StrengthTypes eMilitaryStrength = m_pPlayer->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer);
; 3129 : 
; 3130 : 							bool bAttackAnyway = true;
; 3131 : 
; 3132 : 							if(eMilitaryStrength <= STRENGTH_AVERAGE || bAttackAnyway)
; 3133 : 							{
; 3134 : 								TargetValueTypes eTargetType = m_pPlayer->GetDiplomacyAI()->GetPlayerTargetValue(eLoopPlayer);
; 3135 : 								if(eTargetType > TARGET_VALUE_IMPOSSIBLE)
; 3136 : 								{
; 3137 : 									bRequestAttack = true;
; 3138 : 								}
; 3139 : 							}
; 3140 : 
; 3141 : 							if(bRequestAttack)
; 3142 : 							{
; 3143 : 								RequestBasicAttack(eLoopPlayer, 1);
; 3144 : 							}
; 3145 : 							//else
; 3146 : 							//{
; 3147 : 							//	iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_FAST_PILLAGERS, false, &iNumRequiredSlots, &iLandReservesUsed);
; 3148 : 
; 3149 : 							//	// Not willing to build units to get this off the ground
; 3150 : 							//	if(iFilledSlots >= iNumRequiredSlots && iLandReservesUsed <= GetLandReservesAvailable())
; 3151 : 							//	{
; 3152 : 							//		m_pPlayer->addAIOperation(AI_OPERATION_PILLAGE_ENEMY, eLoopPlayer);
; 3153 : 							//	}
; 3154 : 							//}
; 3155 : 						}
; 3156 : 
; 3157 : 					case WAR_STATE_DEFENSIVE:
; 3158 : 					case WAR_STATE_NEARLY_DEFEATED:
; 3159 : 						{
; 3160 : 							//CvCity *pThreatenedCity;
; 3161 : 							//int iOperationID;
; 3162 : 
; 3163 : 							//// Start by seeing if we have a city that needs defense
; 3164 : 							//for (int iI = 0; iI < m_pPlayer->getNumCities(); iI++)
; 3165 : 							//{
; 3166 : 							//	pThreatenedCity = GetMostThreatenedCity(iI);
; 3167 : 							//	if (pThreatenedCity == NULL)
; 3168 : 							//	{
; 3169 : 							//		break;
; 3170 : 							//	}
; 3171 : 
; 3172 : 							//	// Do we already have an operation protecting this city?
; 3173 : 							//	if (!m_pPlayer->haveAIOperationOfType(AI_OPERATION_CITY_CLOSE_DEFENSE, &iOperationID, NO_PLAYER, pThreatenedCity->plot()))
; 3174 : 							//	{
; 3175 : 							//		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_CLOSE_CITY_DEFENSE, false, &iNumRequiredSlots);
; 3176 : 
; 3177 : 							//		// Not willing to build units to get this off the ground
; 3178 : 							//		if (iFilledSlots >= iNumRequiredSlots)
; 3179 : 							//		{
; 3180 : 							//			m_pPlayer->addAIOperation(AI_OPERATION_CITY_CLOSE_DEFENSE, eLoopPlayer);
; 3181 : 							//		}
; 3182 : 							//	}
; 3183 : 							//}
; 3184 : 
; 3185 : 							//// With any extra defensive bandwidth let's add rapid response forces
; 3186 : 							//iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_RAPID_RESPONSE_FORCE, false, &iNumRequiredSlots);
; 3187 : 
; 3188 : 							//// Not willing to build units to get this off the ground
; 3189 : 							//if (iFilledSlots >= iNumRequiredSlots)
; 3190 : 							//{
; 3191 : 							//	m_pPlayer->addAIOperation(AI_OPERATION_RAPID_RESPONSE, eLoopPlayer);
; 3192 : 							//}
; 3193 : 						}
; 3194 : 						break;
; 3195 : 
; 3196 : 					default:
; 3197 : 						break;
; 3198 : 					}
; 3199 : 				}
; 3200 : 			}*/
; 3201 : 		}
; 3202 : 	
; 3203 : 		// naval attack
; 3204 : 		for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	xor	edi, edi
$LL14@UpdateOper:

; 3205 : 		{
; 3206 : 			eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 3207 : 			// Is this a player we have relations with?
; 3208 : 			if(eLoopPlayer != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [ecx+44]
	je	SHORT $LN13@UpdateOper
	push	0
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	test	al, al
	je	SHORT $LN13@UpdateOper

; 3209 : 			{
; 3210 : 				eWarState = m_pPlayer->GetDiplomacyAI()->GetWarState(eLoopPlayer);

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarState@CvDiplomacyAI@@QBE?AW4WarStateTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarState

; 3211 : 
; 3212 : 				// if we're not at war
; 3213 : 				if (eWarState == NO_WAR_STATE_TYPE)

	cmp	eax, -1
	je	SHORT $LN13@UpdateOper

; 3214 : 				{
; 3215 : 					continue;
; 3216 : 				}
; 3217 : 
; 3218 : 				// Naval operations as part of a war effort, but only one at a time
; 3219 : 				bool bHasOperationUnderway = m_pPlayer->haveAIOperationOfType(AI_OPERATION_PURE_NAVAL_CITY_ATTACK, &iOperationID, NO_PLAYER);

	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
	lea	eax, DWORD PTR _iOperationID$[esp+136]
	push	eax
	push	18					; 00000012H
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType

; 3220 : 				if (!bHasOperationUnderway)

	test	al, al
	jne	SHORT $LN13@UpdateOper

; 3221 : 				{
; 3222 : 					RequestPureNavalAttack(eLoopPlayer, 1);

	push	1
	push	edi
	mov	ecx, esi
	call	?RequestPureNavalAttack@CvMilitaryAI@@QAE_NW4PlayerTypes@@H@Z ; CvMilitaryAI::RequestPureNavalAttack
$LN13@UpdateOper:
	inc	edi
	cmp	edi, 22					; 00000016H
	jl	SHORT $LL14@UpdateOper
$LN415@UpdateOper:

; 3223 : 				}
; 3224 : 			}
; 3225 : 		}
; 3226 : 	}
; 3227 : 
; 3228 : 	//
; 3229 : 	// Naval operations (vs. opportunity targets)
; 3230 : 	//
; 3231 : 	// Total number of these operations can't exceed (FLAVOR_NAVAL / 2)
; 3232 : 	int iFlavorNaval = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL"));

	push	0
	push	OFFSET $SG227892
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 3233 : 	int iNumSuperiority = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_SUPERIORITY);

	mov	ecx, DWORD PTR [esi]
	push	10					; 0000000aH
	mov	edi, eax
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType

; 3234 : 	int iNumBombard = m_pPlayer->numOperationsOfType(AI_OPERATION_NAVAL_BOMBARDMENT);

	mov	ecx, DWORD PTR [esi]
	push	9
	mov	ebx, eax
	call	?numOperationsOfType@CvPlayer@@QAEHH@Z	; CvPlayer::numOperationsOfType

; 3235 : 	int iMaxOperations = iFlavorNaval / 2;
; 3236 : 	if(GC.getMap().GetAIMapHint() & 1)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebp, eax
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	je	SHORT $LN8@UpdateOper

; 3237 : 	{
; 3238 : 		iMaxOperations *= 2;

	add	edi, edi
$LN8@UpdateOper:

; 3239 : 	}
; 3240 : 
; 3241 : 	if((iNumSuperiority + iNumBombard) <= iMaxOperations)

	lea	ecx, DWORD PTR [ebx+ebp]
	cmp	ecx, edi
	jg	$LN1@UpdateOper

; 3242 : 	{
; 3243 : 		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_SQUADRON, true, &iNumRequiredSlots);

	mov	eax, DWORD PTR [esi]
	push	0
	lea	edx, DWORD PTR _iNumRequiredSlots$[esp+132]
	push	edx
	push	1
	push	9
	push	eax
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H

; 3244 : 
; 3245 : 		// Not willing to build units to get this off the ground
; 3246 : 		if(iFilledSlots >= iNumRequiredSlots)

	cmp	eax, DWORD PTR _iNumRequiredSlots$[esp+128]
	jl	SHORT $LN403@UpdateOper

; 3247 : 		{
; 3248 : 			// If I have a colonization operation underway, start up naval superiority as extra escorts
; 3249 : 			if(m_pPlayer->haveAIOperationOfType(AI_OPERATION_QUICK_COLONIZE, &iOperationID))

	push	0
	push	-1
	lea	ecx, DWORD PTR _iOperationID$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	12					; 0000000cH
	call	?haveAIOperationOfType@CvPlayer@@QAE_NHPAHW4PlayerTypes@@PAVCvPlot@@@Z ; CvPlayer::haveAIOperationOfType
	test	al, al
	je	SHORT $LN5@UpdateOper
$LN439@UpdateOper:

; 3250 : 			{
; 3251 : 				m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SUPERIORITY, NO_PLAYER);

	push	0
	push	0
	push	-1
	push	-1
	push	10					; 0000000aH
	jmp	SHORT $LN438@UpdateOper
$LN5@UpdateOper:

; 3252 : 				return;
; 3253 : 			}
; 3254 : 			else if (IsUsingStrategy(eStrategyFightAWar))

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _eStrategyFightAWar$[esp+128]
	cmp	BYTE PTR [eax+edx], 0

; 3255 : 			{
; 3256 : 				m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_SUPERIORITY, NO_PLAYER);
; 3257 : 				return;

	jne	SHORT $LN439@UpdateOper
$LN403@UpdateOper:

; 3258 : 			}
; 3259 : 		}
; 3260 : 
; 3261 : 		iFilledSlots = MilitaryAIHelpers::NumberOfFillableSlots(m_pPlayer, MUFORMATION_NAVAL_BOMBARDMENT, true, &iNumRequiredSlots);

	mov	edx, DWORD PTR [esi]
	push	0
	lea	ecx, DWORD PTR _iNumRequiredSlots$[esp+132]
	push	ecx
	push	1
	push	16					; 00000010H
	push	edx
	call	?NumberOfFillableSlots@MilitaryAIHelpers@@YAHPAVCvPlayer@@W4MultiunitFormationTypes@@_NPAH3@Z ; MilitaryAIHelpers::NumberOfFillableSlots
	add	esp, 20					; 00000014H

; 3262 : 
; 3263 : 		// Not willing to build units to get this off the ground
; 3264 : 		if(iFilledSlots >= iNumRequiredSlots)

	cmp	eax, DWORD PTR _iNumRequiredSlots$[esp+128]
	jl	SHORT $LN1@UpdateOper

; 3265 : 		{
; 3266 : 			// If fighting off barbarians, start naval bombardment, but only if don't have one
; 3267 : 			if(iNumBombard == 0 && IsUsingStrategy(eStrategyBarbs))

	test	ebp, ebp
	jne	SHORT $LN1@UpdateOper
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _eStrategyBarbs$[esp+128]
	cmp	BYTE PTR [ecx+eax], 0
	je	SHORT $LN1@UpdateOper

; 3268 : 			{
; 3269 : 				m_pPlayer->addAIOperation(AI_OPERATION_NAVAL_BOMBARDMENT, NO_PLAYER);

	push	ebp
	push	ebp
	push	-1
	push	-1
	push	9
$LN438@UpdateOper:
	mov	ecx, DWORD PTR [esi]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
$LN1@UpdateOper:

; 3270 : 				return;
; 3271 : 			}
; 3272 : 		}
; 3273 : 	}
; 3274 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 112				; 00000070H
	ret	0
$LN440@UpdateOper:
	DD	$LN70@UpdateOper
	DD	$LN77@UpdateOper
	DD	$LN93@UpdateOper
	DD	$LN93@UpdateOper
	DD	$LN82@UpdateOper
	DD	$LN82@UpdateOper
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateOperations@CvMilitaryAI@@AAEXXZ$0:
	mov	eax, DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S2@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4IA, eax
	ret	0
__ehhandler$?UpdateOperations@CvMilitaryAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?UpdateOperations@CvMilitaryAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateOperations@CvMilitaryAI@@AAEXXZ ENDP		; CvMilitaryAI::UpdateOperations
PUBLIC	?DoTurn@CvMilitaryAI@@QAEXXZ			; CvMilitaryAI::DoTurn
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvMilitaryAI@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvMilitaryAI@@QAEXXZ PROC			; CvMilitaryAI::DoTurn, COMDAT
; _this$ = ecx

; 472  : {

	push	esi
	mov	esi, ecx

; 473  : 	AI_PERF_FORMAT("AI-perf.csv", ("MilitaryAI DoTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 474  : 
; 475  : 	ScanForBarbarians();

	call	?ScanForBarbarians@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::ScanForBarbarians

; 476  : 	UpdateThreats();

	mov	ecx, esi
	call	?UpdateThreats@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateThreats

; 477  : 	UpdateWars();

	mov	ecx, esi
	call	?UpdateWars@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateWars

; 478  : 	UpdateBaseData();

	mov	ecx, esi
	call	?UpdateBaseData@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateBaseData

; 479  : 	UpdateDefenseState();

	mov	ecx, esi
	call	?UpdateDefenseState@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::UpdateDefenseState

; 480  : 	UpdateMilitaryStrategies();

	mov	ecx, esi
	call	?UpdateMilitaryStrategies@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::UpdateMilitaryStrategies

; 481  : 
; 482  : 	if(!m_pPlayer->isHuman())

	mov	ecx, DWORD PTR [esi]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN2@DoTurn

; 483  : 	{
; 484  : 		UpdateOperations();

	mov	ecx, esi
	call	?UpdateOperations@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::UpdateOperations

; 485  : 		MakeEmergencyPurchases();

	mov	ecx, esi
	call	?MakeEmergencyPurchases@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::MakeEmergencyPurchases

; 486  : 		MakeOffensivePurchases();

	mov	ecx, esi
	call	?MakeOffensivePurchases@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::MakeOffensivePurchases

; 487  : 		RequestImprovements();
; 488  : 		DisbandObsoleteUnits();

	mov	ecx, esi
	call	?DisbandObsoleteUnits@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::DisbandObsoleteUnits
$LN2@DoTurn:

; 489  : 	}
; 490  : 
; 491  : 	LogMilitaryStatus();

	mov	ecx, esi
	call	?LogMilitaryStatus@CvMilitaryAI@@AAEXXZ	; CvMilitaryAI::LogMilitaryStatus

; 492  : 
; 493  : 	if(GetArmyBeingBuilt() != NO_ARMY_TYPE)

	cmp	DWORD PTR [esi+44], -1
	je	SHORT $LN1@DoTurn

; 494  : 	{
; 495  : 		LogAvailableForces();

	mov	ecx, esi
	pop	esi
	jmp	?LogAvailableForces@CvMilitaryAI@@AAEXXZ ; CvMilitaryAI::LogAvailableForces
$LN1@DoTurn:
	pop	esi

; 496  : 	}
; 497  : }

	ret	0
?DoTurn@CvMilitaryAI@@QAEXXZ ENDP			; CvMilitaryAI::DoTurn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ
text$yd	SEGMENT
??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ PROC ; `CvMilitaryAI::FindBestAttackTarget'::`43'::`dynamic atexit destructor for 'prelimWeightedTargetList'', COMDAT
	mov	eax, DWORD PTR ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	cmp	eax, OFFSET ?prelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+12
	je	SHORT $LN8@dynamic
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN8@dynamic:
	ret	0
??__FprelimWeightedTargetList@?CL@??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ENDP ; `CvMilitaryAI::FindBestAttackTarget'::`43'::`dynamic atexit destructor for 'prelimWeightedTargetList''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ
text$yd	SEGMENT
??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ PROC ; `CvMilitaryAI::FindBestAttackTarget'::`2'::`dynamic atexit destructor for 'weightedTargetList'', COMDAT
	mov	eax, DWORD PTR ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	cmp	eax, OFFSET ?weightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+12
	je	SHORT $LN8@dynamic@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN8@dynamic@2:
	ret	0
??__FweightedTargetList@?1??FindBestAttackTarget@CvMilitaryAI@@QAE?AUCvMilitaryTarget@@W4AIOperationTypes@@W4PlayerTypes@@PAH@Z@YAXXZ ENDP ; `CvMilitaryAI::FindBestAttackTarget'::`2'::`dynamic atexit destructor for 'weightedTargetList''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ
text$yd	SEGMENT
??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ PROC ; `CvMilitaryAI::UpdateOperations'::`166'::`dynamic atexit destructor for 'weightedTargetList'', COMDAT
	mov	eax, DWORD PTR ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A
	cmp	eax, OFFSET ?weightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@4V?$CvWeightedVector@UCvMilitaryTarget@@$0CIA@$00@@A+12
	je	SHORT $LN8@dynamic@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN8@dynamic@3:
	ret	0
??__FweightedTargetList@?KG@??UpdateOperations@CvMilitaryAI@@AAEXXZ@YAXXZ ENDP ; `CvMilitaryAI::UpdateOperations'::`166'::`dynamic atexit destructor for 'weightedTargetList''
text$yd	ENDS
END
