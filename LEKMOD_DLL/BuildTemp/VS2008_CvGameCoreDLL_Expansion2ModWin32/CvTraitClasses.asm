; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\Github\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTraitClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG222455 DB	'ShortDescription', 00H
	ORG $+3
$SG222456 DB	'LevelExperienceModifier', 00H
$SG222457 DB	'GreatPeopleRateModifier', 00H
$SG222458 DB	'GreatScientistRateModifier', 00H
	ORG $+1
$SG222459 DB	'GreatGeneralRateModifier', 00H
	ORG $+3
$SG222460 DB	'GreatGeneralExtraBonus', 00H
	ORG $+1
$SG222461 DB	'GreatPersonGiftInfluence', 00H
	ORG $+3
$SG222462 DB	'MaxGlobalBuildingProductionModifier', 00H
$SG222463 DB	'MaxTeamBuildingProductionModifier', 00H
	ORG $+2
$SG222464 DB	'MaxPlayerBuildingProductionModifier', 00H
$SG222465 DB	'CityUnhappinessModifier', 00H
$SG222466 DB	'PopulationUnhappinessModifier', 00H
	ORG $+2
$SG222467 DB	'CityStateBonusModifier', 00H
	ORG $+1
$SG222468 DB	'CityStateFriendshipModifier', 00H
$SG222469 DB	'CityStateCombatModifier', 00H
$SG222470 DB	'LandBarbarianConversionPercent', 00H
	ORG $+1
$SG222471 DB	'LandBarbarianConversionExtraUnits', 00H
	ORG $+2
$SG222472 DB	'SeaBarbarianConversionPercent', 00H
	ORG $+2
$SG222473 DB	'CapitalBuildingModifier', 00H
$SG222474 DB	'PlotBuyCostModifier', 00H
$SG222475 DB	'PlotCultureCostModifier', 00H
$SG222476 DB	'SciencePerGreatPersonBorn', 00H
	ORG $+2
$SG222477 DB	'NumTurnsBeforeMinorAlliesRefuseBribes', 00H
	ORG $+2
$SG222478 DB	'GoldenAgeTileBonusFaith', 00H
$SG222479 DB	'CultureFromKills', 00H
	ORG $+3
$SG222480 DB	'FaithFromKills', 00H
	ORG $+1
$SG222481 DB	'CityCultureBonus', 00H
	ORG $+3
$SG222482 DB	'CapitalThemingBonusModifier', 00H
$SG222483 DB	'PolicyCostModifier', 00H
	ORG $+1
$SG222484 DB	'CityConnectionTradeRouteChange', 00H
	ORG $+1
$SG222485 DB	'WonderProductionModifier', 00H
	ORG $+3
$SG222486 DB	'PlunderModifier', 00H
$SG222487 DB	'ImprovementMaintenanceModifier', 00H
	ORG $+1
$SG222488 DB	'GoldenAgeDurationModifier', 00H
	ORG $+2
$SG222489 DB	'GoldenAgeMoveChange', 00H
$SG222490 DB	'GoldenAgeCombatModifier', 00H
$SG222491 DB	'GoldenAgeTourismModifier', 00H
	ORG $+3
$SG222492 DB	'GoldenAgeGreatArtistRateModifier', 00H
	ORG $+3
$SG222493 DB	'GoldenAgeGreatMusicianRateModifier', 00H
	ORG $+1
$SG222494 DB	'GoldenAgeGreatWriterRateModifier', 00H
	ORG $+3
$SG222495 DB	'ExtraEmbarkMoves', 00H
	ORG $+3
$SG222496 DB	'NaturalWonderFirstFinderGold', 00H
	ORG $+3
$SG222497 DB	'NaturalWonderSubsequentFinderGold', 00H
	ORG $+2
$SG222498 DB	'NaturalWonderYieldModifier', 00H
	ORG $+1
$SG222499 DB	'NaturalWonderHappinessModifier', 00H
	ORG $+1
$SG222500 DB	'NearbyImprovementCombatBonus', 00H
	ORG $+3
$SG222501 DB	'NearbyImprovementBonusRange', 00H
$SG222502 DB	'CultureBuildingYieldChange', 00H
	ORG $+1
$SG222503 DB	'CombatBonusVsHigherTech', 00H
$SG222504 DB	'CombatBonusVsLargerCiv', 00H
	ORG $+1
$SG222505 DB	'LandUnitMaintenanceModifier', 00H
$SG222506 DB	'NavalUnitMaintenanceModifier', 00H
	ORG $+3
$SG222507 DB	'RazeSpeedModifier', 00H
	ORG $+2
$SG222508 DB	'DOFGreatPersonModifier', 00H
	ORG $+1
$SG222509 DB	'LuxuryHappinessRetention', 00H
	ORG $+3
$SG222510 DB	'ExtraHappinessPerLuxury', 00H
$SG222511 DB	'ExtraSpies', 00H
	ORG $+1
$SG222512 DB	'HappinessPerReligion', 00H
	ORG $+3
$SG222513 DB	'UnresearchedTechBonusFromKills', 00H
	ORG $+1
$SG222514 DB	'ExtraFoundedCityTerritoryClaimRange', 00H
$SG222515 DB	'FreeSocialPoliciesPerEra', 00H
	ORG $+3
$SG222516 DB	'NumTradeRoutesModifier', 00H
	ORG $+1
$SG222517 DB	'TradeRouteResourceModifier', 00H
	ORG $+1
$SG222518 DB	'UniqueLuxuryCities', 00H
	ORG $+1
$SG222519 DB	'UniqueLuxuryQuantity', 00H
	ORG $+3
$SG222520 DB	'WorkerSpeedModifier', 00H
$SG222521 DB	'AfraidMinorPerTurnInfluence', 00H
$SG222522 DB	'LandTradeRouteRangeBonus', 00H
	ORG $+3
$SG222523 DB	'TradeReligionModifier', 00H
	ORG $+2
$SG222524 DB	'TradeBuildingModifier', 00H
	ORG $+2
$SG222526 DB	'FreeUnit', 00H
	ORG $+3
$SG222528 DB	'FreeUnitPrereqTech', 00H
	ORG $+1
$SG222531 DB	'FreeBuildingPrereqTech', 00H
	ORG $+1
$SG222534 DB	'CapitalFreeBuildingPrereqTech', 00H
	ORG $+2
$SG222537 DB	'CombatBonusImprovement', 00H
	ORG $+1
$SG222540 DB	'ObsoleteTech', 00H
	ORG $+3
$SG222542 DB	'PrereqTech', 00H
	ORG $+1
$SG222544 DB	'FreeBuilding', 00H
	ORG $+3
$SG222547 DB	'FreeCapitalBuilding', 00H
$SG222550 DB	'FreeBuildingOnConquest', 00H
	ORG $+1
$SG222553 DB	'FightWellDamaged', 00H
	ORG $+3
$SG222554 DB	'MoveFriendlyWoodsAsRoad', 00H
$SG222555 DB	'FasterAlongRiver', 00H
	ORG $+3
$SG222556 DB	'FasterInHills', 00H
	ORG $+2
$SG222557 DB	'EmbarkedAllWater', 00H
	ORG $+3
$SG222558 DB	'EmbarkedToLandFlatCost', 00H
	ORG $+1
$SG222559 DB	'NoHillsImprovementMaintenance', 00H
	ORG $+2
$SG222560 DB	'TechBoostFromCapitalScienceBuildings', 00H
	ORG $+3
$SG222561 DB	'StaysAliveZeroCities', 00H
	ORG $+3
$SG222562 DB	'FaithFromUnimprovedForest', 00H
	ORG $+2
$SG222563 DB	'SeaTradeRoutesArePlunderImmune', 00H
	ORG $+1
$SG222564 DB	'EarnsGreatPersonOnSlotOrGuild', 00H
	ORG $+2
$SG222565 DB	'BonusReligiousBelief', 00H
	ORG $+3
$SG222566 DB	'AbleToAnnexCityStates', 00H
	ORG $+2
$SG222567 DB	'CrossesMountainsAfterGreatGeneral', 00H
	ORG $+2
$SG222568 DB	'MayaCalendarBonuses', 00H
$SG222569 DB	'NoAnnexing', 00H
	ORG $+1
$SG222570 DB	'TechFromCityConquer', 00H
$SG222571 DB	'UniqueLuxuryRequiresNewArea', 00H
$SG222572 DB	'RiverTradeRoad', 00H
	ORG $+1
$SG222573 DB	'AngerFreeIntrusionOfCityStates', 00H
	ORG $+1
$SG222575 DB	'TraitType', 00H
	ORG $+2
$SG222576 DB	'Trait_ExtraYieldThresholds', 00H
	ORG $+1
$SG222577 DB	'TraitType', 00H
	ORG $+2
$SG222578 DB	'Trait_YieldChanges', 00H
	ORG $+1
$SG222579 DB	'TraitType', 00H
	ORG $+2
$SG222580 DB	'Trait_YieldChangesStrategicResources', 00H
	ORG $+3
$SG222581 DB	'TraitType', 00H
	ORG $+2
$SG222582 DB	'Trait_YieldChangesLuxuryResources', 00H
	ORG $+2
$SG222583 DB	'TraitType', 00H
	ORG $+2
$SG222584 DB	'Trait_YieldChangesNaturalWonder', 00H
$SG222585 DB	'TraitType', 00H
	ORG $+2
$SG222586 DB	'Trait_YieldChangesPerTradePartner', 00H
	ORG $+2
$SG222587 DB	'TraitType', 00H
	ORG $+2
$SG222588 DB	'Trait_YieldChangesIncomingTradeRoute', 00H
	ORG $+3
$SG222589 DB	'TraitType', 00H
	ORG $+2
$SG222590 DB	'Trait_YieldModifiers', 00H
	ORG $+3
$SG222598 DB	'Trait_Terrains', 00H
	ORG $+5
$SG222602 DB	'select TraitType, Terrains.ID as TerrainID, StrategicRes'
	DB	'ourceQuantityModifier from Trait_Terrains join Terrains on Te'
	DB	'rrains.Type = TerrainType where TraitType = ?', 00H
	ORG $+1
$SG222607 DB	'TerrainID', 00H
	ORG $+2
$SG222609 DB	'StrategicResourceQuantityModifier', 00H
	ORG $+2
$SG222611 DB	'FreePromotionUnitCombats', 00H
	ORG $+3
$SG222615 DB	'select UnitPromotions.ID, UnitCombatInfos.ID from Trait_'
	DB	'FreePromotionUnitCombats, UnitPromotions, UnitCombatInfos whe'
	DB	're TraitType = ? and PromotionType = UnitPromotions.Type and '
	DB	'UnitCombatType = UnitCombatInfos.Type', 00H
$SG222695 DB	'ResourceQuantityModifier', 00H
	ORG $+3
$SG222696 DB	'TraitType', 00H
	ORG $+2
$SG222697 DB	'ResourceType', 00H
	ORG $+3
$SG222698 DB	'Trait_ResourceQuantityModifiers', 00H
$SG222699 DB	'Resources', 00H
	ORG $+2
$SG222701 DB	'UnitCombatInfos', 00H
$SG222703 DB	'Trait_MovesChangeUnitCombats', 00H
	ORG $+7
$SG222707 DB	'select UnitCombatInfos.ID, MovesChange from Trait_MovesC'
	DB	'hangeUnitCombats inner join UnitCombatInfos on UnitCombatInfo'
	DB	's.Type = UnitCombatType where TraitType = ?;', 00H
	ORG $+2
$SG222714 DB	'UnitCombatInfos', 00H
$SG222716 DB	'Trait_MaintenanceModifierUnitCombats', 00H
	ORG $+7
$SG222720 DB	'select UnitCombatInfos.ID, MaintenanceModifier from Trai'
	DB	't_MaintenanceModifierUnitCombats inner join UnitCombatInfos o'
	DB	'n UnitCombatInfos.Type = UnitCombatType where TraitType = ?;', 00H
	ORG $+2
$SG222726 DB	'Yields', 00H
	ORG $+1
$SG222727 DB	'Improvements', 00H
	ORG $+3
$SG222729 DB	'Trait_ImprovementYieldChanges', 00H
	ORG $+6
$SG222732 DB	'select Improvements.ID as ImprovementID, Yields.ID as Yi'
	DB	'eldID, Yield from Trait_ImprovementYieldChanges inner join Im'
	DB	'provements on Improvements.Type = ImprovementType inner join '
	DB	'Yields on Yields.Type = YieldType where TraitType = ?', 00H
$SG222739 DB	'Yields', 00H
	ORG $+1
$SG222740 DB	'Specialists', 00H
$SG222742 DB	'Building_SpecialistYieldChanges', 00H
$SG222753 DB	'Features', 00H
	ORG $+3
$SG222745 DB	'select Specialists.ID as SpecialistID, Yields.ID as Yiel'
	DB	'dID, Yield from Trait_SpecialistYieldChanges inner join Speci'
	DB	'alists on Specialists.Type = SpecialistType inner join Yields'
	DB	' on Yields.Type = YieldType where TraitType = ?', 00H
	ORG $+2
$SG222752 DB	'Yields', 00H
	ORG $+1
$SG222755 DB	'Trait_UnimprovedFeatureYieldChanges', 00H
$SG222758 DB	'select Features.ID as FeatureID, Yields.ID as YieldID, Y'
	DB	'ield from Trait_UnimprovedFeatureYieldChanges inner join Feat'
	DB	'ures on Features.Type = FeatureType inner join Yields on Yiel'
	DB	'ds.Type = YieldType where TraitType = ?', 00H
	ORG $+2
$SG222770 DB	'Trait_NoTrain', 00H
	ORG $+6
$SG222773 DB	'SELECT Traits.ID, UnitClasses.ID FROM Trait_NoTrain inne'
	DB	'r join Traits on Trait_NoTrain.TraitType = Traits.Type inner '
	DB	'join UnitClasses on Trait_NoTrain.UnitClassType = UnitClasses'
	DB	'.Type where TraitType = ?', 00H
$SG222785 DB	'Trait_FreeResourceFirstXCities', 00H
	ORG $+5
$SG222788 DB	'select Resources.ID as ResourceID, ResourceQuantity, Num'
	DB	'Cities from Trait_FreeResourceFirstXCities inner join Resourc'
	DB	'es on Resources.Type = ResourceType where TraitType = ?', 00H
	ORG $+3
_CALENDAR_START DD 0c542865br			; -3112.4
_DAYS_IN_BAKTUN DD 0480ca000r			; 144000
_DAYS_IN_KATUN DD 045e10000r			; 7200
_DAYS_IN_TUN DD	043b40000r			; 360
_DAYS_IN_WINAL DD 041a00000r			; 20
_DAYS_IN_YEAR DD 043b69f00r			; 365.242
$SG223434 DB	'%d.%d.%d.%d.%d', 00H
	ORG $+1
$SG223454 DB	'TXT_KEY_MAYA_CALENDAR_LONG_STRING', 00H
	ORG $+2
$SG223461 DB	'UNIT_PROPHET', 00H
	ORG $+3
$SG223472 DB	'UNIT_ENGINEER', 00H
	ORG $+2
$SG223478 DB	'UNIT_SCIENTIST', 00H
	ORG $+1
$SG223482 DB	'AIGRANDSTRATEGY_SPACESHIP', 00H
	ORG $+2
$SG223485 DB	'UNIT_ARTIST', 00H
$SG223489 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG223492 DB	'UNIT_MERCHANT', 00H
	ORG $+2
$SG223496 DB	'AIGRANDSTRATEGY_UNITED_NATIONS', 00H
	ORG $+1
$SG223499 DB	'UNIT_GREAT_GENERAL', 00H
	ORG $+1
$SG223503 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG223506 DB	'UNIT_PROPHET', 00H
	ORG $+3
$SG223510 DB	'UNIT_ENGINEER', 00H
	ORG $+2
$SG223514 DB	'UNIT_WRITER', 00H
$SG223518 DB	'UNIT_MERCHANT', 00H
	ORG $+2
$SG223522 DB	'UNIT_SCIENTIST', 00H
	ORG $+1
$SG223526 DB	'UNIT_ARTIST', 00H
$SG223530 DB	'UNIT_MUSICIAN', 00H
	ORG $+2
$SG223534 DB	'UNIT_GREAT_GENERAL', 00H
	ORG $+1
$SG223538 DB	'UNIT_GREAT_ADMIRAL', 00H
	ORG $+1
$SG223692 DB	'SPECIALUNIT_PEOPLE', 00H
	ORG $+1
$SG224039 DB	'Barbarian Camp Conversion', 00H
	ORG $+2
$SG224051 DB	'Converted barbarian camp, X: %d, Y: %d', 00H
	ORG $+1
$SG224054 DB	'TXT_KEY_NOTIFICATION_BARB_CAMP_CONVERTS', 00H
$SG224057 DB	'TXT_KEY_NOTIFICATION_SUMMARY_BARB_CAMP_CONVERTS', 00H
$SG224070 DB	'Barbarian Naval Unit Conversion', 00H
$SG224073 DB	'LEADER_SULEIMAN', 00H
$SG224076 DB	'Converted barbarian naval unit, X: %d, Y: %d', 00H
	ORG $+3
$SG224079 DB	'TXT_KEY_NOTIFICATION_BARB_NAVAL_UNIT_CONVERTS', 00H
	ORG $+2
$SG224082 DB	'TXT_KEY_NOTIFICATION_SUMMARY_BARB_NAVAL_UNIT_CONVERTS', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLevelExperienceModifier
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetLevelExperienceModifier, COMDAT
; _this$ = ecx

; 199  : 	return m_iLevelExperienceModifier;

	mov	eax, DWORD PTR [ecx+260]

; 200  : }

	ret	0
?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetLevelExperienceModifier
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatPeopleRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 205  : 	return m_iGreatPeopleRateModifier;

	mov	eax, DWORD PTR [ecx+264]

; 206  : }

	ret	0
?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatScientistRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGreatScientistRateModifier, COMDAT
; _this$ = ecx

; 211  : 	return m_iGreatScientistRateModifier;

	mov	eax, DWORD PTR [ecx+268]

; 212  : }

	ret	0
?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGreatScientistRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatGeneralRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 217  : 	return m_iGreatGeneralRateModifier;

	mov	eax, DWORD PTR [ecx+272]

; 218  : }

	ret	0
?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetGreatGeneralExtraBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatGeneralExtraBonus, COMDAT
; _this$ = ecx

; 223  : 	return m_iGreatGeneralExtraBonus;

	mov	eax, DWORD PTR [ecx+276]

; 224  : }

	ret	0
?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatGeneralExtraBonus
_TEXT	ENDS
PUBLIC	?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatPersonGiftInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatPersonGiftInfluence, COMDAT
; _this$ = ecx

; 229  : 	return m_iGreatPersonGiftInfluence;

	mov	eax, DWORD PTR [ecx+280]

; 230  : }

	ret	0
?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatPersonGiftInfluence
_TEXT	ENDS
PUBLIC	?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxGlobalBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetMaxGlobalBuildingProductionModifier, COMDAT
; _this$ = ecx

; 235  : 	return m_iMaxGlobalBuildingProductionModifier;

	mov	eax, DWORD PTR [ecx+284]

; 236  : }

	ret	0
?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetMaxGlobalBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxTeamBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetMaxTeamBuildingProductionModifier, COMDAT
; _this$ = ecx

; 241  : 	return m_iMaxTeamBuildingProductionModifier;

	mov	eax, DWORD PTR [ecx+288]

; 242  : }

	ret	0
?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetMaxTeamBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxPlayerBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetMaxPlayerBuildingProductionModifier, COMDAT
; _this$ = ecx

; 247  : 	return m_iMaxPlayerBuildingProductionModifier;

	mov	eax, DWORD PTR [ecx+292]

; 248  : }

	ret	0
?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetMaxPlayerBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityUnhappinessModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCityUnhappinessModifier, COMDAT
; _this$ = ecx

; 253  : 	return m_iCityUnhappinessModifier;

	mov	eax, DWORD PTR [ecx+296]

; 254  : }

	ret	0
?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCityUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPopulationUnhappinessModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetPopulationUnhappinessModifier, COMDAT
; _this$ = ecx

; 259  : 	return m_iPopulationUnhappinessModifier;

	mov	eax, DWORD PTR [ecx+300]

; 260  : }

	ret	0
?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetPopulationUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCityStateBonusModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCityStateBonusModifier, COMDAT
; _this$ = ecx

; 265  : 	return m_iCityStateBonusModifier;

	mov	eax, DWORD PTR [ecx+304]

; 266  : }

	ret	0
?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCityStateBonusModifier
_TEXT	ENDS
PUBLIC	?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityStateFriendshipModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCityStateFriendshipModifier, COMDAT
; _this$ = ecx

; 271  : 	return m_iCityStateFriendshipModifier;

	mov	eax, DWORD PTR [ecx+308]

; 272  : }

	ret	0
?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCityStateFriendshipModifier
_TEXT	ENDS
PUBLIC	?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityStateCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCityStateCombatModifier, COMDAT
; _this$ = ecx

; 277  : 	return m_iCityStateCombatModifier;

	mov	eax, DWORD PTR [ecx+312]

; 278  : }

	ret	0
?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCityStateCombatModifier
_TEXT	ENDS
PUBLIC	?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandBarbarianConversionPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetLandBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 283  : 	return m_iLandBarbarianConversionPercent;

	mov	eax, DWORD PTR [ecx+316]

; 284  : }

	ret	0
?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetLandBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandBarbarianConversionExtraUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetLandBarbarianConversionExtraUnits, COMDAT
; _this$ = ecx

; 289  : 	return m_iLandBarbarianConversionExtraUnits;

	mov	eax, DWORD PTR [ecx+320]

; 290  : }

	ret	0
?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetLandBarbarianConversionExtraUnits
_TEXT	ENDS
PUBLIC	?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetSeaBarbarianConversionPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetSeaBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 295  : 	return m_iSeaBarbarianConversionPercent;

	mov	eax, DWORD PTR [ecx+324]

; 296  : }

	ret	0
?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetSeaBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCapitalBuildingModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCapitalBuildingModifier, COMDAT
; _this$ = ecx

; 301  : 	return m_iCapitalBuildingModifier;

	mov	eax, DWORD PTR [ecx+328]

; 302  : }

	ret	0
?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCapitalBuildingModifier
_TEXT	ENDS
PUBLIC	?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPlotBuyCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetPlotBuyCostModifier, COMDAT
; _this$ = ecx

; 307  : 	return m_iPlotBuyCostModifier;

	mov	eax, DWORD PTR [ecx+332]

; 308  : }

	ret	0
?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetPlotBuyCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPlotCultureCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 313  : 	return m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR [ecx+336]

; 314  : }

	ret	0
?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetSciencePerGreatPersonBorn
; Function compile flags: /Ogtpy
;	COMDAT ?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetSciencePerGreatPersonBorn, COMDAT
; _this$ = ecx

; 320  : 	return m_iSciencePerGreatPersonBorn;

	mov	eax, DWORD PTR [ecx+340]

; 321  : }

	ret	0
?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetSciencePerGreatPersonBorn
_TEXT	ENDS
PUBLIC	?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNumTurnsBeforeMinorAlliesRefuseBribes
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNumTurnsBeforeMinorAlliesRefuseBribes, COMDAT
; _this$ = ecx

; 328  : 	return m_iNumTurnsBeforeMinorAlliesRefuseBribes;

	mov	eax, DWORD PTR [ecx+344]

; 329  : }

	ret	0
?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNumTurnsBeforeMinorAlliesRefuseBribes
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeTileBonusFaith
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeTileBonusFaith, COMDAT
; _this$ = ecx

; 336  : 	return m_iGoldenAgeTileBonusFaith;

	mov	eax, DWORD PTR [ecx+348]

; 337  : }

	ret	0
?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeTileBonusFaith
_TEXT	ENDS
PUBLIC	?GetCultureFromKills@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCultureFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureFromKills@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureFromKills@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetCultureFromKills, COMDAT
; _this$ = ecx

; 344  : 	return m_iCultureFromKills;

	mov	eax, DWORD PTR [ecx+352]

; 345  : }

	ret	0
?GetCultureFromKills@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetCultureFromKills
_TEXT	ENDS
PUBLIC	?GetFaithFromKills@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetFaithFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithFromKills@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithFromKills@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetFaithFromKills, COMDAT
; _this$ = ecx

; 350  : 	return m_iFaithFromKills;

	mov	eax, DWORD PTR [ecx+356]

; 351  : }

	ret	0
?GetFaithFromKills@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetFaithFromKills
_TEXT	ENDS
PUBLIC	?GetCityCultureBonus@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCityCultureBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityCultureBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityCultureBonus@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetCityCultureBonus, COMDAT
; _this$ = ecx

; 356  : 	return m_iCityCultureBonus;

	mov	eax, DWORD PTR [ecx+360]

; 357  : }

	ret	0
?GetCityCultureBonus@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetCityCultureBonus
_TEXT	ENDS
PUBLIC	?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCapitalThemingBonusModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCapitalThemingBonusModifier, COMDAT
; _this$ = ecx

; 362  : 	return m_iCapitalThemingBonusModifier;

	mov	eax, DWORD PTR [ecx+364]

; 363  : }

	ret	0
?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCapitalThemingBonusModifier
_TEXT	ENDS
PUBLIC	?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPolicyCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetPolicyCostModifier, COMDAT
; _this$ = ecx

; 368  : 	return m_iPolicyCostModifier;

	mov	eax, DWORD PTR [ecx+368]

; 369  : }

	ret	0
?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetPolicyCostModifier
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityConnectionTradeRouteChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCityConnectionTradeRouteChange, COMDAT
; _this$ = ecx

; 374  : 	return m_iCityConnectionTradeRouteChange;

	mov	eax, DWORD PTR [ecx+372]

; 375  : }

	ret	0
?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCityConnectionTradeRouteChange
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetWonderProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 380  : 	return m_iWonderProductionModifier;

	mov	eax, DWORD PTR [ecx+376]

; 381  : }

	ret	0
?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetPlunderModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPlunderModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlunderModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlunderModifier@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetPlunderModifier, COMDAT
; _this$ = ecx

; 386  : 	return m_iPlunderModifier;

	mov	eax, DWORD PTR [ecx+380]

; 387  : }

	ret	0
?GetPlunderModifier@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetPlunderModifier
_TEXT	ENDS
PUBLIC	?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetImprovementMaintenanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetImprovementMaintenanceModifier, COMDAT
; _this$ = ecx

; 392  : 	return m_iImprovementMaintenanceModifier;

	mov	eax, DWORD PTR [ecx+384]

; 393  : }

	ret	0
?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetImprovementMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeDurationModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeDurationModifier, COMDAT
; _this$ = ecx

; 398  : 	return m_iGoldenAgeDurationModifier;

	mov	eax, DWORD PTR [ecx+388]

; 399  : }

	ret	0
?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeDurationModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetGoldenAgeMoveChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeMoveChange, COMDAT
; _this$ = ecx

; 404  : 	return m_iGoldenAgeMoveChange;

	mov	eax, DWORD PTR [ecx+392]

; 405  : }

	ret	0
?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeMoveChange
_TEXT	ENDS
PUBLIC	?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeCombatModifier, COMDAT
; _this$ = ecx

; 410  : 	return m_iGoldenAgeCombatModifier;

	mov	eax, DWORD PTR [ecx+396]

; 411  : }

	ret	0
?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeCombatModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeTourismModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeTourismModifier, COMDAT
; _this$ = ecx

; 416  : 	return m_iGoldenAgeTourismModifier;

	mov	eax, DWORD PTR [ecx+400]

; 417  : }

	ret	0
?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeTourismModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatArtistRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGoldenAgeGreatArtistRateModifier, COMDAT
; _this$ = ecx

; 422  : 	return m_iGoldenAgeGreatArtistRateModifier;

	mov	eax, DWORD PTR [ecx+404]

; 423  : }

	ret	0
?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGoldenAgeGreatArtistRateModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatMusicianRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGoldenAgeGreatMusicianRateModifier, COMDAT
; _this$ = ecx

; 428  : 	return m_iGoldenAgeGreatMusicianRateModifier;

	mov	eax, DWORD PTR [ecx+408]

; 429  : }

	ret	0
?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGoldenAgeGreatMusicianRateModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatWriterRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGoldenAgeGreatWriterRateModifier, COMDAT
; _this$ = ecx

; 434  : 	return m_iGoldenAgeGreatWriterRateModifier;

	mov	eax, DWORD PTR [ecx+412]

; 435  : }

	ret	0
?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGoldenAgeGreatWriterRateModifier
_TEXT	ENDS
PUBLIC	?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetExtraEmbarkMoves
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetExtraEmbarkMoves, COMDAT
; _this$ = ecx

; 440  : 	return m_iExtraEmbarkMoves;

	mov	eax, DWORD PTR [ecx+424]

; 441  : }

	ret	0
?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetExtraEmbarkMoves
_TEXT	ENDS
PUBLIC	?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetFreeUnitClassType
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetFreeUnitClassType, COMDAT
; _this$ = ecx

; 446  : 	return m_iFreeUnitClassType;

	mov	eax, DWORD PTR [ecx+428]

; 447  : }

	ret	0
?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetFreeUnitClassType
_TEXT	ENDS
PUBLIC	?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderFirstFinderGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderFirstFinderGold, COMDAT
; _this$ = ecx

; 452  : 	return m_iNaturalWonderFirstFinderGold;

	mov	eax, DWORD PTR [ecx+432]

; 453  : }

	ret	0
?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderFirstFinderGold
_TEXT	ENDS
PUBLIC	?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderSubsequentFinderGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderSubsequentFinderGold, COMDAT
; _this$ = ecx

; 458  : 	return m_iNaturalWonderSubsequentFinderGold;

	mov	eax, DWORD PTR [ecx+436]

; 459  : }

	ret	0
?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderSubsequentFinderGold
_TEXT	ENDS
PUBLIC	?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderYieldModifier, COMDAT
; _this$ = ecx

; 464  : 	return m_iNaturalWonderYieldModifier;

	mov	eax, DWORD PTR [ecx+440]

; 465  : }

	ret	0
?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderYieldModifier
_TEXT	ENDS
PUBLIC	?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderHappinessModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderHappinessModifier, COMDAT
; _this$ = ecx

; 470  : 	return m_iNaturalWonderHappinessModifier;

	mov	eax, DWORD PTR [ecx+444]

; 471  : }

	ret	0
?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderHappinessModifier
_TEXT	ENDS
PUBLIC	?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNearbyImprovementCombatBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNearbyImprovementCombatBonus, COMDAT
; _this$ = ecx

; 476  : 	return m_iNearbyImprovementCombatBonus;

	mov	eax, DWORD PTR [ecx+448]

; 477  : }

	ret	0
?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNearbyImprovementCombatBonus
_TEXT	ENDS
PUBLIC	?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNearbyImprovementBonusRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNearbyImprovementBonusRange, COMDAT
; _this$ = ecx

; 482  : 	return m_iNearbyImprovementBonusRange;

	mov	eax, DWORD PTR [ecx+452]

; 483  : }

	ret	0
?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNearbyImprovementBonusRange
_TEXT	ENDS
PUBLIC	?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCultureBuildingYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCultureBuildingYieldChange, COMDAT
; _this$ = ecx

; 488  : 	return m_iCultureBuildingYieldChange;

	mov	eax, DWORD PTR [ecx+456]

; 489  : }

	ret	0
?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCultureBuildingYieldChange
_TEXT	ENDS
PUBLIC	?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCombatBonusVsHigherTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCombatBonusVsHigherTech, COMDAT
; _this$ = ecx

; 494  : 	return m_iCombatBonusVsHigherTech;

	mov	eax, DWORD PTR [ecx+460]

; 495  : }

	ret	0
?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCombatBonusVsHigherTech
_TEXT	ENDS
PUBLIC	?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCombatBonusVsLargerCiv
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCombatBonusVsLargerCiv, COMDAT
; _this$ = ecx

; 500  : 	return m_iCombatBonusVsLargerCiv;

	mov	eax, DWORD PTR [ecx+464]

; 501  : }

	ret	0
?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCombatBonusVsLargerCiv
_TEXT	ENDS
PUBLIC	?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetRazeSpeedModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetRazeSpeedModifier, COMDAT
; _this$ = ecx

; 506  : 	return m_iRazeSpeedModifier;

	mov	eax, DWORD PTR [ecx+476]

; 507  : }

	ret	0
?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetRazeSpeedModifier
_TEXT	ENDS
PUBLIC	?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetDOFGreatPersonModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetDOFGreatPersonModifier, COMDAT
; _this$ = ecx

; 512  : 	return m_iDOFGreatPersonModifier;

	mov	eax, DWORD PTR [ecx+480]

; 513  : }

	ret	0
?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetDOFGreatPersonModifier
_TEXT	ENDS
PUBLIC	?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandUnitMaintenanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetLandUnitMaintenanceModifier, COMDAT
; _this$ = ecx

; 518  : 	return m_iLandUnitMaintenanceModifier;

	mov	eax, DWORD PTR [ecx+468]

; 519  : }

	ret	0
?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetLandUnitMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNavalUnitMaintenanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNavalUnitMaintenanceModifier, COMDAT
; _this$ = ecx

; 524  : 	return m_iNavalUnitMaintenanceModifier;

	mov	eax, DWORD PTR [ecx+472]

; 525  : }

	ret	0
?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNavalUnitMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLuxuryHappinessRetention
; Function compile flags: /Ogtpy
;	COMDAT ?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetLuxuryHappinessRetention, COMDAT
; _this$ = ecx

; 530  : 	return m_iLuxuryHappinessRetention;

	mov	eax, DWORD PTR [ecx+484]

; 531  : }

	ret	0
?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetLuxuryHappinessRetention
_TEXT	ENDS
PUBLIC	?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetExtraHappinessPerLuxury
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetExtraHappinessPerLuxury, COMDAT
; _this$ = ecx

; 537  : 	return m_iExtraHappinessPerLuxury;

	mov	eax, DWORD PTR [ecx+488]

; 538  : }

	ret	0
?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetExtraHappinessPerLuxury
_TEXT	ENDS
PUBLIC	?GetExtraSpies@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetExtraSpies
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraSpies@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraSpies@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetExtraSpies, COMDAT
; _this$ = ecx

; 545  : 	return m_iExtraSpies;

	mov	eax, DWORD PTR [ecx+492]

; 546  : }

	ret	0
?GetExtraSpies@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetExtraSpies
_TEXT	ENDS
PUBLIC	?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetHappinessPerReligion
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetHappinessPerReligion, COMDAT
; _this$ = ecx

; 552  : 	return m_iHappinessPerReligion;

	mov	eax, DWORD PTR [ecx+496]

; 553  : }

	ret	0
?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetHappinessPerReligion
_TEXT	ENDS
PUBLIC	?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z	; std::_Container_base::_Swap_aux
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z PROC	; std::_Container_base::_Swap_aux, COMDAT
; _this$ = ecx

; 602  : 		// Do nothing: we don't have an aux object.
; 603  : 		}

	ret	4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z ENDP	; std::_Container_base::_Swap_aux
_TEXT	ENDS
PUBLIC	?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetUnresearchedTechBonusFromKills
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetUnresearchedTechBonusFromKills, COMDAT
; _this$ = ecx

; 559  : 	return m_iUnresearchedTechBonusFromKills;

	mov	eax, DWORD PTR [ecx+500]

; 560  : }

	ret	0
?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetUnresearchedTechBonusFromKills
_TEXT	ENDS
PUBLIC	?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetExtraFoundedCityTerritoryClaimRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetExtraFoundedCityTerritoryClaimRange, COMDAT
; _this$ = ecx

; 564  : 	return m_iExtraFoundedCityTerritoryClaimRange;

	mov	eax, DWORD PTR [ecx+504]

; 565  : }

	ret	0
?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetExtraFoundedCityTerritoryClaimRange
_TEXT	ENDS
PUBLIC	?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetFreeSocialPoliciesPerEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetFreeSocialPoliciesPerEra, COMDAT
; _this$ = ecx

; 570  : 	return m_iFreeSocialPoliciesPerEra;

	mov	eax, DWORD PTR [ecx+508]

; 571  : }

	ret	0
?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetFreeSocialPoliciesPerEra
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetNumTradeRoutesModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetNumTradeRoutesModifier, COMDAT
; _this$ = ecx

; 575  : 	return m_iNumTradeRoutesModifier;

	mov	eax, DWORD PTR [ecx+512]

; 576  : }

	ret	0
?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetNumTradeRoutesModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetTradeRouteResourceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetTradeRouteResourceModifier, COMDAT
; _this$ = ecx

; 580  : 	return m_iTradeRouteResourceModifier;

	mov	eax, DWORD PTR [ecx+516]

; 581  : }

	ret	0
?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetTradeRouteResourceModifier
_TEXT	ENDS
PUBLIC	?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetUniqueLuxuryCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetUniqueLuxuryCities, COMDAT
; _this$ = ecx

; 585  : 	return m_iUniqueLuxuryCities;

	mov	eax, DWORD PTR [ecx+520]

; 586  : }

	ret	0
?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetUniqueLuxuryCities
_TEXT	ENDS
PUBLIC	?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetUniqueLuxuryQuantity
; Function compile flags: /Ogtpy
;	COMDAT ?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetUniqueLuxuryQuantity, COMDAT
; _this$ = ecx

; 590  : 	return m_iUniqueLuxuryQuantity;

	mov	eax, DWORD PTR [ecx+524]

; 591  : }

	ret	0
?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetUniqueLuxuryQuantity
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetWorkerSpeedModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 595  : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR [ecx+528]

; 596  : }

	ret	0
?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetAfraidMinorPerTurnInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetAfraidMinorPerTurnInfluence, COMDAT
; _this$ = ecx

; 600  : 	return m_iAfraidMinorPerTurnInfluence;

	mov	eax, DWORD PTR [ecx+532]

; 601  : }

	ret	0
?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetAfraidMinorPerTurnInfluence
_TEXT	ENDS
PUBLIC	?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandTradeRouteRangeBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetLandTradeRouteRangeBonus, COMDAT
; _this$ = ecx

; 605  : 	return m_iLandTradeRouteRangeBonus;

	mov	eax, DWORD PTR [ecx+536]

; 606  : }

	ret	0
?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetLandTradeRouteRangeBonus
_TEXT	ENDS
PUBLIC	?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetTradeReligionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetTradeReligionModifier, COMDAT
; _this$ = ecx

; 610  : 	return m_iTradeReligionModifier;

	mov	eax, DWORD PTR [ecx+540]

; 611  : }

	ret	0
?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetTradeReligionModifier
_TEXT	ENDS
PUBLIC	?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetTradeBuildingModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetTradeBuildingModifier, COMDAT
; _this$ = ecx

; 615  : 	return m_iTradeBuildingModifier;

	mov	eax, DWORD PTR [ecx+544]

; 616  : }

	ret	0
?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetTradeBuildingModifier
_TEXT	ENDS
PUBLIC	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeBuildingPrereqTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ PROC ; CvTraitEntry::GetFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 622  : 	return m_eFreeBuildingPrereqTech;

	mov	eax, DWORD PTR [ecx+564]

; 623  : }

	ret	0
?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ENDP ; CvTraitEntry::GetFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ PROC ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 626  : 	return m_eCapitalFreeBuildingPrereqTech;

	mov	eax, DWORD PTR [ecx+568]

; 627  : }

	ret	0
?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ENDP ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeUnitPrereqTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ PROC ; CvTraitEntry::GetFreeUnitPrereqTech, COMDAT
; _this$ = ecx

; 632  : 	return m_eFreeUnitPrereqTech;

	mov	eax, DWORD PTR [ecx+548]

; 633  : }

	ret	0
?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ENDP ; CvTraitEntry::GetFreeUnitPrereqTech
_TEXT	ENDS
PUBLIC	?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ ; CvTraitEntry::GetCombatBonusImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ
_TEXT	SEGMENT
?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ PROC ; CvTraitEntry::GetCombatBonusImprovement, COMDAT
; _this$ = ecx

; 638  : 	return m_eCombatBonusImprovement;

	mov	eax, DWORD PTR [ecx+552]

; 639  : }

	ret	0
?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ ENDP ; CvTraitEntry::GetCombatBonusImprovement
_TEXT	ENDS
PUBLIC	?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvTraitEntry::GetFreeBuilding, COMDAT
; _this$ = ecx

; 644  : 	return m_eFreeBuilding;

	mov	eax, DWORD PTR [ecx+556]

; 645  : }

	ret	0
?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvTraitEntry::GetFreeBuilding
_TEXT	ENDS
PUBLIC	?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeCapitalBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvTraitEntry::GetFreeCapitalBuilding, COMDAT
; _this$ = ecx

; 650  : 	return m_eFreeCapitalBuilding;

	mov	eax, DWORD PTR [ecx+560]

; 651  : }

	ret	0
?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvTraitEntry::GetFreeCapitalBuilding
_TEXT	ENDS
PUBLIC	?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuildingOnConquest
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvTraitEntry::GetFreeBuildingOnConquest, COMDAT
; _this$ = ecx

; 656  : 	return m_eFreeBuildingOnConquest;

	mov	eax, DWORD PTR [ecx+572]

; 657  : }

	ret	0
?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvTraitEntry::GetFreeBuildingOnConquest
_TEXT	ENDS
PUBLIC	?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsFightWellDamaged
; Function compile flags: /Ogtpy
;	COMDAT ?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsFightWellDamaged, COMDAT
; _this$ = ecx

; 662  : 	return m_bFightWellDamaged;

	mov	al, BYTE PTR [ecx+576]

; 663  : }

	ret	0
?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsFightWellDamaged
_TEXT	ENDS
PUBLIC	?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsMoveFriendlyWoodsAsRoad
; Function compile flags: /Ogtpy
;	COMDAT ?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsMoveFriendlyWoodsAsRoad, COMDAT
; _this$ = ecx

; 668  : 	return m_bMoveFriendlyWoodsAsRoad;

	mov	al, BYTE PTR [ecx+577]

; 669  : }

	ret	0
?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsMoveFriendlyWoodsAsRoad
_TEXT	ENDS
PUBLIC	?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsFasterAlongRiver
; Function compile flags: /Ogtpy
;	COMDAT ?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsFasterAlongRiver, COMDAT
; _this$ = ecx

; 674  : 	return m_bFasterAlongRiver;

	mov	al, BYTE PTR [ecx+578]

; 675  : }

	ret	0
?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsFasterAlongRiver
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File s:\msvs2008\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?IsFasterInHills@CvTraitEntry@@QBE_NXZ		; CvTraitEntry::IsFasterInHills
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?IsFasterInHills@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFasterInHills@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsFasterInHills, COMDAT
; _this$ = ecx

; 680  : 	return m_bFasterInHills;

	mov	al, BYTE PTR [ecx+579]

; 681  : }

	ret	0
?IsFasterInHills@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsFasterInHills
_TEXT	ENDS
PUBLIC	?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsEmbarkedAllWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsEmbarkedAllWater, COMDAT
; _this$ = ecx

; 686  : 	return m_bEmbarkedAllWater;

	mov	al, BYTE PTR [ecx+580]

; 687  : }

	ret	0
?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsEmbarkedAllWater
_TEXT	ENDS
PUBLIC	?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsEmbarkedToLandFlatCost
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsEmbarkedToLandFlatCost, COMDAT
; _this$ = ecx

; 692  : 	return m_bEmbarkedToLandFlatCost;

	mov	al, BYTE PTR [ecx+581]

; 693  : }

	ret	0
?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsEmbarkedToLandFlatCost
_TEXT	ENDS
PUBLIC	?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsNoHillsImprovementMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsNoHillsImprovementMaintenance, COMDAT
; _this$ = ecx

; 698  : 	return m_bNoHillsImprovementMaintenance;

	mov	al, BYTE PTR [ecx+582]

; 699  : }

	ret	0
?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsNoHillsImprovementMaintenance
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
PUBLIC	?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsTechBoostFromCapitalScienceBuildings
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsTechBoostFromCapitalScienceBuildings, COMDAT
; _this$ = ecx

; 704  : 	return m_bTechBoostFromCapitalScienceBuildings;

	mov	al, BYTE PTR [ecx+583]

; 705  : }

	ret	0
?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsTechBoostFromCapitalScienceBuildings
_TEXT	ENDS
PUBLIC	?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsStaysAliveZeroCities
; Function compile flags: /Ogtpy
;	COMDAT ?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsStaysAliveZeroCities, COMDAT
; _this$ = ecx

; 710  : 	return m_bStaysAliveZeroCities;

	mov	al, BYTE PTR [ecx+584]

; 711  : }

	ret	0
?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsStaysAliveZeroCities
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsFaithFromUnimprovedForest
; Function compile flags: /Ogtpy
;	COMDAT ?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsFaithFromUnimprovedForest, COMDAT
; _this$ = ecx

; 716  : 	return m_bFaithFromUnimprovedForest;

	mov	al, BYTE PTR [ecx+585]

; 717  : }

	ret	0
?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsFaithFromUnimprovedForest
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsSeaTradeRoutesArePlunderImmune
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsSeaTradeRoutesArePlunderImmune, COMDAT
; _this$ = ecx

; 723  : 	return m_bSeaTradeRoutesArePlunderImmune;

	mov	al, BYTE PTR [ecx+586]

; 724  : }

	ret	0
?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsSeaTradeRoutesArePlunderImmune
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsEarnsGreatPersonOnSlotOrGuild
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsEarnsGreatPersonOnSlotOrGuild, COMDAT
; _this$ = ecx

; 731  : 	return m_bEarnsGreatPersonOnSlotOrGuild;

	mov	al, BYTE PTR [ecx+587]

; 732  : }

	ret	0
?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsEarnsGreatPersonOnSlotOrGuild
_TEXT	ENDS
PUBLIC	?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsHasBuiltWritersGuild
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsHasBuiltWritersGuild, COMDAT
; _this$ = ecx

; 736  : 	return m_bHasBuiltWritersGuild;

	mov	al, BYTE PTR [ecx+588]

; 737  : };

	ret	0
?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsHasBuiltWritersGuild
_TEXT	ENDS
PUBLIC	?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z	; CvTraitEntry::SetHasBuiltWritersGuild
; Function compile flags: /Ogtpy
;	COMDAT ?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z
_TEXT	SEGMENT
_hasBuilt$ = 8						; size = 1
?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z PROC	; CvTraitEntry::SetHasBuiltWritersGuild, COMDAT
; _this$ = ecx

; 741  : 	m_bHasBuiltWritersGuild = hasBuilt;

	mov	al, BYTE PTR _hasBuilt$[esp-4]
	mov	BYTE PTR [ecx+588], al

; 742  : };

	ret	4
?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z ENDP	; CvTraitEntry::SetHasBuiltWritersGuild
_TEXT	ENDS
PUBLIC	?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsHasBuiltArtistsGuild
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsHasBuiltArtistsGuild, COMDAT
; _this$ = ecx

; 746  : 	return m_bHasBuiltArtistsGuild;

	mov	al, BYTE PTR [ecx+589]

; 747  : };

	ret	0
?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsHasBuiltArtistsGuild
_TEXT	ENDS
PUBLIC	?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z	; CvTraitEntry::SetHasBuiltArtistsGuild
; Function compile flags: /Ogtpy
;	COMDAT ?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z
_TEXT	SEGMENT
_hasBuilt$ = 8						; size = 1
?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z PROC	; CvTraitEntry::SetHasBuiltArtistsGuild, COMDAT
; _this$ = ecx

; 751  : 	m_bHasBuiltArtistsGuild = hasBuilt;

	mov	al, BYTE PTR _hasBuilt$[esp-4]
	mov	BYTE PTR [ecx+589], al

; 752  : };

	ret	4
?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z ENDP	; CvTraitEntry::SetHasBuiltArtistsGuild
_TEXT	ENDS
PUBLIC	?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsHasBuiltMusiciansGuild
; Function compile flags: /Ogtpy
;	COMDAT ?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsHasBuiltMusiciansGuild, COMDAT
; _this$ = ecx

; 756  : 	return m_bHasBuiltMusiciansGuild;

	mov	al, BYTE PTR [ecx+590]

; 757  : };

	ret	0
?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsHasBuiltMusiciansGuild
_TEXT	ENDS
PUBLIC	?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z ; CvTraitEntry::SetHasBuiltMusiciansGuild
; Function compile flags: /Ogtpy
;	COMDAT ?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z
_TEXT	SEGMENT
_hasBuilt$ = 8						; size = 1
?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z PROC	; CvTraitEntry::SetHasBuiltMusiciansGuild, COMDAT
; _this$ = ecx

; 761  : 	m_bHasBuiltMusiciansGuild = hasBuilt;

	mov	al, BYTE PTR _hasBuilt$[esp-4]
	mov	BYTE PTR [ecx+590], al

; 762  : };

	ret	4
?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z ENDP	; CvTraitEntry::SetHasBuiltMusiciansGuild
_TEXT	ENDS
PUBLIC	?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsBonusReligiousBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsBonusReligiousBelief, COMDAT
; _this$ = ecx

; 768  : 	return m_bBonusReligiousBelief;

	mov	al, BYTE PTR [ecx+591]

; 769  : }

	ret	0
?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsBonusReligiousBelief
_TEXT	ENDS
PUBLIC	?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsAbleToAnnexCityStates
; Function compile flags: /Ogtpy
;	COMDAT ?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsAbleToAnnexCityStates, COMDAT
; _this$ = ecx

; 774  : 	return m_bAbleToAnnexCityStates;

	mov	al, BYTE PTR [ecx+592]

; 775  : }

	ret	0
?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsAbleToAnnexCityStates
_TEXT	ENDS
PUBLIC	?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsCrossesMountainsAfterGreatGeneral
; Function compile flags: /Ogtpy
;	COMDAT ?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsCrossesMountainsAfterGreatGeneral, COMDAT
; _this$ = ecx

; 780  : 	return m_bCrossesMountainsAfterGreatGeneral;

	mov	al, BYTE PTR [ecx+593]

; 781  : }

	ret	0
?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsCrossesMountainsAfterGreatGeneral
_TEXT	ENDS
PUBLIC	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsMayaCalendarBonuses
; Function compile flags: /Ogtpy
;	COMDAT ?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsMayaCalendarBonuses, COMDAT
; _this$ = ecx

; 786  : 	return m_bMayaCalendarBonuses;

	mov	al, BYTE PTR [ecx+594]

; 787  : }

	ret	0
?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsMayaCalendarBonuses
_TEXT	ENDS
PUBLIC	?IsNoAnnexing@CvTraitEntry@@QBE_NXZ		; CvTraitEntry::IsNoAnnexing
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoAnnexing@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoAnnexing@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsNoAnnexing, COMDAT
; _this$ = ecx

; 792  : 	return m_bNoAnnexing;

	mov	al, BYTE PTR [ecx+595]

; 793  : }

	ret	0
?IsNoAnnexing@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsNoAnnexing
_TEXT	ENDS
PUBLIC	?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsTechFromCityConquer
; Function compile flags: /Ogtpy
;	COMDAT ?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsTechFromCityConquer, COMDAT
; _this$ = ecx

; 798  : 	return m_bTechFromCityConquer;

	mov	al, BYTE PTR [ecx+596]

; 799  : }

	ret	0
?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsTechFromCityConquer
_TEXT	ENDS
PUBLIC	?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsUniqueLuxuryRequiresNewArea
; Function compile flags: /Ogtpy
;	COMDAT ?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsUniqueLuxuryRequiresNewArea, COMDAT
; _this$ = ecx

; 804  : 	return m_bUniqueLuxuryRequiresNewArea;

	mov	al, BYTE PTR [ecx+597]

; 805  : }

	ret	0
?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsUniqueLuxuryRequiresNewArea
_TEXT	ENDS
PUBLIC	?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ		; CvTraitEntry::IsRiverTradeRoad
; Function compile flags: /Ogtpy
;	COMDAT ?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsRiverTradeRoad, COMDAT
; _this$ = ecx

; 810  : 	return m_bRiverTradeRoad;

	mov	al, BYTE PTR [ecx+598]

; 811  : }

	ret	0
?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsRiverTradeRoad
_TEXT	ENDS
PUBLIC	?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsAngerFreeIntrusionOfCityStates
; Function compile flags: /Ogtpy
;	COMDAT ?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsAngerFreeIntrusionOfCityStates, COMDAT
; _this$ = ecx

; 816  : 	return m_bAngerFreeIntrusionOfCityStates;

	mov	al, BYTE PTR [ecx+599]

; 817  : }

	ret	0
?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsAngerFreeIntrusionOfCityStates
_TEXT	ENDS
PUBLIC	?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z	; CvTraitEntry::GetExtraYieldThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetExtraYieldThreshold, COMDAT
; _this$ = ecx

; 834  : 	return m_paiExtraYieldThreshold ? m_paiExtraYieldThreshold[i] : -1;

	mov	eax, DWORD PTR [ecx+628]
	test	eax, eax
	je	SHORT $LN3@GetExtraYi
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 835  : }

	ret	4
$LN3@GetExtraYi:

; 834  : 	return m_paiExtraYieldThreshold ? m_paiExtraYieldThreshold[i] : -1;

	or	eax, -1

; 835  : }

	ret	4
?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetExtraYieldThreshold
_TEXT	ENDS
PUBLIC	?GetYieldChange@CvTraitEntry@@QBEHH@Z		; CvTraitEntry::GetYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChange@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChange@CvTraitEntry@@QBEHH@Z PROC		; CvTraitEntry::GetYieldChange, COMDAT
; _this$ = ecx

; 840  : 	return m_paiYieldChange ? m_paiYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+632]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 841  : }

	ret	4
$LN3@GetYieldCh:

; 840  : 	return m_paiYieldChange ? m_paiYieldChange[i] : -1;

	or	eax, -1

; 841  : }

	ret	4
?GetYieldChange@CvTraitEntry@@QBEHH@Z ENDP		; CvTraitEntry::GetYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeStrategicResources
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangeStrategicResources, COMDAT
; _this$ = ecx

; 846  : 	return m_paiYieldChangeStrategicResources ? m_paiYieldChangeStrategicResources[i] : -1;

	mov	eax, DWORD PTR [ecx+636]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 847  : }

	ret	4
$LN3@GetYieldCh@2:

; 846  : 	return m_paiYieldChangeStrategicResources ? m_paiYieldChangeStrategicResources[i] : -1;

	or	eax, -1

; 847  : }

	ret	4
?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangeStrategicResources
_TEXT	ENDS
PUBLIC	?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeLuxuryResources
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangeLuxuryResources, COMDAT
; _this$ = ecx

; 853  : 	return m_paiYieldChangeLuxuryResources ? m_paiYieldChangeLuxuryResources[i] : -1;

	mov	eax, DWORD PTR [ecx+640]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 854  : }

	ret	4
$LN3@GetYieldCh@3:

; 853  : 	return m_paiYieldChangeLuxuryResources ? m_paiYieldChangeLuxuryResources[i] : -1;

	or	eax, -1

; 854  : }

	ret	4
?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangeLuxuryResources
_TEXT	ENDS
PUBLIC	?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetYieldChangeNaturalWonder, COMDAT
; _this$ = ecx

; 860  : 	return m_paiYieldChangeNaturalWonder ? m_paiYieldChangeNaturalWonder[i] : -1;

	mov	eax, DWORD PTR [ecx+644]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@4
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 861  : }

	ret	4
$LN3@GetYieldCh@4:

; 860  : 	return m_paiYieldChangeNaturalWonder ? m_paiYieldChangeNaturalWonder[i] : -1;

	or	eax, -1

; 861  : }

	ret	4
?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetYieldChangeNaturalWonder
_TEXT	ENDS
PUBLIC	?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangePerTradePartner
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangePerTradePartner, COMDAT
; _this$ = ecx

; 866  : 	return m_paiYieldChangePerTradePartner ? m_paiYieldChangePerTradePartner[i] : -1;

	mov	eax, DWORD PTR [ecx+648]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@5
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 867  : }

	ret	4
$LN3@GetYieldCh@5:

; 866  : 	return m_paiYieldChangePerTradePartner ? m_paiYieldChangePerTradePartner[i] : -1;

	or	eax, -1

; 867  : }

	ret	4
?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangePerTradePartner
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeIncomingTradeRoute
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangeIncomingTradeRoute, COMDAT
; _this$ = ecx

; 872  : 	return m_paiYieldChangeIncomingTradeRoute ? m_paiYieldChangeIncomingTradeRoute[i] : -1;

	mov	eax, DWORD PTR [ecx+652]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@6
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 873  : }

	ret	4
$LN3@GetYieldCh@6:

; 872  : 	return m_paiYieldChangeIncomingTradeRoute ? m_paiYieldChangeIncomingTradeRoute[i] : -1;

	or	eax, -1

; 873  : }

	ret	4
?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangeIncomingTradeRoute
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvTraitEntry@@QBEHH@Z		; CvTraitEntry::GetYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifier@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldModifier@CvTraitEntry@@QBEHH@Z PROC		; CvTraitEntry::GetYieldModifier, COMDAT
; _this$ = ecx

; 878  : 	return m_paiYieldModifier ? m_paiYieldModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+656]
	test	eax, eax
	je	SHORT $LN3@GetYieldMo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 879  : }

	ret	4
$LN3@GetYieldMo:

; 878  : 	return m_paiYieldModifier ? m_paiYieldModifier[i] : -1;

	or	eax, -1

; 879  : }

	ret	4
?GetYieldModifier@CvTraitEntry@@QBEHH@Z ENDP		; CvTraitEntry::GetYieldModifier
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
PUBLIC	?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetStrategicResourceQuantityModifier
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetStrategicResourceQuantityModifier, COMDAT
; _this$ = ecx

; 884  : 	return m_piStrategicResourceQuantityModifier ? m_piStrategicResourceQuantityModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+660]
	test	eax, eax
	je	SHORT $LN3@GetStrateg
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 885  : }

	ret	4
$LN3@GetStrateg:

; 884  : 	return m_piStrategicResourceQuantityModifier ? m_piStrategicResourceQuantityModifier[i] : -1;

	or	eax, -1

; 885  : }

	ret	4
?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetStrategicResourceQuantityModifier
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetResourceQuantityModifier
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetResourceQuantityModifier, COMDAT
; _this$ = ecx

; 890  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 891  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 892  : 	return m_piResourceQuantityModifiers ? m_piResourceQuantityModifiers[i] : -1;

	mov	eax, DWORD PTR [ecx+664]
	test	eax, eax
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 893  : }

	ret	4
$LN3@GetResourc:

; 890  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 891  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 892  : 	return m_piResourceQuantityModifiers ? m_piResourceQuantityModifiers[i] : -1;

	or	eax, -1

; 893  : }

	ret	4
?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetResourceQuantityModifier
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetImprovementYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTraitEntry::GetImprovementYieldChanges, COMDAT
; _this$ = ecx

; 898  : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "Index out of bounds");
; 899  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 900  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 901  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 902  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 903  : 	return m_ppiImprovementYieldChanges.first ? m_ppiImprovementYieldChanges.first[eIndex1][eIndex2] : 0;
; 904  : #else
; 905  : 	return m_ppiImprovementYieldChanges ? m_ppiImprovementYieldChanges[eIndex1][eIndex2] : 0;

	mov	eax, DWORD PTR [ecx+676]
	test	eax, eax
	je	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _eIndex1$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eIndex2$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 906  : #endif
; 907  : }

	ret	8
$LN3@GetImprove:

; 898  : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "Index out of bounds");
; 899  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 900  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 901  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 902  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 903  : 	return m_ppiImprovementYieldChanges.first ? m_ppiImprovementYieldChanges.first[eIndex1][eIndex2] : 0;
; 904  : #else
; 905  : 	return m_ppiImprovementYieldChanges ? m_ppiImprovementYieldChanges[eIndex1][eIndex2] : 0;

	xor	eax, eax

; 906  : #endif
; 907  : }

	ret	8
?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTraitEntry::GetImprovementYieldChanges
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetSpecialistYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z PROC ; CvTraitEntry::GetSpecialistYieldChanges, COMDAT
; _this$ = ecx

; 912  : 	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "Index out of bounds");
; 913  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 914  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 915  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 916  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 917  : 	return m_ppiSpecialistYieldChanges.first ? m_ppiSpecialistYieldChanges.first[eIndex1][eIndex2] : 0;
; 918  : #else
; 919  : 	return m_ppiSpecialistYieldChanges ? m_ppiSpecialistYieldChanges[eIndex1][eIndex2] : 0;

	mov	eax, DWORD PTR [ecx+680]
	test	eax, eax
	je	SHORT $LN3@GetSpecial
	mov	ecx, DWORD PTR _eIndex1$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eIndex2$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 920  : #endif
; 921  : }

	ret	8
$LN3@GetSpecial:

; 912  : 	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "Index out of bounds");
; 913  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 914  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 915  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 916  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 917  : 	return m_ppiSpecialistYieldChanges.first ? m_ppiSpecialistYieldChanges.first[eIndex1][eIndex2] : 0;
; 918  : #else
; 919  : 	return m_ppiSpecialistYieldChanges ? m_ppiSpecialistYieldChanges[eIndex1][eIndex2] : 0;

	xor	eax, eax

; 920  : #endif
; 921  : }

	ret	8
?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ENDP ; CvTraitEntry::GetSpecialistYieldChanges
_TEXT	ENDS
PUBLIC	?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetUnimprovedFeatureYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z PROC ; CvTraitEntry::GetUnimprovedFeatureYieldChanges, COMDAT
; _this$ = ecx

; 926  : 	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "Index out of bounds");
; 927  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 928  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 929  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 930  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 931  : 	return m_ppiUnimprovedFeatureYieldChanges.first ? m_ppiUnimprovedFeatureYieldChanges.first[eIndex1][eIndex2] : 0;
; 932  : #else
; 933  : 	return m_ppiUnimprovedFeatureYieldChanges ? m_ppiUnimprovedFeatureYieldChanges[eIndex1][eIndex2] : 0;

	mov	eax, DWORD PTR [ecx+684]
	test	eax, eax
	je	SHORT $LN3@GetUnimpro
	mov	ecx, DWORD PTR _eIndex1$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eIndex2$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 934  : #endif
; 935  : }

	ret	8
$LN3@GetUnimpro:

; 926  : 	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "Index out of bounds");
; 927  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 928  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 929  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 930  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 931  : 	return m_ppiUnimprovedFeatureYieldChanges.first ? m_ppiUnimprovedFeatureYieldChanges.first[eIndex1][eIndex2] : 0;
; 932  : #else
; 933  : 	return m_ppiUnimprovedFeatureYieldChanges ? m_ppiUnimprovedFeatureYieldChanges[eIndex1][eIndex2] : 0;

	xor	eax, eax

; 934  : #endif
; 935  : }

	ret	8
?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ENDP ; CvTraitEntry::GetUnimprovedFeatureYieldChanges
_TEXT	ENDS
PUBLIC	?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z	; CvTraitEntry::GetMovesChangeUnitCombat
; Function compile flags: /Ogtpy
;	COMDAT ?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_unitCombatID$ = 8					; size = 4
?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetMovesChangeUnitCombat, COMDAT
; _this$ = ecx

; 940  : 	CvAssertMsg((unitCombatID >= 0), "unitCombatID is less than zero");
; 941  : 	CvAssertMsg((unitCombatID < GC.getNumUnitCombatClassInfos()), "unitCombatID exceeds number of combat classes");
; 942  : 
; 943  : 	return m_piMovesChangeUnitCombats[unitCombatID];

	mov	eax, DWORD PTR [ecx+668]
	mov	ecx, DWORD PTR _unitCombatID$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 944  : }

	ret	4
?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetMovesChangeUnitCombat
_TEXT	ENDS
PUBLIC	?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetMaintenanceModifierUnitCombat
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_unitCombatID$ = 8					; size = 4
?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetMaintenanceModifierUnitCombat, COMDAT
; _this$ = ecx

; 949  : 	CvAssertMsg((unitCombatID >= 0), "unitCombatID is less than zero");
; 950  : 	CvAssertMsg((unitCombatID < GC.getNumUnitCombatClassInfos()), "unitCombatID exceeds number of combat classes");
; 951  : 
; 952  : 	return m_piMaintenanceModifierUnitCombats[unitCombatID];

	mov	eax, DWORD PTR [ecx+672]
	mov	ecx, DWORD PTR _unitCombatID$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 953  : }

	ret	4
?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetMaintenanceModifierUnitCombat
_TEXT	ENDS
PUBLIC	?GetObsoleteTech@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetObsoleteTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetObsoleteTech@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetObsoleteTech@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetObsoleteTech, COMDAT
; _this$ = ecx

; 964  : 	return m_iObsoleteTech;

	mov	eax, DWORD PTR [ecx+416]

; 965  : }

	ret	0
?GetObsoleteTech@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetObsoleteTech
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?GetPrereqTech@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetPrereqTech
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetPrereqTech@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqTech@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetPrereqTech, COMDAT
; _this$ = ecx

; 970  : 	return m_iPrereqTech;

	mov	eax, DWORD PTR [ecx+420]

; 971  : }

	ret	0
?GetPrereqTech@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetPrereqTech
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ; CvTraitXMLEntries::GetTraitEntries
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ PROC ; CvTraitXMLEntries::GetTraitEntries, COMDAT
; _this$ = ecx

; 1510 : {

	mov	eax, ecx

; 1511 : 	return m_paTraitEntries;
; 1512 : }

	ret	0
?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ENDP ; CvTraitXMLEntries::GetTraitEntries
_TEXT	ENDS
PUBLIC	?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z ; CvPlayerTraits::GetCapitalBuildingDiscount
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eBuilding$ = 8						; size = 4
?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z PROC ; CvPlayerTraits::GetCapitalBuildingDiscount, COMDAT
; _this$ = ecx

; 2507 : {

	push	esi
	mov	esi, ecx

; 2508 : 	if(m_iCapitalBuildingModifier > 0)

	cmp	DWORD PTR [esi+112], 0
	jle	SHORT $LN1@GetCapital

; 2509 : 	{
; 2510 : 		// Find this player's capital
; 2511 : 		CvCity* pCapital = m_pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR [esi+4]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 2512 : 		if(pCapital)

	test	eax, eax
	je	SHORT $LN1@GetCapital

; 2513 : 		{
; 2514 : 			if(pCapital->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$[esp]
	push	ecx
	mov	ecx, eax
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN1@GetCapital

; 2515 : 			{
; 2516 : 				return m_iCapitalBuildingModifier;

	mov	eax, DWORD PTR [esi+112]
	pop	esi

; 2521 : }

	ret	4
$LN1@GetCapital:

; 2517 : 			}
; 2518 : 		}
; 2519 : 	}
; 2520 : 	return 0;

	xor	eax, eax
	pop	esi

; 2521 : }

	ret	4
?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z ENDP ; CvPlayerTraits::GetCapitalBuildingDiscount
_TEXT	ENDS
PUBLIC	?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsAbleToCrossMountains
; Function compile flags: /Ogtpy
;	COMDAT ?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsAbleToCrossMountains, COMDAT
; _this$ = ecx

; 2596 : 	return (m_bCrossesMountainsAfterGreatGeneral /*&& m_pPlayer->getGreatGeneralsCreated() > 0*/); // NQMP GJS - new Carthage UA no longer needs Great General

	mov	al, BYTE PTR [ecx+341]

; 2597 : }

	ret	0
?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsAbleToCrossMountains
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::operator=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::operator=, COMDAT
; _this$ = ecx

; 623  : 		{

	mov	eax, ecx

; 624  : 		return *this;
; 625  : 		}

	ret	4
??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::operator=
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@I@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@I@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]

; 771  : 		}

	ret	4
??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@I@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV?$Array@H$05@Firaxis@@I@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV?$Array@H$05@Firaxis@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV?$Array@H$05@Firaxis@@I@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*8]

; 786  : 		}

	ret	4
??A?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV?$Array@H$05@Firaxis@@I@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEABUFreeResourceXCities@@I@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEABUFreeResourceXCities@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEABUFreeResourceXCities@@I@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 771  : 		}

	ret	4
??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEABUFreeResourceXCities@@I@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAUFreeResourceXCities@@I@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAUFreeResourceXCities@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAUFreeResourceXCities@@I@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 786  : 		}

	ret	4
??A?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAUFreeResourceXCities@@I@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAPAVCvTraitEntry@@I@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEABW4TraitTypes@@I@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEABW4TraitTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEABW4TraitTypes@@I@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEABW4TraitTypes@@I@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UFreeTraitUnit@@$00@@QAEAAUFreeTraitUnit@@I@Z ; BaseVector<FreeTraitUnit,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UFreeTraitUnit@@$00@@QAEAAUFreeTraitUnit@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UFreeTraitUnit@@$00@@QAEAAUFreeTraitUnit@@I@Z PROC ; BaseVector<FreeTraitUnit,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UFreeTraitUnit@@$00@@QAEAAUFreeTraitUnit@@I@Z ENDP ; BaseVector<FreeTraitUnit,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UFreeTraitUnit@@$00@@QBEIXZ	; BaseVector<FreeTraitUnit,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UFreeTraitUnit@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UFreeTraitUnit@@$00@@QBEIXZ PROC	; BaseVector<FreeTraitUnit,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UFreeTraitUnit@@$00@@QBEIXZ ENDP	; BaseVector<FreeTraitUnit,1>::size
_TEXT	ENDS
PUBLIC	?size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::size
_TEXT	ENDS
PUBLIC	??0?$pair@HH@std@@QAE@ABH0@Z			; std::pair<int,int>::pair<int,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@HH@std@@QAE@ABH0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@HH@std@@QAE@ABH0@Z PROC			; std::pair<int,int>::pair<int,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@HH@std@@QAE@ABH0@Z ENDP			; std::pair<int,int>::pair<int,int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\functional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setl	al

; 144  : 		}

	ret	8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::key_comp
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::key_comp, COMDAT
; _this$ = ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 622  : 		}

	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::key_comp
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >::~_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >::~_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >::~_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UFreeResourceXCities@@@std@@QAE@XZ ; std::allocator<FreeResourceXCities>::allocator<FreeResourceXCities>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@UFreeResourceXCities@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UFreeResourceXCities@@@std@@QAE@XZ PROC	; std::allocator<FreeResourceXCities>::allocator<FreeResourceXCities>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UFreeResourceXCities@@@std@@QAE@XZ ENDP	; std::allocator<FreeResourceXCities>::allocator<FreeResourceXCities>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTraitEntry@@@std@@QAE@XZ	; std::allocator<CvTraitEntry *>::allocator<CvTraitEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTraitEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvTraitEntry@@@std@@QAE@XZ PROC	; std::allocator<CvTraitEntry *>::allocator<CvTraitEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvTraitEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvTraitEntry *>::allocator<CvTraitEntry *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::capacity
_TEXT	ENDS
PUBLIC	??0?$allocator@W4TraitTypes@@@std@@QAE@XZ	; std::allocator<enum TraitTypes>::allocator<enum TraitTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@W4TraitTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4TraitTypes@@@std@@QAE@XZ PROC		; std::allocator<enum TraitTypes>::allocator<enum TraitTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4TraitTypes@@@std@@QAE@XZ ENDP		; std::allocator<enum TraitTypes>::allocator<enum TraitTypes>
_TEXT	ENDS
PUBLIC	??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEPAUFreeTraitUnit@@I@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ DB 's:\github\l'
	DB	'ekmod\lekmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEPAUFreeTraitUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEPAUFreeTraitUnit@@I@Z PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 5
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 5
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEPAUFreeTraitUnit@@I@Z ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ	; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ PROC	; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ ENDP	; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UFreeTraitUnit@@$00@@IAE@XZ	; BaseVector<FreeTraitUnit,1>::BaseVector<FreeTraitUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UFreeTraitUnit@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UFreeTraitUnit@@$00@@IAE@XZ PROC	; BaseVector<FreeTraitUnit,1>::BaseVector<FreeTraitUnit,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UFreeTraitUnit@@$00@@IAE@XZ ENDP	; BaseVector<FreeTraitUnit,1>::BaseVector<FreeTraitUnit,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UFreeTraitUnit@@$00@@IAEXPAUFreeTraitUnit@@I@Z ; BaseVector<FreeTraitUnit,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UFreeTraitUnit@@$00@@IAEXPAUFreeTraitUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UFreeTraitUnit@@$00@@IAEXPAUFreeTraitUnit@@I@Z PROC ; BaseVector<FreeTraitUnit,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UFreeTraitUnit@@$00@@IAEXPAUFreeTraitUnit@@I@Z ENDP ; BaseVector<FreeTraitUnit,1>::Destroy
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >::~_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >::~_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >::~_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UMayaBonusChoice@@@std@@QAE@XZ	; std::allocator<MayaBonusChoice>::allocator<MayaBonusChoice>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@UMayaBonusChoice@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UMayaBonusChoice@@@std@@QAE@XZ PROC	; std::allocator<MayaBonusChoice>::allocator<MayaBonusChoice>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UMayaBonusChoice@@@std@@QAE@XZ ENDP	; std::allocator<MayaBonusChoice>::allocator<MayaBonusChoice>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEABQAVCvTraitEntry@@XZ ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEABQAVCvTraitEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEABQAVCvTraitEntry@@XZ PROC ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEABQAVCvTraitEntry@@XZ ENDP ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEABUMayaBonusChoice@@XZ ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEABUMayaBonusChoice@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEABUMayaBonusChoice@@XZ PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEABUMayaBonusChoice@@XZ ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 8

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z PROC ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@PAUMayaBonusChoice@@@Z ENDP ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Isnil
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 21					; 00000015H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBHH@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::size
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Root
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Kfn
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@SAABHABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBHH@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,int> >::allocator<std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T228765 = -80						; size = 28
$T228764 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T228765[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T228764[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T228765[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T228764[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T228764[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T228764[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T228764[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T228765[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T228764[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >::_Container_base_aux_alloc_empty<std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UFreeResourceXCities@@@std@@QAE@ABV01@@Z ; std::allocator<FreeResourceXCities>::allocator<FreeResourceXCities>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@UFreeResourceXCities@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UFreeResourceXCities@@@std@@QAE@ABV01@@Z PROC ; std::allocator<FreeResourceXCities>::allocator<FreeResourceXCities>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UFreeResourceXCities@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<FreeResourceXCities>::allocator<FreeResourceXCities>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@I@Z ; std::allocator<FreeResourceXCities>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@I@Z PROC ; std::allocator<FreeResourceXCities>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@I@Z ENDP ; std::allocator<FreeResourceXCities>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T228800 = -80						; size = 28
$T228799 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T228800[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T228799[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T228800[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T228799[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T228799[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T228799[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T228799[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T228800[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T228799[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTraitEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvTraitEntry *>::allocator<CvTraitEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTraitEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvTraitEntry@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvTraitEntry *>::allocator<CvTraitEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvTraitEntry@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvTraitEntry *>::allocator<CvTraitEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvTraitEntry@@@std@@QAEXPAPAVCvTraitEntry@@I@Z ; std::allocator<CvTraitEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvTraitEntry@@@std@@QAEXPAPAVCvTraitEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvTraitEntry@@@std@@QAEXPAPAVCvTraitEntry@@I@Z PROC ; std::allocator<CvTraitEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvTraitEntry@@@std@@QAEXPAPAVCvTraitEntry@@I@Z ENDP ; std::allocator<CvTraitEntry *>::deallocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Make_iter
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T228845 = -80						; size = 28
$T228844 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T228845[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T228844[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T228845[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T228844[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T228844[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T228844[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T228844[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T228845[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T228844[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >::_Container_base_aux_alloc_empty<std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UMayaBonusChoice@@@std@@QAE@ABV01@@Z ; std::allocator<MayaBonusChoice>::allocator<MayaBonusChoice>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@UMayaBonusChoice@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UMayaBonusChoice@@@std@@QAE@ABV01@@Z PROC ; std::allocator<MayaBonusChoice>::allocator<MayaBonusChoice>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UMayaBonusChoice@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<MayaBonusChoice>::allocator<MayaBonusChoice>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@I@Z ; std::allocator<MayaBonusChoice>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@I@Z PROC ; std::allocator<MayaBonusChoice>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@I@Z ENDP ; std::allocator<MayaBonusChoice>::deallocate
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator-
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::iterator
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z PROC ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z ENDP ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator-
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator-
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator-
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Color
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 20					; 00000014H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Color
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+21], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UFreeResourceXCities@@@std@@QBEIXZ ; std::allocator<FreeResourceXCities>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UFreeResourceXCities@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UFreeResourceXCities@@@std@@QBEIXZ PROC ; std::allocator<FreeResourceXCities>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@UFreeResourceXCities@@@std@@QBEIXZ ENDP ; std::allocator<FreeResourceXCities>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvTraitEntry@@@std@@QBEIXZ ; std::allocator<CvTraitEntry *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvTraitEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvTraitEntry@@@std@@QBEIXZ PROC ; std::allocator<CvTraitEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvTraitEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvTraitEntry *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UMayaBonusChoice@@@std@@QBEIXZ ; std::allocator<MayaBonusChoice>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UMayaBonusChoice@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UMayaBonusChoice@@@std@@QBEIXZ PROC ; std::allocator<MayaBonusChoice>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@UMayaBonusChoice@@@std@@QBEIXZ ENDP ; std::allocator<MayaBonusChoice>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z PROC ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z ENDP ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,int> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,int> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBHH@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,int> >::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+=
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+=
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node::_Node
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHH@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z ; std::pair<int const ,int>::pair<int const ,int><int,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z PROC	; std::pair<int const ,int>::pair<int const ,int><int,int>, COMDAT
; _this$ = ecx

; 57   : 		{	// construct from compatible pair

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 58   : 		}

	ret	4
??$?0HH@?$pair@$$CBHH@std@@QAE@ABU?$pair@HH@1@@Z ENDP	; std::pair<int const ,int>::pair<int const ,int><int,int>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z ; std::operator==<std::pair<int const ,int>,std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z PROC ; std::operator==<std::pair<int const ,int>,std::pair<int const ,int> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBHH@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHH@std@@@0@0@Z ENDP ; std::operator==<std::pair<int const ,int>,std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z PROC ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@0@Z ENDP ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
_TEXT	ENDS
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ; std::_Allocate<FreeResourceXCities>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z
_TEXT	SEGMENT
$T229190 = -12						; size = 12
$T229194 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z PROC ; std::_Allocate<FreeResourceXCities>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229194[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229190[esp+16]
	mov	DWORD PTR $T229194[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229190[esp+16]
	push	ecx
	mov	DWORD PTR $T229190[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ENDP ; std::_Allocate<FreeResourceXCities>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z ; std::_Allocate<CvTraitEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T229200 = -12						; size = 12
$T229204 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvTraitEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229204[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229200[esp+16]
	mov	DWORD PTR $T229204[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229200[esp+16]
	push	ecx
	mov	DWORD PTR $T229200[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvTraitEntry *>
_TEXT	ENDS
PUBLIC	??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ; std::_Allocate<MayaBonusChoice>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z
_TEXT	SEGMENT
$T229210 = -12						; size = 12
$T229214 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z PROC ; std::_Allocate<MayaBonusChoice>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229214[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229210[esp+16]
	mov	DWORD PTR $T229214[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229210[esp+16]
	push	ecx
	mov	DWORD PTR $T229210[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ENDP ; std::_Allocate<MayaBonusChoice>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node><std::pair<int const ,int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node><std::pair<int const ,int> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHH@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node><std::pair<int const ,int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T229223 = -12						; size = 12
$T229227 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229227[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229223[esp+16]
	mov	DWORD PTR $T229227[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229223[esp+16]
	push	ecx
	mov	DWORD PTR $T229223[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QBEPBHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QBEPBHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QBEPBHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::swap<std::less<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC	; std::swap<std::less<int> >, COMDAT

; 18   : 	if (&_Left != &_Right)
; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;
; 21   : 
; 22   : 		_Left = _Right;
; 23   : 		_Right = _Tmp;
; 24   : 		}
; 25   : 	}

	ret	0
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP	; std::swap<std::less<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUFreeResourceXCities@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFreeResourceXCities@@0@Z ; std::_Iter_random<FreeResourceXCities *,FreeResourceXCities *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUFreeResourceXCities@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFreeResourceXCities@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUFreeResourceXCities@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFreeResourceXCities@@0@Z PROC ; std::_Iter_random<FreeResourceXCities *,FreeResourceXCities *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUFreeResourceXCities@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUFreeResourceXCities@@0@Z ENDP ; std::_Iter_random<FreeResourceXCities *,FreeResourceXCities *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUFreeResourceXCities@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUFreeResourceXCities@@0@Z ; std::_Ptr_cat<FreeResourceXCities *,FreeResourceXCities *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUFreeResourceXCities@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUFreeResourceXCities@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUFreeResourceXCities@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUFreeResourceXCities@@0@Z PROC ; std::_Ptr_cat<FreeResourceXCities *,FreeResourceXCities *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUFreeResourceXCities@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUFreeResourceXCities@@0@Z ENDP ; std::_Ptr_cat<FreeResourceXCities *,FreeResourceXCities *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTraitEntry@@0@Z ; std::_Iter_random<CvTraitEntry * *,CvTraitEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTraitEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTraitEntry@@0@Z PROC ; std::_Iter_random<CvTraitEntry * *,CvTraitEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTraitEntry@@0@Z ENDP ; std::_Iter_random<CvTraitEntry * *,CvTraitEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTraitEntry@@0@Z ; std::_Ptr_cat<CvTraitEntry * *,CvTraitEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTraitEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTraitEntry@@0@Z PROC ; std::_Ptr_cat<CvTraitEntry * *,CvTraitEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvTraitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTraitEntry@@0@Z ENDP ; std::_Ptr_cat<CvTraitEntry * *,CvTraitEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvTraitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTraitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTraitEntry * *,CvTraitEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvTraitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTraitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvTraitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTraitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTraitEntry * *,CvTraitEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvTraitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTraitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTraitEntry * *,CvTraitEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4TraitTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4TraitTypes@@0@Z ; std::_Iter_random<enum TraitTypes *,enum TraitTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4TraitTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4TraitTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4TraitTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4TraitTypes@@0@Z PROC ; std::_Iter_random<enum TraitTypes *,enum TraitTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4TraitTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4TraitTypes@@0@Z ENDP ; std::_Iter_random<enum TraitTypes *,enum TraitTypes *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@3
	push	esi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@3
	pop	esi
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUMayaBonusChoice@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMayaBonusChoice@@0@Z ; std::_Iter_random<MayaBonusChoice *,MayaBonusChoice *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUMayaBonusChoice@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMayaBonusChoice@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUMayaBonusChoice@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMayaBonusChoice@@0@Z PROC ; std::_Iter_random<MayaBonusChoice *,MayaBonusChoice *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUMayaBonusChoice@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMayaBonusChoice@@0@Z ENDP ; std::_Iter_random<MayaBonusChoice *,MayaBonusChoice *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUMayaBonusChoice@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMayaBonusChoice@@0@Z ; std::_Ptr_cat<MayaBonusChoice *,MayaBonusChoice *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUMayaBonusChoice@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMayaBonusChoice@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUMayaBonusChoice@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMayaBonusChoice@@0@Z PROC ; std::_Ptr_cat<MayaBonusChoice *,MayaBonusChoice *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUMayaBonusChoice@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUMayaBonusChoice@@0@Z ENDP ; std::_Ptr_cat<MayaBonusChoice *,MayaBonusChoice *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@4
	push	esi
$LL3@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@4
	pop	esi
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z ; std::_Fill<FreeResourceXCities *,FreeResourceXCities>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z PROC ; std::_Fill<FreeResourceXCities *,FreeResourceXCities>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z ENDP ; std::_Fill<FreeResourceXCities *,FreeResourceXCities>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUFreeResourceXCities@@@std@@YA?AU_Undefined_move_tag@0@ABQAUFreeResourceXCities@@@Z ; std::_Move_cat<FreeResourceXCities *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUFreeResourceXCities@@@std@@YA?AU_Undefined_move_tag@0@ABQAUFreeResourceXCities@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUFreeResourceXCities@@@std@@YA?AU_Undefined_move_tag@0@ABQAUFreeResourceXCities@@@Z PROC ; std::_Move_cat<FreeResourceXCities *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUFreeResourceXCities@@@std@@YA?AU_Undefined_move_tag@0@ABQAUFreeResourceXCities@@@Z ENDP ; std::_Move_cat<FreeResourceXCities *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTraitEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z ; std::_Fill<enum TraitTypes *,enum TraitTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z PROC ; std::_Fill<enum TraitTypes *,enum TraitTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z ENDP ; std::_Fill<enum TraitTypes *,enum TraitTypes>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4TraitTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4TraitTypes@@@Z ; std::_Move_cat<enum TraitTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4TraitTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4TraitTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4TraitTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4TraitTypes@@@Z PROC ; std::_Move_cat<enum TraitTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4TraitTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4TraitTypes@@@Z ENDP ; std::_Move_cat<enum TraitTypes *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z ; std::_Fill<MayaBonusChoice *,MayaBonusChoice>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z PROC ; std::_Fill<MayaBonusChoice *,MayaBonusChoice>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z ENDP ; std::_Fill<MayaBonusChoice *,MayaBonusChoice>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUMayaBonusChoice@@@std@@YA?AU_Undefined_move_tag@0@ABQAUMayaBonusChoice@@@Z ; std::_Move_cat<MayaBonusChoice *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUMayaBonusChoice@@@std@@YA?AU_Undefined_move_tag@0@ABQAUMayaBonusChoice@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUMayaBonusChoice@@@std@@YA?AU_Undefined_move_tag@0@ABQAUMayaBonusChoice@@@Z PROC ; std::_Move_cat<MayaBonusChoice *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUMayaBonusChoice@@@std@@YA?AU_Undefined_move_tag@0@ABQAUMayaBonusChoice@@@Z ENDP ; std::_Move_cat<MayaBonusChoice *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@3
	push	esi
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@3
	pop	esi
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@ABU1@@Z ; std::_Construct<FreeResourceXCities,FreeResourceXCities>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Construct@UFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@ABU1@@Z PROC ; std::_Construct<FreeResourceXCities,FreeResourceXCities>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@UFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@ABU1@@Z ENDP ; std::_Construct<FreeResourceXCities,FreeResourceXCities>
_TEXT	ENDS
PUBLIC	??$_Destroy@UFreeResourceXCities@@@std@@YAXPAUFreeResourceXCities@@@Z ; std::_Destroy<FreeResourceXCities>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UFreeResourceXCities@@@std@@YAXPAUFreeResourceXCities@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UFreeResourceXCities@@@std@@YAXPAUFreeResourceXCities@@@Z PROC ; std::_Destroy<FreeResourceXCities>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UFreeResourceXCities@@@std@@YAXPAUFreeResourceXCities@@@Z ENDP ; std::_Destroy<FreeResourceXCities>
_TEXT	ENDS
PUBLIC	??$_Destroy@UMayaBonusChoice@@@std@@YAXPAUMayaBonusChoice@@@Z ; std::_Destroy<MayaBonusChoice>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UMayaBonusChoice@@@std@@YAXPAUMayaBonusChoice@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UMayaBonusChoice@@@std@@YAXPAUMayaBonusChoice@@@Z PROC ; std::_Destroy<MayaBonusChoice>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UMayaBonusChoice@@@std@@YAXPAUMayaBonusChoice@@@Z ENDP ; std::_Destroy<MayaBonusChoice>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getGOLD_FROM_BARBARIAN_CONVERSION@CvGlobals@@QAEHXZ ; CvGlobals::getGOLD_FROM_BARBARIAN_CONVERSION
; Function compile flags: /Ogtpy
;	COMDAT ?getGOLD_FROM_BARBARIAN_CONVERSION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getGOLD_FROM_BARBARIAN_CONVERSION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getGOLD_FROM_BARBARIAN_CONVERSION, COMDAT
; _this$ = ecx

; 6144 : 		return m_iGOLD_FROM_BARBARIAN_CONVERSION;

	mov	eax, DWORD PTR [ecx+7068]

; 6145 : 	}

	ret	0
?getGOLD_FROM_BARBARIAN_CONVERSION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getGOLD_FROM_BARBARIAN_CONVERSION
_TEXT	ENDS
PUBLIC	?getTRAIT_WOUNDED_DAMAGE_MOD@CvGlobals@@QAEHXZ	; CvGlobals::getTRAIT_WOUNDED_DAMAGE_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getTRAIT_WOUNDED_DAMAGE_MOD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTRAIT_WOUNDED_DAMAGE_MOD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getTRAIT_WOUNDED_DAMAGE_MOD, COMDAT
; _this$ = ecx

; 6589 : 		return m_iTRAIT_WOUNDED_DAMAGE_MOD;

	mov	eax, DWORD PTR [ecx+7460]

; 6590 : 	}

	ret	0
?getTRAIT_WOUNDED_DAMAGE_MOD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getTRAIT_WOUNDED_DAMAGE_MOD
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT, COMDAT
; _this$ = ecx

; 7355 : 		return m_iBARBARIAN_CAMP_IMPROVEMENT;

	mov	eax, DWORD PTR [ecx+8548]

; 7356 : 	}

	ret	0
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetID@CvArea@@QBEHXZ				; CvArea::GetID
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
;	COMDAT ?GetID@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvArea@@QBEHXZ PROC				; CvArea::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvArea@@QBEHXZ ENDP				; CvArea::GetID
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??0FreeResourceXCities@@QAE@XZ			; FreeResourceXCities::FreeResourceXCities
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ??0FreeResourceXCities@@QAE@XZ
_TEXT	SEGMENT
??0FreeResourceXCities@@QAE@XZ PROC			; FreeResourceXCities::FreeResourceXCities, COMDAT
; _this$ = ecx

; 18   : 	{};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0FreeResourceXCities@@QAE@XZ ENDP			; FreeResourceXCities::FreeResourceXCities
_TEXT	ENDS
PUBLIC	??0MayaBonusChoice@@QAE@XZ			; MayaBonusChoice::MayaBonusChoice
; Function compile flags: /Ogtpy
;	COMDAT ??0MayaBonusChoice@@QAE@XZ
_TEXT	SEGMENT
??0MayaBonusChoice@@QAE@XZ PROC				; MayaBonusChoice::MayaBonusChoice, COMDAT
; _this$ = ecx

; 29   : 	{};

	mov	eax, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], 0
	ret	0
??0MayaBonusChoice@@QAE@XZ ENDP				; MayaBonusChoice::MayaBonusChoice
_TEXT	ENDS
PUBLIC	??0MayaBonusChoice@@QAE@ABU0@@Z			; MayaBonusChoice::MayaBonusChoice
; Function compile flags: /Ogtpy
;	COMDAT ??0MayaBonusChoice@@QAE@ABU0@@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
??0MayaBonusChoice@@QAE@ABU0@@Z PROC			; MayaBonusChoice::MayaBonusChoice, COMDAT
; _this$ = ecx

; 31   : 	MayaBonusChoice(const MayaBonusChoice& in)

	mov	eax, ecx

; 32   : 	{
; 33   : 		m_eUnitType = in.m_eUnitType;

	mov	ecx, DWORD PTR _in$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 34   : 		m_iBaktunJustFinished = in.m_iBaktunJustFinished;

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 35   : 	};

	ret	4
??0MayaBonusChoice@@QAE@ABU0@@Z ENDP			; MayaBonusChoice::MayaBonusChoice
_TEXT	ENDS
PUBLIC	?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetLandBarbarianConversionPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetLandBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 479  : 		return m_iLandBarbarianConversionPercent;

	mov	eax, DWORD PTR [ecx+100]

; 480  : 	};

	ret	0
?GetLandBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetLandBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?GetSeaBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetSeaBarbarianConversionPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeaBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetSeaBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetSeaBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 487  : 		return m_iSeaBarbarianConversionPercent;

	mov	eax, DWORD PTR [ecx+108]

; 488  : 	};

	ret	0
?GetSeaBarbarianConversionPercent@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetSeaBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4TraitTypes@@@std@@QAE@ABV01@@Z	; std::allocator<enum TraitTypes>::allocator<enum TraitTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@W4TraitTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4TraitTypes@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum TraitTypes>::allocator<enum TraitTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4TraitTypes@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum TraitTypes>::allocator<enum TraitTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T229529 = -80						; size = 28
$T229528 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229529[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229528[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229529[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229528[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229528[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229528[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229528[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T229529[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T229528[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T229563 = -80						; size = 28
$T229562 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229563[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229562[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229563[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229562[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229562[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229562[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229562[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T229563[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T229562[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@I@Z ; std::allocator<enum TraitTypes>::deallocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@I@Z PROC ; std::allocator<enum TraitTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@I@Z ENDP ; std::allocator<enum TraitTypes>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z PROC ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z ENDP ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4TraitTypes@@@std@@QBEIXZ ; std::allocator<enum TraitTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4TraitTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4TraitTypes@@@std@@QBEIXZ PROC	; std::allocator<enum TraitTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4TraitTypes@@@std@@QBEIXZ ENDP	; std::allocator<enum TraitTypes>::max_size
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T229624 = -12						; size = 12
$T229628 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229628[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229624[esp+16]
	mov	DWORD PTR $T229628[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229624[esp+16]
	push	ecx
	mov	DWORD PTR $T229624[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ; std::_Allocate<enum TraitTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T229634 = -12						; size = 12
$T229638 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z PROC ; std::_Allocate<enum TraitTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229638[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229634[esp+16]
	mov	DWORD PTR $T229638[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229634[esp+16]
	push	ecx
	mov	DWORD PTR $T229634[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum TraitTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??0?$allocator@_N@std@@QAE@XZ			; std::allocator<bool>::allocator<bool>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_N@std@@QAE@XZ PROC			; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@_N@std@@QAE@XZ ENDP			; std::allocator<bool>::allocator<bool>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >::~_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >::~_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >::~_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@XZ ; std::allocator<Firaxis::Array<int,6> >::allocator<Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@XZ PROC	; std::allocator<Firaxis::Array<int,6> >::allocator<Firaxis::Array<int,6> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@XZ ENDP	; std::allocator<Firaxis::Array<int,6> >::allocator<Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@XZ PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T229670 = -80						; size = 28
$T229669 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229670[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229669[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229670[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229669[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229669[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229669[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229669[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@6:
$LN12@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T229670[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T229669[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >::_Container_base_aux_alloc_empty<std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@ABV01@@Z ; std::allocator<Firaxis::Array<int,6> >::allocator<Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Firaxis::Array<int,6> >::allocator<Firaxis::Array<int,6> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@V?$Array@H$05@Firaxis@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Firaxis::Array<int,6> >::allocator<Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@I@Z ; std::allocator<Firaxis::Array<int,6> >::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@I@Z PROC ; std::allocator<Firaxis::Array<int,6> >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@I@Z ENDP ; std::allocator<Firaxis::Array<int,6> >::deallocate
_TEXT	ENDS
PUBLIC	?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ; std::vector<bool,std::allocator<bool> >::_Nw
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z PROC	; std::vector<bool,std::allocator<bool> >::_Nw, COMDAT

; 2331 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	eax, DWORD PTR __Count$[esp-4]
	add	eax, 31					; 0000001fH
	shr	eax, 5

; 2332 : 		}

	ret	0
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ENDP	; std::vector<bool,std::allocator<bool> >::_Nw
_TEXT	ENDS
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
; File s:\msvs2008\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2
__ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T229707 = -80						; size = 28
$T229706 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 2374 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 2375 : 		_THROW(length_error, "vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229707[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229706[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229707[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229706[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229706[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229706[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229706[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@7:
$LN12@Xlen@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0:
	lea	ecx, DWORD PTR $T229707[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2:
	lea	ecx, DWORD PTR $T229706[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T229738 = -80						; size = 28
$T229737 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229738[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T229737[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T229738[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T229737[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T229737[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229737[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T229737[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@8:
$LN12@Xlen@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T229738[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T229737[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@I@std@@QAEXPAII@Z	; std::allocator<unsigned int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$Array@H$05@Firaxis@@@std@@QBEIXZ ; std::allocator<Firaxis::Array<int,6> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@V?$Array@H$05@Firaxis@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$Array@H$05@Firaxis@@@std@@QBEIXZ PROC ; std::allocator<Firaxis::Array<int,6> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$Array@H$05@Firaxis@@@std@@QBEIXZ ENDP ; std::allocator<Firaxis::Array<int,6> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	mov	eax, ecx

; 1603 : 		if (_Off == 0)

	mov	ecx, DWORD PTR __Off$[esp-4]
	test	ecx, ecx

; 1604 : 			return (*this); // early out

	je	SHORT $LN6@operator@2
	push	esi

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jge	SHORT $LN2@operator@2
	mov	edx, DWORD PTR [eax+4]
	mov	esi, ecx
	neg	esi
	cmp	edx, esi
	jae	SHORT $LN2@operator@2

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	add	ecx, edx

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	or	edx, -1
	sub	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	esi, -4					; fffffffcH
	sub	esi, edx
	add	DWORD PTR [eax], esi

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
$LN2@operator@2:

; 1618 : 			this->_Myoff %= _VBITS;
; 1619 : 			}
; 1620 : 		else
; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR [eax+4]
	add	ecx, edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi
$LN6@operator@2:

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1649 : 
; 1650 :  #if _HAS_ITERATOR_DEBUGGING
; 1651 : 		_Compat(_Right);
; 1652 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1653 : 
; 1654 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)
; 1655 : 			+ (difference_type)this->_Myoff
; 1656 : 			- (difference_type)_Right._Myoff);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1657 : 		}

	ret	4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z PROC ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z ENDP ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z PROC ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1403 : 		{	// construct with offset and pointer

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1404 : 		}

	ret	8
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ENDP ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4TraitTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4TraitTypes@@0@Z ; std::_Ptr_cat<enum TraitTypes *,enum TraitTypes *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAW4TraitTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4TraitTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4TraitTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4TraitTypes@@0@Z PROC ; std::_Ptr_cat<enum TraitTypes *,enum TraitTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4TraitTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4TraitTypes@@0@Z ENDP ; std::_Ptr_cat<enum TraitTypes *,enum TraitTypes *>
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ; std::_Allocate<Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z
_TEXT	SEGMENT
$T229833 = -12						; size = 12
$T229837 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z PROC ; std::_Allocate<Firaxis::Array<int,6> >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN1@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229837[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229833[esp+16]
	mov	DWORD PTR $T229837[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229833[esp+16]
	push	ecx
	mov	DWORD PTR $T229833[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@7:
$LN8@Allocate@7:
	int	3
??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ENDP ; std::_Allocate<Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T229843 = -12						; size = 12
$T229847 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T229847[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T229843[esp+16]
	mov	DWORD PTR $T229847[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T229843[esp+16]
	push	ecx
	mov	DWORD PTR $T229843[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@8:
$LN8@Allocate@8:
	int	3
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2048 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx]

; 2049 : 		}

	ret	0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::end
_TEXT	ENDS
PUBLIC	?size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::size
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@XZ ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@XZ PROC ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEABV?$Array@H$05@Firaxis@@XZ ENDP ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 24			; 00000018H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >::SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z
_TEXT	SEGMENT
$T229899 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >::SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T229899[esp]
	push	edx
	mov	DWORD PTR $T229899[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >::SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >
_TEXT	ENDS
PUBLIC	??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==, COMDAT
; _this$ = ecx

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@3
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@3
	mov	eax, 1

; 1673 : 		}

	ret	4
$LN3@operator@3:

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	xor	eax, eax

; 1673 : 		}

	ret	4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
_TEXT	ENDS
PUBLIC	?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc, COMDAT
; _this$ = ecx

; 1734 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1735 : 		_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1736 : 		if (this->_Myoff < _VBITS - 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 31					; 0000001fH
	jae	SHORT $LN2@Inc

; 1737 : 			++this->_Myoff;

	inc	eax
	mov	DWORD PTR [ecx+4], eax

; 1740 : 		}

	ret	0
$LN2@Inc:

; 1738 : 		else
; 1739 : 			this->_Myoff = 0, ++this->_Myptr;

	add	DWORD PTR [ecx], 4
	mov	DWORD PTR [ecx+4], 0

; 1740 : 		}

	ret	0
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1465 : 		{	// construct with base

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1466 : 		}

	ret	4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ
_TEXT	SEGMENT
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr, COMDAT
; _this$ = ecx

; 1500 : 
; 1501 :  #if _HAS_ITERATOR_DEBUGGING
; 1502 : 		if (this->_Mycont == 0 || this->_Myptr == 0)
; 1503 : 			{
; 1504 : 			_DEBUG_ERROR("vector<bool> iterator not dereferencable");
; 1505 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1506 : 			}
; 1507 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1508 :  		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1509 : 		_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() < ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1510 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1511 : 
; 1512 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [ecx]

; 1513 : 		}

	ret	0
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
_TEXT	ENDS
PUBLIC	?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
; Function compile flags: /Ogtpy
;	COMDAT ?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask, COMDAT
; _this$ = ecx

; 1518 : 		return ((_Vbase)(1 << this->_Myoff));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl

; 1519 : 		}

	ret	0
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@5

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@5:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$Array@H$05@Firaxis@@0@Z ; std::_Iter_random<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$Array@H$05@Firaxis@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$Array@H$05@Firaxis@@0@Z PROC ; std::_Iter_random<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$Array@H$05@Firaxis@@0@Z ENDP ; std::_Iter_random<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$Array@H$05@Firaxis@@0@Z ; std::_Ptr_cat<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$Array@H$05@Firaxis@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$Array@H$05@Firaxis@@0@Z PROC ; std::_Ptr_cat<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAV?$Array@H$05@Firaxis@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$Array@H$05@Firaxis@@0@Z ENDP ; std::_Ptr_cat<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z PROC ; std::_Iter_random<unsigned int *,unsigned int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ENDP ; std::_Iter_random<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z PROC ; std::_Ptr_cat<unsigned int *,unsigned int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ENDP ; std::_Ptr_cat<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@6

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@6:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Destroy@W4TraitTypes@@@std@@YAXPAW4TraitTypes@@@Z ; std::_Destroy<enum TraitTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4TraitTypes@@@std@@YAXPAW4TraitTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4TraitTypes@@@std@@YAXPAW4TraitTypes@@@Z PROC ; std::_Destroy<enum TraitTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4TraitTypes@@@std@@YAXPAW4TraitTypes@@@Z ENDP ; std::_Destroy<enum TraitTypes>
_TEXT	ENDS
PUBLIC	??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1791 : 		return (_Reft(*this));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1792 : 		}

	ret	4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	??4?$Array@H$05@Firaxis@@QAEABV01@ABV01@@Z	; Firaxis::Array<int,6>::operator=
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\farray.h
;	COMDAT ??4?$Array@H$05@Firaxis@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_akItems$ = 8						; size = 4
??4?$Array@H$05@Firaxis@@QAEABV01@ABV01@@Z PROC		; Firaxis::Array<int,6>::operator=, COMDAT
; _this$ = ecx

; 184  : 	    {

	mov	eax, ecx

; 185  : 		    for ( uint i = 0; i < ARRAY_SIZE; i++ )
; 186  : 		    {
; 187  : 			    m_akItems[ i ] = akItems.m_akItems[ i ];

	mov	ecx, DWORD PTR _akItems$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx

; 188  : 		    }
; 189  : 
; 190  : 		    return ( *this );
; 191  : 	    }

	ret	4
??4?$Array@H$05@Firaxis@@QAEABV01@ABV01@@Z ENDP		; Firaxis::Array<int,6>::operator=
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	?capacity@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@5

; 636  : 		}

	ret	0
$LN3@capacity@5:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::capacity
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator==
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1475 : 		{	// assign _Val to bit

	mov	eax, ecx

; 1476 : 		if (_Val)
; 1477 : 			*_Getptr() |= _Mask();

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR __Val$[esp], 0
	je	SHORT $LN2@operator@4
	or	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
$LN2@operator@4:

; 1478 : 		else
; 1479 : 			*_Getptr() &= ~_Mask();

	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+=
_TEXT	ENDS
PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@6
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@6:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$Array@H$05@Firaxis@@@std@@YAXPAV?$Array@H$05@Firaxis@@@Z ; std::_Destroy<Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy@V?$Array@H$05@Firaxis@@@std@@YAXPAV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$Array@H$05@Firaxis@@@std@@YAXPAV?$Array@H$05@Firaxis@@@Z PROC ; std::_Destroy<Firaxis::Array<int,6> >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@V?$Array@H$05@Firaxis@@@std@@YAXPAV?$Array@H$05@Firaxis@@@Z ENDP ; std::_Destroy<Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	??$_Construct@W4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@ABW41@@Z ; std::_Construct<enum TraitTypes,enum TraitTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@W4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@ABW41@@Z PROC ; std::_Construct<enum TraitTypes,enum TraitTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@W4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@ABW41@@Z ENDP ; std::_Construct<enum TraitTypes,enum TraitTypes>
_TEXT	ENDS
PUBLIC	??A?$Array@H$05@Firaxis@@QBEABHI@Z		; Firaxis::Array<int,6>::operator[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\farray.h
;	COMDAT ??A?$Array@H$05@Firaxis@@QBEABHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$05@Firaxis@@QBEABHI@Z PROC			; Firaxis::Array<int,6>::operator[], COMDAT
; _this$ = ecx

; 144  : #		ifdef _MSC_VER
; 145  : #			pragma warning ( push )
; 146  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 147  : 			// sad day. 
; 148  : #		endif//_MSC_VER
; 149  : 		    assert( i < ARRAY_SIZE );
; 150  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 151  : #		ifdef _MSC_VER
; 152  : #		pragma warning ( pop )
; 153  : #		endif//_MSC_VER
; 154  : 	    }

	ret	4
??A?$Array@H$05@Firaxis@@QBEABHI@Z ENDP			; Firaxis::Array<int,6>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@H$05@Firaxis@@QAEAAHI@Z		; Firaxis::Array<int,6>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@H$05@Firaxis@@QAEAAHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$05@Firaxis@@QAEAAHI@Z PROC			; Firaxis::Array<int,6>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@H$05@Firaxis@@QAEAAHI@Z ENDP			; Firaxis::Array<int,6>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$Array@H$05@Firaxis@@QBEIXZ		; Firaxis::Array<int,6>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$Array@H$05@Firaxis@@QBEIXZ
_TEXT	SEGMENT
?size@?$Array@H$05@Firaxis@@QBEIXZ PROC			; Firaxis::Array<int,6>::size, COMDAT
; _this$ = ecx

; 195  : 			return ARRAY_SIZE;

	mov	eax, 6

; 196  : 		}

	ret	0
?size@?$Array@H$05@Firaxis@@QBEIXZ ENDP			; Firaxis::Array<int,6>::size
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@4
	pop	esi
$LN1@Fill@4:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z ; std::_Fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z PROC ; std::_Fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	add	eax, 24					; 00000018H
	cmp	eax, edx
	jne	SHORT $LL3@Fill@5
	pop	esi
$LN1@Fill@5:

; 3160 : 	}

	ret	0
??$_Fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z ENDP ; std::_Fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAV?$Array@H$05@Firaxis@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$Array@H$05@Firaxis@@@Z ; std::_Move_cat<Firaxis::Array<int,6> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAV?$Array@H$05@Firaxis@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAV?$Array@H$05@Firaxis@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$Array@H$05@Firaxis@@@Z PROC ; std::_Move_cat<Firaxis::Array<int,6> *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAV?$Array@H$05@Firaxis@@@std@@YA?AU_Undefined_move_tag@0@ABQAV?$Array@H$05@Firaxis@@@Z ENDP ; std::_Move_cat<Firaxis::Array<int,6> *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAII@std@@YAXPAI0ABI@Z			; std::_Fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::_Fill<unsigned int *,unsigned int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@6
	pop	esi
$LN1@Fill@6:

; 3160 : 	}

	ret	0
??$_Fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::_Fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z PROC ; std::_Move_cat<unsigned int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ENDP ; std::_Move_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec, COMDAT
; _this$ = ecx

; 1719 : 		if (this->_Myoff != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@Dec@2

; 1720 : 			{
; 1721 : 			--this->_Myoff;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 1729 : 			}
; 1730 : 		}

	ret	0
$LN2@Dec@2:

; 1722 : 			}
; 1723 : 		else
; 1724 : 			{
; 1725 : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1726 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Myptr > this->_My_cont_begin());
; 1727 : 			--this->_Myptr;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 1728 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR [ecx+4], 31			; 0000001fH

; 1729 : 			}
; 1730 : 		}

	ret	0
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@4

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@4:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@5
	push	esi
$LL2@Copy_backw@5:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-24]
	sub	ecx, 24					; 00000018H
	sub	eax, 24					; 00000018H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@5
	pop	esi
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@6

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@6:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@V?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@ABV12@@Z ; std::_Construct<Firaxis::Array<int,6>,Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Construct@V?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@ABV12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@ABV12@@Z PROC ; std::_Construct<Firaxis::Array<int,6>,Firaxis::Array<int,6> >, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@V?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@ABV12@@Z ENDP ; std::_Construct<Firaxis::Array<int,6>,Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z PROC ; std::_Iter_cat<unsigned int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ENDP ; std::_Iter_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop@2:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@2
	pop	esi
$LN1@Fill_n@2:

; 3199 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T230164 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T230164[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T230164[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T230164[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T230164[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?getShortDescription@CvTraitEntry@@QBEPBDXZ	; CvTraitEntry::getShortDescription
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?getShortDescription@CvTraitEntry@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDescription@CvTraitEntry@@QBEPBDXZ PROC	; CvTraitEntry::getShortDescription, COMDAT
; _this$ = ecx

; 822  : 	return m_strShortDescription;

	add	ecx, 600				; 00000258H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDescription@CvTraitEntry@@QBEPBDXZ ENDP	; CvTraitEntry::getShortDescription
_TEXT	ENDS
PUBLIC	?setShortDescription@CvTraitEntry@@QAEXPBD@Z	; CvTraitEntry::setShortDescription
; Function compile flags: /Ogtpy
;	COMDAT ?setShortDescription@CvTraitEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setShortDescription@CvTraitEntry@@QAEXPBD@Z PROC	; CvTraitEntry::setShortDescription, COMDAT
; _this$ = ecx

; 828  : 	m_strShortDescription = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 600				; 00000258H
	test	eax, eax
	je	SHORT $LN4@setShortDe
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setShortDe:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 829  : }

	ret	4
?setShortDescription@CvTraitEntry@@QAEXPBD@Z ENDP	; CvTraitEntry::setShortDescription
_TEXT	ENDS
PUBLIC	?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ; CvTraitEntry::GetFreeResourceXCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_eResource$ = 12					; size = 4
?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z PROC ; CvTraitEntry::GetFreeResourceXCities, COMDAT
; _this$ = ecx

; 958  : 	return m_aFreeResourceXCities[(int)eResource];

	mov	ecx, DWORD PTR [ecx+704]
	mov	edx, DWORD PTR _eResource$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 959  : }

	ret	8
?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ENDP ; CvTraitEntry::GetFreeResourceXCities
_TEXT	ENDS
PUBLIC	?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ; CvTraitEntry::IsObsoleteByTech
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
; Function compile flags: /Ogtpy
;	COMDAT ?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z PROC ; CvTraitEntry::IsObsoleteByTech, COMDAT
; _this$ = ecx

; 998  : 	if(m_iObsoleteTech != NO_TECH)

	mov	eax, DWORD PTR [ecx+416]
	cmp	eax, -1
	je	SHORT $LN1@IsObsolete

; 999  : 	{
; 1000 : 		if(GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)m_iObsoleteTech))

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN1@IsObsolete

; 1001 : 		{
; 1002 : 			return true;

	mov	al, 1

; 1006 : }

	ret	4
$LN1@IsObsolete:

; 1003 : 		}
; 1004 : 	}
; 1005 : 	return false;

	xor	al, al

; 1006 : }

	ret	4
?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ENDP ; CvTraitEntry::IsObsoleteByTech
_TEXT	ENDS
PUBLIC	?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ; CvTraitEntry::IsEnabledByTech
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z PROC ; CvTraitEntry::IsEnabledByTech, COMDAT
; _this$ = ecx

; 1011 : 	if(m_iPrereqTech != NO_TECH)

	mov	eax, DWORD PTR [ecx+420]
	cmp	eax, -1
	je	SHORT $LN1@IsEnabledB

; 1012 : 	{
; 1013 : 		if(GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)m_iPrereqTech))

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	setne	al

; 1023 : }

	ret	4
$LN1@IsEnabledB:

; 1014 : 		{
; 1015 : 			return true;
; 1016 : 		}
; 1017 : 		else
; 1018 : 		{
; 1019 : 			return false;
; 1020 : 		}
; 1021 : 	}
; 1022 : 	return true;

	mov	al, 1

; 1023 : }

	ret	4
?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ENDP ; CvTraitEntry::IsEnabledByTech
_TEXT	ENDS
PUBLIC	?GetNumTraits@CvTraitXMLEntries@@QAEHXZ		; CvTraitXMLEntries::GetNumTraits
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTraits@CvTraitXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumTraits@CvTraitXMLEntries@@QAEHXZ PROC		; CvTraitXMLEntries::GetNumTraits, COMDAT
; _this$ = ecx

; 1517 : 	return m_paTraitEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1518 : }

	ret	0
?GetNumTraits@CvTraitXMLEntries@@QAEHXZ ENDP		; CvTraitXMLEntries::GetNumTraits
_TEXT	ENDS
PUBLIC	?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z ; CvTraitXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z PROC ; CvTraitXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 1534 : 	return m_paTraitEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1535 : }

	ret	4
?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z ENDP ; CvTraitXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z ; CvPlayerTraits::GetMovesChangeUnitCombat
; Function compile flags: /Ogtpy
;	COMDAT ?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z
_TEXT	SEGMENT
_unitCombatID$ = 8					; size = 4
?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z PROC	; CvPlayerTraits::GetMovesChangeUnitCombat, COMDAT
; _this$ = ecx

; 2235 : 	CvAssertMsg(unitCombatID < GC.getNumUnitCombatClassInfos(),  "Invalid unitCombatID parameter in call to CvPlayerTraits::GetMovesChangeUnitCombat()");
; 2236 : 
; 2237 : 	if(unitCombatID == NO_UNITCLASS)

	mov	eax, DWORD PTR _unitCombatID$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@GetMovesCh

; 2238 : 	{
; 2239 : 		return 0;

	xor	eax, eax

; 2243 : }

	ret	4
$LN1@GetMovesCh:

; 2240 : 	}
; 2241 : 
; 2242 : 	return m_paiMovesChangeUnitCombat[unitCombatID];

	mov	ecx, DWORD PTR [ecx+756]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2243 : }

	ret	4
?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z ENDP	; CvPlayerTraits::GetMovesChangeUnitCombat
_TEXT	ENDS
PUBLIC	?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z
_TEXT	SEGMENT
_unitCombatID$ = 8					; size = 4
?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z PROC ; CvPlayerTraits::GetMaintenanceModifierUnitCombat, COMDAT
; _this$ = ecx

; 2248 : 	CvAssertMsg(unitCombatID < GC.getNumUnitCombatClassInfos(),  "Invalid unitCombatID parameter in call to CvPlayerTraits::GetMaintenanceModifierUnitCombat()");
; 2249 : 
; 2250 : 	if(unitCombatID == NO_UNITCLASS)

	mov	eax, DWORD PTR _unitCombatID$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@GetMainten

; 2251 : 	{
; 2252 : 		return 0;

	xor	eax, eax

; 2256 : }

	ret	4
$LN1@GetMainten:

; 2253 : 	}
; 2254 : 
; 2255 : 	return m_paiMaintenanceModifierUnitCombat[unitCombatID];

	mov	ecx, DWORD PTR [ecx+772]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2256 : }

	ret	4
?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z ENDP ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetImprovementYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eImprovement$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvPlayerTraits::GetImprovementYieldChange, COMDAT
; _this$ = ecx

; 2261 : 	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(),  "Invalid eImprovement parameter in call to CvPlayerTraits::GetImprovementYieldChange()");
; 2262 : 	CvAssertMsg(eYield < NUM_YIELD_TYPES,  "Invalid eYield parameter in call to CvPlayerTraits::GetImprovementYieldChange()");
; 2263 : 
; 2264 : 	if(eImprovement == NO_IMPROVEMENT)

	mov	eax, DWORD PTR _eImprovement$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@GetImprove@2

; 2265 : 	{
; 2266 : 		return 0;

	xor	eax, eax

; 2270 : }

	ret	8
$LN1@GetImprove@2:

; 2267 : 	}
; 2268 : 
; 2269 : 	return m_ppaaiImprovementYieldChange[(int)eImprovement][(int)eYield];

	mov	edx, DWORD PTR _eYield$[esp-4]
	mov	ecx, DWORD PTR [ecx+788]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2270 : }

	ret	8
?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetImprovementYieldChange
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetSpecialistYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eSpecialist$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z PROC ; CvPlayerTraits::GetSpecialistYieldChange, COMDAT
; _this$ = ecx

; 2275 : 	CvAssertMsg(eSpecialist < GC.getNumSpecialistInfos(),  "Invalid eSpecialist parameter in call to CvPlayerTraits::GetSpecialistYieldChange()");
; 2276 : 	CvAssertMsg(eYield < NUM_YIELD_TYPES,  "Invalid eYield parameter in call to CvPlayerTraits::GetSpecialistYieldChange()");
; 2277 : 
; 2278 : 	if(eSpecialist == NO_SPECIALIST)

	mov	eax, DWORD PTR _eSpecialist$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@GetSpecial@2

; 2279 : 	{
; 2280 : 		return 0;

	xor	eax, eax

; 2284 : }

	ret	8
$LN1@GetSpecial@2:

; 2281 : 	}
; 2282 : 
; 2283 : 	return m_ppaaiSpecialistYieldChange[(int)eSpecialist][(int)eYield];

	mov	edx, DWORD PTR _eYield$[esp-4]
	mov	ecx, DWORD PTR [ecx+804]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2284 : }

	ret	8
?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetSpecialistYieldChange
_TEXT	ENDS
PUBLIC	?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eFeature$ = 8						; size = 4
_eYield$ = 12						; size = 4
?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z PROC ; CvPlayerTraits::GetUnimprovedFeatureYieldChange, COMDAT
; _this$ = ecx

; 2289 : 	CvAssertMsg(eFeature < GC.getNumFeatureInfos(),  "Invalid eImprovement parameter in call to CvPlayerTraits::GetUnimprovedFeatureYieldChange()");
; 2290 : 	CvAssertMsg(eYield < NUM_YIELD_TYPES,  "Invalid eYield parameter in call to CvPlayerTraits::GetUnimprovedFeatureYieldChange()");
; 2291 : 
; 2292 : 	if(eFeature == NO_FEATURE)

	mov	eax, DWORD PTR _eFeature$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@GetUnimpro@2

; 2293 : 	{
; 2294 : 		return 0;

	xor	eax, eax

; 2298 : }

	ret	8
$LN1@GetUnimpro@2:

; 2295 : 	}
; 2296 : 
; 2297 : 	return m_ppaaiUnimprovedFeatureYieldChange[(int)eFeature][(int)eYield];

	mov	edx, DWORD PTR _eYield$[esp-4]
	mov	ecx, DWORD PTR [ecx+820]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2298 : }

	ret	8
?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
_TEXT	ENDS
PUBLIC	?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z ; CvPlayerTraits::GetFirstFreeUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z PROC ; CvPlayerTraits::GetFirstFreeUnit, COMDAT
; _this$ = ecx

; 2553 : 	m_uiFreeUnitIndex = 0;
; 2554 : 	m_eFreeUnitPrereqTech = eTech;
; 2555 : 
; 2556 : 	while(m_uiFreeUnitIndex < m_aFreeTraitUnits.size())

	cmp	DWORD PTR [ecx+644], 0
	push	esi
	mov	esi, DWORD PTR _eTech$[esp]
	mov	DWORD PTR [ecx+352], 0
	mov	DWORD PTR [ecx+356], esi
	jbe	SHORT $LN2@GetFirstFr
	mov	edx, DWORD PTR [ecx+640]
$LL3@GetFirstFr:

; 2557 : 	{
; 2558 : 		if(eTech == m_aFreeTraitUnits[m_uiFreeUnitIndex].m_ePrereqTech)

	mov	eax, DWORD PTR [ecx+352]
	cmp	esi, DWORD PTR [edx+eax*8+4]
	je	SHORT $LN13@GetFirstFr

; 2561 : 		}
; 2562 : 
; 2563 : 		m_uiFreeUnitIndex++;

	inc	eax
	mov	DWORD PTR [ecx+352], eax
	cmp	eax, DWORD PTR [ecx+644]
	jb	SHORT $LL3@GetFirstFr
$LN2@GetFirstFr:

; 2564 : 	}
; 2565 : 
; 2566 : 	return NO_UNITCLASS;

	or	eax, -1
	pop	esi

; 2567 : }

	ret	4
$LN13@GetFirstFr:

; 2559 : 		{
; 2560 : 			return m_aFreeTraitUnits[m_uiFreeUnitIndex].m_iFreeUnit;

	mov	ecx, eax
	mov	eax, DWORD PTR [edx+ecx*8]
	pop	esi

; 2567 : }

	ret	4
?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z ENDP ; CvPlayerTraits::GetFirstFreeUnit
_TEXT	ENDS
PUBLIC	?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ		; CvPlayerTraits::GetNextFreeUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ
_TEXT	SEGMENT
?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ PROC		; CvPlayerTraits::GetNextFreeUnit, COMDAT
; _this$ = ecx

; 2572 : 	m_uiFreeUnitIndex++;

	inc	DWORD PTR [ecx+352]
	mov	eax, DWORD PTR [ecx+352]
	push	esi
	push	edi

; 2573 : 
; 2574 : 	while(m_uiFreeUnitIndex < m_aFreeTraitUnits.size())

	cmp	eax, DWORD PTR [ecx+644]
	jae	SHORT $LN2@GetNextFre
	mov	edx, DWORD PTR [ecx+640]
	mov	esi, DWORD PTR [ecx+356]
$LL3@GetNextFre:

; 2575 : 	{
; 2576 : 		if(m_eFreeUnitPrereqTech == m_aFreeTraitUnits[m_uiFreeUnitIndex].m_ePrereqTech)

	cmp	esi, DWORD PTR [edx+eax*8+4]
	je	SHORT $LN13@GetNextFre

; 2579 : 		}
; 2580 : 
; 2581 : 		m_uiFreeUnitIndex++;

	inc	eax
	mov	edi, eax
	mov	DWORD PTR [ecx+352], eax
	cmp	edi, DWORD PTR [ecx+644]
	jb	SHORT $LL3@GetNextFre
$LN2@GetNextFre:
	pop	edi

; 2582 : 	}
; 2583 : 
; 2584 : 	return NO_UNITCLASS;

	or	eax, -1
	pop	esi

; 2585 : }

	ret	0
$LN13@GetNextFre:

; 2577 : 		{
; 2578 : 			return m_aFreeTraitUnits[m_uiFreeUnitIndex].m_iFreeUnit;

	mov	eax, DWORD PTR [edx+eax*8]
	pop	edi
	pop	esi

; 2585 : }

	ret	0
?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ ENDP		; CvPlayerTraits::GetNextFreeUnit
_TEXT	ENDS
PUBLIC	?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ; CvPlayerTraits::GetFreeResourceXCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_eResource$ = 12					; size = 4
?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z PROC ; CvPlayerTraits::GetFreeResourceXCities, COMDAT
; _this$ = ecx

; 2590 : 	return m_aFreeResourceXCities[(int)eResource];

	mov	ecx, DWORD PTR [ecx+836]
	mov	edx, DWORD PTR _eResource$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 2591 : }

	ret	8
?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ENDP ; CvPlayerTraits::GetFreeResourceXCities
_TEXT	ENDS
PUBLIC	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::ComputeMayaDate
EXTRN	?getGameTurnYear@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurnYear
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?ComputeMayaDate@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
tv331 = -4						; size = 4
tv272 = -4						; size = 4
tv260 = -4						; size = 4
tv248 = -4						; size = 4
tv236 = -4						; size = 4
_fDays$223551 = -4					; size = 4
_fYear$ = -4						; size = 4
?ComputeMayaDate@CvPlayerTraits@@QAEXXZ PROC		; CvPlayerTraits::ComputeMayaDate, COMDAT
; _this$ = ecx

; 2869 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 2870 : 	float fCalendarStart = CALENDAR_START;
; 2871 : 	int iYear = GC.getGame().getGameTurnYear();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurnYear@CvGame@@QAEHXZ		; CvGame::getGameTurnYear

; 2872 : 	float fYear = (float)iYear;

	mov	DWORD PTR tv331[esp+8], eax
	fild	DWORD PTR tv331[esp+8]
	fstp	DWORD PTR _fYear$[esp+8]

; 2873 : 
; 2874 : 	if(fYear >= fCalendarStart)

	fld	DWORD PTR _fYear$[esp+8]
	fld	DWORD PTR _CALENDAR_START
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN7@ComputeMay

; 2875 : 	{
; 2876 : 		// Days since calendar start
; 2877 : 		float fDays = (fYear - fCalendarStart) * DAYS_IN_YEAR;

	fsubp	ST(1), ST(0)
	fmul	DWORD PTR _DAYS_IN_YEAR
	fstp	DWORD PTR _fDays$223551[esp+8]

; 2878 : 		m_iBaktun = (int)(fDays / DAYS_IN_BAKTUN);

	fld	DWORD PTR _fDays$223551[esp+8]
	fld	ST(0)
	fld	DWORD PTR _DAYS_IN_BAKTUN
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	call	__ftol2_sse_excpt
	mov	DWORD PTR tv236[esp+8], eax

; 2879 : 		fDays = fDays - ((float)m_iBaktun * DAYS_IN_BAKTUN);

	fimul	DWORD PTR tv236[esp+8]
	mov	DWORD PTR [esi+716], eax
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _fDays$223551[esp+8]

; 2880 : 		m_iKatun = (int)(fDays / DAYS_IN_KATUN);

	fld	DWORD PTR _fDays$223551[esp+8]
	fld	ST(0)
	fld	DWORD PTR _DAYS_IN_KATUN
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	call	__ftol2_sse_excpt
	mov	DWORD PTR tv248[esp+8], eax

; 2881 : 		fDays = fDays - ((float)m_iKatun * DAYS_IN_KATUN);

	fimul	DWORD PTR tv248[esp+8]
	mov	DWORD PTR [esi+720], eax
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _fDays$223551[esp+8]

; 2882 : 		m_iTun = (int)(fDays / DAYS_IN_TUN);

	fld	DWORD PTR _fDays$223551[esp+8]
	fld	ST(0)
	fld	DWORD PTR _DAYS_IN_TUN
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	call	__ftol2_sse_excpt
	mov	DWORD PTR tv260[esp+8], eax

; 2883 : 		fDays = fDays - ((float)m_iTun * DAYS_IN_TUN);

	fimul	DWORD PTR tv260[esp+8]
	mov	DWORD PTR [esi+724], eax
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _fDays$223551[esp+8]

; 2884 : 		m_iWinal = (int)(fDays / DAYS_IN_WINAL);

	fld	DWORD PTR _fDays$223551[esp+8]
	fld	ST(0)
	fld	DWORD PTR _DAYS_IN_WINAL
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	call	__ftol2_sse_excpt
	mov	DWORD PTR tv272[esp+8], eax

; 2885 : 		fDays = fDays - ((float)m_iWinal * DAYS_IN_WINAL);

	fimul	DWORD PTR tv272[esp+8]
	mov	DWORD PTR [esi+728], eax
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _fDays$223551[esp+8]

; 2886 : 		m_iKin = (int)fDays;

	fld	DWORD PTR _fDays$223551[esp+8]
	call	__ftol2_sse_excpt
	mov	DWORD PTR [esi+732], eax
	pop	esi

; 2887 : 	}
; 2888 : }

	pop	ecx
	ret	0
$LN7@ComputeMay:

; 2873 : 
; 2874 : 	if(fYear >= fCalendarStart)

	fstp	ST(1)
	pop	esi
	fstp	ST(0)

; 2887 : 	}
; 2888 : }

	pop	ecx
	ret	0
?ComputeMayaDate@CvPlayerTraits@@QAEXXZ ENDP		; CvPlayerTraits::ComputeMayaDate
_TEXT	ENDS
PUBLIC	?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsFreeMayaGreatPersonChoice
EXTRN	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetSpecialUnitType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
; Function compile flags: /Ogtpy
;	COMDAT ?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ PROC ; CvPlayerTraits::IsFreeMayaGreatPersonChoice, COMDAT
; _this$ = ecx

; 2922 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 2923 : 	// True if have already selected each GP type once
; 2924 : 	int iNumGreatPeopleTypes = 0;

	xor	ebx, ebx

; 2925 : 	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	ebx
	mov	edi, ecx
	push	OFFSET $SG223692
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2926 : 
; 2927 : 	// Loop through adding the available units
; 2928 : #ifdef AUI_WARNING_FIXES
; 2929 : 	for (uint iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
; 2930 : #else
; 2931 : 	for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	xor	esi, esi
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	test	eax, eax
	jle	SHORT $LN5@IsFreeMaya
	npad	6
$LL7@IsFreeMaya:

; 2932 : #endif
; 2933 : 	{
; 2934 : 		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
; 2935 : 		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo

; 2936 : 		if(pkUnitClassInfo)

	test	eax, eax
	je	SHORT $LN6@IsFreeMaya

; 2937 : 		{
; 2938 : 			const UnitTypes eUnit = (UnitTypes)m_pPlayer->getCivilizationInfo().getCivilizationUnits(eUnitClass);

	mov	ecx, DWORD PTR [edi+4]
	push	esi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits

; 2939 : 			if (eUnit != NO_UNIT)

	cmp	eax, -1
	je	SHORT $LN6@IsFreeMaya

; 2940 : 			{
; 2941 : 				CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 2942 : 				if (pUnitEntry)

	test	eax, eax
	je	SHORT $LN6@IsFreeMaya

; 2943 : 				{
; 2944 : 					if (pUnitEntry->GetSpecialUnitType() == eSpecialUnitGreatPerson)

	mov	ecx, eax
	call	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetSpecialUnitType
	cmp	eax, ebp
	jne	SHORT $LN6@IsFreeMaya

; 2945 : 					{
; 2946 : 						iNumGreatPeopleTypes++;

	inc	ebx
$LN6@IsFreeMaya:

; 2926 : 
; 2927 : 	// Loop through adding the available units
; 2928 : #ifdef AUI_WARNING_FIXES
; 2929 : 	for (uint iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
; 2930 : #else
; 2931 : 	for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	esi, eax
	jl	SHORT $LL7@IsFreeMaya
$LN5@IsFreeMaya:

; 2947 : 					}
; 2948 : 				}
; 2949 : 			}	
; 2950 : 		}
; 2951 : 	}
; 2952 : 
; 2953 : 	return ((int)m_aMayaBonusChoices.size() >= iNumGreatPeopleTypes);

	mov	eax, DWORD PTR [edi+744]
	sub	eax, DWORD PTR [edi+740]
	pop	edi
	sar	eax, 3
	xor	ecx, ecx
	cmp	eax, ebx
	pop	esi
	setge	cl
	pop	ebp
	mov	al, cl
	pop	ebx

; 2954 : }

	ret	0
?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ ENDP ; CvPlayerTraits::IsFreeMayaGreatPersonChoice
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@5

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@5:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@5

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@5:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::FStaticVector<FreeTraitUnit,5,1,297,0>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::FStaticVector<FreeTraitUnit,5,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 5
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::FStaticVector<FreeTraitUnit,5,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UFreeTraitUnit@@$00@@QAEXXZ	; BaseVector<FreeTraitUnit,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UFreeTraitUnit@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UFreeTraitUnit@@$00@@QAEXXZ PROC	; BaseVector<FreeTraitUnit,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UFreeTraitUnit@@$00@@QAEXXZ ENDP	; BaseVector<FreeTraitUnit,1>::clear
_TEXT	ENDS
PUBLIC	?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::end
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEAAPAVCvTraitEntry@@XZ ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEAAPAVCvTraitEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEAAPAVCvTraitEntry@@XZ PROC ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEAAPAVCvTraitEntry@@XZ ENDP ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??C?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEPBUMayaBonusChoice@@XZ ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEPBUMayaBonusChoice@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEPBUMayaBonusChoice@@XZ PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator->, COMDAT
; _this$ = ecx

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEPBUMayaBonusChoice@@XZ ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator++, COMDAT
; _this$ = ecx

; 131  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 132  : 		++*this;

	add	edx, 8
	mov	DWORD PTR [ecx], edx

; 133  : 		return (_Tmp);
; 134  : 		}

	ret	8
??E?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::~_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Key
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Key
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::get_allocator, COMDAT
; _this$ = ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 617  : 		}

	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHH@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
; Function compile flags: /Ogtpy
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound, COMDAT
; _this$ = ecx

; 1350 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1351 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1352 : 
; 1353 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Ubound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Ubound:

; 1354 : 			if (_DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN2@Ubound

; 1355 : 				{	// _Pnode greater than _Keyval, remember it
; 1356 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1357 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]

; 1358 : 				}
; 1359 : 			else

	jmp	SHORT $LN1@Ubound
$LN2@Ubound:

; 1360 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]
$LN1@Ubound:

; 1351 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1352 : 
; 1353 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Ubound
$LN3@Ubound:

; 1361 : 
; 1362 : 		return (_Wherenode);	// return best remembered candidate
; 1363 : 		}

	ret	4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z PROC ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE@V?$allocator@UFreeResourceXCities@@@1@@Z ENDP ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z PROC ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTraitEntry@@@1@@Z ENDP ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXPAUFreeTraitUnit@@I@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXPAUFreeTraitUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXPAUFreeTraitUnit@@I@Z PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXPAUFreeTraitUnit@@I@Z ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z PROC ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE@V?$allocator@UMayaBonusChoice@@@1@@Z ENDP ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN3@Inc@2

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN34@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN17@Inc@2
	npad	7
$LL18@Inc@2:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL18@Inc@2
$LN17@Inc@2:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc@2:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN1@Inc@2
$LL2@Inc@2:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL2@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc@2:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z PROC ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@PAPAVCvTraitEntry@@@Z ENDP ; std::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Vector_iterator<CvTraitEntry *,std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::end
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jge	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?max_size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBEIXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UFreeResourceXCities@@@std@@QAEPAUFreeResourceXCities@@I@Z ; std::allocator<FreeResourceXCities>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UFreeResourceXCities@@@std@@QAEPAUFreeResourceXCities@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UFreeResourceXCities@@@std@@QAEPAUFreeResourceXCities@@I@Z PROC ; std::allocator<FreeResourceXCities>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ; std::_Allocate<FreeResourceXCities>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UFreeResourceXCities@@@std@@QAEPAUFreeResourceXCities@@I@Z ENDP ; std::allocator<FreeResourceXCities>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvTraitEntry@@@std@@QAEPAPAVCvTraitEntry@@I@Z ; std::allocator<CvTraitEntry *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvTraitEntry@@@std@@QAEPAPAVCvTraitEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvTraitEntry@@@std@@QAEPAPAVCvTraitEntry@@I@Z PROC ; std::allocator<CvTraitEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z ; std::_Allocate<CvTraitEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvTraitEntry@@@std@@QAEPAPAVCvTraitEntry@@I@Z ENDP ; std::allocator<CvTraitEntry *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?max_size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBEIXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UMayaBonusChoice@@@std@@QAEPAUMayaBonusChoice@@I@Z ; std::allocator<MayaBonusChoice>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UMayaBonusChoice@@@std@@QAEPAUMayaBonusChoice@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UMayaBonusChoice@@@std@@QAEPAUMayaBonusChoice@@I@Z PROC ; std::allocator<MayaBonusChoice>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ; std::_Allocate<MayaBonusChoice>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UMayaBonusChoice@@@std@@QAEPAUMayaBonusChoice@@I@Z ENDP ; std::allocator<MayaBonusChoice>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z PROC ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@PAUFreeResourceXCities@@@Z ENDP ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z PROC ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@PAW4TraitTypes@@@Z ENDP ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z ; GetLocalizedText<int,int,int,int,int>
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$0
__ehfuncinfo$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T230941 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
_arg5$ = 32						; size = 4
??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z PROC ; GetLocalizedText<int,int,int,int,int>, COMDAT

; 553  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 554  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T230941[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 555  : 	text << arg1 << arg2 << arg3 << arg4 << arg5;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	edx, DWORD PTR _arg4$[esp+108]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	ecx, DWORD PTR _arg5$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 556  : 
; 557  : 	size_t bytes = 0;
; 558  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 559  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 560  : 	str.assign(szComposedString, bytes);
; 561  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T230941[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 562  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$1:
	mov	eax, DWORD PTR $T230941[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T230941[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z ENDP ; GetLocalizedText<int,int,int,int,int>
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@6
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@6:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@6

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@6:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$225699 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$225702 = -8					; size = 4
_tValue$225707 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$225699[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225702[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$225702[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225699[esp+32], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225707[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 505  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@7
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@7:

; 507  : 	{
; 508  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@7

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 511  : }

	ret	0
$LN14@operator@7:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 511  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	edi
$LN2@WriteHashe:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
$T231026 = 12						; size = 4
_aArray$ = 12						; size = 4
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>, COMDAT

; 591  : {

	push	ebx

; 592  : 	kStream << aArray.size();

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	mov	esi, DWORD PTR _aArray$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T231026[esp+8]
	sar	eax, 2
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T231026[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 593  : 
; 594  : 	for(uint iI = 0; iI < aArray.size(); iI++)

	mov	edx, DWORD PTR [esi+8]
	sub	edx, DWORD PTR [esi+4]
	xor	edi, edi
	sar	edx, 2
	test	edx, edx
	jbe	SHORT $LN2@WriteHashe@2
$LL4@WriteHashe@2:

; 595  : 	{
; 596  : 		const TType eType = static_cast<TType>(iI);
; 597  : 		if(WriteHashed(kStream, eType))

	push	edi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@2
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+edi*4]

; 598  : 		{
; 599  : 			kStream << aArray[iI];

	push	ecx
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@2:
	mov	edx, DWORD PTR [esi+8]
	sub	edx, DWORD PTR [esi+4]
	inc	edi
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LL4@WriteHashe@2
$LN2@WriteHashe@2:
	pop	edi
	pop	esi
	pop	ebx

; 600  : 		}
; 601  : 	}
; 602  : }

	ret	0
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
_TEXT	ENDS
PUBLIC	??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::_Swap_adl<std::less<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC ; std::_Swap_adl<std::less<int> >, COMDAT

; 31   : 	swap(_Left, _Right);
; 32   : 	}

	ret	0
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP ; std::_Swap_adl<std::less<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z ; stdext::unchecked_copy<FreeResourceXCities *,FreeResourceXCities *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z PROC ; stdext::unchecked_copy<FreeResourceXCities *,FreeResourceXCities *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z ENDP ; stdext::unchecked_copy<FreeResourceXCities *,FreeResourceXCities *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTraitEntry * *,CvTraitEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvTraitEntry * *,CvTraitEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvTraitEntry * *,CvTraitEntry * *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z ; stdext::unchecked_copy<enum TraitTypes *,enum TraitTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z PROC ; stdext::unchecked_copy<enum TraitTypes *,enum TraitTypes *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z ENDP ; stdext::unchecked_copy<enum TraitTypes *,enum TraitTypes *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z ; stdext::unchecked_copy<MayaBonusChoice *,MayaBonusChoice *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z PROC ; stdext::unchecked_copy<MayaBonusChoice *,MayaBonusChoice *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z ENDP ; stdext::unchecked_copy<MayaBonusChoice *,MayaBonusChoice *>
_TEXT	ENDS
PUBLIC	??$fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z ; std::fill<FreeResourceXCities *,FreeResourceXCities>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z PROC ; std::fill<FreeResourceXCities *,FreeResourceXCities>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z ENDP ; std::fill<FreeResourceXCities *,FreeResourceXCities>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTraitEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTraitEntry@@@std@@@std@@YAXPAPAVCvTraitEntry@@0AAV?$allocator@PAVCvTraitEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	??$fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z ; std::fill<enum TraitTypes *,enum TraitTypes>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z PROC ; std::fill<enum TraitTypes *,enum TraitTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z ENDP ; std::fill<enum TraitTypes *,enum TraitTypes>
_TEXT	ENDS
PUBLIC	??$fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z ; std::fill<MayaBonusChoice *,MayaBonusChoice>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z PROC ; std::fill<MayaBonusChoice *,MayaBonusChoice>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z ENDP ; std::fill<MayaBonusChoice *,MayaBonusChoice>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUFreeResourceXCities@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<FreeResourceXCities *,FreeResourceXCities *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@2
	push	esi
$LL6@Move_backw@2:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@2
	pop	esi
$LN5@Move_backw@2:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4TraitTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum TraitTypes *,enum TraitTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@3
	push	esi
$LL6@Move_backw@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@3
	pop	esi
$LN5@Move_backw@3:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUMayaBonusChoice@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<MayaBonusChoice *,MayaBonusChoice *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@ABU3@@Z ; std::allocator<FreeResourceXCities>::construct
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@ABU3@@Z PROC ; std::allocator<FreeResourceXCities>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@ABU3@@Z ENDP ; std::allocator<FreeResourceXCities>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@@Z ; std::allocator<FreeResourceXCities>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@@Z PROC ; std::allocator<FreeResourceXCities>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UFreeResourceXCities@@@std@@QAEXPAUFreeResourceXCities@@@Z ENDP ; std::allocator<FreeResourceXCities>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@@Z ; std::allocator<MayaBonusChoice>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@@Z PROC ; std::allocator<MayaBonusChoice>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@@Z ENDP ; std::allocator<MayaBonusChoice>::destroy
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??$_Construct@UMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@ABU1@@Z ; std::_Construct<MayaBonusChoice,MayaBonusChoice>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Construct@UMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@ABU1@@Z PROC ; std::_Construct<MayaBonusChoice,MayaBonusChoice>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@5:

; 53   : 	}

	ret	0
??$_Construct@UMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@ABU1@@Z ENDP ; std::_Construct<MayaBonusChoice,MayaBonusChoice>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop@3:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::~_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::~_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::~_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z PROC ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE@V?$allocator@W4TraitTypes@@@1@@Z ENDP ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?max_size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4TraitTypes@@@std@@QAEPAW4TraitTypes@@I@Z ; std::allocator<enum TraitTypes>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4TraitTypes@@@std@@QAEPAW4TraitTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4TraitTypes@@@std@@QAEPAW4TraitTypes@@I@Z PROC ; std::allocator<enum TraitTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ; std::_Allocate<enum TraitTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4TraitTypes@@@std@@QAEPAW4TraitTypes@@I@Z ENDP ; std::allocator<enum TraitTypes>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z PROC ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE@V?$allocator@V?$Array@H$05@Firaxis@@@1@@Z ENDP ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 732  : 		}

	ret	0
?max_size@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBEIXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEPAV?$Array@H$05@Firaxis@@I@Z ; std::allocator<Firaxis::Array<int,6> >::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEPAV?$Array@H$05@Firaxis@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEPAV?$Array@H$05@Firaxis@@I@Z PROC ; std::allocator<Firaxis::Array<int,6> >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ; std::_Allocate<Firaxis::Array<int,6> >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEPAV?$Array@H$05@Firaxis@@I@Z ENDP ; std::allocator<Firaxis::Array<int,6> >::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1822 : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=

; 1823 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1824 : 		}

	ret	4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+, COMDAT
; _this$ = ecx

; 1827 : 		{	// return this + integer

	sub	esp, 8

; 1828 : 		_Mytype _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 1829 : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR __Tmp$[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$[esp+8]
	mov	edx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1830 : 		}

	add	esp, 8
	ret	8
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
_TEXT	ENDS
PUBLIC	??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1845 : 		return (*(_Mybase *)this - _Right);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1846 : 		}

	ret	4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z PROC ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@PAV?$Array@H$05@Firaxis@@@Z ENDP ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator!=
_TEXT	ENDS
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1567 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1568 : 		}

	ret	4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@@Z ; std::allocator<enum TraitTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@@Z PROC ; std::allocator<enum TraitTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@@Z ENDP ; std::allocator<enum TraitTypes>::destroy
_TEXT	ENDS
PUBLIC	??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1576 : 		{	// preincrement

	mov	eax, ecx

; 1577 : 		_Inc();

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN4@operator@8
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0

; 1577 : 		_Inc();

$LN4@operator@8:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=, COMDAT
; _this$ = ecx

; 1677 : 		return (!(*this == _Right));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@operator@9
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN5@operator@9
	mov	eax, 1
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4

; 1677 : 		return (!(*this == _Right));

$LN5@operator@9:
	xor	eax, eax
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
_TEXT	ENDS
PUBLIC	??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if bit is set

	mov	edx, ecx

; 1495 : 		return ((*_Getptr() & _Mask()) != 0);

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [edx]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1496 : 		}

	ret	0
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@7
	push	esi
$LL3@Copy_opt@7:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@7
	pop	esi
$LN1@Copy_opt@7:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@@Z ; std::allocator<Firaxis::Array<int,6> >::destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@@Z PROC ; std::allocator<Firaxis::Array<int,6> >::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@@Z ENDP ; std::allocator<Firaxis::Array<int,6> >::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@ABW43@@Z ; std::allocator<enum TraitTypes>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@ABW43@@Z PROC ; std::allocator<enum TraitTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@W4TraitTypes@@@std@@QAEXPAW4TraitTypes@@ABW43@@Z ENDP ; std::allocator<enum TraitTypes>::construct
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator!=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1795 : 		{	// preincrement

	mov	eax, ecx

; 1796 : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN6@operator@10
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0

; 1796 : 		++*(_Mybase *)this;

$LN6@operator@10:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1471 : 		return (*this = bool(_Right));

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	esi
	mov	esi, 1
	shl	esi, cl
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	test	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, 1
	je	SHORT $LN10@operator@11
	shl	esi, cl
	or	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4

; 1471 : 		return (*this = bool(_Right));

$LN10@operator@11:
	shl	esi, cl
	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+=
_TEXT	ENDS
PUBLIC	??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z ; operator>><int,6>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_kArray$ = 12						; size = 4
??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z PROC ; operator>><int,6>, COMDAT

; 560  : {

	push	ebx
	push	esi

; 561  : 	for( unsigned int i = 0; i < kArray.size(); ++i )

	mov	esi, DWORD PTR _kArray$[esp+4]
	push	edi
	mov	edi, DWORD PTR _kStream$[esp+8]
	mov	ebx, 6
$LL3@operator@12:

; 562  : 	{
; 563  : 		kStream >> kArray[i];

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@12

; 564  : 	}
; 565  : 	return kStream;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 566  : }

	ret	0
??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z ENDP ; operator>><int,6>
_TEXT	ENDS
PUBLIC	??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z ; operator<<<int,6>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_kArray$ = 12						; size = 4
??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z PROC ; operator<<<int,6>, COMDAT

; 570  : {

	push	ebx
	push	esi

; 571  : 	for( unsigned int i = 0; i < kArray.size(); ++i )

	mov	esi, DWORD PTR _kArray$[esp+4]
	push	edi
	mov	edi, DWORD PTR _kStream$[esp+8]
	mov	ebx, 6
$LL3@operator@13:

; 572  : 	{
; 573  : 		kStream << kArray[i];

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@13

; 574  : 	}
; 575  : 	return kStream;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 576  : }

	ret	0
??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z ENDP ; operator<<<int,6>
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@4
	pop	esi
$LN3@fill@4:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z ; std::fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z PROC ; std::fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z ; std::_Fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >
??$fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z ENDP ; std::fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	??$fill@PAII@std@@YAXPAI0ABI@Z			; std::fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::fill<unsigned int *,unsigned int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@5
	pop	esi
$LN3@fill@5:

; 3188 : 	}

	ret	0
??$fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@4
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@4:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
	npad	3

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LL10@Fill@7:
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LN18@Fill@7
	cmp	ecx, DWORD PTR __Last$[esp+4]
	je	SHORT $LN40@Fill@7
$LN18@Fill@7:

; 3159 : 		*_First = _Val;

	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR [edx], 0
	je	SHORT $LN27@Fill@7
	or	DWORD PTR [eax], esi
	jmp	SHORT $LN2@Fill@7
$LN27@Fill@7:
	not	esi
	and	DWORD PTR [eax], esi
$LN2@Fill@7:
	mov	ecx, DWORD PTR __First$[esp+4]
	mov	eax, DWORD PTR __First$[esp]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN11@Fill@7
	inc	ecx
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LL10@Fill@7

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LN11@Fill@7:
	xor	ecx, ecx
	add	eax, 4
	mov	DWORD PTR __First$[esp+4], ecx
	mov	DWORD PTR __First$[esp], eax
	jmp	SHORT $LL10@Fill@7
$LN40@Fill@7:
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T232103 = -4						; size = 1
__Cat$232107 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T232103[esp+4], 0
	mov	eax, DWORD PTR $T232103[esp+4]
	mov	ecx, DWORD PTR __Cat$232107[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@5
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@5:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@ABV34@@Z ; std::allocator<Firaxis::Array<int,6> >::construct
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?construct@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@ABV34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@ABV34@@Z PROC ; std::allocator<Firaxis::Array<int,6> >::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx
$LN5@construct@4:

; 156  : 		}

	ret	8
?construct@?$allocator@V?$Array@H$05@Firaxis@@@std@@QAEXPAV?$Array@H$05@Firaxis@@ABV34@@Z ENDP ; std::allocator<Firaxis::Array<int,6> >::construct
_TEXT	ENDS
PUBLIC	??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1589 : 		{	// predecrement

	mov	eax, ecx

; 1590 : 		_Dec();

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN4@operator@14
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0

; 1590 : 		_Dec();

$LN4@operator@14:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@3
	pop	esi
$LN3@Fill_n@3:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@7
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@7:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@8
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@8:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@4
	pop	esi
$LN3@Fill_n@4:

; 3243 : 	}

	ret	0
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL6@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
$LN5@Uninit_cop@4:
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z	; CvPlayerTraits::HasTrait
EXTRN	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z:PROC	; CvLeaderHeadInfo::hasTrait
EXTRN	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ:PROC ; CvPlayer::getLeaderInfo
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z
_TEXT	SEGMENT
_eTrait$ = 8						; size = 4
?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z PROC	; CvPlayerTraits::HasTrait, COMDAT
; _this$ = ecx

; 2149 : {

	push	esi
	mov	esi, ecx

; 2150 : 	CvAssert(m_pPlayer);
; 2151 : 
; 2152 : 	if(m_pPlayer != NULL)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	$LN2@HasTrait
	push	edi

; 2153 : 	{
; 2154 : 		CvAssertMsg((m_pPlayer->getLeaderType() >= 0), "getLeaderType() is less than zero");
; 2155 : 		CvAssertMsg((eTrait >= 0), "eTrait is less than zero");
; 2156 : 		return m_pPlayer->getLeaderInfo().hasTrait(eTrait) && !m_pTraits->GetEntry(eTrait)->IsObsoleteByTech(m_pPlayer->getTeam()) && m_pTraits->GetEntry(eTrait)->IsEnabledByTech(m_pPlayer->getTeam());

	mov	edi, DWORD PTR _eTrait$[esp+4]
	push	edi
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	ecx, eax
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	test	al, al
	je	$LN5@HasTrait
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN11@HasTrait
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN12@HasTrait
$LN11@HasTrait:
	or	eax, -1
$LN12@HasTrait:
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [ecx+416]
	cmp	edx, -1
	je	SHORT $LN20@HasTrait
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	SHORT $LN5@HasTrait
$LN20@HasTrait:
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN30@HasTrait
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN31@HasTrait
$LN30@HasTrait:
	or	eax, -1
$LN31@HasTrait:
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+edi*4]
	push	eax
	call	?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ; CvTraitEntry::IsEnabledByTech
	test	al, al
	je	SHORT $LN5@HasTrait
	pop	edi
	mov	eax, 1
	pop	esi

; 2161 : 	}
; 2162 : }

	ret	4
$LN5@HasTrait:
	pop	edi

; 2153 : 	{
; 2154 : 		CvAssertMsg((m_pPlayer->getLeaderType() >= 0), "getLeaderType() is less than zero");
; 2155 : 		CvAssertMsg((eTrait >= 0), "eTrait is less than zero");
; 2156 : 		return m_pPlayer->getLeaderInfo().hasTrait(eTrait) && !m_pTraits->GetEntry(eTrait)->IsObsoleteByTech(m_pPlayer->getTeam()) && m_pTraits->GetEntry(eTrait)->IsEnabledByTech(m_pPlayer->getTeam());

	xor	eax, eax
	pop	esi

; 2161 : 	}
; 2162 : }

	ret	4
$LN2@HasTrait:

; 2157 : 	}
; 2158 : 	else
; 2159 : 	{
; 2160 : 		return false;

	xor	al, al
	pop	esi

; 2161 : 	}
; 2162 : }

	ret	4
?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ENDP	; CvPlayerTraits::HasTrait
_TEXT	ENDS
PUBLIC	?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeBuilding
EXTRN	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z:PROC ; CvGlobals::getTraitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ PROC ; CvPlayerTraits::GetFreeBuilding, COMDAT
; _this$ = ecx

; 2329 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2330 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	xor	ebp, ebp
	sar	eax, 2
	push	edi
	test	eax, eax
	jbe	SHORT $LN3@GetFreeBui
	npad	11
$LL5@GetFreeBui:
	mov	eax, DWORD PTR [esi+32]
	lea	edi, DWORD PTR [ebp*4]

; 2331 : 	{
; 2332 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	ecx, DWORD PTR [eax+edi]
	add	eax, edi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	ebx, eax

; 2333 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]))

	test	ebx, ebx
	je	SHORT $LN4@GetFreeBui
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	push	edx
	mov	ecx, esi
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	test	al, al
	je	SHORT $LN4@GetFreeBui

; 2334 : 		{
; 2335 : 			if(pkTraitInfo->GetFreeBuilding()!=NO_BUILDING)

	cmp	DWORD PTR [ebx+556], -1
	jne	SHORT $LN19@GetFreeBui
$LN4@GetFreeBui:

; 2330 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	inc	ebp
	sar	eax, 2
	cmp	ebp, eax
	jb	SHORT $LL5@GetFreeBui
$LN3@GetFreeBui:
	pop	edi
	pop	esi
	pop	ebp

; 2338 : 			}
; 2339 : 		}
; 2340 : 	}
; 2341 : 
; 2342 : 
; 2343 : 	return NO_BUILDING;

	or	eax, -1
	pop	ebx

; 2344 : }

	ret	0
$LN19@GetFreeBui:

; 2336 : 			{
; 2337 : 				return pkTraitInfo->GetFreeBuilding();

	mov	eax, DWORD PTR [ebx+556]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2344 : }

	ret	0
?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPlayerTraits::GetFreeBuilding
_TEXT	ENDS
PUBLIC	?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeCapitalBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ PROC ; CvPlayerTraits::GetFreeCapitalBuilding, COMDAT
; _this$ = ecx

; 2347 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2348 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	xor	ebp, ebp
	sar	eax, 2
	push	edi
	test	eax, eax
	jbe	SHORT $LN3@GetFreeCap
	npad	11
$LL5@GetFreeCap:
	mov	eax, DWORD PTR [esi+32]
	lea	edi, DWORD PTR [ebp*4]

; 2349 : 	{
; 2350 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	ecx, DWORD PTR [eax+edi]
	add	eax, edi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	ebx, eax

; 2351 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]))

	test	ebx, ebx
	je	SHORT $LN4@GetFreeCap
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	push	edx
	mov	ecx, esi
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	test	al, al
	je	SHORT $LN4@GetFreeCap

; 2352 : 		{
; 2353 : 			if(pkTraitInfo->GetFreeCapitalBuilding()!=NO_BUILDING)

	cmp	DWORD PTR [ebx+560], -1
	jne	SHORT $LN19@GetFreeCap
$LN4@GetFreeCap:

; 2348 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	inc	ebp
	sar	eax, 2
	cmp	ebp, eax
	jb	SHORT $LL5@GetFreeCap
$LN3@GetFreeCap:
	pop	edi
	pop	esi
	pop	ebp

; 2356 : 			}
; 2357 : 		}
; 2358 : 	}
; 2359 : 
; 2360 : 	return NO_BUILDING;

	or	eax, -1
	pop	ebx

; 2361 : }

	ret	0
$LN19@GetFreeCap:

; 2354 : 			{
; 2355 : 				return pkTraitInfo->GetFreeCapitalBuilding();

	mov	eax, DWORD PTR [ebx+560]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2361 : }

	ret	0
?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPlayerTraits::GetFreeCapitalBuilding
_TEXT	ENDS
PUBLIC	?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeBuildingOnConquest
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ PROC ; CvPlayerTraits::GetFreeBuildingOnConquest, COMDAT
; _this$ = ecx

; 2366 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2367 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	xor	ebp, ebp
	sar	eax, 2
	push	edi
	test	eax, eax
	jbe	SHORT $LN3@GetFreeBui@2
	npad	11
$LL5@GetFreeBui@2:
	mov	eax, DWORD PTR [esi+32]
	lea	edi, DWORD PTR [ebp*4]

; 2368 : 	{
; 2369 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	ecx, DWORD PTR [eax+edi]
	add	eax, edi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	ebx, eax

; 2370 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]))

	test	ebx, ebx
	je	SHORT $LN4@GetFreeBui@2
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	push	edx
	mov	ecx, esi
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	test	al, al
	je	SHORT $LN4@GetFreeBui@2

; 2371 : 		{
; 2372 : 			if(pkTraitInfo->GetFreeBuildingOnConquest()!=NO_BUILDING)

	cmp	DWORD PTR [ebx+572], -1
	jne	SHORT $LN19@GetFreeBui@2
$LN4@GetFreeBui@2:

; 2367 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	inc	ebp
	sar	eax, 2
	cmp	ebp, eax
	jb	SHORT $LL5@GetFreeBui@2
$LN3@GetFreeBui@2:
	pop	edi
	pop	esi
	pop	ebp

; 2375 : 			}
; 2376 : 		}
; 2377 : 	}
; 2378 : 
; 2379 : 	return NO_BUILDING;

	or	eax, -1
	pop	ebx

; 2380 : }

	ret	0
$LN19@GetFreeBui@2:

; 2373 : 			{
; 2374 : 				return pkTraitInfo->GetFreeBuildingOnConquest();

	mov	eax, DWORD PTR [ebx+572]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2380 : }

	ret	0
?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPlayerTraits::GetFreeBuildingOnConquest
_TEXT	ENDS
PUBLIC	?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetFreeBuildingPrereqTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ PROC ; CvPlayerTraits::GetFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 2526 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2527 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	xor	ebp, ebp
	sar	eax, 2
	push	edi
	test	eax, eax
	jbe	SHORT $LN2@GetFreeBui@3
	npad	11
$LL4@GetFreeBui@3:
	mov	eax, DWORD PTR [esi+32]
	lea	edi, DWORD PTR [ebp*4]

; 2528 : 	{
; 2529 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	ecx, DWORD PTR [eax+edi]
	add	eax, edi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	ebx, eax

; 2530 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]) && pkTraitInfo->GetFreeBuildingPrereqTech())

	test	ebx, ebx
	je	SHORT $LN3@GetFreeBui@3
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	push	edx
	mov	ecx, esi
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	test	al, al
	je	SHORT $LN3@GetFreeBui@3
	cmp	DWORD PTR [ebx+564], 0
	jne	SHORT $LN18@GetFreeBui@3
$LN3@GetFreeBui@3:

; 2527 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	inc	ebp
	sar	eax, 2
	cmp	ebp, eax
	jb	SHORT $LL4@GetFreeBui@3
$LN2@GetFreeBui@3:
	pop	edi
	pop	esi
	pop	ebp

; 2532 : 	}
; 2533 : 
; 2534 : 	return NO_TECH;

	or	eax, -1
	pop	ebx

; 2535 : }

	ret	0
$LN18@GetFreeBui@3:

; 2531 : 			return pkTraitInfo->GetFreeBuildingPrereqTech();

	mov	eax, DWORD PTR [ebx+564]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2535 : }

	ret	0
?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ENDP ; CvPlayerTraits::GetFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ PROC ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 2538 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2539 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	xor	ebp, ebp
	sar	eax, 2
	push	edi
	test	eax, eax
	jbe	SHORT $LN2@GetCapital@2
	npad	11
$LL4@GetCapital@2:
	mov	eax, DWORD PTR [esi+32]
	lea	edi, DWORD PTR [ebp*4]

; 2540 : 	{
; 2541 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	ecx, DWORD PTR [eax+edi]
	add	eax, edi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	ebx, eax

; 2542 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]) && pkTraitInfo->GetCapitalFreeBuildingPrereqTech())

	test	ebx, ebx
	je	SHORT $LN3@GetCapital@2
	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	push	edx
	mov	ecx, esi
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	test	al, al
	je	SHORT $LN3@GetCapital@2
	cmp	DWORD PTR [ebx+568], 0
	jne	SHORT $LN18@GetCapital@2
$LN3@GetCapital@2:

; 2539 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	eax, DWORD PTR [esi+36]
	sub	eax, DWORD PTR [esi+32]
	inc	ebp
	sar	eax, 2
	cmp	ebp, eax
	jb	SHORT $LL4@GetCapital@2
$LN2@GetCapital@2:
	pop	edi
	pop	esi
	pop	ebp

; 2544 : 	}
; 2545 : 
; 2546 : 	return NO_TECH;

	or	eax, -1
	pop	ebx

; 2547 : }

	ret	0
$LN18@GetCapital@2:

; 2543 : 			return pkTraitInfo->GetCapitalFreeBuildingPrereqTech();

	mov	eax, DWORD PTR [ebx+568]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2547 : }

	ret	0
?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ENDP ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsUsingMayaCalendar
EXTRN	?getNumTraitInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTraitInfos
; Function compile flags: /Ogtpy
;	COMDAT ?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsUsingMayaCalendar, COMDAT
; _this$ = ecx

; 2623 : {

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 2624 : 	int iNumTraits = GC.getNumTraitInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	mov	edi, eax

; 2625 : 	for(int iI = 0; iI < iNumTraits; iI++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN5@IsUsingMay
	npad	9
$LL7@IsUsingMay:

; 2626 : 	{
; 2627 : 		const TraitTypes eTrait = static_cast<TraitTypes>(iI);
; 2628 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(eTrait);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo

; 2629 : 		if(pkTraitInfo)

	test	eax, eax
	je	SHORT $LN6@IsUsingMay

; 2630 : 		{
; 2631 : 			if(pkTraitInfo->IsMayaCalendarBonuses())

	cmp	BYTE PTR [eax+594], 0
	jne	SHORT $LN13@IsUsingMay
$LN6@IsUsingMay:

; 2625 : 	for(int iI = 0; iI < iNumTraits; iI++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL7@IsUsingMay
$LN5@IsUsingMay:
	pop	edi
	pop	esi

; 2634 : 				{
; 2635 : 					return true;
; 2636 : 				}
; 2637 : 				else
; 2638 : 				{
; 2639 : 					return false;
; 2640 : 				}
; 2641 : 			}
; 2642 : 		}
; 2643 : 	}
; 2644 : 	return false;

	xor	al, al
	pop	ebx

; 2645 : }

	ret	0
$LN13@IsUsingMay:

; 2632 : 			{
; 2633 : 				if(HasTrait(eTrait))

	push	esi
	mov	ecx, ebx
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	pop	edi
	test	al, al
	pop	esi
	setne	al
	pop	ebx

; 2645 : }

	ret	0
?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsUsingMayaCalendar
_TEXT	ENDS
PUBLIC	?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ	; CvPlayerTraits::IsEndOfMayaLongCount
; Function compile flags: /Ogtpy
;	COMDAT ?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ
_TEXT	SEGMENT
?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ PROC	; CvPlayerTraits::IsEndOfMayaLongCount, COMDAT
; _this$ = ecx

; 2649 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 2650 : 	bool bRtnValue = false;

	xor	bl, bl

; 2651 : 
; 2652 : 	if (!IsUsingMayaCalendar())

	call	?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsUsingMayaCalendar
	test	al, al
	jne	SHORT $LN2@IsEndOfMay
	pop	esi
	pop	ebx

; 2667 : }

	ret	0
$LN2@IsEndOfMay:

; 2653 : 	{
; 2654 : 		return bRtnValue;
; 2655 : 	}
; 2656 : 
; 2657 : 	ComputeMayaDate();

	mov	ecx, esi
	call	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::ComputeMayaDate

; 2658 : 
; 2659 : 	if(m_iBaktunPreviousTurn + 1 == m_iBaktun)

	mov	ecx, DWORD PTR [esi+712]
	mov	eax, DWORD PTR [esi+716]
	inc	ecx
	cmp	ecx, eax
	jne	SHORT $LN1@IsEndOfMay

; 2660 : 	{
; 2661 : 		bRtnValue = true;

	mov	bl, 1
$LN1@IsEndOfMay:

; 2662 : 	}
; 2663 : 
; 2664 : 	m_iBaktunPreviousTurn = m_iBaktun;

	mov	DWORD PTR [esi+712], eax
	pop	esi

; 2665 : 
; 2666 : 	return bRtnValue;

	mov	al, bl
	pop	ebx

; 2667 : }

	ret	0
?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ ENDP	; CvPlayerTraits::IsEndOfMayaLongCount
_TEXT	ENDS
PUBLIC	?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ ; CvPlayerTraits::GetMayaCalendarString
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ$0
__ehfuncinfo$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
$T232735 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ PROC ; CvPlayerTraits::GetMayaCalendarString, COMDAT
; _this$ = ecx

; 2671 : {

	push	-1
	push	__ehhandler$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR $T232735[esp+24], 0

; 2672 : 	CvString szRtnValue;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	esi, ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2673 : 	ComputeMayaDate();
; 2674 : 	szRtnValue.Format("%d.%d.%d.%d.%d", m_iBaktun, m_iKatun, m_iTun, m_iWinal, m_iKin);
; 2675 : 	return szRtnValue;

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR $T232735[esp+24], 1
	call	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::ComputeMayaDate
	mov	eax, DWORD PTR [esi+732]
	mov	ecx, DWORD PTR [esi+728]
	mov	edx, DWORD PTR [esi+724]
	push	eax
	mov	eax, DWORD PTR [esi+720]
	push	ecx
	mov	ecx, DWORD PTR [esi+716]
	push	edx
	push	eax
	push	ecx
	push	OFFSET $SG223434
	push	edi
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2676 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	add	esp, 28					; 0000001cH
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T232735[ebp]
	and	eax, 1
	je	$LN4@GetMayaCal
	and	DWORD PTR $T232735[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetMayaCal:
	ret	0
__ehhandler$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ ENDP ; CvPlayerTraits::GetMayaCalendarString
PUBLIC	?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ ; CvPlayerTraits::GetMayaCalendarLongString
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$1
__ehfuncinfo$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
$T232752 = -44						; size = 4
$T232750 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ PROC ; CvPlayerTraits::GetMayaCalendarLongString, COMDAT
; _this$ = ecx

; 2680 : {

	push	-1
	push	__ehhandler$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T232752[esp+56], ebx

; 2681 : 	CvString szRtnValue;

	mov	edi, DWORD PTR ___$ReturnUdt$[esp+52]
	mov	esi, ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2682 : 	ComputeMayaDate();
; 2683 : 	szRtnValue = GetLocalizedText("TXT_KEY_MAYA_CALENDAR_LONG_STRING", m_iBaktun, m_iKatun, m_iTun, m_iWinal, m_iKin);
; 2684 : 	return szRtnValue;

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	mov	DWORD PTR $T232752[esp+56], 1
	call	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::ComputeMayaDate
	lea	eax, DWORD PTR [esi+732]
	push	eax
	lea	ecx, DWORD PTR [esi+728]
	push	ecx
	lea	edx, DWORD PTR [esi+724]
	push	edx
	lea	eax, DWORD PTR [esi+720]
	push	eax
	add	esi, 716				; 000002ccH
	push	esi
	lea	ecx, DWORD PTR $T232750[esp+76]
	push	OFFSET $SG223454
	push	ecx
	call	??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z ; GetLocalizedText<int,int,int,int,int>
	add	esp, 28					; 0000001cH
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+68], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232750[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2685 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T232752[ebp]
	and	eax, 1
	je	$LN4@GetMayaCal@2
	and	DWORD PTR $T232752[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetMayaCal@2:
	ret	0
__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$1:
	lea	ecx, DWORD PTR $T232750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ ENDP ; CvPlayerTraits::GetMayaCalendarLongString
PUBLIC	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z
_TEXT	SEGMENT
_eUnit$ = 8						; size = 4
?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z PROC	; CvPlayerTraits::GetUnitBaktun, COMDAT
; _this$ = ecx

; 2893 : 	std::vector<MayaBonusChoice>::const_iterator it;
; 2894 : 
; 2895 : 	// Loop through all units available to tactical AI this turn
; 2896 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2897 : 	for (it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); ++it)
; 2898 : #else
; 2899 : 	for(it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); it++)

	mov	eax, DWORD PTR [ecx+740]
	mov	ecx, DWORD PTR [ecx+744]
	cmp	eax, ecx
	je	SHORT $LN2@GetUnitBak
	mov	edx, DWORD PTR _eUnit$[esp-4]
$LL15@GetUnitBak:

; 2900 : #endif
; 2901 : 	{
; 2902 : 		if(it->m_eUnitType == eUnit)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN34@GetUnitBak
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL15@GetUnitBak
$LN2@GetUnitBak:

; 2905 : 		}
; 2906 : 	}
; 2907 : 
; 2908 : 	return 0;

	xor	eax, eax

; 2909 : }

	ret	4
$LN34@GetUnitBak:

; 2903 : 		{
; 2904 : 			return it->m_iBaktunJustFinished;

	mov	eax, DWORD PTR [eax+4]

; 2909 : }

	ret	4
?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ENDP	; CvPlayerTraits::GetUnitBaktun
_TEXT	ENDS
PUBLIC	?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z ; CvPlayerTraits::ConvertBarbarianCamp
EXTRN	?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z:PROC ; CvPlot::SetBarbarianCampNotConverting
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z:PROC ; CvHomelandAI::LogHomelandMessage
EXTRN	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ:PROC ; CvPlayer::GetHomelandAI
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ:PROC	; CvUnit::jumpToNearestValidPlot
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlot::SetPlayerThatClearedBarbCampHere
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ:PROC ; CvPlot::IsBarbarianCampNotConverting
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$3
__ehfuncinfo$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_pGiftUnit$ = -104					; size = 8
_logMsg$224050 = -96					; size = 28
_strSummary$224055 = -68				; size = 28
_strBuffer$224052 = -40					; size = 28
__$EHRec$ = -12						; size = 12
$T232968 = 8						; size = 4
_iI$224043 = 8						; size = 4
_pPlot$ = 8						; size = 4
?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z PROC ; CvPlayerTraits::ConvertBarbarianCamp, COMDAT
; _this$ = ecx

; 3565 : {

	push	-1
	push	__ehhandler$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi

; 3566 : 	UnitHandle pGiftUnit;

	xor	ebx, ebx
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _pGiftUnit$[esp+116], ebx
	mov	BYTE PTR _pGiftUnit$[esp+120], bl

; 3567 : 
; 3568 : 	// Has this camp already decided not to convert?
; 3569 : 	if(pPlot->IsBarbarianCampNotConverting())

	mov	edi, DWORD PTR _pPlot$[esp+112]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+124], ebx
	call	?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ ; CvPlot::IsBarbarianCampNotConverting
	test	al, al

; 3570 : 	{
; 3571 : 		return false;

	jne	$LN112@ConvertBar

; 3572 : 	}
; 3573 : 
; 3574 : 	// Roll die to see if it converts
; 3575 : 	if(GC.getGame().getJonRandNum(100, "Barbarian Camp Conversion") < m_iLandBarbarianConversionPercent)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG224039
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	cmp	eax, DWORD PTR [esi+100]

; 3576 : 	{
; 3577 : 		pPlot->setImprovementType(NO_IMPROVEMENT);

	mov	ecx, edi
	jge	$LN11@ConvertBar
	push	ebp
	push	-1
	push	-1
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 3578 : 
; 3579 : 		int iNumGold = /*25*/ GC.getGOLD_FROM_BARBARIAN_CONVERSION();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7068

; 3580 : 		m_pPlayer->GetTreasury()->ChangeGold(iNumGold);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3581 : 
; 3582 : 		// Set who last cleared the camp here
; 3583 : 		pPlot->SetPlayerThatClearedBarbCampHere(m_pPlayer->GetID());

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatClearedBarbCampHere

; 3584 : 
; 3585 : 		// Convert the barbarian into our unit
; 3586 : 		FAssertMsg(m_eCampGuardType < GC.getNumUnitInfos(), "Illegal camp guard unit type");
; 3587 : 		pGiftUnit = m_pPlayer->initUnit(m_eCampGuardType, pPlot->getX(), pPlot->getY(), NO_UNITAI, NO_DIRECTION, true /*bNoMove*/);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebx
	push	ebx
	push	1
	push	1
	push	-1
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+348]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	ebp, eax
	mov	ebx, ebp
	mov	DWORD PTR _pGiftUnit$[esp+120], ebx
	test	ebp, ebp
	je	SHORT $LN44@ConvertBar
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@ConvertBar:

; 3588 : 		if (!pGiftUnit->jumpToNearestValidPlot())

	mov	ecx, ebp
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot

; 3589 : 			pGiftUnit->kill(false);

	mov	ecx, ebp
	test	al, al
	jne	SHORT $LN10@ConvertBar
	push	-1
	push	0
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 3590 : 		else

	jmp	SHORT $LN9@ConvertBar
$LN10@ConvertBar:

; 3591 : 			pGiftUnit->finishMoves();

	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN9@ConvertBar:

; 3592 : 
; 3593 : 		// Convert any extra units
; 3594 : 		for(int iI = 0; iI < m_iLandBarbarianConversionExtraUnits; iI++)

	cmp	DWORD PTR [esi+104], 0
	mov	DWORD PTR _iI$224043[esp+116], 0
	jle	SHORT $LN6@ConvertBar
	npad	8
$LL110@ConvertBar:

; 3595 : 		{
; 3596 : 			pGiftUnit = m_pPlayer->initUnit(m_eCampGuardType, pPlot->getX(), pPlot->getY(), NO_UNITAI, NO_DIRECTION, true /*bNoMove*/);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	edx, DWORD PTR [esi+348]
	push	0
	push	0
	push	1
	push	1
	push	-1
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	ebp, eax
	test	ebx, ebx
	je	SHORT $LN60@ConvertBar
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN60@ConvertBar:
	mov	ebx, ebp
	mov	DWORD PTR _pGiftUnit$[esp+120], ebx
	test	ebp, ebp
	je	SHORT $LN62@ConvertBar
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@ConvertBar:

; 3597 : 			if (!pGiftUnit->jumpToNearestValidPlot())

	mov	ecx, ebp
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot

; 3598 : 				pGiftUnit->kill(false);

	mov	ecx, ebp
	test	al, al
	jne	SHORT $LN5@ConvertBar
	push	-1
	push	0
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 3599 : 			else

	jmp	SHORT $LN7@ConvertBar
$LN5@ConvertBar:

; 3600 : 				pGiftUnit->finishMoves();

	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN7@ConvertBar:

; 3592 : 
; 3593 : 		// Convert any extra units
; 3594 : 		for(int iI = 0; iI < m_iLandBarbarianConversionExtraUnits; iI++)

	mov	eax, DWORD PTR _iI$224043[esp+116]
	inc	eax
	cmp	eax, DWORD PTR [esi+104]
	mov	DWORD PTR _iI$224043[esp+116], eax
	jl	SHORT $LL110@ConvertBar
$LN6@ConvertBar:

; 3601 : 		}
; 3602 : 
; 3603 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN3@ConvertBar
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN3@ConvertBar

; 3604 : 		{
; 3605 : 			CvString logMsg;

	lea	ecx, DWORD PTR _logMsg$224050[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3606 : 			logMsg.Format("Converted barbarian camp, X: %d, Y: %d", pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _logMsg$224050[esp+128]
	push	OFFSET $SG224051
	push	edx
	mov	BYTE PTR __$EHRec$[esp+144], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3607 : 			m_pPlayer->GetHomelandAI()->LogHomelandMessage(logMsg);

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _logMsg$224050[esp+120]
	push	eax
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3608 : 		}

	lea	ecx, DWORD PTR _logMsg$224050[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ConvertBar:

; 3609 : 
; 3610 : 		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BARB_CAMP_CONVERTS");

	lea	ecx, DWORD PTR _strBuffer$224052[esp+120]
	push	OFFSET $SG224054
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 3611 : 		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_BARB_CAMP_CONVERTS");

	lea	edx, DWORD PTR _strSummary$224055[esp+128]
	push	OFFSET $SG224057
	push	edx
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 16					; 00000010H

; 3612 : 		m_pPlayer->GetNotifications()->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pPlot->getX(), pPlot->getY(), -1);

	movsx	ebp, WORD PTR [edi+2]
	movsx	edi, WORD PTR [edi]
	lea	ecx, DWORD PTR _strSummary$224055[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strBuffer$224052[esp+120]
	mov	DWORD PTR $T232968[esp+116], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T232968[esp+116]
	push	-1
	push	-1
	push	ebp
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	-1097390650				; be9725c6H
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3613 : 		//Increase Stat
; 3614 : 		if(m_pPlayer->isHuman() &&!GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR [esi+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	pop	ebp
	test	al, al
	je	SHORT $LN2@ConvertBar
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN2@ConvertBar

; 3615 : 		{
; 3616 : 			gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_BARBSCONVERTED, 10, ACHIEVEMENT_SPECIAL_BARBARIANWARLORD);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+848]
	push	110					; 0000006eH
	push	10					; 0000000aH
	push	128					; 00000080H
	call	eax
$LN2@ConvertBar:

; 3617 : 		}
; 3618 : 	}

	lea	ecx, DWORD PTR _strSummary$224055[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$224052[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3624 : 		return false;
; 3625 : 	}
; 3626 : 
; 3627 : 	return true;

	mov	DWORD PTR __$EHRec$[esp+124], -1
	test	ebx, ebx
	je	SHORT $LN106@ConvertBar
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN106@ConvertBar:
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 3628 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	mov	DWORD PTR fs:0, ecx
	add	esp, 104				; 00000068H
	ret	4
$LN11@ConvertBar:

; 3619 : 
; 3620 : 	// Decided not to
; 3621 : 	else
; 3622 : 	{
; 3623 : 		pPlot->SetBarbarianCampNotConverting(true);

	push	1
	call	?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z ; CvPlot::SetBarbarianCampNotConverting
$LN112@ConvertBar:

; 3628 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 104				; 00000068H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pGiftUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _logMsg$224050[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strBuffer$224052[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _strSummary$224055[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z ENDP ; CvPlayerTraits::ConvertBarbarianCamp
PUBLIC	?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlayerTraits::ConvertBarbarianNavalUnit
EXTRN	?SetNotConverting@CvUnit@@QAEX_N@Z:PROC		; CvUnit::SetNotConverting
EXTRN	__imp___stricmp:PROC
EXTRN	?setupGraphical@CvUnit@@QAEXXZ:PROC		; CvUnit::setupGraphical
EXTRN	?convert@CvUnit@@QAEXPAV1@_N@Z:PROC		; CvUnit::convert
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?IsNotConverting@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsNotConverting
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$4
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T233200 = -108						; size = 4
_pGiftUnit$ = -104					; size = 8
_logMsg$224075 = -96					; size = 28
_strSummary$224080 = -68				; size = 28
_strBuffer$224077 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvPlayerTraits::ConvertBarbarianNavalUnit, COMDAT
; _this$ = ecx

; 3632 : {

	push	-1
	push	__ehhandler$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 96					; 00000060H
	push	esi
	push	edi
	mov	esi, ecx
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+124], edi

; 3633 : 	UnitHandle pGiftUnit;

	mov	DWORD PTR _pGiftUnit$[esp+116], edi
	mov	BYTE PTR _pGiftUnit$[esp+120], 0

; 3634 : 
; 3635 : 	// Has this unit already decided not to convert?
; 3636 : 	if(pUnit->IsNotConverting())

	mov	ecx, DWORD PTR _pUnit$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+124], 1
	call	?IsNotConverting@CvUnit@@QBE_NXZ	; CvUnit::IsNotConverting
	test	al, al

; 3637 : 	{
; 3638 : 		return false;

	jne	$LN146@ConvertBar@2

; 3639 : 	}
; 3640 : 
; 3641 : 	// Roll die to see if it converts
; 3642 : 	if(GC.getGame().getJonRandNum(100, "Barbarian Naval Unit Conversion") < m_iSeaBarbarianConversionPercent)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG224070
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	cmp	eax, DWORD PTR [esi+108]
	jge	$LN4@ConvertBar@2

; 3643 : 	{
; 3644 : 		int iNumGold = /*25*/ GC.getGOLD_FROM_BARBARIAN_CONVERSION();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7068

; 3645 : 		m_pPlayer->GetTreasury()->ChangeGold(iNumGold);

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	ebp
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3646 : 
; 3647 : 		// Convert the barbarian into our unit
; 3648 : #ifdef AUI_UNIT_FIX_GIFTED_UNITS_ARE_GIFTED_NOT_CLONED
; 3649 : 		pGiftUnit = m_pPlayer->initUnit(pUnit->getUnitType(), pUnit->getX(), pUnit->getY(), pUnit->AI_getUnitAIType(), NO_DIRECTION, true /*bNoMove*/, false, DEFAULT_UNIT_MAP_LAYER, 0, true);
; 3650 : #else
; 3651 : 		pGiftUnit = m_pPlayer->initUnit(pUnit->getUnitType(), pUnit->getX(), pUnit->getY(), pUnit->AI_getUnitAIType(), NO_DIRECTION, true /*bNoMove*/, false);

	mov	ecx, DWORD PTR _pUnit$[esp+120]
	mov	edi, DWORD PTR [ecx+88]
	mov	ebx, DWORD PTR [ecx+76]
	push	0
	push	0
	push	0
	push	1
	push	-1
	mov	ebp, ecx
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	push	eax
	push	edi
	push	ebx
	mov	ecx, ebp
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	edi, eax
	mov	DWORD PTR _pGiftUnit$[esp+124], edi
	test	edi, edi
	je	SHORT $LN53@ConvertBar@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ConvertBar@2:

; 3652 : #endif
; 3653 : 		CvAssertMsg(pGiftUnit, "GiftUnit is not assigned a valid value");
; 3654 : 		pGiftUnit->convert(pUnit.pointer(), false);

	mov	eax, DWORD PTR _pUnit$[esp+120]
	push	0
	push	eax
	mov	ecx, edi
	call	?convert@CvUnit@@QAEXPAV1@_N@Z		; CvUnit::convert

; 3655 : 		pGiftUnit->setupGraphical();

	mov	ecx, edi
	call	?setupGraphical@CvUnit@@QAEXXZ		; CvUnit::setupGraphical

; 3656 : 		pGiftUnit->finishMoves(); // No move first turn

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3657 : 
; 3658 : 		// Validate that the achievement is reached by a live human and active player at the same time
; 3659 : 		if(m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer() && m_pPlayer->getLeaderInfo().GetType() && _stricmp(m_pPlayer->getLeaderInfo().GetType(), "LEADER_SULEIMAN") == 0)

	mov	ecx, DWORD PTR [esi+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN3@ConvertBar@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN3@ConvertBar@2
	mov	ecx, DWORD PTR [esi+4]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	je	SHORT $LN3@ConvertBar@2
	mov	ecx, DWORD PTR [esi+4]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	OFFSET $SG224073
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@ConvertBar@2

; 3660 : 		{
; 3661 : 			gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_BARBSNAVALCONVERTED, 10, ACHIEVEMENT_SPECIAL_BARBARYPIRATE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+848]
	push	111					; 0000006fH
	push	10					; 0000000aH
	push	130					; 00000082H
	call	eax
$LN3@ConvertBar@2:

; 3662 : 		}
; 3663 : 
; 3664 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN2@ConvertBar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN2@ConvertBar@2

; 3665 : 		{
; 3666 : 			CvString logMsg;

	lea	ecx, DWORD PTR _logMsg$224075[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3667 : 			logMsg.Format("Converted barbarian naval unit, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$[esp+120]
	mov	ecx, DWORD PTR [eax+88]
	mov	eax, DWORD PTR [eax+76]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _logMsg$224075[esp+132]
	push	OFFSET $SG224076
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+148], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3668 : 			m_pPlayer->GetHomelandAI()->LogHomelandMessage(logMsg);

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _logMsg$224075[esp+124]
	push	edx
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3669 : 		}

	lea	ecx, DWORD PTR _logMsg$224075[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ConvertBar@2:

; 3670 : 
; 3671 : 		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BARB_NAVAL_UNIT_CONVERTS");

	lea	eax, DWORD PTR _strBuffer$224077[esp+124]
	push	OFFSET $SG224079
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 3672 : 		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_BARB_NAVAL_UNIT_CONVERTS");

	lea	ecx, DWORD PTR _strSummary$224080[esp+132]
	push	OFFSET $SG224082
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+148], 3
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 16					; 00000010H

; 3673 : 		m_pPlayer->GetNotifications()->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pUnit->getX(), pUnit->getY(), -1);

	mov	eax, DWORD PTR _pUnit$[esp+120]
	mov	ebp, DWORD PTR [eax+88]
	mov	ebx, DWORD PTR [eax+76]
	lea	ecx, DWORD PTR _strSummary$224080[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strBuffer$224077[esp+124]
	mov	DWORD PTR $T233200[esp+124], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR $T233200[esp+124]
	mov	ecx, DWORD PTR [esi+4]
	push	-1
	push	-1
	push	ebp
	push	ebx
	push	edx
	push	eax
	push	-1097390650				; be9725c6H
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3674 : 		return true;

	lea	ecx, DWORD PTR _strSummary$224080[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$224077[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebp
	mov	BYTE PTR __$EHRec$[esp+128], 0
	pop	ebx
	test	edi, edi
	je	SHORT $LN114@ConvertBar@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN114@ConvertBar@2:
	mov	ecx, DWORD PTR _pUnit$[esp+112]
	mov	DWORD PTR __$EHRec$[esp+124], -1
	test	ecx, ecx
	je	SHORT $LN119@ConvertBar@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN119@ConvertBar@2:
	pop	edi
	mov	al, 1
	pop	esi

; 3682 : 	}
; 3683 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, ecx
	add	esp, 108				; 0000006cH
	ret	8
$LN4@ConvertBar@2:

; 3675 : 	}
; 3676 : 
; 3677 : 	// Decided not to
; 3678 : 	else
; 3679 : 	{
; 3680 : 		pUnit->SetNotConverting(true);

	mov	ecx, DWORD PTR _pUnit$[esp+112]
	push	1
	call	?SetNotConverting@CvUnit@@QAEX_N@Z	; CvUnit::SetNotConverting
$LN146@ConvertBar@2:

; 3681 : 		return false;

	mov	ecx, DWORD PTR _pUnit$[esp+112]
	mov	DWORD PTR __$EHRec$[esp+124], -1
	cmp	ecx, edi
	je	SHORT $LN131@ConvertBar@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN131@ConvertBar@2:

; 3682 : 	}
; 3683 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	pop	edi
	xor	al, al
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 108				; 0000006cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _pGiftUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR _logMsg$224075[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _strBuffer$224077[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$4:
	lea	ecx, DWORD PTR _strSummary$224080[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvPlayerTraits::ConvertBarbarianNavalUnit
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::upper_bound
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::upper_bound, COMDAT
; _this$ = ecx

; 1019 : 		return (_TREE_CONST_ITERATOR(_Ubound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN30@upper_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@upper_boun:
	cmp	edx, DWORD PTR [eax+12]
	jge	SHORT $LN4@upper_boun
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN3@upper_boun
$LN4@upper_boun:
	mov	eax, DWORD PTR [eax+8]
$LN3@upper_boun:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@upper_boun
$LN30@upper_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1020 : 		}

	ret	8
?upper_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::upper_bound
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@XZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::end
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
_TEXT	ENDS
PUBLIC	??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator->
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator->, COMDAT
; _this$ = ecx

; 269  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 270  : 			}

	ret	0
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBEPBU?$pair@$$CBHH@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator->
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN30@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL6@lower_boun
$LN30@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::lower_bound
_TEXT	ENDS
PUBLIC	?begin@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@XZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ; std::_Allocate<FreeResourceXCities>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z ; std::_Allocate<CvTraitEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@XZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::end
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 5
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 5
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+52], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ; std::_Allocate<MayaBonusChoice>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode
	mov	DWORD PTR [eax], 0
$LN27@Buynode:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode
	mov	DWORD PTR [ecx], 0
$LN37@Buynode:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode
	mov	DWORD PTR [ecx], 0
$LN47@Buynode:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+21], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Make_iter
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXPAPAVCvTraitEntry@@0@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXPAPAVCvTraitEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXPAPAVCvTraitEntry@@0@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXPAPAVCvTraitEntry@@0@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Make_iter
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<MayaBonusChoice,std::allocator<MayaBonusChoice> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<FreeResourceXCities,std::allocator<FreeResourceXCities> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum TraitTypes,std::allocator<enum TraitTypes> >::operator+
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
; File s:\msvs2008\vc\include\xtree
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T233859 = -80						; size = 28
$T233858 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T233859[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233858[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233859[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T233858[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T233858[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T233858[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T233858[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase:
$LN40@erase:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LN39@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase
$LN39@erase:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+21], 0
	je	SHORT $LN37@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase
$LN37@erase:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase
$LN288@erase:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase
$LN33@erase:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase
$LN31@erase:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN43@erase
	mov	eax, esi
	jmp	SHORT $LN44@erase
$LN43@erase:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Min
	add	esp, 4
$LN44@erase:
	mov	DWORD PTR [ebx], eax
$LN29@erase:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+21], 0
	je	SHORT $LN45@erase
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN45@erase:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN35@erase:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase
$LN26@erase:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+21], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase
$LN23@erase:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase
$LN21@erase:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN173@erase
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+20], bl
	jne	$LN19@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase
	npad	6
$LL18@erase:
	cmp	BYTE PTR [edi+20], bl
	jne	$LN16@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN14@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+20], bl
	je	SHORT $LN292@erase
$LN11@erase:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN9@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+20], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN15@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+20], 0
	jne	SHORT $LN7@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+20], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+20], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+21], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN4@erase
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+20], bl
	jne	SHORT $LN4@erase
$LN292@erase:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+20], 0
$LN291@erase:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase
$LN4@erase:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+20], bl
	jne	SHORT $LN2@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+20], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+20], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+20]
	mov	BYTE PTR [eax+20], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+20], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+20], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
$LN16@erase:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+20], bl
$LN19@erase:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T233859[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T233858[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+21], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+21], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+16], ecx
	mov	BYTE PTR [eax+20], dl
	mov	BYTE PTR [eax+21], 0
$LN4@Buynode@2:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??$?6V?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@FDataStream@@QAEAAV0@ABV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@Z ; FDataStream::operator<<<std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6V?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@FDataStream@@QAEAAV0@ABV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@Z
_TEXT	SEGMENT
$T234382 = 8						; size = 1
_kData$ = 8						; size = 4
??$?6V?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@FDataStream@@QAEAAV0@ABV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@Z PROC ; FDataStream::operator<<<std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T234382[esp]
	setne	cl
	mov	BYTE PTR $T234382[esp], cl
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6V?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@FDataStream@@QAEAAV0@ABV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@@Z ENDP ; FDataStream::operator<<<std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>, COMDAT
; _this$ = ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Ucopy
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Ucopy:
	pop	edi
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	12					; 0000000cH
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z ; stdext::_Unchecked_move_backward<FreeResourceXCities *,FreeResourceXCities *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<FreeResourceXCities *,FreeResourceXCities *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<FreeResourceXCities *,FreeResourceXCities *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum TraitTypes *,enum TraitTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum TraitTypes *,enum TraitTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@2
	push	esi
$LL12@Unchecked_@2:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@2
	pop	esi
$LN11@Unchecked_@2:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum TraitTypes *,enum TraitTypes *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z ; stdext::_Unchecked_move_backward<MayaBonusChoice *,MayaBonusChoice *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<MayaBonusChoice *,MayaBonusChoice *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@3
	push	esi
$LL12@Unchecked_@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@3
	pop	esi
$LN11@Unchecked_@3:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<MayaBonusChoice *,MayaBonusChoice *>
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::_Find<std::_Vector_const_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z PROC ; std::_Find<std::_Vector_const_iterator<int,std::allocator<int> >,int>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN19@Find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL7@Find:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN19@Find
	add	ecx, 4
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL7@Find
$LN19@Find:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ENDP ; std::_Find<std::_Vector_const_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::_Find<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z PROC ; std::_Find<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN23@Find@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@Find@2:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN23@Find@2
	add	ecx, 4
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL9@Find@2
$LN23@Find@2:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ENDP ; std::_Find<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<FreeResourceXCities> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<MayaBonusChoice> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@ABU3@@Z ; std::allocator<MayaBonusChoice>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@ABU3@@Z PROC ; std::allocator<MayaBonusChoice>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@5:

; 156  : 		}

	ret	8
?construct@?$allocator@UMayaBonusChoice@@@std@@QAEXPAUMayaBonusChoice@@ABU3@@Z ENDP ; std::allocator<MayaBonusChoice>::construct
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z
_TEXT	SEGMENT
$T234743 = -4						; size = 1
__Cat$234747 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T234743[esp+4], 0
	mov	eax, DWORD PTR $T234743[esp+4]
	mov	ecx, DWORD PTR __Cat$234747[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
$LL6@Uninit_cop@5:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@5:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@6
	push	esi
$LL6@Uninit_cop@6:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN18@Uninit_cop@6
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN18@Uninit_cop@6:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@6
	pop	esi
$LN4@Uninit_cop@6:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ; std::_Allocate<enum TraitTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@6
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen
$LN16@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ; std::_Allocate<Firaxis::Array<int,6> >

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@6:
?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Buy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@7
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN16@Buy@7:
$LN2@Buy@7:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@7:
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1786 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1787 : 		}

	ret	4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2053 : 		const size_type _Maxsize = _Myvec.max_size();
; 2054 : 		return (_Maxsize < (size_type)(-1) / _VBITS
; 2055 : 			? _Maxsize * _VBITS : (size_type)(-1));

	or	eax, -1

; 2056 : 		}

	ret	0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT	ENDS
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum TraitTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ; stdext::unchecked_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z
_TEXT	SEGMENT
$T235084 = -4						; size = 1
__Cat$235089 = -4					; size = 1
$T235086 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z PROC ; stdext::unchecked_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T235084[esp+4], 0
	mov	eax, DWORD PTR $T235084[esp+4]
	mov	ecx, DWORD PTR __Cat$235089[esp+4]
	mov	edx, DWORD PTR $T235086[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ENDP ; stdext::unchecked_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+8]
	npad	2

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

$LL18@Copy_opt@8:
	mov	eax, DWORD PTR __First$[esp+4]
	cmp	eax, DWORD PTR __Last$[esp+4]
	jne	SHORT $LN26@Copy_opt@8
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN62@Copy_opt@8
$LN26@Copy_opt@8:

; 2472 : 		*_Dest = *_First;

	mov	ebx, 1
	shl	ebx, cl
	mov	ecx, esi
	test	ebx, DWORD PTR [eax]
	mov	eax, 1
	je	SHORT $LN49@Copy_opt@8
	shl	eax, cl
	or	DWORD PTR [edx], eax
	jmp	SHORT $LN2@Copy_opt@8
$LN49@Copy_opt@8:
	shl	eax, cl
	not	eax
	and	DWORD PTR [edx], eax
$LN2@Copy_opt@8:
	mov	esi, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR __Dest$[esp+4]
	cmp	esi, 31					; 0000001fH
	jae	SHORT $LN11@Copy_opt@8

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	inc	esi
	jmp	SHORT $LN63@Copy_opt@8
$LN11@Copy_opt@8:
	xor	esi, esi
	add	edx, 4
	mov	DWORD PTR __Dest$[esp+4], edx
$LN63@Copy_opt@8:
	mov	ecx, DWORD PTR __First$[esp+8]
	mov	DWORD PTR __Dest$[esp+8], esi
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN19@Copy_opt@8
	inc	ecx
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@8
$LN19@Copy_opt@8:
	xor	ecx, ecx
	add	DWORD PTR __First$[esp+4], 4
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@8
$LN62@Copy_opt@8:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax+4], esi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAEXABV?$Array@H$05@Firaxis@@@Z ; SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >::operator()
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAEXABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAEXABV?$Array@H$05@Firaxis@@@Z PROC ; SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >::operator(), COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebx

; 75   : 		m_saveTo << i;

	mov	ebx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR _i$[esp+4]
	push	edi
	mov	edi, 6
	npad	2
$LL5@operator@15:
	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL5@operator@15
	pop	edi
	pop	esi
	pop	ebx

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@QAEXABV?$Array@H$05@Firaxis@@@Z ENDP ; SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const >::operator()
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@4:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H

; 3188 : 	}

	ret	0
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z
_TEXT	SEGMENT
$T235382 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$235385 = 16					; size = 1
$T235364 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$235385[esp]
	mov	edx, DWORD PTR $T235364[esp]
	mov	BYTE PTR $T235382[esp+4], 0
	mov	eax, DWORD PTR $T235382[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@5:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	edx, DWORD PTR __Count$[esp-4]
	test	edx, edx
	jbe	SHORT $LN4@Uninit_fil@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@3:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], esi
$LN5@Uninit_fil@3:
	dec	edx
	add	eax, 24					; 00000018H
	test	edx, edx
	ja	SHORT $LL6@Uninit_fil@3
	pop	esi
$LN4@Uninit_fil@3:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1808 : 		{	// predecrement

	mov	eax, ecx

; 1809 : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN6@operator@16
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0

; 1809 : 		--*(_Mybase *)this;

$LN6@operator@16:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@9
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@9:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@9
	pop	esi
$LN7@unchecked_@9:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@10
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@10:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@10
	pop	esi
$LN7@unchecked_@10:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z
_TEXT	SEGMENT
$T235628 = -4						; size = 1
__Cat$235633 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T235628[esp+4], 0
	mov	eax, DWORD PTR $T235628[esp+4]
	mov	ecx, DWORD PTR __Cat$235633[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z ; CvPlayerTraits::CheckForBarbarianConversion
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z$0
__ehfuncinfo$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_bRtnValue$ = -21					; size = 1
_pNavalUnit$223337 = -20				; size = 8
__$EHRec$ = -12						; size = 12
$T235637 = 8						; size = 4
_pPlot$ = 8						; size = 4
?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z PROC ; CvPlayerTraits::CheckForBarbarianConversion, COMDAT
; _this$ = ecx

; 2467 : {

	push	-1
	push	__ehhandler$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebp
	push	esi
	push	edi

; 2468 : 	// Loop through all adjacent plots
; 2469 : 	CvPlot* pAdjacentPlot;
; 2470 : 	int iI;
; 2471 : 	bool bRtnValue = false;
; 2472 : 
; 2473 : 	if(pPlot->isWater() && GetSeaBarbarianConversionPercent() > 0)

	mov	edi, DWORD PTR _pPlot$[esp+32]
	xor	al, al
	cmp	BYTE PTR [edi+5], 3
	mov	ebp, ecx
	mov	BYTE PTR _bRtnValue$[esp+36], al
	jne	$LN10@CheckForBa
	cmp	DWORD PTR [ebp+108], 0
	jle	$LN10@CheckForBa

; 2474 : 	{
; 2475 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	esi, esi
	npad	3
$LL9@CheckForBa:

; 2476 : 		{
; 2477 : 			pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	esi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 2478 : 
; 2479 : 			if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN8@CheckForBa

; 2480 : 			{
; 2481 : 				if(pAdjacentPlot->isWater())

	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN8@CheckForBa

; 2482 : 				{
; 2483 : 					UnitHandle pNavalUnit = pAdjacentPlot->getBestDefender(BARBARIAN_PLAYER);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	63					; 0000003fH
	lea	edx, DWORD PTR _pNavalUnit$223337[esp+64]
	push	edx
	mov	ecx, eax
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 2484 : 					if(pNavalUnit)

	mov	ecx, DWORD PTR _pNavalUnit$223337[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	ecx, ecx
	je	SHORT $LN3@CheckForBa

; 2485 : 					{
; 2486 : 						if(ConvertBarbarianNavalUnit(pNavalUnit))

	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	cl, BYTE PTR _pNavalUnit$223337[esp+48]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T235637[esp+40], esp
	test	eax, eax
	je	SHORT $LN30@CheckForBa
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@CheckForBa:
	mov	ecx, ebp
	call	?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlayerTraits::ConvertBarbarianNavalUnit

; 2487 : 						{
; 2488 : 							bRtnValue = true;

	mov	ecx, DWORD PTR _pNavalUnit$223337[esp+36]
	test	al, al
	je	SHORT $LN3@CheckForBa
	mov	BYTE PTR _bRtnValue$[esp+36], 1
$LN3@CheckForBa:

; 2489 : 						}
; 2490 : 					}
; 2491 : 				}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ecx, ecx
	je	SHORT $LN8@CheckForBa
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN8@CheckForBa:

; 2474 : 	{
; 2475 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	$LL9@CheckForBa
$LN45@CheckForBa:

; 2500 : 	}
; 2501 : 
; 2502 : 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[esp+36]
$LN1@CheckForBa:

; 2503 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	add	esp, 24					; 00000018H
	ret	4
$LN10@CheckForBa:

; 2492 : 			}
; 2493 : 		}
; 2494 : 	}
; 2495 : 
; 2496 : 	else if(GetLandBarbarianConversionPercent() > 0 && pPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT() &&
; 2497 : 	        m_eCampGuardType != NO_UNIT)

	cmp	DWORD PTR [ebp+100], 0
	jle	SHORT $LN1@CheckForBa
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, edi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, esi
	jne	SHORT $LN45@CheckForBa
	cmp	DWORD PTR [ebp+348], -1
	je	SHORT $LN45@CheckForBa

; 2498 : 	{
; 2499 : 		bRtnValue = ConvertBarbarianCamp(pPlot);

	push	edi
	mov	ecx, ebp
	call	?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z ; CvPlayerTraits::ConvertBarbarianCamp

; 2503 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebp
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pNavalUnit$223337[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z ENDP ; CvPlayerTraits::CheckForBarbarianConversion
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
$T235704 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jge	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jl	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T235704[esp+8], eax
	lea	eax, DWORD PTR $T235704[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
_TEXT	ENDS
PUBLIC	??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::vector<enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::vector<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::vector<enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+52], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::erase
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xtree
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	cmp	BYTE PTR [ebx+21], 0
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __Newroot$[ebp], eax
	jne	SHORT $LN8@Copy

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	movzx	ecx, BYTE PTR [ebx+20]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	lea	edx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode

; 1082 : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	cmp	BYTE PTR [edx+21], 0
	mov	edi, eax
	je	SHORT $LN2@Copy

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], edi
$LN2@Copy:

; 1084 : 
; 1085 : 			_TRY_BEGIN
; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR [edi], eax

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR [edi+8], eax
$LN8@Copy:

; 1091 : 			_CATCH_END
; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree
; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN29@Copy:
$LN28@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T236428 = -80						; size = 28
$T236427 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 536870910		; 1ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T236428[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T236427[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T236428[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T236427[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T236427[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T236427[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T236427[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+20], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+20], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+20], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+20], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+20], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+20], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+20], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T236428[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$2:
	lea	ecx, DWORD PTR $T236427[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_ptr<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
_TEXT	ENDS
PUBLIC	??$find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::find<std::_Vector_const_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z PROC ; std::find<std::_Vector_const_iterator<int,std::allocator<int> >,int>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN21@find@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@find@2:
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN21@find@2
	add	ecx, 4
	cmp	ecx, eax
	jne	SHORT $LL9@find@2
$LN21@find@2:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ENDP ; std::find<std::_Vector_const_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::find<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z PROC ; std::find<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN25@find@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL11@find@3:
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN25@find@3
	add	ecx, 4
	cmp	ecx, eax
	jne	SHORT $LL11@find@3
$LN25@find@3:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ENDP ; std::find<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@std@@@Z
_TEXT	SEGMENT
$T237010 = -4						; size = 1
__Cat$237014 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237010[esp+4], 0
	mov	eax, DWORD PTR $T237010[esp+4]
	mov	ecx, DWORD PTR __Cat$237014[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@std@@@Z
_TEXT	SEGMENT
$T237019 = -4						; size = 1
__Cat$237023 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237019[esp+4], 0
	mov	eax, DWORD PTR $T237019[esp+4]
	mov	ecx, DWORD PTR __Cat$237023[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@@Z ; std::_Destroy_range<std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@@Z PROC ; std::_Destroy_range<std::allocator<FreeResourceXCities> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@0AAV?$allocator@UFreeResourceXCities@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@@Z ; std::_Destroy_range<std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MayaBonusChoice> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@0AAV?$allocator@UMayaBonusChoice@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@4
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@4:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN18@Uninit_fil@4
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN18@Uninit_fil@4:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@4
	pop	esi
$LN4@Uninit_fil@4:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T237101 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$237104 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$237104[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237101[esp+4], 0
	mov	eax, DWORD PTR $T237101[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@U_Undefined_move_tag@3@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z
_TEXT	SEGMENT
$T237111 = -4						; size = 1
__Cat$237115 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237111[esp+4], 0
	mov	eax, DWORD PTR $T237111[esp+4]
	mov	ecx, DWORD PTR __Cat$237115[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z
_TEXT	SEGMENT
$T237120 = -4						; size = 1
__Cat$237124 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237120[esp+4], 0
	mov	eax, DWORD PTR $T237120[esp+4]
	mov	ecx, DWORD PTR __Cat$237124[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum TraitTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@0AAV?$allocator@W4TraitTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@3
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@3:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1985 : 		return (iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1986 : 		}

	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1996 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 1997 : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jbe	SHORT $LN20@end

; 1998 : 			_Tmp += _Mysize;

	push	ecx
	mov	ecx, esi
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@end:

; 1999 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2000 : 		}

	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2012 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 2013 : 		if (0 < _Mysize)

	cmp	DWORD PTR [ecx], 0
	jbe	SHORT $LN36@Make_iter

; 2014 : 			_Tmp += _Where - begin();

	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Where$[esp]
	sub	edx, ecx
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[esp+4]
	mov	ecx, esi
	push	edx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@Make_iter:

; 2015 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2016 : 		}

	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@4
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@4:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
PUBLIC	??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T237828 = -4						; size = 1
__Cat$237833 = 8					; size = 1
$T237830 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2587 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 2588 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2589 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$237833[esp]
	mov	edx, DWORD PTR $T237830[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T237828[esp+8], 0
	mov	eax, DWORD PTR $T237828[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2590 : 	}

	pop	ecx
	ret	0
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@@Z ; std::_Destroy_range<std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@0AAV?$allocator@V?$Array@H$05@Firaxis@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >,SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >,SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const > >, COMDAT

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));
; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	eax, DWORD PTR __Last$[esp-4]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	mov	ebp, eax

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, eax
	je	SHORT $LN1@for_each
	push	ebx
	push	edi
$LL6@for_each:

; 29   : 		_Func(*_ChkFirst);

	mov	ebx, DWORD PTR __Func$[esp+12]
	mov	edi, 6
	npad	5
$LL18@for_each:
	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL18@for_each

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, ebp
	jne	SHORT $LL6@for_each
	pop	edi
	pop	ebx
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	ebp

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >,SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z
_TEXT	SEGMENT
$T237910 = -4						; size = 1
__Cat$237914 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237910[esp+4], 0
	mov	eax, DWORD PTR $T237910[esp+4]
	mov	ecx, DWORD PTR __Cat$237914[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@5
	pop	esi
$LN9@Uninit_fil@5:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	esi
	push	edi
$LL2@Copy_backw@7:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	esi, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR __Last$[esp+8]
	cmp	DWORD PTR __First$[esp+4], esi
	jne	SHORT $LN9@Copy_backw@7
	cmp	DWORD PTR __First$[esp+8], ecx
	je	SHORT $LN61@Copy_backw@7
$LN9@Copy_backw@7:

; 2676 : 		*--_Dest = *--_Last;

	test	ecx, ecx
	je	SHORT $LN16@Copy_backw@7
	dec	ecx
	jmp	SHORT $LN62@Copy_backw@7
$LN16@Copy_backw@7:
	sub	esi, 4
	mov	DWORD PTR __Last$[esp+4], esi
	mov	ecx, 31					; 0000001fH
$LN62@Copy_backw@7:
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR __Last$[esp+8], ecx
	test	edx, edx
	je	SHORT $LN30@Copy_backw@7
	dec	edx
	jmp	SHORT $LN63@Copy_backw@7
$LN30@Copy_backw@7:
	sub	eax, 4
	mov	DWORD PTR __Dest$[esp+4], eax
	mov	edx, 31					; 0000001fH
$LN63@Copy_backw@7:
	mov	edi, 1
	shl	edi, cl
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	ecx, edx
	test	edi, DWORD PTR [esi]
	mov	esi, 1
	je	SHORT $LN48@Copy_backw@7
	shl	esi, cl
	or	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@7
$LN48@Copy_backw@7:
	shl	esi, cl
	not	esi
	and	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@7
$LN61@Copy_backw@7:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@7
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@7:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@6:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@6
	pop	esi
$LN9@Uninit_fil@6:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> >,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T238302 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$238305 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> >,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$238305[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238302[esp+4], 0
	mov	eax, DWORD PTR $T238302[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@U_Undefined_move_tag@4@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> >,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z ; CvTraitEntry::IsFreePromotionUnitCombat
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_promotionID$ = 8					; size = 4
_unitCombatID$ = 12					; size = 4
?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z PROC	; CvTraitEntry::IsFreePromotionUnitCombat, COMDAT
; _this$ = ecx

; 975  : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 976  : 	std::multimap<int, int>::const_iterator it = m_FreePromotionUnitCombats.find(promotionID);

	lea	eax, DWORD PTR _promotionID$[esp+8]
	push	eax
	lea	ecx, DWORD PTR _it$[esp+16]
	lea	esi, DWORD PTR [edi+688]
	push	ecx
	mov	ecx, esi
	call	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find

; 977  : 	if(it != m_FreePromotionUnitCombats.end())

	mov	edx, DWORD PTR _it$[esp+12]
	cmp	edx, DWORD PTR [edi+692]
	je	SHORT $LN2@IsFreeProm

; 978  : 	{
; 979  : 		// get an iterator to the element that is one past the last element associated with key
; 980  : 		std::multimap<int, int>::const_iterator lastElement = m_FreePromotionUnitCombats.upper_bound(promotionID);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	mov	esi, ecx
	jne	SHORT $LN20@IsFreeProm
	mov	ecx, DWORD PTR _promotionID$[esp+8]
	npad	6
$LL21@IsFreeProm:
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN19@IsFreeProm
	mov	esi, eax
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@IsFreeProm
$LN19@IsFreeProm:
	mov	eax, DWORD PTR [eax+8]
$LN18@IsFreeProm:
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL21@IsFreeProm
$LN20@IsFreeProm:

; 981  : 
; 982  : 		// for each element in the sequence [itr, lastElement)
; 983  : 		for(; it != lastElement; ++it)

	cmp	edx, esi
	je	SHORT $LN2@IsFreeProm
	mov	edi, DWORD PTR _unitCombatID$[esp+8]
	npad	4
$LL44@IsFreeProm:

; 984  : 		{
; 985  : 			if(it->second == unitCombatID)

	cmp	DWORD PTR [edx+16], edi
	je	SHORT $LN58@IsFreeProm
	lea	ecx, DWORD PTR _it$[esp+12]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
	mov	edx, DWORD PTR _it$[esp+12]
	cmp	edx, esi
	jne	SHORT $LL44@IsFreeProm
$LN2@IsFreeProm:
	pop	edi

; 988  : 			}
; 989  : 		}
; 990  : 	}
; 991  : 
; 992  : 	return false;

	xor	al, al
	pop	esi

; 993  : }

	pop	ecx
	ret	8
$LN58@IsFreeProm:
	pop	edi

; 986  : 			{
; 987  : 				return true;

	mov	al, 1
	pop	esi

; 993  : }

	pop	ecx
	ret	8
?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z ENDP	; CvTraitEntry::IsFreePromotionUnitCombat
_TEXT	ENDS
PUBLIC	?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z ; CvPlayerTraits::WillGetUniqueLuxury
EXTRN	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvResourceInfo::GetRequiredCivilization
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?GetOriginalCapitalX@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetOriginalCapitalX
EXTRN	?GetOriginalCapitalY@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetOriginalCapitalY
EXTRN	?GetNumCitiesFounded@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumCitiesFounded
; Function compile flags: /Ogtpy
;	COMDAT ?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z
_TEXT	SEGMENT
_iArea$223179 = -8					; size = 4
_this$ = -4						; size = 4
tv392 = 8						; size = 4
$T238469 = 8						; size = 4
$T238460 = 8						; size = 4
_pArea$ = 8						; size = 4
?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z PROC ; CvPlayerTraits::WillGetUniqueLuxury, COMDAT
; _this$ = ecx

; 2166 : {

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, ecx

; 2167 : 	// Still have more of these cities to award?
; 2168 : 	if (m_iUniqueLuxuryCities > m_iUniqueLuxuryCitiesPlaced)

	mov	eax, DWORD PTR [ebp+292]
	cmp	eax, DWORD PTR [ebp+300]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+24], ebp
	jle	$LN3@WillGetUni

; 2169 : 	{
; 2170 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area BEGIN
; 2171 : 		if (m_pPlayer->GetNumCitiesFounded() == 0)

	mov	ecx, DWORD PTR [ebp+4]
	call	?GetNumCitiesFounded@CvPlayer@@QBEHXZ	; CvPlayer::GetNumCitiesFounded
	test	eax, eax

; 2172 : 		{
; 2173 : 			return false;

	je	$LN3@WillGetUni

; 2174 : 		}
; 2175 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area END
; 2176 : 
; 2177 : 		int iArea = pArea->GetID();
; 2178 : 
; 2179 : 		// If we have to be in a new area, check to see if this area is okay
; 2180 : 		if (m_bUniqueLuxuryRequiresNewArea)

	cmp	BYTE PTR [ebp+345], 0
	mov	ecx, DWORD PTR _pArea$[esp+20]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _iArea$223179[esp+24], edx
	je	$LN82@WillGetUni

; 2181 : 		{
; 2182 : 			/* NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area
; 2183 : 			// Can't be the capital itself
; 2184 : 			if (m_pPlayer->GetNumCitiesFounded() == 0)
; 2185 : 			{
; 2186 : 				return false;
; 2187 : 			}
; 2188 : 			*/
; 2189 : 
; 2190 : 			CvPlot *pOriginalCapitalPlot = GC.getMap().plot(m_pPlayer->GetOriginalCapitalX(), m_pPlayer->GetOriginalCapitalY());

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T238469[esp+20], edi
	call	?GetOriginalCapitalY@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalY
	mov	ecx, DWORD PTR [ebp+4]
	mov	ebx, eax
	call	?GetOriginalCapitalX@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalX
	cmp	eax, -2147483647			; 80000001H
	je	$LN81@WillGetUni
	cmp	ebx, -2147483647			; 80000001H
	je	$LN81@WillGetUni
	cmp	BYTE PTR [edi+4056], 0
	mov	ecx, DWORD PTR [edi+4020]
	je	SHORT $LN80@WillGetUni
	test	eax, eax
	jge	SHORT $LN30@WillGetUni
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN32@WillGetUni
$LN30@WillGetUni:
	cmp	eax, ecx
	jl	SHORT $LN80@WillGetUni
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN32@WillGetUni
$LN80@WillGetUni:
	mov	esi, eax
$LN32@WillGetUni:
	mov	eax, DWORD PTR $T238469[esp+20]
	cmp	BYTE PTR [eax+4057], 0
	mov	edi, DWORD PTR [edi+4024]
	je	SHORT $LN85@WillGetUni
	test	ebx, ebx
	jge	SHORT $LN40@WillGetUni
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN42@WillGetUni
$LN40@WillGetUni:
	cmp	ebx, edi
	jl	SHORT $LN85@WillGetUni
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN42@WillGetUni
$LN85@WillGetUni:
	mov	edx, ebx
$LN42@WillGetUni:
	test	esi, esi
	jl	SHORT $LN81@WillGetUni
	cmp	esi, ecx
	jge	SHORT $LN81@WillGetUni
	test	edx, edx
	jl	SHORT $LN81@WillGetUni
	cmp	edx, edi
	jge	SHORT $LN81@WillGetUni
	imul	ecx, edx
	mov	edx, DWORD PTR $T238469[esp+20]
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]

; 2191 : 			if (pOriginalCapitalPlot)

	test	ecx, ecx
	je	SHORT $LN81@WillGetUni

; 2192 : 			{
; 2193 : 				if (pOriginalCapitalPlot->getArea() == iArea)

	mov	eax, DWORD PTR _iArea$223179[esp+24]
	cmp	DWORD PTR [ecx+356], eax

; 2194 : 				{
; 2195 : 					return false;

	je	$LN3@WillGetUni
$LN81@WillGetUni:

; 2196 : 				}
; 2197 : 			}
; 2198 : 
; 2199 : 			// Already in the list?
; 2200 : 			if (std::find (m_aUniqueLuxuryAreas.begin(), m_aUniqueLuxuryAreas.end(), iArea) != m_aUniqueLuxuryAreas.end())

	mov	esi, DWORD PTR [ebp+704]
	mov	eax, DWORD PTR [ebp+700]
	lea	ecx, DWORD PTR _iArea$223179[esp+24]
	push	ecx
	push	esi
	push	eax
	lea	edx, DWORD PTR $T238460[esp+32]
	push	edx
	call	??$find@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::find<std::_Vector_const_iterator<int,std::allocator<int> >,int>
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [eax], esi

; 2201 : 			{
; 2202 : 				return false;

	jne	SHORT $LN3@WillGetUni
$LN82@WillGetUni:

; 2203 : 			}
; 2204 : 		}
; 2205 : 
; 2206 : 		int iNumUniqueResourcesGiven = m_aUniqueLuxuryAreas.size();

	mov	esi, DWORD PTR [ebp+704]
	sub	esi, DWORD PTR [ebp+700]

; 2207 : 
; 2208 : 		// Loop through all resources and see if we can find one more
; 2209 : 		int iNumUniquesFound = 0;
; 2210 : #ifdef AUI_WARNING_FIXES
; 2211 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2212 : #else
; 2213 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	sar	esi, 2
	xor	ebp, ebp
	xor	edi, edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN3@WillGetUni
	npad	2
$LL84@WillGetUni:

; 2214 : #endif
; 2215 : 		{
; 2216 : 			ResourceTypes eResource = (ResourceTypes) iResourceLoop;
; 2217 : 			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ebx, eax

; 2218 : 			if (pkResource != NULL && pkResource->GetRequiredCivilization() == m_pPlayer->getCivilizationType())

	test	ebx, ebx
	je	SHORT $LN4@WillGetUni
	mov	eax, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [eax+4]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	mov	ecx, ebx
	mov	DWORD PTR tv392[esp+20], eax
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	mov	ecx, DWORD PTR tv392[esp+20]
	cmp	eax, ecx
	jne	SHORT $LN4@WillGetUni

; 2219 : 			{
; 2220 : 				iNumUniquesFound++;

	inc	ebp

; 2221 : 				if (iNumUniquesFound > iNumUniqueResourcesGiven)

	cmp	ebp, esi
	jg	SHORT $LN77@WillGetUni
$LN4@WillGetUni:

; 2207 : 
; 2208 : 		// Loop through all resources and see if we can find one more
; 2209 : 		int iNumUniquesFound = 0;
; 2210 : #ifdef AUI_WARNING_FIXES
; 2211 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2212 : #else
; 2213 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	SHORT $LL84@WillGetUni
$LN3@WillGetUni:
	pop	edi
	pop	esi
	pop	ebp

; 2224 : 				}
; 2225 : 			}
; 2226 : 		}
; 2227 : 	}
; 2228 : 
; 2229 : 	return false;

	xor	al, al
	pop	ebx

; 2230 : }

	add	esp, 8
	ret	4
$LN77@WillGetUni:
	pop	edi
	pop	esi
	pop	ebp

; 2222 : 				{
; 2223 : 					return true;

	mov	al, 1
	pop	ebx

; 2230 : }

	add	esp, 8
	ret	4
?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z ENDP ; CvPlayerTraits::WillGetUniqueLuxury
_TEXT	ENDS
PUBLIC	?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z ; CvPlayerTraits::HasFreePromotionUnitCombat
; Function compile flags: /Ogtpy
;	COMDAT ?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_promotionID$ = 8					; size = 4
_unitCombatID$ = 12					; size = 4
?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z PROC ; CvPlayerTraits::HasFreePromotionUnitCombat, COMDAT
; _this$ = ecx

; 2302 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+16], ecx
	push	edi

; 2303 : 	CvAssertMsg((promotionID >= 0), "promotionID is less than zero");
; 2304 : #ifdef AUI_WARNING_FIXES
; 2305 : 	for (uint iI = 0; iI < GC.getNumTraitInfos(); iI++)
; 2306 : #else
; 2307 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	test	eax, eax
	jle	SHORT $LN4@HasFreePro
	mov	ebx, DWORD PTR _unitCombatID$[esp+16]
	mov	ebp, DWORD PTR _promotionID$[esp+16]
$LL12@HasFreePro:

; 2308 : #endif
; 2309 : 	{
; 2310 : 		const TraitTypes eTrait = static_cast<TraitTypes>(iI);
; 2311 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(eTrait);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	edi, eax

; 2312 : 		if(pkTraitInfo)

	test	edi, edi
	je	SHORT $LN5@HasFreePro

; 2313 : 		{
; 2314 : 			if(HasTrait(eTrait))

	mov	ecx, DWORD PTR _this$[esp+20]
	push	esi
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	test	al, al
	je	SHORT $LN5@HasFreePro

; 2315 : 			{
; 2316 : 				if(pkTraitInfo->IsFreePromotionUnitCombat(promotionID, unitCombatID))

	push	ebx
	push	ebp
	mov	ecx, edi
	call	?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z ; CvTraitEntry::IsFreePromotionUnitCombat
	test	al, al
	jne	SHORT $LN10@HasFreePro
$LN5@HasFreePro:

; 2303 : 	CvAssertMsg((promotionID >= 0), "promotionID is less than zero");
; 2304 : #ifdef AUI_WARNING_FIXES
; 2305 : 	for (uint iI = 0; iI < GC.getNumTraitInfos(); iI++)
; 2306 : #else
; 2307 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	esi, eax
	jl	SHORT $LL12@HasFreePro
$LN4@HasFreePro:
	pop	edi
	pop	esi
	pop	ebp

; 2319 : 				}
; 2320 : 			}
; 2321 : 		}
; 2322 : 	}
; 2323 : 
; 2324 : 	return false;

	xor	al, al
	pop	ebx

; 2325 : }

	pop	ecx
	ret	8
$LN10@HasFreePro:
	pop	edi
	pop	esi
	pop	ebp

; 2317 : 				{
; 2318 : 					return true;

	mov	al, 1
	pop	ebx

; 2325 : }

	pop	ecx
	ret	8
?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z ENDP ; CvPlayerTraits::HasFreePromotionUnitCombat
_TEXT	ENDS
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__Tmp$238695 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2090 : 		{	// subscript mutable sequence

	sub	esp, 8

; 2091 : 		return (*(begin() + _Off));

	mov	ecx, DWORD PTR [ecx+8]
	xor	eax, eax
	mov	DWORD PTR __Tmp$238695[esp+12], eax
	mov	eax, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$238695[esp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$238695[esp+12]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$238695[esp+8]
	mov	edx, DWORD PTR __Tmp$238695[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 2092 : 		}

	add	esp, 8
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::clear
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@2:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@2:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::clear
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T239053 = 12						; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	push	ebp
	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	mov	esi, edx
	mov	BYTE PTR __Addleft$[esp+12], 1
	jne	SHORT $LN9@insert
	push	edi
	mov	edi, DWORD PTR [ebp]
	npad	2
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edi, DWORD PTR [eax+12]
	mov	esi, eax
	setl	dl
	mov	BYTE PTR __Addleft$[esp+16], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	dl, dl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL10@insert
	pop	edi
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	eax, DWORD PTR __Addleft$[esp+12]
	push	ebp
	push	esi
	push	eax
	lea	edx, DWORD PTR $T239053[esp+20]
	push	edx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 647  : 			if (!_Addleft)
; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())
; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));
; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay
; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,
; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));
; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	ebx, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	push	edi
	push	eax
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR [ebx+8]

; 1065 : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN2@Copy@2

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN25@Copy@2
$LL26@Copy@2:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+21], 0
	je	SHORT $LL26@Copy@2
$LN25@Copy@2:
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN43@Copy@2
$LL44@Copy@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL44@Copy@2
$LN43@Copy@2:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
$LN2@Copy@2:

; 1069 : 			}
; 1070 : 		else
; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU3@IABU3@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Ufill
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Ufill@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T239411 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$239414 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU3@IABU3@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$239414[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T239411[esp+12], 0
	mov	eax, DWORD PTR $T239411[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU3@IABU3@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW43@IABW43@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T239429 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$239432 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$239432[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T239429[esp+12], 0
	mov	eax, DWORD PTR $T239429[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T239441 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@5
	cmp	edx, eax
	jne	SHORT $LN101@erase@5

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@5:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@5
	npad	2
$LL2@erase@5:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+21], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@5
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN103@erase@5
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN79@erase@5
	npad	5
$LL80@erase@5:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL80@erase@5
$LN79@erase@5:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@5
$LN103@erase@5:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN63@erase@5
	npad	7
$LL64@erase@5:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@5
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+21], 0
	je	SHORT $LL64@erase@5
$LN63@erase@5:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@5:
	push	edx
	lea	eax, DWORD PTR $T239441[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@5
$LN1@erase@5:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXPAUFreeResourceXCities@@0@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXPAUFreeResourceXCities@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXPAUFreeResourceXCities@@0@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXPAUFreeResourceXCities@@0@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXPAUMayaBonusChoice@@0@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXPAUMayaBonusChoice@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXPAUMayaBonusChoice@@0@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXPAUMayaBonusChoice@@0@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@std@@@Z
_TEXT	SEGMENT
$T239766 = -4						; size = 1
__Cat$239771 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239766[esp+4], 0
	mov	eax, DWORD PTR $T239766[esp+4]
	mov	ecx, DWORD PTR __Cat$239771[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z
_TEXT	SEGMENT
$T239800 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239804 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$239804[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239800[esp+4], 0
	mov	eax, DWORD PTR $T239800[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239820 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239823 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$239823[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239820[esp+4], 0
	mov	eax, DWORD PTR $T239820[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239839 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239843 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$239843[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239839[esp+4], 0
	mov	eax, DWORD PTR $T239839[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@U_Undefined_move_tag@3@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXPAW4TraitTypes@@0@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXPAW4TraitTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXPAW4TraitTypes@@0@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXPAW4TraitTypes@@0@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@3
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@3
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@3:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@3:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
; Function compile flags: /Ogtpy
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T240044 = 8						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 2360 : 		{	// trim base vector to exact length in bits

	push	ebx

; 2361 : 		if (max_size() < _Size)

	mov	ebx, DWORD PTR __Size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, -1
	jbe	SHORT $LN3@Trim

; 2362 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN42@Trim:
$LN3@Trim:

; 2363 : 		size_type _Words = _Nw(_Size);
; 2364 : 
; 2365 : 		if (_Words < _Myvec.size())

	mov	eax, DWORD PTR [edi+12]
	sub	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+4]
	push	esi
	lea	esi, DWORD PTR [ebx+31]
	shr	esi, 5
	sar	eax, 2
	cmp	esi, eax
	jae	SHORT $LN2@Trim

; 2366 : 			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());

	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	push	eax
	lea	edx, DWORD PTR [edx+esi*4]
	push	edx
	lea	eax, DWORD PTR $T240044[esp+16]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN2@Trim:

; 2367 : 		_Mysize = _Size;

	mov	DWORD PTR [edi], ebx

; 2368 : 		_Size %= _VBITS;

	and	ebx, 31					; 0000001fH

; 2369 : 		if (0 < _Size)

	jbe	SHORT $LN40@Trim

; 2370 : 			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);

	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ecx+esi*4-4]
	mov	edx, 1
	mov	ecx, ebx
	shl	edx, cl
	dec	edx
	and	DWORD PTR [eax], edx
$LN40@Trim:
	pop	esi
	pop	edi
	pop	ebx

; 2371 : 		}

	ret	4
$LN41@Trim:
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXPAV?$Array@H$05@Firaxis@@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXPAV?$Array@H$05@Firaxis@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXPAV?$Array@H$05@Firaxis@@0@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXPAV?$Array@H$05@Firaxis@@0@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Destroy
_TEXT	ENDS
PUBLIC	??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator<<<Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z
_TEXT	SEGMENT
$T240146 = -8						; size = 8
$T240158 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z PROC ; operator<<<Firaxis::Array<int,6> >, COMDAT

; 198  : {

	sub	esp, 8
	push	esi

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	esi, DWORD PTR _readFrom$[esp+8]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+12]
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T240158[esp+12]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T240158[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	esi
	push	edi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T240146[esp+32]
	push	edx
	call	??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >,SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const > >
	add	esp, 20					; 00000014H

; 200  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi

; 201  : }

	add	esp, 8
	ret	0
??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ENDP ; operator<<<Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV34@IABV34@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Ufill
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Ufill@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV34@IABV34@@Z
_TEXT	SEGMENT
$T240193 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$240196 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV34@IABV34@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$240196[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T240193[esp+12], 0
	mov	eax, DWORD PTR $T240193[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV34@IABV34@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@11
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@11:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@11
	pop	esi
$LN13@unchecked_@11:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T240358 = -4						; size = 1
__Cat$240363 = 8					; size = 1
$T240360 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2740 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 2741 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2742 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Cat$240363[esp]
	mov	edx, DWORD PTR $T240360[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T240358[esp+8], 0
	mov	eax, DWORD PTR $T240358[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2743 : 	}

	pop	ecx
	ret	0
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@12
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@12:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@12
	pop	esi
$LN13@unchecked_@12:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z
_TEXT	SEGMENT
$T240555 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240558 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240558[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240555[esp+4], 0
	mov	eax, DWORD PTR $T240555[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z ; CvTraitEntry::NoTrain
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
__Tmp$240668 = -8					; size = 8
_eUnitClass$ = 8					; size = 4
?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z PROC	; CvTraitEntry::NoTrain, COMDAT
; _this$ = ecx

; 1027 : 	if (eUnitClass != NO_UNITCLASS)

	mov	edx, DWORD PTR _eUnitClass$[esp-4]
	sub	esp, 8
	cmp	edx, -1
	je	SHORT $LN2@NoTrain

; 1028 : 	{
; 1029 : 		return m_abNoTrainUnitClass[eUnitClass];

	mov	eax, DWORD PTR [ecx+724]
	xor	ecx, ecx
	mov	DWORD PTR __Tmp$240668[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$240668[esp+12]
	mov	DWORD PTR __Tmp$240668[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$240668[esp+12]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR __Tmp$240668[esp+8]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1034 : 	}
; 1035 : }

	add	esp, 8
	ret	4
$LN2@NoTrain:

; 1030 : 	}
; 1031 : 	else
; 1032 : 	{
; 1033 : 		return false;

	xor	al, al

; 1034 : 	}
; 1035 : }

	add	esp, 8
	ret	4
?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z ENDP	; CvTraitEntry::NoTrain
_TEXT	ENDS
PUBLIC	??0CvTraitXMLEntries@@QAE@XZ			; CvTraitXMLEntries::CvTraitXMLEntries
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTraitXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvTraitXMLEntries@@QAE@XZ PROC			; CvTraitXMLEntries::CvTraitXMLEntries, COMDAT
; _this$ = ecx

; 1498 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 1499 : 
; 1500 : }

	ret	0
??0CvTraitXMLEntries@@QAE@XZ ENDP			; CvTraitXMLEntries::CvTraitXMLEntries
_TEXT	ENDS
PUBLIC	?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z ; CvPlayerTraits::NoTrain
; Function compile flags: /Ogtpy
;	COMDAT ?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
__Tmp$240930 = -8					; size = 8
_eUnitClassType$ = 8					; size = 4
?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z PROC	; CvPlayerTraits::NoTrain, COMDAT
; _this$ = ecx

; 2601 : 	if (eUnitClassType != NO_UNITCLASS)

	mov	edx, DWORD PTR _eUnitClassType$[esp-4]
	sub	esp, 8
	cmp	edx, -1
	je	SHORT $LN2@NoTrain@2

; 2602 : 	{
; 2603 : 		return m_abNoTrain[eUnitClassType];

	mov	eax, DWORD PTR [ecx+628]
	xor	ecx, ecx
	mov	DWORD PTR __Tmp$240930[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$240930[esp+12]
	mov	DWORD PTR __Tmp$240930[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$240930[esp+12]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR __Tmp$240930[esp+8]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 2608 : 	}
; 2609 : }

	add	esp, 8
	ret	4
$LN2@NoTrain@2:

; 2604 : 	}
; 2605 : 	else
; 2606 : 	{
; 2607 : 		return false;

	xor	al, al

; 2608 : 	}
; 2609 : }

	add	esp, 8
	ret	4
?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z ENDP	; CvPlayerTraits::NoTrain
_TEXT	ENDS
PUBLIC	?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z	; CvPlayerTraits::Write
EXTRN	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumUnitCombatClassInfos
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z:PROC ; operator<<
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iNumUnitCombatClassInfos$ = -16			; size = 4
_uiVersion$ = -12					; size = 4
$T241927 = -8						; size = 8
$T241866 = -8						; size = 8
$T241805 = -8						; size = 8
$T241929 = 8						; size = 4
$T241868 = 8						; size = 4
$T241807 = 8						; size = 4
$T241720 = 8						; size = 1
$T240972 = 8						; size = 4
$T240971 = 8						; size = 4
$T240969 = 8						; size = 4
$T240957 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTraits::Write, COMDAT
; _this$ = ecx

; 3383 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 3384 : 	// Current version number
; 3385 : 	uint uiVersion = 19;
; 3386 : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+20]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+32], 19	; 00000013H
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3387 : 
; 3388 : 	kStream << m_iGreatPeopleRateModifier;

	lea	ecx, DWORD PTR [edi+44]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3389 : 	kStream << m_iGreatScientistRateModifier;

	lea	edx, DWORD PTR [edi+48]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3390 : 	kStream << m_iGreatGeneralRateModifier;

	lea	eax, DWORD PTR [edi+52]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3391 : 	kStream << m_iGreatGeneralExtraBonus;

	lea	ecx, DWORD PTR [edi+56]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3392 : 	kStream << m_iGreatPersonGiftInfluence;

	lea	edx, DWORD PTR [edi+60]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3393 : 	kStream << m_iLevelExperienceModifier;

	lea	eax, DWORD PTR [edi+64]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3394 : 	kStream << m_iMaxGlobalBuildingProductionModifier;

	lea	ecx, DWORD PTR [edi+68]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3395 : 	kStream << m_iMaxTeamBuildingProductionModifier;

	lea	edx, DWORD PTR [edi+72]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3396 : 	kStream << m_iMaxPlayerBuildingProductionModifier;

	lea	eax, DWORD PTR [edi+76]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3397 : 	kStream << m_iCityUnhappinessModifier;

	lea	ecx, DWORD PTR [edi+80]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3398 : 	kStream << m_iPopulationUnhappinessModifier;

	lea	edx, DWORD PTR [edi+84]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3399 : 	kStream << m_iCityStateBonusModifier;

	lea	eax, DWORD PTR [edi+88]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3400 : 	kStream << m_iCityStateFriendshipModifier;

	lea	ecx, DWORD PTR [edi+92]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3401 : 	kStream << m_iCityStateCombatModifier;

	lea	edx, DWORD PTR [edi+96]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3402 : 	kStream << m_iLandBarbarianConversionPercent;

	lea	eax, DWORD PTR [edi+100]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3403 : 	kStream << m_iLandBarbarianConversionExtraUnits;

	lea	ecx, DWORD PTR [edi+104]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3404 : 	kStream << m_iSeaBarbarianConversionPercent;

	lea	edx, DWORD PTR [edi+108]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3405 : 	kStream << m_iCapitalBuildingModifier;

	lea	eax, DWORD PTR [edi+112]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3406 : 	kStream << m_iPlotBuyCostModifier;

	lea	ecx, DWORD PTR [edi+116]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3407 : 	kStream << m_iPlotCultureCostModifier;

	lea	edx, DWORD PTR [edi+120]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3408 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 3409 : 	kStream << m_iSciencePerGreatPersonBorn;

	lea	eax, DWORD PTR [edi+124]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3410 : #endif
; 3411 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 3412 : 	kStream << m_iNumTurnsBeforeMinorAlliesRefuseBribes;

	lea	ecx, DWORD PTR [edi+128]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3413 : #endif
; 3414 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 3415 : 	kStream << m_iGoldenAgeTileBonusFaith;

	lea	edx, DWORD PTR [edi+132]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3416 : #endif
; 3417 : 	kStream << m_iCultureFromKills;

	lea	eax, DWORD PTR [edi+136]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3418 : 	kStream << m_iFaithFromKills;

	lea	ecx, DWORD PTR [edi+140]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3419 : 	kStream << m_iCityCultureBonus;

	lea	edx, DWORD PTR [edi+144]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3420 : 	kStream << m_iCapitalThemingBonusModifier;

	lea	eax, DWORD PTR [edi+148]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3421 : 	kStream << m_iPolicyCostModifier;

	lea	ecx, DWORD PTR [edi+152]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3422 : 	kStream << m_iCityConnectionTradeRouteChange;

	lea	edx, DWORD PTR [edi+156]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3423 : 	kStream << m_iWonderProductionModifier;

	lea	eax, DWORD PTR [edi+160]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3424 : 	kStream << m_iPlunderModifier;

	lea	ecx, DWORD PTR [edi+164]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3425 : 	kStream << m_iImprovementMaintenanceModifier;

	lea	edx, DWORD PTR [edi+168]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3426 : 	kStream << m_iGoldenAgeDurationModifier;

	lea	eax, DWORD PTR [edi+172]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3427 : 	kStream << m_iGoldenAgeMoveChange;

	lea	ecx, DWORD PTR [edi+176]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3428 : 	kStream << m_iGoldenAgeCombatModifier;

	lea	edx, DWORD PTR [edi+180]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3429 : 	kStream << m_iGoldenAgeTourismModifier;

	lea	eax, DWORD PTR [edi+184]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3430 : 	kStream << m_iGoldenAgeGreatArtistRateModifier;

	lea	ecx, DWORD PTR [edi+188]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3431 : 	kStream << m_iGoldenAgeGreatMusicianRateModifier;

	lea	edx, DWORD PTR [edi+192]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3432 : 	kStream << m_iGoldenAgeGreatWriterRateModifier;

	lea	eax, DWORD PTR [edi+196]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3433 : 	kStream << m_iExtraEmbarkMoves;

	lea	ecx, DWORD PTR [edi+200]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3434 : 	kStream << m_iNaturalWonderFirstFinderGold;

	lea	edx, DWORD PTR [edi+204]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3435 : 	kStream << m_iNaturalWonderSubsequentFinderGold;

	lea	eax, DWORD PTR [edi+208]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3436 : 	kStream << m_iNaturalWonderYieldModifier;

	lea	ecx, DWORD PTR [edi+212]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3437 : 	kStream << m_iNaturalWonderHappinessModifier;

	lea	edx, DWORD PTR [edi+216]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3438 : 	kStream << m_iNearbyImprovementCombatBonus;

	lea	eax, DWORD PTR [edi+220]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3439 : 	kStream << m_iNearbyImprovementBonusRange;

	lea	ecx, DWORD PTR [edi+224]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3440 : 	kStream << m_iCultureBuildingYieldChange;

	lea	edx, DWORD PTR [edi+228]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3441 : 	kStream << m_iCombatBonusVsHigherTech;

	lea	eax, DWORD PTR [edi+232]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3442 : 	kStream << m_iCombatBonusVsLargerCiv;

	lea	ecx, DWORD PTR [edi+236]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3443 : 	kStream << m_iLandUnitMaintenanceModifier;

	lea	edx, DWORD PTR [edi+240]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3444 : 	kStream << m_iNavalUnitMaintenanceModifier;

	lea	eax, DWORD PTR [edi+244]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3445 : 	kStream << m_iRazeSpeedModifier;

	lea	ecx, DWORD PTR [edi+248]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3446 : 	kStream << m_iDOFGreatPersonModifier;

	lea	edx, DWORD PTR [edi+252]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3447 : 	kStream << m_iLuxuryHappinessRetention;

	lea	eax, DWORD PTR [edi+256]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3448 : 	kStream << m_iExtraHappinessPerLuxury; // NQMP GJS - New Netherlands UA

	lea	ecx, DWORD PTR [edi+260]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3449 : 	kStream << m_iExtraSpies;

	lea	edx, DWORD PTR [edi+264]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3450 : 	kStream << m_iHappinessPerReligion; // NQMP GJS - New Ottoman UA

	lea	eax, DWORD PTR [edi+268]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3451 : 	kStream << m_iUnresearchedTechBonusFromKills;

	lea	ecx, DWORD PTR [edi+272]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3452 : 	kStream << m_iExtraFoundedCityTerritoryClaimRange;

	lea	edx, DWORD PTR [edi+276]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3453 : 	kStream << m_iFreeSocialPoliciesPerEra;

	lea	eax, DWORD PTR [edi+280]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3454 : 	kStream << m_iNumTradeRoutesModifier;

	lea	ecx, DWORD PTR [edi+284]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3455 : 	kStream << m_iTradeRouteResourceModifier;

	lea	edx, DWORD PTR [edi+288]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3456 : 	kStream << m_iUniqueLuxuryCities;

	lea	eax, DWORD PTR [edi+292]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3457 : 	kStream << m_iUniqueLuxuryQuantity;

	lea	ecx, DWORD PTR [edi+296]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3458 : 	kStream << m_iUniqueLuxuryCitiesPlaced;

	lea	edx, DWORD PTR [edi+300]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3459 : 	kStream << m_iWorkerSpeedModifier;

	lea	eax, DWORD PTR [edi+304]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3460 : 	kStream << m_iAfraidMinorPerTurnInfluence;

	lea	ecx, DWORD PTR [edi+308]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3461 : 	kStream << m_iLandTradeRouteRangeBonus;

	lea	edx, DWORD PTR [edi+312]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3462 : 	kStream << m_iTradeReligionModifier;

	lea	eax, DWORD PTR [edi+316]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3463 : 	kStream << m_iTradeBuildingModifier;

	lea	ecx, DWORD PTR [edi+320]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3464 : 
; 3465 : 	kStream << m_bFightWellDamaged;

	lea	edx, DWORD PTR [edi+324]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3466 : 	kStream << m_bMoveFriendlyWoodsAsRoad;

	lea	eax, DWORD PTR [edi+325]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3467 : 	kStream << m_bFasterAlongRiver;

	lea	ecx, DWORD PTR [edi+326]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3468 : 	kStream << m_bFasterInHills;

	lea	edx, DWORD PTR [edi+327]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3469 : 	kStream << m_bEmbarkedAllWater;

	lea	eax, DWORD PTR [edi+328]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3470 : 	kStream << m_bEmbarkedToLandFlatCost;

	lea	ecx, DWORD PTR [edi+329]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3471 : 	kStream << m_bNoHillsImprovementMaintenance;

	lea	edx, DWORD PTR [edi+330]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3472 : 	kStream << m_bTechBoostFromCapitalScienceBuildings;

	lea	eax, DWORD PTR [edi+331]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3473 : 	kStream << m_bStaysAliveZeroCities;

	lea	ecx, DWORD PTR [edi+332]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3474 : 	kStream << m_bFaithFromUnimprovedForest;

	lea	edx, DWORD PTR [edi+333]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3475 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 3476 : 	kStream << m_bSeaTradeRoutesArePlunderImmune;

	lea	eax, DWORD PTR [edi+334]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3477 : #endif
; 3478 : 
; 3479 : 	// NQMP GJS - New France UA begin
; 3480 : 	kStream << m_bEarnsGreatPersonOnSlotOrGuild;

	lea	ecx, DWORD PTR [edi+335]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3481 : 	kStream << m_bHasBuiltWritersGuild;

	lea	edx, DWORD PTR [edi+336]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3482 : 	kStream << m_bHasBuiltArtistsGuild;

	lea	eax, DWORD PTR [edi+337]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3483 : 	kStream << m_bHasBuiltMusiciansGuild;

	lea	ecx, DWORD PTR [edi+338]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3484 : 	// NQMP GJS - New France UA end
; 3485 : 
; 3486 : 	kStream << m_bBonusReligiousBelief;

	lea	edx, DWORD PTR [edi+339]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3487 : 	kStream << m_bAbleToAnnexCityStates;

	lea	eax, DWORD PTR [edi+340]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3488 : 	kStream << m_bCrossesMountainsAfterGreatGeneral;

	lea	ecx, DWORD PTR [edi+341]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3489 : 	kStream << m_bMayaCalendarBonuses;

	lea	edx, DWORD PTR [edi+342]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3490 : 
; 3491 : 	kStream << m_iBaktunPreviousTurn;

	lea	eax, DWORD PTR [edi+712]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3492 : 
; 3493 : 	std::vector<MayaBonusChoice>::const_iterator it;
; 3494 : 	kStream << m_aMayaBonusChoices.size();

	mov	ecx, DWORD PTR [edi+744]
	sub	ecx, DWORD PTR [edi+740]
	lea	edx, DWORD PTR $T240957[esp+24]
	sar	ecx, 3
	mov	DWORD PTR $T240957[esp+24], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3495 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3496 : 	for (it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); ++it)
; 3497 : #else
; 3498 : 	for(it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); it++)

	mov	ebx, DWORD PTR [edi+740]
	cmp	ebx, DWORD PTR [edi+744]
	je	SHORT $LN16@Write
	npad	6
$LL217@Write:

; 3499 : #endif
; 3500 : 	{
; 3501 : 		kStream << it->m_eUnitType;

	push	ebx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<
	add	esp, 8
	lea	eax, DWORD PTR [ebx+4]

; 3502 : 		kStream << it->m_iBaktunJustFinished;

	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 8
	cmp	ebx, DWORD PTR [edi+744]
	jne	SHORT $LL217@Write
$LN16@Write:
	push	ebp

; 3503 : 	}
; 3504 : 
; 3505 : 	kStream << m_bNoAnnexing;

	lea	ecx, DWORD PTR [edi+343]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3506 : 	kStream << m_bTechFromCityConquer;

	lea	edx, DWORD PTR [edi+344]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3507 : 	kStream << m_bUniqueLuxuryRequiresNewArea;

	lea	eax, DWORD PTR [edi+345]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3508 : 	kStream << m_bRiverTradeRoad;

	lea	ecx, DWORD PTR [edi+346]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3509 : 	kStream << m_bAngerFreeIntrusionOfCityStates;

	lea	edx, DWORD PTR [edi+347]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3510 : 
; 3511 : 	kStream << m_eCampGuardType;

	lea	eax, DWORD PTR [edi+348]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<

; 3512 : 	kStream << m_eCombatBonusImprovement;

	lea	ecx, DWORD PTR [edi+360]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z ; operator<<
	add	esp, 16					; 00000010H

; 3513 : 
; 3514 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iExtraYieldThreshold);

	lea	ebx, DWORD PTR [edi+376]
	mov	ebp, 6
	npad	1
$LL253@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL253@Write

; 3515 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iFreeCityYield);

	lea	ebx, DWORD PTR [edi+400]
	mov	ebp, 6
	npad	5
$LL266@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL266@Write

; 3516 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeStrategicResources);

	lea	ebx, DWORD PTR [edi+424]
	mov	ebp, 6
	npad	5
$LL279@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL279@Write

; 3517 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeLuxuryResources); // NQMP GJS - New Netherlands UA

	lea	ebx, DWORD PTR [edi+448]
	mov	ebp, 6
	npad	5
$LL292@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL292@Write

; 3518 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldRateModifier);

	lea	ebx, DWORD PTR [edi+544]
	mov	ebp, 6
	npad	5
$LL305@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL305@Write

; 3519 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeNaturalWonder);

	lea	ebx, DWORD PTR [edi+472]
	mov	ebp, 6
	npad	5
$LL318@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL318@Write

; 3520 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangePerTradePartner);

	lea	ebx, DWORD PTR [edi+496]
	mov	ebp, 6
	npad	5
$LL331@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL331@Write

; 3521 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeIncomingTradeRoute);

	lea	ebx, DWORD PTR [edi+520]
	mov	ebp, 6
	npad	5
$LL344@Write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL344@Write

; 3522 : 	
; 3523 : 	CvInfosSerializationHelper::WriteHashedDataArray<TerrainTypes>(kStream, &m_iStrategicResourceQuantityModifier[0], GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	push	eax
	lea	edx, DWORD PTR [edi+568]
	push	edx
	push	esi
	call	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>

; 3524 : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_aiResourceQuantityModifier);

	lea	eax, DWORD PTR [edi+604]
	push	eax
	push	esi
	call	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>

; 3525 : 
; 3526 : 	kStream << m_abNoTrain.size();

	mov	ecx, DWORD PTR [edi+620]
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR $T240969[esp+28]
	mov	DWORD PTR $T240969[esp+28], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3527 : 	for (uint ui = 0; ui < m_abNoTrain.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+620], ebx
	jbe	SHORT $LN13@Write
	npad	8
$LL506@Write:

; 3528 : 	{
; 3529 : 		kStream << m_abNoTrain[ui];

	mov	eax, DWORD PTR [edi+628]
	mov	ecx, ebp
	test	ebx, ebx
	je	SHORT $LN379@Write
	jge	SHORT $LN380@Write
	mov	ecx, ebx
	neg	ecx
	je	SHORT $LN380@Write
	or	edx, -1
	sub	edx, ebx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ecx, -4					; fffffffcH
	sub	ecx, edx
	add	eax, ecx
	jmp	SHORT $LN507@Write
$LN380@Write:
	mov	edx, ebx
	shr	edx, 5
	lea	eax, DWORD PTR [eax+edx*4]
$LN507@Write:
	mov	ecx, ebx
	and	ecx, 31					; 0000001fH
$LN379@Write:
	mov	edx, 1
	shl	edx, cl
	lea	ecx, DWORD PTR $T241720[esp+28]
	push	ecx
	mov	ecx, esi
	test	edx, DWORD PTR [eax]
	setne	al
	mov	BYTE PTR $T241720[esp+32], al
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [edi+620]
	jb	SHORT $LL506@Write
$LN13@Write:

; 3530 : 	}
; 3531 : 
; 3532 : 	kStream << m_aFreeTraitUnits.size();

	mov	edx, DWORD PTR [edi+644]
	lea	eax, DWORD PTR $T240971[esp+28]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T240971[esp+32], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3533 : 	for(uint ui = 0; ui < m_aFreeTraitUnits.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+644], ebx
	jbe	SHORT $LN10@Write
	npad	3
$LL12@Write:
	mov	ecx, DWORD PTR [edi+640]
	lea	ebp, DWORD PTR [ebx*8]
	add	ecx, ebp

; 3534 : 	{
; 3535 : 		kStream << m_aFreeTraitUnits[ui].m_iFreeUnit;

	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<

; 3536 : 		kStream << m_aFreeTraitUnits[ui].m_ePrereqTech;

	mov	edx, DWORD PTR [edi+640]
	lea	eax, DWORD PTR [edx+ebp+4]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z ; operator<<
	inc	ebx
	add	esp, 16					; 00000010H
	cmp	ebx, DWORD PTR [edi+644]
	jb	SHORT $LL12@Write
$LN10@Write:

; 3537 : 	}
; 3538 : 
; 3539 : 	int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos

; 3540 : 	kStream << 	iNumUnitCombatClassInfos;

	lea	ecx, DWORD PTR _iNumUnitCombatClassInfos$[esp+32]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _iNumUnitCombatClassInfos$[esp+36], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3541 : 	for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	mov	eax, DWORD PTR _iNumUnitCombatClassInfos$[esp+32]
	xor	ebx, ebx
	pop	ebp
	test	eax, eax
	jle	SHORT $LN7@Write
	npad	8
$LL9@Write:
	mov	edx, DWORD PTR [edi+756]
	lea	eax, DWORD PTR [edx+ebx*4]

; 3542 : 	{
; 3543 : 		kStream << m_paiMovesChangeUnitCombat[iI];

	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR _iNumUnitCombatClassInfos$[esp+28]
	inc	ebx
	cmp	ebx, eax
	jl	SHORT $LL9@Write
$LN7@Write:

; 3544 : 	}
; 3545 : 	for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN4@Write
$LL6@Write:
	mov	ecx, DWORD PTR [edi+772]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 3546 : 	{
; 3547 : 		kStream << m_paiMaintenanceModifierUnitCombat[iI];

	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR _iNumUnitCombatClassInfos$[esp+28]
	jl	SHORT $LL6@Write
$LN4@Write:

; 3548 : 	}
; 3549 : 
; 3550 : 	kStream << m_ppaaiImprovementYieldChange;

	mov	ecx, DWORD PTR [edi+792]
	sub	ecx, DWORD PTR [edi+788]
	lea	ebx, DWORD PTR [edi+784]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T241807[esp+24]
	add	eax, edx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T241807[esp+28], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+4]
	push	ebx
	push	esi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T241805[esp+44]
	push	edx
	call	??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >,SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const > >

; 3551 : 	kStream << m_ppaaiSpecialistYieldChange;

	mov	ecx, DWORD PTR [edi+808]
	sub	ecx, DWORD PTR [edi+804]
	lea	ebx, DWORD PTR [edi+800]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	add	esp, 20					; 00000014H
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T241868[esp+24]
	add	eax, edx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T241868[esp+28], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+4]
	push	ebx
	push	esi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T241866[esp+44]
	push	edx
	call	??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >,SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const > >

; 3552 : 	kStream << m_ppaaiUnimprovedFeatureYieldChange;

	mov	ecx, DWORD PTR [edi+824]
	sub	ecx, DWORD PTR [edi+820]
	lea	ebx, DWORD PTR [edi+816]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	add	esp, 20					; 00000014H
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T241929[esp+24]
	add	eax, edx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T241929[esp+28], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+4]
	push	ebx
	push	esi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T241927[esp+44]
	push	edx
	call	??$for_each@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBV?$Array@H$05@Firaxis@@$$CBV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >,SerializeFromSequenceContainer<Firaxis::Array<int,6> const ,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > const > >

; 3553 : 
; 3554 : 	kStream << (int)m_aUniqueLuxuryAreas.size();

	mov	eax, DWORD PTR [edi+704]
	sub	eax, DWORD PTR [edi+700]
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T240972[esp+24]
	sar	eax, 2
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T240972[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3555 : 	for (unsigned int iI = 0; iI < m_aUniqueLuxuryAreas.size(); iI++)

	xor	ebx, ebx
	mov	edx, DWORD PTR [edi+704]
	sub	edx, DWORD PTR [edi+700]
	sar	edx, 2
	test	edx, edx
	jbe	SHORT $LN1@Write
	npad	6
$LL3@Write:
	mov	eax, DWORD PTR [edi+700]
	lea	ecx, DWORD PTR [eax+ebx*4]

; 3556 : 	{
; 3557 : 		kStream << m_aUniqueLuxuryAreas[iI];

	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	edx, DWORD PTR [edi+704]
	sub	edx, DWORD PTR [edi+700]
	inc	ebx
	sar	edx, 2
	cmp	ebx, edx
	jb	SHORT $LL3@Write
$LN1@Write:
	pop	edi
	pop	esi
	pop	ebx

; 3558 : 	}
; 3559 : }

	add	esp, 16					; 00000010H
	ret	4
?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTraits::Write
_TEXT	ENDS
PUBLIC	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN33@operator@17
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@17

; 572  : 				clear();	// new sequence empty, erase existing sequence

	call	?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::clear
	pop	ebp
	pop	ebx
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@17:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@17

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@17:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN24@operator@17
	xor	ebx, ebx
	jmp	SHORT $LN25@operator@17
$LN24@operator@17:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN25@operator@17:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@17

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@17:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN28@operator@17

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@operator@17:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	test	al, al
	je	SHORT $LN32@operator@17

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
	mov	DWORD PTR [esi+8], eax
$LN32@operator@17:
	pop	ebp
	pop	ebx
$LN33@operator@17:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
_TEXT	ENDS
PUBLIC	?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
$T242038 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::insert, COMDAT
; _this$ = ecx

; 271  : 		return (_Mybase::insert(_Val).first);

	mov	eax, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	push	eax
	lea	edx, DWORD PTR $T242038[esp+12]
	push	edx
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx

; 272  : 		}

	add	esp, 8
	ret	8
?insert@?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::insert
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T242210 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	esi
	push	edi

; 545  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN20@operator@18

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T242210[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
$LN20@operator@18:
	pop	edi

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, esi
	pop	esi

; 552  : 		}

	ret	4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T242264 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T242264[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::erase
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@6
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@6
	push	ebx
	npad	4
$LL28@erase@6:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	add	edx, 8
	add	esi, 8
	cmp	edx, edi
	jne	SHORT $LL28@erase@6
	pop	ebx
$LN26@erase@6:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@6:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@7
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@7
	push	ebx
	npad	4
$LL28@erase@7:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	add	edx, 4
	add	esi, 4
	cmp	edx, edi
	jne	SHORT $LL28@erase@7
	pop	ebx
$LN26@erase@7:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@7:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@8
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@8
	push	ebx
	npad	4
$LL28@erase@8:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	add	edx, 8
	add	esi, 8
	cmp	edx, edi
	jne	SHORT $LL28@erase@8
	pop	ebx
$LN26@erase@8:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@8:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU3@IABU3@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T242607 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$242610 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU3@IABU3@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$242610[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T242607[esp+12], 0
	mov	eax, DWORD PTR $T242607[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU3@IABU3@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Umove@PAUFreeResourceXCities@@@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU2@00@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Umove<FreeResourceXCities *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUFreeResourceXCities@@@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU2@00@Z
_TEXT	SEGMENT
$T242662 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242665 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUFreeResourceXCities@@@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU2@00@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Umove<FreeResourceXCities *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$242665[esp]
	mov	BYTE PTR $T242662[esp+4], 0
	mov	eax, DWORD PTR $T242662[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUFreeResourceXCities@@@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU2@00@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Umove<FreeResourceXCities *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z
_TEXT	SEGMENT
$T242702 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242696 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242696[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242702[esp+4], 0
	mov	eax, DWORD PTR $T242702[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z
_TEXT	SEGMENT
$T242733 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$242737 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$242737[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T242733[esp+4], 0
	mov	eax, DWORD PTR $T242733[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1903 : 		{	// construct empty vector

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 1904 : 		}

	ret	0
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1957 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1958 : 		_Mysize = 0;

	mov	DWORD PTR [esi], 0

; 1959 : 		}

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@vector@4:
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	pop	esi
	ret	0
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T243376 = -28						; size = 1
__First$ = -24						; size = 8
$T242933 = -16						; size = 8
__Next$ = -8						; size = 8
__Last$ = -8						; size = 8
__Cat$243380 = 8					; size = 1
$T243378 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Tmp$243499 = 12					; size = 8
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2221 : 		{	// erase [_First, _Last)

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2222 : 		iterator _First = _Make_iter(_First_arg);

	mov	ebp, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+8]
	xor	esi, esi
	mov	DWORD PTR __First$[esp+44], ebx
	mov	DWORD PTR __First$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN36@erase@9
	mov	eax, DWORD PTR __First_arg$[esp+40]
	sub	eax, ebx
	sar	eax, 2
	shl	eax, 5
	add	eax, DWORD PTR __First_arg$[esp+44]
	lea	ecx, DWORD PTR __First$[esp+44]
	push	eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@erase@9:

; 2223 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	DWORD PTR __Last$[esp+44], ebx
	mov	DWORD PTR __Last$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN71@erase@9
	mov	ecx, DWORD PTR __Last_arg$[esp+40]
	sub	ecx, ebx
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Last_arg$[esp+44]
	push	ecx
	lea	ecx, DWORD PTR __Last$[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN71@erase@9:

; 2224 : 		size_type _Off = _First - begin();

	mov	esi, DWORD PTR __First$[esp+44]
	sub	esi, ebx
	sar	esi, 2
	shl	esi, 5
	add	esi, DWORD PTR __First$[esp+48]

; 2225 : 
; 2226 :  #if _HAS_ITERATOR_DEBUGGING
; 2227 : 		if (_Last < _First || end() < _Last)
; 2228 : 			_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2229 : 		iterator _Next = std::copy(_Last, end(), _First);
; 2230 : 		size_type _Newsize = _Next - begin();
; 2231 : 		_Orphan_range(_Newsize, _Mysize);
; 2232 : 		_Trim(_Newsize);
; 2233 : 
; 2234 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 2235 : 		iterator _Next = std::copy(_Last, end(), _First);

	mov	DWORD PTR $T242933[esp+44], ebx
	mov	DWORD PTR $T242933[esp+48], 0
	test	ebp, ebp
	jbe	SHORT $LN108@erase@9
	push	ebp
	lea	ecx, DWORD PTR $T242933[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN108@erase@9:
	mov	eax, DWORD PTR __Cat$243380[esp+40]
	mov	ecx, DWORD PTR $T243378[esp+40]
	mov	BYTE PTR $T243376[esp+44], 0
	mov	edx, DWORD PTR $T243376[esp+44]
	push	edx
	mov	edx, DWORD PTR __First$[esp+52]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR $T242933[esp+60]
	push	edx
	mov	edx, DWORD PTR $T242933[esp+60]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+68]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR __Next$[esp+80]
	push	edx
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>

; 2236 : 		_Trim(_Next - begin());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR __Next$[esp+84]
	sub	ecx, eax
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Next$[esp+88]
	add	esp, 40					; 00000028H
	push	ecx
	mov	ecx, edi
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2237 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2238 : 
; 2239 : 		return (begin() + _Off);

	mov	edi, DWORD PTR [edi+8]
	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$243499[esp+44]
	mov	DWORD PTR __Tmp$243499[esp+44], edi
	mov	DWORD PTR __Tmp$243499[esp+48], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+40]
	mov	edx, DWORD PTR __Tmp$243499[esp+40]
	mov	ecx, DWORD PTR __Tmp$243499[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 2240 : 		}

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z
_TEXT	SEGMENT
$T243558 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$243562 = 12					; size = 1
$T243560 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [edi], eax
	cmp	eax, edx
	je	SHORT $LN26@erase@10

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	BYTE PTR $T243558[esp+8], 0
	mov	ebx, DWORD PTR $T243558[esp+8]
	push	ebx
	mov	ebx, DWORD PTR __Cat$243562[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T243560[esp+16]
	push	ebx
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], eax
	pop	ebx
$LN26@erase@10:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214846 = 16					; size = 4
__Tmp$214836 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214836[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214846[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill@2
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill@2
	pop	ebx
$LN22@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Umove@PAV?$Array@H$05@Firaxis@@@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV23@00@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Umove<Firaxis::Array<int,6> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAV?$Array@H$05@Firaxis@@@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV23@00@Z
_TEXT	SEGMENT
$T243918 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243921 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$Array@H$05@Firaxis@@@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV23@00@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Umove<Firaxis::Array<int,6> *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$243921[esp]
	mov	BYTE PTR $T243918[esp+4], 0
	mov	eax, DWORD PTR $T243918[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAV?$Array@H$05@Firaxis@@@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV23@00@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Umove<Firaxis::Array<int,6> *>
_TEXT	ENDS
PUBLIC	??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<bool,std::allocator<bool> >::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	mov	eax, esi
	pop	esi
	ret	4
??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 529  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 530  : 		_TRY_BEGIN
; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy

; 535  : 		_CATCH_END
; 536  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN57@Tree:
$LN56@Tree:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T244192 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T244192[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
_TEXT	ENDS
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi

; 1034 : 		if (this == &_Right)

	mov	esi, DWORD PTR __Right$[esp+16]
	push	edi
	cmp	ecx, esi
	je	SHORT $LN23@swap@4

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())
; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	lea	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	je	SHORT $LN20@swap@4
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN20@swap@4:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	lea	eax, DWORD PTR [esi+8]
	add	ecx, 8
	cmp	ecx, eax
	je	SHORT $LN23@swap@4
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN23@swap@4:

; 1048 : 			}
; 1049 : 		else
; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);
; 1052 : 
; 1053 : 			_Myt _Tmp = *this;
; 1054 : 
; 1055 : 			*this = _Right;
; 1056 : 			_Right = _Tmp;
; 1057 : 			}
; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
PUBLIC	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	je	SHORT $LN15@clear@4
	mov	eax, esi
	cmp	esi, esi
	je	SHORT $LN40@clear@4
	push	edi
$LL42@clear@4:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL42@clear@4
	pop	edi
$LN40@clear@4:
	mov	DWORD PTR [ecx+8], edx
$LN15@clear@4:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::clear
_TEXT	ENDS
PUBLIC	?clear@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	esi, edx
	je	SHORT $LN15@clear@5
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN40@clear@5
	push	edi
$LL42@clear@5:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	add	eax, 4
	add	esi, 4
	cmp	eax, edx
	jne	SHORT $LL42@clear@5
	pop	edi
$LN40@clear@5:
	mov	DWORD PTR [ecx+8], esi
$LN15@clear@5:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@6:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	je	SHORT $LN15@clear@6
	mov	eax, esi
	cmp	esi, esi
	je	SHORT $LN40@clear@6
	push	edi
$LL42@clear@6:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL42@clear@6
	pop	edi
$LN40@clear@6:
	mov	DWORD PTR [ecx+8], edx
$LN15@clear@6:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::clear
_TEXT	ENDS
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z
_TEXT	SEGMENT
$T245067 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 718  : 		if (size() < _Newsize)

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	cmp	edx, eax
	jbe	SHORT $LN36@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
$LN36@resize:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T245067[esp+12]
	push	eax
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN1@resize:
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
PUBLIC	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n, COMDAT
; _this$ = ecx

; 545  : 		{	// construct from _Count * _Val

	push	ebx
	push	esi

; 546  : 		if (_Buy(_Count))

	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR __Count$[esp+8]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	edi, ebx
	je	SHORT $LN5@Construct_
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN10@Construct_
	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN48@Construct_:
$LN10@Construct_:
	push	ebx
	push	edi
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	lea	ecx, DWORD PTR [eax+edi*4]
	add	esp, 8
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN
; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	ecx, edi
	mov	edx, eax
	cmp	edi, ebx
	jbe	SHORT $LN38@Construct_
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	ebp
$LL40@Construct_:
	mov	ebp, DWORD PTR [ebx]
	mov	DWORD PTR [edx], ebp
	dec	ecx
	add	edx, 4
	test	ecx, ecx
	ja	SHORT $LL40@Construct_
	pop	ebp
$LN38@Construct_:
	lea	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], edx
$LN5@Construct_:
	pop	edi
	pop	esi
	pop	ebx

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();
; 552  : 			_RERAISE;
; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

	ret	8
$LN47@Construct_:
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$2
__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$0
__unwindtable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
_TEXT	SEGMENT
__Tmp$225240 = -24					; size = 8
__Tmp$225230 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$245526 = 8					; size = 1
__Cat$245454 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$225215 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T245523 = 16						; size = 1
$T245451 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ; std::_Allocate<FreeResourceXCities>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$225215[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU3@IABU3@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$245454[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T245451[ebp], 0
	mov	ecx, DWORD PTR $T245451[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$225215[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T245523[ebp], 0
	mov	edx, DWORD PTR $T245523[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$245526[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$225215[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$225215[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225230[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$225230[ebp], edx
	call	??$_Umove@PAUFreeResourceXCities@@@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU2@00@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Umove<FreeResourceXCities *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$225230[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU3@IABU3@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$225230[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z ; std::fill<FreeResourceXCities *,FreeResourceXCities>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$225240[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$225240[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAUFreeResourceXCities@@@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEPAUFreeResourceXCities@@PAU2@00@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Umove<FreeResourceXCities *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAUFreeResourceXCities@@PAU1@@stdext@@YAPAUFreeResourceXCities@@PAU1@00@Z ; stdext::_Unchecked_move_backward<FreeResourceXCities *,FreeResourceXCities *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$225240[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAUFreeResourceXCities@@U1@@std@@YAXPAUFreeResourceXCities@@0ABU1@@Z ; std::fill<FreeResourceXCities *,FreeResourceXCities>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n
PUBLIC	??$_Umove@PAW4TraitTypes@@@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW42@00@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Umove<enum TraitTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAW4TraitTypes@@@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T245603 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$245606 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4TraitTypes@@@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW42@00@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Umove<enum TraitTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$245606[esp]
	mov	BYTE PTR $T245603[esp+4], 0
	mov	eax, DWORD PTR $T245603[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4TraitTypes@@@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW42@00@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Umove<enum TraitTypes *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUMayaBonusChoice@@@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU2@00@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Umove<MayaBonusChoice *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUMayaBonusChoice@@@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU2@00@Z
_TEXT	SEGMENT
$T245658 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$245661 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUMayaBonusChoice@@@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU2@00@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Umove<MayaBonusChoice *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$245661[esp]
	mov	BYTE PTR $T245658[esp+4], 0
	mov	eax, DWORD PTR $T245658[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUMayaBonusChoice@@@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU2@00@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Umove<MayaBonusChoice *>
_TEXT	ENDS
PUBLIC	??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@7:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T245685 = -8						; size = 8
$T245682 = -8						; size = 8
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::vector<bool,std::allocator<bool> >::clear, COMDAT
; _this$ = ecx

; 2243 : 		{	// erase all elements

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2244 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR $T245682[esp+16], edi
	mov	DWORD PTR $T245682[esp+20], 0
	test	eax, eax
	jbe	SHORT $LN20@clear@7
	push	eax
	lea	ecx, DWORD PTR $T245682[esp+20]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@clear@7:
	mov	ecx, DWORD PTR $T245682[esp+20]
	mov	edx, DWORD PTR $T245682[esp+16]
	push	ecx
	push	edx
	xor	eax, eax
	push	eax
	push	edi
	lea	eax, DWORD PTR $T245685[esp+32]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
	pop	edi
	pop	esi

; 2245 : 		}

	add	esp, 8
	ret	0
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@8:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	?clear@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T245947 = -4						; size = 1
$T245949 = -4						; size = 1
__Cat$245951 = -4					; size = 1
?clear@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx
	push	esi
	mov	esi, ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN15@clear@8
	mov	BYTE PTR $T245947[esp+8], 0
	mov	edx, DWORD PTR $T245947[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$245951[esp+12]
	push	edx
	mov	edx, DWORD PTR $T245949[esp+16]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN15@clear@8:
	pop	esi

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$2
__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$0
__unwindtable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
__Tmp$214946 = -44					; size = 24
__Tmp$214936 = -44					; size = 24
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$246229 = 8					; size = 1
__Cat$246156 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$214921 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T246226 = 16						; size = 1
$T246153 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN85@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 178956970				; 0aaaaaaaH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen
$LN91@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 178956970				; 0aaaaaaaH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ; std::_Allocate<Firaxis::Array<int,6> >

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 2
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	edi
	mov	DWORD PTR __Newvec$214921[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV34@IABV34@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$246156[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T246153[ebp], 0
	mov	ecx, DWORD PTR $T246153[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$214921[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$214921[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	BYTE PTR $T246226[ebp], 0
	mov	edx, DWORD PTR $T246226[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$246229[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$214921[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$214921[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@3
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214936[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$214936[ebp+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$214936[ebp+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$214936[ebp+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$214936[ebp+20], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$214936[ebp+16], edx
	call	??$_Umove@PAV?$Array@H$05@Firaxis@@@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV23@00@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Umove<Firaxis::Array<int,6> *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$214936[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV34@IABV34@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$214936[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$_Fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z ; std::_Fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$214946[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$214946[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]
	add	edi, edi
	mov	DWORD PTR __Tmp$214946[ebp+8], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$214946[ebp+12], edx
	mov	edx, DWORD PTR [eax+20]
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$214946[ebp+16], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$214946[ebp+20], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAV?$Array@H$05@Firaxis@@@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEPAV?$Array@H$05@Firaxis@@PAV23@00@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Umove<Firaxis::Array<int,6> *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR tv525[ebp]
	push	ebx
	push	eax
	push	ecx
	call	??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$214946[ebp]
	push	edx
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAV?$Array@H$05@Firaxis@@V12@@std@@YAXPAV?$Array@H$05@Firaxis@@0ABV12@@Z ; std::_Fill<Firaxis::Array<int,6> *,Firaxis::Array<int,6> >
	add	esp, 24					; 00000018H
$LN85@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215058 = 16					; size = 4
__Tmp$215048 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@4
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@4
$LN29@Insert_n@4:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@4
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN64@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215048[esp+16], edx
	jae	SHORT $LN3@Insert_n@4
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215048[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215048[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@4:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215058[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@4:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@4:
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T246459 = -4						; size = 4
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T246459[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??_7CvTraitEntry@@6B@				; CvTraitEntry::`vftable'
PUBLIC	??1CvTraitEntry@@QAE@XZ				; CvTraitEntry::~CvTraitEntry
PUBLIC	??_R4CvTraitEntry@@6B@				; CvTraitEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTraitEntry@@@8			; CvTraitEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvTraitEntry@@8				; CvTraitEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTraitEntry@@8				; CvTraitEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTraitEntry@@8			; CvTraitEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTraitEntry::CacheResults
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvTraitEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTraitEntry@@8 DD FLAT:??_R0?AVCvTraitEntry@@@8 ; CvTraitEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTraitEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTraitEntry@@8
rdata$r	SEGMENT
??_R2CvTraitEntry@@8 DD FLAT:??_R1A@?0A@EA@CvTraitEntry@@8 ; CvTraitEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvTraitEntry@@8
rdata$r	SEGMENT
??_R3CvTraitEntry@@8 DD 00H				; CvTraitEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvTraitEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTraitEntry@@@8
_DATA	SEGMENT
??_R0?AVCvTraitEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvTraitEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTraitEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTraitEntry@@6B@
rdata$r	SEGMENT
??_R4CvTraitEntry@@6B@ DD 00H				; CvTraitEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTraitEntry@@@8
	DD	FLAT:??_R3CvTraitEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvTraitEntry@@6B@
CONST	SEGMENT
??_7CvTraitEntry@@6B@ DD FLAT:??_R4CvTraitEntry@@6B@	; CvTraitEntry::`vftable'
	DD	FLAT:?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvTraitEntry@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1CvTraitEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvTraitEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$4
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTraitEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246690 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTraitEntry@@QAE@XZ PROC				; CvTraitEntry::~CvTraitEntry, COMDAT
; _this$ = ecx

; 170  : {

	push	-1
	push	__ehhandler$??1CvTraitEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvTraitEntry@@6B@

; 171  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 172  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges.first, m_ppiImprovementYieldChanges.second);
; 173  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiSpecialistYieldChanges.first, m_ppiSpecialistYieldChanges.second);
; 174  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiUnimprovedFeatureYieldChanges.first, m_ppiUnimprovedFeatureYieldChanges.second);
; 175  : #else
; 176  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges);

	lea	eax, DWORD PTR [esi+676]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+44], 4
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 177  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiSpecialistYieldChanges);

	lea	ecx, DWORD PTR [esi+680]
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 178  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiUnimprovedFeatureYieldChanges);

	lea	edx, DWORD PTR [esi+684]
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 179  : #endif
; 180  : #ifdef AUI_WARNING_FIXES
; 181  : 	SAFE_DELETE_ARRAY(m_paiExtraYieldThreshold);
; 182  : 	SAFE_DELETE_ARRAY(m_paiYieldChange);
; 183  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeStrategicResources);
; 184  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeLuxuryResources); // NQMP GJS - New Netherlands UA
; 185  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeNaturalWonder);
; 186  : 	SAFE_DELETE_ARRAY(m_paiYieldChangePerTradePartner);
; 187  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeIncomingTradeRoute);
; 188  : 	SAFE_DELETE_ARRAY(m_paiYieldModifier);
; 189  : 	SAFE_DELETE_ARRAY(m_piStrategicResourceQuantityModifier);
; 190  : 	SAFE_DELETE_ARRAY(m_piResourceQuantityModifiers);
; 191  : 	SAFE_DELETE_ARRAY(m_piMovesChangeUnitCombats);
; 192  : 	SAFE_DELETE_ARRAY(m_piMaintenanceModifierUnitCombats);
; 193  : #endif
; 194  : }

	xor	ebx, ebx
	mov	DWORD PTR [esi+716], ebx
	mov	eax, DWORD PTR [esi+724]
	add	esp, 12					; 0000000cH
	cmp	eax, ebx
	je	SHORT $LN15@CvTraitEnt
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@CvTraitEnt:
	mov	DWORD PTR [esi+724], ebx
	mov	DWORD PTR [esi+728], ebx
	mov	DWORD PTR [esi+732], ebx
	mov	eax, DWORD PTR [esi+704]
	cmp	eax, ebx
	je	SHORT $LN24@CvTraitEnt
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@CvTraitEnt:
	mov	DWORD PTR [esi+704], ebx
	mov	DWORD PTR [esi+708], ebx
	mov	DWORD PTR [esi+712], ebx
	mov	eax, DWORD PTR [esi+692]
	mov	ecx, DWORD PTR [eax]
	lea	edi, DWORD PTR [esi+688]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T246690[esp+40]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+52], 1
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	ecx, DWORD PTR [esi+600]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	BYTE PTR __$EHRec$[esp+40], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 600				; 00000258H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	jmp	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 716				; 000002ccH
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$??1CvTraitEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTraitEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTraitEntry@@QAE@XZ ENDP				; CvTraitEntry::~CvTraitEntry
PUBLIC	??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0CvPlayerTraits@@QAE@XZ			; CvPlayerTraits::CvPlayerTraits
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__ehfuncinfo$??0CvPlayerTraits@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0CvPlayerTraits@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvPlayerTraits@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$11
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlayerTraits@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlayerTraits@@QAE@XZ PROC				; CvPlayerTraits::CvPlayerTraits, COMDAT
; _this$ = ecx

; 1542 : {

	push	-1
	push	__ehhandler$??0CvPlayerTraits@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+608], ecx
	mov	DWORD PTR [eax+612], ecx
	mov	DWORD PTR [eax+616], ecx
	mov	DWORD PTR [eax+620], ecx
	mov	DWORD PTR [eax+628], ecx
	mov	DWORD PTR [eax+632], ecx
	mov	DWORD PTR [eax+636], ecx
	lea	edx, DWORD PTR [eax+652]
	mov	DWORD PTR [eax+644], ecx
	mov	DWORD PTR [eax+648], 5
	mov	DWORD PTR [eax+640], edx
	mov	DWORD PTR [eax+700], ecx
	mov	DWORD PTR [eax+704], ecx
	mov	DWORD PTR [eax+708], ecx
	mov	DWORD PTR [eax+740], ecx
	mov	DWORD PTR [eax+744], ecx
	mov	DWORD PTR [eax+748], ecx
	mov	DWORD PTR [eax+756], ecx
	mov	DWORD PTR [eax+760], ecx
	mov	DWORD PTR [eax+764], ecx
	mov	DWORD PTR [eax+772], ecx
	mov	DWORD PTR [eax+776], ecx
	mov	DWORD PTR [eax+780], ecx
	mov	DWORD PTR [eax+788], ecx
	mov	DWORD PTR [eax+792], ecx
	mov	DWORD PTR [eax+796], ecx
	mov	DWORD PTR [eax+804], ecx
	mov	DWORD PTR [eax+808], ecx
	mov	DWORD PTR [eax+812], ecx
	mov	DWORD PTR [eax+820], ecx
	mov	DWORD PTR [eax+824], ecx
	mov	DWORD PTR [eax+828], ecx
	mov	DWORD PTR [eax+836], ecx
	mov	DWORD PTR [eax+840], ecx
	mov	DWORD PTR [eax+844], ecx

; 1543 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 604				; 0000025cH
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 620				; 0000026cH
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 640				; 00000280H
	jmp	??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 736				; 000002e0H
	jmp	??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 768				; 00000300H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 784				; 00000310H
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 800				; 00000320H
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__ehhandler$??0CvPlayerTraits@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPlayerTraits@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlayerTraits@@QAE@XZ ENDP				; CvPlayerTraits::CvPlayerTraits
PUBLIC	?Uninit@CvPlayerTraits@@QAEXXZ			; CvPlayerTraits::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
$T249893 = -8						; size = 1
__Cat$249897 = -8					; size = 1
$T249895 = -8						; size = 1
$T249732 = -8						; size = 1
__Cat$249736 = -8					; size = 1
$T249734 = -8						; size = 1
$T249537 = -8						; size = 1
__Cat$249541 = -8					; size = 1
$T249539 = -8						; size = 1
$T248926 = -8						; size = 8
$T248923 = -8						; size = 8
?Uninit@CvPlayerTraits@@QAEXXZ PROC			; CvPlayerTraits::Uninit, COMDAT
; _this$ = ecx

; 1899 : {

	sub	esp, 8
	push	ebx

; 1900 : 	m_aiResourceQuantityModifier.clear();

	mov	ebx, DWORD PTR __imp__memmove_s
	push	ebp
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+612]
	push	edi
	mov	edi, DWORD PTR [esi+608]
	cmp	edi, ecx
	je	SHORT $LN17@Uninit
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN42@Uninit
	push	edx
	push	ecx
	push	edx
	push	edi
	call	ebx
	add	esp, 16					; 00000010H
$LN42@Uninit:
	mov	DWORD PTR [esi+612], ebp
$LN17@Uninit:

; 1901 : 	m_abNoTrain.clear();

	mov	eax, DWORD PTR [esi+620]
	mov	ebp, DWORD PTR [esi+628]
	lea	edi, DWORD PTR [esi+620]
	mov	DWORD PTR $T248923[esp+24], ebp
	mov	DWORD PTR $T248923[esp+28], 0
	test	eax, eax
	jbe	SHORT $LN64@Uninit
	push	eax
	lea	ecx, DWORD PTR $T248923[esp+28]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN64@Uninit:
	mov	ecx, DWORD PTR $T248923[esp+28]
	mov	edx, DWORD PTR $T248923[esp+24]
	push	ecx
	push	edx
	xor	eax, eax
	push	eax
	push	ebp
	lea	eax, DWORD PTR $T248926[esp+40]
	push	eax
	mov	ecx, edi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase

; 1902 : 	m_paiMovesChangeUnitCombat.clear();

	mov	edx, DWORD PTR [esi+756]
	mov	ecx, DWORD PTR [esi+760]
	cmp	edx, ecx
	je	SHORT $LN94@Uninit
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edi, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edi+edx]
	test	eax, eax
	jle	SHORT $LN119@Uninit
	push	edi
	push	ecx
	push	edi
	push	edx
	call	ebx
	add	esp, 16					; 00000010H
$LN119@Uninit:
	mov	DWORD PTR [esi+760], ebp
$LN94@Uninit:

; 1903 : 	m_paiMaintenanceModifierUnitCombat.clear();

	mov	edi, DWORD PTR [esi+772]
	mov	ecx, DWORD PTR [esi+776]
	cmp	edi, ecx
	je	SHORT $LN136@Uninit
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN161@Uninit
	push	edx
	push	ecx
	push	edx
	push	edi
	call	ebx
	add	esp, 16					; 00000010H
$LN161@Uninit:
	mov	DWORD PTR [esi+776], ebp
$LN136@Uninit:

; 1904 : 	m_ppaaiImprovementYieldChange.clear();

	mov	ecx, DWORD PTR [esi+788]
	mov	eax, DWORD PTR [esi+792]
	cmp	ecx, eax
	je	SHORT $LN178@Uninit
	mov	BYTE PTR $T249537[esp+24], 0
	mov	edx, DWORD PTR $T249537[esp+24]
	push	edx
	mov	edx, DWORD PTR __Cat$249541[esp+28]
	push	edx
	mov	edx, DWORD PTR $T249539[esp+32]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+792], eax
$LN178@Uninit:

; 1905 : 	m_ppaaiSpecialistYieldChange.clear();

	mov	ecx, DWORD PTR [esi+804]
	mov	eax, DWORD PTR [esi+808]
	cmp	ecx, eax
	je	SHORT $LN217@Uninit
	mov	BYTE PTR $T249732[esp+24], 0
	mov	edx, DWORD PTR $T249732[esp+24]
	push	edx
	mov	edx, DWORD PTR __Cat$249736[esp+28]
	push	edx
	mov	edx, DWORD PTR $T249734[esp+32]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+808], eax
$LN217@Uninit:

; 1906 : 	m_ppaaiUnimprovedFeatureYieldChange.clear();

	mov	ecx, DWORD PTR [esi+820]
	mov	eax, DWORD PTR [esi+824]
	cmp	ecx, eax
	je	SHORT $LN256@Uninit
	mov	BYTE PTR $T249893[esp+24], 0
	mov	edx, DWORD PTR $T249893[esp+24]
	push	edx
	mov	edx, DWORD PTR __Cat$249897[esp+28]
	push	edx
	mov	edx, DWORD PTR $T249895[esp+32]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+824], eax
$LN256@Uninit:

; 1907 : 	m_aFreeResourceXCities.clear();

	mov	ecx, DWORD PTR [esi+836]
	mov	edx, DWORD PTR [esi+840]
	cmp	ecx, edx
	je	SHORT $LN295@Uninit
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN320@Uninit
$LL322@Uninit:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL322@Uninit
$LN320@Uninit:
	mov	DWORD PTR [esi+840], ecx
$LN295@Uninit:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1908 : }

	add	esp, 8
	ret	0
?Uninit@CvPlayerTraits@@QAEXXZ ENDP			; CvPlayerTraits::Uninit
_TEXT	ENDS
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T250277 = -4						; size = 4
$T250241 = 8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ecx

; 713  : 		resize(_Newsize, _Ty());

	mov	edx, DWORD PTR __Newsize$[esp]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T250277[esp+12], 0
	cmp	edx, eax
	jbe	SHORT $LN38@resize@2
	lea	edi, DWORD PTR $T250277[esp+12]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	pop	edi
	pop	esi

; 714  : 		}

	pop	ecx
	ret	4
$LN38@resize@2:

; 713  : 		resize(_Newsize, _Ty());

	jae	SHORT $LN3@resize@2
	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T250241[esp+16]
	push	eax
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN3@resize@2:
	pop	edi
	pop	esi

; 714  : 		}

	pop	ecx
	ret	4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
PUBLIC	??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\map
;	COMDAT ??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 228  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 229  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 489  : 		_Construct_n(_Count, _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Count$[esp]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n

; 490  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
$T250540 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 24
?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	esi

; 718  : 		if (size() < _Newsize)

	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	edx, esi
	sub	edx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR __Newsize$[esp+4]
	cmp	edx, eax
	jbe	SHORT $LN36@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	28					; 0000001cH
$LN36@resize@3:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@3

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edx+edx*2]
	push	esi
	lea	eax, DWORD PTR [edi+eax*8]
	push	eax
	lea	edx, DWORD PTR $T250540[esp+12]
	push	edx
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase
$LN1@resize@3:
	pop	edi
	pop	esi

; 722  : 		}

	ret	28					; 0000001cH
?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize
_TEXT	ENDS
PUBLIC	?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$250883 = 8					; size = 1
__Cat$250811 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$225337 = 12					; size = 4
__Tmp$225327 = 12					; size = 4
__Newvec$225312 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T250880 = 16						; size = 1
$T250808 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@5
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@5
$LN29@Insert_n@5:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen
$LN87@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ; std::_Allocate<enum TraitTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$225312[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW43@IABW43@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$250811[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T250808[ebp], 0
	mov	ecx, DWORD PTR $T250808[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$225312[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T250880[ebp], 0
	mov	edx, DWORD PTR $T250880[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$250883[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$225312[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$225312[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225327[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4TraitTypes@@@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW42@00@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Umove<enum TraitTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$225327[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW43@IABW43@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$225327[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z ; std::fill<enum TraitTypes *,enum TraitTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@5:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$225337[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4TraitTypes@@@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEPAW4TraitTypes@@PAW42@00@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Umove<enum TraitTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4TraitTypes@@PAW41@@stdext@@YAPAW4TraitTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum TraitTypes *,enum TraitTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$225337[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4TraitTypes@@W41@@std@@YAXPAW4TraitTypes@@0ABW41@@Z ; std::fill<enum TraitTypes *,enum TraitTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$2
__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$0
__unwindtable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
_TEXT	SEGMENT
__Tmp$225394 = -24					; size = 8
__Tmp$225384 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$251117 = 8					; size = 1
__Cat$251045 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$225369 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T251113 = 16						; size = 1
$T251041 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@6
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@6
$LN29@Insert_n@6:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n@6:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n@6

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen
$LN91@Insert_n@6:
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@6:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ; std::_Allocate<MayaBonusChoice>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$225369[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU3@IABU3@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$251045[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T251041[ebp], 0
	mov	ecx, DWORD PTR $T251041[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$225369[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T251113[ebp], 0
	mov	edx, DWORD PTR $T251113[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$251117[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$225369[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$225369[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n@6:
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225384[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$225384[ebp], edx
	call	??$_Umove@PAUMayaBonusChoice@@@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU2@00@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Umove<MayaBonusChoice *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$225384[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU3@IABU3@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$225384[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z ; std::fill<MayaBonusChoice *,MayaBonusChoice>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@6:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$225394[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$225394[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAUMayaBonusChoice@@@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEPAUMayaBonusChoice@@PAU2@00@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Umove<MayaBonusChoice *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAUMayaBonusChoice@@PAU1@@stdext@@YAPAUMayaBonusChoice@@PAU1@00@Z ; stdext::_Unchecked_move_backward<MayaBonusChoice *,MayaBonusChoice *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$225394[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAUMayaBonusChoice@@U1@@std@@YAXPAUMayaBonusChoice@@0ABU1@@Z ; std::fill<MayaBonusChoice *,MayaBonusChoice>
	add	esp, 24					; 00000018H
$LN1@Insert_n@6:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_uiNumEntries$ = -20					; size = 4
_iI$225711 = -16					; size = 4
$T251291 = -12						; size = 4
$T251301 = -8						; size = 4
_tDummy$225722 = -4					; size = 4
_kStream$ = 8						; size = 4
_bValid$225715 = 12					; size = 1
_aiArray$ = 12						; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 390  : {

	sub	esp, 20					; 00000014H
	push	ebx

; 391  : 	uint uiNumEntries;
; 392  : 
; 393  : 	kStream >> uiNumEntries;

	mov	ebx, DWORD PTR _kStream$[esp+20]
	push	esi
	lea	eax, DWORD PTR _uiNumEntries$[esp+28]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 394  : 
; 395  : 	if(aiArray.size() < uiNumEntries)

	mov	esi, DWORD PTR _aiArray$[esp+24]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _uiNumEntries$[esp+28]
	sar	ecx, 2
	cmp	ecx, eax
	jae	SHORT $LN8@ReadHashed@2

; 396  : 		aiArray.resize(uiNumEntries);

	push	eax
	mov	ecx, esi
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize
	mov	eax, DWORD PTR _uiNumEntries$[esp+28]
$LN8@ReadHashed@2:

; 397  : 
; 398  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$225711[esp+28], 0
	test	eax, eax
	jbe	$LN5@ReadHashed@2
	push	ebp
	push	edi
$LL7@ReadHashed@2:

; 399  : 	{
; 400  : 		bool bValid;
; 401  : 		int iType = ReadHashed(kStream, &bValid);

	lea	edx, DWORD PTR _bValid$225715[esp+32]
	push	edx
	push	ebx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	edi, eax
	add	esp, 8

; 402  : 		if(iType != -1)

	cmp	edi, -1
	je	SHORT $LN4@ReadHashed@2

; 403  : 		{
; 404  : 			if (iType >= (int)aiArray.size())

	mov	edx, DWORD PTR [esi+8]
	mov	ebp, DWORD PTR [esi+4]
	mov	eax, edx
	sub	eax, ebp
	sar	eax, 2
	cmp	edi, eax
	jl	SHORT $LN19@ReadHashed@2

; 405  : 				aiArray.resize(iType+1);

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR $T251291[esp+36], 0
	cmp	ecx, eax
	jbe	SHORT $LN62@ReadHashed@2
	lea	ebp, DWORD PTR $T251291[esp+36]
	push	ebp
	sub	ecx, eax
	push	ecx
	push	edx
	mov	ecx, esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 406  : 
; 407  : 			kStream >> aiArray[iType];

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+edi*4]
	push	edx
	jmp	SHORT $LN63@ReadHashed@2
$LN62@ReadHashed@2:

; 405  : 				aiArray.resize(iType+1);

	jae	SHORT $LN19@ReadHashed@2
	lea	eax, DWORD PTR [ebp+ecx*4]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T251301[esp+44]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN19@ReadHashed@2:

; 406  : 
; 407  : 			kStream >> aiArray[iType];

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+edi*4]
	push	edx
	jmp	SHORT $LN63@ReadHashed@2
$LN4@ReadHashed@2:

; 408  : 		}
; 409  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225715[esp+32], 0
	jne	SHORT $LN6@ReadHashed@2

; 410  : 		{
; 411  : 			TData tDummy;
; 412  : 			kStream >> tDummy;

	lea	eax, DWORD PTR _tDummy$225722[esp+36]
	push	eax
$LN63@ReadHashed@2:
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed@2:
	mov	eax, DWORD PTR _iI$225711[esp+36]
	inc	eax
	mov	DWORD PTR _iI$225711[esp+36], eax
	cmp	eax, DWORD PTR _uiNumEntries$[esp+36]
	jb	$LL7@ReadHashed@2
	pop	edi
	pop	ebp
$LN5@ReadHashed@2:
	pop	esi
	pop	ebx

; 413  : 		}
; 414  : 	}
; 415  : }

	add	esp, 20					; 00000014H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??_GCvTraitEntry@@QAEPAXI@Z			; CvTraitEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTraitEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTraitEntry@@QAEPAXI@Z PROC			; CvTraitEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTraitEntry@@QAE@XZ			; CvTraitEntry::~CvTraitEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTraitEntry@@QAEPAXI@Z ENDP			; CvTraitEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@2:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@2
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert
_TEXT	ENDS
PUBLIC	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
$T251677 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::resize, COMDAT
; _this$ = ecx

; 718  : 		if (size() < _Newsize)

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	cmp	edx, eax
	jbe	SHORT $LN36@resize@4

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
$LN36@resize@4:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@4

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T251677[esp+12]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN1@resize@4:
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
_TEXT	ENDS
PUBLIC	??0CvTraitEntry@@QAE@XZ				; CvTraitEntry::CvTraitEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvTraitEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$3
__ehfuncinfo$??0CvTraitEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvTraitEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvTraitEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTraitEntry@@QAE@XZ PROC				; CvTraitEntry::CvTraitEntry, COMDAT
; _this$ = ecx

; 165  : {

	push	-1
	push	__ehhandler$??0CvTraitEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvTraitEntry@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], ebx
	mov	DWORD PTR [esi+340], ebx
	mov	DWORD PTR [esi+344], ebx
	mov	DWORD PTR [esi+348], ebx
	mov	DWORD PTR [esi+352], ebx
	mov	DWORD PTR [esi+356], ebx
	mov	DWORD PTR [esi+360], ebx
	mov	DWORD PTR [esi+364], ebx
	mov	DWORD PTR [esi+368], ebx
	mov	DWORD PTR [esi+372], ebx
	mov	DWORD PTR [esi+376], ebx
	mov	DWORD PTR [esi+380], ebx
	mov	DWORD PTR [esi+384], ebx
	mov	DWORD PTR [esi+388], ebx
	mov	DWORD PTR [esi+392], ebx
	mov	DWORD PTR [esi+396], ebx
	mov	DWORD PTR [esi+400], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], eax
	mov	DWORD PTR [esi+420], eax
	mov	DWORD PTR [esi+424], ebx
	mov	DWORD PTR [esi+428], eax
	mov	DWORD PTR [esi+432], ebx
	mov	DWORD PTR [esi+436], ebx
	mov	DWORD PTR [esi+440], ebx
	mov	DWORD PTR [esi+444], ebx
	mov	DWORD PTR [esi+448], ebx
	mov	DWORD PTR [esi+452], ebx
	mov	DWORD PTR [esi+456], ebx
	mov	DWORD PTR [esi+460], ebx
	mov	DWORD PTR [esi+464], ebx
	mov	DWORD PTR [esi+468], ebx
	mov	DWORD PTR [esi+472], ebx
	mov	DWORD PTR [esi+476], ebx
	mov	DWORD PTR [esi+480], ebx
	mov	DWORD PTR [esi+484], ebx
	mov	DWORD PTR [esi+488], ebx
	mov	DWORD PTR [esi+492], ebx
	mov	DWORD PTR [esi+496], ebx
	mov	DWORD PTR [esi+500], ebx
	mov	DWORD PTR [esi+504], ebx
	mov	DWORD PTR [esi+508], ebx
	mov	DWORD PTR [esi+512], ebx
	mov	DWORD PTR [esi+516], ebx
	mov	DWORD PTR [esi+520], ebx
	mov	DWORD PTR [esi+524], ebx
	mov	DWORD PTR [esi+548], eax
	mov	DWORD PTR [esi+556], eax
	mov	DWORD PTR [esi+560], eax
	lea	ecx, DWORD PTR [esi+600]
	mov	DWORD PTR [esi+564], eax
	mov	DWORD PTR [esi+568], eax
	mov	DWORD PTR [esi+572], eax
	mov	BYTE PTR [esi+576], bl
	mov	BYTE PTR [esi+577], bl
	mov	BYTE PTR [esi+578], bl
	mov	BYTE PTR [esi+579], bl
	mov	BYTE PTR [esi+580], bl
	mov	BYTE PTR [esi+581], bl
	mov	BYTE PTR [esi+582], bl
	mov	BYTE PTR [esi+583], bl
	mov	BYTE PTR [esi+584], bl
	mov	BYTE PTR [esi+585], bl
	mov	BYTE PTR [esi+586], bl
	mov	BYTE PTR [esi+587], bl
	mov	BYTE PTR [esi+588], bl
	mov	BYTE PTR [esi+589], bl
	mov	BYTE PTR [esi+590], bl
	mov	BYTE PTR [esi+591], bl
	mov	BYTE PTR [esi+592], bl
	mov	BYTE PTR [esi+593], bl
	mov	BYTE PTR [esi+594], bl
	mov	BYTE PTR [esi+595], bl
	mov	BYTE PTR [esi+596], bl
	mov	BYTE PTR [esi+597], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+628], ebx
	mov	DWORD PTR [esi+632], ebx
	mov	DWORD PTR [esi+636], ebx
	mov	DWORD PTR [esi+640], ebx
	mov	DWORD PTR [esi+644], ebx
	mov	DWORD PTR [esi+648], ebx
	mov	DWORD PTR [esi+652], ebx
	mov	DWORD PTR [esi+656], ebx
	mov	DWORD PTR [esi+660], ebx
	mov	DWORD PTR [esi+664], ebx
	mov	DWORD PTR [esi+676], ebx
	lea	edi, DWORD PTR [esi+688]
	mov	DWORD PTR [esi+680], ebx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+36], 1
	mov	DWORD PTR [esi+684], ebx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR [edi+4], eax
	mov	BYTE PTR [eax+21], 1
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [esi+704], ebx
	mov	DWORD PTR [esi+708], ebx
	mov	DWORD PTR [esi+712], ebx

; 166  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+716], ebx
	mov	DWORD PTR [esi+724], ebx
	mov	DWORD PTR [esi+728], ebx
	mov	DWORD PTR [esi+732], ebx
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 600				; 00000258H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 688				; 000002b0H
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	jmp	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
__ehhandler$??0CvTraitEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTraitEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTraitEntry@@QAE@XZ ENDP				; CvTraitEntry::CvTraitEntry
PUBLIC	??1CvPlayerTraits@@QAE@XZ			; CvPlayerTraits::~CvPlayerTraits
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1CvPlayerTraits@@QAE@XZ DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$??1CvPlayerTraits@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvPlayerTraits@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$12
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlayerTraits@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlayerTraits@@QAE@XZ PROC				; CvPlayerTraits::~CvPlayerTraits, COMDAT
; _this$ = ecx

; 1547 : {

	push	-1
	push	__ehhandler$??1CvPlayerTraits@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR __$EHRec$[esp+32], 12		; 0000000cH

; 1548 : 	Uninit();

	call	?Uninit@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Uninit

; 1549 : }

	mov	eax, DWORD PTR [esi+836]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN21@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@CvPlayerTr:
	mov	DWORD PTR [esi+836], edi
	mov	DWORD PTR [esi+840], edi
	mov	DWORD PTR [esi+844], edi
	mov	eax, DWORD PTR [esi+820]
	cmp	eax, edi
	je	SHORT $LN28@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@CvPlayerTr:
	mov	DWORD PTR [esi+820], edi
	mov	DWORD PTR [esi+824], edi
	mov	DWORD PTR [esi+828], edi
	mov	eax, DWORD PTR [esi+804]
	cmp	eax, edi
	je	SHORT $LN35@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@CvPlayerTr:
	mov	DWORD PTR [esi+804], edi
	mov	DWORD PTR [esi+808], edi
	mov	DWORD PTR [esi+812], edi
	mov	eax, DWORD PTR [esi+788]
	cmp	eax, edi
	je	SHORT $LN42@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN42@CvPlayerTr:
	mov	DWORD PTR [esi+788], edi
	mov	DWORD PTR [esi+792], edi
	mov	DWORD PTR [esi+796], edi
	mov	eax, DWORD PTR [esi+772]
	cmp	eax, edi
	je	SHORT $LN49@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@CvPlayerTr:
	mov	DWORD PTR [esi+772], edi
	mov	DWORD PTR [esi+776], edi
	mov	DWORD PTR [esi+780], edi
	mov	eax, DWORD PTR [esi+756]
	cmp	eax, edi
	je	SHORT $LN56@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@CvPlayerTr:
	mov	DWORD PTR [esi+756], edi
	mov	DWORD PTR [esi+760], edi
	mov	DWORD PTR [esi+764], edi
	mov	eax, DWORD PTR [esi+740]
	cmp	eax, edi
	je	SHORT $LN63@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN63@CvPlayerTr:
	mov	DWORD PTR [esi+740], edi
	mov	DWORD PTR [esi+744], edi
	mov	DWORD PTR [esi+748], edi
	mov	eax, DWORD PTR [esi+700]
	cmp	eax, edi
	je	SHORT $LN70@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN70@CvPlayerTr:
	mov	DWORD PTR [esi+700], edi
	mov	DWORD PTR [esi+704], edi
	mov	DWORD PTR [esi+708], edi
	mov	eax, DWORD PTR [esi+640]
	lea	ecx, DWORD PTR [esi+652]
	mov	BYTE PTR __$EHRec$[esp+32], 3
	cmp	eax, ecx
	je	SHORT $LN74@CvPlayerTr
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN74@CvPlayerTr:
	mov	DWORD PTR [esi+620], edi
	mov	eax, DWORD PTR [esi+628]
	cmp	eax, edi
	je	SHORT $LN93@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN93@CvPlayerTr:
	mov	DWORD PTR [esi+628], edi
	mov	DWORD PTR [esi+632], edi
	mov	DWORD PTR [esi+636], edi
	mov	eax, DWORD PTR [esi+608]
	cmp	eax, edi
	je	SHORT $LN102@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN102@CvPlayerTr:
	mov	DWORD PTR [esi+608], edi
	mov	DWORD PTR [esi+612], edi
	mov	DWORD PTR [esi+616], edi
	mov	eax, DWORD PTR [esi+32]
	cmp	eax, edi
	je	SHORT $LN109@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN109@CvPlayerTr:
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+8], edi
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, edi
	je	SHORT $LN118@CvPlayerTr
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN118@CvPlayerTr:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 604				; 0000025cH
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 620				; 0000026cH
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 640				; 00000280H
	jmp	??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 736				; 000002e0H
	jmp	??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 768				; 00000300H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 784				; 00000310H
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 800				; 00000320H
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 816				; 00000330H
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 832				; 00000340H
	jmp	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
__ehhandler$??1CvPlayerTraits@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPlayerTraits@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlayerTraits@@QAE@XZ ENDP				; CvPlayerTraits::~CvPlayerTraits
PUBLIC	?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z ; CvPlayerTraits::AddUniqueLuxuries
EXTRN	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlot::setResourceType
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Ogtpy
;	COMDAT ?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
tv433 = -8						; size = 4
_iArea$223293 = -8					; size = 4
$T252725 = -4						; size = 4
_iNumUniquesFound$223312 = -4				; size = 4
$T252720 = -4						; size = 4
_pCity$ = 8						; size = 4
?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z PROC ; CvPlayerTraits::AddUniqueLuxuries, COMDAT
; _this$ = ecx

; 2384 : {

	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 2385 : 	// Still have more of these cities to award?
; 2386 : 	if (m_iUniqueLuxuryCities > m_iUniqueLuxuryCitiesPlaced)

	mov	eax, DWORD PTR [ebx+292]
	cmp	eax, DWORD PTR [ebx+300]
	jle	$LN1@AddUniqueL

; 2387 : 	{
; 2388 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area BEGIN
; 2389 : 		if (m_pPlayer->GetNumCitiesFounded() == 1)

	mov	ecx, DWORD PTR [ebx+4]
	call	?GetNumCitiesFounded@CvPlayer@@QBEHXZ	; CvPlayer::GetNumCitiesFounded
	cmp	eax, 1
	je	$LN1@AddUniqueL
	push	esi

; 2390 : 		{
; 2391 : 			return;
; 2392 : 		}
; 2393 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area END
; 2394 : 
; 2395 : 		// NQMP GJS - Spice Islanders must be coastal BEGIN
; 2396 : 		if (!pCity->isCoastal())

	mov	esi, DWORD PTR _pCity$[esp+12]
	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN94@AddUniqueL
	push	ebp
	push	edi

; 2397 : 		{
; 2398 : 			return;
; 2399 : 		}
; 2400 : 		// NQMP GJS - Spice Islanders must be coastal END
; 2401 : 
; 2402 : 		int iArea = pCity->getArea();

	mov	ecx, esi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea

; 2403 : 
; 2404 : 		// If we have to be in a new area, check to see if this area is okay
; 2405 : 		if (m_bUniqueLuxuryRequiresNewArea)

	cmp	BYTE PTR [ebx+345], 0
	mov	DWORD PTR _iArea$223293[esp+24], eax
	je	$LN88@AddUniqueL

; 2406 : 		{
; 2407 : 			/* NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area
; 2408 : 			// Can't be the capital itself of the area where the capital was founded
; 2409 : 			if (m_pPlayer->GetNumCitiesFounded() == 1)
; 2410 : 			{
; 2411 : 				return;
; 2412 : 			}
; 2413 : 			*/
; 2414 : 
; 2415 : 			CvPlot *pOriginalCapitalPlot = GC.getMap().plot(m_pPlayer->GetOriginalCapitalX(), m_pPlayer->GetOriginalCapitalY());

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T252725[esp+24], edi
	call	?GetOriginalCapitalY@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalY
	mov	ecx, DWORD PTR [ebx+4]
	mov	ebp, eax
	call	?GetOriginalCapitalX@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalX
	cmp	eax, -2147483647			; 80000001H
	je	$LN87@AddUniqueL
	cmp	ebp, -2147483647			; 80000001H
	je	$LN87@AddUniqueL
	cmp	BYTE PTR [edi+4056], 0
	mov	ecx, DWORD PTR [edi+4020]
	je	SHORT $LN86@AddUniqueL
	test	eax, eax
	jge	SHORT $LN30@AddUniqueL
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN32@AddUniqueL
$LN30@AddUniqueL:
	cmp	eax, ecx
	jl	SHORT $LN86@AddUniqueL
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN32@AddUniqueL
$LN86@AddUniqueL:
	mov	esi, eax
$LN32@AddUniqueL:
	mov	edx, DWORD PTR $T252725[esp+24]
	cmp	BYTE PTR [edx+4057], 0
	mov	edi, DWORD PTR [edi+4024]
	je	SHORT $LN93@AddUniqueL
	test	ebp, ebp
	jge	SHORT $LN40@AddUniqueL
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN42@AddUniqueL
$LN40@AddUniqueL:
	cmp	ebp, edi
	jl	SHORT $LN93@AddUniqueL
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN42@AddUniqueL
$LN93@AddUniqueL:
	mov	edx, ebp
$LN42@AddUniqueL:
	test	esi, esi
	jl	SHORT $LN87@AddUniqueL
	cmp	esi, ecx
	jge	SHORT $LN87@AddUniqueL
	test	edx, edx
	jl	SHORT $LN87@AddUniqueL
	cmp	edx, edi
	jge	SHORT $LN87@AddUniqueL
	mov	eax, DWORD PTR $T252725[esp+24]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]

; 2416 : 			if (pOriginalCapitalPlot)

	test	ecx, ecx
	je	SHORT $LN87@AddUniqueL

; 2417 : 			{
; 2418 : 				if (pOriginalCapitalPlot->getArea() == iArea)

	mov	edx, DWORD PTR _iArea$223293[esp+24]
	cmp	DWORD PTR [ecx+356], edx
	je	$LN95@AddUniqueL
$LN87@AddUniqueL:

; 2419 : 				{
; 2420 : 					return;
; 2421 : 				}
; 2422 : 			}
; 2423 : 
; 2424 : 			// Already in the list?
; 2425 : 			if (std::find (m_aUniqueLuxuryAreas.begin(), m_aUniqueLuxuryAreas.end(), iArea) != m_aUniqueLuxuryAreas.end())

	mov	esi, DWORD PTR [ebx+704]
	mov	eax, DWORD PTR [ebx+700]
	lea	ecx, DWORD PTR _iArea$223293[esp+24]
	push	ecx
	push	esi
	push	eax
	lea	edx, DWORD PTR $T252720[esp+36]
	push	edx
	call	??$find@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@0ABH@Z ; std::find<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [eax], esi
	jne	$LN95@AddUniqueL
$LN88@AddUniqueL:

; 2426 : 			{
; 2427 : 				return;
; 2428 : 			}
; 2429 : 		}
; 2430 : 
; 2431 : 		m_aUniqueLuxuryAreas.push_back(iArea);  		// Store area

	lea	eax, DWORD PTR _iArea$223293[esp+24]
	lea	edi, DWORD PTR [ebx+696]
	push	eax
	mov	ecx, edi
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 2432 : 		int iNumUniqueResourcesGiven = m_aUniqueLuxuryAreas.size();

	mov	esi, DWORD PTR [edi+8]
	sub	esi, DWORD PTR [edi+4]

; 2433 : 		m_iUniqueLuxuryCitiesPlaced++;   // One less to give out

	inc	DWORD PTR [ebx+300]

; 2434 : 
; 2435 : 		// Loop through all resources and see if we can find this many unique ones
; 2436 : 		ResourceTypes eResourceToGive = NO_RESOURCE;
; 2437 : 		int iNumUniquesFound = 0;

	xor	edi, edi

; 2438 : #ifdef AUI_WARNING_FIXES
; 2439 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2440 : #else
; 2441 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	sar	esi, 2
	mov	DWORD PTR _iNumUniquesFound$223312[esp+24], edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN95@AddUniqueL
	npad	4
$LL91@AddUniqueL:

; 2442 : #endif
; 2443 : 		{
; 2444 : 			ResourceTypes eResource = (ResourceTypes) iResourceLoop;
; 2445 : 			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ebp, eax

; 2446 : 			if (pkResource != NULL && pkResource->GetRequiredCivilization() == m_pPlayer->getCivilizationType())

	test	ebp, ebp
	je	SHORT $LN5@AddUniqueL
	mov	ecx, DWORD PTR [ebx+4]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	mov	ecx, ebp
	mov	DWORD PTR tv433[esp+24], eax
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	mov	ecx, DWORD PTR tv433[esp+24]
	cmp	eax, ecx
	jne	SHORT $LN5@AddUniqueL

; 2447 : 			{
; 2448 : 				iNumUniquesFound++;

	mov	eax, DWORD PTR _iNumUniquesFound$223312[esp+24]
	inc	eax
	mov	DWORD PTR _iNumUniquesFound$223312[esp+24], eax

; 2449 : 				if (iNumUniquesFound == iNumUniqueResourcesGiven)

	cmp	eax, esi
	je	SHORT $LN83@AddUniqueL
$LN5@AddUniqueL:

; 2438 : #ifdef AUI_WARNING_FIXES
; 2439 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2440 : #else
; 2441 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	SHORT $LL91@AddUniqueL
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 2461 : 		}
; 2462 : 	}
; 2463 : }

	add	esp, 8
	ret	4
$LN83@AddUniqueL:

; 2450 : 				{
; 2451 : 					eResourceToGive = eResource;
; 2452 : 					break;
; 2453 : 				}
; 2454 : 			}
; 2455 : 		}
; 2456 : 
; 2457 : 		if (eResourceToGive != NO_RESOURCE)

	cmp	edi, -1
	je	SHORT $LN95@AddUniqueL

; 2458 : 		{
; 2459 : 			pCity->plot()->setResourceType(NO_RESOURCE, 0, true);

	mov	esi, DWORD PTR _pCity$[esp+20]
	push	1
	push	0
	push	-1
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType

; 2460 : 			pCity->plot()->setResourceType(eResourceToGive, m_iUniqueLuxuryQuantity, true);

	mov	ecx, DWORD PTR [ebx+296]
	push	1
	push	ecx
	push	edi
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
$LN95@AddUniqueL:
	pop	edi
	pop	ebp
$LN94@AddUniqueL:
	pop	esi
$LN1@AddUniqueL:
	pop	ebx

; 2461 : 		}
; 2462 : 	}
; 2463 : }

	add	esp, 8
	ret	4
?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z ENDP ; CvPlayerTraits::AddUniqueLuxuries
_TEXT	ENDS
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$0
__ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
$T252913 = 12						; size = 4
__Val$ = 12						; size = 1
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1918 : 		{	// construct from _Count * _Val

	push	-1
	push	__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	movzx	eax, BYTE PTR __Val$[esp+12]
	push	esi
	neg	eax
	push	edi
	mov	edi, DWORD PTR __Count$[esp+20]
	sbb	eax, eax
	mov	DWORD PTR $T252913[esp+20], eax
	mov	esi, ecx
	lea	edx, DWORD PTR $T252913[esp+20]
	lea	eax, DWORD PTR [edi+31]
	push	edx
	shr	eax, 5
	lea	ecx, DWORD PTR [esi+4]
	push	eax
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], 0
	call	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n

; 1919 : 		_Trim(_Count);

	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 1920 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXI@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T252979 = -24						; size = 24
__Newsize$ = 8						; size = 4
?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXI@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize, COMDAT
; _this$ = ecx

; 713  : 		resize(_Newsize, _Ty());

	mov	edx, DWORD PTR $T252979[esp]
	sub	esp, 24					; 00000018H
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR $T252979[esp+52]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR $T252979[esp+56]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR $T252979[esp+60]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR $T252979[esp+64]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR $T252979[esp+68]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR __Newsize$[esp+44]
	push	eax
	call	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize

; 714  : 		}

	add	esp, 24					; 00000018H
	ret	4
?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z
_TEXT	SEGMENT
$T253014 = -4						; size = 1
__Cat$253018 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$253018[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T253014[esp+12], 0
	mov	eax, DWORD PTR $T253014[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@5
	xor	esi, esi
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@5:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@6
	xor	esi, esi
	jmp	SHORT $LN4@insert@6
$LN3@insert@6:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert@6:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::insert
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTraitEntry@@@@YAXAAPAVCvTraitEntry@@@Z ; SAFE_DELETE<CvTraitEntry>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvTraitEntry@@@@YAXAAPAVCvTraitEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTraitEntry@@@@YAXAAPAVCvTraitEntry@@@Z PROC ; SAFE_DELETE<CvTraitEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET
	mov	ecx, esi
	call	??1CvTraitEntry@@QAE@XZ			; CvTraitEntry::~CvTraitEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTraitEntry@@@@YAXAAPAVCvTraitEntry@@@Z ENDP ; SAFE_DELETE<CvTraitEntry>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_v$213776 = -4						; size = 4
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >, COMDAT

; 83   : {

	push	ecx
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+8]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	cmp	edi, ecx
	je	SHORT $LN20@SerializeT
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN45@SerializeT
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN45@SerializeT:
	mov	DWORD PTR [esi+8], ebx
$LN20@SerializeT:

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	edi, DWORD PTR _loadFrom$[esp+12]
	lea	eax, DWORD PTR _count$[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _count$[esp+16], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR _count$[esp+12], ebx
	jbe	SHORT $LN1@SerializeT
	push	ebp
$LL117@SerializeT:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	ecx, DWORD PTR _v$213776[esp+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN60@SerializeT
	xor	eax, eax
	jmp	SHORT $LN61@SerializeT
$LN60@SerializeT:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
$LN61@SerializeT:
	mov	ecx, DWORD PTR [esi+8]
	mov	ebp, ecx
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, eax
	jae	SHORT $LN53@SerializeT
	mov	edx, DWORD PTR _v$213776[esp+20]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN2@SerializeT
$LN53@SerializeT:
	lea	eax, DWORD PTR _v$213776[esp+20]
	push	eax
	push	1
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN2@SerializeT:
	inc	ebx
	cmp	ebx, DWORD PTR _count$[esp+16]
	jb	SHORT $LL117@SerializeT
	pop	ebp
$LN1@SerializeT:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	pop	ecx
	ret	0
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
$T253845 = -4						; size = 1
__Cat$253848 = 8					; size = 1
$T253814 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@4
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@4
$LN9@push_back@4:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@4:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$253848[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T253845[esp+16], 0
	mov	ecx, DWORD PTR $T253845[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 24					; 00000018H
	add	edi, 24					; 00000018H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@4:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T253814[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T253871 = -32						; size = 8
__Oldend$214983 = -24					; size = 8
$T253874 = -16						; size = 8
$T253872 = -16						; size = 8
$T253873 = -8						; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2296 : 		{	// make room to insert _Count elements at _Where

	sub	esp, 32					; 00000020H
	push	ebx

; 2297 : 		size_type _Off = _Where - begin();
; 2298 : 
; 2299 :  #if _HAS_ITERATOR_DEBUGGING
; 2300 : 		if (end() < _Where)
; 2301 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2302 : 		bool _Realloc = capacity() - size() < _Count;
; 2303 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2304 : 
; 2305 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Where$[esp+36]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	sub	ebp, eax
	sar	ebp, 2
	shl	ebp, 5
	add	ebp, DWORD PTR __Where$[esp+44]
	test	ebx, ebx
	je	$LN1@Insert_x

; 2306 : 			;
; 2307 : 		else if (max_size() - size() < _Count)

	mov	eax, DWORD PTR [esi]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN4@Insert_x

; 2308 : 			_Xlen();	// result too long

	mov	ecx, esi
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN97@Insert_x:
$LN4@Insert_x:
	push	edi

; 2309 : 		else
; 2310 : 			{	// worth doing
; 2311 : 			_Myvec.resize(_Nw(size() + _Count), 0);

	lea	edx, DWORD PTR [eax+ebx+31]
	push	0
	shr	edx, 5
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 2312 : 			if (size() == 0)

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LN2@Insert_x
	pop	edi

; 2313 : 				_Mysize += _Count;

	mov	DWORD PTR [esi], ebx
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN2@Insert_x:

; 2314 : 			else
; 2315 : 				{	// make room and copy down suffix
; 2316 : 				iterator _Oldend = end();

	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR __Oldend$214983[esp+48], ebx
	mov	DWORD PTR __Oldend$214983[esp+52], 0
	test	edi, edi
	jbe	SHORT $LN60@Insert_x
	push	edi
	lea	ecx, DWORD PTR __Oldend$214983[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN60@Insert_x:

; 2317 : 				_Mysize += _Count;

	mov	eax, DWORD PTR __Count$[esp+44]
	add	eax, edi
	mov	DWORD PTR [esi], eax

; 2318 : 				std::copy_backward(begin() + _Off, _Oldend, end());

	mov	DWORD PTR $T253871[esp+48], ebx
	mov	DWORD PTR $T253871[esp+52], 0
	je	SHORT $LN79@Insert_x
	push	eax
	lea	ecx, DWORD PTR $T253871[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN79@Insert_x:
	push	ebp
	lea	ecx, DWORD PTR $T253873[esp+52]
	push	ecx
	lea	ecx, DWORD PTR $T253872[esp+56]
	mov	DWORD PTR $T253872[esp+56], ebx
	mov	DWORD PTR $T253872[esp+60], 0
	call	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
	mov	edx, DWORD PTR $T253871[esp+52]
	mov	ecx, DWORD PTR $T253871[esp+48]
	push	edx
	mov	edx, DWORD PTR __Oldend$214983[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Oldend$214983[esp+56]
	push	edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T253874[esp+72]
	push	ecx
	call	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
	add	esp, 28					; 0000001cH
	pop	edi
$LN1@Insert_x:
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN96@Insert_x:
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
PUBLIC	?DeleteArray@CvTraitXMLEntries@@QAEXXZ		; CvTraitXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?DeleteArray@CvTraitXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvTraitXMLEntries@@QAEXXZ PROC		; CvTraitXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 1522 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 1523 : 	for(std::vector<CvTraitEntry*>::iterator it = m_paTraitEntries.begin(); it != m_paTraitEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 1524 : 	{
; 1525 : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvTraitEntry@@QAE@XZ			; CvTraitEntry::~CvTraitEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 1526 : 	}
; 1527 : 
; 1528 : 	m_paTraitEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 1529 : }

	ret	0
?DeleteArray@CvTraitXMLEntries@@QAEXXZ ENDP		; CvTraitXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z
_TEXT	SEGMENT
$T254503 = -4						; size = 1
__Cat$254506 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@5
	xor	eax, eax
	jmp	SHORT $LN10@push_back@5
$LN9@push_back@5:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@5:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$254506[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T254503[esp+12], 0
	mov	eax, DWORD PTR $T254503[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@5:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z
_TEXT	SEGMENT
$T254651 = -4						; size = 1
__Cat$254654 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@6
	xor	eax, eax
	jmp	SHORT $LN10@push_back@6
$LN9@push_back@6:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@6:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$254654[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T254651[esp+12], 0
	mov	eax, DWORD PTR $T254651[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@6:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator>><int>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z
_TEXT	SEGMENT
$T254949 = -28						; size = 1
_count$ = -28						; size = 4
_v$213954 = -24						; size = 24
_loadFrom$ = 8						; size = 4
__Cat$254953 = 12					; size = 1
$T254951 = 12						; size = 1
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >, COMDAT

; 83   : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+36]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	xor	ebx, ebx
	cmp	ecx, eax
	je	SHORT $LN20@SerializeT@2
	mov	BYTE PTR $T254949[esp+40], bl
	mov	edx, DWORD PTR $T254949[esp+40]
	push	edx
	mov	edx, DWORD PTR __Cat$254953[esp+40]
	push	edx
	mov	edx, DWORD PTR $T254951[esp+44]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN20@SerializeT@2:

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebp, DWORD PTR _loadFrom$[esp+36]
	lea	eax, DWORD PTR _count$[esp+40]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR _count$[esp+44], ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	cmp	DWORD PTR _count$[esp+40], ebx
	jbe	SHORT $LN1@SerializeT@2
	push	edi
$LL3@SerializeT@2:

; 84   : 	container.clear();

	lea	esi, DWORD PTR _v$213954[esp+44]
	mov	edi, 6
	npad	5

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

$LL49@SerializeT@2:
	push	esi
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL49@SerializeT@2

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$213954[esp+44]
	push	ecx
	mov	ecx, DWORD PTR _container$[esp+44]
	call	?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back
	inc	ebx
	cmp	ebx, DWORD PTR _count$[esp+44]
	jb	SHORT $LL3@SerializeT@2
	pop	edi
$LN1@SerializeT@2:
	pop	esi
	pop	ebp
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 28					; 0000001cH
	ret	0
??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z
_TEXT	SEGMENT
__Tmp$255052 = -16					; size = 8
__Tmp$255107 = -8					; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 1
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2290 : 		{	// insert _Count * _Val at _Where

	sub	esp, 16					; 00000010H

; 2291 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	eax, DWORD PTR __Where$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR __Count$[esp+16]
	push	esi
	push	edi
	push	ebx
	mov	esi, ecx
	mov	ecx, DWORD PTR __Where$[esp+28]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x

; 2292 : 		std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	mov	esi, DWORD PTR [esi+8]
	mov	edi, eax
	lea	edx, DWORD PTR [edi+ebx]
	xor	eax, eax
	push	edx
	lea	ecx, DWORD PTR __Tmp$255052[esp+32]
	mov	DWORD PTR __Tmp$255052[esp+32], esi
	mov	DWORD PTR __Tmp$255052[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	xor	eax, eax
	push	edi
	lea	ecx, DWORD PTR __Tmp$255107[esp+32]
	mov	DWORD PTR __Tmp$255107[esp+32], esi
	mov	DWORD PTR __Tmp$255107[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$255052[esp+32]
	mov	edx, DWORD PTR __Tmp$255052[esp+28]
	lea	eax, DWORD PTR __Val$[esp+24]
	push	eax
	mov	eax, DWORD PTR __Tmp$255107[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Tmp$255107[esp+36]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 2293 : 		}

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
PUBLIC	??1CvTraitXMLEntries@@QAE@XZ			; CvTraitXMLEntries::~CvTraitXMLEntries
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvTraitXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTraitXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvTraitXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTraitXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTraitXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTraitXMLEntries@@QAE@XZ PROC			; CvTraitXMLEntries::~CvTraitXMLEntries, COMDAT
; _this$ = ecx

; 1504 : {

	push	-1
	push	__ehhandler$??1CvTraitXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 1505 : 	DeleteArray();

	call	?DeleteArray@CvTraitXMLEntries@@QAEXXZ	; CvTraitXMLEntries::DeleteArray

; 1506 : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvTraitXML
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvTraitXML:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTraitXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
__ehhandler$??1CvTraitXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTraitXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTraitXMLEntries@@QAE@XZ ENDP			; CvTraitXMLEntries::~CvTraitXMLEntries
PUBLIC	?InitPlayerTraits@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::InitPlayerTraits
EXTRN	?getNumSpecialistInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumSpecialistInfos
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
EXTRN	?ChangeWoundedUnitDamageMod@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeWoundedUnitDamageMod
EXTRN	?isMajorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMajorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?InitPlayerTraits@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
_iSpecialistLoop$223071 = -100				; size = 4
_iImprovementLoop$223061 = -100				; size = 4
_iFeatureLoop$223051 = -100				; size = 4
_iI$223016 = -96					; size = 4
tv3696 = -92						; size = 4
tv3597 = -92						; size = 4
tv3498 = -92						; size = 4
__Tmp$255634 = -92					; size = 8
tv3974 = -84						; size = 4
$T255150 = -84						; size = 4
_traitUnit$223095 = -80					; size = 8
_yields$223060 = -72					; size = 24
_yields$223070 = -48					; size = 24
_yields$223080 = -24					; size = 24
?InitPlayerTraits@CvPlayerTraits@@QAEXXZ PROC		; CvPlayerTraits::InitPlayerTraits, COMDAT
; _this$ = ecx

; 1578 : {

	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1579 : 
; 1580 : 	// precompute the traits our leader has
; 1581 : 	m_vPotentiallyActiveLeaderTraits.clear();

	mov	eax, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [esi+32]
	lea	ebx, DWORD PTR [esi+28]
	push	edi
	cmp	edx, eax
	je	SHORT $LN79@InitPlayer
	mov	ecx, eax
	cmp	eax, eax
	je	SHORT $LN104@InitPlayer
	npad	4
$LL106@InitPlayer:
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	add	ecx, 4
	add	edx, 4
	cmp	ecx, eax
	jne	SHORT $LL106@InitPlayer
$LN104@InitPlayer:
	mov	DWORD PTR [ebx+8], edx
$LN79@InitPlayer:

; 1582 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	test	eax, eax
	jle	$LN60@InitPlayer

; 1583 : 	{
; 1584 : 		m_vLeaderHasTrait[iI] = false;

	xor	ebp, ebp
$LL633@InitPlayer:
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, ebp
	test	edi, edi
	je	SHORT $LN129@InitPlayer
	jge	SHORT $LN130@InitPlayer
	mov	ecx, edi
	neg	ecx
	je	SHORT $LN130@InitPlayer
	or	edx, -1
	sub	edx, edi
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ecx, -4					; fffffffcH
	sub	ecx, edx
	add	eax, ecx
	jmp	SHORT $LN638@InitPlayer
$LN130@InitPlayer:
	mov	edx, edi
	shr	edx, 5
	lea	eax, DWORD PTR [eax+edx*4]
$LN638@InitPlayer:
	mov	ecx, edi
	and	ecx, 31					; 0000001fH
$LN129@InitPlayer:
	mov	edx, 1
	shl	edx, cl
	not	edx
	and	DWORD PTR [eax], edx

; 1585 : 		if (m_pPlayer && m_pPlayer->isMajorCiv() && m_pPlayer->isAlive() && m_pPlayer->getLeaderInfo().hasTrait( (TraitTypes)iI ))

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN61@InitPlayer
	call	?isMajorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMajorCiv
	test	al, al
	je	SHORT $LN61@InitPlayer
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN61@InitPlayer
	push	edi
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	ecx, eax
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	test	al, al
	je	SHORT $LN61@InitPlayer

; 1586 : 		{
; 1587 : 			m_vLeaderHasTrait[iI] = true;

	mov	eax, DWORD PTR [esi+16]
	xor	ecx, ecx
	mov	DWORD PTR __Tmp$255634[esp+120], ecx
	push	edi
	lea	ecx, DWORD PTR __Tmp$255634[esp+120]
	mov	DWORD PTR __Tmp$255634[esp+120], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$255634[esp+120]
	mov	eax, DWORD PTR __Tmp$255634[esp+116]
	mov	edx, 1
	shl	edx, cl

; 1588 : 			m_vPotentiallyActiveLeaderTraits.push_back( (TraitTypes)iI );

	mov	ecx, ebx
	mov	DWORD PTR $T255150[esp+116], edi
	or	DWORD PTR [eax], edx
	lea	eax, DWORD PTR $T255150[esp+116]
	push	eax
	call	?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
$LN61@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	edi, eax
	jl	$LL633@InitPlayer
$LN60@InitPlayer:

; 1589 : 		}
; 1590 : 	}
; 1591 : #ifdef AUI_WARNING_FIXES
; 1592 : 	for (uint iI = 0; iI < GC.getNumTraitInfos(); iI++)
; 1593 : #else
; 1594 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$223016[esp+116], 0
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	test	eax, eax
	jle	$LN56@InitPlayer
	npad	7
$LL626@InitPlayer:

; 1595 : #endif
; 1596 : 
; 1597 : 	{
; 1598 : 		if(HasTrait((TraitTypes)iI))

	mov	ecx, DWORD PTR _iI$223016[esp+116]
	push	ecx
	mov	ecx, esi
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	test	al, al
	je	$LN57@InitPlayer

; 1599 : 		{
; 1600 : 			CvTraitEntry* trait = GC.getTraitInfo((TraitTypes)iI);

	mov	edx, DWORD PTR _iI$223016[esp+116]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	ebp, eax

; 1601 : 			m_iGreatPeopleRateModifier += trait->GetGreatPeopleRateModifier();

	mov	eax, DWORD PTR [ebp+264]
	add	DWORD PTR [esi+44], eax

; 1602 : 			m_iGreatScientistRateModifier += trait->GetGreatScientistRateModifier();

	mov	ecx, DWORD PTR [ebp+268]
	add	DWORD PTR [esi+48], ecx

; 1603 : 			m_iGreatGeneralRateModifier += trait->GetGreatGeneralRateModifier();

	mov	edx, DWORD PTR [ebp+272]
	add	DWORD PTR [esi+52], edx

; 1604 : 			m_iGreatGeneralExtraBonus += trait->GetGreatGeneralExtraBonus();

	mov	eax, DWORD PTR [ebp+276]
	add	DWORD PTR [esi+56], eax

; 1605 : 			m_iGreatPersonGiftInfluence += trait->GetGreatPersonGiftInfluence();

	mov	ecx, DWORD PTR [ebp+280]
	add	DWORD PTR [esi+60], ecx

; 1606 : 			m_iLevelExperienceModifier += trait->GetLevelExperienceModifier();

	mov	edx, DWORD PTR [ebp+260]
	add	DWORD PTR [esi+64], edx

; 1607 : 			m_iMaxGlobalBuildingProductionModifier += trait->GetMaxGlobalBuildingProductionModifier();

	mov	eax, DWORD PTR [ebp+284]
	add	DWORD PTR [esi+68], eax

; 1608 : 			m_iMaxTeamBuildingProductionModifier += trait->GetMaxTeamBuildingProductionModifier();

	mov	ecx, DWORD PTR [ebp+288]
	add	DWORD PTR [esi+72], ecx

; 1609 : 			m_iMaxPlayerBuildingProductionModifier += trait->GetMaxPlayerBuildingProductionModifier();

	mov	edx, DWORD PTR [ebp+292]
	add	DWORD PTR [esi+76], edx

; 1610 : 			m_iCityUnhappinessModifier += trait->GetCityUnhappinessModifier();

	mov	eax, DWORD PTR [ebp+296]
	add	DWORD PTR [esi+80], eax

; 1611 : 			m_iPopulationUnhappinessModifier += trait->GetPopulationUnhappinessModifier();

	mov	ecx, DWORD PTR [ebp+300]
	add	DWORD PTR [esi+84], ecx

; 1612 : 			m_iCityStateBonusModifier += trait->GetCityStateBonusModifier();

	mov	edx, DWORD PTR [ebp+304]
	add	DWORD PTR [esi+88], edx

; 1613 : 			m_iCityStateFriendshipModifier += trait->GetCityStateFriendshipModifier();

	mov	eax, DWORD PTR [ebp+308]
	add	DWORD PTR [esi+92], eax

; 1614 : 			m_iCityStateCombatModifier += trait->GetCityStateCombatModifier();

	mov	ecx, DWORD PTR [ebp+312]
	add	DWORD PTR [esi+96], ecx

; 1615 : 			m_iLandBarbarianConversionPercent += trait->GetLandBarbarianConversionPercent();

	mov	edx, DWORD PTR [ebp+316]
	add	DWORD PTR [esi+100], edx

; 1616 : 			m_iLandBarbarianConversionExtraUnits += trait->GetLandBarbarianConversionExtraUnits();

	mov	eax, DWORD PTR [ebp+320]
	add	DWORD PTR [esi+104], eax

; 1617 : 			m_iSeaBarbarianConversionPercent += trait->GetSeaBarbarianConversionPercent();

	mov	ecx, DWORD PTR [ebp+324]
	add	DWORD PTR [esi+108], ecx

; 1618 : 			m_iCapitalBuildingModifier += trait->GetCapitalBuildingModifier();

	mov	edx, DWORD PTR [ebp+328]
	add	DWORD PTR [esi+112], edx

; 1619 : 			m_iPlotBuyCostModifier += trait->GetPlotBuyCostModifier();

	mov	eax, DWORD PTR [ebp+332]
	add	DWORD PTR [esi+116], eax

; 1620 : 			m_iPlotCultureCostModifier += trait->GetPlotCultureCostModifier();

	mov	ecx, DWORD PTR [ebp+336]
	add	DWORD PTR [esi+120], ecx

; 1621 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 1622 : 			m_iSciencePerGreatPersonBorn += trait->GetSciencePerGreatPersonBorn();

	mov	edx, DWORD PTR [ebp+340]
	add	DWORD PTR [esi+124], edx

; 1623 : #endif
; 1624 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 1625 : 			m_iNumTurnsBeforeMinorAlliesRefuseBribes += trait->GetNumTurnsBeforeMinorAlliesRefuseBribes();

	mov	eax, DWORD PTR [ebp+344]
	add	DWORD PTR [esi+128], eax

; 1626 : #endif
; 1627 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 1628 : 			m_iGoldenAgeTileBonusFaith += trait->GetGoldenAgeTileBonusFaith();

	mov	ecx, DWORD PTR [ebp+348]
	add	DWORD PTR [esi+132], ecx

; 1629 : #endif
; 1630 : 			m_iCultureFromKills += trait->GetCultureFromKills();

	mov	edx, DWORD PTR [ebp+352]
	add	DWORD PTR [esi+136], edx

; 1631 : 			m_iFaithFromKills += trait->GetFaithFromKills();

	mov	eax, DWORD PTR [ebp+356]
	add	DWORD PTR [esi+140], eax

; 1632 : 			m_iCityCultureBonus += trait->GetCityCultureBonus();

	mov	ecx, DWORD PTR [ebp+360]
	add	DWORD PTR [esi+144], ecx

; 1633 : 			m_iCapitalThemingBonusModifier += trait->GetCapitalThemingBonusModifier();

	mov	edx, DWORD PTR [ebp+364]
	add	DWORD PTR [esi+148], edx

; 1634 : 			m_iPolicyCostModifier += trait->GetPolicyCostModifier();

	mov	eax, DWORD PTR [ebp+368]
	add	DWORD PTR [esi+152], eax

; 1635 : 			m_iCityConnectionTradeRouteChange += trait->GetCityConnectionTradeRouteChange();

	mov	ecx, DWORD PTR [ebp+372]
	add	DWORD PTR [esi+156], ecx

; 1636 : 			m_iWonderProductionModifier += trait->GetWonderProductionModifier();

	mov	edx, DWORD PTR [ebp+376]
	add	DWORD PTR [esi+160], edx

; 1637 : 			m_iPlunderModifier += trait->GetPlunderModifier();

	mov	eax, DWORD PTR [ebp+380]
	add	DWORD PTR [esi+164], eax

; 1638 : 			m_iImprovementMaintenanceModifier += trait->GetImprovementMaintenanceModifier();

	mov	ecx, DWORD PTR [ebp+384]
	add	DWORD PTR [esi+168], ecx

; 1639 : 			m_iGoldenAgeDurationModifier += trait->GetGoldenAgeDurationModifier();

	mov	edx, DWORD PTR [ebp+388]
	add	DWORD PTR [esi+172], edx

; 1640 : 			m_iGoldenAgeMoveChange += trait->GetGoldenAgeMoveChange();

	mov	eax, DWORD PTR [ebp+392]
	add	DWORD PTR [esi+176], eax

; 1641 : 			m_iGoldenAgeCombatModifier += trait->GetGoldenAgeCombatModifier();

	mov	ecx, DWORD PTR [ebp+396]
	add	DWORD PTR [esi+180], ecx

; 1642 : 			m_iGoldenAgeTourismModifier += trait->GetGoldenAgeTourismModifier();

	mov	edx, DWORD PTR [ebp+400]
	add	DWORD PTR [esi+184], edx

; 1643 : 			m_iGoldenAgeGreatArtistRateModifier += trait->GetGoldenAgeGreatArtistRateModifier();

	mov	eax, DWORD PTR [ebp+404]
	add	DWORD PTR [esi+188], eax

; 1644 : 			m_iGoldenAgeGreatMusicianRateModifier += trait->GetGoldenAgeGreatMusicianRateModifier();

	mov	ecx, DWORD PTR [ebp+408]
	add	DWORD PTR [esi+192], ecx

; 1645 : 			m_iGoldenAgeGreatWriterRateModifier += trait->GetGoldenAgeGreatWriterRateModifier();

	mov	edx, DWORD PTR [ebp+412]
	add	DWORD PTR [esi+196], edx

; 1646 : 			m_iExtraEmbarkMoves += trait->GetExtraEmbarkMoves();

	mov	eax, DWORD PTR [ebp+424]
	add	DWORD PTR [esi+200], eax

; 1647 : 			m_iNaturalWonderFirstFinderGold += trait->GetNaturalWonderFirstFinderGold();

	mov	ecx, DWORD PTR [ebp+432]
	add	DWORD PTR [esi+204], ecx

; 1648 : 			m_iNaturalWonderSubsequentFinderGold += trait->GetNaturalWonderSubsequentFinderGold();

	mov	edx, DWORD PTR [ebp+436]
	add	DWORD PTR [esi+208], edx

; 1649 : 			m_iNaturalWonderYieldModifier += trait->GetNaturalWonderYieldModifier();

	mov	eax, DWORD PTR [ebp+440]
	add	DWORD PTR [esi+212], eax

; 1650 : 			m_iNaturalWonderHappinessModifier += trait->GetNaturalWonderHappinessModifier();

	mov	ecx, DWORD PTR [ebp+444]
	add	DWORD PTR [esi+216], ecx

; 1651 : 			m_iNearbyImprovementCombatBonus += trait->GetNearbyImprovementCombatBonus();

	mov	edx, DWORD PTR [ebp+448]
	add	DWORD PTR [esi+220], edx

; 1652 : 			m_iNearbyImprovementBonusRange += trait->GetNearbyImprovementBonusRange();

	mov	eax, DWORD PTR [ebp+452]
	add	DWORD PTR [esi+224], eax

; 1653 : 			m_iCultureBuildingYieldChange += trait->GetCultureBuildingYieldChange();

	mov	ecx, DWORD PTR [ebp+456]
	add	DWORD PTR [esi+228], ecx

; 1654 : 			m_iCombatBonusVsHigherTech += trait->GetCombatBonusVsHigherTech();

	mov	edx, DWORD PTR [ebp+460]
	add	DWORD PTR [esi+232], edx

; 1655 : 			m_iCombatBonusVsLargerCiv += trait->GetCombatBonusVsLargerCiv();

	mov	eax, DWORD PTR [ebp+464]
	add	DWORD PTR [esi+236], eax

; 1656 : 			m_iLandUnitMaintenanceModifier += trait->GetLandUnitMaintenanceModifier();

	mov	ecx, DWORD PTR [ebp+468]
	add	DWORD PTR [esi+240], ecx

; 1657 : 			m_iNavalUnitMaintenanceModifier += trait->GetNavalUnitMaintenanceModifier();

	mov	edx, DWORD PTR [ebp+472]
	add	DWORD PTR [esi+244], edx

; 1658 : 			m_iRazeSpeedModifier += trait->GetRazeSpeedModifier();

	mov	eax, DWORD PTR [ebp+476]
	add	DWORD PTR [esi+248], eax

; 1659 : 			m_iDOFGreatPersonModifier += trait->GetDOFGreatPersonModifier();

	mov	ecx, DWORD PTR [ebp+480]
	add	DWORD PTR [esi+252], ecx

; 1660 : 			m_iLuxuryHappinessRetention += trait->GetLuxuryHappinessRetention();

	mov	edx, DWORD PTR [ebp+484]
	add	DWORD PTR [esi+256], edx

; 1661 : 			m_iExtraHappinessPerLuxury += trait->GetExtraHappinessPerLuxury(); // NQMP GJS - New Netherlands UA

	mov	eax, DWORD PTR [ebp+488]
	add	DWORD PTR [esi+260], eax

; 1662 : 			m_iExtraSpies += trait->GetExtraSpies();

	mov	ecx, DWORD PTR [ebp+492]
	add	DWORD PTR [esi+264], ecx

; 1663 : 			m_iHappinessPerReligion += trait->GetHappinessPerReligion(); // NQMP GJS - New Ottoman UA

	mov	edx, DWORD PTR [ebp+496]
	add	DWORD PTR [esi+268], edx

; 1664 : 			m_iUnresearchedTechBonusFromKills += trait->GetUnresearchedTechBonusFromKills();

	mov	eax, DWORD PTR [ebp+500]
	add	DWORD PTR [esi+272], eax

; 1665 : 			m_iExtraFoundedCityTerritoryClaimRange += trait->GetExtraFoundedCityTerritoryClaimRange();

	mov	ecx, DWORD PTR [ebp+504]
	add	DWORD PTR [esi+276], ecx

; 1666 : 			m_iFreeSocialPoliciesPerEra += trait->GetFreeSocialPoliciesPerEra();

	mov	edx, DWORD PTR [ebp+508]
	add	DWORD PTR [esi+280], edx

; 1667 : 			m_iNumTradeRoutesModifier += trait->GetNumTradeRoutesModifier();

	mov	eax, DWORD PTR [ebp+512]
	add	DWORD PTR [esi+284], eax

; 1668 : 			m_iTradeRouteResourceModifier += trait->GetTradeRouteResourceModifier();

	mov	ecx, DWORD PTR [ebp+516]
	add	DWORD PTR [esi+288], ecx

; 1669 : 			m_iUniqueLuxuryCities += trait->GetUniqueLuxuryCities();

	mov	edx, DWORD PTR [ebp+520]
	add	DWORD PTR [esi+292], edx

; 1670 : 			m_iUniqueLuxuryQuantity	+= trait->GetUniqueLuxuryQuantity();

	mov	eax, DWORD PTR [ebp+524]
	add	DWORD PTR [esi+296], eax

; 1671 : 			m_iWorkerSpeedModifier += trait->GetWorkerSpeedModifier();

	mov	ecx, DWORD PTR [ebp+528]
	add	DWORD PTR [esi+304], ecx

; 1672 : 			m_iAfraidMinorPerTurnInfluence += trait->GetAfraidMinorPerTurnInfluence();

	mov	edx, DWORD PTR [ebp+532]
	add	DWORD PTR [esi+308], edx

; 1673 : 			m_iLandTradeRouteRangeBonus += trait->GetLandTradeRouteRangeBonus();

	mov	eax, DWORD PTR [ebp+536]
	add	DWORD PTR [esi+312], eax

; 1674 : 			m_iTradeReligionModifier += trait->GetTradeReligionModifier();

	mov	ecx, DWORD PTR [ebp+540]
	add	DWORD PTR [esi+316], ecx

; 1675 : 			m_iTradeBuildingModifier += trait->GetTradeBuildingModifier();

	mov	edx, DWORD PTR [ebp+544]
	add	DWORD PTR [esi+320], edx

; 1676 : 
; 1677 : 			if(trait->IsFightWellDamaged())

	cmp	BYTE PTR [ebp+576], 0
	je	SHORT $LN54@InitPlayer

; 1678 : 			{
; 1679 : 				m_bFightWellDamaged = true;
; 1680 : 				// JON: Changing the way this works. Above line can/should probably be removed at some point
; 1681 : 				int iWoundedUnitDamageMod = /*-50*/ GC.getTRAIT_WOUNDED_DAMAGE_MOD();
; 1682 : 				m_pPlayer->ChangeWoundedUnitDamageMod(iWoundedUnitDamageMod);

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+324], 1
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7460
	push	eax
	call	?ChangeWoundedUnitDamageMod@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeWoundedUnitDamageMod
$LN54@InitPlayer:

; 1683 : 			}
; 1684 : 			if(trait->IsMoveFriendlyWoodsAsRoad())

	cmp	BYTE PTR [ebp+577], 0
	je	SHORT $LN53@InitPlayer

; 1685 : 			{
; 1686 : 				m_bMoveFriendlyWoodsAsRoad = true;

	mov	BYTE PTR [esi+325], 1
$LN53@InitPlayer:

; 1687 : 			}
; 1688 : 			if(trait->IsFasterAlongRiver())

	cmp	BYTE PTR [ebp+578], 0
	je	SHORT $LN52@InitPlayer

; 1689 : 			{
; 1690 : 				m_bFasterAlongRiver = true;

	mov	BYTE PTR [esi+326], 1
$LN52@InitPlayer:

; 1691 : 			}
; 1692 : 			if(trait->IsFasterInHills())

	cmp	BYTE PTR [ebp+579], 0
	je	SHORT $LN51@InitPlayer

; 1693 : 			{
; 1694 : 				m_bFasterInHills = true;

	mov	BYTE PTR [esi+327], 1
$LN51@InitPlayer:

; 1695 : 			}
; 1696 : 			if(trait->IsEmbarkedAllWater())

	cmp	BYTE PTR [ebp+580], 0
	je	SHORT $LN50@InitPlayer

; 1697 : 			{
; 1698 : 				m_bEmbarkedAllWater = true;

	mov	BYTE PTR [esi+328], 1
$LN50@InitPlayer:

; 1699 : 			}
; 1700 : 			if(trait->IsEmbarkedToLandFlatCost())

	cmp	BYTE PTR [ebp+581], 0
	je	SHORT $LN49@InitPlayer

; 1701 : 			{
; 1702 : 				m_bEmbarkedToLandFlatCost = true;

	mov	BYTE PTR [esi+329], 1
$LN49@InitPlayer:

; 1703 : 			}
; 1704 : 			if(trait->IsNoHillsImprovementMaintenance())

	cmp	BYTE PTR [ebp+582], 0
	je	SHORT $LN48@InitPlayer

; 1705 : 			{
; 1706 : 				m_bNoHillsImprovementMaintenance = true;

	mov	BYTE PTR [esi+330], 1
$LN48@InitPlayer:

; 1707 : 			}
; 1708 : 			if(trait->IsTechBoostFromCapitalScienceBuildings())

	cmp	BYTE PTR [ebp+583], 0
	je	SHORT $LN47@InitPlayer

; 1709 : 			{
; 1710 : 				m_bTechBoostFromCapitalScienceBuildings = true;

	mov	BYTE PTR [esi+331], 1
$LN47@InitPlayer:

; 1711 : 			}
; 1712 : 			if(trait->IsStaysAliveZeroCities())

	cmp	BYTE PTR [ebp+584], 0
	je	SHORT $LN46@InitPlayer

; 1713 : 			{
; 1714 : 				m_bStaysAliveZeroCities = true;

	mov	BYTE PTR [esi+332], 1
$LN46@InitPlayer:

; 1715 : 			}
; 1716 : 			if(trait->IsFaithFromUnimprovedForest())

	cmp	BYTE PTR [ebp+585], 0
	je	SHORT $LN45@InitPlayer

; 1717 : 			{
; 1718 : 				m_bFaithFromUnimprovedForest = true;

	mov	BYTE PTR [esi+333], 1
$LN45@InitPlayer:

; 1719 : 			}
; 1720 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 1721 : 			if(trait->IsSeaTradeRoutesArePlunderImmune())

	cmp	BYTE PTR [ebp+586], 0
	je	SHORT $LN44@InitPlayer

; 1722 : 			{
; 1723 : 				m_bSeaTradeRoutesArePlunderImmune = true;

	mov	BYTE PTR [esi+334], 1
$LN44@InitPlayer:

; 1724 : 			}
; 1725 : #endif
; 1726 : 			// NQMP GJS - New France UA begin
; 1727 : 			if(trait->IsEarnsGreatPersonOnSlotOrGuild())

	cmp	BYTE PTR [ebp+587], 0
	je	SHORT $LN43@InitPlayer

; 1728 : 			{
; 1729 : 				m_bEarnsGreatPersonOnSlotOrGuild = true;

	mov	BYTE PTR [esi+335], 1
$LN43@InitPlayer:

; 1730 : 			}
; 1731 : 			// NQMP GJS - New France UA end
; 1732 : 			if(trait->IsBonusReligiousBelief())

	cmp	BYTE PTR [ebp+591], 0
	je	SHORT $LN42@InitPlayer

; 1733 : 			{
; 1734 : 				m_bBonusReligiousBelief = true;

	mov	BYTE PTR [esi+339], 1
$LN42@InitPlayer:

; 1735 : 			}
; 1736 : 			if(trait->IsAbleToAnnexCityStates())

	cmp	BYTE PTR [ebp+592], 0
	je	SHORT $LN41@InitPlayer

; 1737 : 			{
; 1738 : 				m_bAbleToAnnexCityStates = true;

	mov	BYTE PTR [esi+340], 1
$LN41@InitPlayer:

; 1739 : 			}
; 1740 : 			if(trait->IsCrossesMountainsAfterGreatGeneral())

	cmp	BYTE PTR [ebp+593], 0
	je	SHORT $LN40@InitPlayer

; 1741 : 			{
; 1742 : 				m_bCrossesMountainsAfterGreatGeneral = true;

	mov	BYTE PTR [esi+341], 1
$LN40@InitPlayer:

; 1743 : 			}
; 1744 : 			if(trait->IsMayaCalendarBonuses())

	cmp	BYTE PTR [ebp+594], 0
	je	SHORT $LN39@InitPlayer

; 1745 : 			{
; 1746 : 				m_bMayaCalendarBonuses = true;

	mov	BYTE PTR [esi+342], 1
$LN39@InitPlayer:

; 1747 : 			}
; 1748 : 			if (trait->IsNoAnnexing())

	cmp	BYTE PTR [ebp+595], 0
	je	SHORT $LN38@InitPlayer

; 1749 : 			{
; 1750 : 				m_bNoAnnexing = true;

	mov	BYTE PTR [esi+343], 1
$LN38@InitPlayer:

; 1751 : 			}
; 1752 : 			if (trait->IsTechFromCityConquer())

	cmp	BYTE PTR [ebp+596], 0
	je	SHORT $LN37@InitPlayer

; 1753 : 			{
; 1754 : 				m_bTechFromCityConquer = true;

	mov	BYTE PTR [esi+344], 1
$LN37@InitPlayer:

; 1755 : 			}
; 1756 : 			if (trait->IsUniqueLuxuryRequiresNewArea())

	cmp	BYTE PTR [ebp+597], 0
	je	SHORT $LN36@InitPlayer

; 1757 : 			{
; 1758 : 				m_bUniqueLuxuryRequiresNewArea = true;

	mov	BYTE PTR [esi+345], 1
$LN36@InitPlayer:

; 1759 : 			}
; 1760 : 			if (trait->IsRiverTradeRoad())

	cmp	BYTE PTR [ebp+598], 0
	je	SHORT $LN35@InitPlayer

; 1761 : 			{
; 1762 : 				m_bRiverTradeRoad = true;

	mov	BYTE PTR [esi+346], 1
$LN35@InitPlayer:

; 1763 : 			}
; 1764 : 			if (trait->IsAngerFreeIntrusionOfCityStates())

	cmp	BYTE PTR [ebp+599], 0
	je	SHORT $LN34@InitPlayer

; 1765 : 			{
; 1766 : 				m_bAngerFreeIntrusionOfCityStates = true;

	mov	BYTE PTR [esi+347], 1
$LN34@InitPlayer:

; 1767 : 			}
; 1768 : 
; 1769 : 			for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	lea	ecx, DWORD PTR [esi+376]
	xor	ebx, ebx
	mov	DWORD PTR tv3974[esp+116], ecx
	npad	4
$LL33@InitPlayer:

; 1770 : 			{
; 1771 : 				if(trait->GetExtraYieldThreshold(iYield) > m_iExtraYieldThreshold[iYield])

	mov	ecx, DWORD PTR [ebp+628]
	test	ecx, ecx
	je	SHORT $LN380@InitPlayer
	mov	edx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN381@InitPlayer
$LN380@InitPlayer:
	or	edx, -1
$LN381@InitPlayer:
	mov	eax, DWORD PTR tv3974[esp+116]
	cmp	edx, DWORD PTR [eax]
	jle	SHORT $LN634@InitPlayer

; 1772 : 				{
; 1773 : 					m_iExtraYieldThreshold[iYield] = trait->GetExtraYieldThreshold(iYield);

	test	ecx, ecx
	je	SHORT $LN384@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN385@InitPlayer
$LN384@InitPlayer:
	or	ecx, -1
$LN385@InitPlayer:
	mov	DWORD PTR [eax], ecx
$LN634@InitPlayer:

; 1774 : 				}
; 1775 : 				m_iFreeCityYield[iYield] = trait->GetYieldChange(iYield);

	mov	ecx, DWORD PTR [ebp+632]
	test	ecx, ecx
	je	SHORT $LN388@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN389@InitPlayer
$LN388@InitPlayer:
	or	ecx, -1
$LN389@InitPlayer:
	mov	DWORD PTR [eax+24], ecx

; 1776 : 				m_iYieldChangeStrategicResources[iYield] = trait->GetYieldChangeStrategicResources(iYield);

	mov	ecx, DWORD PTR [ebp+636]
	test	ecx, ecx
	je	SHORT $LN392@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN393@InitPlayer
$LN392@InitPlayer:
	or	ecx, -1
$LN393@InitPlayer:
	mov	DWORD PTR [eax+48], ecx

; 1777 : 				m_iYieldChangeLuxuryResources[iYield] = trait->GetYieldChangeLuxuryResources(iYield); // NQMP GJS - New Netherlands UA

	mov	ecx, DWORD PTR [ebp+640]
	test	ecx, ecx
	je	SHORT $LN396@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN397@InitPlayer
$LN396@InitPlayer:
	or	ecx, -1
$LN397@InitPlayer:
	mov	DWORD PTR [eax+72], ecx

; 1778 : 				m_iYieldChangeNaturalWonder[iYield] = trait->GetYieldChangeNaturalWonder(iYield);

	mov	ecx, DWORD PTR [ebp+644]
	test	ecx, ecx
	je	SHORT $LN400@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN401@InitPlayer
$LN400@InitPlayer:
	or	ecx, -1
$LN401@InitPlayer:
	mov	DWORD PTR [eax+96], ecx

; 1779 : 				m_iYieldChangePerTradePartner[iYield] = trait->GetYieldChangePerTradePartner(iYield);

	mov	ecx, DWORD PTR [ebp+648]
	test	ecx, ecx
	je	SHORT $LN404@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN405@InitPlayer
$LN404@InitPlayer:
	or	ecx, -1
$LN405@InitPlayer:
	mov	DWORD PTR [eax+120], ecx

; 1780 : 				m_iYieldChangeIncomingTradeRoute[iYield] = trait->GetYieldChangeIncomingTradeRoute(iYield);

	mov	ecx, DWORD PTR [ebp+652]
	test	ecx, ecx
	je	SHORT $LN408@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN409@InitPlayer
$LN408@InitPlayer:
	or	ecx, -1
$LN409@InitPlayer:
	mov	DWORD PTR [eax+144], ecx

; 1781 : 				m_iYieldRateModifier[iYield] = trait->GetYieldModifier(iYield);

	mov	ecx, DWORD PTR [ebp+656]
	test	ecx, ecx
	je	SHORT $LN412@InitPlayer
	mov	ecx, DWORD PTR [ebx+ecx]
	jmp	SHORT $LN413@InitPlayer
$LN412@InitPlayer:
	or	ecx, -1
$LN413@InitPlayer:
	mov	DWORD PTR [eax+168], ecx

; 1782 : 
; 1783 : #ifdef AUI_WARNING_FIXES
; 1784 : 				for (uint iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
; 1785 : #else
; 1786 : 				for(int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iFeatureLoop$223051[esp+116], 0
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	test	eax, eax
	jle	$LN27@InitPlayer
	xor	edi, edi
	mov	DWORD PTR tv3498[esp+116], ebx
$LL627@InitPlayer:

; 1787 : #endif
; 1788 : 				{
; 1789 : 					int iChange = trait->GetUnimprovedFeatureYieldChanges((FeatureTypes)iFeatureLoop, (YieldTypes)iYield);

	mov	eax, DWORD PTR [ebp+684]
	test	eax, eax
	je	$LN28@InitPlayer
	mov	edx, DWORD PTR _iFeatureLoop$223051[esp+116]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [ebx+eax]

; 1790 : 					if(iChange > 0)

	test	ecx, ecx
	jle	SHORT $LN28@InitPlayer

; 1791 : 					{
; 1792 : 						Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiUnimprovedFeatureYieldChange[iFeatureLoop];

	mov	eax, DWORD PTR [esi+820]
	mov	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR _yields$223060[esp+116], edx
	mov	edx, DWORD PTR [eax+edi+4]
	mov	DWORD PTR _yields$223060[esp+120], edx
	mov	edx, DWORD PTR [eax+edi+8]
	mov	DWORD PTR _yields$223060[esp+124], edx
	mov	edx, DWORD PTR [eax+edi+12]
	mov	DWORD PTR _yields$223060[esp+128], edx
	mov	edx, DWORD PTR [eax+edi+16]
	mov	DWORD PTR _yields$223060[esp+132], edx
	mov	edx, DWORD PTR [eax+edi+20]
	mov	DWORD PTR _yields$223060[esp+136], edx

; 1793 : 						yields[iYield] = (m_ppaaiUnimprovedFeatureYieldChange[iFeatureLoop][iYield] + iChange);

	mov	edx, DWORD PTR tv3498[esp+116]
	mov	edx, DWORD PTR [eax+edx]
	add	edx, ecx
	mov	DWORD PTR _yields$223060[esp+ebx+116], edx

; 1794 : 						m_ppaaiUnimprovedFeatureYieldChange[iFeatureLoop] = yields;

	mov	ecx, DWORD PTR _yields$223060[esp+116]
	mov	edx, DWORD PTR _yields$223060[esp+120]
	mov	DWORD PTR [eax+edi], ecx
	mov	ecx, DWORD PTR _yields$223060[esp+124]
	mov	DWORD PTR [eax+edi+4], edx
	mov	edx, DWORD PTR _yields$223060[esp+128]
	mov	DWORD PTR [eax+edi+8], ecx
	mov	ecx, DWORD PTR _yields$223060[esp+132]
	mov	DWORD PTR [eax+edi+12], edx
	mov	edx, DWORD PTR _yields$223060[esp+136]
	mov	DWORD PTR [eax+edi+16], ecx
	mov	DWORD PTR [eax+edi+20], edx
$LN28@InitPlayer:
	inc	DWORD PTR _iFeatureLoop$223051[esp+116]
	add	DWORD PTR tv3498[esp+116], 24		; 00000018H
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	edi, 24					; 00000018H
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	DWORD PTR _iFeatureLoop$223051[esp+116], eax
	jl	$LL627@InitPlayer
$LN27@InitPlayer:

; 1795 : 					}
; 1796 : 				}
; 1797 : 
; 1798 : #ifdef AUI_WARNING_FIXES
; 1799 : 				for (uint iImprovementLoop = 0; iImprovementLoop < GC.getNumImprovementInfos(); iImprovementLoop++)
; 1800 : #else
; 1801 : 				for(int iImprovementLoop = 0; iImprovementLoop < GC.getNumImprovementInfos(); iImprovementLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iImprovementLoop$223061[esp+116], 0
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	test	eax, eax
	jle	$LN23@InitPlayer
	xor	edi, edi
	mov	DWORD PTR tv3597[esp+116], ebx
	npad	2
$LL628@InitPlayer:

; 1802 : #endif
; 1803 : 				{
; 1804 : 					int iChange = trait->GetImprovementYieldChanges((ImprovementTypes)iImprovementLoop, (YieldTypes)iYield);

	mov	eax, DWORD PTR [ebp+676]
	test	eax, eax
	je	$LN24@InitPlayer
	mov	ecx, DWORD PTR _iImprovementLoop$223061[esp+116]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ebx+edx]

; 1805 : 					if(iChange > 0)

	test	ecx, ecx
	jle	SHORT $LN24@InitPlayer

; 1806 : 					{
; 1807 : 						Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiImprovementYieldChange[iImprovementLoop];

	mov	eax, DWORD PTR [esi+788]
	mov	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR _yields$223070[esp+116], edx
	mov	edx, DWORD PTR [eax+edi+4]
	mov	DWORD PTR _yields$223070[esp+120], edx
	mov	edx, DWORD PTR [eax+edi+8]
	mov	DWORD PTR _yields$223070[esp+124], edx
	mov	edx, DWORD PTR [eax+edi+12]
	mov	DWORD PTR _yields$223070[esp+128], edx
	mov	edx, DWORD PTR [eax+edi+16]
	mov	DWORD PTR _yields$223070[esp+132], edx
	mov	edx, DWORD PTR [eax+edi+20]
	mov	DWORD PTR _yields$223070[esp+136], edx

; 1808 : 						yields[iYield] = (m_ppaaiImprovementYieldChange[iImprovementLoop][iYield] + iChange);

	mov	edx, DWORD PTR tv3597[esp+116]
	mov	edx, DWORD PTR [eax+edx]
	add	edx, ecx
	mov	DWORD PTR _yields$223070[esp+ebx+116], edx

; 1809 : 						m_ppaaiImprovementYieldChange[iImprovementLoop] = yields;

	mov	ecx, DWORD PTR _yields$223070[esp+116]
	mov	edx, DWORD PTR _yields$223070[esp+120]
	mov	DWORD PTR [eax+edi], ecx
	mov	ecx, DWORD PTR _yields$223070[esp+124]
	mov	DWORD PTR [eax+edi+4], edx
	mov	edx, DWORD PTR _yields$223070[esp+128]
	mov	DWORD PTR [eax+edi+8], ecx
	mov	ecx, DWORD PTR _yields$223070[esp+132]
	mov	DWORD PTR [eax+edi+12], edx
	mov	edx, DWORD PTR _yields$223070[esp+136]
	mov	DWORD PTR [eax+edi+16], ecx
	mov	DWORD PTR [eax+edi+20], edx
$LN24@InitPlayer:
	inc	DWORD PTR _iImprovementLoop$223061[esp+116]
	add	DWORD PTR tv3597[esp+116], 24		; 00000018H
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	edi, 24					; 00000018H
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iImprovementLoop$223061[esp+116], eax
	jl	$LL628@InitPlayer
$LN23@InitPlayer:

; 1810 : 					}
; 1811 : 				}
; 1812 : 
; 1813 : #ifdef AUI_WARNING_FIXES
; 1814 : 				for (uint iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
; 1815 : #else
; 1816 : 				for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSpecialistLoop$223071[esp+116], 0
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	$LN32@InitPlayer
	xor	edi, edi
	mov	DWORD PTR tv3696[esp+116], ebx
	npad	3
$LL629@InitPlayer:

; 1817 : #endif
; 1818 : 				{
; 1819 : 					int iChange = trait->GetSpecialistYieldChanges((SpecialistTypes)iSpecialistLoop, (YieldTypes)iYield);

	mov	eax, DWORD PTR [ebp+680]
	test	eax, eax
	je	SHORT $LN20@InitPlayer
	mov	ecx, DWORD PTR _iSpecialistLoop$223071[esp+116]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ebx+edx]

; 1820 : 					if(iChange > 0)

	test	ecx, ecx
	jle	SHORT $LN20@InitPlayer

; 1821 : 					{
; 1822 : 						Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiSpecialistYieldChange[iSpecialistLoop];

	mov	eax, DWORD PTR [esi+804]
	mov	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR _yields$223080[esp+116], edx
	mov	edx, DWORD PTR [eax+edi+4]
	mov	DWORD PTR _yields$223080[esp+120], edx
	mov	edx, DWORD PTR [eax+edi+8]
	mov	DWORD PTR _yields$223080[esp+124], edx
	mov	edx, DWORD PTR [eax+edi+12]
	mov	DWORD PTR _yields$223080[esp+128], edx
	mov	edx, DWORD PTR [eax+edi+16]
	mov	DWORD PTR _yields$223080[esp+132], edx
	mov	edx, DWORD PTR [eax+edi+20]
	mov	DWORD PTR _yields$223080[esp+136], edx

; 1823 : 						yields[iYield] = (m_ppaaiSpecialistYieldChange[iSpecialistLoop][iYield] + iChange);

	mov	edx, DWORD PTR tv3696[esp+116]
	mov	edx, DWORD PTR [eax+edx]
	add	edx, ecx
	mov	DWORD PTR _yields$223080[esp+ebx+116], edx

; 1824 : 						m_ppaaiSpecialistYieldChange[iSpecialistLoop] = yields;

	mov	ecx, DWORD PTR _yields$223080[esp+116]
	mov	edx, DWORD PTR _yields$223080[esp+120]
	mov	DWORD PTR [eax+edi], ecx
	mov	ecx, DWORD PTR _yields$223080[esp+124]
	mov	DWORD PTR [eax+edi+4], edx
	mov	edx, DWORD PTR _yields$223080[esp+128]
	mov	DWORD PTR [eax+edi+8], ecx
	mov	ecx, DWORD PTR _yields$223080[esp+132]
	mov	DWORD PTR [eax+edi+12], edx
	mov	edx, DWORD PTR _yields$223080[esp+136]
	mov	DWORD PTR [eax+edi+16], ecx
	mov	DWORD PTR [eax+edi+20], edx
$LN20@InitPlayer:
	inc	DWORD PTR _iSpecialistLoop$223071[esp+116]
	add	DWORD PTR tv3696[esp+116], 24		; 00000018H
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	edi, 24					; 00000018H
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	DWORD PTR _iSpecialistLoop$223071[esp+116], eax
	jl	$LL629@InitPlayer
$LN32@InitPlayer:

; 1767 : 			}
; 1768 : 
; 1769 : 			for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	add	DWORD PTR tv3974[esp+116], 4
	add	ebx, 4
	cmp	ebx, 24					; 00000018H
	jl	$LL33@InitPlayer

; 1825 : 					}
; 1826 : 				}
; 1827 : 			}
; 1828 : 			CvAssert(GC.getNumTerrainInfos() <= NUM_TERRAIN_TYPES);
; 1829 : #ifdef AUI_WARNING_FIXES
; 1830 : 			for (uint iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)
; 1831 : #else
; 1832 : 			for(int iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	test	eax, eax
	jle	SHORT $LN630@InitPlayer
	lea	ebx, DWORD PTR [esi+568]
$LL632@InitPlayer:

; 1833 : #endif
; 1834 : 			{
; 1835 : 				m_iStrategicResourceQuantityModifier[iTerrain] = trait->GetStrategicResourceQuantityModifier(iTerrain);

	mov	eax, DWORD PTR [ebp+660]
	test	eax, eax
	je	SHORT $LN473@InitPlayer
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN474@InitPlayer
$LN473@InitPlayer:
	or	eax, -1
$LN474@InitPlayer:
	mov	DWORD PTR [ebx], eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	add	ebx, 4
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	edi, eax
	jl	SHORT $LL632@InitPlayer
$LN630@InitPlayer:

; 1836 : 			}
; 1837 : 
; 1838 : #ifdef AUI_WARNING_FIXES
; 1839 : 			for (uint iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)
; 1840 : #else
; 1841 : 			for(int iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN12@InitPlayer
$LL14@InitPlayer:

; 1842 : #endif
; 1843 : 			{
; 1844 : 				m_aiResourceQuantityModifier[iResource] = trait->GetResourceQuantityModifier(iResource);

	mov	eax, DWORD PTR [ebp+664]
	test	eax, eax
	je	SHORT $LN477@InitPlayer
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN478@InitPlayer
$LN477@InitPlayer:
	or	eax, -1
$LN478@InitPlayer:
	mov	ecx, DWORD PTR [esi+608]
	mov	DWORD PTR [ecx+edi*4], eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	SHORT $LL14@InitPlayer
$LN12@InitPlayer:

; 1845 : 			}
; 1846 : 
; 1847 : #ifdef AUI_WARNING_FIXES
; 1848 : 			for (uint iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)
; 1849 : #else
; 1850 : 			for (int iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	test	eax, eax
	jle	$LN631@InitPlayer
$LL635@InitPlayer:

; 1851 : #endif
; 1852 : 			{
; 1853 : 				m_abNoTrain[iUnitClass] = trait->NoTrain((UnitClassTypes)iUnitClass);

	cmp	edi, -1
	je	SHORT $LN482@InitPlayer
	mov	eax, DWORD PTR [ebp+724]
	xor	ecx, ecx
	test	edi, edi
	je	SHORT $LN636@InitPlayer
	jge	SHORT $LN506@InitPlayer
	mov	edx, edi
	neg	edx
	je	SHORT $LN506@InitPlayer
	or	ecx, -1
	sub	ecx, edi
	shr	ecx, 5
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, -4					; fffffffcH
	sub	edx, ecx
	add	eax, edx
	jmp	SHORT $LN639@InitPlayer
$LN506@InitPlayer:
	mov	ecx, edi
	shr	ecx, 5
	lea	eax, DWORD PTR [eax+ecx*4]
$LN639@InitPlayer:
	mov	ecx, edi
	and	ecx, 31					; 0000001fH
$LN636@InitPlayer:
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [eax]
	setne	dl
	jmp	SHORT $LN481@InitPlayer
$LN482@InitPlayer:
	xor	dl, dl
$LN481@InitPlayer:
	mov	eax, DWORD PTR [esi+628]
	xor	ecx, ecx
	test	edi, edi
	je	SHORT $LN544@InitPlayer
	jge	SHORT $LN545@InitPlayer
	mov	ecx, edi
	neg	ecx
	je	SHORT $LN545@InitPlayer
	or	ecx, -1
	sub	ecx, edi
	shr	ecx, 5
	add	ecx, ecx
	add	ecx, ecx
	mov	ebx, -4					; fffffffcH
	sub	ebx, ecx
	add	eax, ebx
	jmp	SHORT $LN640@InitPlayer
$LN545@InitPlayer:
	mov	ecx, edi
	shr	ecx, 5
	lea	eax, DWORD PTR [eax+ecx*4]
$LN640@InitPlayer:
	mov	ecx, edi
	and	ecx, 31					; 0000001fH
$LN544@InitPlayer:
	test	dl, dl
	mov	edx, 1
	je	SHORT $LN558@InitPlayer
	shl	edx, cl
	or	DWORD PTR [eax], edx
	jmp	SHORT $LN10@InitPlayer
$LN558@InitPlayer:
	shl	edx, cl
	not	edx
	and	DWORD PTR [eax], edx
$LN10@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	edi, eax
	jl	$LL635@InitPlayer
$LN631@InitPlayer:

; 1854 : 			}
; 1855 : 
; 1856 : 			FreeTraitUnit traitUnit;
; 1857 : #ifdef AUI_WARNING_FIXES
; 1858 : 			traitUnit.m_iFreeUnit = (UnitClassTypes)trait->GetFreeUnitClassType();
; 1859 : #else
; 1860 : 			traitUnit.m_iFreeUnit = (UnitTypes)trait->GetFreeUnitClassType();

	mov	eax, DWORD PTR [ebp+428]
	mov	DWORD PTR _traitUnit$223095[esp+116], eax

; 1861 : #endif
; 1862 : 			if(traitUnit.m_iFreeUnit != NO_UNITCLASS)

	cmp	eax, -1
	je	SHORT $LN574@InitPlayer

; 1863 : 			{
; 1864 : 				traitUnit.m_ePrereqTech = trait->GetFreeUnitPrereqTech();
; 1865 : 				m_aFreeTraitUnits.push_back(traitUnit);

	mov	eax, DWORD PTR [esi+648]
	mov	ebx, DWORD PTR [ebp+548]
	lea	edi, DWORD PTR [esi+640]
	mov	BYTE PTR [edi+52], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN573@InitPlayer
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize
$LN573@InitPlayer:
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN576@InitPlayer
	mov	edx, DWORD PTR _traitUnit$223095[esp+116]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
$LN576@InitPlayer:
	inc	DWORD PTR [edi+4]
$LN574@InitPlayer:

; 1866 : 			}
; 1867 : 
; 1868 : 			m_eCombatBonusImprovement = trait->GetCombatBonusImprovement();

	mov	eax, DWORD PTR [ebp+552]

; 1869 : 
; 1870 : #ifdef AUI_WARNING_FIXES
; 1871 : 			for (uint jJ = 0; jJ < GC.getNumUnitCombatClassInfos(); jJ++)
; 1872 : #else
; 1873 : 			int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+360], eax
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos

; 1874 : 			for(int jJ= 0; jJ < iNumUnitCombatClassInfos; jJ++)

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN637@InitPlayer
	npad	9
$LL7@InitPlayer:
	mov	edx, DWORD PTR [esi+756]

; 1875 : #endif
; 1876 : 			{
; 1877 : 				m_paiMovesChangeUnitCombat[jJ] += trait->GetMovesChangeUnitCombat(jJ);

	mov	edi, DWORD PTR [ebp+668]
	mov	edi, DWORD PTR [edi+ecx*4]
	add	DWORD PTR [edx+ecx*4], edi

; 1878 : 				m_paiMaintenanceModifierUnitCombat[jJ] += trait->GetMaintenanceModifierUnitCombat(jJ);

	mov	edi, DWORD PTR [ebp+672]
	mov	edi, DWORD PTR [edi+ecx*4]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [esi+772]
	add	DWORD PTR [edx+ecx*4], edi
	lea	edx, DWORD PTR [edx+ecx*4]
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL7@InitPlayer
$LN637@InitPlayer:

; 1879 : 			}
; 1880 : 
; 1881 : #ifdef AUI_WARNING_FIXES
; 1882 : 			for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 1883 : #else
; 1884 : 			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN57@InitPlayer
	npad	1
$LL4@InitPlayer:

; 1885 : #endif
; 1886 : 			{
; 1887 : 				FreeResourceXCities temp = trait->GetFreeResourceXCities((ResourceTypes)iResourceLoop);

	mov	eax, DWORD PTR [ebp+704]
	mov	edx, DWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR [eax+edi*8+4]

; 1888 : 				if(temp.m_iResourceQuantity > 0)

	test	eax, eax
	jle	SHORT $LN3@InitPlayer

; 1889 : 				{
; 1890 : 					m_aFreeResourceXCities[iResourceLoop] = temp;

	mov	ecx, DWORD PTR [esi+836]
	mov	DWORD PTR [ecx+edi*8], edx
	mov	DWORD PTR [ecx+edi*8+4], eax
$LN3@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	SHORT $LL4@InitPlayer
$LN57@InitPlayer:

; 1589 : 		}
; 1590 : 	}
; 1591 : #ifdef AUI_WARNING_FIXES
; 1592 : 	for (uint iI = 0; iI < GC.getNumTraitInfos(); iI++)
; 1593 : #else
; 1594 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	edi, DWORD PTR _iI$223016[esp+116]
	inc	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$223016[esp+116], edi
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	edi, eax
	jl	$LL626@InitPlayer
$LN56@InitPlayer:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1891 : 				}
; 1892 : 			}
; 1893 : 		}
; 1894 : 	}
; 1895 : }

	add	esp, 100				; 00000064H
	ret	0
?InitPlayerTraits@CvPlayerTraits@@QAEXXZ ENDP		; CvPlayerTraits::InitPlayerTraits
_TEXT	ENDS
PUBLIC	?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z ; CvPlayerTraits::SetUnitBaktun
; Function compile flags: /Ogtpy
;	COMDAT ?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z
_TEXT	SEGMENT
_choice$ = -8						; size = 8
_eUnit$ = 8						; size = 4
?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z PROC	; CvPlayerTraits::SetUnitBaktun, COMDAT
; _this$ = ecx

; 2913 : {

	sub	esp, 8

; 2914 : 	MayaBonusChoice choice;
; 2915 : 	choice.m_eUnitType = eUnit;

	mov	eax, DWORD PTR _eUnit$[esp+4]

; 2916 : 	choice.m_iBaktunJustFinished = m_iBaktun;

	mov	edx, DWORD PTR [ecx+716]
	mov	DWORD PTR _choice$[esp+8], eax

; 2917 : 	m_aMayaBonusChoices.push_back(choice);

	lea	eax, DWORD PTR _choice$[esp+8]
	push	eax
	add	ecx, 736				; 000002e0H
	mov	DWORD PTR _choice$[esp+16], edx
	call	?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back

; 2918 : }

	add	esp, 8
	ret	4
?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z ENDP	; CvPlayerTraits::SetUnitBaktun
_TEXT	ENDS
PUBLIC	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z
_TEXT	SEGMENT
$T256676 = -16						; size = 8
$T256674 = -16						; size = 8
__Tmp$256897 = -8					; size = 8
$T256680 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z PROC ; std::vector<bool,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 2039 : 		{	// determine new length, padding with _Val elements as needed

	sub	esp, 16					; 00000010H
	push	ebx

; 2040 : 		if (size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp+16]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	cmp	ebx, esi
	jbe	SHORT $LN68@resize@5

; 2041 : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR $T256674[esp+28], eax
	mov	DWORD PTR $T256674[esp+32], 0
	test	esi, esi
	jbe	SHORT $LN25@resize@5
	push	esi
	lea	ecx, DWORD PTR $T256674[esp+32]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN25@resize@5:
	mov	ecx, DWORD PTR __Val$[esp+24]
	mov	edx, DWORD PTR $T256674[esp+32]
	mov	eax, DWORD PTR $T256674[esp+28]
	push	ecx
	sub	ebx, esi
	push	ebx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	pop	edi
	pop	esi
	pop	ebx

; 2044 : 		}

	add	esp, 16					; 00000010H
	ret	8
$LN68@resize@5:

; 2042 : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@5
	push	ebp

; 2043 : 			erase(begin() + _Newsize, end());

	mov	ebp, DWORD PTR [edi+8]
	mov	DWORD PTR $T256676[esp+32], ebp
	mov	DWORD PTR $T256676[esp+36], 0
	test	esi, esi
	jbe	SHORT $LN48@resize@5
	push	esi
	lea	ecx, DWORD PTR $T256676[esp+36]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN48@resize@5:
	xor	eax, eax
	push	ebx
	lea	ecx, DWORD PTR __Tmp$256897[esp+36]
	mov	DWORD PTR __Tmp$256897[esp+36], ebp
	mov	DWORD PTR __Tmp$256897[esp+40], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR $T256676[esp+36]
	mov	edx, DWORD PTR $T256676[esp+32]
	mov	eax, DWORD PTR __Tmp$256897[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Tmp$256897[esp+36]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T256680[esp+48]
	push	edx
	mov	ecx, edi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
	pop	ebp
$LN1@resize@5:
	pop	edi
	pop	esi
	pop	ebx

; 2044 : 		}

	add	esp, 16					; 00000010H
	ret	8
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::resize
_TEXT	ENDS
PUBLIC	??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator>><Firaxis::Array<int,6> >
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z PROC ; operator>><Firaxis::Array<int,6> >, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ENDP ; operator>><Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Tmp$257016 = 12					; size = 8
__Where$ = 12						; size = 8
__Val$ = 20						; size = 1
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z PROC ; std::vector<bool,std::allocator<bool> >::insert, COMDAT
; _this$ = ecx

; 2151 : 		size_type _Off = _Where - begin();
; 2152 : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __Where$[esp+4]
	mov	eax, DWORD PTR [edi+8]
	mov	esi, ecx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[esp+8]
	push	edx
	push	1
	sar	esi, 2
	push	eax
	push	ecx
	shl	esi, 5
	mov	ecx, edi
	add	esi, eax
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n

; 2153 : 		return (begin() + _Off);

	mov	edi, DWORD PTR [edi+8]
	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$257016[esp+8]
	mov	DWORD PTR __Tmp$257016[esp+8], edi
	mov	DWORD PTR __Tmp$257016[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$257016[esp+4]
	mov	edx, DWORD PTR __Tmp$257016[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2154 : 		}

	ret	16					; 00000010H
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::insert
_TEXT	ENDS
PUBLIC	?Reset@CvPlayerTraits@@QAEXXZ			; CvPlayerTraits::Reset
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Reset@CvPlayerTraits@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$0
__ehfuncinfo$?Reset@CvPlayerTraits@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Reset@CvPlayerTraits@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?Reset@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
tv3646 = -60						; size = 4
tv3494 = -56						; size = 4
tv3458 = -56						; size = 4
tv3422 = -56						; size = 4
__Result$259118 = -56					; size = 4
_temp$223166 = -56					; size = 8
$T260297 = -48						; size = 1
__Cat$260301 = -48					; size = 1
$T257937 = -48						; size = 1
__Cat$257941 = -48					; size = 1
$T257939 = -48						; size = 1
tv2781 = -48						; size = 4
tv2691 = -48						; size = 4
$T257736 = -48						; size = 1
__Cat$257740 = -48					; size = 1
$T257738 = -48						; size = 1
$T257541 = -48						; size = 1
__Cat$257545 = -48					; size = 1
$T257543 = -48						; size = 1
$T260055 = -48						; size = 4
$T260041 = -48						; size = 4
$T259681 = -48						; size = 4
__Result$259379 = -48					; size = 4
$T259672 = -48						; size = 4
$T258735 = -48						; size = 8
$T258496 = -48						; size = 4
$T258487 = -48						; size = 4
tv204 = -48						; size = 4
$T257087 = -48						; size = 4
$T257951 = -40						; size = 24
$T257756 = -40						; size = 24
$T257561 = -40						; size = 24
$T257023 = -40						; size = 20
__$EHRec$ = -12						; size = 12
?Reset@CvPlayerTraits@@QAEXXZ PROC			; CvPlayerTraits::Reset, COMDAT
; _this$ = ecx

; 1912 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?Reset@CvPlayerTraits@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 1913 : 	Uninit();

	call	?Uninit@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Uninit

; 1914 : 
; 1915 : 
; 1916 : 	m_vLeaderHasTrait = std::vector<bool>( GC.getNumTraitInfos(), false );

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	mov	edi, eax
	lea	eax, DWORD PTR $T257087[esp+80]
	lea	ecx, DWORD PTR [edi+31]
	shr	ecx, 5
	push	eax
	xor	ebx, ebx
	push	ecx
	lea	ecx, DWORD PTR $T257023[esp+92]
	mov	DWORD PTR $T257023[esp+88], ebx
	mov	DWORD PTR $T257087[esp+88], ebx
	call	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
	push	edi
	lea	ecx, DWORD PTR $T257023[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
	mov	edx, DWORD PTR $T257023[esp+80]
	lea	eax, DWORD PTR $T257023[esp+84]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR [esi+8], edx
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	mov	eax, DWORD PTR $T257023[esp+88]
	or	edi, -1
	mov	DWORD PTR __$EHRec$[esp+88], edi
	cmp	eax, ebx
	je	SHORT $LN66@Reset
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN66@Reset:

; 1917 : 	m_vPotentiallyActiveLeaderTraits.clear();

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [esi+32]
	cmp	edx, ecx
	je	SHORT $LN84@Reset
	mov	eax, ecx
	cmp	ecx, ecx
	je	SHORT $LN109@Reset
$LL111@Reset:
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	add	eax, 4
	add	edx, 4
	cmp	eax, ecx
	jne	SHORT $LL111@Reset
$LN109@Reset:
	mov	DWORD PTR [esi+36], edx
$LN84@Reset:

; 1918 : 
; 1919 : 	m_iGreatPeopleRateModifier = 0;

	mov	DWORD PTR [esi+44], ebx

; 1920 : 	m_iGreatScientistRateModifier = 0;

	mov	DWORD PTR [esi+48], ebx

; 1921 : 	m_iGreatGeneralRateModifier = 0;

	mov	DWORD PTR [esi+52], ebx

; 1922 : 	m_iGreatGeneralExtraBonus = 0;

	mov	DWORD PTR [esi+56], ebx

; 1923 : 	m_iGreatPersonGiftInfluence = 0;

	mov	DWORD PTR [esi+60], ebx

; 1924 : 	m_iLevelExperienceModifier= 0;

	mov	DWORD PTR [esi+64], ebx

; 1925 : 	m_iMaxGlobalBuildingProductionModifier = 0;

	mov	DWORD PTR [esi+68], ebx

; 1926 : 	m_iMaxTeamBuildingProductionModifier = 0;

	mov	DWORD PTR [esi+72], ebx

; 1927 : 	m_iMaxPlayerBuildingProductionModifier = 0;

	mov	DWORD PTR [esi+76], ebx

; 1928 : 	m_iCityUnhappinessModifier = 0;

	mov	DWORD PTR [esi+80], ebx

; 1929 : 	m_iPopulationUnhappinessModifier = 0;

	mov	DWORD PTR [esi+84], ebx

; 1930 : 	m_iCityStateBonusModifier = 0;

	mov	DWORD PTR [esi+88], ebx

; 1931 : 	m_iCityStateFriendshipModifier = 0;

	mov	DWORD PTR [esi+92], ebx

; 1932 : 	m_iCityStateCombatModifier = 0;

	mov	DWORD PTR [esi+96], ebx

; 1933 : 	m_iLandBarbarianConversionPercent = 0;

	mov	DWORD PTR [esi+100], ebx

; 1934 : 	m_iLandBarbarianConversionExtraUnits = 0;

	mov	DWORD PTR [esi+104], ebx

; 1935 : 	m_iSeaBarbarianConversionPercent = 0;

	mov	DWORD PTR [esi+108], ebx

; 1936 : 	m_iCapitalBuildingModifier = 0;

	mov	DWORD PTR [esi+112], ebx

; 1937 : 	m_iPlotBuyCostModifier = 0;

	mov	DWORD PTR [esi+116], ebx

; 1938 : 	m_iPlotCultureCostModifier = 0;

	mov	DWORD PTR [esi+120], ebx

; 1939 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 1940 : 	m_iSciencePerGreatPersonBorn = 0;

	mov	DWORD PTR [esi+124], ebx

; 1941 : #endif
; 1942 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 1943 : 	m_iNumTurnsBeforeMinorAlliesRefuseBribes = 0;

	mov	DWORD PTR [esi+128], ebx

; 1944 : #endif
; 1945 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 1946 : 	m_iGoldenAgeTileBonusFaith = 0;

	mov	DWORD PTR [esi+132], ebx

; 1947 : #endif
; 1948 : 	m_iCultureFromKills = 0;

	mov	DWORD PTR [esi+136], ebx

; 1949 : 	m_iFaithFromKills = 0;

	mov	DWORD PTR [esi+140], ebx

; 1950 : 	m_iCityCultureBonus = 0;

	mov	DWORD PTR [esi+144], ebx

; 1951 : 	m_iCapitalThemingBonusModifier = 0;

	mov	DWORD PTR [esi+148], ebx

; 1952 : 	m_iPolicyCostModifier = 0;

	mov	DWORD PTR [esi+152], ebx

; 1953 : 	m_iCityConnectionTradeRouteChange = 0;

	mov	DWORD PTR [esi+156], ebx

; 1954 : 	m_iWonderProductionModifier = 0;

	mov	DWORD PTR [esi+160], ebx

; 1955 : 	m_iPlunderModifier = 0;

	mov	DWORD PTR [esi+164], ebx

; 1956 : 	m_iImprovementMaintenanceModifier = 0;

	mov	DWORD PTR [esi+168], ebx

; 1957 : 	m_iGoldenAgeDurationModifier = 0;

	mov	DWORD PTR [esi+172], ebx

; 1958 : 	m_iGoldenAgeMoveChange = 0;

	mov	DWORD PTR [esi+176], ebx

; 1959 : 	m_iGoldenAgeCombatModifier = 0;

	mov	DWORD PTR [esi+180], ebx

; 1960 : 	m_iGoldenAgeTourismModifier = 0;

	mov	DWORD PTR [esi+184], ebx

; 1961 : 	m_iGoldenAgeGreatArtistRateModifier = 0;

	mov	DWORD PTR [esi+188], ebx

; 1962 : 	m_iGoldenAgeGreatMusicianRateModifier = 0;

	mov	DWORD PTR [esi+192], ebx

; 1963 : 	m_iGoldenAgeGreatWriterRateModifier = 0;

	mov	DWORD PTR [esi+196], ebx

; 1964 : 	m_iExtraEmbarkMoves = 0;

	mov	DWORD PTR [esi+200], ebx

; 1965 : 	m_iNaturalWonderFirstFinderGold = 0;

	mov	DWORD PTR [esi+204], ebx

; 1966 : 	m_iNaturalWonderSubsequentFinderGold = 0;

	mov	DWORD PTR [esi+208], ebx

; 1967 : 	m_iNaturalWonderYieldModifier = 0;

	mov	DWORD PTR [esi+212], ebx

; 1968 : 	m_iNaturalWonderHappinessModifier = 0;

	mov	DWORD PTR [esi+216], ebx

; 1969 : 	m_iNearbyImprovementCombatBonus = 0;

	mov	DWORD PTR [esi+220], ebx

; 1970 : 	m_iNearbyImprovementBonusRange = 0;

	mov	DWORD PTR [esi+224], ebx

; 1971 : 	m_iCultureBuildingYieldChange = 0;

	mov	DWORD PTR [esi+228], ebx

; 1972 : 	m_iCombatBonusVsHigherTech = 0;

	mov	DWORD PTR [esi+232], ebx

; 1973 : 	m_iCombatBonusVsLargerCiv = 0;

	mov	DWORD PTR [esi+236], ebx

; 1974 : 	m_iLandUnitMaintenanceModifier = 0;

	mov	DWORD PTR [esi+240], ebx

; 1975 : 	m_iNavalUnitMaintenanceModifier = 0;

	mov	DWORD PTR [esi+244], ebx

; 1976 : 	m_iRazeSpeedModifier = 0;

	mov	DWORD PTR [esi+248], ebx

; 1977 : 	m_iDOFGreatPersonModifier = 0;

	mov	DWORD PTR [esi+252], ebx

; 1978 : 	m_iLuxuryHappinessRetention = 0;

	mov	DWORD PTR [esi+256], ebx

; 1979 : 	m_iExtraHappinessPerLuxury = 0; // NQMP GJS - New Netherlands UA

	mov	DWORD PTR [esi+260], ebx

; 1980 : 	m_iExtraSpies = 0;

	mov	DWORD PTR [esi+264], ebx

; 1981 : 	m_iHappinessPerReligion = 0; // NQMP GJS - New Ottoman UA

	mov	DWORD PTR [esi+268], ebx

; 1982 : 	m_iUnresearchedTechBonusFromKills = 0;

	mov	DWORD PTR [esi+272], ebx

; 1983 : 	m_iExtraFoundedCityTerritoryClaimRange = 0;

	mov	DWORD PTR [esi+276], ebx

; 1984 : 	m_iFreeSocialPoliciesPerEra = 0;

	mov	DWORD PTR [esi+280], ebx

; 1985 : 	m_iNumTradeRoutesModifier = 0;

	mov	DWORD PTR [esi+284], ebx

; 1986 : 	m_iTradeRouteResourceModifier = 0;

	mov	DWORD PTR [esi+288], ebx

; 1987 : 	m_iUniqueLuxuryCities = 0;

	mov	DWORD PTR [esi+292], ebx

; 1988 : 	m_iUniqueLuxuryQuantity = 0;

	mov	DWORD PTR [esi+296], ebx

; 1989 : 	m_iWorkerSpeedModifier = 0;

	mov	DWORD PTR [esi+304], ebx

; 1990 : 	m_iAfraidMinorPerTurnInfluence = 0;

	mov	DWORD PTR [esi+308], ebx

; 1991 : 	m_iLandTradeRouteRangeBonus = 0;

	mov	DWORD PTR [esi+312], ebx

; 1992 : 	m_iTradeReligionModifier = 0;

	mov	DWORD PTR [esi+316], ebx

; 1993 : 	m_iTradeBuildingModifier = 0;

	mov	DWORD PTR [esi+320], ebx

; 1994 : 
; 1995 : 	m_bFightWellDamaged = false;

	mov	BYTE PTR [esi+324], bl

; 1996 : 	m_bMoveFriendlyWoodsAsRoad = false;

	mov	BYTE PTR [esi+325], bl

; 1997 : 	m_bFasterAlongRiver = false;

	mov	BYTE PTR [esi+326], bl

; 1998 : 	m_bFasterInHills = false;

	mov	BYTE PTR [esi+327], bl

; 1999 : 	m_bEmbarkedAllWater = false;

	mov	BYTE PTR [esi+328], bl

; 2000 : 	m_bEmbarkedToLandFlatCost = false;

	mov	BYTE PTR [esi+329], bl

; 2001 : 	m_bNoHillsImprovementMaintenance = false;

	mov	BYTE PTR [esi+330], bl

; 2002 : 	m_bTechBoostFromCapitalScienceBuildings = false;

	mov	BYTE PTR [esi+331], bl

; 2003 : 	m_bStaysAliveZeroCities = false;

	mov	BYTE PTR [esi+332], bl

; 2004 : 	m_bFaithFromUnimprovedForest = false;

	mov	BYTE PTR [esi+333], bl

; 2005 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 2006 : 	m_bSeaTradeRoutesArePlunderImmune = false;

	mov	BYTE PTR [esi+334], bl

; 2007 : #endif
; 2008 : 	
; 2009 : 	// NQMP GJS - New France UA begin
; 2010 : 	m_bEarnsGreatPersonOnSlotOrGuild = false;

	mov	BYTE PTR [esi+335], bl

; 2011 : 	m_bHasBuiltWritersGuild = false;
; 2012 : 	m_bHasBuiltArtistsGuild = false;
; 2013 : 	m_bHasBuiltMusiciansGuild = false;
; 2014 : 	// NQMP GJS - New France UA end
; 2015 : 	
; 2016 : 	m_bBonusReligiousBelief = false;
; 2017 : 	m_bAbleToAnnexCityStates = false;
; 2018 : 	m_bCrossesMountainsAfterGreatGeneral = false;
; 2019 : 	m_bMayaCalendarBonuses = false;
; 2020 : 	m_bNoAnnexing = false;
; 2021 : 	m_bTechFromCityConquer = false;
; 2022 : 	m_bUniqueLuxuryRequiresNewArea = false;
; 2023 : 	m_bRiverTradeRoad = false;
; 2024 : 	m_bAngerFreeIntrusionOfCityStates = false;
; 2025 : 
; 2026 : 	m_eCampGuardType = NO_UNIT;

	mov	DWORD PTR [esi+348], edi

; 2027 : 	m_eCombatBonusImprovement = NO_IMPROVEMENT;

	mov	DWORD PTR [esi+360], edi

; 2028 : 
; 2029 : 	m_ppaaiImprovementYieldChange.clear();

	lea	edi, DWORD PTR [esi+784]
	mov	BYTE PTR [esi+336], bl
	mov	BYTE PTR [esi+337], bl
	mov	BYTE PTR [esi+338], bl
	mov	BYTE PTR [esi+339], bl
	mov	BYTE PTR [esi+340], bl
	mov	BYTE PTR [esi+341], bl
	mov	BYTE PTR [esi+342], bl
	mov	BYTE PTR [esi+343], bl
	mov	BYTE PTR [esi+344], bl
	mov	BYTE PTR [esi+345], bl
	mov	BYTE PTR [esi+346], bl
	mov	BYTE PTR [esi+347], bl
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, eax
	je	SHORT $LN128@Reset
	mov	BYTE PTR $T257541[esp+80], bl
	mov	edx, DWORD PTR $T257541[esp+80]
	push	edx
	mov	edx, DWORD PTR __Cat$257545[esp+84]
	push	edx
	mov	edx, DWORD PTR $T257543[esp+88]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+8], eax
$LN128@Reset:

; 2030 : 	m_ppaaiImprovementYieldChange.resize(GC.getNumImprovementInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	edx, DWORD PTR $T257561[esp+80]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR $T257561[esp+108]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR $T257561[esp+112]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR $T257561[esp+116]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR $T257561[esp+120]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR $T257561[esp+124]
	mov	DWORD PTR [ecx+20], edx
	push	eax
	mov	ecx, edi
	call	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize

; 2031 : 	m_ppaaiSpecialistYieldChange.clear();

	mov	eax, DWORD PTR [esi+808]
	mov	ecx, DWORD PTR [esi+804]
	lea	edi, DWORD PTR [esi+800]
	cmp	ecx, eax
	je	SHORT $LN169@Reset
	mov	BYTE PTR $T257736[esp+80], bl
	mov	edx, DWORD PTR $T257736[esp+80]
	push	edx
	mov	edx, DWORD PTR __Cat$257740[esp+84]
	push	edx
	mov	edx, DWORD PTR $T257738[esp+88]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+8], eax
$LN169@Reset:

; 2032 : 	m_ppaaiSpecialistYieldChange.resize(GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	mov	edx, DWORD PTR $T257756[esp+80]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR $T257756[esp+108]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR $T257756[esp+112]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR $T257756[esp+116]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR $T257756[esp+120]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR $T257756[esp+124]
	mov	DWORD PTR [ecx+20], edx
	push	eax
	mov	ecx, edi
	call	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize

; 2033 : 	m_ppaaiUnimprovedFeatureYieldChange.clear();

	mov	eax, DWORD PTR [esi+824]
	mov	ecx, DWORD PTR [esi+820]
	lea	edi, DWORD PTR [esi+816]
	cmp	ecx, eax
	je	SHORT $LN210@Reset
	mov	BYTE PTR $T257937[esp+80], bl
	mov	edx, DWORD PTR $T257937[esp+80]
	push	edx
	mov	edx, DWORD PTR __Cat$257941[esp+84]
	push	edx
	mov	edx, DWORD PTR $T257939[esp+88]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAV?$Array@H$05@Firaxis@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+8], eax
$LN210@Reset:

; 2034 : 	m_ppaaiUnimprovedFeatureYieldChange.resize(GC.getNumFeatureInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	mov	edx, DWORD PTR $T257951[esp+80]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR $T257951[esp+108]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR $T257951[esp+112]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR $T257951[esp+116]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR $T257951[esp+120]
	mov	DWORD PTR [ecx+16], edx
	mov	edx, DWORD PTR $T257951[esp+124]
	mov	DWORD PTR [ecx+20], edx
	push	eax
	mov	ecx, edi
	call	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize

; 2035 : 
; 2036 : 	Firaxis::Array< int, NUM_YIELD_TYPES > yield;
; 2037 : 	for(unsigned int j = 0; j < NUM_YIELD_TYPES; ++j)
; 2038 : 	{
; 2039 : 		yield[j] = 0;
; 2040 : 	}
; 2041 : 
; 2042 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	lea	eax, DWORD PTR [esi+400]
	xor	edi, edi
	mov	DWORD PTR tv3646[esp+80], eax
	mov	DWORD PTR tv204[esp+80], 6
	npad	11
$LL27@Reset:

; 2043 : 	{
; 2044 : 		m_iExtraYieldThreshold[iYield] = 0;

	mov	eax, DWORD PTR tv3646[esp+80]

; 2045 : 		m_iFreeCityYield[iYield] = 0;
; 2046 : 		m_iYieldChangeStrategicResources[iYield] = 0;
; 2047 : 		m_iYieldChangeLuxuryResources[iYield] = 0; // NQMP GJS - New Netherlands UA
; 2048 : 		m_iYieldChangeNaturalWonder[iYield] = 0;
; 2049 : 		m_iYieldChangePerTradePartner[iYield] = 0;
; 2050 : 		m_iYieldChangeIncomingTradeRoute[iYield] = 0;
; 2051 : 		m_iYieldRateModifier[iYield] = 0;
; 2052 : 
; 2053 : #ifdef AUI_WARNING_FIXES
; 2054 : 		for (uint iImprovement = 0; iImprovement < GC.getNumImprovementInfos(); iImprovement++)
; 2055 : 		{
; 2056 : 			m_ppaaiImprovementYieldChange[iImprovement] = yield;
; 2057 : 		}
; 2058 : 		for (uint iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)
; 2059 : 		{
; 2060 : 			m_ppaaiSpecialistYieldChange[iSpecialist] = yield;
; 2061 : 		}
; 2062 : 		for (uint iFeature = 0; iFeature < GC.getNumFeatureInfos(); iFeature++)
; 2063 : #else
; 2064 : 		for(int iImprovement = 0; iImprovement < GC.getNumImprovementInfos(); iImprovement++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [eax-24], ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+48], ebx
	mov	DWORD PTR [eax+72], ebx
	mov	DWORD PTR [eax+96], ebx
	mov	DWORD PTR [eax+120], ebx
	mov	DWORD PTR [eax+144], ebx
	xor	ebp, ebp
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	test	eax, eax
	jle	SHORT $LN22@Reset

; 2043 : 	{
; 2044 : 		m_iExtraYieldThreshold[iYield] = 0;

	mov	DWORD PTR tv3422[esp+80], ebx
$LL24@Reset:

; 2065 : 		{
; 2066 : 			m_ppaaiImprovementYieldChange[iImprovement] = yield;

	mov	eax, DWORD PTR [esi+788]
	mov	ecx, DWORD PTR tv3422[esp+80]
	add	eax, ecx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	add	ecx, 24					; 00000018H
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR tv3422[esp+80], ecx
	mov	DWORD PTR [eax+16], edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [eax+20], edi
	inc	ebp
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	ebp, eax
	jl	SHORT $LL24@Reset
$LN22@Reset:

; 2067 : 		}
; 2068 : 		for(int iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	test	eax, eax
	jle	SHORT $LN19@Reset
	xor	ecx, ecx
	jmp	SHORT $LN21@Reset
	npad	7
$LL762@Reset:
	mov	ecx, DWORD PTR tv3458[esp+80]
$LN21@Reset:

; 2069 : 		{
; 2070 : 			m_ppaaiSpecialistYieldChange[iSpecialist] = yield;

	mov	eax, DWORD PTR [esi+804]
	add	eax, ecx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	add	ecx, 24					; 00000018H
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR tv3458[esp+80], ecx
	mov	DWORD PTR [eax+16], edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [eax+20], edi
	inc	ebp
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	ebp, eax
	jl	SHORT $LL762@Reset
$LN19@Reset:

; 2071 : 		}
; 2072 : 		for(int iFeature = 0; iFeature < GC.getNumFeatureInfos(); iFeature++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	test	eax, eax
	jle	SHORT $LN26@Reset
	mov	DWORD PTR tv3494[esp+80], ebx
	npad	9
$LL18@Reset:

; 2073 : #endif
; 2074 : 		{
; 2075 : 			m_ppaaiUnimprovedFeatureYieldChange[iFeature] = yield;

	mov	eax, DWORD PTR [esi+820]
	mov	ecx, DWORD PTR tv3494[esp+80]
	add	eax, ecx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	add	ecx, 24					; 00000018H
	mov	DWORD PTR [eax+12], edi
	mov	DWORD PTR tv3494[esp+80], ecx
	mov	DWORD PTR [eax+16], edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [eax+20], edi
	inc	ebp
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	ebp, eax
	jl	SHORT $LL18@Reset
$LN26@Reset:

; 2035 : 
; 2036 : 	Firaxis::Array< int, NUM_YIELD_TYPES > yield;
; 2037 : 	for(unsigned int j = 0; j < NUM_YIELD_TYPES; ++j)
; 2038 : 	{
; 2039 : 		yield[j] = 0;
; 2040 : 	}
; 2041 : 
; 2042 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	add	DWORD PTR tv3646[esp+80], 4
	sub	DWORD PTR tv204[esp+80], 1
	jne	$LL27@Reset

; 2076 : 		}
; 2077 : 	}
; 2078 : 
; 2079 : #ifdef AUI_WARNING_FIXES
; 2080 : 	for (uint iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)
; 2081 : #else
; 2082 : 	for(int iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	test	eax, eax
	jle	SHORT $LN13@Reset
	lea	ebp, DWORD PTR [esi+568]
	npad	7
$LL15@Reset:

; 2083 : #endif
; 2084 : 	{
; 2085 : 		m_iStrategicResourceQuantityModifier[iTerrain] = 0;

	mov	DWORD PTR [ebp], ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	add	ebp, 4
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	edi, eax
	jl	SHORT $LL15@Reset
$LN13@Reset:

; 2086 : 	}
; 2087 : 
; 2088 : 	m_aiResourceQuantityModifier.clear();

	mov	ecx, DWORD PTR [esi+612]
	mov	edx, DWORD PTR [esi+608]
	lea	edi, DWORD PTR [esi+604]
	cmp	edx, ecx
	je	SHORT $LN274@Reset
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	ebp, DWORD PTR [eax*4]
	mov	DWORD PTR tv2691[esp+80], ebp
	add	ebp, edx
	cmp	eax, ebx
	jle	SHORT $LN299@Reset
	mov	eax, DWORD PTR tv2691[esp+80]
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN299@Reset:
	mov	DWORD PTR [edi+8], ebp
$LN274@Reset:

; 2089 : 	m_aiResourceQuantityModifier.resize(GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	edx, DWORD PTR [edi+8]
	mov	ebp, DWORD PTR [edi+4]
	mov	ecx, edx
	sub	ecx, ebp
	sar	ecx, 2
	mov	DWORD PTR $T258487[esp+80], ebx
	cmp	eax, ecx
	jbe	SHORT $LN767@Reset
	lea	ebp, DWORD PTR $T258487[esp+80]
	push	ebp
	sub	eax, ecx
	push	eax
	push	edx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN339@Reset
$LN767@Reset:
	jae	SHORT $LN339@Reset
	lea	ebp, DWORD PTR [ebp+eax*4]
	mov	DWORD PTR $T258496[esp+80], ebp
	cmp	ebp, edx
	je	SHORT $LN339@Reset
	mov	eax, edx
	sub	eax, edx
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	add	ebp, ecx
	cmp	eax, ebx
	jle	SHORT $LN364@Reset
	push	ecx
	push	edx
	push	ecx
	mov	ecx, DWORD PTR $T258496[esp+92]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN364@Reset:
	mov	DWORD PTR [edi+8], ebp
$LN339@Reset:

; 2090 : 
; 2091 : #ifdef AUI_WARNING_FIXES
; 2092 : 	for (uint iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)
; 2093 : #else
; 2094 : 	for(int iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN10@Reset
	npad	2
$LL12@Reset:

; 2095 : #endif
; 2096 : 	{
; 2097 : 		m_aiResourceQuantityModifier[iResource] = 0;

	mov	edx, DWORD PTR [esi+608]
	mov	DWORD PTR [edx+edi*4], ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	edi, eax
	jl	SHORT $LL12@Reset
$LN10@Reset:

; 2098 : 	}
; 2099 : 
; 2100 : 	m_abNoTrain.clear();

	mov	eax, DWORD PTR [esi+620]
	mov	ecx, DWORD PTR [esi+628]
	lea	edi, DWORD PTR [esi+620]
	xor	edx, edx
	cmp	eax, ebx
	jbe	SHORT $LN390@Reset
	jge	SHORT $LN391@Reset
	mov	edx, eax
	neg	edx
	je	SHORT $LN391@Reset
	or	edx, -1
	sub	edx, eax
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ebp, -4					; fffffffcH
	sub	ebp, edx
	add	ecx, ebp
	jmp	SHORT $LN768@Reset
$LN391@Reset:
	mov	edx, eax
	shr	edx, 5
	lea	ecx, DWORD PTR [ecx+edx*4]
$LN768@Reset:
	and	eax, 31					; 0000001fH
	mov	edx, eax
$LN390@Reset:
	mov	eax, DWORD PTR [edi+8]
	push	edx
	push	ecx
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T258735[esp+96]
	push	eax
	mov	ecx, edi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase

; 2101 : 	m_abNoTrain.resize(GC.getNumUnitClassInfos());

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	push	eax
	mov	ecx, edi
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 2102 : #ifdef AUI_WARNING_FIXES
; 2103 : 	for (uint iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)
; 2104 : #else
; 2105 : 	for (int iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	test	eax, eax
	jle	SHORT $LN7@Reset
$LN9@Reset:

; 2106 : #endif
; 2107 : 	{
; 2108 : 		m_abNoTrain[iUnitClass] = false;

	mov	eax, DWORD PTR [esi+628]
	mov	ecx, ebx
	cmp	edi, ebx
	je	SHORT $LN431@Reset
	jge	SHORT $LN432@Reset
	mov	ecx, edi
	neg	ecx
	je	SHORT $LN432@Reset
	or	edx, -1
	sub	edx, edi
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ecx, -4					; fffffffcH
	sub	ecx, edx
	add	eax, ecx
	jmp	SHORT $LN769@Reset
$LN432@Reset:
	mov	edx, edi
	shr	edx, 5
	lea	eax, DWORD PTR [eax+edx*4]
$LN769@Reset:
	mov	ecx, edi
	and	ecx, 31					; 0000001fH
$LN431@Reset:
	mov	edx, 1
	shl	edx, cl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	not	edx
	and	DWORD PTR [eax], edx
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	edi, eax
	jl	SHORT $LN9@Reset
$LN7@Reset:

; 2109 : 	}
; 2110 : 
; 2111 : 	m_aFreeTraitUnits.clear();
; 2112 : 
; 2113 : #ifdef AUI_WARNING_FIXES
; 2114 : 	uint iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();
; 2115 : 	CvAssertMsg((0 < iNumUnitCombatClassInfos), "GC.getNumUnitCombatClassInfos() is not greater than zero but an array is being allocated in CvPlayerTraits::Reset");
; 2116 : 	m_paiMovesChangeUnitCombat.clear();
; 2117 : 	m_paiMaintenanceModifierUnitCombat.clear();
; 2118 : 	m_paiMovesChangeUnitCombat.resize(iNumUnitCombatClassInfos);
; 2119 : 	m_paiMaintenanceModifierUnitCombat.resize(iNumUnitCombatClassInfos);
; 2120 : 	for (uint iI = 0; iI < iNumUnitCombatClassInfos; iI++)
; 2121 : #else
; 2122 : 	int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+644], ebx
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos

; 2123 : 	CvAssertMsg((0 < iNumUnitCombatClassInfos),  "GC.getNumUnitCombatClassInfos() is not greater than zero but an array is being allocated in CvPlayerTraits::Reset");
; 2124 : 	m_paiMovesChangeUnitCombat.clear();

	mov	ecx, DWORD PTR [esi+760]
	mov	edx, DWORD PTR [esi+756]
	lea	ebp, DWORD PTR [esi+752]
	mov	edi, eax
	cmp	edx, ecx
	je	SHORT $LN478@Reset
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	ebp, DWORD PTR [eax*4]
	mov	DWORD PTR tv2781[esp+80], ebp
	add	ebp, edx
	cmp	eax, ebx
	mov	DWORD PTR __Result$259118[esp+80], ebp
	jle	SHORT $LN503@Reset
	mov	eax, DWORD PTR tv2781[esp+80]
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN503@Reset:
	mov	eax, DWORD PTR __Result$259118[esp+80]
	lea	ebp, DWORD PTR [esi+752]
	mov	DWORD PTR [ebp+8], eax
$LN478@Reset:

; 2125 : 	m_paiMaintenanceModifierUnitCombat.clear();

	mov	eax, DWORD PTR [esi+776]
	mov	edx, DWORD PTR [esi+772]
	cmp	edx, eax
	je	SHORT $LN520@Reset
	sub	eax, eax
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	add	edx, ecx
	cmp	eax, ebx
	mov	DWORD PTR __Result$259379[esp+80], edx
	jle	SHORT $LN545@Reset
	mov	eax, DWORD PTR [esi+776]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+772]
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN545@Reset:
	mov	ecx, DWORD PTR __Result$259379[esp+80]
	mov	DWORD PTR [esi+776], ecx
$LN520@Reset:

; 2126 : 	m_paiMovesChangeUnitCombat.resize(iNumUnitCombatClassInfos);

	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	mov	DWORD PTR $T259672[esp+80], ebx
	cmp	edi, eax
	jbe	SHORT $LN770@Reset
	lea	edx, DWORD PTR $T259672[esp+80]
	push	edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN585@Reset
$LN770@Reset:
	jae	SHORT $LN585@Reset
	lea	ebp, DWORD PTR [edx+edi*4]
	mov	DWORD PTR $T259681[esp+80], ebp
	cmp	ebp, ecx
	je	SHORT $LN585@Reset
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebp, edx
	cmp	eax, ebx
	jle	SHORT $LN610@Reset
	mov	eax, DWORD PTR $T259681[esp+80]
	push	edx
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN610@Reset:
	mov	DWORD PTR [esi+760], ebp
$LN585@Reset:

; 2127 : 	m_paiMaintenanceModifierUnitCombat.resize(iNumUnitCombatClassInfos);

	mov	ecx, DWORD PTR [esi+776]
	mov	ebp, DWORD PTR [esi+772]
	lea	edx, DWORD PTR [esi+768]
	mov	eax, ecx
	sub	eax, ebp
	sar	eax, 2
	mov	DWORD PTR $T260041[esp+80], ebx
	cmp	edi, eax
	jbe	SHORT $LN771@Reset
	lea	ebp, DWORD PTR $T260041[esp+80]
	push	ebp
	mov	ebp, edi
	sub	ebp, eax
	push	ebp
	push	ecx
	mov	ecx, edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN650@Reset
$LN771@Reset:
	jae	SHORT $LN650@Reset
	lea	ebp, DWORD PTR [ebp+edi*4]
	mov	DWORD PTR $T260055[esp+80], ebp
	cmp	ebp, ecx
	je	SHORT $LN650@Reset
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebp, edx
	cmp	eax, ebx
	jle	SHORT $LN675@Reset
	push	edx
	push	ecx
	mov	ecx, DWORD PTR $T260055[esp+88]
	push	edx
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN675@Reset:
	mov	DWORD PTR [esi+776], ebp
$LN650@Reset:

; 2128 : 	for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	xor	eax, eax
	cmp	edi, ebx
	jle	SHORT $LN4@Reset
	npad	12
$LL6@Reset:

; 2129 : #endif
; 2130 : 	{
; 2131 : 		m_paiMovesChangeUnitCombat[iI] = 0;

	mov	edx, DWORD PTR [esi+756]
	mov	DWORD PTR [edx+eax*4], ebx

; 2132 : 		m_paiMaintenanceModifierUnitCombat[iI] = 0;

	mov	ecx, DWORD PTR [esi+772]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL6@Reset
$LN4@Reset:

; 2133 : 	}
; 2134 : 
; 2135 : #ifdef AUI_WARNING_FIXES
; 2136 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2137 : #else
; 2138 : 	int iResourceLoop;
; 2139 : 	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN1@Reset

; 2140 : #endif
; 2141 : 	{
; 2142 : 		FreeResourceXCities temp;

	mov	DWORD PTR _temp$223166[esp+80], ebx
	mov	DWORD PTR _temp$223166[esp+84], ebx
	add	esi, 832				; 00000340H
$LL3@Reset:

; 2143 : 		m_aFreeResourceXCities.push_back(temp);

	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	jne	SHORT $LN692@Reset
	xor	eax, eax
	jmp	SHORT $LN693@Reset
$LN692@Reset:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN693@Reset:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN685@Reset
	mov	BYTE PTR $T260297[esp+80], bl
	mov	eax, DWORD PTR $T260297[esp+80]
	mov	ecx, DWORD PTR __Cat$260301[esp+80]
	push	eax
	push	ecx
	push	esi
	lea	edx, DWORD PTR _temp$223166[esp+92]
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN2@Reset
$LN685@Reset:
	lea	eax, DWORD PTR _temp$223166[esp+80]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n
$LN2@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	ebp, eax
	jl	SHORT $LL3@Reset
$LN1@Reset:

; 2144 : 	}
; 2145 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T257023[ebp+4]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$0:
	lea	ecx, DWORD PTR $T257023[ebp]
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$?Reset@CvPlayerTraits@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?Reset@CvPlayerTraits@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Reset@CvPlayerTraits@@QAEXXZ ENDP			; CvPlayerTraits::Reset
PUBLIC	?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::ChooseMayaBoost
EXTRN	?ChangeNumMayaBoosts@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumMayaBoosts
EXTRN	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z:PROC ; CvCityCitizens::DoSpawnGreatPerson
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?GetGreatPersonSpawnCity@CvPlayer@@QAEPAVCvCity@@W4UnitTypes@@@Z:PROC ; CvPlayer::GetGreatPersonSpawnCity
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ:PROC ; CvDiplomacyAI::GetWonderCompetitiveness
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ:PROC ; CvGameReligions::GetNumReligionsStillToFound
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligionCreatedByPlayer
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
_choice$261095 = -8					; size = 8
_ePossibleGreatPerson$ = -8				; size = 4
?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ PROC		; CvPlayerTraits::ChooseMayaBoost, COMDAT
; _this$ = ecx

; 2689 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2690 : 	UnitTypes eDesiredGreatPerson = NO_UNIT;
; 2691 : 	UnitTypes ePossibleGreatPerson;
; 2692 : 
; 2693 : 	// Go for a prophet?
; 2694 : 	ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_PROPHET", true);

	push	1
	mov	esi, ecx
	push	OFFSET $SG223461
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	or	edi, -1
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+744]
	mov	ebp, eax

; 2695 : 	if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR [esi+740]
	cmp	eax, ecx
	je	SHORT $LN319@ChooseMaya
	npad	1
$LL57@ChooseMaya:
	cmp	DWORD PTR [eax], ebp
	je	SHORT $LN292@ChooseMaya
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL57@ChooseMaya

; 2784 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	jmp	SHORT $LN319@ChooseMaya
$LN292@ChooseMaya:

; 2695 : 	if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN320@ChooseMaya
$LN319@ChooseMaya:

; 2696 : 	{
; 2697 : 		CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ebx, eax

; 2698 : 		ReligionTypes eReligion = pReligions->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, ebx
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer

; 2699 : 
; 2700 : 		// Have a religion that isn't enhanced yet?
; 2701 : 		if(eReligion != NO_RELIGION)

	cmp	eax, -1
	je	SHORT $LN39@ChooseMaya

; 2702 : 		{
; 2703 : 			const CvReligion* pMyReligion = pReligions->GetReligion(eReligion, m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	push	eax
	mov	ecx, ebx
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 2704 : 			if(!pMyReligion->m_bEnhanced)

	cmp	BYTE PTR [eax+21], 0
	jne	SHORT $LN320@ChooseMaya

; 2705 : 			{
; 2706 : 				eDesiredGreatPerson = ePossibleGreatPerson;
; 2707 : 			}
; 2708 : 		}
; 2709 : 
; 2710 : 		// Don't have a religion and they can still be founded?
; 2711 : 		else

	jmp	SHORT $LN330@ChooseMaya
$LN39@ChooseMaya:

; 2712 : 		{
; 2713 : 			if(pReligions->GetNumReligionsStillToFound() > 0)

	mov	ecx, ebx
	call	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ ; CvGameReligions::GetNumReligionsStillToFound
	test	eax, eax
	jle	SHORT $LN320@ChooseMaya
$LN330@ChooseMaya:

; 2714 : 			{
; 2715 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	edi, ebp

; 2716 : 			}
; 2717 : 		}
; 2718 : 	}
; 2719 : 
; 2720 : 	// Highly wonder competitive and still early in game?
; 2721 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	ebp, -1
	jne	SHORT $LN321@ChooseMaya
$LN320@ChooseMaya:

; 2722 : 	{
; 2723 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ENGINEER");

	push	0
	push	OFFSET $SG223472
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+744]
	mov	edx, eax

; 2724 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR [esi+740]
	mov	DWORD PTR _ePossibleGreatPerson$[esp+24], edx
	cmp	eax, ecx
	je	SHORT $LN309@ChooseMaya
$LL99@ChooseMaya:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN293@ChooseMaya
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL99@ChooseMaya

; 2784 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	jmp	SHORT $LN309@ChooseMaya
$LN293@ChooseMaya:

; 2724 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN321@ChooseMaya
$LN309@ChooseMaya:

; 2725 : 		{
; 2726 : 			if(m_pPlayer->GetDiplomacyAI()->GetWonderCompetitiveness() >= 8 && GC.getGame().getGameTurn() <= (GC.getGame().getEstimateEndTurn() / 2))

	mov	ecx, DWORD PTR [esi+4]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ ; CvDiplomacyAI::GetWonderCompetitiveness
	cmp	eax, 8
	jl	SHORT $LN321@ChooseMaya
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, ecx
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	cdq
	sub	eax, edx
	mov	ebx, eax
	mov	ecx, ebp
	sar	ebx, 1
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, ebx
	jg	SHORT $LN321@ChooseMaya

; 2727 : 			{
; 2728 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	edi, DWORD PTR _ePossibleGreatPerson$[esp+24]
$LN321@ChooseMaya:

; 2729 : 			}
; 2730 : 		}
; 2731 : 	}
; 2732 : 
; 2733 : 	// Does our grand strategy match one that is available?
; 2734 : 	AIGrandStrategyTypes eVictoryStrategy = m_pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	ecx, DWORD PTR [esi+4]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	mov	ebx, eax

; 2735 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	edi, -1
	jne	$LN324@ChooseMaya

; 2736 : 	{
; 2737 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_SCIENTIST");

	push	0
	push	OFFSET $SG223478
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+744]
	mov	edi, eax

; 2738 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR [esi+740]
	cmp	eax, ecx
	je	SHORT $LN326@ChooseMaya
	npad	6
$LL135@ChooseMaya:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN294@ChooseMaya
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL135@ChooseMaya

; 2784 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	jmp	SHORT $LN326@ChooseMaya
$LN294@ChooseMaya:

; 2738 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN311@ChooseMaya
$LN326@ChooseMaya:

; 2739 : 		{
; 2740 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))

	push	0
	push	OFFSET $SG223482
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN311@ChooseMaya

; 2741 : 			{
; 2742 : 				eDesiredGreatPerson = ePossibleGreatPerson;
; 2743 : 			}
; 2744 : 		}
; 2745 : 	}
; 2746 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	edi, -1
	jne	$LN324@ChooseMaya
$LN311@ChooseMaya:

; 2747 : 	{
; 2748 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ARTIST");

	push	0
	push	OFFSET $SG223485
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+744]
	mov	edi, eax

; 2749 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR [esi+740]
	cmp	eax, ecx
	je	SHORT $LN327@ChooseMaya
$LL167@ChooseMaya:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN295@ChooseMaya
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL167@ChooseMaya

; 2784 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	jmp	SHORT $LN327@ChooseMaya
$LN295@ChooseMaya:

; 2749 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN313@ChooseMaya
$LN327@ChooseMaya:

; 2750 : 		{
; 2751 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))

	push	0
	push	OFFSET $SG223489
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN313@ChooseMaya

; 2752 : 			{
; 2753 : 				eDesiredGreatPerson = ePossibleGreatPerson;
; 2754 : 			}
; 2755 : 		}
; 2756 : 	}
; 2757 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	edi, -1
	jne	$LN324@ChooseMaya
$LN313@ChooseMaya:

; 2758 : 	{
; 2759 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MERCHANT");

	push	0
	push	OFFSET $SG223492
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+744]
	mov	edi, eax

; 2760 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR [esi+740]
	cmp	eax, ecx
	je	SHORT $LN328@ChooseMaya
$LL199@ChooseMaya:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN296@ChooseMaya
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL199@ChooseMaya

; 2784 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	jmp	SHORT $LN328@ChooseMaya
$LN296@ChooseMaya:

; 2760 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN315@ChooseMaya
$LN328@ChooseMaya:

; 2761 : 		{
; 2762 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))

	push	0
	push	OFFSET $SG223496
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN315@ChooseMaya

; 2763 : 			{
; 2764 : 				eDesiredGreatPerson = ePossibleGreatPerson;
; 2765 : 			}
; 2766 : 		}
; 2767 : 	}
; 2768 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	edi, -1
	jne	$LN324@ChooseMaya
$LN315@ChooseMaya:

; 2769 : 	{
; 2770 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_GENERAL");

	push	0
	push	OFFSET $SG223499
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+744]
	mov	edi, eax

; 2771 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR [esi+740]
	cmp	eax, ecx
	je	SHORT $LN329@ChooseMaya
	npad	4
$LL231@ChooseMaya:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN297@ChooseMaya
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL231@ChooseMaya

; 2784 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	jmp	SHORT $LN329@ChooseMaya
$LN297@ChooseMaya:

; 2771 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN317@ChooseMaya
$LN329@ChooseMaya:

; 2772 : 		{
; 2773 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))

	push	0
	push	OFFSET $SG223503
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	ebx, eax
	jne	SHORT $LN317@ChooseMaya

; 2774 : 			{
; 2775 : 				eDesiredGreatPerson = ePossibleGreatPerson;
; 2776 : 			}
; 2777 : 		}
; 2778 : 	}
; 2779 : 
; 2780 : 	// No obvious strategic choice, just go for first one available in a reasonable order
; 2781 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	edi, -1
	jne	$LN324@ChooseMaya
$LN317@ChooseMaya:

; 2782 : 	{
; 2783 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_PROPHET", true);

	push	1
	push	OFFSET $SG223506
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+744]
	mov	edi, eax

; 2784 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR [esi+740]
	cmp	eax, ecx
	je	$LN3@ChooseMaya
$LL263@ChooseMaya:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN298@ChooseMaya
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL263@ChooseMaya
	jmp	$LN3@ChooseMaya
$LN298@ChooseMaya:
	cmp	DWORD PTR [eax+4], 0

; 2785 : 		{
; 2786 : 			eDesiredGreatPerson = ePossibleGreatPerson;
; 2787 : 		}
; 2788 : 		else

	je	$LN3@ChooseMaya

; 2789 : 		{
; 2790 : 			ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ENGINEER");

	push	0
	push	OFFSET $SG223510
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2791 : 			if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax

; 2792 : 			{
; 2793 : 				eDesiredGreatPerson = ePossibleGreatPerson;
; 2794 : 			}
; 2795 : 			else

	je	$LN3@ChooseMaya

; 2796 : 			{
; 2797 : 				ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_WRITER");

	push	0
	push	OFFSET $SG223514
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2798 : 				if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax

; 2799 : 				{
; 2800 : 					eDesiredGreatPerson = ePossibleGreatPerson;
; 2801 : 				}
; 2802 : 				else

	je	$LN3@ChooseMaya

; 2803 : 				{
; 2804 : 					ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MERCHANT");

	push	0
	push	OFFSET $SG223518
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2805 : 					if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax

; 2806 : 					{
; 2807 : 						eDesiredGreatPerson = ePossibleGreatPerson;
; 2808 : 					}
; 2809 : 					else

	je	$LN3@ChooseMaya

; 2810 : 					{
; 2811 : 						ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_SCIENTIST");

	push	0
	push	OFFSET $SG223522
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2812 : 						if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax

; 2813 : 						{
; 2814 : 							eDesiredGreatPerson = ePossibleGreatPerson;
; 2815 : 						}
; 2816 : 						else

	je	SHORT $LN3@ChooseMaya

; 2817 : 						{
; 2818 : 							ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ARTIST");

	push	0
	push	OFFSET $SG223526
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2819 : 							if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax

; 2820 : 							{
; 2821 : 								eDesiredGreatPerson = ePossibleGreatPerson;
; 2822 : 							}
; 2823 : 							else

	je	SHORT $LN3@ChooseMaya

; 2824 : 							{
; 2825 : 								ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MUSICIAN");

	push	0
	push	OFFSET $SG223530
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2826 : 								if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax

; 2827 : 								{
; 2828 : 									eDesiredGreatPerson = ePossibleGreatPerson;
; 2829 : 								}
; 2830 : 								else

	je	SHORT $LN3@ChooseMaya

; 2831 : 								{
; 2832 : 									ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_GENERAL");

	push	0
	push	OFFSET $SG223534
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2833 : 									if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax

; 2834 : 									{
; 2835 : 										eDesiredGreatPerson = ePossibleGreatPerson;
; 2836 : 									}
; 2837 : 									else

	je	SHORT $LN3@ChooseMaya

; 2838 : 									{
; 2839 : 										ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_ADMIRAL");

	push	0
	push	OFFSET $SG223538
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 2840 : 										if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	push	edi
	mov	ecx, esi
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN2@ChooseMaya
$LN3@ChooseMaya:

; 2841 : 										{
; 2842 : 											eDesiredGreatPerson = ePossibleGreatPerson;
; 2843 : 										}
; 2844 : 									}
; 2845 : 								}
; 2846 : 							}
; 2847 : 						}
; 2848 : 					}
; 2849 : 				}
; 2850 : 			}
; 2851 : 		}
; 2852 : 	}
; 2853 : 
; 2854 : 	// Actually get the great person
; 2855 : 	if(eDesiredGreatPerson != NO_UNIT)

	cmp	edi, -1
	je	SHORT $LN2@ChooseMaya
$LN324@ChooseMaya:

; 2856 : 	{
; 2857 : 		CvCity* pCity = m_pPlayer->GetGreatPersonSpawnCity(eDesiredGreatPerson);

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	?GetGreatPersonSpawnCity@CvPlayer@@QAEPAVCvCity@@W4UnitTypes@@@Z ; CvPlayer::GetGreatPersonSpawnCity

; 2858 : 		if(pCity)

	test	eax, eax
	je	SHORT $LN281@ChooseMaya

; 2859 : 		{
; 2860 : 			pCity->GetCityCitizens()->DoSpawnGreatPerson(eDesiredGreatPerson, true, false);

	push	0
	push	1
	push	edi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson

; 2861 : 			SetUnitBaktun(eDesiredGreatPerson);

	mov	edx, DWORD PTR [esi+716]
	lea	eax, DWORD PTR _choice$261095[esp+24]
	push	eax
	lea	ecx, DWORD PTR [esi+736]
	mov	DWORD PTR _choice$261095[esp+28], edi
	mov	DWORD PTR _choice$261095[esp+32], edx
	call	?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back
$LN281@ChooseMaya:

; 2862 : 		}
; 2863 : 		m_pPlayer->ChangeNumMayaBoosts(-1);

	mov	ecx, DWORD PTR [esi+4]
	push	-1
	call	?ChangeNumMayaBoosts@CvPlayer@@QAEXH@Z	; CvPlayer::ChangeNumMayaBoosts
$LN2@ChooseMaya:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2864 : 	}
; 2865 : }

	add	esp, 8
	ret	0
?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ ENDP		; CvPlayerTraits::ChooseMayaBoost
_TEXT	ENDS
PUBLIC	?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z ; std::vector<bool,std::allocator<bool> >::push_back
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z
_TEXT	SEGMENT
$T261157 = -8						; size = 8
$T261156 = -8						; size = 8
__Val$ = 8						; size = 1
?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z PROC ; std::vector<bool,std::allocator<bool> >::push_back, COMDAT
; _this$ = ecx

; 2115 : 		{	// insert element at end

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2116 : 		insert(end(), _Val);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T261156[esp+12], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T261156[esp+16], 0
	test	eax, eax
	jbe	SHORT $LN20@push_back@7
	push	eax
	lea	ecx, DWORD PTR $T261156[esp+16]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@push_back@7:
	mov	ecx, DWORD PTR __Val$[esp+8]
	mov	edx, DWORD PTR $T261156[esp+16]
	mov	eax, DWORD PTR $T261156[esp+12]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T261157[esp+24]
	push	ecx
	mov	ecx, esi
	call	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert
	pop	esi

; 2117 : 		}

	add	esp, 8
	ret	4
?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::push_back
_TEXT	ENDS
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv2341 = -96						; size = 4
_iUnitClassLoop$222765 = -96				; size = 4
_YieldID$222763 = -96					; size = 4
_YieldID$222750 = -96					; size = 4
_YieldID$222737 = -96					; size = 4
_iResourceLoop$222779 = -92				; size = 4
_pResults$222771 = -92					; size = 4
_FeatureID$222762 = -92					; size = 4
_SpecialistID$222749 = -92				; size = 4
_ImprovementID$222736 = -92				; size = 4
_iUnitCombatID$222724 = -92				; size = 4
_iUnitCombatID$222711 = -92				; size = 4
_unitPromotionID$222619 = -92				; size = 4
_iTerrainID$222606 = -92				; size = 4
$T262204 = -88						; size = 1
$T261434 = -88						; size = 4
$T261289 = -88						; size = 8
_temp$222792 = -80					; size = 8
_temp$222783 = -80					; size = 8
$T261239 = -80						; size = 12
$T261236 = -80						; size = 8
_strKey$222769 = -68					; size = 28
_strKey$222754 = -68					; size = 28
_strKey$222741 = -68					; size = 28
_strKey$222728 = -68					; size = 28
_sqlKey$222715 = -68					; size = 28
_sqlKey$222702 = -68					; size = 28
_sqlKey$222610 = -68					; size = 28
_sqlKey$222597 = -68					; size = 28
_strKey$222784 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_szTraitType$ = 8					; size = 4
_kResults$ = 8						; size = 4
__Cat$262207 = 12					; size = 1
_iResource$222793 = 12					; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvTraitEntry::CacheResults, COMDAT
; _this$ = ecx

; 1039 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 1040 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+100]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN44@CacheResul
	pop	edi
	pop	esi

; 1489 : 
; 1490 : 	return true;
; 1491 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	8
$LN44@CacheResul:
	push	ebx

; 1041 : 		return false;
; 1042 : 
; 1043 : 	//Basic Properties
; 1044 : 	setShortDescription(kResults.GetText("ShortDescription"));

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	ebp
	push	OFFSET $SG222455
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+600]
	test	eax, eax
	je	SHORT $LN60@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN59@CacheResul
$LN60@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN59@CacheResul:

; 1045 : 
; 1046 : 	m_iLevelExperienceModifier				= kResults.GetInt("LevelExperienceModifier");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222456
	mov	ecx, edi
	call	ebp

; 1047 : 	m_iGreatPeopleRateModifier				= kResults.GetInt("GreatPeopleRateModifier");

	push	OFFSET $SG222457
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebp

; 1048 : 	m_iGreatScientistRateModifier			= kResults.GetInt("GreatScientistRateModifier");

	push	OFFSET $SG222458
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebp

; 1049 : 	m_iGreatGeneralRateModifier				= kResults.GetInt("GreatGeneralRateModifier");

	push	OFFSET $SG222459
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebp

; 1050 : 	m_iGreatGeneralExtraBonus				= kResults.GetInt("GreatGeneralExtraBonus");

	push	OFFSET $SG222460
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebp

; 1051 : 	m_iGreatPersonGiftInfluence				= kResults.GetInt("GreatPersonGiftInfluence");

	push	OFFSET $SG222461
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebp

; 1052 : 	m_iMaxGlobalBuildingProductionModifier	= kResults.GetInt("MaxGlobalBuildingProductionModifier");

	push	OFFSET $SG222462
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebp

; 1053 : 	m_iMaxTeamBuildingProductionModifier	= kResults.GetInt("MaxTeamBuildingProductionModifier");

	push	OFFSET $SG222463
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebp

; 1054 : 	m_iMaxPlayerBuildingProductionModifier	= kResults.GetInt("MaxPlayerBuildingProductionModifier");

	push	OFFSET $SG222464
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebp

; 1055 : 	m_iCityUnhappinessModifier           	= kResults.GetInt("CityUnhappinessModifier");

	push	OFFSET $SG222465
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebp

; 1056 : 	m_iPopulationUnhappinessModifier    	= kResults.GetInt("PopulationUnhappinessModifier");

	push	OFFSET $SG222466
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebp

; 1057 : 	m_iCityStateBonusModifier               = kResults.GetInt("CityStateBonusModifier");

	push	OFFSET $SG222467
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebp

; 1058 : 	m_iCityStateFriendshipModifier          = kResults.GetInt("CityStateFriendshipModifier");

	push	OFFSET $SG222468
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebp

; 1059 : 	m_iCityStateCombatModifier				= kResults.GetInt("CityStateCombatModifier");

	push	OFFSET $SG222469
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebp

; 1060 : 	m_iLandBarbarianConversionPercent       = kResults.GetInt("LandBarbarianConversionPercent");

	push	OFFSET $SG222470
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebp

; 1061 : 	m_iLandBarbarianConversionExtraUnits    = kResults.GetInt("LandBarbarianConversionExtraUnits");

	push	OFFSET $SG222471
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebp

; 1062 : 	m_iSeaBarbarianConversionPercent        = kResults.GetInt("SeaBarbarianConversionPercent");

	push	OFFSET $SG222472
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebp

; 1063 : 	m_iCapitalBuildingModifier				= kResults.GetInt("CapitalBuildingModifier");

	push	OFFSET $SG222473
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebp

; 1064 : 	m_iPlotBuyCostModifier					= kResults.GetInt("PlotBuyCostModifier");

	push	OFFSET $SG222474
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebp

; 1065 : 	m_iPlotCultureCostModifier              = kResults.GetInt("PlotCultureCostModifier");

	push	OFFSET $SG222475
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	ebp
	mov	DWORD PTR [esi+336], eax

; 1066 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 1067 : 	m_iSciencePerGreatPersonBorn			= kResults.GetInt("SciencePerGreatPersonBorn");

	push	OFFSET $SG222476
	mov	ecx, edi
	call	ebp

; 1068 : #endif
; 1069 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 1070 : 	m_iNumTurnsBeforeMinorAlliesRefuseBribes = kResults.GetInt("NumTurnsBeforeMinorAlliesRefuseBribes");

	push	OFFSET $SG222477
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	ebp

; 1071 : #endif
; 1072 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 1073 : 	m_iGoldenAgeTileBonusFaith              = kResults.GetInt("GoldenAgeTileBonusFaith");

	push	OFFSET $SG222478
	mov	ecx, edi
	mov	DWORD PTR [esi+344], eax
	call	ebp

; 1074 : #endif
; 1075 : 	m_iCultureFromKills						= kResults.GetInt("CultureFromKills");

	push	OFFSET $SG222479
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	ebp

; 1076 : 	m_iFaithFromKills						= kResults.GetInt("FaithFromKills");

	push	OFFSET $SG222480
	mov	ecx, edi
	mov	DWORD PTR [esi+352], eax
	call	ebp

; 1077 : 	m_iCityCultureBonus						= kResults.GetInt("CityCultureBonus");

	push	OFFSET $SG222481
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	ebp

; 1078 : 	m_iCapitalThemingBonusModifier          = kResults.GetInt("CapitalThemingBonusModifier");

	push	OFFSET $SG222482
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	ebp

; 1079 : 	m_iPolicyCostModifier					= kResults.GetInt("PolicyCostModifier");

	push	OFFSET $SG222483
	mov	ecx, edi
	mov	DWORD PTR [esi+364], eax
	call	ebp

; 1080 : 	m_iCityConnectionTradeRouteChange		= kResults.GetInt("CityConnectionTradeRouteChange");

	push	OFFSET $SG222484
	mov	ecx, edi
	mov	DWORD PTR [esi+368], eax
	call	ebp

; 1081 : 	m_iWonderProductionModifier				= kResults.GetInt("WonderProductionModifier");

	push	OFFSET $SG222485
	mov	ecx, edi
	mov	DWORD PTR [esi+372], eax
	call	ebp

; 1082 : 	m_iPlunderModifier						= kResults.GetInt("PlunderModifier");

	push	OFFSET $SG222486
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	ebp

; 1083 : 	m_iImprovementMaintenanceModifier       = kResults.GetInt("ImprovementMaintenanceModifier");

	push	OFFSET $SG222487
	mov	ecx, edi
	mov	DWORD PTR [esi+380], eax
	call	ebp

; 1084 : 	m_iGoldenAgeDurationModifier			= kResults.GetInt("GoldenAgeDurationModifier");

	push	OFFSET $SG222488
	mov	ecx, edi
	mov	DWORD PTR [esi+384], eax
	call	ebp

; 1085 : 	m_iGoldenAgeMoveChange				    = kResults.GetInt("GoldenAgeMoveChange");

	push	OFFSET $SG222489
	mov	ecx, edi
	mov	DWORD PTR [esi+388], eax
	call	ebp

; 1086 : 	m_iGoldenAgeCombatModifier				= kResults.GetInt("GoldenAgeCombatModifier");

	push	OFFSET $SG222490
	mov	ecx, edi
	mov	DWORD PTR [esi+392], eax
	call	ebp

; 1087 : 	m_iGoldenAgeTourismModifier				= kResults.GetInt("GoldenAgeTourismModifier");

	push	OFFSET $SG222491
	mov	ecx, edi
	mov	DWORD PTR [esi+396], eax
	call	ebp

; 1088 : 	m_iGoldenAgeGreatArtistRateModifier		= kResults.GetInt("GoldenAgeGreatArtistRateModifier");

	push	OFFSET $SG222492
	mov	ecx, edi
	mov	DWORD PTR [esi+400], eax
	call	ebp

; 1089 : 	m_iGoldenAgeGreatMusicianRateModifier	= kResults.GetInt("GoldenAgeGreatMusicianRateModifier");

	push	OFFSET $SG222493
	mov	ecx, edi
	mov	DWORD PTR [esi+404], eax
	call	ebp

; 1090 : 	m_iGoldenAgeGreatWriterRateModifier		= kResults.GetInt("GoldenAgeGreatWriterRateModifier");

	push	OFFSET $SG222494
	mov	ecx, edi
	mov	DWORD PTR [esi+408], eax
	call	ebp

; 1091 : 	m_iExtraEmbarkMoves						= kResults.GetInt("ExtraEmbarkMoves");

	push	OFFSET $SG222495
	mov	ecx, edi
	mov	DWORD PTR [esi+412], eax
	call	ebp
	mov	DWORD PTR [esi+424], eax

; 1092 : 	m_iNaturalWonderFirstFinderGold         = kResults.GetInt("NaturalWonderFirstFinderGold");

	push	OFFSET $SG222496
	mov	ecx, edi
	call	ebp

; 1093 : 	m_iNaturalWonderSubsequentFinderGold    = kResults.GetInt("NaturalWonderSubsequentFinderGold");

	push	OFFSET $SG222497
	mov	ecx, edi
	mov	DWORD PTR [esi+432], eax
	call	ebp

; 1094 : 	m_iNaturalWonderYieldModifier           = kResults.GetInt("NaturalWonderYieldModifier");

	push	OFFSET $SG222498
	mov	ecx, edi
	mov	DWORD PTR [esi+436], eax
	call	ebp

; 1095 : 	m_iNaturalWonderHappinessModifier       = kResults.GetInt("NaturalWonderHappinessModifier");

	push	OFFSET $SG222499
	mov	ecx, edi
	mov	DWORD PTR [esi+440], eax
	call	ebp

; 1096 : 	m_iNearbyImprovementCombatBonus			= kResults.GetInt("NearbyImprovementCombatBonus");

	push	OFFSET $SG222500
	mov	ecx, edi
	mov	DWORD PTR [esi+444], eax
	call	ebp

; 1097 : 	m_iNearbyImprovementBonusRange			= kResults.GetInt("NearbyImprovementBonusRange");

	push	OFFSET $SG222501
	mov	ecx, edi
	mov	DWORD PTR [esi+448], eax
	call	ebp

; 1098 : 	m_iCultureBuildingYieldChange			= kResults.GetInt("CultureBuildingYieldChange");

	push	OFFSET $SG222502
	mov	ecx, edi
	mov	DWORD PTR [esi+452], eax
	call	ebp

; 1099 : 	m_iCombatBonusVsHigherTech				= kResults.GetInt("CombatBonusVsHigherTech");

	push	OFFSET $SG222503
	mov	ecx, edi
	mov	DWORD PTR [esi+456], eax
	call	ebp

; 1100 : 	m_iCombatBonusVsLargerCiv				= kResults.GetInt("CombatBonusVsLargerCiv");

	push	OFFSET $SG222504
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebp

; 1101 : 	m_iLandUnitMaintenanceModifier          = kResults.GetInt("LandUnitMaintenanceModifier");

	push	OFFSET $SG222505
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebp

; 1102 : 	m_iNavalUnitMaintenanceModifier         = kResults.GetInt("NavalUnitMaintenanceModifier");

	push	OFFSET $SG222506
	mov	ecx, edi
	mov	DWORD PTR [esi+468], eax
	call	ebp

; 1103 : 	m_iRazeSpeedModifier					= kResults.GetInt("RazeSpeedModifier");

	push	OFFSET $SG222507
	mov	ecx, edi
	mov	DWORD PTR [esi+472], eax
	call	ebp

; 1104 : 	m_iDOFGreatPersonModifier				= kResults.GetInt("DOFGreatPersonModifier");

	push	OFFSET $SG222508
	mov	ecx, edi
	mov	DWORD PTR [esi+476], eax
	call	ebp

; 1105 : 	m_iLuxuryHappinessRetention				= kResults.GetInt("LuxuryHappinessRetention");

	push	OFFSET $SG222509
	mov	ecx, edi
	mov	DWORD PTR [esi+480], eax
	call	ebp

; 1106 : 	m_iExtraHappinessPerLuxury				= kResults.GetInt("ExtraHappinessPerLuxury"); // NQMP GJS - New Netherlands UA

	push	OFFSET $SG222510
	mov	ecx, edi
	mov	DWORD PTR [esi+484], eax
	call	ebp

; 1107 : 	m_iExtraSpies							= kResults.GetInt("ExtraSpies");

	push	OFFSET $SG222511
	mov	ecx, edi
	mov	DWORD PTR [esi+488], eax
	call	ebp

; 1108 : 	m_iHappinessPerReligion					= kResults.GetInt("HappinessPerReligion"); // NQMP GJS - New Ottoman UA

	push	OFFSET $SG222512
	mov	ecx, edi
	mov	DWORD PTR [esi+492], eax
	call	ebp

; 1109 : 	m_iUnresearchedTechBonusFromKills		= kResults.GetInt("UnresearchedTechBonusFromKills");

	push	OFFSET $SG222513
	mov	ecx, edi
	mov	DWORD PTR [esi+496], eax
	call	ebp

; 1110 : 	m_iExtraFoundedCityTerritoryClaimRange  = kResults.GetInt("ExtraFoundedCityTerritoryClaimRange");

	push	OFFSET $SG222514
	mov	ecx, edi
	mov	DWORD PTR [esi+500], eax
	call	ebp

; 1111 : 	m_iFreeSocialPoliciesPerEra				= kResults.GetInt("FreeSocialPoliciesPerEra");

	push	OFFSET $SG222515
	mov	ecx, edi
	mov	DWORD PTR [esi+504], eax
	call	ebp
	mov	DWORD PTR [esi+508], eax

; 1112 : 	m_iNumTradeRoutesModifier				= kResults.GetInt("NumTradeRoutesModifier");

	push	OFFSET $SG222516
	mov	ecx, edi
	call	ebp

; 1113 : 	m_iTradeRouteResourceModifier			= kResults.GetInt("TradeRouteResourceModifier");

	push	OFFSET $SG222517
	mov	ecx, edi
	mov	DWORD PTR [esi+512], eax
	call	ebp

; 1114 : 	m_iUniqueLuxuryCities					= kResults.GetInt("UniqueLuxuryCities");

	push	OFFSET $SG222518
	mov	ecx, edi
	mov	DWORD PTR [esi+516], eax
	call	ebp

; 1115 : 	m_iUniqueLuxuryQuantity					= kResults.GetInt("UniqueLuxuryQuantity");

	push	OFFSET $SG222519
	mov	ecx, edi
	mov	DWORD PTR [esi+520], eax
	call	ebp

; 1116 : 	m_iWorkerSpeedModifier					= kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET $SG222520
	mov	ecx, edi
	mov	DWORD PTR [esi+524], eax
	call	ebp

; 1117 : 	m_iAfraidMinorPerTurnInfluence			= kResults.GetInt("AfraidMinorPerTurnInfluence");

	push	OFFSET $SG222521
	mov	ecx, edi
	mov	DWORD PTR [esi+528], eax
	call	ebp

; 1118 : 	m_iLandTradeRouteRangeBonus				= kResults.GetInt("LandTradeRouteRangeBonus");

	push	OFFSET $SG222522
	mov	ecx, edi
	mov	DWORD PTR [esi+532], eax
	call	ebp

; 1119 : 	m_iTradeReligionModifier				= kResults.GetInt("TradeReligionModifier");

	push	OFFSET $SG222523
	mov	ecx, edi
	mov	DWORD PTR [esi+536], eax
	call	ebp

; 1120 : 	m_iTradeBuildingModifier				= kResults.GetInt("TradeBuildingModifier");

	push	OFFSET $SG222524
	mov	ecx, edi
	mov	DWORD PTR [esi+540], eax
	call	ebp

; 1121 : 
; 1122 : 	const char* szTextVal = NULL;
; 1123 : 	szTextVal = kResults.GetText("FreeUnit");

	push	OFFSET $SG222526
	mov	ecx, edi
	mov	DWORD PTR [esi+544], eax
	call	ebx

; 1124 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN43@CacheResul

; 1125 : 	{
; 1126 : 		m_iFreeUnitClassType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+428], eax
$LN43@CacheResul:

; 1127 : 	}
; 1128 : 
; 1129 : 	szTextVal = kResults.GetText("FreeUnitPrereqTech");

	push	OFFSET $SG222528
	mov	ecx, edi
	call	ebx

; 1130 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN42@CacheResul

; 1131 : 	{
; 1132 : 		m_eFreeUnitPrereqTech = (TechTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+548], eax
$LN42@CacheResul:

; 1133 : 	}
; 1134 : 
; 1135 : 	//// CMP DLL THING
; 1136 : 
; 1137 : 	szTextVal = kResults.GetText("FreeBuildingPrereqTech");

	push	OFFSET $SG222531
	mov	ecx, edi
	call	ebx

; 1138 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN41@CacheResul

; 1139 : 	{
; 1140 : 		m_eFreeBuildingPrereqTech = (TechTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+564], eax
$LN41@CacheResul:

; 1141 : 	}
; 1142 : 	szTextVal = kResults.GetText("CapitalFreeBuildingPrereqTech");

	push	OFFSET $SG222534
	mov	ecx, edi
	call	ebx

; 1143 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN40@CacheResul

; 1144 : 	{
; 1145 : 		m_eCapitalFreeBuildingPrereqTech = (TechTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+568], eax
$LN40@CacheResul:

; 1146 : 	}
; 1147 : 
; 1148 : 	///
; 1149 : 
; 1150 : 
; 1151 : 	szTextVal = kResults.GetText("CombatBonusImprovement");

	push	OFFSET $SG222537
	mov	ecx, edi
	call	ebx

; 1152 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN39@CacheResul

; 1153 : 	{
; 1154 : 		m_eCombatBonusImprovement = (ImprovementTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+552], eax
$LN39@CacheResul:

; 1155 : 	}
; 1156 : 
; 1157 : 	szTextVal = kResults.GetText("ObsoleteTech");

	push	OFFSET $SG222540
	mov	ecx, edi
	call	ebx

; 1158 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN38@CacheResul

; 1159 : 	{
; 1160 : 		m_iObsoleteTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+416], eax
$LN38@CacheResul:

; 1161 : 	}
; 1162 : 
; 1163 : 	szTextVal = kResults.GetText("PrereqTech");

	push	OFFSET $SG222542
	mov	ecx, edi
	call	ebx

; 1164 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN37@CacheResul

; 1165 : 	{
; 1166 : 		m_iPrereqTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+420], eax
$LN37@CacheResul:

; 1167 : 	}
; 1168 : 
; 1169 : 	szTextVal = kResults.GetText("FreeBuilding");

	push	OFFSET $SG222544
	mov	ecx, edi
	call	ebx

; 1170 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN36@CacheResul

; 1171 : 	{
; 1172 : 		m_eFreeBuilding = (BuildingTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+556], eax
$LN36@CacheResul:

; 1173 : 	}
; 1174 : 
; 1175 : 	szTextVal = kResults.GetText("FreeCapitalBuilding");

	push	OFFSET $SG222547
	mov	ecx, edi
	call	ebx

; 1176 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN35@CacheResul

; 1177 : 	{
; 1178 : 		m_eFreeCapitalBuilding = (BuildingTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+560], eax
$LN35@CacheResul:

; 1179 : 	}
; 1180 : 
; 1181 : 	szTextVal = kResults.GetText("FreeBuildingOnConquest");

	push	OFFSET $SG222550
	mov	ecx, edi
	call	ebx

; 1182 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN34@CacheResul

; 1183 : 	{
; 1184 : 		m_eFreeBuildingOnConquest = (BuildingTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+572], eax
$LN34@CacheResul:

; 1185 : 	}
; 1186 : 
; 1187 : 	m_bFightWellDamaged = kResults.GetBool("FightWellDamaged");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG222553
	mov	ecx, edi
	call	ebx

; 1188 : 	m_bMoveFriendlyWoodsAsRoad = kResults.GetBool("MoveFriendlyWoodsAsRoad");

	push	OFFSET $SG222554
	mov	ecx, edi
	mov	BYTE PTR [esi+576], al
	call	ebx

; 1189 : 	m_bFasterAlongRiver = kResults.GetBool("FasterAlongRiver");

	push	OFFSET $SG222555
	mov	ecx, edi
	mov	BYTE PTR [esi+577], al
	call	ebx

; 1190 : 	m_bFasterInHills = kResults.GetBool("FasterInHills");

	push	OFFSET $SG222556
	mov	ecx, edi
	mov	BYTE PTR [esi+578], al
	call	ebx

; 1191 : 	m_bEmbarkedAllWater = kResults.GetBool("EmbarkedAllWater");

	push	OFFSET $SG222557
	mov	ecx, edi
	mov	BYTE PTR [esi+579], al
	call	ebx

; 1192 : 	m_bEmbarkedToLandFlatCost = kResults.GetBool("EmbarkedToLandFlatCost");

	push	OFFSET $SG222558
	mov	ecx, edi
	mov	BYTE PTR [esi+580], al
	call	ebx

; 1193 : 	m_bNoHillsImprovementMaintenance = kResults.GetBool("NoHillsImprovementMaintenance");

	push	OFFSET $SG222559
	mov	ecx, edi
	mov	BYTE PTR [esi+581], al
	call	ebx

; 1194 : 	m_bTechBoostFromCapitalScienceBuildings = kResults.GetBool("TechBoostFromCapitalScienceBuildings");

	push	OFFSET $SG222560
	mov	ecx, edi
	mov	BYTE PTR [esi+582], al
	call	ebx

; 1195 : 	m_bStaysAliveZeroCities = kResults.GetBool("StaysAliveZeroCities");

	push	OFFSET $SG222561
	mov	ecx, edi
	mov	BYTE PTR [esi+583], al
	call	ebx

; 1196 : 	m_bFaithFromUnimprovedForest = kResults.GetBool("FaithFromUnimprovedForest");

	push	OFFSET $SG222562
	mov	ecx, edi
	mov	BYTE PTR [esi+584], al
	call	ebx

; 1197 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 1198 : 	m_bSeaTradeRoutesArePlunderImmune = kResults.GetBool("SeaTradeRoutesArePlunderImmune");

	push	OFFSET $SG222563
	mov	ecx, edi
	mov	BYTE PTR [esi+585], al
	call	ebx

; 1199 : #endif
; 1200 : 	m_bEarnsGreatPersonOnSlotOrGuild = kResults.GetBool("EarnsGreatPersonOnSlotOrGuild"); // NQMP GJS - New France UA

	push	OFFSET $SG222564
	mov	ecx, edi
	mov	BYTE PTR [esi+586], al
	call	ebx

; 1201 : 	m_bBonusReligiousBelief = kResults.GetBool("BonusReligiousBelief");

	push	OFFSET $SG222565
	mov	ecx, edi
	mov	BYTE PTR [esi+587], al
	call	ebx

; 1202 : 	m_bAbleToAnnexCityStates = kResults.GetBool("AbleToAnnexCityStates");

	push	OFFSET $SG222566
	mov	ecx, edi
	mov	BYTE PTR [esi+591], al
	call	ebx

; 1203 : 	m_bCrossesMountainsAfterGreatGeneral = kResults.GetBool("CrossesMountainsAfterGreatGeneral");

	push	OFFSET $SG222567
	mov	ecx, edi
	mov	BYTE PTR [esi+592], al
	call	ebx

; 1204 : 	m_bMayaCalendarBonuses = kResults.GetBool("MayaCalendarBonuses");

	push	OFFSET $SG222568
	mov	ecx, edi
	mov	BYTE PTR [esi+593], al
	call	ebx

; 1205 : 	m_bNoAnnexing = kResults.GetBool("NoAnnexing");

	push	OFFSET $SG222569
	mov	ecx, edi
	mov	BYTE PTR [esi+594], al
	call	ebx

; 1206 : 	m_bTechFromCityConquer = kResults.GetBool("TechFromCityConquer");

	push	OFFSET $SG222570
	mov	ecx, edi
	mov	BYTE PTR [esi+595], al
	call	ebx

; 1207 : 	m_bUniqueLuxuryRequiresNewArea = kResults.GetBool("UniqueLuxuryRequiresNewArea");

	push	OFFSET $SG222571
	mov	ecx, edi
	mov	BYTE PTR [esi+596], al
	call	ebx

; 1208 : 	m_bRiverTradeRoad = kResults.GetBool("RiverTradeRoad");

	push	OFFSET $SG222572
	mov	ecx, edi
	mov	BYTE PTR [esi+597], al
	call	ebx
	mov	BYTE PTR [esi+598], al

; 1209 : 	m_bAngerFreeIntrusionOfCityStates = kResults.GetBool("AngerFreeIntrusionOfCityStates");

	push	OFFSET $SG222573
	mov	ecx, edi
	call	ebx

; 1210 : 
; 1211 : 	//Arrays
; 1212 : 	const char* szTraitType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR [esi+599], al
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 1213 : 	kUtility.SetYields(m_paiExtraYieldThreshold, "Trait_ExtraYieldThresholds", "TraitType", szTraitType);

	mov	edi, DWORD PTR _kUtility$[esp+108]
	mov	ebx, eax
	push	ebx
	push	OFFSET $SG222575
	push	OFFSET $SG222576
	lea	ecx, DWORD PTR [esi+628]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _szTraitType$[esp+124], ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1214 : 
; 1215 : 	kUtility.SetYields(m_paiYieldChange, "Trait_YieldChanges", "TraitType", szTraitType);

	push	ebx
	push	OFFSET $SG222577
	push	OFFSET $SG222578
	lea	edx, DWORD PTR [esi+632]
	push	edx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1216 : 	kUtility.SetYields(m_paiYieldChangeStrategicResources, "Trait_YieldChangesStrategicResources", "TraitType", szTraitType);

	push	ebx
	push	OFFSET $SG222579
	push	OFFSET $SG222580
	lea	eax, DWORD PTR [esi+636]
	push	eax
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1217 : 	kUtility.SetYields(m_paiYieldChangeLuxuryResources, "Trait_YieldChangesLuxuryResources", "TraitType", szTraitType); // NQMP GJS - New Netherlands UA

	push	ebx
	push	OFFSET $SG222581
	push	OFFSET $SG222582
	lea	ecx, DWORD PTR [esi+640]
	push	ecx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1218 : 	kUtility.SetYields(m_paiYieldChangeNaturalWonder, "Trait_YieldChangesNaturalWonder", "TraitType", szTraitType);

	push	ebx
	push	OFFSET $SG222583
	push	OFFSET $SG222584
	lea	edx, DWORD PTR [esi+644]
	push	edx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1219 : 	kUtility.SetYields(m_paiYieldChangePerTradePartner, "Trait_YieldChangesPerTradePartner", "TraitType", szTraitType);

	push	ebx
	push	OFFSET $SG222585
	push	OFFSET $SG222586
	lea	eax, DWORD PTR [esi+648]
	push	eax
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1220 : 	kUtility.SetYields(m_paiYieldChangeIncomingTradeRoute, "Trait_YieldChangesIncomingTradeRoute", "TraitType", szTraitType);

	push	ebx
	push	OFFSET $SG222587
	push	OFFSET $SG222588
	lea	ecx, DWORD PTR [esi+652]
	push	ecx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1221 : 	kUtility.SetYields(m_paiYieldModifier, "Trait_YieldModifiers", "TraitType", szTraitType);

	push	ebx
	push	OFFSET $SG222589
	push	OFFSET $SG222590
	lea	edx, DWORD PTR [esi+656]
	push	edx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1222 : 
; 1223 : 	const int iNumTerrains = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos

; 1224 : 
; 1225 : 	//Trait_Terrains
; 1226 : 	{
; 1227 : 		kUtility.InitializeArray(m_piStrategicResourceQuantityModifier, iNumTerrains, 0);

	xor	ecx, ecx
	mov	ebx, eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [ebx*4]
	push	ecx
	push	0
	mov	DWORD PTR [esi+660], eax
	push	eax
	call	_memset
	add	esp, 16					; 00000010H

; 1228 : 
; 1229 : 		std::string sqlKey = "Trait_Terrains";

	push	OFFSET $SG222598
	lea	ecx, DWORD PTR _sqlKey$222597[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1230 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$222597[esp+112]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+124], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 1231 : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN317@CacheResul

; 1232 : 		{
; 1233 : 			const char* szSQL = "select TraitType, Terrains.ID as TerrainID, StrategicResourceQuantityModifier from Trait_Terrains join Terrains on Terrains.Type = TerrainType where TraitType = ?";
; 1234 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222602
	lea	eax, DWORD PTR _sqlKey$222597[esp+116]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN317@CacheResul:

; 1235 : 		}
; 1236 : 
; 1237 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1238 : 
; 1239 : 		while(pResults->Step())

	mov	ebx, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, edi
	call	ebx
	test	al, al
	je	SHORT $LN31@CacheResul
$LL32@CacheResul:

; 1240 : 		{
; 1241 : 			const int iTerrainID = pResults->GetInt("TerrainID");

	push	OFFSET $SG222607
	mov	ecx, edi
	call	ebp

; 1242 : 			CvAssert(iTerrainID > -1 && iTerrainID < iNumTerrains);
; 1243 : 
; 1244 : 			const int iStrategicResourceQuantityModifier = pResults->GetInt("StrategicResourceQuantityModifier");

	push	OFFSET $SG222609
	mov	ecx, edi
	mov	DWORD PTR _iTerrainID$222606[esp+116], eax
	call	ebp

; 1245 : 			m_piStrategicResourceQuantityModifier[iTerrainID] = iStrategicResourceQuantityModifier;

	mov	edx, DWORD PTR [esi+660]
	mov	ecx, DWORD PTR _iTerrainID$222606[esp+112]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, edi
	call	ebx
	test	al, al
	jne	SHORT $LL32@CacheResul
$LN31@CacheResul:

; 1246 : 		}
; 1247 : 	}

	lea	ecx, DWORD PTR _sqlKey$222597[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1248 : 
; 1249 : 	//Populate m_FreePromotionUnitCombats
; 1250 : 	{
; 1251 : 		std::string sqlKey = "FreePromotionUnitCombats";

	push	OFFSET $SG222611
	lea	ecx, DWORD PTR _sqlKey$222610[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1252 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	mov	edi, DWORD PTR _kUtility$[esp+108]
	lea	edx, DWORD PTR _sqlKey$222610[esp+112]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 1253 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN30@CacheResul

; 1254 : 		{
; 1255 : 			const char* szSQL = "select UnitPromotions.ID, UnitCombatInfos.ID from Trait_FreePromotionUnitCombats, UnitPromotions, UnitCombatInfos where TraitType = ? and PromotionType = UnitPromotions.Type and UnitCombatType = UnitCombatInfos.Type";
; 1256 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG222615
	lea	eax, DWORD PTR _sqlKey$222610[esp+116]
	push	eax
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN30@CacheResul:

; 1257 : 		}
; 1258 : 
; 1259 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1260 : 
; 1261 : 		while(pResults->Step())

	mov	ecx, ebp
	call	ebx
	mov	edi, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	test	al, al
	je	SHORT $LN28@CacheResul
$LL29@CacheResul:

; 1262 : 		{
; 1263 : 			const int unitPromotionID = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	edi

; 1264 : 			const int unitCombatInfoID = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _unitPromotionID$222619[esp+116], eax
	call	edi

; 1265 : 
; 1266 : 			m_FreePromotionUnitCombats.insert(std::pair<int, int>(unitPromotionID, unitCombatInfoID));

	mov	edx, DWORD PTR _unitPromotionID$222619[esp+112]
	mov	DWORD PTR $T261236[esp+116], eax
	lea	eax, DWORD PTR $T261236[esp+112]
	push	eax
	lea	ecx, DWORD PTR $T261289[esp+116]
	push	ecx
	lea	ecx, DWORD PTR [esi+688]
	mov	DWORD PTR $T261236[esp+120], edx
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
	mov	ecx, ebp
	call	ebx
	test	al, al
	jne	SHORT $LL29@CacheResul
$LN28@CacheResul:

; 1267 : 		}
; 1268 : 
; 1269 : 		pResults->Reset();

	mov	ecx, ebp
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 1270 : 
; 1271 : 		//Trim extra memory off container since this is mostly read-only.
; 1272 : 		std::multimap<int,int>(m_FreePromotionUnitCombats).swap(m_FreePromotionUnitCombats);

	lea	ebp, DWORD PTR [esi+688]
	push	ebp
	lea	ecx, DWORD PTR $T261239[esp+116]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	push	ebp
	lea	ecx, DWORD PTR $T261239[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 2
	call	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
	mov	eax, DWORD PTR $T261239[esp+116]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T261434[esp+120]
	push	edx
	lea	ecx, DWORD PTR $T261239[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	mov	eax, DWORD PTR $T261239[esp+116]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 1273 : 
; 1274 : 		kUtility.PopulateArrayByValue(m_piResourceQuantityModifiers, "Resources", "Trait_ResourceQuantityModifiers", "ResourceType", "TraitType", szTraitType, "ResourceQuantityModifier");

	mov	ecx, DWORD PTR _szTraitType$[esp+112]
	mov	ebp, DWORD PTR _kUtility$[esp+112]
	add	esp, 4
	push	0
	push	0
	push	OFFSET $SG222695
	push	ecx
	push	OFFSET $SG222696
	push	OFFSET $SG222697
	push	OFFSET $SG222698
	push	OFFSET $SG222699
	lea	edx, DWORD PTR [esi+664]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 1275 : 	}

	lea	ecx, DWORD PTR _sqlKey$222610[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1276 : 
; 1277 : 	//Populate m_MovesChangeUnitCombats
; 1278 : 	{
; 1279 : 		const int iNumUnitCombatClasses = kUtility.MaxRows("UnitCombatInfos");

	push	OFFSET $SG222701
	mov	ecx, ebp
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 1280 : 		kUtility.InitializeArray(m_piMovesChangeUnitCombats, iNumUnitCombatClasses, 0);

	xor	ecx, ecx
	mov	ebp, eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [ebp*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+668], eax
	call	_memset
	add	esp, 16					; 00000010H

; 1281 : 
; 1282 : 		std::string sqlKey = "Trait_MovesChangeUnitCombats";

	push	OFFSET $SG222703
	lea	ecx, DWORD PTR _sqlKey$222702[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1283 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	lea	edx, DWORD PTR _sqlKey$222702[esp+112]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+124], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 1284 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN27@CacheResul

; 1285 : 		{
; 1286 : 			const char* szSQL = "select UnitCombatInfos.ID, MovesChange from Trait_MovesChangeUnitCombats inner join UnitCombatInfos on UnitCombatInfos.Type = UnitCombatType where TraitType = ?;";
; 1287 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222707
	lea	eax, DWORD PTR _sqlKey$222702[esp+116]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN27@CacheResul:

; 1288 : 		}
; 1289 : 
; 1290 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1291 : 
; 1292 : 		while(pResults->Step())

	mov	ecx, ebp
	call	ebx
	test	al, al
	je	SHORT $LN25@CacheResul
$LL26@CacheResul:

; 1293 : 		{
; 1294 : 			const int iUnitCombatID = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	edi

; 1295 : 			CvAssert(iUnitCombatID > -1 && iUnitCombatID < iNumUnitCombatClasses);
; 1296 : 
; 1297 : 			const int iMovesChange = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iUnitCombatID$222711[esp+116], eax
	call	edi

; 1298 : 			m_piMovesChangeUnitCombats[iUnitCombatID] = iMovesChange;

	mov	edx, DWORD PTR [esi+668]
	mov	ecx, DWORD PTR _iUnitCombatID$222711[esp+112]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, ebp
	call	ebx
	test	al, al
	jne	SHORT $LL26@CacheResul
$LN25@CacheResul:

; 1299 : 		}
; 1300 : 
; 1301 : 		pResults->Reset();

	mov	ecx, ebp
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 1302 : 	}

	lea	ecx, DWORD PTR _sqlKey$222702[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1303 : 
; 1304 : 	//Populate m_MaintenanceModifierUnitCombats
; 1305 : 	{
; 1306 : 		const int iNumUnitCombatClasses = kUtility.MaxRows("UnitCombatInfos");

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222714
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 1307 : 		kUtility.InitializeArray(m_piMaintenanceModifierUnitCombats, iNumUnitCombatClasses, 0);

	xor	ecx, ecx
	mov	ebp, eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [ebp*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+672], eax
	call	_memset
	add	esp, 16					; 00000010H

; 1308 : 
; 1309 : 		std::string sqlKey = "Trait_MaintenanceModifierUnitCombats";

	push	OFFSET $SG222716
	lea	ecx, DWORD PTR _sqlKey$222715[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1310 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	lea	edx, DWORD PTR _sqlKey$222715[esp+112]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+124], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 1311 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN24@CacheResul

; 1312 : 		{
; 1313 : 			const char* szSQL = "select UnitCombatInfos.ID, MaintenanceModifier from Trait_MaintenanceModifierUnitCombats inner join UnitCombatInfos on UnitCombatInfos.Type = UnitCombatType where TraitType = ?;";
; 1314 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222720
	lea	eax, DWORD PTR _sqlKey$222715[esp+116]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN24@CacheResul:

; 1315 : 		}
; 1316 : 
; 1317 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1318 : 
; 1319 : 		while(pResults->Step())

	mov	ecx, ebp
	call	ebx
	test	al, al
	je	SHORT $LN22@CacheResul
	npad	2
$LL23@CacheResul:

; 1320 : 		{
; 1321 : 			const int iUnitCombatID = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	edi

; 1322 : 			CvAssert(iUnitCombatID > -1 && iUnitCombatID < iNumUnitCombatClasses);
; 1323 : 
; 1324 : 			const int iMaintenanceModifier = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iUnitCombatID$222724[esp+116], eax
	call	edi

; 1325 : 			m_piMaintenanceModifierUnitCombats[iUnitCombatID] = iMaintenanceModifier;

	mov	edx, DWORD PTR [esi+672]
	mov	ecx, DWORD PTR _iUnitCombatID$222724[esp+112]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, ebp
	call	ebx
	test	al, al
	jne	SHORT $LL23@CacheResul
$LN22@CacheResul:

; 1326 : 		}
; 1327 : 
; 1328 : 		pResults->Reset();

	mov	ecx, ebp
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 1329 : 	}

	lea	ecx, DWORD PTR _sqlKey$222715[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1330 : 
; 1331 : 	//ImprovementYieldChanges
; 1332 : 	{
; 1333 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1334 : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges.first, "Improvements", "Yields");
; 1335 : 		m_ppiImprovementYieldChanges.second = kUtility.MaxRows("Improvements");
; 1336 : #else
; 1337 : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges, "Improvements", "Yields");

	mov	ebp, DWORD PTR _kUtility$[esp+108]
	push	0
	push	OFFSET $SG222726
	lea	eax, DWORD PTR [esi+676]
	push	OFFSET $SG222727
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1338 : #endif
; 1339 : 
; 1340 : 		std::string strKey("Trait_ImprovementYieldChanges");

	push	OFFSET $SG222729
	lea	ecx, DWORD PTR _strKey$222728[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1341 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$222728[esp+112]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+124], 5
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 1342 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN21@CacheResul

; 1343 : 		{
; 1344 : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Trait_ImprovementYieldChanges inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where TraitType = ?");

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222732
	lea	eax, DWORD PTR _strKey$222728[esp+116]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN21@CacheResul:

; 1345 : 		}
; 1346 : 
; 1347 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1348 : 
; 1349 : 		while(pResults->Step())

	mov	ecx, ebp
	call	ebx
	test	al, al
	je	SHORT $LN19@CacheResul
$LL20@CacheResul:

; 1350 : 		{
; 1351 : 			const int ImprovementID = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	edi

; 1352 : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _ImprovementID$222736[esp+116], eax
	call	edi

; 1353 : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebp
	mov	DWORD PTR _YieldID$222737[esp+116], eax
	call	edi

; 1354 : 
; 1355 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1356 : 			m_ppiImprovementYieldChanges.first[ImprovementID][YieldID] = yield;
; 1357 : #else
; 1358 : 			m_ppiImprovementYieldChanges[ImprovementID][YieldID] = yield;

	mov	edx, DWORD PTR [esi+676]
	mov	ecx, DWORD PTR _ImprovementID$222736[esp+112]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _YieldID$222737[esp+112]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, ebp
	call	ebx
	test	al, al
	jne	SHORT $LL20@CacheResul
$LN19@CacheResul:

; 1359 : #endif
; 1360 : 		}
; 1361 : 	}

	lea	ecx, DWORD PTR _strKey$222728[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1362 : 
; 1363 : 	//SpecialistYieldChanges
; 1364 : 	{
; 1365 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1366 : 		kUtility.Initialize2DArray(m_ppiSpecialistYieldChanges.first, "Specialists", "Yields");
; 1367 : 		m_ppiSpecialistYieldChanges.second = kUtility.MaxRows("Specialists");
; 1368 : #else
; 1369 : 		kUtility.Initialize2DArray(m_ppiSpecialistYieldChanges, "Specialists", "Yields");

	mov	ebp, DWORD PTR _kUtility$[esp+108]
	push	0
	push	OFFSET $SG222739
	lea	eax, DWORD PTR [esi+680]
	push	OFFSET $SG222740
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1370 : #endif
; 1371 : 
; 1372 : 		std::string strKey("Building_SpecialistYieldChanges");

	push	OFFSET $SG222742
	lea	ecx, DWORD PTR _strKey$222741[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1373 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$222741[esp+112]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+124], 6
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 1374 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN18@CacheResul

; 1375 : 		{
; 1376 : 			pResults = kUtility.PrepareResults(strKey, "select Specialists.ID as SpecialistID, Yields.ID as YieldID, Yield from Trait_SpecialistYieldChanges inner join Specialists on Specialists.Type = SpecialistType inner join Yields on Yields.Type = YieldType where TraitType = ?");

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222745
	lea	eax, DWORD PTR _strKey$222741[esp+116]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN18@CacheResul:

; 1377 : 		}
; 1378 : 
; 1379 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1380 : 
; 1381 : 		while(pResults->Step())

	mov	ecx, ebp
	call	ebx
	test	al, al
	je	SHORT $LN16@CacheResul
$LL17@CacheResul:

; 1382 : 		{
; 1383 : 			const int SpecialistID = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	edi

; 1384 : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _SpecialistID$222749[esp+116], eax
	call	edi

; 1385 : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebp
	mov	DWORD PTR _YieldID$222750[esp+116], eax
	call	edi

; 1386 : 
; 1387 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1388 : 			m_ppiSpecialistYieldChanges.first[SpecialistID][YieldID] = yield;
; 1389 : #else
; 1390 : 			m_ppiSpecialistYieldChanges[SpecialistID][YieldID] = yield;

	mov	edx, DWORD PTR [esi+680]
	mov	ecx, DWORD PTR _SpecialistID$222749[esp+112]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _YieldID$222750[esp+112]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, ebp
	call	ebx
	test	al, al
	jne	SHORT $LL17@CacheResul
$LN16@CacheResul:

; 1391 : #endif
; 1392 : 		}
; 1393 : 	}

	lea	ecx, DWORD PTR _strKey$222741[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1394 : 
; 1395 : 	//UnimprovedFeatureYieldChanges
; 1396 : 	{
; 1397 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1398 : 		kUtility.Initialize2DArray(m_ppiUnimprovedFeatureYieldChanges.first, "Features", "Yields");
; 1399 : 		m_ppiUnimprovedFeatureYieldChanges.second = kUtility.MaxRows("Features");
; 1400 : #else
; 1401 : 		kUtility.Initialize2DArray(m_ppiUnimprovedFeatureYieldChanges, "Features", "Yields");

	mov	ebp, DWORD PTR _kUtility$[esp+108]
	push	0
	push	OFFSET $SG222752
	lea	eax, DWORD PTR [esi+684]
	push	OFFSET $SG222753
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1402 : #endif
; 1403 : 
; 1404 : 		std::string strKey("Trait_UnimprovedFeatureYieldChanges");

	push	OFFSET $SG222755
	lea	ecx, DWORD PTR _strKey$222754[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1405 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$222754[esp+112]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+124], 7
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 1406 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN15@CacheResul

; 1407 : 		{
; 1408 : 			pResults = kUtility.PrepareResults(strKey, "select Features.ID as FeatureID, Yields.ID as YieldID, Yield from Trait_UnimprovedFeatureYieldChanges inner join Features on Features.Type = FeatureType inner join Yields on Yields.Type = YieldType where TraitType = ?");

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222758
	lea	eax, DWORD PTR _strKey$222754[esp+116]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN15@CacheResul:

; 1409 : 		}
; 1410 : 
; 1411 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1412 : 
; 1413 : 		while(pResults->Step())

	mov	ecx, ebp
	call	ebx
	test	al, al
	je	SHORT $LN13@CacheResul
	npad	2
$LL14@CacheResul:

; 1414 : 		{
; 1415 : 			const int FeatureID = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	edi

; 1416 : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _FeatureID$222762[esp+116], eax
	call	edi

; 1417 : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebp
	mov	DWORD PTR _YieldID$222763[esp+116], eax
	call	edi

; 1418 : 
; 1419 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1420 : 			m_ppiUnimprovedFeatureYieldChanges.first[FeatureID][YieldID] = yield;
; 1421 : #else
; 1422 : 			m_ppiUnimprovedFeatureYieldChanges[FeatureID][YieldID] = yield;

	mov	edx, DWORD PTR [esi+684]
	mov	ecx, DWORD PTR _FeatureID$222762[esp+112]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _YieldID$222763[esp+112]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, ebp
	call	ebx
	test	al, al
	jne	SHORT $LL14@CacheResul
$LN13@CacheResul:

; 1423 : #endif
; 1424 : 		}
; 1425 : 	}

	lea	ecx, DWORD PTR _strKey$222754[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1426 : 
; 1427 : 	// NoTrain
; 1428 : 	{
; 1429 : #ifdef AUI_WARNING_FIXES
; 1430 : 		for (uint iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)
; 1431 : #else
; 1432 : 		int iUnitClassLoop;
; 1433 : 		for (iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iUnitClassLoop$222765[esp+112], 0
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	test	eax, eax
	jle	SHORT $LN318@CacheResul
	lea	ebp, DWORD PTR [esi+716]
$LL12@CacheResul:

; 1434 : #endif
; 1435 : 		{
; 1436 : 			m_abNoTrainUnitClass.push_back(false);

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ebp+8]
	xor	edx, edx
	test	eax, eax
	jbe	SHORT $LN147@CacheResul
	jge	SHORT $LN148@CacheResul
	mov	edx, eax
	neg	edx
	je	SHORT $LN148@CacheResul
	or	edx, -1
	sub	edx, eax
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ebp, -4					; fffffffcH
	sub	ebp, edx
	add	ecx, ebp
	jmp	SHORT $LN321@CacheResul
$LN148@CacheResul:
	mov	edx, eax
	shr	edx, 5
	lea	ecx, DWORD PTR [ecx+edx*4]
$LN321@CacheResul:
	and	eax, 31					; 0000001fH
	mov	edx, eax
$LN147@CacheResul:
	push	0
	push	1
	push	edx
	push	ecx
	lea	ebp, DWORD PTR [esi+716]
	mov	ecx, ebp
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	inc	DWORD PTR _iUnitClassLoop$222765[esp+112]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iUnitClassLoop$222765[esp+112], eax
	jl	SHORT $LL12@CacheResul
$LN318@CacheResul:

; 1437 : 		}
; 1438 : 
; 1439 : 		std::string strKey("Trait_NoTrain");

	push	OFFSET $SG222770
	lea	ecx, DWORD PTR _strKey$222769[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1440 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	lea	eax, DWORD PTR _strKey$222769[esp+112]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+124], 8
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax
	mov	DWORD PTR _pResults$222771[esp+112], ebp

; 1441 : 		if (pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN9@CacheResul

; 1442 : 		{
; 1443 : 			pResults = kUtility.PrepareResults(strKey, "SELECT Traits.ID, UnitClasses.ID FROM Trait_NoTrain inner join Traits on Trait_NoTrain.TraitType = Traits.Type inner join UnitClasses on Trait_NoTrain.UnitClassType = UnitClasses.Type where TraitType = ?");

	push	OFFSET $SG222773
	lea	ecx, DWORD PTR _strKey$222769[esp+116]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+116]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
	mov	DWORD PTR _pResults$222771[esp+112], eax
$LN9@CacheResul:

; 1444 : 		}
; 1445 : 
; 1446 : 		pResults->Bind(1, szTraitType);

	mov	edx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	edx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1447 : 
; 1448 : 		while (pResults->Step())

	mov	ecx, ebp
	call	ebx
	test	al, al
	je	SHORT $LN7@CacheResul
$LL8@CacheResul:

; 1449 : 		{
; 1450 : 			const int iUnitClass = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	call	edi

; 1451 : 			m_abNoTrainUnitClass[iUnitClass] = true;

	mov	edx, DWORD PTR [esi+724]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN217@CacheResul
	jge	SHORT $LN218@CacheResul
	mov	ecx, eax
	neg	ecx
	je	SHORT $LN218@CacheResul
	or	ecx, -1
	sub	ecx, eax
	shr	ecx, 5
	add	ecx, ecx
	add	ecx, ecx
	mov	ebp, -4					; fffffffcH
	sub	ebp, ecx
	add	edx, ebp
	mov	ebp, DWORD PTR _pResults$222771[esp+112]
	jmp	SHORT $LN322@CacheResul
$LN218@CacheResul:
	mov	ecx, eax
	shr	ecx, 5
	lea	edx, DWORD PTR [edx+ecx*4]
$LN322@CacheResul:
	and	eax, 31					; 0000001fH
	mov	ecx, eax
$LN217@CacheResul:
	mov	eax, 1
	shl	eax, cl
	mov	ecx, ebp
	or	DWORD PTR [edx], eax
	call	ebx
	test	al, al
	jne	SHORT $LL8@CacheResul
$LN7@CacheResul:

; 1452 : 		}
; 1453 : 	}

	lea	ecx, DWORD PTR _strKey$222769[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1454 : 
; 1455 : 	// FreeResourceXCities
; 1456 : 	{
; 1457 : 		// Init vector
; 1458 : #ifdef AUI_WARNING_FIXES
; 1459 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 1460 : #else
; 1461 : 		int iResourceLoop;
; 1462 : 		for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iResourceLoop$222779[esp+112], 0
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	$LN4@CacheResul

; 1463 : #endif
; 1464 : 		{
; 1465 : 			FreeResourceXCities temp;

	xor	eax, eax
	mov	DWORD PTR _temp$222783[esp+112], eax
	mov	DWORD PTR _temp$222783[esp+116], eax
	lea	ebp, DWORD PTR [esi+700]
$LL319@CacheResul:

; 1466 : 			m_aFreeResourceXCities.push_back(temp);

	mov	ecx, DWORD PTR [ebp+4]
	test	ecx, ecx
	jne	SHORT $LN252@CacheResul
	xor	eax, eax
	jmp	SHORT $LN253@CacheResul
$LN252@CacheResul:
	mov	eax, DWORD PTR [ebp+12]
	sub	eax, ecx
	sar	eax, 3
$LN253@CacheResul:
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR tv2341[esp+112], edx
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	lea	eax, DWORD PTR _temp$222783[esp+112]
	jae	SHORT $LN245@CacheResul
	mov	edx, DWORD PTR __Cat$262207[esp+108]
	mov	BYTE PTR $T262204[esp+112], 0
	mov	ecx, DWORD PTR $T262204[esp+112]
	push	ecx
	mov	ecx, DWORD PTR tv2341[esp+116]
	push	edx
	push	ebp
	push	eax
	push	1
	push	ecx
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
	mov	edx, DWORD PTR tv2341[esp+136]
	add	esp, 24					; 00000018H
	add	edx, 8
	mov	DWORD PTR [ebp+8], edx
	jmp	SHORT $LN5@CacheResul
$LN245@CacheResul:
	mov	ecx, DWORD PTR tv2341[esp+112]
	push	eax
	push	1
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n
$LN5@CacheResul:
	inc	DWORD PTR _iResourceLoop$222779[esp+112]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222779[esp+112], eax
	jl	SHORT $LL319@CacheResul
$LN4@CacheResul:

; 1467 : 		}
; 1468 : 
; 1469 : 		std::string strKey("Trait_FreeResourceFirstXCities");

	push	OFFSET $SG222785
	lea	ecx, DWORD PTR _strKey$222784[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1470 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	lea	edx, DWORD PTR _strKey$222784[esp+112]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+124], 9
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 1471 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN3@CacheResul

; 1472 : 		{
; 1473 : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, ResourceQuantity, NumCities from Trait_FreeResourceFirstXCities inner join Resources on Resources.Type = ResourceType where TraitType = ?");

	mov	ecx, DWORD PTR _kUtility$[esp+108]
	push	OFFSET $SG222788
	lea	eax, DWORD PTR _strKey$222784[esp+116]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN3@CacheResul:

; 1474 : 		}
; 1475 : 
; 1476 : 		pResults->Bind(1, szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[esp+108]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1477 : 
; 1478 : 		while(pResults->Step())

	mov	ecx, ebp
	call	ebx
	test	al, al
	je	SHORT $LN1@CacheResul
$LL2@CacheResul:

; 1479 : 		{
; 1480 : 			FreeResourceXCities temp;
; 1481 : 
; 1482 : 			const int iResource = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	edi

; 1483 : 			temp.m_iResourceQuantity = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iResource$222793[esp+112], eax
	call	edi

; 1484 : 			temp.m_iNumCities = pResults->GetInt(2);

	push	2
	mov	ecx, ebp
	mov	DWORD PTR _temp$222792[esp+120], eax
	call	edi

; 1485 : 
; 1486 : 			m_aFreeResourceXCities[iResource] = temp;

	mov	ecx, DWORD PTR [esi+704]
	mov	edx, DWORD PTR _iResource$222793[esp+108]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR _temp$222792[esp+116]
	mov	DWORD PTR [ecx+edx*8+4], eax
	mov	ecx, ebp
	call	ebx
	test	al, al
	jne	SHORT $LL2@CacheResul
$LN1@CacheResul:

; 1487 : 		}
; 1488 : 	}

	lea	ecx, DWORD PTR _strKey$222784[esp+112]
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1489 : 
; 1490 : 	return true;
; 1491 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _sqlKey$222597[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _sqlKey$222610[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR $T261239[ebp]
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _sqlKey$222702[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _sqlKey$222715[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _strKey$222728[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _strKey$222741[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7:
	lea	ecx, DWORD PTR _strKey$222754[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8:
	lea	ecx, DWORD PTR _strKey$222769[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9:
	lea	ecx, DWORD PTR _strKey$222784[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvTraitEntry::CacheResults
PUBLIC	?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z ; CvPlayerTraits::Init
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$0
__ehfuncinfo$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T262266 = -32						; size = 20
__$EHRec$ = -12						; size = 12
$T262757 = 8						; size = 4
_pTraits$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z PROC ; CvPlayerTraits::Init, COMDAT
; _this$ = ecx

; 1553 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 1554 : 	// Store off the pointers to objects we'll need later
; 1555 : 	m_pTraits = pTraits;

	mov	eax, DWORD PTR _pTraits$[esp+8]
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 1556 : 	m_pPlayer = pPlayer;

	mov	ecx, DWORD PTR _pPlayer$[esp+36]
	mov	DWORD PTR [esi+4], ecx
	push	edi

; 1557 : 
; 1558 : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR [esi], eax
	call	?Reset@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Reset

; 1559 : 
; 1560 : 	// Initialize items that can't be reset everytime we earn a new tech (which resets all the other
; 1561 : 	// trait data that can rebuilt from the trait entries)
; 1562 : 	m_iBaktunPreviousTurn = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+712], ebx

; 1563 : 	m_aMayaBonusChoices.clear();

	mov	edx, DWORD PTR [esi+744]
	mov	ecx, DWORD PTR [esi+740]
	cmp	ecx, edx
	je	SHORT $LN18@Init
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN43@Init
	npad	1
$LL45@Init:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL45@Init
$LN43@Init:
	mov	DWORD PTR [esi+744], ecx
$LN18@Init:

; 1564 : 	m_iBaktun = 0;

	mov	DWORD PTR [esi+716], ebx

; 1565 : 	m_iKatun = 0;

	mov	DWORD PTR [esi+720], ebx

; 1566 : 	m_iTun = 0;

	mov	DWORD PTR [esi+724], ebx

; 1567 : 	m_iWinal = 0;

	mov	DWORD PTR [esi+728], ebx

; 1568 : 	m_iKin = 0;

	mov	DWORD PTR [esi+732], ebx

; 1569 : 
; 1570 : 	m_aUniqueLuxuryAreas.clear();

	mov	ecx, DWORD PTR [esi+704]
	mov	edi, DWORD PTR [esi+700]
	cmp	edi, ecx
	je	SHORT $LN62@Init
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, ebx
	lea	edx, DWORD PTR [eax*4]
	push	ebp
	lea	ebp, DWORD PTR [edx+edi]
	jle	SHORT $LN87@Init
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN87@Init:
	mov	DWORD PTR [esi+704], ebp
	pop	ebp
$LN62@Init:

; 1571 : 	m_iUniqueLuxuryCitiesPlaced = 0;
; 1572 : 
; 1573 : 	m_vLeaderHasTrait = std::vector<bool>( GC.getNumTraitInfos(), false );

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+300], ebx
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	mov	edi, eax
	lea	edx, DWORD PTR $T262757[esp+40]
	lea	eax, DWORD PTR [edi+31]
	push	edx
	shr	eax, 5
	push	eax
	lea	ecx, DWORD PTR $T262266[esp+56]
	mov	DWORD PTR $T262266[esp+52], ebx
	mov	DWORD PTR $T262757[esp+48], ebx
	call	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
	push	edi
	lea	ecx, DWORD PTR $T262266[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], ebx
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
	mov	ecx, DWORD PTR $T262266[esp+44]
	lea	edx, DWORD PTR $T262266[esp+48]
	mov	DWORD PTR [esi+8], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+56], 1
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	mov	eax, DWORD PTR $T262266[esp+52]
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN122@Init
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN122@Init:

; 1574 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$1:
	lea	ecx, DWORD PTR $T262266[ebp+4]
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR $T262266[ebp]
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z ENDP ; CvPlayerTraits::Init
PUBLIC	?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z	; CvPlayerTraits::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
$T264889 = -36						; size = 1
_uiVersion$ = -32					; size = 4
_iNumEntries$ = -28					; size = 4
$T264014 = -24						; size = 1
__Tmp$263324 = -24					; size = 8
_i$223834 = -24						; size = 4
_choice$ = -16						; size = 8
__Tmp$265157 = -8					; size = 8
$T264449 = -8						; size = 8
_trait$223843 = -8					; size = 8
__Cat$264017 = 8					; size = 1
$T265577 = 8						; size = 4
$T265568 = 8						; size = 4
_iAreaID$223867 = 8					; size = 4
_bValue$223838 = 8					; size = 1
_iI$223751 = 8						; size = 4
$T262838 = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTraits::Read, COMDAT
; _this$ = ecx

; 2960 : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2961 : 	int iNumEntries;
; 2962 : 
; 2963 : 	// Version number to maintain backwards compatibility
; 2964 : 	uint uiVersion;
; 2965 : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+48]
	lea	eax, DWORD PTR _uiVersion$[esp+52]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2966 : 
; 2967 : 	// precompute the traits our leader has
; 2968 : 	m_vPotentiallyActiveLeaderTraits.clear();

	mov	eax, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [esi+32]
	lea	ebx, DWORD PTR [esi+28]
	cmp	edx, eax
	je	SHORT $LN89@Read
	mov	ecx, eax
	cmp	eax, eax
	je	SHORT $LN114@Read
	npad	4
$LL116@Read:
	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebp
	add	ecx, 4
	add	edx, 4
	cmp	ecx, eax
	jne	SHORT $LL116@Read
$LN114@Read:
	mov	DWORD PTR [ebx+8], edx
$LN89@Read:

; 2969 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	test	eax, eax
	jle	$LN68@Read
$LL1068@Read:

; 2970 : 	{
; 2971 : 		m_vLeaderHasTrait[iI] = false;

	mov	eax, DWORD PTR [esi+16]
	xor	ecx, ecx
	test	ebp, ebp
	je	SHORT $LN139@Read
	jge	SHORT $LN140@Read
	mov	ecx, ebp
	neg	ecx
	je	SHORT $LN140@Read
	or	edx, -1
	sub	edx, ebp
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ecx, -4					; fffffffcH
	sub	ecx, edx
	add	eax, ecx
	jmp	SHORT $LN1069@Read
$LN140@Read:
	mov	edx, ebp
	shr	edx, 5
	lea	eax, DWORD PTR [eax+edx*4]
$LN1069@Read:
	mov	ecx, ebp
	and	ecx, 31					; 0000001fH
$LN139@Read:
	mov	edx, 1
	shl	edx, cl
	not	edx
	and	DWORD PTR [eax], edx

; 2972 : 		if (m_pPlayer && m_pPlayer->isMajorCiv() && m_pPlayer->isAlive() && m_pPlayer->getLeaderInfo().hasTrait( (TraitTypes)iI ))

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN69@Read
	call	?isMajorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMajorCiv
	test	al, al
	je	SHORT $LN69@Read
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN69@Read
	push	ebp
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	ecx, eax
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	test	al, al
	je	SHORT $LN69@Read

; 2973 : 		{
; 2974 : 			m_vLeaderHasTrait[iI] = true;

	mov	eax, DWORD PTR [esi+16]
	xor	ecx, ecx
	mov	DWORD PTR __Tmp$263324[esp+56], ecx
	push	ebp
	lea	ecx, DWORD PTR __Tmp$263324[esp+56]
	mov	DWORD PTR __Tmp$263324[esp+56], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$263324[esp+56]
	mov	eax, DWORD PTR __Tmp$263324[esp+52]
	mov	edx, 1
	shl	edx, cl

; 2975 : 			m_vPotentiallyActiveLeaderTraits.push_back( (TraitTypes)iI );

	mov	ecx, ebx
	mov	DWORD PTR $T262838[esp+48], ebp
	or	DWORD PTR [eax], edx
	lea	eax, DWORD PTR $T262838[esp+48]
	push	eax
	call	?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
$LN69@Read:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	ebp, eax
	jl	$LL1068@Read
$LN68@Read:

; 2976 : 		}
; 2977 : 	}
; 2978 : 
; 2979 : 	kStream >> m_iGreatPeopleRateModifier;

	lea	ecx, DWORD PTR [esi+44]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2980 : 	kStream >> m_iGreatScientistRateModifier;

	lea	edx, DWORD PTR [esi+48]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2981 : 	kStream >> m_iGreatGeneralRateModifier;

	lea	eax, DWORD PTR [esi+52]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2982 : 	kStream >> m_iGreatGeneralExtraBonus;

	lea	ecx, DWORD PTR [esi+56]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2983 : 
; 2984 : 	kStream >> m_iGreatPersonGiftInfluence;

	lea	edx, DWORD PTR [esi+60]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2985 : 
; 2986 : 	kStream >> m_iLevelExperienceModifier;

	lea	eax, DWORD PTR [esi+64]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2987 : 	kStream >> m_iMaxGlobalBuildingProductionModifier;

	lea	ecx, DWORD PTR [esi+68]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2988 : 	kStream >> m_iMaxTeamBuildingProductionModifier;

	lea	edx, DWORD PTR [esi+72]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2989 : 	kStream >> m_iMaxPlayerBuildingProductionModifier;

	lea	eax, DWORD PTR [esi+76]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2990 : 	kStream >> m_iCityUnhappinessModifier;

	lea	ecx, DWORD PTR [esi+80]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2991 : 	kStream >> m_iPopulationUnhappinessModifier;

	lea	edx, DWORD PTR [esi+84]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2992 : 	kStream >> m_iCityStateBonusModifier;

	lea	eax, DWORD PTR [esi+88]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2993 : 	kStream >> m_iCityStateFriendshipModifier;

	lea	ecx, DWORD PTR [esi+92]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2994 : 	kStream >> m_iCityStateCombatModifier;

	lea	edx, DWORD PTR [esi+96]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2995 : 	kStream >> m_iLandBarbarianConversionPercent;

	lea	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2996 : 	kStream >> m_iLandBarbarianConversionExtraUnits;

	lea	ecx, DWORD PTR [esi+104]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2997 : 	kStream >> m_iSeaBarbarianConversionPercent;

	lea	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2998 : 	kStream >> m_iCapitalBuildingModifier;

	lea	eax, DWORD PTR [esi+112]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2999 : 	kStream >> m_iPlotBuyCostModifier;

	lea	ecx, DWORD PTR [esi+116]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3000 : 	kStream >> m_iPlotCultureCostModifier;

	lea	edx, DWORD PTR [esi+120]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3001 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 3002 : 	kStream >> m_iSciencePerGreatPersonBorn;

	lea	eax, DWORD PTR [esi+124]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3003 : #endif
; 3004 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 3005 : 	kStream >> m_iNumTurnsBeforeMinorAlliesRefuseBribes;

	lea	ecx, DWORD PTR [esi+128]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3006 : #endif
; 3007 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 3008 : 	kStream >> m_iGoldenAgeTileBonusFaith;

	lea	edx, DWORD PTR [esi+132]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3009 : #endif
; 3010 : 	kStream >> m_iCultureFromKills;

	lea	eax, DWORD PTR [esi+136]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3011 : 	if (uiVersion >= 19)

	cmp	DWORD PTR _uiVersion$[esp+52], 19	; 00000013H
	jb	SHORT $LN66@Read

; 3012 : 	{
; 3013 : 		kStream >> m_iFaithFromKills;

	lea	ecx, DWORD PTR [esi+140]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3014 : 	}
; 3015 : 	else

	xor	ebx, ebx
	jmp	SHORT $LN65@Read
$LN66@Read:

; 3016 : 	{
; 3017 : 		m_iFaithFromKills = 0;

	xor	ebx, ebx
	mov	DWORD PTR [esi+140], ebx
$LN65@Read:

; 3018 : 	}
; 3019 : 	kStream >> m_iCityCultureBonus;

	lea	edx, DWORD PTR [esi+144]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3020 : 
; 3021 : 	if (uiVersion >= 17)

	cmp	DWORD PTR _uiVersion$[esp+52], 17	; 00000011H
	jb	SHORT $LN64@Read

; 3022 : 	{
; 3023 : 		kStream >> m_iCapitalThemingBonusModifier;

	lea	eax, DWORD PTR [esi+148]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3024 : 	}
; 3025 : 	else

	jmp	SHORT $LN63@Read
$LN64@Read:

; 3026 : 	{
; 3027 : 		m_iCapitalThemingBonusModifier = 0;

	mov	DWORD PTR [esi+148], ebx
$LN63@Read:

; 3028 : 	}
; 3029 : 
; 3030 : 	kStream >> m_iPolicyCostModifier;

	lea	ecx, DWORD PTR [esi+152]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3031 : 	kStream >> m_iCityConnectionTradeRouteChange;

	lea	edx, DWORD PTR [esi+156]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3032 : 	kStream >> m_iWonderProductionModifier;

	lea	eax, DWORD PTR [esi+160]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3033 : 	kStream >> m_iPlunderModifier;

	lea	ecx, DWORD PTR [esi+164]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3034 : 
; 3035 : 	kStream >> m_iImprovementMaintenanceModifier;

	lea	edx, DWORD PTR [esi+168]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3036 : 
; 3037 : 	kStream >> m_iGoldenAgeDurationModifier;

	lea	eax, DWORD PTR [esi+172]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3038 : 	kStream >> m_iGoldenAgeMoveChange;

	lea	ecx, DWORD PTR [esi+176]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3039 : 	kStream >> m_iGoldenAgeCombatModifier;

	lea	edx, DWORD PTR [esi+180]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3040 : 
; 3041 : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+52], 2
	jb	SHORT $LN62@Read

; 3042 : 	{
; 3043 : 		kStream >> m_iGoldenAgeTourismModifier;

	lea	eax, DWORD PTR [esi+184]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3044 : 		kStream >> m_iGoldenAgeGreatArtistRateModifier;

	lea	ecx, DWORD PTR [esi+188]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3045 : 		kStream >> m_iGoldenAgeGreatMusicianRateModifier;

	lea	edx, DWORD PTR [esi+192]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3046 : 		kStream >> m_iGoldenAgeGreatWriterRateModifier;

	lea	eax, DWORD PTR [esi+196]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3047 : 	}
; 3048 : 	else

	jmp	SHORT $LN61@Read
$LN62@Read:

; 3049 : 	{
; 3050 : 		m_iGoldenAgeTourismModifier = 0;

	mov	DWORD PTR [esi+184], ebx

; 3051 : 		m_iGoldenAgeGreatArtistRateModifier = 0;

	mov	DWORD PTR [esi+188], ebx

; 3052 : 		m_iGoldenAgeGreatMusicianRateModifier = 0;

	mov	DWORD PTR [esi+192], ebx

; 3053 : 		m_iGoldenAgeGreatWriterRateModifier = 0;

	mov	DWORD PTR [esi+196], ebx
$LN61@Read:

; 3054 : 	}
; 3055 : 
; 3056 : 	kStream >> m_iExtraEmbarkMoves;

	lea	ecx, DWORD PTR [esi+200]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3057 : 
; 3058 : 	kStream >> m_iNaturalWonderFirstFinderGold;

	lea	edx, DWORD PTR [esi+204]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3059 : 
; 3060 : 	kStream >> m_iNaturalWonderSubsequentFinderGold;

	lea	eax, DWORD PTR [esi+208]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3061 : 
; 3062 : 	kStream >> m_iNaturalWonderYieldModifier;

	lea	ecx, DWORD PTR [esi+212]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3063 : 	kStream >> m_iNaturalWonderHappinessModifier;

	lea	edx, DWORD PTR [esi+216]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3064 : 
; 3065 : 	kStream >> m_iNearbyImprovementCombatBonus;

	lea	eax, DWORD PTR [esi+220]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3066 : 	kStream >> m_iNearbyImprovementBonusRange;

	lea	ecx, DWORD PTR [esi+224]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3067 : 
; 3068 : 	kStream >> m_iCultureBuildingYieldChange;

	lea	edx, DWORD PTR [esi+228]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3069 : 
; 3070 : 	kStream >> m_iCombatBonusVsHigherTech;

	lea	eax, DWORD PTR [esi+232]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3071 : 
; 3072 : 	kStream >> m_iCombatBonusVsLargerCiv;

	lea	ecx, DWORD PTR [esi+236]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3073 : 
; 3074 : 	kStream >> m_iLandUnitMaintenanceModifier;

	lea	edx, DWORD PTR [esi+240]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3075 : 
; 3076 : 	kStream >> m_iNavalUnitMaintenanceModifier;

	lea	eax, DWORD PTR [esi+244]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3077 : 
; 3078 : 	kStream >> m_iRazeSpeedModifier;

	lea	ecx, DWORD PTR [esi+248]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3079 : 
; 3080 : 	kStream >> m_iDOFGreatPersonModifier;

	lea	edx, DWORD PTR [esi+252]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3081 : 
; 3082 : 	kStream >> m_iLuxuryHappinessRetention;

	lea	eax, DWORD PTR [esi+256]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3083 : 
; 3084 : 	kStream >> m_iExtraHappinessPerLuxury; // NQMP GJS - New Netherlands UA

	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3085 : 
; 3086 : 	kStream >> m_iExtraSpies;

	lea	edx, DWORD PTR [esi+264]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3087 : 
; 3088 : 	kStream >> m_iHappinessPerReligion; // NQMP GJS - New Ottoman UA

	lea	eax, DWORD PTR [esi+268]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3089 : 
; 3090 : 	kStream >> m_iUnresearchedTechBonusFromKills;

	lea	ecx, DWORD PTR [esi+272]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3091 : 
; 3092 : 	if (uiVersion >= 4)

	cmp	DWORD PTR _uiVersion$[esp+52], 4
	jb	SHORT $LN60@Read

; 3093 : 	{
; 3094 : 		kStream >> m_iExtraFoundedCityTerritoryClaimRange;

	lea	edx, DWORD PTR [esi+276]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3095 : 	}
; 3096 : 	else

	jmp	SHORT $LN59@Read
$LN60@Read:

; 3097 : 	{
; 3098 : 		m_iExtraFoundedCityTerritoryClaimRange = 0;

	mov	DWORD PTR [esi+276], ebx
$LN59@Read:

; 3099 : 	}
; 3100 : 
; 3101 : 	if (uiVersion >= 5)

	cmp	DWORD PTR _uiVersion$[esp+52], 5
	jb	SHORT $LN58@Read

; 3102 : 	{
; 3103 : 		kStream >> m_iFreeSocialPoliciesPerEra;

	lea	eax, DWORD PTR [esi+280]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3104 : 	}
; 3105 : 	else

	jmp	SHORT $LN57@Read
$LN58@Read:

; 3106 : 	{
; 3107 : 		m_iFreeSocialPoliciesPerEra = 0;

	mov	DWORD PTR [esi+280], ebx
$LN57@Read:

; 3108 : 	}
; 3109 : 
; 3110 : 	if (uiVersion >= 6)

	cmp	DWORD PTR _uiVersion$[esp+52], 6
	jb	SHORT $LN56@Read

; 3111 : 	{
; 3112 : 		kStream >> m_iNumTradeRoutesModifier;

	lea	ecx, DWORD PTR [esi+284]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3113 : 	}
; 3114 : 	else

	jmp	SHORT $LN55@Read
$LN56@Read:

; 3115 : 	{
; 3116 : 		m_iNumTradeRoutesModifier = 0;

	mov	DWORD PTR [esi+284], ebx
$LN55@Read:

; 3117 : 	}
; 3118 : 
; 3119 : 	if (uiVersion >= 8)

	cmp	DWORD PTR _uiVersion$[esp+52], 8
	jb	SHORT $LN54@Read

; 3120 : 	{
; 3121 : 		kStream >> m_iTradeRouteResourceModifier;

	lea	edx, DWORD PTR [esi+288]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3122 : 	}
; 3123 : 	else

	jmp	SHORT $LN53@Read
$LN54@Read:

; 3124 : 	{
; 3125 : 		m_iTradeRouteResourceModifier = 0;

	mov	DWORD PTR [esi+288], ebx
$LN53@Read:

; 3126 : 	}
; 3127 : 
; 3128 : 	if (uiVersion >= 9)

	cmp	DWORD PTR _uiVersion$[esp+52], 9
	jb	SHORT $LN52@Read

; 3129 : 	{
; 3130 : 		kStream >> m_iUniqueLuxuryCities;

	lea	eax, DWORD PTR [esi+292]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3131 : 		kStream >> m_iUniqueLuxuryQuantity;

	lea	ecx, DWORD PTR [esi+296]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3132 : 	}
; 3133 : 	else

	jmp	SHORT $LN51@Read
$LN52@Read:

; 3134 : 	{
; 3135 : 		m_iUniqueLuxuryCities = 0;

	mov	DWORD PTR [esi+292], ebx

; 3136 : 		m_iUniqueLuxuryQuantity = 0;

	mov	DWORD PTR [esi+296], ebx
$LN51@Read:

; 3137 : 	}
; 3138 : 
; 3139 : 	if (uiVersion >= 11)

	cmp	DWORD PTR _uiVersion$[esp+52], 11	; 0000000bH
	jb	SHORT $LN50@Read

; 3140 : 	{
; 3141 : 		kStream >> m_iUniqueLuxuryCitiesPlaced;

	lea	edx, DWORD PTR [esi+300]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3142 : 	}
; 3143 : 	else

	jmp	SHORT $LN49@Read
$LN50@Read:

; 3144 : 	{
; 3145 : 		m_iUniqueLuxuryCitiesPlaced = 0;

	mov	DWORD PTR [esi+300], ebx
$LN49@Read:

; 3146 : 	}
; 3147 : 
; 3148 : 	if (uiVersion >= 13)

	cmp	DWORD PTR _uiVersion$[esp+52], 13	; 0000000dH
	jb	SHORT $LN48@Read

; 3149 : 	{
; 3150 : 		kStream >> m_iWorkerSpeedModifier;

	lea	eax, DWORD PTR [esi+304]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3151 : 	}
; 3152 : 	else

	jmp	SHORT $LN47@Read
$LN48@Read:

; 3153 : 	{
; 3154 : 		m_iWorkerSpeedModifier = 0;

	mov	DWORD PTR [esi+304], ebx
$LN47@Read:

; 3155 : 	}
; 3156 : 
; 3157 : 	if (uiVersion >= 14)

	cmp	DWORD PTR _uiVersion$[esp+52], 14	; 0000000eH
	jb	SHORT $LN46@Read

; 3158 : 	{
; 3159 : 		kStream >> m_iAfraidMinorPerTurnInfluence;

	lea	ecx, DWORD PTR [esi+308]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3160 : 	}
; 3161 : 	else

	jmp	SHORT $LN45@Read
$LN46@Read:

; 3162 : 	{
; 3163 : 		m_iAfraidMinorPerTurnInfluence = 0;

	mov	DWORD PTR [esi+308], ebx
$LN45@Read:

; 3164 : 	}
; 3165 : 	
; 3166 : 	if (uiVersion >= 15)

	cmp	DWORD PTR _uiVersion$[esp+52], 15	; 0000000fH
	jb	SHORT $LN44@Read

; 3167 : 	{
; 3168 : 		kStream >> m_iLandTradeRouteRangeBonus;

	lea	edx, DWORD PTR [esi+312]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3169 : 		kStream >> m_iTradeReligionModifier;

	lea	eax, DWORD PTR [esi+316]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3170 : 	}
; 3171 : 	else

	jmp	SHORT $LN43@Read
$LN44@Read:

; 3172 : 	{
; 3173 : 		m_iLandTradeRouteRangeBonus = 0;

	mov	DWORD PTR [esi+312], ebx

; 3174 : 		m_iTradeReligionModifier = 0;

	mov	DWORD PTR [esi+316], ebx
$LN43@Read:

; 3175 : 	}
; 3176 : 
; 3177 : 	if (uiVersion >= 16)

	cmp	DWORD PTR _uiVersion$[esp+52], 16	; 00000010H
	jb	SHORT $LN42@Read

; 3178 : 	{
; 3179 : 		kStream >> m_iTradeBuildingModifier;

	lea	ecx, DWORD PTR [esi+320]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3180 : 	}
; 3181 : 	else

	jmp	SHORT $LN41@Read
$LN42@Read:

; 3182 : 	{
; 3183 : 		m_iTradeBuildingModifier = 0;

	mov	DWORD PTR [esi+320], ebx
$LN41@Read:

; 3184 : 	}
; 3185 : 
; 3186 : 	kStream >> m_bFightWellDamaged;

	lea	edx, DWORD PTR [esi+324]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3187 : 	kStream >> m_bMoveFriendlyWoodsAsRoad;

	lea	eax, DWORD PTR [esi+325]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3188 : 	kStream >> m_bFasterAlongRiver;

	lea	ecx, DWORD PTR [esi+326]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3189 : 
; 3190 : 	kStream >> m_bFasterInHills;

	lea	edx, DWORD PTR [esi+327]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3191 : 
; 3192 : 	kStream >> m_bEmbarkedAllWater;

	lea	eax, DWORD PTR [esi+328]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3193 : 
; 3194 : 	kStream >> m_bEmbarkedToLandFlatCost;

	lea	ecx, DWORD PTR [esi+329]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3195 : 
; 3196 : 	kStream >> m_bNoHillsImprovementMaintenance;

	lea	edx, DWORD PTR [esi+330]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3197 : 
; 3198 : 	kStream >> m_bTechBoostFromCapitalScienceBuildings;

	lea	eax, DWORD PTR [esi+331]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3199 : 	kStream >> m_bStaysAliveZeroCities;

	lea	ecx, DWORD PTR [esi+332]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3200 : 
; 3201 : 	kStream >> m_bFaithFromUnimprovedForest;

	lea	edx, DWORD PTR [esi+333]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3202 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 3203 : 	kStream >> m_bSeaTradeRoutesArePlunderImmune;

	lea	eax, DWORD PTR [esi+334]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3204 : #endif
; 3205 : 
; 3206 : 	// NQMP GJS - New France UA begin
; 3207 : 	kStream >> m_bEarnsGreatPersonOnSlotOrGuild;

	lea	ecx, DWORD PTR [esi+335]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3208 : 	kStream >> m_bHasBuiltWritersGuild;

	lea	edx, DWORD PTR [esi+336]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3209 : 	kStream >> m_bHasBuiltArtistsGuild;

	lea	eax, DWORD PTR [esi+337]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3210 : 	kStream >> m_bHasBuiltMusiciansGuild;

	lea	ecx, DWORD PTR [esi+338]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3211 : 	// NQMP GJS - New France UA end
; 3212 : 
; 3213 : 
; 3214 : 	kStream >> m_bBonusReligiousBelief;

	lea	edx, DWORD PTR [esi+339]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3215 : 
; 3216 : 	kStream >> m_bAbleToAnnexCityStates;

	lea	eax, DWORD PTR [esi+340]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3217 : 
; 3218 : 	kStream >> m_bCrossesMountainsAfterGreatGeneral;

	lea	ecx, DWORD PTR [esi+341]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3219 : 
; 3220 : 	kStream >> m_bMayaCalendarBonuses;

	lea	edx, DWORD PTR [esi+342]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3221 : 	kStream >> m_iBaktunPreviousTurn;

	lea	eax, DWORD PTR [esi+712]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3222 : 
; 3223 : 	kStream >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$[esp+52]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3224 : 	m_aMayaBonusChoices.clear();

	mov	edx, DWORD PTR [esi+744]
	mov	ecx, DWORD PTR [esi+740]
	lea	ebp, DWORD PTR [esi+736]
	cmp	ecx, edx
	je	SHORT $LN402@Read
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN427@Read
$LL429@Read:
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebx
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL429@Read
$LN427@Read:
	mov	DWORD PTR [ebp+8], ecx
	xor	ebx, ebx
$LN402@Read:

; 3225 : 	MayaBonusChoice choice;
; 3226 : 	for(int iI = 0; iI < iNumEntries; iI++)

	cmp	DWORD PTR _iNumEntries$[esp+52], ebx
	mov	DWORD PTR _choice$[esp+52], -1
	mov	DWORD PTR _choice$[esp+56], ebx
	mov	DWORD PTR _iI$223751[esp+48], ebx
	jle	$LN38@Read
	npad	6
$LL1062@Read:

; 3227 : 	{
; 3228 : 		kStream >> choice.m_eUnitType;

	lea	edx, DWORD PTR _choice$[esp+52]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8

; 3229 : 		kStream >> choice.m_iBaktunJustFinished;

	lea	eax, DWORD PTR _choice$[esp+56]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3230 : 		m_aMayaBonusChoices.push_back(choice);

	mov	ecx, DWORD PTR [ebp+4]
	test	ecx, ecx
	jne	SHORT $LN444@Read
	xor	eax, eax
	jmp	SHORT $LN445@Read
$LN444@Read:
	mov	eax, DWORD PTR [ebp+12]
	sub	eax, ecx
	sar	eax, 3
$LN445@Read:
	mov	ebx, DWORD PTR [ebp+8]
	mov	edx, ebx
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN437@Read
	mov	ecx, DWORD PTR __Cat$264017[esp+48]
	mov	BYTE PTR $T264014[esp+52], 0
	mov	eax, DWORD PTR $T264014[esp+52]
	push	eax
	push	ecx
	push	ebp
	lea	edx, DWORD PTR _choice$[esp+64]
	push	edx
	push	1
	push	ebx
	call	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H
	add	ebx, 8
	mov	DWORD PTR [ebp+8], ebx
	jmp	SHORT $LN39@Read
$LN437@Read:
	lea	eax, DWORD PTR _choice$[esp+52]
	push	eax
	push	1
	push	ebx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n
$LN39@Read:
	mov	eax, DWORD PTR _iI$223751[esp+48]
	inc	eax
	cmp	eax, DWORD PTR _iNumEntries$[esp+52]
	mov	DWORD PTR _iI$223751[esp+48], eax
	jl	$LL1062@Read
$LN38@Read:

; 3231 : 	}
; 3232 : 
; 3233 : 	kStream >> m_bNoAnnexing;

	lea	ecx, DWORD PTR [esi+343]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3234 : 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[esp+52], 3
	jb	SHORT $LN37@Read

; 3235 : 	{
; 3236 : 		kStream >> m_bTechFromCityConquer;

	lea	edx, DWORD PTR [esi+344]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3237 : 	}
; 3238 : 	else

	jmp	SHORT $LN36@Read
$LN37@Read:

; 3239 : 	{
; 3240 : 		m_bTechFromCityConquer = false;

	mov	BYTE PTR [esi+344], 0
$LN36@Read:

; 3241 : 	}
; 3242 : 
; 3243 : 	if (uiVersion >= 9)

	cmp	DWORD PTR _uiVersion$[esp+52], 9
	jb	SHORT $LN35@Read

; 3244 : 	{
; 3245 : 		kStream >> m_bUniqueLuxuryRequiresNewArea;

	lea	eax, DWORD PTR [esi+345]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3246 : 	}
; 3247 : 	else

	jmp	SHORT $LN34@Read
$LN35@Read:

; 3248 : 	{
; 3249 : 		m_bUniqueLuxuryRequiresNewArea = false;

	mov	BYTE PTR [esi+345], 0
$LN34@Read:

; 3250 : 	}
; 3251 : 
; 3252 : 	if (uiVersion >= 12)

	cmp	DWORD PTR _uiVersion$[esp+52], 12	; 0000000cH
	jb	SHORT $LN33@Read

; 3253 : 	{
; 3254 : 		kStream >> m_bRiverTradeRoad;

	lea	ecx, DWORD PTR [esi+346]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3255 : 	}
; 3256 : 	else

	jmp	SHORT $LN32@Read
$LN33@Read:

; 3257 : 	{
; 3258 : 		m_bRiverTradeRoad = false;

	mov	BYTE PTR [esi+346], 0
$LN32@Read:

; 3259 : 	}
; 3260 : 
; 3261 : 	if (uiVersion >= 18)

	cmp	DWORD PTR _uiVersion$[esp+52], 18	; 00000012H
	jb	SHORT $LN31@Read

; 3262 : 	{
; 3263 : 		kStream >> m_bAngerFreeIntrusionOfCityStates;

	lea	edx, DWORD PTR [esi+347]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3264 : 	}
; 3265 : 	else

	jmp	SHORT $LN30@Read
$LN31@Read:

; 3266 : 	{
; 3267 : 		m_bAngerFreeIntrusionOfCityStates = false;

	mov	BYTE PTR [esi+347], 0
$LN30@Read:

; 3268 : 	}
; 3269 : 
; 3270 : 	kStream >> m_eCampGuardType;

	lea	eax, DWORD PTR [esi+348]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>

; 3271 : 
; 3272 : 	kStream >> m_eCombatBonusImprovement;

	lea	ecx, DWORD PTR [esi+360]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 3273 : 
; 3274 : 	ArrayWrapper<int> kExtraYieldThreshold(NUM_YIELD_TYPES, m_iExtraYieldThreshold);

	lea	ebp, DWORD PTR [esi+376]
	mov	ebx, 6

; 3275 : 	kStream >> kExtraYieldThreshold;

$LL498@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL498@Read

; 3276 : 
; 3277 : 	ArrayWrapper<int> kFreeCityYield(NUM_YIELD_TYPES, m_iFreeCityYield);

	lea	ebp, DWORD PTR [esi+400]
	mov	ebx, 6
	npad	2

; 3278 : 	kStream >> kFreeCityYield;

$LL511@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL511@Read

; 3279 : 
; 3280 : 	ArrayWrapper<int> kYieldChangeResourcesWrapper(NUM_YIELD_TYPES, m_iYieldChangeStrategicResources);

	lea	ebp, DWORD PTR [esi+424]
	mov	ebx, 6
	npad	5

; 3281 : 	kStream >> kYieldChangeResourcesWrapper;

$LL524@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL524@Read

; 3282 : 
; 3283 : 	ArrayWrapper<int> kYieldChangeLuxuryResourcesWrapper(NUM_YIELD_TYPES, m_iYieldChangeLuxuryResources); // NQMP GJS - New Netherlands UA

	lea	ebp, DWORD PTR [esi+448]
	mov	ebx, 6
	npad	5

; 3284 : 	kStream >> kYieldChangeLuxuryResourcesWrapper; // NQMP GJS - New Netherlands UA

$LL537@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL537@Read

; 3285 : 
; 3286 : 	ArrayWrapper<int> kYieldRateModifierWrapper(NUM_YIELD_TYPES, m_iYieldRateModifier);

	lea	ebp, DWORD PTR [esi+544]
	mov	ebx, 6
	npad	5

; 3287 : 	kStream >> kYieldRateModifierWrapper;

$LL550@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL550@Read

; 3288 : 
; 3289 : 	ArrayWrapper<int> kYieldChangeNaturalWonderWrapper(NUM_YIELD_TYPES, m_iYieldChangeNaturalWonder);

	lea	ebp, DWORD PTR [esi+472]
	mov	ebx, 6
	npad	5

; 3290 : 	kStream >> kYieldChangeNaturalWonderWrapper;

$LL563@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL563@Read

; 3291 : 
; 3292 : 	if (uiVersion >= 7)

	cmp	DWORD PTR _uiVersion$[esp+52], 7
	jb	SHORT $LN29@Read

; 3293 : 	{
; 3294 : 		ArrayWrapper<int> kYieldChangePerTradePartnerWrapper(NUM_YIELD_TYPES, m_iYieldChangePerTradePartner);

	lea	ebp, DWORD PTR [esi+496]
	mov	ebx, 6

; 3295 : 		kStream >> kYieldChangePerTradePartnerWrapper;

$LL576@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL576@Read

; 3296 : 
; 3297 : 		ArrayWrapper<int> kYieldChangeIncomingTradeRouteWrapper(NUM_YIELD_TYPES, m_iYieldChangeIncomingTradeRoute);

	lea	ebp, DWORD PTR [esi+520]
	mov	ebx, 6
	npad	3

; 3298 : 		kStream >> kYieldChangeIncomingTradeRouteWrapper;

$LL589@Read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL589@Read

; 3299 : 	}
; 3300 : 	else

	jmp	SHORT $LN25@Read
$LN29@Read:

; 3301 : 	{
; 3302 : 		for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	lea	eax, DWORD PTR [esi+520]
	mov	ecx, 6
	npad	3
$LL27@Read:

; 3303 : 		{
; 3304 : 			m_iYieldChangePerTradePartner[iYield] = 0;

	mov	DWORD PTR [eax-24], 0

; 3305 : 			m_iYieldChangeIncomingTradeRoute[iYield] = 0;

	mov	DWORD PTR [eax], 0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL27@Read
$LN25@Read:

; 3306 : 		}
; 3307 : 	}
; 3308 : 
; 3309 : 	CvAssert(GC.getNumTerrainInfos() == NUM_TERRAIN_TYPES);	// If this is not true, m_iStrategicResourceQuantityModifier must be resized dynamically
; 3310 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, &m_iStrategicResourceQuantityModifier[0], GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	push	eax
	lea	edx, DWORD PTR [esi+568]
	push	edx
	push	edi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>

; 3311 : 
; 3312 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiResourceQuantityModifier);

	lea	eax, DWORD PTR [esi+604]
	push	eax
	push	edi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 20					; 00000014H

; 3313 : 
; 3314 : 	kStream >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$[esp+52]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3315 : 	m_abNoTrain.clear();

	mov	eax, DWORD PTR [esi+620]
	mov	edx, DWORD PTR [esi+628]
	lea	ecx, DWORD PTR [esi+620]
	xor	ebp, ebp
	test	eax, eax
	jbe	SHORT $LN621@Read
	jge	SHORT $LN622@Read
	mov	ebx, eax
	neg	ebx
	je	SHORT $LN622@Read
	or	ebx, -1
	sub	ebx, eax
	shr	ebx, 5
	add	ebx, ebx
	add	ebx, ebx
	mov	ebp, -4					; fffffffcH
	sub	ebp, ebx
	add	edx, ebp
	jmp	SHORT $LN1070@Read
$LN622@Read:
	mov	ebx, eax
	shr	ebx, 5
	lea	edx, DWORD PTR [edx+ebx*4]
$LN1070@Read:
	and	eax, 31					; 0000001fH
	mov	ebp, eax
$LN621@Read:
	push	ebp
	push	edx
	xor	eax, eax
	push	eax
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	lea	edx, DWORD PTR $T264449[esp+68]
	push	edx
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase

; 3316 : 	for (int i = 0; i < iNumEntries; i++)

	cmp	DWORD PTR _iNumEntries$[esp+52], 0
	mov	DWORD PTR _i$223834[esp+52], 0
	jle	$LN22@Read
$LL24@Read:

; 3317 : 	{
; 3318 : 		bool bValue;
; 3319 : 		kStream >> bValue;

	lea	eax, DWORD PTR _bValue$223838[esp+48]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3320 : 		m_abNoTrain.push_back(bValue);

	mov	eax, DWORD PTR [esi+620]
	mov	ecx, DWORD PTR [esi+628]
	lea	ebp, DWORD PTR [esi+620]
	xor	edx, edx
	test	eax, eax
	jbe	SHORT $LN665@Read
	jge	SHORT $LN666@Read
	mov	edx, eax
	neg	edx
	je	SHORT $LN666@Read
	or	edx, -1
	sub	edx, eax
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ebx, -4					; fffffffcH
	sub	ebx, edx
	add	ecx, ebx
	jmp	SHORT $LN1071@Read
$LN666@Read:
	mov	edx, eax
	shr	edx, 5
	lea	ecx, DWORD PTR [ecx+edx*4]
$LN1071@Read:
	and	eax, 31					; 0000001fH
	mov	edx, eax
$LN665@Read:
	mov	al, BYTE PTR _bValue$223838[esp+48]
	push	1
	push	edx
	push	ecx
	mov	ecx, ebp
	mov	BYTE PTR $T264889[esp+64], al
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
	mov	edx, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax+1]
	xor	ebx, ebx
	mov	ebp, edx
	mov	DWORD PTR __Tmp$265157[esp+56], ebx
	test	ecx, ecx
	je	SHORT $LN1060@Read
	jge	SHORT $LN711@Read
	mov	ebx, ecx
	neg	ebx
	je	SHORT $LN711@Read
	or	ebx, -1
	sub	ebx, ecx
	shr	ebx, 5
	lea	ebx, DWORD PTR [ebx*4+4]
	sub	ebp, ebx
	jmp	SHORT $LN1072@Read
$LN711@Read:
	mov	ebx, ecx
	shr	ebx, 5
	lea	ebp, DWORD PTR [edx+ebx*4]
$LN1072@Read:
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR __Tmp$265157[esp+56], ecx
$LN1060@Read:
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN1061@Read
	jge	SHORT $LN736@Read
	mov	ecx, eax
	neg	ecx
	je	SHORT $LN736@Read
	or	ecx, -1
	sub	ecx, eax
	shr	ecx, 5
	lea	ecx, DWORD PTR [ecx*4+4]
	sub	edx, ecx
	jmp	SHORT $LN1073@Read
$LN736@Read:
	mov	ecx, eax
	shr	ecx, 5
	lea	edx, DWORD PTR [edx+ecx*4]
$LN1073@Read:
	and	eax, 31					; 0000001fH
	mov	ecx, eax
$LN1061@Read:
	lea	eax, DWORD PTR $T264889[esp+52]
	push	eax
	mov	eax, DWORD PTR __Tmp$265157[esp+60]
	push	eax
	push	ebp
	push	ecx
	push	edx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	mov	eax, DWORD PTR _i$223834[esp+72]
	inc	eax
	add	esp, 20					; 00000014H
	cmp	eax, DWORD PTR _iNumEntries$[esp+52]
	mov	DWORD PTR _i$223834[esp+52], eax
	jl	$LL24@Read
$LN22@Read:

; 3321 : 	}
; 3322 : 
; 3323 : 	kStream >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$[esp+52]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3324 : 	m_aFreeTraitUnits.clear();

	xor	ebx, ebx

; 3325 : 	for(int iI = 0; iI < iNumEntries; iI++)

	cmp	DWORD PTR _iNumEntries$[esp+52], ebx
	mov	DWORD PTR [esi+644], ebx
	jle	SHORT $LN1063@Read
	lea	ebp, DWORD PTR [esi+640]
$LL21@Read:

; 3326 : 	{
; 3327 : 		FreeTraitUnit trait;
; 3328 : 		kStream >> trait.m_iFreeUnit;

	lea	edx, DWORD PTR _trait$223843[esp+52]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>

; 3329 : 		kStream >> trait.m_ePrereqTech;

	lea	eax, DWORD PTR _trait$223843[esp+64]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z ; operator>>

; 3330 : 		m_aFreeTraitUnits.push_back(trait);

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 16					; 00000010H
	mov	BYTE PTR [ebp+52], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN779@Read
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize
$LN779@Read:
	mov	ecx, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN782@Read
	mov	ecx, DWORD PTR _trait$223843[esp+52]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _trait$223843[esp+56]
	mov	DWORD PTR [eax+4], edx
$LN782@Read:
	inc	DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, DWORD PTR _iNumEntries$[esp+52]
	jl	SHORT $LL21@Read
$LN1063@Read:

; 3331 : 	}
; 3332 : 
; 3333 : 	kStream >> iNumEntries;

	lea	eax, DWORD PTR _iNumEntries$[esp+52]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3334 : 	for(int iI = 0; iI < iNumEntries; iI++)

	mov	eax, DWORD PTR _iNumEntries$[esp+52]
	xor	ebp, ebp
	test	eax, eax
	jle	SHORT $LN16@Read
	npad	1
$LL18@Read:
	mov	ecx, DWORD PTR [esi+756]
	lea	edx, DWORD PTR [ecx+ebp*4]

; 3335 : 	{
; 3336 : 		kStream >> m_paiMovesChangeUnitCombat[iI];

	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	eax, DWORD PTR _iNumEntries$[esp+52]
	inc	ebp
	cmp	ebp, eax
	jl	SHORT $LL18@Read
$LN16@Read:

; 3337 : 	}
; 3338 : 	if (uiVersion >= 10)

	cmp	DWORD PTR _uiVersion$[esp+52], 10	; 0000000aH
	jb	SHORT $LN15@Read

; 3339 : 	{
; 3340 : 		for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebx, ebx
	test	eax, eax
	jle	$LN8@Read
	npad	5
$LL14@Read:
	mov	eax, DWORD PTR [esi+772]
	lea	ecx, DWORD PTR [eax+ebx*4]

; 3341 : 		{
; 3342 : 			kStream >> m_paiMaintenanceModifierUnitCombat[iI];

	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	ebx
	cmp	ebx, DWORD PTR _iNumEntries$[esp+52]
	jl	SHORT $LL14@Read

; 3343 : 		}
; 3344 : 	}
; 3345 : 	else

	jmp	$LN8@Read
$LN15@Read:

; 3346 : 	{
; 3347 : 		int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos

; 3348 : 		m_paiMaintenanceModifierUnitCombat.resize(iNumUnitCombatClassInfos);

	mov	ecx, DWORD PTR [esi+776]
	mov	ebx, DWORD PTR [esi+772]
	lea	edx, DWORD PTR [esi+768]
	mov	ebp, eax
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	mov	DWORD PTR $T265568[esp+48], 0
	cmp	ebp, eax
	jbe	SHORT $LN1074@Read
	lea	ebx, DWORD PTR $T265568[esp+48]
	push	ebx
	mov	ebx, ebp
	sub	ebx, eax
	push	ebx
	push	ecx
	mov	ecx, edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN1066@Read
$LN1074@Read:
	jae	SHORT $LN1066@Read
	lea	ebx, DWORD PTR [ebx+ebp*4]
	mov	DWORD PTR $T265577[esp+48], ebx
	cmp	ebx, ecx
	je	SHORT $LN1066@Read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebx, edx
	test	eax, eax
	jle	SHORT $LN1064@Read
	push	edx
	push	ecx
	push	edx
	mov	edx, DWORD PTR $T265577[esp+60]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1064@Read:
	mov	DWORD PTR [esi+776], ebx
$LN1066@Read:

; 3349 : 		for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	xor	eax, eax
	test	ebp, ebp
	jle	SHORT $LN8@Read
$LL10@Read:

; 3350 : 		{
; 3351 : 			m_paiMaintenanceModifierUnitCombat[iI] = 0;

	mov	ecx, DWORD PTR [esi+772]
	mov	DWORD PTR [ecx+eax*4], 0
	inc	eax
	cmp	eax, ebp
	jl	SHORT $LL10@Read
$LN8@Read:

; 3352 : 		}
; 3353 : 	}
; 3354 : 
; 3355 : 	kStream >> m_ppaaiImprovementYieldChange;

	lea	edx, DWORD PTR [esi+784]
	push	edx
	push	edi
	call	??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >

; 3356 : 	kStream >> m_ppaaiSpecialistYieldChange;

	lea	eax, DWORD PTR [esi+800]
	push	eax
	push	edi
	call	??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >

; 3357 : 
; 3358 : 	kStream >> m_ppaaiUnimprovedFeatureYieldChange;

	lea	ecx, DWORD PTR [esi+816]
	push	ecx
	push	edi
	call	??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >

; 3359 : 
; 3360 : 	if (uiVersion >= 11)

	mov	eax, DWORD PTR _uiVersion$[esp+76]
	add	esp, 24					; 00000018H
	cmp	eax, 11					; 0000000bH
	jb	$LN7@Read

; 3361 : 	{
; 3362 : 		kStream >> iNumEntries;

	lea	edx, DWORD PTR _iNumEntries$[esp+52]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3363 : 		m_aUniqueLuxuryAreas.clear();

	mov	ecx, DWORD PTR [esi+704]
	mov	ebx, DWORD PTR [esi+700]
	add	esi, 696				; 000002b8H
	cmp	ebx, ecx
	je	SHORT $LN1065@Read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ebx+edx]
	test	eax, eax
	jle	SHORT $LN910@Read
	push	edx
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN910@Read:
	mov	DWORD PTR [esi+8], ebp
$LN1065@Read:

; 3364 : 		for (int iI = 0; iI < iNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _iNumEntries$[esp+52], ebx
	jle	$LN992@Read
	npad	4
$LL1067@Read:

; 3365 : 		{
; 3366 : 			int iAreaID;
; 3367 : 			kStream >> iAreaID;

	lea	eax, DWORD PTR _iAreaID$223867[esp+48]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3368 : 			m_aUniqueLuxuryAreas.push_back(iAreaID);

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN923@Read
	xor	eax, eax
	jmp	SHORT $LN924@Read
$LN923@Read:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
$LN924@Read:
	mov	ecx, DWORD PTR [esi+8]
	mov	ebp, ecx
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, eax
	jae	SHORT $LN916@Read
	mov	edx, DWORD PTR _iAreaID$223867[esp+48]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN5@Read
$LN916@Read:
	lea	eax, DWORD PTR _iAreaID$223867[esp+48]
	push	eax
	push	1
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN5@Read:
	inc	ebx
	cmp	ebx, DWORD PTR _iNumEntries$[esp+52]
	jl	SHORT $LL1067@Read
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3378 : 	}
; 3379 : }

	add	esp, 36					; 00000024H
	ret	4
$LN7@Read:

; 3369 : 		}
; 3370 : 	}
; 3371 : 	else if (uiVersion >= 9)

	cmp	eax, 9
	jb	SHORT $LN2@Read

; 3372 : 	{
; 3373 : 		kStream >> m_aUniqueLuxuryAreas;

	add	esi, 696				; 000002b8H
	push	esi
	push	edi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3378 : 	}
; 3379 : }

	add	esp, 36					; 00000024H
	ret	4
$LN2@Read:

; 3374 : 	}
; 3375 : 	else
; 3376 : 	{
; 3377 : 		m_aUniqueLuxuryAreas.clear();

	mov	ecx, DWORD PTR [esi+704]
	mov	edi, DWORD PTR [esi+700]
	cmp	edi, ecx
	je	SHORT $LN992@Read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edi+edx]
	test	eax, eax
	jle	SHORT $LN1017@Read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1017@Read:
	mov	DWORD PTR [esi+704], ebx
$LN992@Read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3378 : 	}
; 3379 : }

	add	esp, 36					; 00000024H
	ret	4
?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTraits::Read
_TEXT	ENDS
END
