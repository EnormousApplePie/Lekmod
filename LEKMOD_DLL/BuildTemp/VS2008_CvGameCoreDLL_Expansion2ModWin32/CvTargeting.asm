; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTargeting.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_ms_LookBackX DD 00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	01H
_ms_LookBackY DD 0ffffffffH
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	0ffffffffH
_ms_HexDirection DD 00H
	DD	04H
	DD	05H
	DD	03H
	DD	00H
	DD	00H
	DD	02H
	DD	01H
	DD	00H
_DATA	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
; Function compile flags: /Ogtpy
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	eax, DWORD PTR _iDX$[esp-4]
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	xor	edx, edx
	test	esi, esi
	setge	dl
	cmp	ecx, edx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN6@hexDistanc
	neg	eax
$LN6@hexDistanc:

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN8@hexDistanc
	neg	esi
$LN8@hexDistanc:

; 112  : 		return iAbsDX + iAbsDY;

	add	eax, esi
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
$LN2@hexDistanc:

; 113  : 	}
; 114  : 	else
; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN10@hexDistanc
	neg	eax
$LN10@hexDistanc:

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN12@hexDistanc
	neg	esi
$LN12@hexDistanc:

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	eax, esi
	jge	SHORT $LN1@hexDistanc
	mov	eax, esi
$LN1@hexDistanc:
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	?GetLastTargetingPathIndex@@YAHH@Z		; GetLastTargetingPathIndex
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtargeting.cpp
;	COMDAT ?GetLastTargetingPathIndex@@YAHH@Z
_TEXT	SEGMENT
_plotIndex$ = 8						; size = 4
?GetLastTargetingPathIndex@@YAHH@Z PROC			; GetLastTargetingPathIndex, COMDAT

; 36   : #if defined(TARGETING_DEBUG)
; 37   : 	int iIndex = 0;
; 38   : 	for (std::vector<int>::const_iterator itr = ms_lastTargetingPath.begin(); itr != ms_lastTargetingPath.end(); ++itr)
; 39   : 	{
; 40   : 		if ((*itr) == plotIndex)
; 41   : 			return iIndex;
; 42   : 		++iIndex;
; 43   : 	}
; 44   : #else
; 45   : 	UNREFERENCED_PARAMETER(plotIndex);
; 46   : #endif
; 47   : 
; 48   : 	return -1;

	or	eax, -1

; 49   : }

	ret	0
?GetLastTargetingPathIndex@@YAHH@Z ENDP			; GetLastTargetingPathIndex
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z	; PlotFromHex
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z
_TEXT	SEGMENT
_kMap$ = 8						; size = 4
_iHexX$ = 12						; size = 4
_iHexY$ = 16						; size = 4
?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z PROC		; PlotFromHex, COMDAT

; 252  : {

	push	ebx

; 253  : 	// NOTE: Y is the same in both hex space and grid space.
; 254  : 	return kMap.plot( hexspaceXToX(iHexX, iHexY), iHexY );	

	mov	ebx, DWORD PTR _iHexY$[esp]
	test	ebx, ebx
	jl	SHORT $LN5@PlotFromHe
	mov	eax, ebx
	jmp	SHORT $LN50@PlotFromHe
$LN5@PlotFromHe:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN50@PlotFromHe:
	mov	ecx, DWORD PTR _iHexX$[esp]
	sar	eax, 1
	add	eax, ecx
	cmp	eax, -2147483647			; 80000001H
	je	$LN7@PlotFromHe
	cmp	ebx, -2147483647			; 80000001H
	je	$LN7@PlotFromHe
	push	ebp
	mov	ebp, DWORD PTR _kMap$[esp+4]
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	push	esi
	je	SHORT $LN17@PlotFromHe
	test	eax, eax
	jge	SHORT $LN19@PlotFromHe
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@PlotFromHe
$LN19@PlotFromHe:
	cmp	eax, ecx
	jl	SHORT $LN17@PlotFromHe
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@PlotFromHe
$LN17@PlotFromHe:
	mov	esi, eax
$LN21@PlotFromHe:
	cmp	BYTE PTR [ebp+4057], 0
	push	edi
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN46@PlotFromHe
	test	ebx, ebx
	jge	SHORT $LN29@PlotFromHe
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@PlotFromHe
$LN29@PlotFromHe:
	cmp	ebx, edi
	jl	SHORT $LN46@PlotFromHe
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@PlotFromHe
$LN46@PlotFromHe:
	mov	edx, ebx
$LN31@PlotFromHe:
	test	esi, esi
	jl	SHORT $LN11@PlotFromHe
	cmp	esi, ecx
	jge	SHORT $LN11@PlotFromHe
	test	edx, edx
	jl	SHORT $LN11@PlotFromHe
	cmp	edx, edi
	jge	SHORT $LN11@PlotFromHe
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 255  : }

	ret	0

; 253  : 	// NOTE: Y is the same in both hex space and grid space.
; 254  : 	return kMap.plot( hexspaceXToX(iHexX, iHexY), iHexY );	

$LN11@PlotFromHe:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 255  : }

	ret	0

; 253  : 	// NOTE: Y is the same in both hex space and grid space.
; 254  : 	return kMap.plot( hexspaceXToX(iHexX, iHexY), iHexY );	

$LN7@PlotFromHe:
	xor	eax, eax
	pop	ebx

; 255  : }

	ret	0
?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ENDP		; PlotFromHex
_TEXT	ENDS
EXTRN	?seeThroughLevel@CvPlot@@QBEH_N@Z:PROC		; CvPlot::seeThroughLevel
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtargeting.cpp
;	COMDAT ?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z
_TEXT	SEGMENT
_straightThrough$ = -46					; size = 1
_oddQuadrant$ = -45					; size = 1
_stepCount$ = -44					; size = 4
_iBlockedCount$ = -40					; size = 4
tv571 = -36						; size = 4
tv561 = -36						; size = 4
_kMap$ = -32						; size = 4
_lastDY$ = -28						; size = 4
_stepY$ = -24						; size = 4
tv563 = -20						; size = 4
_shortAxisStepFactor$218184 = -20			; size = 4
_originalDX$ = -16					; size = 4
_originalDY$ = -12					; size = 4
_stepX$ = -8						; size = 4
_shortAxisStepFactor$218155 = -4			; size = 4
_startX$ = 8						; size = 4
_startY$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_fromLevel$ = 24					; size = 4
?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z PROC	; CanSeeDisplacementPlot_Strict, COMDAT

; 103  : {

	sub	esp, 48					; 00000030H

; 104  : 	int originalDX = dx;
; 105  : 	int originalDY = dy;

	mov	ecx, DWORD PTR _dy$[esp+44]
	mov	edx, DWORD PTR _dx$[esp+44]

; 106  : 
; 107  : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp

; 108  : 
; 109  : 	// Use Bresenham's line algorithm, with a slight modification, to step through the cells.
; 110  : 	// The modification is that if we are stepping in the upper-right or lower-left quadrant,
; 111  : 	// and we need to take a step on the 'short' axis, we will check the plot with just the
; 112  : 	// adjustment to the X axis, before we do the normal check for the step on the X and Y
; 113  : 	// axis.  This is needed because in those quadrants a change on both the X and Y axis 
; 114  : 	// is not contiguous.
; 115  : 
; 116  : 	// Because the hex grid is low-resolution, checks are also made to allow the ray to continue 
; 117  : 	// around a blockage if that blockage obscures only part of the next hex cell along the ray.
; 118  : 	// This is done by 'looking back' at the alternate path the ray could have taken as it is 
; 119  : 	// traversing the hex grid.
; 120  : 
; 121  : 	// Make DX and DY positive and adjust the step constant for the opposite axis.
; 122  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 123  : 	int stepY = 1;
; 124  : #else
; 125  : 	int stepY;
; 126  : #endif
; 127  : 	if (dy < 0) 

	xor	ebx, ebx
	cmp	ecx, ebx
	push	esi
	push	edi
	mov	DWORD PTR _originalDX$[esp+64], edx
	mov	DWORD PTR _originalDY$[esp+64], ecx
	mov	DWORD PTR _kMap$[esp+64], eax
	jge	SHORT $LN50@CanSeeDisp

; 128  : 	{ 
; 129  : 		dy = -dy;  

	neg	ecx

; 130  : 		stepY = -1; 

	mov	DWORD PTR _stepY$[esp+64], -1

; 131  : 	} 
; 132  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 133  : 	int stepX = 1;
; 134  : #else
; 135  : 	else 

	jmp	SHORT $LN49@CanSeeDisp
$LN50@CanSeeDisp:

; 136  : 		stepY = 1; 

	mov	DWORD PTR _stepY$[esp+64], 1
$LN49@CanSeeDisp:

; 137  : 
; 138  : 	int stepX;
; 139  : #endif
; 140  : 	if (dx < 0) 

	cmp	edx, ebx
	jge	SHORT $LN48@CanSeeDisp

; 141  : 	{ 
; 142  : 		dx = -dx;  

	neg	edx

; 143  : 		stepX = -1; 

	or	ebp, -1
	mov	DWORD PTR _stepX$[esp+64], ebp

; 144  : 	} 
; 145  : #ifndef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 146  : 	else 

	jmp	SHORT $LN47@CanSeeDisp
$LN48@CanSeeDisp:

; 147  : 		stepX = 1;

	mov	DWORD PTR _stepX$[esp+64], 1
	mov	ebp, DWORD PTR _stepX$[esp+64]
$LN47@CanSeeDisp:

; 148  : #endif
; 149  : 
; 150  : 	dy <<= 1;

	add	ecx, ecx

; 151  : 	dx <<= 1;

	add	edx, edx

; 152  : 
; 153  : 	int currentDX = 0;

	xor	edi, edi

; 154  : 	int currentDY = 0;

	xor	esi, esi

; 155  : 
; 156  : 	// If in an odd quadrant, stepping down on the short axis requires two checks to be contiguous
; 157  : 	bool oddQuadrant = stepX != stepY;

	cmp	ebp, DWORD PTR _stepY$[esp+64]
	mov	DWORD PTR _dy$[esp+60], ecx
	setne	BYTE PTR _oddQuadrant$[esp+64]
	mov	DWORD PTR _dx$[esp+60], edx

; 158  : 	// Is the line going to go such that it travels through the centers of the hexes?
; 159  : 	// If so, we don't have to worry about testing to see if we can look around blocked hexes.
; 160  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 161  : 	bool straightThrough = dx == 0 || dy == 0 || (dx == dy && oddQuadrant);
; 162  : #else
; 163  : 	bool straightThrough = dx == 0 || dy == 0;

	cmp	edx, ebx
	je	SHORT $LN53@CanSeeDisp
	mov	BYTE PTR _straightThrough$[esp+64], bl
	cmp	ecx, ebx
	jne	SHORT $LN54@CanSeeDisp
$LN53@CanSeeDisp:
	mov	BYTE PTR _straightThrough$[esp+64], 1
$LN54@CanSeeDisp:

; 164  : #endif
; 165  : 
; 166  : 	// Start from the next cell after the source plot
; 167  : 	int lastDX = currentDX;
; 168  : 	int lastDY = currentDY;
; 169  : 	int lookbackDirection = -1;

	or	eax, -1

; 170  : 	int stepCount = 0;
; 171  : 	int iBlockedCount = 0;
; 172  : 
; 173  : 	// If dx is greater than dy, scan along the x axis, adjusting the Y as needed
; 174  : 	if (dx > dy) 

	cmp	ecx, edx
	mov	DWORD PTR _lastDY$[esp+64], ebx
	mov	DWORD PTR _stepCount$[esp+64], ebx
	mov	DWORD PTR _iBlockedCount$[esp+64], ebx
	jge	$LN84@CanSeeDisp

; 175  : 	{
; 176  : 		int shortAxisStepFactor = (dx >> 1); 

	sar	edx, 1
	mov	DWORD PTR _shortAxisStepFactor$218155[esp+64], edx

; 177  : 		while (currentDX != originalDX) 

	cmp	DWORD PTR _originalDX$[esp+64], ebx
	je	$LN21@CanSeeDisp
	mov	edx, DWORD PTR _startX$[esp+60]
	mov	DWORD PTR tv561[esp+64], edx
	mov	edx, DWORD PTR _startY$[esp+60]
	mov	DWORD PTR tv563[esp+64], edx
	jmp	SHORT $LN45@CanSeeDisp
	npad	8
$LL71@CanSeeDisp:

; 175  : 	{
; 176  : 		int shortAxisStepFactor = (dx >> 1); 

	mov	ebp, DWORD PTR _stepX$[esp+64]
	mov	ecx, DWORD PTR _dy$[esp+60]
$LN45@CanSeeDisp:

; 178  : 		{
; 179  : 			shortAxisStepFactor += dy;

	mov	edx, DWORD PTR _shortAxisStepFactor$218155[esp+64]

; 180  : 
; 181  : 			if (shortAxisStepFactor >= dx) 
; 182  : 			{
; 183  : 				shortAxisStepFactor -= dx;
; 184  : 
; 185  : 				if (oddQuadrant)
; 186  : 				{
; 187  : 					currentDX += stepX;

	add	DWORD PTR tv561[esp+64], ebp
	add	edx, ecx
	mov	ecx, DWORD PTR _dx$[esp+60]
	add	edi, ebp
	cmp	edx, ecx
	mov	DWORD PTR _shortAxisStepFactor$218155[esp+64], edx
	jl	$LN32@CanSeeDisp
	sub	DWORD PTR _shortAxisStepFactor$218155[esp+64], ecx
	cmp	BYTE PTR _oddQuadrant$[esp+64], 0

; 188  : 					currentDY += stepY;
; 189  : 				}
; 190  : 				else

	jne	$LN86@CanSeeDisp

; 191  : 				{
; 192  : 					currentDX += stepX;
; 193  : 
; 194  : 					// Look back to see if we were possibly blocked by the alternate route to this hex.  We will ignore the check if inside the rings that allow the user to look around obstacles.
; 195  : 					if (!straightThrough && lookbackDirection != -1)

	cmp	BYTE PTR _straightThrough$[esp+64], 0
	jne	SHORT $LN73@CanSeeDisp
	cmp	eax, -1
	je	SHORT $LN73@CanSeeDisp

; 196  : 					{
; 197  : 						CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	ecx, DWORD PTR _ms_LookBackY[eax*4]
	mov	edx, DWORD PTR _ms_LookBackX[eax*4]
	mov	eax, DWORD PTR _kMap$[esp+64]
	add	ecx, esi
	add	ecx, DWORD PTR _startY$[esp+60]
	add	edx, edi
	add	edx, DWORD PTR _startX$[esp+60]
	push	ecx
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 198  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 199  : 						if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN72@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jge	SHORT $LN73@CanSeeDisp
$LN72@CanSeeDisp:

; 200  : 						{
; 201  : 							++iBlockedCount;

	inc	DWORD PTR _iBlockedCount$[esp+64]

; 202  : 							if (stepCount > STRICT_LOOSE_CUTOFF || iBlockedCount >= 2)

	mov	eax, 2
	cmp	DWORD PTR _stepCount$[esp+64], eax
	jg	$LN36@CanSeeDisp
	cmp	DWORD PTR _iBlockedCount$[esp+64], eax
	jge	$LN36@CanSeeDisp
$LN73@CanSeeDisp:

; 204  : 						}
; 205  : 					}
; 206  : 
; 207  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 208  : 					if (currentDX == originalDX && currentDY == originalDY)

	cmp	edi, DWORD PTR _originalDX$[esp+64]
	jne	SHORT $LN35@CanSeeDisp
	cmp	esi, DWORD PTR _originalDY$[esp+64]
	je	$LN21@CanSeeDisp
$LN35@CanSeeDisp:

; 209  : 						break;	
; 210  : 
; 211  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	ecx, DWORD PTR tv563[esp+64]
	mov	edx, DWORD PTR tv561[esp+64]
	mov	eax, DWORD PTR _kMap$[esp+64]
	push	ecx
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 212  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 213  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	$LN36@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jl	$LN36@CanSeeDisp

; 214  : 						return false;
; 215  : 
; 216  : 					lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, edi
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*2]
	sub	ecx, DWORD PTR _lastDY$[esp+64]

; 217  : 
; 218  : 					++stepCount;
; 219  : 					lastDX = currentDX; lastDY = currentDY;

	mov	ebx, edi
	add	ecx, esi
	mov	eax, DWORD PTR _ms_HexDirection[ecx*4+16]
	inc	DWORD PTR _stepCount$[esp+64]
	mov	DWORD PTR _lastDY$[esp+64], esi
$LN86@CanSeeDisp:

; 220  : 
; 221  : 					currentDY += stepY;

	mov	ecx, DWORD PTR _stepY$[esp+64]
	add	esi, ecx
	add	DWORD PTR tv563[esp+64], ecx
$LN32@CanSeeDisp:

; 222  : 				}
; 223  : 			}
; 224  : 			else
; 225  : 				currentDX += stepX;
; 226  : 
; 227  : 			// Look back to see if we were possibly blocked by the alternate route to this hex.
; 228  : 			if (!straightThrough && lookbackDirection != -1)

	cmp	BYTE PTR _straightThrough$[esp+64], 0
	jne	SHORT $LN76@CanSeeDisp
	cmp	eax, -1
	je	SHORT $LN76@CanSeeDisp

; 229  : 			{
; 230  : 				CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	edx, DWORD PTR _ms_LookBackY[eax*4]
	mov	eax, DWORD PTR _ms_LookBackX[eax*4]
	mov	ecx, DWORD PTR _kMap$[esp+64]
	add	edx, esi
	add	edx, DWORD PTR _startY$[esp+60]
	add	eax, edi
	add	eax, DWORD PTR _startX$[esp+60]
	push	edx
	push	eax
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 231  : 				TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 232  : 				if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN82@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jge	SHORT $LN76@CanSeeDisp
$LN82@CanSeeDisp:

; 233  : 				{
; 234  : 					if (stepCount > STRICT_LOOSE_CUTOFF || ++iBlockedCount >= 2)

	cmp	DWORD PTR _stepCount$[esp+64], 2
	jg	SHORT $LN36@CanSeeDisp
	mov	eax, DWORD PTR _iBlockedCount$[esp+64]
	inc	eax
	cmp	eax, 2
	mov	DWORD PTR _iBlockedCount$[esp+64], eax
	jge	SHORT $LN36@CanSeeDisp
$LN76@CanSeeDisp:

; 235  : 						return false;
; 236  : 				}
; 237  : 			}
; 238  : 
; 239  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 240  : 			if (currentDX == originalDX && currentDY == originalDY)

	cmp	edi, DWORD PTR _originalDX$[esp+64]
	jne	SHORT $LN26@CanSeeDisp
	cmp	esi, DWORD PTR _originalDY$[esp+64]
	je	$LN21@CanSeeDisp
$LN26@CanSeeDisp:

; 241  : 				break;	
; 242  : 
; 243  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	edx, DWORD PTR tv563[esp+64]
	mov	eax, DWORD PTR tv561[esp+64]
	mov	ecx, DWORD PTR _kMap$[esp+64]
	push	edx
	push	eax
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 244  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 245  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN36@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jl	SHORT $LN36@CanSeeDisp

; 246  : 				return false;
; 247  : 
; 248  : 			lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];
; 249  : 
; 250  : 			++stepCount;

	inc	DWORD PTR _stepCount$[esp+64]
	mov	eax, edi
	sub	eax, ebx
	lea	edx, DWORD PTR [eax+eax*2]
	sub	edx, DWORD PTR _lastDY$[esp+64]

; 251  : 			lastDX = currentDX; lastDY = currentDY;

	mov	ebx, edi
	add	edx, esi
	mov	eax, DWORD PTR _ms_HexDirection[edx*4+16]
	mov	DWORD PTR _lastDY$[esp+64], esi
	cmp	edi, DWORD PTR _originalDX$[esp+64]
	jne	$LL71@CanSeeDisp
	pop	edi
	pop	esi
	pop	ebp

; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : 	return true;

	mov	al, 1
	pop	ebx

; 341  : }

	add	esp, 48					; 00000030H
	ret	0
$LN36@CanSeeDisp:
	pop	edi
	pop	esi
	pop	ebp

; 203  : 								return false;

	xor	al, al
	pop	ebx

; 341  : }

	add	esp, 48					; 00000030H
	ret	0
$LN84@CanSeeDisp:

; 252  : 		}
; 253  : 	} 
; 254  : 	else 
; 255  : 	{
; 256  : 		// Y axis runs are longer, scan along them and adjust the X as needed.
; 257  : 		// The short axis step is primed slightly differently if the step ratio is 2:1
; 258  : 		// so that the initial step goes in a more favorable direction
; 259  : 		int shortAxisStepFactor = (dy!=dx && dx != 0 && (dy>>1) == dx)?((dy >> 1) - dx):(dy >> 1);

	je	SHORT $LN55@CanSeeDisp
	test	edx, edx
	je	SHORT $LN55@CanSeeDisp
	sar	ecx, 1
	cmp	ecx, edx
	jne	SHORT $LN81@CanSeeDisp
	sub	ecx, edx
	jmp	SHORT $LN85@CanSeeDisp
$LN81@CanSeeDisp:
	mov	ecx, DWORD PTR _dy$[esp+60]
$LN55@CanSeeDisp:
	sar	ecx, 1
$LN85@CanSeeDisp:
	mov	DWORD PTR _shortAxisStepFactor$218184[esp+64], ecx

; 260  : 		//int fraction = (dy >> 1);
; 261  : 		while (currentDY != originalDY) 

	cmp	DWORD PTR _originalDY$[esp+64], ebx
	je	$LN21@CanSeeDisp
	mov	ecx, DWORD PTR _startX$[esp+60]
	mov	ebp, DWORD PTR _startY$[esp+60]
	mov	DWORD PTR tv571[esp+64], ecx
	jmp	SHORT $LN22@CanSeeDisp
	npad	9
$LL77@CanSeeDisp:
	mov	edx, DWORD PTR _dx$[esp+60]
$LN22@CanSeeDisp:

; 262  : 		{
; 263  : 			shortAxisStepFactor += dx;

	add	DWORD PTR _shortAxisStepFactor$218184[esp+64], edx

; 264  : 
; 265  : 			if (shortAxisStepFactor >= dy) 

	mov	ecx, DWORD PTR _dy$[esp+60]
	cmp	DWORD PTR _shortAxisStepFactor$218184[esp+64], ecx
	jl	$LN20@CanSeeDisp

; 266  : 			{
; 267  : 				shortAxisStepFactor -= dy;

	sub	DWORD PTR _shortAxisStepFactor$218184[esp+64], ecx

; 268  : 
; 269  : 				if (oddQuadrant)
; 270  : 				{
; 271  : 					// A change in the X and Y axis will yield a contiguous line
; 272  : 					currentDX += stepX;

	mov	ecx, DWORD PTR _stepX$[esp+64]
	add	DWORD PTR tv571[esp+64], ecx
	add	edi, ecx
	cmp	BYTE PTR _oddQuadrant$[esp+64], 0

; 273  : 					currentDY += stepY;
; 274  : 				}
; 275  : 				else

	jne	$LN20@CanSeeDisp

; 276  : 				{
; 277  : 					// Adjust just the X axis, then check so that the line is contiguous.
; 278  : 					currentDX += stepX;
; 279  : 
; 280  : 					// Look back to see if we were possibly blocked by the alternate route to this hex.
; 281  : 					if (!straightThrough && lookbackDirection != -1)

	cmp	BYTE PTR _straightThrough$[esp+64], 0
	jne	SHORT $LN78@CanSeeDisp
	cmp	eax, -1
	je	SHORT $LN78@CanSeeDisp

; 282  : 					{
; 283  : 						CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	edx, DWORD PTR _ms_LookBackY[eax*4]
	mov	eax, DWORD PTR _ms_LookBackX[eax*4]
	mov	ecx, DWORD PTR _kMap$[esp+64]
	add	edx, esi
	add	edx, DWORD PTR _startY$[esp+60]
	add	eax, edi
	add	eax, DWORD PTR _startX$[esp+60]
	push	edx
	push	eax
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 284  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 285  : 						if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN15@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jge	SHORT $LN78@CanSeeDisp
$LN15@CanSeeDisp:

; 286  : 						{
; 287  : 							if (stepCount > STRICT_LOOSE_CUTOFF || ++iBlockedCount >= 2)

	cmp	DWORD PTR _stepCount$[esp+64], 2
	jg	$LN36@CanSeeDisp
	mov	eax, DWORD PTR _iBlockedCount$[esp+64]
	inc	eax
	cmp	eax, 2
	mov	DWORD PTR _iBlockedCount$[esp+64], eax
	jge	$LN36@CanSeeDisp
$LN78@CanSeeDisp:

; 288  : 								return false;
; 289  : 						}
; 290  : 					}
; 291  : 
; 292  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 293  : 					if (currentDX == originalDX && currentDY == originalDY)

	cmp	edi, DWORD PTR _originalDX$[esp+64]
	jne	SHORT $LN12@CanSeeDisp
	cmp	esi, DWORD PTR _originalDY$[esp+64]
	je	$LN21@CanSeeDisp
$LN12@CanSeeDisp:

; 294  : 						break;	
; 295  : 
; 296  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	edx, DWORD PTR tv571[esp+64]
	mov	eax, DWORD PTR _kMap$[esp+64]
	push	ebp
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 297  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 298  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	$LN36@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jl	$LN36@CanSeeDisp

; 299  : 						return false;
; 300  : 
; 301  : 					lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, edi
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*2]
	sub	ecx, DWORD PTR _lastDY$[esp+64]

; 302  : 
; 303  : 					++stepCount;
; 304  : 					lastDX = currentDX; lastDY = currentDY;

	mov	ebx, edi
	add	ecx, esi
	mov	eax, DWORD PTR _ms_HexDirection[ecx*4+16]
	inc	DWORD PTR _stepCount$[esp+64]
	mov	DWORD PTR _lastDY$[esp+64], esi
$LN20@CanSeeDisp:

; 305  : 
; 306  : 					currentDY += stepY;
; 307  : 				}
; 308  : 			}
; 309  : 			else
; 310  : 				currentDY += stepY;

	mov	ecx, DWORD PTR _stepY$[esp+64]
	add	esi, ecx
	add	ebp, ecx

; 311  : 
; 312  : 			// Look back to see if we were possibly blocked by the alternate route to this hex.
; 313  : 			if (!straightThrough && lookbackDirection != -1)

	cmp	BYTE PTR _straightThrough$[esp+64], 0
	jne	SHORT $LN79@CanSeeDisp
	cmp	eax, -1
	je	SHORT $LN79@CanSeeDisp

; 314  : 			{
; 315  : 				CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[lookbackDirection], startY + currentDY + ms_LookBackY[lookbackDirection]);

	mov	edx, DWORD PTR _ms_LookBackY[eax*4]
	mov	eax, DWORD PTR _ms_LookBackX[eax*4]
	mov	ecx, DWORD PTR _kMap$[esp+64]
	add	edx, esi
	add	edx, DWORD PTR _startY$[esp+60]
	add	eax, edi
	add	eax, DWORD PTR _startX$[esp+60]
	push	edx
	push	eax
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 316  : 				TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 317  : 				if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN6@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jge	SHORT $LN79@CanSeeDisp
$LN6@CanSeeDisp:

; 318  : 				{
; 319  : 					if (stepCount > STRICT_LOOSE_CUTOFF || ++iBlockedCount >= 2)

	cmp	DWORD PTR _stepCount$[esp+64], 2
	jg	$LN36@CanSeeDisp
	mov	eax, DWORD PTR _iBlockedCount$[esp+64]
	inc	eax
	cmp	eax, 2
	mov	DWORD PTR _iBlockedCount$[esp+64], eax
	jge	$LN36@CanSeeDisp
$LN79@CanSeeDisp:

; 320  : 						return false;
; 321  : 				}
; 322  : 			}
; 323  : 
; 324  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 325  : 			if (currentDX == originalDX && currentDY == originalDY)

	cmp	edi, DWORD PTR _originalDX$[esp+64]
	jne	SHORT $LN3@CanSeeDisp
	cmp	esi, DWORD PTR _originalDY$[esp+64]
	je	SHORT $LN21@CanSeeDisp
$LN3@CanSeeDisp:

; 326  : 				break;	
; 327  : 
; 328  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	edx, DWORD PTR tv571[esp+64]
	mov	eax, DWORD PTR _kMap$[esp+64]
	push	ebp
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 329  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 330  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	$LN36@CanSeeDisp
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+60], eax
	jl	$LN36@CanSeeDisp

; 331  : 				return false;
; 332  : 
; 333  : 			lookbackDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];
; 334  : 
; 335  : 			++stepCount;

	inc	DWORD PTR _stepCount$[esp+64]
	mov	eax, edi
	sub	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*2]
	sub	ecx, DWORD PTR _lastDY$[esp+64]

; 336  : 			lastDX = currentDX; lastDY = currentDY;

	mov	ebx, edi
	add	ecx, esi
	mov	eax, DWORD PTR _ms_HexDirection[ecx*4+16]
	mov	DWORD PTR _lastDY$[esp+64], esi
	cmp	esi, DWORD PTR _originalDY$[esp+64]
	jne	$LL77@CanSeeDisp
$LN21@CanSeeDisp:
	pop	edi
	pop	esi
	pop	ebp

; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : 	return true;

	mov	al, 1
	pop	ebx

; 341  : }

	add	esp, 48					; 00000030H
	ret	0
?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z ENDP	; CanSeeDisplacementPlot_Strict
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z
_TEXT	SEGMENT
_straightThrough$ = -42					; size = 1
_oddQuadrant$ = -41					; size = 1
tv574 = -40						; size = 4
tv562 = -40						; size = 4
_kMap$ = -36						; size = 4
_lastDX$ = -32						; size = 4
_lastDY$ = -28						; size = 4
_stepY$ = -24						; size = 4
tv564 = -20						; size = 4
_shortAxisStepFactor$218266 = -20			; size = 4
_originalDX$ = -16					; size = 4
tv572 = -12						; size = 4
_shortAxisStepFactor$218237 = -12			; size = 4
_originalDY$ = -8					; size = 4
_stepX$ = -4						; size = 4
_startX$ = 8						; size = 4
_startY$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_fromLevel$ = 24					; size = 4
?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z PROC		; CanSeeDisplacementPlot_Loose, COMDAT

; 348  : {

	sub	esp, 44					; 0000002cH

; 349  : 	int originalDX = dx;
; 350  : 	int originalDY = dy;
; 351  : 
; 352  : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR _dy$[esp+40]
	mov	edx, DWORD PTR _dx$[esp+40]
	mov	DWORD PTR _kMap$[esp+44], ecx

; 353  : 
; 354  : 	// Use Bresenham's line algorithm, with a slight modification, to step through the cells.
; 355  : 	// The modification is that if we are stepping in the upper-right or lower-left quadrant,
; 356  : 	// and we need to take a step on the 'short' axis, we will check the plot with just the
; 357  : 	// adjustment to the X axis, before we do the normal check for the step on the X and Y
; 358  : 	// axis.  This is needed because in those quadrants a change on both the X and Y axis 
; 359  : 	// is not contiguous.
; 360  : 
; 361  : 	// Because the hex grid is low-resolution, checks are also made to allow the ray to continue 
; 362  : 	// around a blockage if that blockage obscures only part of the next hex cell along the ray.
; 363  : 	// This is done by 'looking back' at the alternate path the ray could have taken as it is 
; 364  : 	// traversing the hex grid.
; 365  : 
; 366  : 	// Make DX and DY positive and adjust the step constant for the opposite axis.
; 367  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 368  : 	int stepY = 1;
; 369  : #else
; 370  : 	int stepY;
; 371  : #endif
; 372  : 	if (dy < 0) 

	or	ecx, -1
	mov	DWORD PTR _originalDX$[esp+44], edx
	mov	DWORD PTR _originalDY$[esp+44], eax
	test	eax, eax
	jge	SHORT $LN50@CanSeeDisp@2

; 373  : 	{ 
; 374  : 		dy = -dy;  

	neg	eax

; 375  : 		stepY = -1; 

	mov	DWORD PTR _stepY$[esp+44], ecx

; 376  : 	} 
; 377  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 378  : 	int stepX = 1;
; 379  : #else
; 380  : 	else 

	jmp	SHORT $LN49@CanSeeDisp@2
$LN50@CanSeeDisp@2:

; 381  : 		stepY = 1; 

	mov	DWORD PTR _stepY$[esp+44], 1
$LN49@CanSeeDisp@2:

; 382  : 
; 383  : 	int stepX;
; 384  : #endif
; 385  : 	if (dx < 0) 

	test	edx, edx
	jge	SHORT $LN48@CanSeeDisp@2

; 386  : 	{ 
; 387  : 		dx = -dx;  

	neg	edx

; 388  : 		stepX = -1; 

	mov	DWORD PTR _stepX$[esp+44], ecx

; 389  : 	} 
; 390  : #ifndef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 391  : 	else 

	jmp	SHORT $LN47@CanSeeDisp@2
$LN48@CanSeeDisp@2:

; 392  : 		stepX = 1;

	mov	DWORD PTR _stepX$[esp+44], 1
	mov	ecx, DWORD PTR _stepX$[esp+44]
$LN47@CanSeeDisp@2:
	push	ebx
	push	ebp
	push	esi

; 393  : #endif
; 394  : 
; 395  : 	dy <<= 1;

	add	eax, eax

; 396  : 	dx <<= 1;

	add	edx, edx
	push	edi

; 397  : 
; 398  : 	int currentDX = 0;

	xor	esi, esi

; 399  : 	int currentDY = 0;

	xor	edi, edi

; 400  : 
; 401  : 	bool bBlocked = false;

	xor	bl, bl

; 402  : 	// If in an odd quadrant, stepping down on the short axis requires two checks to be contiguous
; 403  : 	bool oddQuadrant = stepX != stepY;

	cmp	ecx, DWORD PTR _stepY$[esp+60]
	mov	DWORD PTR _dy$[esp+56], eax
	setne	BYTE PTR _oddQuadrant$[esp+60]

; 404  : 	// Is the line going to go such that it travels through the centers of the hexes?
; 405  : 	// If so, we don't have to worry about testing to see if we can look around blocked hexes.
; 406  : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 407  : 	bool straightThrough = dx == 0 || dy == 0 || (dx == dy && oddQuadrant);
; 408  : #else
; 409  : 	bool straightThrough = dx == 0 || dy == 0;

	xor	ebp, ebp
	mov	DWORD PTR _dx$[esp+56], edx
	cmp	edx, ebp
	je	SHORT $LN53@CanSeeDisp@2
	mov	BYTE PTR _straightThrough$[esp+60], 0
	cmp	eax, ebp
	jne	SHORT $LN54@CanSeeDisp@2
$LN53@CanSeeDisp@2:
	mov	BYTE PTR _straightThrough$[esp+60], 1
$LN54@CanSeeDisp@2:

; 410  : #endif
; 411  : 
; 412  : 	// Start from the next cell after the source plot
; 413  : 	int lastDX = currentDX;

	mov	DWORD PTR _lastDX$[esp+60], ebp

; 414  : 	int lastDY = currentDY;

	mov	DWORD PTR _lastDY$[esp+60], ebp

; 415  : 	int blockedDirection = 0;

	xor	ebp, ebp

; 416  : 
; 417  : 	// If dx is greater than dy, scan along the x axis, adjusting the Y as needed
; 418  : 	if (dx > dy) 

	cmp	eax, edx
	jge	$LN77@CanSeeDisp@2

; 419  : 	{
; 420  : 		int shortAxisStepFactor = (dx >> 1); 

	sar	edx, 1
	mov	DWORD PTR _shortAxisStepFactor$218237[esp+60], edx

; 421  : 		while (currentDX != originalDX) 

	cmp	DWORD PTR _originalDX$[esp+60], esi
	je	$LN68@CanSeeDisp@2
	mov	edx, DWORD PTR _startX$[esp+56]
	mov	DWORD PTR tv562[esp+60], edx
	mov	edx, DWORD PTR _startY$[esp+56]
	mov	DWORD PTR tv564[esp+60], edx
	jmp	SHORT $LN45@CanSeeDisp@2
$LL71@CanSeeDisp@2:

; 419  : 	{
; 420  : 		int shortAxisStepFactor = (dx >> 1); 

	mov	eax, DWORD PTR _dy$[esp+56]
	mov	ecx, DWORD PTR _stepX$[esp+60]
$LN45@CanSeeDisp@2:

; 422  : 		{
; 423  : 			shortAxisStepFactor += dy;

	mov	edx, DWORD PTR _shortAxisStepFactor$218237[esp+60]

; 424  : 
; 425  : 			if (shortAxisStepFactor >= dx) 
; 426  : 			{
; 427  : 				shortAxisStepFactor -= dx;
; 428  : 
; 429  : 				if (oddQuadrant)
; 430  : 				{
; 431  : 					currentDX += stepX;

	add	DWORD PTR tv562[esp+60], ecx
	add	edx, eax
	mov	eax, DWORD PTR _dx$[esp+56]
	add	esi, ecx
	cmp	edx, eax
	mov	DWORD PTR _shortAxisStepFactor$218237[esp+60], edx
	jl	$LN32@CanSeeDisp@2
	sub	DWORD PTR _shortAxisStepFactor$218237[esp+60], eax
	cmp	BYTE PTR _oddQuadrant$[esp+60], 0

; 432  : 					currentDY += stepY;
; 433  : 				}
; 434  : 				else

	jne	$LN79@CanSeeDisp@2

; 435  : 				{
; 436  : 					currentDX += stepX;
; 437  : 
; 438  : 					// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 439  : 					if (bBlocked)

	test	bl, bl
	je	SHORT $LN73@CanSeeDisp@2

; 440  : 					{
; 441  : 						if (!straightThrough)

	cmp	BYTE PTR _straightThrough$[esp+60], 0
	jne	$LN61@CanSeeDisp@2

; 442  : 						{
; 443  : 							CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	eax, DWORD PTR _ms_LookBackY[ebp*4]
	mov	ecx, DWORD PTR _ms_LookBackX[ebp*4]
	mov	edx, DWORD PTR _kMap$[esp+60]
	add	eax, edi
	add	eax, DWORD PTR _startY$[esp+56]
	add	ecx, esi
	add	ecx, DWORD PTR _startX$[esp+56]
	push	eax
	push	ecx
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 444  : 							if(passThroughPlot)

	test	eax, eax
	je	SHORT $LN38@CanSeeDisp@2

; 445  : 							{
; 446  : 								TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 447  : 								bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	setl	bl
$LN38@CanSeeDisp@2:

; 448  : 							}
; 449  : 
; 450  : 							if (bBlocked)

	test	bl, bl
	jne	$LN61@CanSeeDisp@2
$LN73@CanSeeDisp@2:

; 452  : 						}
; 453  : 						else
; 454  : 							return false;
; 455  : 					}
; 456  : 
; 457  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 458  : 					if (currentDX == originalDX && currentDY == originalDY)

	cmp	esi, DWORD PTR _originalDX$[esp+60]
	jne	SHORT $LN35@CanSeeDisp@2
	cmp	edi, DWORD PTR _originalDY$[esp+60]
	je	$LN68@CanSeeDisp@2
$LN35@CanSeeDisp@2:

; 459  : 						break;	
; 460  : 
; 461  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	eax, DWORD PTR tv564[esp+60]
	mov	ecx, DWORD PTR tv562[esp+60]
	mov	edx, DWORD PTR _kMap$[esp+60]
	push	eax
	push	ecx
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 462  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 463  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN33@CanSeeDisp@2
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	jge	SHORT $LN34@CanSeeDisp@2
$LN33@CanSeeDisp@2:

; 464  : 					{
; 465  : 						bBlocked = true;
; 466  : 						blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, esi
	sub	eax, DWORD PTR _lastDX$[esp+60]
	mov	bl, 1
	lea	eax, DWORD PTR [eax+eax*2]
	sub	eax, DWORD PTR _lastDY$[esp+60]
	add	eax, edi
	mov	ebp, DWORD PTR _ms_HexDirection[eax*4+16]
$LN34@CanSeeDisp@2:

; 467  : 					}
; 468  : 
; 469  : 					lastDX = currentDX; lastDY = currentDY;

	mov	DWORD PTR _lastDX$[esp+60], esi
	mov	DWORD PTR _lastDY$[esp+60], edi
$LN79@CanSeeDisp@2:

; 470  : 
; 471  : 					currentDY += stepY;

	mov	eax, DWORD PTR _stepY$[esp+60]
	add	edi, eax
	add	DWORD PTR tv564[esp+60], eax
$LN32@CanSeeDisp@2:

; 472  : 				}
; 473  : 			}
; 474  : 			else
; 475  : 				currentDX += stepX;
; 476  : 
; 477  : 			// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 478  : 			if (bBlocked)

	test	bl, bl
	je	SHORT $LN28@CanSeeDisp@2

; 479  : 			{
; 480  : 				if (!straightThrough)	// If going along a single axis, we are looking directly down the middle of a hex so there is nothing to look around.

	cmp	BYTE PTR _straightThrough$[esp+60], 0
	jne	$LN61@CanSeeDisp@2

; 481  : 				{
; 482  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	ecx, DWORD PTR _ms_LookBackY[ebp*4]
	mov	edx, DWORD PTR _ms_LookBackX[ebp*4]
	mov	eax, DWORD PTR _kMap$[esp+60]
	add	ecx, edi
	add	ecx, DWORD PTR _startY$[esp+56]
	add	edx, esi
	add	edx, DWORD PTR _startX$[esp+56]
	push	ecx
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 483  : 					if(passThroughPlot)

	test	eax, eax
	je	SHORT $LN29@CanSeeDisp@2

; 484  : 					{
; 485  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 486  : 						bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	setl	bl
$LN29@CanSeeDisp@2:

; 487  : 					}
; 488  : 
; 489  : 					if (bBlocked)

	test	bl, bl
	jne	SHORT $LN61@CanSeeDisp@2
$LN28@CanSeeDisp@2:

; 490  : 						return false;
; 491  : 				}
; 492  : 				else
; 493  : 					return false;
; 494  : 			}
; 495  : 
; 496  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 497  : 			if (currentDX == originalDX && currentDY == originalDY)

	cmp	esi, DWORD PTR _originalDX$[esp+60]
	jne	SHORT $LN26@CanSeeDisp@2
	cmp	edi, DWORD PTR _originalDY$[esp+60]
	je	$LN68@CanSeeDisp@2
$LN26@CanSeeDisp@2:

; 498  : 				break;	
; 499  : 
; 500  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	ecx, DWORD PTR tv564[esp+60]
	mov	edx, DWORD PTR tv562[esp+60]
	mov	eax, DWORD PTR _kMap$[esp+60]
	push	ecx
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 501  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 502  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN24@CanSeeDisp@2
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	jge	SHORT $LN25@CanSeeDisp@2
$LN24@CanSeeDisp@2:

; 503  : 			{
; 504  : 				bBlocked = true;
; 505  : 				blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, esi
	sub	eax, DWORD PTR _lastDX$[esp+60]
	mov	bl, 1
	lea	ecx, DWORD PTR [eax+eax*2]
	sub	ecx, DWORD PTR _lastDY$[esp+60]
	add	ecx, edi
	mov	ebp, DWORD PTR _ms_HexDirection[ecx*4+16]
$LN25@CanSeeDisp@2:

; 506  : 			}
; 507  : 
; 508  : 			lastDX = currentDX; lastDY = currentDY;

	mov	DWORD PTR _lastDX$[esp+60], esi
	mov	DWORD PTR _lastDY$[esp+60], edi
	cmp	esi, DWORD PTR _originalDX$[esp+60]
	jne	$LL71@CanSeeDisp@2
	pop	edi
	pop	esi
	pop	ebp

; 608  : 		}
; 609  : 	}
; 610  : 
; 611  : 	return true;

	mov	al, 1
	pop	ebx

; 612  : }

	add	esp, 44					; 0000002cH
	ret	0
$LN61@CanSeeDisp@2:
	pop	edi
	pop	esi
	pop	ebp

; 451  : 								return false;

	xor	al, al
	pop	ebx

; 612  : }

	add	esp, 44					; 0000002cH
	ret	0
$LN77@CanSeeDisp@2:

; 509  : 		}
; 510  : 	} 
; 511  : 	else 
; 512  : 	{
; 513  : 		// Y axis runs are longer, scan along them and adjust the X as needed.
; 514  : 		// The short axis step is primed slightly differently if the step ratio is 2:1
; 515  : 		// so that the initial step goes in a more favorable direction
; 516  : 		int shortAxisStepFactor = (dy!=dx && dx != 0 && (dy>>1) == dx)?((dy >> 1) - dx):(dy >> 1);

	je	SHORT $LN55@CanSeeDisp@2
	test	edx, edx
	je	SHORT $LN55@CanSeeDisp@2
	sar	eax, 1
	cmp	eax, edx
	jne	SHORT $LN75@CanSeeDisp@2
	sub	eax, edx
	jmp	SHORT $LN78@CanSeeDisp@2
$LN75@CanSeeDisp@2:
	mov	eax, DWORD PTR _dy$[esp+56]
$LN55@CanSeeDisp@2:
	sar	eax, 1
$LN78@CanSeeDisp@2:
	mov	DWORD PTR _shortAxisStepFactor$218266[esp+60], eax

; 517  : 		//int fraction = (dy >> 1);
; 518  : 		while (currentDY != originalDY) 

	cmp	DWORD PTR _originalDY$[esp+60], esi
	je	$LN68@CanSeeDisp@2
	mov	eax, DWORD PTR _startX$[esp+56]
	mov	DWORD PTR tv572[esp+60], eax
	mov	eax, DWORD PTR _startY$[esp+56]
	mov	DWORD PTR tv574[esp+60], eax
	jmp	SHORT $LN22@CanSeeDisp@2
	npad	4
$LL72@CanSeeDisp@2:
	mov	edx, DWORD PTR _dx$[esp+56]
	mov	ecx, DWORD PTR _stepX$[esp+60]
$LN22@CanSeeDisp@2:

; 519  : 		{
; 520  : 			shortAxisStepFactor += dx;

	add	DWORD PTR _shortAxisStepFactor$218266[esp+60], edx

; 521  : 
; 522  : 			if (shortAxisStepFactor >= dy) 

	mov	eax, DWORD PTR _dy$[esp+56]
	cmp	DWORD PTR _shortAxisStepFactor$218266[esp+60], eax
	jl	$LN20@CanSeeDisp@2

; 523  : 			{
; 524  : 				shortAxisStepFactor -= dy;

	sub	DWORD PTR _shortAxisStepFactor$218266[esp+60], eax

; 525  : 
; 526  : 				if (oddQuadrant)
; 527  : 				{
; 528  : 					// A change in the X and Y axis will yield a contiguous line
; 529  : 					currentDX += stepX;

	add	DWORD PTR tv572[esp+60], ecx
	add	esi, ecx
	cmp	BYTE PTR _oddQuadrant$[esp+60], 0

; 530  : 					currentDY += stepY;
; 531  : 				}
; 532  : 				else

	jne	$LN20@CanSeeDisp@2

; 533  : 				{
; 534  : 					// Adjust just the X axis, then check so that the line is contiguous.
; 535  : 					currentDX += stepX;
; 536  : 
; 537  : 					// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 538  : 					if (bBlocked)

	test	bl, bl
	je	SHORT $LN76@CanSeeDisp@2

; 539  : 					{
; 540  : 						if (!straightThrough)	// If going along a single axis, we are looking directly down the middle of a hex so there is nothing to look around.

	cmp	BYTE PTR _straightThrough$[esp+60], 0
	jne	SHORT $LN61@CanSeeDisp@2

; 541  : 						{
; 542  : 							CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	ecx, DWORD PTR _ms_LookBackY[ebp*4]
	mov	edx, DWORD PTR _ms_LookBackX[ebp*4]
	mov	eax, DWORD PTR _kMap$[esp+60]
	add	ecx, edi
	add	ecx, DWORD PTR _startY$[esp+56]
	add	edx, esi
	add	edx, DWORD PTR _startX$[esp+56]
	push	ecx
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 543  : 							if(passThroughPlot)

	test	eax, eax
	je	SHORT $LN15@CanSeeDisp@2

; 544  : 							{
; 545  : 								TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 546  : 								bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	setl	bl
$LN15@CanSeeDisp@2:

; 547  : 							}
; 548  : 
; 549  : 							if (bBlocked)

	test	bl, bl
	jne	$LN61@CanSeeDisp@2
$LN76@CanSeeDisp@2:

; 550  : 								return false;
; 551  : 						}
; 552  : 						else
; 553  : 							return false;
; 554  : 					}
; 555  : 
; 556  : 					// Don't test the destination, we only want to test the plots between the start and the destination
; 557  : 					if (currentDX == originalDX && currentDY == originalDY)

	cmp	esi, DWORD PTR _originalDX$[esp+60]
	jne	SHORT $LN12@CanSeeDisp@2
	cmp	edi, DWORD PTR _originalDY$[esp+60]
	je	$LN68@CanSeeDisp@2
$LN12@CanSeeDisp@2:

; 558  : 						break;	
; 559  : 
; 560  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	ecx, DWORD PTR tv574[esp+60]
	mov	edx, DWORD PTR tv572[esp+60]
	mov	eax, DWORD PTR _kMap$[esp+60]
	push	ecx
	push	edx
	push	eax
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 561  : 					TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 562  : 					if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN10@CanSeeDisp@2
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	jge	SHORT $LN11@CanSeeDisp@2
$LN10@CanSeeDisp@2:

; 563  : 					{
; 564  : 						bBlocked = true;
; 565  : 						blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, esi
	sub	eax, DWORD PTR _lastDX$[esp+60]
	mov	bl, 1
	lea	ecx, DWORD PTR [eax+eax*2]
	sub	ecx, DWORD PTR _lastDY$[esp+60]
	add	ecx, edi
	mov	ebp, DWORD PTR _ms_HexDirection[ecx*4+16]
$LN11@CanSeeDisp@2:

; 566  : 					}
; 567  : 
; 568  : 					lastDX = currentDX; lastDY = currentDY;

	mov	DWORD PTR _lastDX$[esp+60], esi
	mov	DWORD PTR _lastDY$[esp+60], edi
$LN20@CanSeeDisp@2:

; 569  : 
; 570  : 					currentDY += stepY;
; 571  : 				}
; 572  : 			}
; 573  : 			else
; 574  : 				currentDY += stepY;

	mov	eax, DWORD PTR _stepY$[esp+60]
	add	DWORD PTR tv574[esp+60], eax
	add	edi, eax

; 575  : 
; 576  : 			// If we were blocked by the previous hex, see if we are able to look around the adjacent one if we split between them
; 577  : 			if (bBlocked)

	test	bl, bl
	je	SHORT $LN5@CanSeeDisp@2

; 578  : 			{
; 579  : 				if (!straightThrough)	// If going along a single axis, we are looking directly down the middle of a hex so there is nothing to look around.

	cmp	BYTE PTR _straightThrough$[esp+60], 0
	jne	$LN61@CanSeeDisp@2

; 580  : 				{
; 581  : 					CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX + ms_LookBackX[blockedDirection], startY + currentDY + ms_LookBackY[blockedDirection]);

	mov	edx, DWORD PTR _ms_LookBackY[ebp*4]
	mov	eax, DWORD PTR _ms_LookBackX[ebp*4]
	mov	ecx, DWORD PTR _kMap$[esp+60]
	add	edx, edi
	add	edx, DWORD PTR _startY$[esp+56]
	add	eax, esi
	add	eax, DWORD PTR _startX$[esp+56]
	push	edx
	push	eax
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 582  : 					if(passThroughPlot)

	test	eax, eax
	je	SHORT $LN6@CanSeeDisp@2

; 583  : 					{
; 584  : 						TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 585  : 						bBlocked = (fromLevel < passThroughPlot->seeThroughLevel());

	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	setl	bl
$LN6@CanSeeDisp@2:

; 586  : 					}
; 587  : 
; 588  : 					if (bBlocked)

	test	bl, bl
	jne	$LN61@CanSeeDisp@2
$LN5@CanSeeDisp@2:

; 589  : 						return false;
; 590  : 				}
; 591  : 				else
; 592  : 					return false;
; 593  : 			}
; 594  : 
; 595  : 			// Don't test the destination, we only want to test the plots between the start and the destination
; 596  : 			if (currentDX == originalDX && currentDY == originalDY)

	cmp	esi, DWORD PTR _originalDX$[esp+60]
	jne	SHORT $LN3@CanSeeDisp@2
	cmp	edi, DWORD PTR _originalDY$[esp+60]
	je	SHORT $LN68@CanSeeDisp@2
$LN3@CanSeeDisp@2:

; 597  : 				break;	
; 598  : 
; 599  : 			CvPlot* passThroughPlot = PlotFromHex(kMap, startX + currentDX, startY + currentDY);

	mov	edx, DWORD PTR tv574[esp+60]
	mov	eax, DWORD PTR tv572[esp+60]
	mov	ecx, DWORD PTR _kMap$[esp+60]
	push	edx
	push	eax
	push	ecx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 600  : 			TRACK_LAST_TARGET_PATH_ENTRY(passThroughPlot);
; 601  : 			if(!passThroughPlot || fromLevel < passThroughPlot->seeThroughLevel())

	test	eax, eax
	je	SHORT $LN1@CanSeeDisp@2
	push	1
	mov	ecx, eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	cmp	DWORD PTR _fromLevel$[esp+56], eax
	jge	SHORT $LN2@CanSeeDisp@2
$LN1@CanSeeDisp@2:

; 602  : 			{
; 603  : 				bBlocked = true;
; 604  : 				blockedDirection = ms_HexDirection[(currentDX - lastDX) + 1][(currentDY - lastDY) + 1];

	mov	eax, esi
	sub	eax, DWORD PTR _lastDX$[esp+60]
	mov	bl, 1
	lea	edx, DWORD PTR [eax+eax*2]
	sub	edx, DWORD PTR _lastDY$[esp+60]
	add	edx, edi
	mov	ebp, DWORD PTR _ms_HexDirection[edx*4+16]
$LN2@CanSeeDisp@2:

; 605  : 			}
; 606  : 
; 607  : 			lastDX = currentDX; lastDY = currentDY;

	mov	DWORD PTR _lastDX$[esp+60], esi
	mov	DWORD PTR _lastDY$[esp+60], edi
	cmp	edi, DWORD PTR _originalDY$[esp+60]
	jne	$LL72@CanSeeDisp@2
$LN68@CanSeeDisp@2:
	pop	edi
	pop	esi
	pop	ebp

; 608  : 		}
; 609  : 	}
; 610  : 
; 611  : 	return true;

	mov	al, 1
	pop	ebx

; 612  : }

	add	esp, 44					; 0000002cH
	ret	0
?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z ENDP		; CanSeeDisplacementPlot_Loose
_TEXT	ENDS
PUBLIC	?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z ; CvTargeting::CanSeeDisplacementPlot
; Function compile flags: /Ogtpy
;	COMDAT ?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z
_TEXT	SEGMENT
_startX$ = 8						; size = 4
_startY$ = 12						; size = 4
_dx$ = 16						; size = 4
_dy$ = 20						; size = 4
_fromLevel$ = 24					; size = 4
?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z PROC	; CvTargeting::CanSeeDisplacementPlot, COMDAT

; 628  : {

	push	ebx

; 629  : 	CLEAR_TARGET_PATH_DEBUG;
; 630  : 
; 631  : 	// convert the start coord to hex-space coordinates
; 632  : 	// No need to convert the Y coord, it is the same in both systems
; 633  : 	startX = xToHexspaceX(startX, startY);

	mov	ebx, DWORD PTR _startY$[esp]
	push	ebp
	push	esi
	push	edi
	test	ebx, ebx
	jl	SHORT $LN9@CanSeeDisp@3
	mov	eax, ebx
	jmp	SHORT $LN27@CanSeeDisp@3
$LN9@CanSeeDisp@3:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN27@CanSeeDisp@3:
	mov	ebp, DWORD PTR _startX$[esp+12]

; 634  : 
; 635  : 	CvMap& kMap = GC.getMap();
; 636  : 	CvPlot* pPlot = PlotFromHex(kMap, startX + dx, startY + dy);

	mov	esi, DWORD PTR _dy$[esp+12]
	mov	edi, DWORD PTR _dx$[esp+12]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	sar	eax, 1
	sub	ebp, eax
	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	lea	ecx, DWORD PTR [edi+ebp]
	push	ecx
	push	edx
	call	?PlotFromHex@@YAPAVCvPlot@@AAVCvMap@@HH@Z ; PlotFromHex
	add	esp, 12					; 0000000cH

; 637  : 	if(pPlot != NULL)

	test	eax, eax
	je	SHORT $LN1@CanSeeDisp@3

; 638  : 	{
; 639  : 		int iHexDistanceBetweenPlots = hexDistance(dx, dy);

	xor	eax, eax
	test	edi, edi
	setge	al
	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	eax, ecx
	mov	ecx, edi
	jne	SHORT $LN14@CanSeeDisp@3
	test	edi, edi
	jge	SHORT $LN18@CanSeeDisp@3
	neg	ecx
$LN18@CanSeeDisp@3:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN20@CanSeeDisp@3
	neg	eax
$LN20@CanSeeDisp@3:
	add	eax, ecx
	jmp	SHORT $LN25@CanSeeDisp@3
$LN14@CanSeeDisp@3:
	test	edi, edi
	jge	SHORT $LN22@CanSeeDisp@3
	neg	ecx
$LN22@CanSeeDisp@3:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN24@CanSeeDisp@3
	neg	eax
$LN24@CanSeeDisp@3:
	cmp	ecx, eax
	jl	SHORT $LN25@CanSeeDisp@3
	mov	eax, ecx
$LN25@CanSeeDisp@3:

; 640  : 		// assume that we can always see our plot and the plot next door
; 641  : 		if(iHexDistanceBetweenPlots <= 1)

	cmp	eax, 1
	jg	SHORT $LN3@CanSeeDisp@3
	pop	edi
	pop	esi
	pop	ebp

; 642  : 			return true;

	mov	al, 1
	pop	ebx

; 653  : }

	ret	0
$LN3@CanSeeDisp@3:

; 643  : 
; 644  : 		// If over STRICT_LOOSE_CUTOFF away, any blockage past the STRICT_LOOSE_CUTOFF will result in not being able to target.
; 645  : 		if (iHexDistanceBetweenPlots > STRICT_LOOSE_CUTOFF /*&& GC.getGame().isOption("STRICT_RANGE_TARGETING")*/)

	cmp	eax, 2
	jle	SHORT $LN2@CanSeeDisp@3

; 646  : 			return CanSeeDisplacementPlot_Strict(startX, startY, dx, dy, fromLevel);

	mov	edx, DWORD PTR _fromLevel$[esp+12]
	push	edx
	push	esi
	push	edi
	push	ebx
	push	ebp
	call	?CanSeeDisplacementPlot_Strict@@YA_NHHHHH@Z ; CanSeeDisplacementPlot_Strict
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 653  : }

	ret	0
$LN2@CanSeeDisp@3:

; 647  : 		else
; 648  : 			return CanSeeDisplacementPlot_Loose(startX, startY, dx, dy, fromLevel);

	mov	eax, DWORD PTR _fromLevel$[esp+12]
	push	eax
	push	esi
	push	edi
	push	ebx
	push	ebp
	call	?CanSeeDisplacementPlot_Loose@@YA_NHHHHH@Z ; CanSeeDisplacementPlot_Loose
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 653  : }

	ret	0
$LN1@CanSeeDisp@3:
	pop	edi
	pop	esi
	pop	ebp

; 649  : 
; 650  : 	}
; 651  : 
; 652  : 	return false;

	xor	al, al
	pop	ebx

; 653  : }

	ret	0
?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z ENDP	; CvTargeting::CanSeeDisplacementPlot
_TEXT	ENDS
END
