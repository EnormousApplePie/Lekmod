; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvEspionageClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?g_eSortPlayer@@3W4PlayerTypes@@A		; g_eSortPlayer
CONST	SEGMENT
$SG222790 DB	'Randomizing m_aiSpyListNameOrder list', 00H
$SG223399 DB	00H
$SG223911 DB	00H
$SG222827 DB	'GAMEOPTION_NO_ESPIONAGE', 00H
$SG222841 DB	'TXT_KEY_NOTIFICATION_SPY_CREATED', 00H
$SG224235 DB	00H
$SG224237 DB	00H
	ORG $+1
$SG222844 DB	'TXT_KEY_NOTIFICATION_SUMMARY_SPY_CREATED', 00H
	ORG $+3
$SG222847 DB	'New Spy, %d,', 00H
	ORG $+3
$SG222896 DB	'TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH_S', 00H
	ORG $+1
$SG222905 DB	'TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH', 00H
	ORG $+3
$SG222912 DB	'Re-eval: can''t steal research, %d,', 00H
	ORG $+1
$SG222919 DB	'Re-eval: potential too low, %d,', 00H
$SG222933 DB	'TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH_S', 00H
	ORG $+1
$SG222924 DB	'Re-eval: m_aaPlayerStealableTechList[eCityOwner].size() '
	DB	'== 0, %d,', 00H
	ORG $+2
$SG222937 DB	'TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH', 00H
	ORG $+3
$SG222946 DB	'Random roll for the result of a spy mission with a count'
	DB	'erspy in the city', 00H
	ORG $+2
$SG222955 DB	'CIVILIZATION_RUSSIA', 00H
$SG222956 DB	'CIVILIZATION_ENGLAND', 00H
	ORG $+3
$SG222961 DB	'Random roll for the result of a spying mission without a'
	DB	' counterspy in the city', 00H
$SG222977 DB	'TXT_KEY_NOTIFICATION_SPY_WAS_KILLED_S', 00H
	ORG $+2
$SG222981 DB	'TXT_KEY_NOTIFICATION_SPY_WAS_KILLED', 00H
$SG222995 DB	'Killed, %d,', 00H
$SG222997 DB	',', 00H
	ORG $+2
$SG222998 DB	',', 00H
	ORG $+2
$SG222999 DB	',', 00H
	ORG $+2
$SG223000 DB	',', 00H
	ORG $+2
$SG223002 DB	',', 00H
	ORG $+2
$SG223003 DB	'Killed', 00H
	ORG $+1
$SG223007 DB	'Re-eval: spy completed mission, %d,', 00H
$SG223021 DB	'TXT_KEY_NOTIFICATION_SPY_STEAL_TECH_S', 00H
	ORG $+2
$SG223024 DB	'TXT_KEY_NOTIFICATION_SPY_STEAL_TECH', 00H
$SG223033 DB	'Stealing tech, %d,', 00H
	ORG $+1
$SG223035 DB	',', 00H
	ORG $+2
$SG223036 DB	',', 00H
	ORG $+2
$SG223037 DB	',', 00H
	ORG $+2
$SG223038 DB	',', 00H
	ORG $+2
$SG223040 DB	',', 00H
	ORG $+2
$SG223046 DB	'Undetected', 00H
	ORG $+1
$SG223048 DB	'Detected', 00H
	ORG $+3
$SG223050 DB	'Identified', 00H
	ORG $+1
$SG223064 DB	'Re-eval: spy killed, %d,', 00H
	ORG $+3
$SG223070 DB	'TXT_KEY_NOTIFICATION_SPY_REVIVED_S', 00H
	ORG $+1
$SG223073 DB	'TXT_KEY_NOTIFICATION_SPY_REVIVED', 00H
	ORG $+3
$SG223078 DB	'Respawned spy, %d,', 00H
	ORG $+1
$SG223111 DB	'Randomizing aiMajorCivIndex list within UncoverIntrigue', 00H
$SG223250 DB	'Moving spy, %d,', 00H
$SG223252 DB	',', 00H
	ORG $+2
$SG223254 DB	',', 00H
	ORG $+2
$SG223257 DB	'Unassigned', 00H
	ORG $+1
$SG223258 DB	',', 00H
	ORG $+2
$SG223259 DB	',', 00H
	ORG $+2
$SG223261 DB	',', 00H
	ORG $+2
$SG223264 DB	'Unassigned', 00H
	ORG $+1
$SG223265 DB	',', 00H
	ORG $+2
$SG223266 DB	',', 00H
	ORG $+2
$SG223268 DB	'Diplomat', 00H
	ORG $+3
$SG223269 DB	',', 00H
	ORG $+2
$SG223307 DB	'TXT_KEY_NOTIFICATION_SPY_PROMOTED', 00H
	ORG $+2
$SG223310 DB	'TXT_KEY_NOTIFICATION_SUMMARY_SPY_PROMOTED', 00H
	ORG $+2
$SG223394 DB	'TXT_KEY_SPY_RANK_0', 00H
	ORG $+1
$SG223396 DB	'TXT_KEY_SPY_RANK_1', 00H
	ORG $+1
$SG223398 DB	'TXT_KEY_SPY_RANK_2', 00H
	ORG $+1
$SG223553 DB	'Re-eval: attempting coup, %d,', 00H
	ORG $+2
$SG223557 DB	'Roll for the result of an attempted coup', 00H
	ORG $+3
$SG223594 DB	'TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_SUCCESS_S', 00H
	ORG $+2
$SG223598 DB	'TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_SUCCESS', 00H
$SG223604 DB	'TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_FAILURE_S', 00H
	ORG $+2
$SG223608 DB	'TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_FAILURE', 00H
$SG223619 DB	'TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_SUCCESS_S', 00H
	ORG $+2
$SG223622 DB	'TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_SUCCESS', 00H
$SG223629 DB	'TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_FAILURE_S', 00H
	ORG $+2
$SG223632 DB	'TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_FAILURE', 00H
$SG223808 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_WO_TECH_S', 00H
$SG223812 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_WO_TECH_W_'
	DB	'TIP', 00H
$SG223815 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_WO_TECH', 00H
	ORG $+2
$SG223820 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_WO_TECH_'
	DB	'S', 00H
	ORG $+2
$SG223825 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_WO_TECH_'
	DB	'W_TIP', 00H
	ORG $+2
$SG223828 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_WO_TECH', 00H
$SG223836 DB	'TXT_KEY_NOTIFICATION_KILLED_A_SPY_S', 00H
$SG223840 DB	'TXT_KEY_NOTIFICATION_KILLED_A_SPY', 00H
	ORG $+2
$SG223855 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_S', 00H
$SG223860 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_W_TIP', 00H
$SG223863 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED', 00H
	ORG $+2
$SG223869 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_S', 00H
	ORG $+2
$SG223875 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_W_TIP', 00H
	ORG $+2
$SG223878 DB	'TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED', 00H
$SG223915 DB	'TXT_KEY_SPY_FULL_NAME', 00H
	ORG $+2
$SG223930 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_YOU_S', 00H
	ORG $+3
$SG223936 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_YOU', 00H
	ORG $+1
$SG223948 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_UNKNOWN_S'
	DB	00H
	ORG $+3
$SG223954 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_UNKNOWN', 00H
	ORG $+1
$SG223965 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_KNOWN_S', 00H
	ORG $+1
$SG223975 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_KNOWN', 00H
	ORG $+3
$SG223992 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_ARMY_S', 00H
	ORG $+2
$SG223998 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_ARMY', 00H
$SG224009 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_AMPHIBIOUS_ARMY_S'
	DB	00H
	ORG $+3
$SG224015 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_AMPHIBIOUS_ARMY', 00H
	ORG $+5
$SG224029 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'YOU_CITY_KNOWN_S', 00H
	ORG $+7
$SG224036 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'YOU_CITY_KNOWN', 00H
	ORG $+1
$SG224043 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'YOU_CITY_UNKNOWN_S', 00H
	ORG $+5
$SG224049 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'YOU_CITY_UNKNOWN', 00H
	ORG $+7
$SG224057 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'KNOWN_CITY_KNOWN_S', 00H
	ORG $+5
$SG224064 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'KNOWN_CITY_KNOWN', 00H
	ORG $+7
$SG224072 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'KNOWN_CITY_UNKNOWN_S', 00H
	ORG $+3
$SG224082 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'KNOWN_CITY_UNKNOWN', 00H
	ORG $+5
$SG224090 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'SOMEONE_S', 00H
	ORG $+6
$SG224092 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'SOMEONE', 00H
$SG224095 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'UNKNOWN_S', 00H
	ORG $+6
$SG224097 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_'
	DB	'UNKNOWN', 00H
$SG224112 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_YOU_CITY_KNOWN_S', 00H
	ORG $+5
$SG224119 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_YOU_CITY_KNOWN', 00H
	ORG $+7
$SG224126 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_YOU_CITY_UNKNOWN_S', 00H
	ORG $+3
$SG224132 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_YOU_CITY_UNKNOWN', 00H
	ORG $+5
$SG224140 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_KNOWN_CITY_KNOWN_S', 00H
	ORG $+3
$SG224147 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_KNOWN_CITY_KNOWN', 00H
	ORG $+5
$SG224155 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_KNOWN_CITY_UNKNOWN_S', 00H
	ORG $+1
$SG224165 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_KNOWN_CITY_UNKNOWN', 00H
	ORG $+3
$SG224173 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_SOMEONE_S', 00H
$SG224191 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_CONSTRUCT_WONDER_S', 00H
	ORG $+3
$SG224175 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_SOMEONE', 00H
	ORG $+6
$SG224178 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_UNKNOWN_S', 00H
$SG224257 DB	'TXT_KEY_INTRIGUE_PLOTTING_AGAINST_UNKNOWN', 00H
	ORG $+2
$SG224180 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINS'
	DB	'T_UNKNOWN', 00H
	ORG $+2
$SG224207 DB	'TXT_KEY_NOTIFICATION_INTRIGUE_CONSTRUCT_WONDER', 00H
	ORG $+1
$SG224249 DB	'TXT_KEY_INTRIGUE_PLOTTING_AGAINST_YOU', 00H
	ORG $+2
$SG224264 DB	'TXT_KEY_INTRIGUE_PLOTTING_AGAINST_KNOWN', 00H
$SG224275 DB	'TXT_KEY_INTRIGUE_BUILDING_ARMY', 00H
	ORG $+1
$SG224282 DB	'TXT_KEY_INTRIGUE_BUILDING_AMPHIBIOUS_ARMY', 00H
	ORG $+2
$SG224291 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_KNOW'
	DB	'N', 00H
	ORG $+2
$SG224299 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_UNKN'
	DB	'OWN', 00H
$SG224308 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_KN'
	DB	'OWN', 00H
$SG224317 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_UN'
	DB	'KNOWN', 00H
	ORG $+2
$SG224329 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_SOMEONE', 00H
	ORG $+1
$SG224332 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_UNKNOWN', 00H
	ORG $+1
$SG224341 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_KN'
	DB	'OWN', 00H
$SG224349 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_UN'
	DB	'KNOWN', 00H
	ORG $+2
$SG224358 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_'
	DB	'KNOWN', 00H
	ORG $+2
$SG224367 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_'
	DB	'UNKNOWN', 00H
$SG224379 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_SOMEONE', 00H
	ORG $+3
$SG224382 DB	'TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_UNKNOWN', 00H
	ORG $+3
$SG224390 DB	'TXT_KEY_INTRIGUE_CONSTRUCT_WONDER', 00H
	ORG $+2
$SG224393 DB	'TXT_KEY_INTRIGUE_CONSTRUCT_WONDER_WO_CITY', 00H
	ORG $+2
$SG224642 DB	'EspionageLog.csv', 00H
	ORG $+3
$SG224652 DB	'%03d,', 00H
	ORG $+2
$SG224653 DB	',', 00H
	ORG $+2
$SG225068 DB	'Re-eval: UN constructed/reassign, %d,', 00H
	ORG $+2
$SG225522 DB	'AI no more tech to steal,', 00H
	ORG $+2
$SG225523 DB	',', 00H
	ORG $+2
$SG225524 DB	',', 00H
	ORG $+2
$SG225525 DB	',', 00H
	ORG $+2
$SG225543 DB	'Random roll to see if we should attempt a coup', 00H
	ORG $+1
$SG226301 DB	'FLAVOR_GROWTH', 00H
	ORG $+2
$SG226436 DB	'Re-eval: assigned to promise player, %d,', 00H
	ORG $+3
$SG226453 DB	'Re-eval: unassigned spy, %d,', 00H
	ORG $+3
$SG226470 DB	'Re-eval: defensive spy, %d,', 00H
$SG226486 DB	'Re-eval: diplomat spy, %d,', 00H
	ORG $+1
$SG92492 DB	'b103d2e0-3aab-40d7-a2f3-375d2eabfcaf', 00H
	ORG $+3
_CIV5_XP1_SCENARIO3_MODID DD FLAT:$SG92492
CONST	ENDS
_DATA	SEGMENT
?g_eSortPlayer@@3W4PlayerTypes@@A DD 0ffffffffH		; g_eSortPlayer
_DATA	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ ; CvMilitaryAI::GetArmyBeingBuilt
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmilitaryai.h
;	COMDAT ?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ
_TEXT	SEGMENT
?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ PROC ; CvMilitaryAI::GetArmyBeingBuilt, COMDAT
; _this$ = ecx

; 255  : 		return m_eArmyTypeBeingBuilt;

	mov	eax, DWORD PTR [ecx+44]

; 256  : 	};

	ret	0
?GetArmyBeingBuilt@CvMilitaryAI@@QBE?AW4ArmyType@@XZ ENDP ; CvMilitaryAI::GetArmyBeingBuilt
_TEXT	ENDS
PUBLIC	??0CvEspionageSpy@@QAE@XZ			; CvEspionageSpy::CvEspionageSpy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
;	COMDAT ??0CvEspionageSpy@@QAE@XZ
_TEXT	SEGMENT
??0CvEspionageSpy@@QAE@XZ PROC				; CvEspionageSpy::CvEspionageSpy, COMDAT
; _this$ = ecx

; 42   : {

	mov	eax, ecx
	or	ecx, -1
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+12], 3
	mov	DWORD PTR [eax+16], 9
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+24], cl
	mov	BYTE PTR [eax+25], 1

; 43   : }

	ret	0
??0CvEspionageSpy@@QAE@XZ ENDP				; CvEspionageSpy::CvEspionageSpy
_TEXT	ENDS
PUBLIC	?IsDisableTechSteal@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsDisableTechSteal
; Function compile flags: /Ogtpy
;	COMDAT ?IsDisableTechSteal@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDisableTechSteal@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsDisableTechSteal, COMDAT
; _this$ = ecx

; 100  : 	return m_bDisableTechSteal;

	mov	al, BYTE PTR [ecx+336]

; 101  : }

	ret	0
?IsDisableTechSteal@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsDisableTechSteal
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_ceilf
EXTRN	__imp__ceil:PROC
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv71 = 8						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 397  :         {return ((float)ceil((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv71[esp+4]
	add	esp, 8
	fld	DWORD PTR tv71[esp-4]
	ret	0
_ceilf	ENDP
_TEXT	ENDS
PUBLIC	_floorf
EXTRN	__imp__floor:PROC
; Function compile flags: /Ogtpy
;	COMDAT _floorf
_TEXT	SEGMENT
tv71 = 8						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 405  :         {return ((float)floor((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	fstp	DWORD PTR tv71[esp+4]
	add	esp, 8
	fld	DWORD PTR tv71[esp-4]
	ret	0
_floorf	ENDP
_TEXT	ENDS
PUBLIC	?ceil@@YAMM@Z					; ceil
; Function compile flags: /Ogtpy
;	COMDAT ?ceil@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
$T232965 = 8						; size = 4
__X$ = 8						; size = 4
?ceil@@YAMM@Z PROC					; ceil, COMDAT

; 502  :         {return (ceilf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv73[esp+4]
	add	esp, 8
	fld	DWORD PTR tv73[esp-4]
	fstp	DWORD PTR $T232965[esp-4]
	fld	DWORD PTR $T232965[esp-4]
	ret	0
?ceil@@YAMM@Z ENDP					; ceil
_TEXT	ENDS
PUBLIC	?floor@@YAMM@Z					; floor
; Function compile flags: /Ogtpy
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
$T232972 = 8						; size = 4
__X$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 512  :         {return (floorf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	fstp	DWORD PTR tv73[esp+4]
	add	esp, 8
	fld	DWORD PTR tv73[esp-4]
	fstp	DWORD PTR $T232972[esp-4]
	fld	DWORD PTR $T232972[esp-4]
	ret	0
?floor@@YAMM@Z ENDP					; floor
_TEXT	ENDS
PUBLIC	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z	; CvPlayerEspionage::GetSpyRankName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
;	COMDAT ?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z
_TEXT	SEGMENT
_iRank$ = 8						; size = 4
?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z PROC	; CvPlayerEspionage::GetSpyRankName, COMDAT
; _this$ = ecx

; 1527 : 	switch(iRank)

	mov	eax, DWORD PTR _iRank$[esp-4]
	sub	eax, 0
	je	SHORT $LN3@GetSpyRank
	sub	eax, 1
	je	SHORT $LN2@GetSpyRank
	sub	eax, 1
	je	SHORT $LN1@GetSpyRank

; 1537 : 		break;
; 1538 : 	}
; 1539 : 
; 1540 : 	return "";

	mov	eax, OFFSET $SG223399

; 1541 : }

	ret	4
$LN1@GetSpyRank:

; 1534 : 		break;
; 1535 : 	case SPY_RANK_SPECIAL_AGENT:
; 1536 : 		return "TXT_KEY_SPY_RANK_2";

	mov	eax, OFFSET $SG223398

; 1541 : }

	ret	4
$LN2@GetSpyRank:

; 1531 : 		break;
; 1532 : 	case SPY_RANK_AGENT:
; 1533 : 		return "TXT_KEY_SPY_RANK_1";

	mov	eax, OFFSET $SG223396

; 1541 : }

	ret	4
$LN3@GetSpyRank:

; 1528 : 	{
; 1529 : 	case SPY_RANK_RECRUIT:
; 1530 : 		return "TXT_KEY_SPY_RANK_0";

	mov	eax, OFFSET $SG223394

; 1541 : }

	ret	4
?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ENDP	; CvPlayerEspionage::GetSpyRankName
_TEXT	ENDS
PUBLIC	??1CvCityEspionage@@QAE@XZ			; CvCityEspionage::~CvCityEspionage
; Function compile flags: /Ogtpy
;	COMDAT ??1CvCityEspionage@@QAE@XZ
_TEXT	SEGMENT
??1CvCityEspionage@@QAE@XZ PROC				; CvCityEspionage::~CvCityEspionage, COMDAT
; _this$ = ecx

; 3956 : }

	ret	0
??1CvCityEspionage@@QAE@XZ ENDP				; CvCityEspionage::~CvCityEspionage
_TEXT	ENDS
PUBLIC	??RScoreCityEntryHighEval@@QBE_NABUScoreCityEntry@@0@Z ; ScoreCityEntryHighEval::operator()
; Function compile flags: /Ogtpy
;	COMDAT ??RScoreCityEntryHighEval@@QBE_NABUScoreCityEntry@@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??RScoreCityEntryHighEval@@QBE_NABUScoreCityEntry@@0@Z PROC ; ScoreCityEntryHighEval::operator(), COMDAT
; _this$ = ecx

; 4956 : 		return a.m_iScore > b.m_iScore;

	mov	eax, DWORD PTR _a$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _b$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setg	al

; 4957 : 	}

	ret	8
??RScoreCityEntryHighEval@@QBE_NABUScoreCityEntry@@0@Z ENDP ; ScoreCityEntryHighEval::operator()
_TEXT	ENDS
PUBLIC	??RScoreCityEntryLowEval@@QBE_NABUScoreCityEntry@@0@Z ; ScoreCityEntryLowEval::operator()
; Function compile flags: /Ogtpy
;	COMDAT ??RScoreCityEntryLowEval@@QBE_NABUScoreCityEntry@@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??RScoreCityEntryLowEval@@QBE_NABUScoreCityEntry@@0@Z PROC ; ScoreCityEntryLowEval::operator(), COMDAT
; _this$ = ecx

; 4964 : 		return a.m_iScore < b.m_iScore;

	mov	eax, DWORD PTR _a$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _b$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setl	al

; 4965 : 	}

	ret	8
??RScoreCityEntryLowEval@@QBE_NABUScoreCityEntry@@0@Z ENDP ; ScoreCityEntryLowEval::operator()
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$0A@@@QAEAAHI@Z		; BaseVector<int,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$0A@@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$0A@@@QAEAAHI@Z PROC			; BaseVector<int,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$0A@@@QAEAAHI@Z ENDP			; BaseVector<int,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$0A@@@QBEABHI@Z		; BaseVector<int,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@H$0A@@@QBEABHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$0A@@@QBEABHI@Z PROC			; BaseVector<int,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@H$0A@@@QBEABHI@Z ENDP			; BaseVector<int,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$0A@@@QBEIXZ		; BaseVector<int,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$0A@@@QBEIXZ PROC			; BaseVector<int,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$0A@@@QBEIXZ ENDP			; BaseVector<int,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z ; BaseVector<CvEspionageSpy,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z PROC ; BaseVector<CvEspionageSpy,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QAEAAVCvEspionageSpy@@I@Z ENDP ; BaseVector<CvEspionageSpy,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvEspionageSpy@@$0A@@@QBEABVCvEspionageSpy@@I@Z ; BaseVector<CvEspionageSpy,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvEspionageSpy@@$0A@@@QBEABVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QBEABVCvEspionageSpy@@I@Z PROC ; BaseVector<CvEspionageSpy,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@VCvEspionageSpy@@$0A@@@QBEABVCvEspionageSpy@@I@Z ENDP ; BaseVector<CvEspionageSpy,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvEspionageSpy@@$0A@@@QBEIXZ ; BaseVector<CvEspionageSpy,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvEspionageSpy@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvEspionageSpy@@$0A@@@QBEIXZ PROC	; BaseVector<CvEspionageSpy,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvEspionageSpy@@$0A@@@QBEIXZ ENDP	; BaseVector<CvEspionageSpy,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEAAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 137  : 	};

	ret	4
??A?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QBEIXZ ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4TechTypes@@$0A@@@QAEAAW4TechTypes@@I@Z ; BaseVector<enum TechTypes,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@W4TechTypes@@$0A@@@QAEAAW4TechTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4TechTypes@@$0A@@@QAEAAW4TechTypes@@I@Z PROC ; BaseVector<enum TechTypes,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@W4TechTypes@@$0A@@@QAEAAW4TechTypes@@I@Z ENDP ; BaseVector<enum TechTypes,0>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@W4TechTypes@@$0A@@@QBEABW4TechTypes@@I@Z ; BaseVector<enum TechTypes,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@W4TechTypes@@$0A@@@QBEABW4TechTypes@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@W4TechTypes@@$0A@@@QBEABW4TechTypes@@I@Z PROC ; BaseVector<enum TechTypes,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@W4TechTypes@@$0A@@@QBEABW4TechTypes@@I@Z ENDP ; BaseVector<enum TechTypes,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ	; BaseVector<enum TechTypes,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ PROC	; BaseVector<enum TechTypes,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@W4TechTypes@@$0A@@@QBEIXZ ENDP	; BaseVector<enum TechTypes,0>::size
_TEXT	ENDS
PUBLIC	??A?$Array@H$0BG@@Firaxis@@QBEABHI@Z		; Firaxis::Array<int,22>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\farray.h
;	COMDAT ??A?$Array@H$0BG@@Firaxis@@QBEABHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$0BG@@Firaxis@@QBEABHI@Z PROC		; Firaxis::Array<int,22>::operator[], COMDAT
; _this$ = ecx

; 144  : #		ifdef _MSC_VER
; 145  : #			pragma warning ( push )
; 146  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 147  : 			// sad day. 
; 148  : #		endif//_MSC_VER
; 149  : 		    assert( i < ARRAY_SIZE );
; 150  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 151  : #		ifdef _MSC_VER
; 152  : #		pragma warning ( pop )
; 153  : #		endif//_MSC_VER
; 154  : 	    }

	ret	4
??A?$Array@H$0BG@@Firaxis@@QBEABHI@Z ENDP		; Firaxis::Array<int,22>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z		; Firaxis::Array<int,22>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z PROC		; Firaxis::Array<int,22>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@H$0BG@@Firaxis@@QAEAAHI@Z ENDP		; Firaxis::Array<int,22>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QBEABV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QBEABV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QBEABV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z PROC ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::operator[], COMDAT
; _this$ = ecx

; 144  : #		ifdef _MSC_VER
; 145  : #			pragma warning ( push )
; 146  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 147  : 			// sad day. 
; 148  : #		endif//_MSC_VER
; 149  : 		    assert( i < ARRAY_SIZE );
; 150  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	shl	eax, 4
	add	eax, ecx

; 151  : #		ifdef _MSC_VER
; 152  : #		pragma warning ( pop )
; 153  : #		endif//_MSC_VER
; 154  : 	    }

	ret	4
??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QBEABV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z ENDP ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::operator[]
_TEXT	ENDS
PUBLIC	??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAEAAV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAEAAV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAEAAV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z PROC ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::operator[], COMDAT
; _this$ = ecx

; 157  : #		ifdef _MSC_VER
; 158  : #			pragma warning ( push )
; 159  : #			pragma warning ( disable : 6385 ) //  Invalid data: accessing 'm_akItems' the readable size is X but X+N bytes might be read
; 160  : 			// sad day. 
; 161  : #		endif//_MSC_VER
; 162  : 		    assert( i < ARRAY_SIZE );
; 163  : 		    return ( m_akItems[ i ] );

	mov	eax, DWORD PTR _i$[esp-4]
	shl	eax, 4
	add	eax, ecx

; 164  : #		ifdef _MSC_VER
; 165  : #		pragma warning ( pop )
; 166  : #		endif//_MSC_VER
; 167  : 		}

	ret	4
??A?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAEAAV?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@I@Z ENDP ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEABUHeistLocation@@I@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEABUHeistLocation@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEABUHeistLocation@@I@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 771  : 		}

	ret	4
??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEABUHeistLocation@@I@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAUHeistLocation@@I@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAUHeistLocation@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAUHeistLocation@@I@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 786  : 		}

	ret	4
??A?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAUHeistLocation@@I@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEABUSpyNotificationMessage@@I@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEABUSpyNotificationMessage@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEABUSpyNotificationMessage@@I@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 771  : 		}

	ret	4
??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEABUSpyNotificationMessage@@I@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAUSpyNotificationMessage@@I@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAUSpyNotificationMessage@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAUSpyNotificationMessage@@I@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 786  : 		}

	ret	4
??A?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAUSpyNotificationMessage@@I@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@I@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@I@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	edx, eax
	shl	edx, 4
	add	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 771  : 		}

	ret	4
??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@I@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAUIntrigueNotificationMessage@@I@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAUIntrigueNotificationMessage@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAUIntrigueNotificationMessage@@I@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	edx, eax
	shl	edx, 4
	add	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 786  : 		}

	ret	4
??A?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAUIntrigueNotificationMessage@@I@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAPAVCvCity@@I@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAUScoreCityEntry@@I@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAUScoreCityEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAUScoreCityEntry@@I@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 786  : 		}

	ret	4
??A?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAUScoreCityEntry@@I@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$0A@@@QAE@XZ			; BaseVector<int,0>::~BaseVector<int,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@H$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@H$0A@@@QAE@XZ PROC			; BaseVector<int,0>::~BaseVector<int,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@H$0A@@@QAE@XZ ENDP			; BaseVector<int,0>::~BaseVector<int,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@H$0A@@@IAE@XZ			; BaseVector<int,0>::BaseVector<int,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@H$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@H$0A@@@IAE@XZ PROC			; BaseVector<int,0>::BaseVector<int,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@H$0A@@@IAE@XZ ENDP			; BaseVector<int,0>::BaseVector<int,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z		; BaseVector<int,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z PROC		; BaseVector<int,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z ENDP		; BaseVector<int,0>::Destroy
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEPAVCvEspionageSpy@@I@Z ; FStaticVector<CvEspionageSpy,8,0,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEPAVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEPAVCvEspionageSpy@@I@Z PROC ; FStaticVector<CvEspionageSpy,8,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 8
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 8
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEPAVCvEspionageSpy@@I@Z ENDP ; FStaticVector<CvEspionageSpy,8,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvEspionageSpy@@$0A@@@QAE@XZ	; BaseVector<CvEspionageSpy,0>::~BaseVector<CvEspionageSpy,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvEspionageSpy@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvEspionageSpy@@$0A@@@QAE@XZ PROC	; BaseVector<CvEspionageSpy,0>::~BaseVector<CvEspionageSpy,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvEspionageSpy@@$0A@@@QAE@XZ ENDP	; BaseVector<CvEspionageSpy,0>::~BaseVector<CvEspionageSpy,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvEspionageSpy@@$0A@@@IAE@XZ	; BaseVector<CvEspionageSpy,0>::BaseVector<CvEspionageSpy,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvEspionageSpy@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvEspionageSpy@@$0A@@@IAE@XZ PROC	; BaseVector<CvEspionageSpy,0>::BaseVector<CvEspionageSpy,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvEspionageSpy@@$0A@@@IAE@XZ ENDP	; BaseVector<CvEspionageSpy,0>::BaseVector<CvEspionageSpy,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvEspionageSpy@@$0A@@@IAEXPAVCvEspionageSpy@@I@Z ; BaseVector<CvEspionageSpy,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvEspionageSpy@@$0A@@@IAEXPAVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvEspionageSpy@@$0A@@@IAEXPAVCvEspionageSpy@@I@Z PROC ; BaseVector<CvEspionageSpy,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvEspionageSpy@@$0A@@@IAEXPAVCvEspionageSpy@@I@Z ENDP ; BaseVector<CvEspionageSpy,0>::Destroy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z PROC ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*4]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 22			; 00000016H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ENDP ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::~BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::~BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAE@XZ ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::~BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAE@XZ ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEPAW4TechTypes@@I@Z ; FStaticVector<enum TechTypes,1,0,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEPAW4TechTypes@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEPAW4TechTypes@@I@Z PROC ; FStaticVector<enum TechTypes,1,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 1
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 1
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEPAW4TechTypes@@I@Z ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@W4TechTypes@@$0A@@@QAE@XZ	; BaseVector<enum TechTypes,0>::~BaseVector<enum TechTypes,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@W4TechTypes@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@W4TechTypes@@$0A@@@QAE@XZ PROC		; BaseVector<enum TechTypes,0>::~BaseVector<enum TechTypes,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@W4TechTypes@@$0A@@@QAE@XZ ENDP		; BaseVector<enum TechTypes,0>::~BaseVector<enum TechTypes,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@W4TechTypes@@$0A@@@IAE@XZ	; BaseVector<enum TechTypes,0>::BaseVector<enum TechTypes,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@W4TechTypes@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@W4TechTypes@@$0A@@@IAE@XZ PROC		; BaseVector<enum TechTypes,0>::BaseVector<enum TechTypes,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@W4TechTypes@@$0A@@@IAE@XZ ENDP		; BaseVector<enum TechTypes,0>::BaseVector<enum TechTypes,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@W4TechTypes@@$0A@@@IAEXPAW4TechTypes@@I@Z ; BaseVector<enum TechTypes,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@W4TechTypes@@$0A@@@IAEXPAW4TechTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4TechTypes@@$0A@@@IAEXPAW4TechTypes@@I@Z PROC ; BaseVector<enum TechTypes,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@W4TechTypes@@$0A@@@IAEXPAW4TechTypes@@I@Z ENDP ; BaseVector<enum TechTypes,0>::Destroy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEPAHI@Z ; FStaticVector<int,22,0,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEPAHI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEPAHI@Z PROC ; FStaticVector<int,22,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN2@Alloc@4

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@4:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 22			; 00000016H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEPAHI@Z ENDP ; FStaticVector<int,22,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXPAHI@Z ; FStaticVector<int,22,0,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXPAHI@Z PROC ; FStaticVector<int,22,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXPAHI@Z ENDP ; FStaticVector<int,22,0,297,0>::Free
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::capacity
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >::~_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >::~_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >::~_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UHeistLocation@@@std@@QAE@XZ	; std::allocator<HeistLocation>::allocator<HeistLocation>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UHeistLocation@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UHeistLocation@@@std@@QAE@XZ PROC	; std::allocator<HeistLocation>::allocator<HeistLocation>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UHeistLocation@@@std@@QAE@XZ ENDP	; std::allocator<HeistLocation>::allocator<HeistLocation>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@2

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::capacity
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >::~_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >::~_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >::~_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$allocator@USpyNotificationMessage@@@std@@QAE@XZ ; std::allocator<SpyNotificationMessage>::allocator<SpyNotificationMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@USpyNotificationMessage@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USpyNotificationMessage@@@std@@QAE@XZ PROC ; std::allocator<SpyNotificationMessage>::allocator<SpyNotificationMessage>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@USpyNotificationMessage@@@std@@QAE@XZ ENDP ; std::allocator<SpyNotificationMessage>::allocator<SpyNotificationMessage>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@3

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::capacity
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >::~_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >::~_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >::~_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@XZ ; std::allocator<IntrigueNotificationMessage>::allocator<IntrigueNotificationMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@XZ PROC ; std::allocator<IntrigueNotificationMessage>::allocator<IntrigueNotificationMessage>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@XZ ENDP ; std::allocator<IntrigueNotificationMessage>::allocator<IntrigueNotificationMessage>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@XZ ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@XZ PROC ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEABUIntrigueNotificationMessage@@XZ ENDP ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 68			; 00000044H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator==
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@XZ		; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvCity@@@std@@QAE@XZ PROC		; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvCity@@@std@@QAE@XZ ENDP		; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@5
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@5:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >::~_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >::~_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >::~_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UScoreCityEntry@@@std@@QAE@XZ	; std::allocator<ScoreCityEntry>::allocator<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UScoreCityEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UScoreCityEntry@@@std@@QAE@XZ PROC	; std::allocator<ScoreCityEntry>::allocator<ScoreCityEntry>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UScoreCityEntry@@@std@@QAE@XZ ENDP	; std::allocator<ScoreCityEntry>::allocator<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@W4TechTypes@@$0A@@@IAEXABV1@@Z ; BaseVector<enum TechTypes,0>::Copy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Copy@?$BaseVector@W4TechTypes@@$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@W4TechTypes@@$0A@@@IAEXABV1@@Z PROC	; BaseVector<enum TechTypes,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	esi
	push	edi

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	edi, DWORD PTR _RHS$[esp+4]
	mov	eax, DWORD PTR [edi+4]

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);
; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	xor	esi, esi
	mov	DWORD PTR [ecx+4], eax
	test	eax, eax
	jbe	SHORT $LN1@Copy
	push	ebx
$LL3@Copy:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi*4]
	add	eax, edx

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	je	SHORT $LN2@Copy
	mov	ebx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+ebx]
	mov	DWORD PTR [eax], edx
$LN2@Copy:
	inc	esi
	cmp	esi, DWORD PTR [ecx+4]
	jb	SHORT $LL3@Copy
	pop	ebx
$LN1@Copy:
	pop	edi
	pop	esi

; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@W4TechTypes@@$0A@@@IAEXABV1@@Z ENDP	; BaseVector<enum TechTypes,0>::Copy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233265 = -80						; size = 28
$T233264 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233265[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233264[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233265[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233264[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233264[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233264[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233264[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233265[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233264[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >::_Container_base_aux_alloc_empty<std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UHeistLocation@@@std@@QAE@ABV01@@Z ; std::allocator<HeistLocation>::allocator<HeistLocation>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UHeistLocation@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UHeistLocation@@@std@@QAE@ABV01@@Z PROC	; std::allocator<HeistLocation>::allocator<HeistLocation>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UHeistLocation@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<HeistLocation>::allocator<HeistLocation>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@I@Z ; std::allocator<HeistLocation>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@I@Z PROC ; std::allocator<HeistLocation>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@I@Z ENDP ; std::allocator<HeistLocation>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233311 = -80						; size = 28
$T233310 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233311[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233310[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233311[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233310[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233310[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233310[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233310[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233311[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233310[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >::_Container_base_aux_alloc_empty<std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$allocator@USpyNotificationMessage@@@std@@QAE@ABV01@@Z ; std::allocator<SpyNotificationMessage>::allocator<SpyNotificationMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@USpyNotificationMessage@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@USpyNotificationMessage@@@std@@QAE@ABV01@@Z PROC ; std::allocator<SpyNotificationMessage>::allocator<SpyNotificationMessage>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@USpyNotificationMessage@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<SpyNotificationMessage>::allocator<SpyNotificationMessage>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@I@Z ; std::allocator<SpyNotificationMessage>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@I@Z PROC ; std::allocator<SpyNotificationMessage>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@I@Z ENDP ; std::allocator<SpyNotificationMessage>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233345 = -80						; size = 28
$T233344 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233345[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233344[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233345[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233344[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233344[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233344[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233344[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233345[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233344[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >::_Container_base_aux_alloc_empty<std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@ABV01@@Z ; std::allocator<IntrigueNotificationMessage>::allocator<IntrigueNotificationMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@ABV01@@Z PROC ; std::allocator<IntrigueNotificationMessage>::allocator<IntrigueNotificationMessage>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UIntrigueNotificationMessage@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<IntrigueNotificationMessage>::allocator<IntrigueNotificationMessage>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@I@Z ; std::allocator<IntrigueNotificationMessage>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@I@Z PROC ; std::allocator<IntrigueNotificationMessage>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@I@Z ENDP ; std::allocator<IntrigueNotificationMessage>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z PROC ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z ENDP ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator-
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233385 = -80						; size = 28
$T233384 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233385[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233384[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233385[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233384[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233384[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233384[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233384[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233385[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233384[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z	; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233419 = -80						; size = 28
$T233418 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233419[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233418[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233419[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233418[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233418[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233418[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233418[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233419[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233418[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >::_Container_base_aux_alloc_empty<std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UScoreCityEntry@@@std@@QAE@ABV01@@Z ; std::allocator<ScoreCityEntry>::allocator<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UScoreCityEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UScoreCityEntry@@@std@@QAE@ABV01@@Z PROC	; std::allocator<ScoreCityEntry>::allocator<ScoreCityEntry>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UScoreCityEntry@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<ScoreCityEntry>::allocator<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@I@Z ; std::allocator<ScoreCityEntry>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@I@Z PROC ; std::allocator<ScoreCityEntry>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@I@Z ENDP ; std::allocator<ScoreCityEntry>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UHeistLocation@@@std@@QBEIXZ ; std::allocator<HeistLocation>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UHeistLocation@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UHeistLocation@@@std@@QBEIXZ PROC	; std::allocator<HeistLocation>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@UHeistLocation@@@std@@QBEIXZ ENDP	; std::allocator<HeistLocation>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@USpyNotificationMessage@@@std@@QBEIXZ ; std::allocator<SpyNotificationMessage>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@USpyNotificationMessage@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@USpyNotificationMessage@@@std@@QBEIXZ PROC ; std::allocator<SpyNotificationMessage>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 214748364				; 0cccccccH

; 167  : 		}

	ret	0
?max_size@?$allocator@USpyNotificationMessage@@@std@@QBEIXZ ENDP ; std::allocator<SpyNotificationMessage>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UIntrigueNotificationMessage@@@std@@QBEIXZ ; std::allocator<IntrigueNotificationMessage>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UIntrigueNotificationMessage@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UIntrigueNotificationMessage@@@std@@QBEIXZ PROC ; std::allocator<IntrigueNotificationMessage>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 63161283				; 03c3c3c3H

; 167  : 		}

	ret	0
?max_size@?$allocator@UIntrigueNotificationMessage@@@std@@QBEIXZ ENDP ; std::allocator<IntrigueNotificationMessage>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ	; std::allocator<CvCity *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ PROC	; std::allocator<CvCity *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ ENDP	; std::allocator<CvCity *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UScoreCityEntry@@@std@@QBEIXZ ; std::allocator<ScoreCityEntry>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@UScoreCityEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UScoreCityEntry@@@std@@QBEIXZ PROC ; std::allocator<ScoreCityEntry>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@UScoreCityEntry@@@std@@QBEIXZ ENDP ; std::allocator<ScoreCityEntry>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z PROC ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z ENDP ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z PROC ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z ENDP ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UHeistLocation@@@std@@YAPAUHeistLocation@@IPAU1@@Z ; std::_Allocate<HeistLocation>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UHeistLocation@@@std@@YAPAUHeistLocation@@IPAU1@@Z
_TEXT	SEGMENT
$T233540 = -12						; size = 12
$T233544 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UHeistLocation@@@std@@YAPAUHeistLocation@@IPAU1@@Z PROC ; std::_Allocate<HeistLocation>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233544[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233540[esp+16]
	mov	DWORD PTR $T233544[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233540[esp+16]
	push	ecx
	mov	DWORD PTR $T233540[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@UHeistLocation@@@std@@YAPAUHeistLocation@@IPAU1@@Z ENDP ; std::_Allocate<HeistLocation>
_TEXT	ENDS
PUBLIC	??$_Allocate@USpyNotificationMessage@@@std@@YAPAUSpyNotificationMessage@@IPAU1@@Z ; std::_Allocate<SpyNotificationMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@USpyNotificationMessage@@@std@@YAPAUSpyNotificationMessage@@IPAU1@@Z
_TEXT	SEGMENT
$T233550 = -12						; size = 12
$T233554 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USpyNotificationMessage@@@std@@YAPAUSpyNotificationMessage@@IPAU1@@Z PROC ; std::_Allocate<SpyNotificationMessage>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233554[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233550[esp+16]
	mov	DWORD PTR $T233554[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233550[esp+16]
	push	ecx
	mov	DWORD PTR $T233550[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@USpyNotificationMessage@@@std@@YAPAUSpyNotificationMessage@@IPAU1@@Z ENDP ; std::_Allocate<SpyNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Allocate@UIntrigueNotificationMessage@@@std@@YAPAUIntrigueNotificationMessage@@IPAU1@@Z ; std::_Allocate<IntrigueNotificationMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@UIntrigueNotificationMessage@@@std@@YAPAUIntrigueNotificationMessage@@IPAU1@@Z
_TEXT	SEGMENT
$T233560 = -12						; size = 12
$T233564 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UIntrigueNotificationMessage@@@std@@YAPAUIntrigueNotificationMessage@@IPAU1@@Z PROC ; std::_Allocate<IntrigueNotificationMessage>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 68					; 00000044H
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233564[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233560[esp+16]
	mov	DWORD PTR $T233564[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233560[esp+16]
	push	ecx
	mov	DWORD PTR $T233560[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@UIntrigueNotificationMessage@@@std@@YAPAUIntrigueNotificationMessage@@IPAU1@@Z ENDP ; std::_Allocate<IntrigueNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z
_TEXT	SEGMENT
$T233570 = -12						; size = 12
$T233574 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z PROC ; std::_Allocate<CvCity *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233574[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233570[esp+16]
	mov	DWORD PTR $T233574[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233570[esp+16]
	push	ecx
	mov	DWORD PTR $T233570[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCity *>
_TEXT	ENDS
PUBLIC	??$_Allocate@UScoreCityEntry@@@std@@YAPAUScoreCityEntry@@IPAU1@@Z ; std::_Allocate<ScoreCityEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@UScoreCityEntry@@@std@@YAPAUScoreCityEntry@@IPAU1@@Z
_TEXT	SEGMENT
$T233580 = -12						; size = 12
$T233584 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UScoreCityEntry@@@std@@YAPAUScoreCityEntry@@IPAU1@@Z PROC ; std::_Allocate<ScoreCityEntry>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T233584[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T233580[esp+16]
	mov	DWORD PTR $T233584[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T233580[esp+16]
	push	ecx
	mov	DWORD PTR $T233580[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@UScoreCityEntry@@@std@@YAPAUScoreCityEntry@@IPAU1@@Z ENDP ; std::_Allocate<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator==
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAPAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUHeistLocation@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUHeistLocation@@0@Z ; std::_Iter_random<HeistLocation *,HeistLocation *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUHeistLocation@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUHeistLocation@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUHeistLocation@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUHeistLocation@@0@Z PROC ; std::_Iter_random<HeistLocation *,HeistLocation *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUHeistLocation@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUHeistLocation@@0@Z ENDP ; std::_Iter_random<HeistLocation *,HeistLocation *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUHeistLocation@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUHeistLocation@@0@Z ; std::_Ptr_cat<HeistLocation *,HeistLocation *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUHeistLocation@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUHeistLocation@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUHeistLocation@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUHeistLocation@@0@Z PROC ; std::_Ptr_cat<HeistLocation *,HeistLocation *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUHeistLocation@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUHeistLocation@@0@Z ENDP ; std::_Ptr_cat<HeistLocation *,HeistLocation *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUSpyNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSpyNotificationMessage@@0@Z ; std::_Iter_random<SpyNotificationMessage *,SpyNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUSpyNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSpyNotificationMessage@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUSpyNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSpyNotificationMessage@@0@Z PROC ; std::_Iter_random<SpyNotificationMessage *,SpyNotificationMessage *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUSpyNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSpyNotificationMessage@@0@Z ENDP ; std::_Iter_random<SpyNotificationMessage *,SpyNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUSpyNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSpyNotificationMessage@@0@Z ; std::_Ptr_cat<SpyNotificationMessage *,SpyNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUSpyNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSpyNotificationMessage@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUSpyNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSpyNotificationMessage@@0@Z PROC ; std::_Ptr_cat<SpyNotificationMessage *,SpyNotificationMessage *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUSpyNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUSpyNotificationMessage@@0@Z ENDP ; std::_Ptr_cat<SpyNotificationMessage *,SpyNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	add	ecx, 20					; 00000014H
	add	eax, 20					; 00000014H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUIntrigueNotificationMessage@@0@Z ; std::_Iter_random<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUIntrigueNotificationMessage@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUIntrigueNotificationMessage@@0@Z PROC ; std::_Iter_random<IntrigueNotificationMessage *,IntrigueNotificationMessage *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUIntrigueNotificationMessage@@0@Z ENDP ; std::_Iter_random<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUIntrigueNotificationMessage@@0@Z ; std::_Ptr_cat<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUIntrigueNotificationMessage@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUIntrigueNotificationMessage@@0@Z PROC ; std::_Ptr_cat<IntrigueNotificationMessage *,IntrigueNotificationMessage *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUIntrigueNotificationMessage@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUIntrigueNotificationMessage@@0@Z ENDP ; std::_Ptr_cat<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ; std::_Iter_random<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z PROC ; std::_Iter_random<CvCity * *,CvCity * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ENDP ; std::_Iter_random<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ; std::_Ptr_cat<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z PROC ; std::_Ptr_cat<CvCity * *,CvCity * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ENDP ; std::_Ptr_cat<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@3:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUScoreCityEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@0@Z ; std::_Ptr_cat<ScoreCityEntry *,ScoreCityEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUScoreCityEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUScoreCityEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@0@Z PROC ; std::_Ptr_cat<ScoreCityEntry *,ScoreCityEntry *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUScoreCityEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@0@Z ENDP ; std::_Ptr_cat<ScoreCityEntry *,ScoreCityEntry *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z ; std::_Fill<HeistLocation *,HeistLocation>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z PROC ; std::_Fill<HeistLocation *,HeistLocation>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z ENDP ; std::_Fill<HeistLocation *,HeistLocation>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUHeistLocation@@@std@@YA?AU_Undefined_move_tag@0@ABQAUHeistLocation@@@Z ; std::_Move_cat<HeistLocation *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUHeistLocation@@@std@@YA?AU_Undefined_move_tag@0@ABQAUHeistLocation@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUHeistLocation@@@std@@YA?AU_Undefined_move_tag@0@ABQAUHeistLocation@@@Z PROC ; std::_Move_cat<HeistLocation *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUHeistLocation@@@std@@YA?AU_Undefined_move_tag@0@ABQAUHeistLocation@@@Z ENDP ; std::_Move_cat<HeistLocation *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z ; std::_Fill<SpyNotificationMessage *,SpyNotificationMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z PROC ; std::_Fill<SpyNotificationMessage *,SpyNotificationMessage>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	add	eax, 20					; 00000014H
	cmp	eax, edx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z ENDP ; std::_Fill<SpyNotificationMessage *,SpyNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUSpyNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUSpyNotificationMessage@@@Z ; std::_Move_cat<SpyNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUSpyNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUSpyNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUSpyNotificationMessage@@@Z PROC ; std::_Move_cat<SpyNotificationMessage *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUSpyNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUSpyNotificationMessage@@@Z ENDP ; std::_Move_cat<SpyNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUIntrigueNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUIntrigueNotificationMessage@@@Z ; std::_Move_cat<IntrigueNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUIntrigueNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUIntrigueNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUIntrigueNotificationMessage@@@Z PROC ; std::_Move_cat<IntrigueNotificationMessage *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUIntrigueNotificationMessage@@@std@@YA?AU_Undefined_move_tag@0@ABQAUIntrigueNotificationMessage@@@Z ENDP ; std::_Move_cat<IntrigueNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::_Fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::_Fill<CvCity * *,CvCity *>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::_Fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ; std::_Move_cat<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Move_cat<CvCity * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Move_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescriptionKey
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescriptionKey, COMDAT
; _this$ = ecx

; 69   : 		return m_strDescriptionKey.c_str();

	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescriptionKey@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescriptionKey
_TEXT	ENDS
PUBLIC	??$_Fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z ; std::_Fill<ScoreCityEntry *,ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z PROC ; std::_Fill<ScoreCityEntry *,ScoreCityEntry>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill@4
	pop	esi
$LN1@Fill@4:

; 3160 : 	}

	ret	0
??$_Fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z ENDP ; std::_Fill<ScoreCityEntry *,ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUScoreCityEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0@Z ; std::_Iter_random<ScoreCityEntry *,ScoreCityEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUScoreCityEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUScoreCityEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0@Z PROC ; std::_Iter_random<ScoreCityEntry *,ScoreCityEntry *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUScoreCityEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0@Z ENDP ; std::_Iter_random<ScoreCityEntry *,ScoreCityEntry *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUScoreCityEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUScoreCityEntry@@@Z ; std::_Move_cat<ScoreCityEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUScoreCityEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUScoreCityEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUScoreCityEntry@@@Z PROC ; std::_Move_cat<ScoreCityEntry *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUScoreCityEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUScoreCityEntry@@@Z ENDP ; std::_Move_cat<ScoreCityEntry *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@H@Z ; std::_Temp_iterator<ScoreCityEntry>::_Temp_iterator<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<ScoreCityEntry>::_Temp_iterator<ScoreCityEntry>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<ScoreCityEntry>::_Temp_iterator<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-20]
	sub	ecx, 20					; 00000014H
	sub	eax, 20					; 00000014H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<ScoreCityEntry *,ScoreCityEntry *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<ScoreCityEntry *,ScoreCityEntry *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@4
	push	esi
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@4
	pop	esi
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<ScoreCityEntry *,ScoreCityEntry *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UHeistLocation@@U1@@std@@YAXPAUHeistLocation@@ABU1@@Z ; std::_Construct<HeistLocation,HeistLocation>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@UHeistLocation@@U1@@std@@YAXPAUHeistLocation@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UHeistLocation@@U1@@std@@YAXPAUHeistLocation@@ABU1@@Z PROC ; std::_Construct<HeistLocation,HeistLocation>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@UHeistLocation@@U1@@std@@YAXPAUHeistLocation@@ABU1@@Z ENDP ; std::_Construct<HeistLocation,HeistLocation>
_TEXT	ENDS
PUBLIC	??$_Destroy@UHeistLocation@@@std@@YAXPAUHeistLocation@@@Z ; std::_Destroy<HeistLocation>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UHeistLocation@@@std@@YAXPAUHeistLocation@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UHeistLocation@@@std@@YAXPAUHeistLocation@@@Z PROC ; std::_Destroy<HeistLocation>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UHeistLocation@@@std@@YAXPAUHeistLocation@@@Z ENDP ; std::_Destroy<HeistLocation>
_TEXT	ENDS
PUBLIC	??$_Construct@USpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@ABU1@@Z ; std::_Construct<SpyNotificationMessage,SpyNotificationMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@USpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@USpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@ABU1@@Z PROC ; std::_Construct<SpyNotificationMessage,SpyNotificationMessage>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@USpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@ABU1@@Z ENDP ; std::_Construct<SpyNotificationMessage,SpyNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Destroy@USpyNotificationMessage@@@std@@YAXPAUSpyNotificationMessage@@@Z ; std::_Destroy<SpyNotificationMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@USpyNotificationMessage@@@std@@YAXPAUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@USpyNotificationMessage@@@std@@YAXPAUSpyNotificationMessage@@@Z PROC ; std::_Destroy<SpyNotificationMessage>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@USpyNotificationMessage@@@std@@YAXPAUSpyNotificationMessage@@@Z ENDP ; std::_Destroy<SpyNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Construct@UScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@ABU1@@Z ; std::_Construct<ScoreCityEntry,ScoreCityEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@UScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@ABU1@@Z PROC ; std::_Construct<ScoreCityEntry,ScoreCityEntry>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@UScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@ABU1@@Z ENDP ; std::_Construct<ScoreCityEntry,ScoreCityEntry>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	??$_Destroy@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z ; std::_Destroy<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z PROC ; std::_Destroy<ScoreCityEntry>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z ENDP ; std::_Destroy<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z ; std::return_temporary_buffer<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z PROC ; std::return_temporary_buffer<ScoreCityEntry>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@UScoreCityEntry@@@std@@YAXPAUScoreCityEntry@@@Z ENDP ; std::return_temporary_buffer<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ; std::_Iter_cat<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Iter_cat<CvCity * *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Iter_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@1@@Z ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@1@@Z PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 399  : 		}

	ret	4
??G?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEHABV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@1@@Z ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator-
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<ScoreCityEntry>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<ScoreCityEntry>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<ScoreCityEntry>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ ; std::_Temp_iterator<ScoreCityEntry>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ PROC ; std::_Temp_iterator<ScoreCityEntry>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ ENDP ; std::_Temp_iterator<ScoreCityEntry>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ ; std::_Temp_iterator<ScoreCityEntry>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ PROC ; std::_Temp_iterator<ScoreCityEntry>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@UScoreCityEntry@@@std@@QBEPAUScoreCityEntry@@XZ ENDP ; std::_Temp_iterator<ScoreCityEntry>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAUScoreCityEntry@@H@std@@QAE@ABQAUScoreCityEntry@@ABH@Z ; std::pair<ScoreCityEntry *,int>::pair<ScoreCityEntry *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUScoreCityEntry@@H@std@@QAE@ABQAUScoreCityEntry@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUScoreCityEntry@@H@std@@QAE@ABQAUScoreCityEntry@@ABH@Z PROC ; std::pair<ScoreCityEntry *,int>::pair<ScoreCityEntry *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUScoreCityEntry@@H@std@@QAE@ABQAUScoreCityEntry@@ABH@Z ENDP ; std::pair<ScoreCityEntry *,int>::pair<ScoreCityEntry *,int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEABUScoreCityEntry@@XZ ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEABUScoreCityEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEABUScoreCityEntry@@XZ PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEABUScoreCityEntry@@XZ ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<ScoreCityEntry>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<ScoreCityEntry>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<ScoreCityEntry>::operator=
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 8

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -8			; fffffff8H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator--
_TEXT	ENDS
PUBLIC	??$swap@UScoreCityEntry@@@std@@YAXAAUScoreCityEntry@@0@Z ; std::swap<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UScoreCityEntry@@@std@@YAXAAUScoreCityEntry@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UScoreCityEntry@@@std@@YAXAAUScoreCityEntry@@0@Z PROC ; std::swap<ScoreCityEntry>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UScoreCityEntry@@@std@@YAXAAUScoreCityEntry@@0@Z ENDP ; std::swap<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@AAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ; std::_Ptr_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@AAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@AAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@AAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@1@Z ; std::_Iter_random<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@1@Z PROC ; std::_Iter_random<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@1@Z ENDP ; std::_Iter_random<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABUScoreCityEntry@@@Z ; std::_Temp_iterator<ScoreCityEntry>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABUScoreCityEntry@@@Z PROC ; std::_Temp_iterator<ScoreCityEntry>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@2
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@2:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@2
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
$LN7@operator@2:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@ABUScoreCityEntry@@@Z ENDP ; std::_Temp_iterator<ScoreCityEntry>::operator=
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<ScoreCityEntry>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<ScoreCityEntry>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<ScoreCityEntry>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<ScoreCityEntry>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<ScoreCityEntry>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@UScoreCityEntry@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<ScoreCityEntry>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ; std::_Iter_random<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z PROC ; std::_Iter_random<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ENDP ; std::_Iter_random<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ; std::_Ptr_cat<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z PROC ; std::_Ptr_cat<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUScoreCityEntry@@AAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ENDP ; std::_Ptr_cat<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0ABV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAUScoreCityEntry@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@@Z ; std::_Iter_cat<ScoreCityEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAUScoreCityEntry@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAUScoreCityEntry@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@@Z PROC ; std::_Iter_cat<ScoreCityEntry *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAUScoreCityEntry@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@@Z ENDP ; std::_Iter_cat<ScoreCityEntry *>
_TEXT	ENDS
PUBLIC	??$_Advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<ScoreCityEntry *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<ScoreCityEntry *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<ScoreCityEntry *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ; std::_Iter_random<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z PROC ; std::_Iter_random<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUScoreCityEntry@@0ABV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@@Z ENDP ; std::_Iter_random<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_MARITIME_GROWTH@CvGlobals@@QAEHXZ ; CvGlobals::getMC_GIFT_WEIGHT_MARITIME_GROWTH
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMC_GIFT_WEIGHT_MARITIME_GROWTH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_MARITIME_GROWTH@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMC_GIFT_WEIGHT_MARITIME_GROWTH, COMDAT
; _this$ = ecx

; 2533 : 		return m_iMC_GIFT_WEIGHT_MARITIME_GROWTH;

	mov	eax, DWORD PTR [ecx+3460]

; 2534 : 	}

	ret	0
?getMC_GIFT_WEIGHT_MARITIME_GROWTH@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMC_GIFT_WEIGHT_MARITIME_GROWTH
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_MILITARISTIC@CvGlobals@@QAEHXZ ; CvGlobals::getMC_GIFT_WEIGHT_MILITARISTIC
; Function compile flags: /Ogtpy
;	COMDAT ?getMC_GIFT_WEIGHT_MILITARISTIC@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_MILITARISTIC@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMC_GIFT_WEIGHT_MILITARISTIC, COMDAT
; _this$ = ecx

; 2549 : 		return m_iMC_GIFT_WEIGHT_MILITARISTIC;

	mov	eax, DWORD PTR [ecx+3476]

; 2550 : 	}

	ret	0
?getMC_GIFT_WEIGHT_MILITARISTIC@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMC_GIFT_WEIGHT_MILITARISTIC
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_RESOURCE_WE_NEED@CvGlobals@@QAEHXZ ; CvGlobals::getMC_GIFT_WEIGHT_RESOURCE_WE_NEED
; Function compile flags: /Ogtpy
;	COMDAT ?getMC_GIFT_WEIGHT_RESOURCE_WE_NEED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_RESOURCE_WE_NEED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getMC_GIFT_WEIGHT_RESOURCE_WE_NEED, COMDAT
; _this$ = ecx

; 2553 : 		return m_iMC_GIFT_WEIGHT_RESOURCE_WE_NEED;

	mov	eax, DWORD PTR [ecx+3480]

; 2554 : 	}

	ret	0
?getMC_GIFT_WEIGHT_RESOURCE_WE_NEED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getMC_GIFT_WEIGHT_RESOURCE_WE_NEED
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_PROTECTIVE@CvGlobals@@QAEHXZ	; CvGlobals::getMC_GIFT_WEIGHT_PROTECTIVE
; Function compile flags: /Ogtpy
;	COMDAT ?getMC_GIFT_WEIGHT_PROTECTIVE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_PROTECTIVE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMC_GIFT_WEIGHT_PROTECTIVE, COMDAT
; _this$ = ecx

; 2561 : 		return m_iMC_GIFT_WEIGHT_PROTECTIVE;

	mov	eax, DWORD PTR [ecx+3488]

; 2562 : 	}

	ret	0
?getMC_GIFT_WEIGHT_PROTECTIVE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMC_GIFT_WEIGHT_PROTECTIVE
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_HOSTILE@CvGlobals@@QAEHXZ	; CvGlobals::getMC_GIFT_WEIGHT_HOSTILE
; Function compile flags: /Ogtpy
;	COMDAT ?getMC_GIFT_WEIGHT_HOSTILE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_HOSTILE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMC_GIFT_WEIGHT_HOSTILE, COMDAT
; _this$ = ecx

; 2565 : 		return m_iMC_GIFT_WEIGHT_HOSTILE;

	mov	eax, DWORD PTR [ecx+3492]

; 2566 : 	}

	ret	0
?getMC_GIFT_WEIGHT_HOSTILE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMC_GIFT_WEIGHT_HOSTILE
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_NEIGHBORS@CvGlobals@@QAEHXZ	; CvGlobals::getMC_GIFT_WEIGHT_NEIGHBORS
; Function compile flags: /Ogtpy
;	COMDAT ?getMC_GIFT_WEIGHT_NEIGHBORS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_NEIGHBORS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMC_GIFT_WEIGHT_NEIGHBORS, COMDAT
; _this$ = ecx

; 2569 : 		return m_iMC_GIFT_WEIGHT_NEIGHBORS;

	mov	eax, DWORD PTR [ecx+3496]

; 2570 : 	}

	ret	0
?getMC_GIFT_WEIGHT_NEIGHBORS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMC_GIFT_WEIGHT_NEIGHBORS
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_CLOSE@CvGlobals@@QAEHXZ	; CvGlobals::getMC_GIFT_WEIGHT_CLOSE
; Function compile flags: /Ogtpy
;	COMDAT ?getMC_GIFT_WEIGHT_CLOSE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_CLOSE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMC_GIFT_WEIGHT_CLOSE, COMDAT
; _this$ = ecx

; 2573 : 		return m_iMC_GIFT_WEIGHT_CLOSE;

	mov	eax, DWORD PTR [ecx+3500]

; 2574 : 	}

	ret	0
?getMC_GIFT_WEIGHT_CLOSE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMC_GIFT_WEIGHT_CLOSE
_TEXT	ENDS
PUBLIC	?getMC_GIFT_WEIGHT_FAR@CvGlobals@@QAEHXZ	; CvGlobals::getMC_GIFT_WEIGHT_FAR
; Function compile flags: /Ogtpy
;	COMDAT ?getMC_GIFT_WEIGHT_FAR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMC_GIFT_WEIGHT_FAR@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMC_GIFT_WEIGHT_FAR, COMDAT
; _this$ = ecx

; 2577 : 		return m_iMC_GIFT_WEIGHT_FAR;

	mov	eax, DWORD PTR [ecx+3504]

; 2578 : 	}

	ret	0
?getMC_GIFT_WEIGHT_FAR@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMC_GIFT_WEIGHT_FAR
_TEXT	ENDS
PUBLIC	?getESPIONAGE_GATHERING_INTEL_COST_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_GATHERING_INTEL_COST_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_GATHERING_INTEL_COST_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_GATHERING_INTEL_COST_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_GATHERING_INTEL_COST_PERCENT, COMDAT
; _this$ = ecx

; 7423 : 		return m_iESPIONAGE_GATHERING_INTEL_COST_PERCENT;

	mov	eax, DWORD PTR [ecx+7924]

; 7424 : 	}

	ret	0
?getESPIONAGE_GATHERING_INTEL_COST_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_GATHERING_INTEL_COST_PERCENT
_TEXT	ENDS
PUBLIC	?getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT, COMDAT
; _this$ = ecx

; 7427 : 		return m_iESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT;

	mov	eax, DWORD PTR [ecx+7928]

; 7428 : 	}

	ret	0
?getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT
_TEXT	ENDS
PUBLIC	?getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT, COMDAT
; _this$ = ecx

; 7431 : 		return m_iESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT;

	mov	eax, DWORD PTR [ecx+7932]

; 7432 : 	}

	ret	0
?getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT
_TEXT	ENDS
PUBLIC	?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_SURVEILLANCE_SIGHT_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_SURVEILLANCE_SIGHT_RANGE, COMDAT
; _this$ = ecx

; 7447 : 		return m_iESPIONAGE_SURVEILLANCE_SIGHT_RANGE;

	mov	eax, DWORD PTR [ecx+7948]

; 7448 : 	}

	ret	0
?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_SURVEILLANCE_SIGHT_RANGE
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP, COMDAT
; _this$ = ecx

; 7451 : 		return m_iESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP;

	mov	eax, DWORD PTR [ecx+7952]

; 7452 : 	}

	ret	0
?getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_NOBODY_BONUS@CvGlobals@@QAEMXZ ; CvGlobals::getESPIONAGE_COUP_NOBODY_BONUS
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_NOBODY_BONUS@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_NOBODY_BONUS@CvGlobals@@QAEMXZ PROC	; CvGlobals::getESPIONAGE_COUP_NOBODY_BONUS, COMDAT
; _this$ = ecx

; 7455 : 		return m_fESPIONAGE_COUP_NOBODY_BONUS;

	fld	DWORD PTR [ecx+8156]

; 7456 : 	}

	ret	0
?getESPIONAGE_COUP_NOBODY_BONUS@CvGlobals@@QAEMXZ ENDP	; CvGlobals::getESPIONAGE_COUP_NOBODY_BONUS
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_MULTIPLY_CONSTANT@CvGlobals@@QAEMXZ ; CvGlobals::getESPIONAGE_COUP_MULTIPLY_CONSTANT
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_MULTIPLY_CONSTANT@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_MULTIPLY_CONSTANT@CvGlobals@@QAEMXZ PROC ; CvGlobals::getESPIONAGE_COUP_MULTIPLY_CONSTANT, COMDAT
; _this$ = ecx

; 7459 : 		return m_fESPIONAGE_COUP_MULTIPLY_CONSTANT;

	fld	DWORD PTR [ecx+8160]

; 7460 : 	}

	ret	0
?getESPIONAGE_COUP_MULTIPLY_CONSTANT@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getESPIONAGE_COUP_MULTIPLY_CONSTANT
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO@CvGlobals@@QAEMXZ ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO@CvGlobals@@QAEMXZ PROC ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO, COMDAT
; _this$ = ecx

; 7463 : 		return m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO;

	fld	DWORD PTR [ecx+8164]

; 7464 : 	}

	ret	0
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE@CvGlobals@@QAEMXZ ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE@CvGlobals@@QAEMXZ PROC ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE, COMDAT
; _this$ = ecx

; 7467 : 		return m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE;

	fld	DWORD PTR [ecx+8168]

; 7468 : 	}

	ret	0
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO@CvGlobals@@QAEMXZ ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO@CvGlobals@@QAEMXZ PROC ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO, COMDAT
; _this$ = ecx

; 7471 : 		return m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO;

	fld	DWORD PTR [ecx+8172]

; 7472 : 	}

	ret	0
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE@CvGlobals@@QAEMXZ ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE@CvGlobals@@QAEMXZ PROC ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE, COMDAT
; _this$ = ecx

; 7475 : 		return m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE;

	fld	DWORD PTR [ecx+8176]

; 7476 : 	}

	ret	0
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE
_TEXT	ENDS
PUBLIC	?getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR@CvGlobals@@QAEMXZ ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR@CvGlobals@@QAEMXZ PROC ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR, COMDAT
; _this$ = ecx

; 7479 : 		return m_fESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR;

	fld	DWORD PTR [ecx+8180]

; 7480 : 	}

	ret	0
?getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T233990 = -80						; size = 28
$T233989 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T233990[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T233989[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T233990[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T233989[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T233989[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T233989[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T233989[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@6:
$LN12@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T233990[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T233989[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T234046 = -12						; size = 12
$T234050 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234050[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T234046[esp+16]
	mov	DWORD PTR $T234050[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234046[esp+16]
	push	ecx
	mov	DWORD PTR $T234046[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ; FDataStream::operator>><CvString>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z PROC ; FDataStream::operator>><CvString>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ENDP ; FDataStream::operator>><CvString>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ; FDataStream::operator<<<CvString>
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z PROC ; FDataStream::operator<<<CvString>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ENDP ; FDataStream::operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@4

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@4:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@6
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@6:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@5
	pop	esi
$LN1@Fill@5:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@5

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@5:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@2
	pop	esi
$LN1@Fill_n@2:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop@2:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T234134 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T234134[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T234134[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T234134[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T234134[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvEspionageSpy@@@Z ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvEspionageSpy@@@Z
_TEXT	SEGMENT
_iSpyState$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_iSpyRank$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvEspionageSpy@@@Z PROC	; operator>>, COMDAT

; 47   : {

	sub	esp, 8
	push	esi

; 48   : 	uint uiVersion;
; 49   : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 50   : 
; 51   : 	loadFrom >> writeTo.m_iName;

	mov	edi, DWORD PTR _writeTo$[esp+12]
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 52   : 	int iSpyRank;
; 53   : 	loadFrom >> iSpyRank;

	lea	ecx, DWORD PTR _iSpyRank$[esp+12]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 54   : 	writeTo.m_eRank = (CvSpyRank)iSpyRank;

	mov	edx, DWORD PTR _iSpyRank$[esp+12]

; 55   : 	loadFrom >> writeTo.m_iCityX;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [edi+12], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 56   : 	loadFrom >> writeTo.m_iCityY;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 57   : 
; 58   : 	int iSpyState;
; 59   : 	loadFrom >> iSpyState;

	lea	edx, DWORD PTR _iSpyState$[esp+16]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 60   : 	writeTo.m_eSpyState = (CvSpyState)iSpyState;

	mov	eax, DWORD PTR _iSpyState$[esp+16]

; 61   : 
; 62   : 	loadFrom >> writeTo.m_iReviveCounter;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [edi+16], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 63   : 	if (uiVersion >= 1)

	cmp	DWORD PTR _uiVersion$[esp+16], 1
	jb	SHORT $LN2@operator@3

; 64   : 	{
; 65   : 		loadFrom >> writeTo.m_bIsDiplomat;

	lea	edx, DWORD PTR [edi+24]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 66   : 	}
; 67   : 	else

	jmp	SHORT $LN1@operator@3
$LN2@operator@3:

; 68   : 	{
; 69   : 		writeTo.m_bIsDiplomat = false;

	mov	BYTE PTR [edi+24], 0
$LN1@operator@3:

; 70   : 	}
; 71   : 	
; 72   : 	loadFrom >> writeTo.m_bEvaluateReassignment;

	add	edi, 25					; 00000019H
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 73   : 	writeTo.m_bEvaluateReassignment = true;

	mov	BYTE PTR [edi], 1
	pop	edi

; 74   : 
; 75   : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 76   : }

	add	esp, 8
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvEspionageSpy@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvEspionageSpy@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvEspionageSpy@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T234180 = 8						; size = 4
$T234179 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvEspionageSpy@@@Z PROC	; operator<<, COMDAT

; 80   : {

	push	ecx
	push	esi

; 81   : 	uint uiVersion = 1;
; 82   : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 83   : 
; 84   : 	saveTo << readFrom.m_iName;

	mov	edi, DWORD PTR _readFrom$[esp+8]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 85   : 	saveTo << (int)readFrom.m_eRank;

	mov	ecx, DWORD PTR [edi+12]
	lea	edx, DWORD PTR $T234179[esp+8]
	mov	DWORD PTR $T234179[esp+8], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 86   : 	saveTo << readFrom.m_iCityX;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 87   : 	saveTo << readFrom.m_iCityY;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 88   : 	saveTo << (int)readFrom.m_eSpyState;

	mov	edx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR $T234180[esp+8]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T234180[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 89   : 	saveTo << readFrom.m_iReviveCounter;

	lea	ecx, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 90   : 	saveTo << readFrom.m_bIsDiplomat;

	lea	edx, DWORD PTR [edi+24]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 91   : 	saveTo << readFrom.m_bEvaluateReassignment;

	add	edi, 25					; 00000019H
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi

; 92   : 
; 93   : 	return saveTo;

	mov	eax, esi
	pop	esi

; 94   : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvEspionageSpy@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?GetNextSpyName@CvPlayerEspionage@@QAEHXZ	; CvPlayerEspionage::GetNextSpyName
; Function compile flags: /Ogtpy
;	COMDAT ?GetNextSpyName@CvPlayerEspionage@@QAEHXZ
_TEXT	SEGMENT
?GetNextSpyName@CvPlayerEspionage@@QAEHXZ PROC		; CvPlayerEspionage::GetNextSpyName, COMDAT
; _this$ = ecx

; 962  : 	CvAssertMsg((uint)m_iSpyListNameOrderIndex < m_aiSpyListNameOrder.size(), "m_iSpyListNameOrderIndex out of bounds probably because this civ doesn't have spy names.")
; 963  : 	if((uint)m_iSpyListNameOrderIndex >= m_aiSpyListNameOrder.size())

	mov	eax, DWORD PTR [ecx+252]
	sub	eax, DWORD PTR [ecx+248]
	mov	edx, DWORD PTR [ecx+260]
	sar	eax, 2
	cmp	edx, eax
	jb	SHORT $LN2@GetNextSpy

; 964  : 	{
; 965  : 		return -1;

	or	eax, -1

; 973  : 	}
; 974  : 	return iName;
; 975  : }

	ret	0
$LN2@GetNextSpy:

; 966  : 	}
; 967  : 
; 968  : 	int iName = m_aiSpyListNameOrder[m_iSpyListNameOrderIndex];

	mov	eax, DWORD PTR [ecx+248]
	mov	eax, DWORD PTR [eax+edx*4]
	push	esi

; 969  : 	m_iSpyListNameOrderIndex++;

	inc	edx
	mov	DWORD PTR [ecx+260], edx

; 970  : 	if(m_iSpyListNameOrderIndex >= (int)m_aiSpyListNameOrder.size())

	mov	esi, DWORD PTR [ecx+252]
	sub	esi, DWORD PTR [ecx+248]
	sar	esi, 2
	cmp	edx, esi
	pop	esi
	jl	SHORT $LN3@GetNextSpy

; 971  : 	{
; 972  : 		m_iSpyListNameOrderIndex = 0;

	mov	DWORD PTR [ecx+260], 0
$LN3@GetNextSpy:

; 973  : 	}
; 974  : 	return iName;
; 975  : }

	ret	0
?GetNextSpyName@CvPlayerEspionage@@QAEHXZ ENDP		; CvPlayerEspionage::GetNextSpyName
_TEXT	ENDS
PUBLIC	?IsSpyInCity@CvPlayerEspionage@@QAE_NI@Z	; CvPlayerEspionage::IsSpyInCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsSpyInCity@CvPlayerEspionage@@QAE_NI@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?IsSpyInCity@CvPlayerEspionage@@QAE_NI@Z PROC		; CvPlayerEspionage::IsSpyInCity, COMDAT
; _this$ = ecx

; 980  : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "uiSpyIndex is out of bounds");
; 981  : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]

; 982  : 	{
; 983  : 		return false;

	jae	SHORT $LN2@IsSpyInCit

; 984  : 	}
; 985  : 
; 986  : 	if(m_aSpyList[uiSpyIndex].m_iCityX != -1 && m_aSpyList[uiSpyIndex].m_iCityY != -1)

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]
	or	ecx, -1
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN2@IsSpyInCit
	cmp	DWORD PTR [eax+8], ecx
	je	SHORT $LN2@IsSpyInCit

; 987  : 	{
; 988  : 		return true;

	mov	al, 1

; 993  : 	}
; 994  : }

	ret	4
$LN2@IsSpyInCit:

; 989  : 	}
; 990  : 	else
; 991  : 	{
; 992  : 		return false;

	xor	al, al

; 993  : 	}
; 994  : }

	ret	4
?IsSpyInCity@CvPlayerEspionage@@QAE_NI@Z ENDP		; CvPlayerEspionage::IsSpyInCity
_TEXT	ENDS
PUBLIC	?IsDiplomat@CvPlayerEspionage@@QAE_NI@Z		; CvPlayerEspionage::IsDiplomat
; Function compile flags: /Ogtpy
;	COMDAT ?IsDiplomat@CvPlayerEspionage@@QAE_NI@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?IsDiplomat@CvPlayerEspionage@@QAE_NI@Z PROC		; CvPlayerEspionage::IsDiplomat, COMDAT
; _this$ = ecx

; 1631 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 1632 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jb	SHORT $LN1@IsDiplomat

; 1633 : 	{
; 1634 : 		return false;

	xor	al, al

; 1638 : }

	ret	4
$LN1@IsDiplomat:

; 1635 : 	}
; 1636 : 
; 1637 : 	return m_aSpyList[uiSpyIndex].m_bIsDiplomat;

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [eax+edx*4+24]

; 1638 : }

	ret	4
?IsDiplomat@CvPlayerEspionage@@QAE_NI@Z ENDP		; CvPlayerEspionage::IsDiplomat
_TEXT	ENDS
PUBLIC	?IsSchmoozing@CvPlayerEspionage@@QAE_NI@Z	; CvPlayerEspionage::IsSchmoozing
; Function compile flags: /Ogtpy
;	COMDAT ?IsSchmoozing@CvPlayerEspionage@@QAE_NI@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?IsSchmoozing@CvPlayerEspionage@@QAE_NI@Z PROC		; CvPlayerEspionage::IsSchmoozing, COMDAT
; _this$ = ecx

; 1642 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 1643 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jb	SHORT $LN3@IsSchmoozi

; 1644 : 	{
; 1645 : 		return false;

	xor	al, al

; 1649 : 	{
; 1650 : 		return true;
; 1651 : 	}
; 1652 : 	else
; 1653 : 	{
; 1654 : 		return false;
; 1655 : 	}
; 1656 : }

	ret	4
$LN3@IsSchmoozi:

; 1646 : 	}
; 1647 : 
; 1648 : 	if (m_aSpyList[uiSpyIndex].m_eSpyState == SPY_STATE_SCHMOOZE)

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax+edx*4+16], 7
	sete	al

; 1649 : 	{
; 1650 : 		return true;
; 1651 : 	}
; 1652 : 	else
; 1653 : 	{
; 1654 : 		return false;
; 1655 : 	}
; 1656 : }

	ret	4
?IsSchmoozing@CvPlayerEspionage@@QAE_NI@Z ENDP		; CvPlayerEspionage::IsSchmoozing
_TEXT	ENDS
PUBLIC	?GetNumSpies@CvPlayerEspionage@@QAEHXZ		; CvPlayerEspionage::GetNumSpies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumSpies@CvPlayerEspionage@@QAEHXZ
_TEXT	SEGMENT
?GetNumSpies@CvPlayerEspionage@@QAEHXZ PROC		; CvPlayerEspionage::GetNumSpies, COMDAT
; _this$ = ecx

; 2226 : 	return m_aSpyList.size();

	mov	eax, DWORD PTR [ecx+8]

; 2227 : }

	ret	0
?GetNumSpies@CvPlayerEspionage@@QAEHXZ ENDP		; CvPlayerEspionage::GetNumSpies
_TEXT	ENDS
PUBLIC	?GetNumAliveSpies@CvPlayerEspionage@@QAEHXZ	; CvPlayerEspionage::GetNumAliveSpies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAliveSpies@CvPlayerEspionage@@QAEHXZ
_TEXT	SEGMENT
?GetNumAliveSpies@CvPlayerEspionage@@QAEHXZ PROC	; CvPlayerEspionage::GetNumAliveSpies, COMDAT
; _this$ = ecx

; 2231 : {

	mov	edx, DWORD PTR [ecx+8]

; 2232 : 	int iCount = 0;

	xor	eax, eax

; 2233 : 	for(uint ui = 0; ui < m_aSpyList.size(); ui++)

	test	edx, edx
	jbe	SHORT $LN2@GetNumAliv
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 16					; 00000010H
	npad	1
$LL4@GetNumAliv:

; 2234 : 	{
; 2235 : 		if(m_aSpyList[ui].m_eSpyState != SPY_STATE_DEAD)

	cmp	DWORD PTR [ecx], 8
	je	SHORT $LN3@GetNumAliv

; 2236 : 		{
; 2237 : 			iCount++;

	inc	eax
$LN3@GetNumAliv:

; 2233 : 	for(uint ui = 0; ui < m_aSpyList.size(); ui++)

	add	ecx, 28					; 0000001cH
	sub	edx, 1
	jne	SHORT $LL4@GetNumAliv
$LN2@GetNumAliv:

; 2238 : 		}
; 2239 : 	}
; 2240 : 
; 2241 : 	return iCount;
; 2242 : }

	ret	0
?GetNumAliveSpies@CvPlayerEspionage@@QAEHXZ ENDP	; CvPlayerEspionage::GetNumAliveSpies
_TEXT	ENDS
PUBLIC	?GetNumAssignedSpies@CvPlayerEspionage@@QAEHXZ	; CvPlayerEspionage::GetNumAssignedSpies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAssignedSpies@CvPlayerEspionage@@QAEHXZ
_TEXT	SEGMENT
?GetNumAssignedSpies@CvPlayerEspionage@@QAEHXZ PROC	; CvPlayerEspionage::GetNumAssignedSpies, COMDAT
; _this$ = ecx

; 2246 : {

	push	esi

; 2247 : 	int iCount = 0;
; 2248 : 	for(uint ui = 0; ui < m_aSpyList.size(); ui++)

	mov	esi, DWORD PTR [ecx+8]
	xor	eax, eax
	xor	edx, edx
	test	esi, esi
	jbe	SHORT $LN3@GetNumAssi
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 4
$LL5@GetNumAssi:

; 2249 : 	{
; 2250 : 		if(m_aSpyList[ui].m_eSpyState == SPY_STATE_DEAD)

	cmp	DWORD PTR [ecx+12], 8
	je	SHORT $LN4@GetNumAssi

; 2251 : 		{
; 2252 : 			continue;
; 2253 : 		}
; 2254 : 
; 2255 : 		if(IsSpyInCity(ui))

	cmp	edx, esi
	jae	SHORT $LN4@GetNumAssi
	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN4@GetNumAssi
	cmp	DWORD PTR [ecx+4], -1
	je	SHORT $LN4@GetNumAssi

; 2256 : 		{
; 2257 : 			iCount++;

	inc	eax
$LN4@GetNumAssi:

; 2247 : 	int iCount = 0;
; 2248 : 	for(uint ui = 0; ui < m_aSpyList.size(); ui++)

	inc	edx
	add	ecx, 28					; 0000001cH
	cmp	edx, esi
	jb	SHORT $LL5@GetNumAssi
$LN3@GetNumAssi:
	pop	esi

; 2258 : 		}
; 2259 : 	}
; 2260 : 
; 2261 : 	return iCount;
; 2262 : }

	ret	0
?GetNumAssignedSpies@CvPlayerEspionage@@QAEHXZ ENDP	; CvPlayerEspionage::GetNumAssignedSpies
_TEXT	ENDS
PUBLIC	?GetNumUnassignedSpies@CvPlayerEspionage@@QAEHXZ ; CvPlayerEspionage::GetNumUnassignedSpies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumUnassignedSpies@CvPlayerEspionage@@QAEHXZ
_TEXT	SEGMENT
?GetNumUnassignedSpies@CvPlayerEspionage@@QAEHXZ PROC	; CvPlayerEspionage::GetNumUnassignedSpies, COMDAT
; _this$ = ecx

; 2266 : {

	mov	edx, DWORD PTR [ecx+8]
	push	esi

; 2267 : 	return GetNumAliveSpies() - GetNumAssignedSpies();

	xor	esi, esi
	test	edx, edx
	jbe	SHORT $LN4@GetNumUnas
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 16					; 00000010H
$LL6@GetNumUnas:
	cmp	DWORD PTR [eax], 8
	je	SHORT $LN5@GetNumUnas
	inc	esi
$LN5@GetNumUnas:
	add	eax, 28					; 0000001cH
	sub	edx, 1
	jne	SHORT $LL6@GetNumUnas
$LN4@GetNumUnas:
	call	?GetNumAssignedSpies@CvPlayerEspionage@@QAEHXZ ; CvPlayerEspionage::GetNumAssignedSpies
	sub	esi, eax
	mov	eax, esi
	pop	esi

; 2268 : }

	ret	0
?GetNumUnassignedSpies@CvPlayerEspionage@@QAEHXZ ENDP	; CvPlayerEspionage::GetNumUnassignedSpies
_TEXT	ENDS
PUBLIC	?IsTechStealable@CvPlayerEspionage@@QAE_NW4PlayerTypes@@W4TechTypes@@@Z ; CvPlayerEspionage::IsTechStealable
; Function compile flags: /Ogtpy
;	COMDAT ?IsTechStealable@CvPlayerEspionage@@QAE_NW4PlayerTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eTech$ = 12						; size = 4
?IsTechStealable@CvPlayerEspionage@@QAE_NW4PlayerTypes@@W4TechTypes@@@Z PROC ; CvPlayerEspionage::IsTechStealable, COMDAT
; _this$ = ecx

; 2334 : 	CvAssertMsg((uint)ePlayer < m_aaPlayerStealableTechList.size(), "ePlayer out of bounds");
; 2335 : 	if((uint)ePlayer >= m_aaPlayerStealableTechList.size())

	mov	edx, DWORD PTR _ePlayer$[esp-4]
	cmp	edx, DWORD PTR [ecx+268]
	jb	SHORT $LN5@IsTechStea

; 2336 : 	{
; 2337 : 		return false;

	xor	al, al

; 2349 : }

	ret	8
$LN5@IsTechStea:

; 2338 : 	}
; 2339 : 
; 2340 : 	for(uint ui = 0; ui < m_aaPlayerStealableTechList[ePlayer].size(); ui++)

	mov	ecx, DWORD PTR [ecx+264]
	lea	edx, DWORD PTR [edx+edx*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [edx+4]
	xor	eax, eax
	push	esi
	test	ecx, ecx
	jbe	SHORT $LN2@IsTechStea
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR _eTech$[esp]
	npad	3
$LL4@IsTechStea:

; 2341 : 	{
; 2342 : 		if(m_aaPlayerStealableTechList[ePlayer][ui] == eTech)

	cmp	DWORD PTR [edx], esi
	je	SHORT $LN19@IsTechStea
	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jb	SHORT $LL4@IsTechStea
$LN2@IsTechStea:

; 2345 : 		}
; 2346 : 	}
; 2347 : 
; 2348 : 	return false;

	xor	al, al
	pop	esi

; 2349 : }

	ret	8
$LN19@IsTechStea:

; 2343 : 		{
; 2344 : 			return true;

	mov	al, 1
	pop	esi

; 2349 : }

	ret	8
?IsTechStealable@CvPlayerEspionage@@QAE_NW4PlayerTypes@@W4TechTypes@@@Z ENDP ; CvPlayerEspionage::IsTechStealable
_TEXT	ENDS
PUBLIC	?GetNumTechsToSteal@CvPlayerEspionage@@QAEHW4PlayerTypes@@@Z ; CvPlayerEspionage::GetNumTechsToSteal
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTechsToSteal@CvPlayerEspionage@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?GetNumTechsToSteal@CvPlayerEspionage@@QAEHW4PlayerTypes@@@Z PROC ; CvPlayerEspionage::GetNumTechsToSteal, COMDAT
; _this$ = ecx

; 2354 : 	CvAssertMsg((uint)ePlayer < m_aiNumTechsToStealList.size(), "ePlayer out of bounds");
; 2355 : 	if((uint)ePlayer >= m_aiNumTechsToStealList.size())

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	cmp	eax, DWORD PTR [ecx+724]
	jb	SHORT $LN1@GetNumTech

; 2356 : 	{
; 2357 : 		return -1;

	or	eax, -1

; 2361 : }

	ret	4
$LN1@GetNumTech:

; 2358 : 	}
; 2359 : 
; 2360 : 	return m_aiNumTechsToStealList[ePlayer];

	mov	ecx, DWORD PTR [ecx+720]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2361 : }

	ret	4
?GetNumTechsToSteal@CvPlayerEspionage@@QAEHW4PlayerTypes@@@Z ENDP ; CvPlayerEspionage::GetNumTechsToSteal
_TEXT	ENDS
PUBLIC	??0IntrigueNotificationMessage@@QAE@XZ		; IntrigueNotificationMessage::IntrigueNotificationMessage
; Function compile flags: /Ogtpy
;	COMDAT ??0IntrigueNotificationMessage@@QAE@XZ
_TEXT	SEGMENT
??0IntrigueNotificationMessage@@QAE@XZ PROC		; IntrigueNotificationMessage::IntrigueNotificationMessage, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+36]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0IntrigueNotificationMessage@@QAE@XZ ENDP		; IntrigueNotificationMessage::IntrigueNotificationMessage
_TEXT	ENDS
PUBLIC	??1IntrigueNotificationMessage@@QAE@XZ		; IntrigueNotificationMessage::~IntrigueNotificationMessage
; Function compile flags: /Ogtpy
;	COMDAT ??1IntrigueNotificationMessage@@QAE@XZ
_TEXT	SEGMENT
??1IntrigueNotificationMessage@@QAE@XZ PROC		; IntrigueNotificationMessage::~IntrigueNotificationMessage, COMDAT
; _this$ = ecx
	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1IntrigueNotificationMessage@@QAE@XZ ENDP		; IntrigueNotificationMessage::~IntrigueNotificationMessage
_TEXT	ENDS
PUBLIC	?GetRecentIntrigueInfo@CvPlayerEspionage@@QAEPAUIntrigueNotificationMessage@@W4PlayerTypes@@@Z ; CvPlayerEspionage::GetRecentIntrigueInfo
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetRecentIntrigueInfo@CvPlayerEspionage@@QAEPAUIntrigueNotificationMessage@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_eTargetPlayer$ = 8					; size = 4
?GetRecentIntrigueInfo@CvPlayerEspionage@@QAEPAUIntrigueNotificationMessage@@W4PlayerTypes@@@Z PROC ; CvPlayerEspionage::GetRecentIntrigueInfo, COMDAT
; _this$ = ecx

; 3534 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3535 : 	/// GetRecentIntriguePlotter: returns the player id of whoever is currently plotting against this player
; 3536 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [esi+1288]
	sub	ecx, DWORD PTR [esi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	xor	edi, edi
	add	eax, edx
	je	SHORT $LN4@GetRecentI
	xor	ebp, ebp
	npad	7
$LL6@GetRecentI:

; 3537 : 	{
; 3538 : 		// if we've already shared this information, don't count it
; 3539 : 		if(m_aIntrigueNotificationMessages[ui].m_bShared)

	mov	ecx, DWORD PTR [esi+1284]
	cmp	BYTE PTR [ecx+ebp+64], 0
	lea	ebx, DWORD PTR [ecx+ebp]
	jne	SHORT $LN5@GetRecentI

; 3540 : 		{
; 3541 : 			continue;
; 3542 : 		}
; 3543 : 
; 3544 : 		// if the message isn't about the target, ignore
; 3545 : 		if(m_aIntrigueNotificationMessages[ui].m_eTargetPlayer != eTargetPlayer)

	mov	edx, DWORD PTR _eTargetPlayer$[esp+12]
	cmp	DWORD PTR [ebx+8], edx
	jne	SHORT $LN5@GetRecentI

; 3546 : 		{
; 3547 : 			continue;
; 3548 : 		}
; 3549 : 
; 3550 : 		// if the message is too long ago, ignore
; 3551 : 		if(m_aIntrigueNotificationMessages[ui].m_iTurnNum < (GC.getGame().getGameTurn() - iIntrigueTurnsValid))  // todo: make 5 an xml global

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, 5
	cmp	DWORD PTR [ebx+24], eax
	jge	SHORT $LN1@GetRecentI
$LN5@GetRecentI:

; 3535 : 	/// GetRecentIntriguePlotter: returns the player id of whoever is currently plotting against this player
; 3536 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [esi+1288]
	sub	ecx, DWORD PTR [esi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	add	ebp, 68					; 00000044H
	cmp	edi, eax
	jb	SHORT $LL6@GetRecentI
$LN4@GetRecentI:
	pop	edi
	pop	esi
	pop	ebp

; 3557 : 	}
; 3558 : 
; 3559 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 3560 : }

	ret	4
$LN1@GetRecentI:

; 3552 : 		{
; 3553 : 			continue;
; 3554 : 		}
; 3555 : 
; 3556 : 		return &(m_aIntrigueNotificationMessages[ui]);

	mov	edx, DWORD PTR [esi+1284]
	mov	ecx, edi
	shl	ecx, 4
	add	ecx, edi
	pop	edi
	pop	esi
	pop	ebp
	lea	eax, DWORD PTR [edx+ecx*4]
	pop	ebx

; 3560 : }

	ret	4
?GetRecentIntrigueInfo@CvPlayerEspionage@@QAEPAUIntrigueNotificationMessage@@W4PlayerTypes@@@Z ENDP ; CvPlayerEspionage::GetRecentIntrigueInfo
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ ; CvPlayerEspionage::GetLogFileName
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T234423 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ PROC ; CvPlayerEspionage::GetLogFileName, COMDAT
; _this$ = ecx

; 3698 : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	DWORD PTR $T234423[esp+20], 0

; 3699 : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3700 : 	strLogName = "EspionageLog.csv";
; 3701 : 	return strLogName;

	push	OFFSET $SG224642
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR $T234423[esp+24], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 3702 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ$0:
	mov	eax, DWORD PTR $T234423[ebp]
	and	eax, 1
	je	$LN4@GetLogFile
	and	DWORD PTR $T234423[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN4@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ ENDP ; CvPlayerEspionage::GetLogFileName
PUBLIC	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$3
__ehfuncinfo$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z
_TEXT	SEGMENT
_strBaseString$224649 = -124				; size = 28
_strOutBuf$224648 = -96					; size = 28
$T234443 = -68						; size = 28
$T234444 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z PROC ; CvPlayerEspionage::LogEspionageMsg, COMDAT
; _this$ = ecx

; 3705 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	edi
	mov	edi, ecx

; 3706 : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogEspiona
	push	esi

; 3707 : 	{
; 3708 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224648[esp+132]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3709 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224649[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+140], 1

; 3710 : 		FILogFile* pLog;
; 3711 : 
; 3712 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR $T234443[esp+132]
	push	eax
	mov	ecx, edi
	call	?GetLogFileName@CvPlayerEspionage@@QBE?AVCvString@@XZ ; CvPlayerEspionage::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T234443[esp+132]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+140], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3713 : 
; 3714 : 		// Get the leading info for this line
; 3715 : 		strBaseString.Format("%03d,", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224649[esp+136]
	push	OFFSET $SG224652
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3716 : 		strBaseString += m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi+1296]
	add	esp, 12					; 0000000cH
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224649[esp+136]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3717 : 		strBaseString += ",";

	push	OFFSET $SG224653
	lea	ecx, DWORD PTR _strBaseString$224649[esp+136]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3718 : 		strOutBuf = strBaseString + strMsg;

	mov	edx, DWORD PTR _strMsg$[esp+128]
	push	edx
	lea	eax, DWORD PTR _strBaseString$224649[esp+136]
	push	eax
	lea	ecx, DWORD PTR $T234444[esp+140]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+140], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224648[esp+136]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T234444[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3719 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224648[esp+132]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 3720 : 	}

	lea	ecx, DWORD PTR _strBaseString$224649[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$224648[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
$LN1@LogEspiona:

; 3721 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$224648[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$224649[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$2:
	lea	ecx, DWORD PTR $T234443[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z$3:
	lea	ecx, DWORD PTR $T234444[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ENDP ; CvPlayerEspionage::LogEspionageMsg
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvPlayerEspionage@@@Z ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4BuildingTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvPlayerEspionage@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
tv634 = 8						; size = 4
$T234505 = 8						; size = 4
$T234504 = 8						; size = 4
$T234503 = 8						; size = 4
$T234501 = 8						; size = 4
$T234500 = 8						; size = 4
$T234499 = 8						; size = 4
_uiCiv$224751 = 8					; size = 4
$T234497 = 8						; size = 4
$T234496 = 8						; size = 4
$T234495 = 8						; size = 4
_saveTo$ = 8						; size = 4
$T234502 = 12						; size = 4
$T234498 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerEspionage@@@Z PROC ; operator<<, COMDAT

; 3838 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3839 : 	uint uiVersion = 0;
; 3840 : 	saveTo << uiVersion;

	mov	edi, DWORD PTR _saveTo$[esp+16]
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	xor	ebp, ebp
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+24], ebp
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3841 : 
; 3842 : 	saveTo << readFrom.m_aSpyList.size();

	mov	esi, DWORD PTR _readFrom$[esp+16]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T234495[esp+16]
	mov	DWORD PTR $T234495[esp+16], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3843 : 	for(uint i = 0; i < readFrom.m_aSpyList.size(); i++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebp
	jbe	SHORT $LN28@operator@4
	npad	7
$LL30@operator@4:

; 3844 : 	{
; 3845 : 		saveTo << readFrom.m_aSpyList[i];

	mov	eax, DWORD PTR [esi+4]
	add	eax, ebp
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABVCvEspionageSpy@@@Z ; operator<<
	inc	ebx
	add	esp, 8
	add	ebp, 28					; 0000001cH
	cmp	ebx, DWORD PTR [esi+8]
	jb	SHORT $LL30@operator@4
$LN28@operator@4:

; 3846 : 	}
; 3847 : 
; 3848 : 	saveTo << readFrom.m_aiSpyListNameOrder.size();

	mov	ecx, DWORD PTR [esi+252]
	sub	ecx, DWORD PTR [esi+248]
	lea	edx, DWORD PTR $T234496[esp+16]
	sar	ecx, 2
	mov	DWORD PTR $T234496[esp+16], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3849 : 	for(uint ui = 0; ui < readFrom.m_aiSpyListNameOrder.size(); ui++)

	mov	eax, DWORD PTR [esi+252]
	sub	eax, DWORD PTR [esi+248]
	xor	ebp, ebp
	sar	eax, 2
	xor	ebx, ebx
	test	eax, eax
	jbe	SHORT $LN25@operator@4
	npad	2
$LL27@operator@4:
	mov	ecx, DWORD PTR [esi+248]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 3850 : 	{
; 3851 : 		saveTo << readFrom.m_aiSpyListNameOrder[ui];

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+252]
	sub	eax, DWORD PTR [esi+248]
	inc	ebx
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LL27@operator@4
$LN25@operator@4:

; 3852 : 	}
; 3853 : 
; 3854 : 	saveTo << readFrom.m_iSpyListNameOrderIndex;

	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3855 : 
; 3856 : 	saveTo << readFrom.m_aaPlayerStealableTechList.size();

	mov	edx, DWORD PTR [esi+268]
	lea	eax, DWORD PTR $T234497[esp+16]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T234497[esp+20], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3857 : 	for(uint uiCiv = 0; uiCiv < readFrom.m_aaPlayerStealableTechList.size(); uiCiv++)

	mov	DWORD PTR _uiCiv$224751[esp+16], ebp
	cmp	DWORD PTR [esi+268], ebp
	jbe	SHORT $LN22@operator@4
	mov	eax, DWORD PTR [esi+264]
	npad	5
$LL201@operator@4:

; 3858 : 	{
; 3859 : 		saveTo << readFrom.m_aaPlayerStealableTechList[uiCiv].size();

	mov	ecx, DWORD PTR [eax+ebp+4]
	lea	edx, DWORD PTR $T234498[esp+16]
	mov	DWORD PTR $T234498[esp+16], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3860 : 		for(uint uiTech = 0; uiTech < readFrom.m_aaPlayerStealableTechList[uiCiv].size(); uiTech++)

	mov	eax, DWORD PTR [esi+264]
	xor	ebx, ebx
	cmp	DWORD PTR [eax+ebp+4], ebx
	lea	ecx, DWORD PTR [eax+ebp]
	jbe	SHORT $LN23@operator@4
$LL21@operator@4:
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+ebx*4]

; 3861 : 		{
; 3862 : 			saveTo << readFrom.m_aaPlayerStealableTechList[uiCiv][uiTech];

	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z ; operator<<
	mov	eax, DWORD PTR [esi+264]
	inc	ebx
	lea	ecx, DWORD PTR [eax+ebp]
	add	esp, 8
	cmp	ebx, DWORD PTR [ecx+4]
	jb	SHORT $LL21@operator@4
$LN23@operator@4:

; 3857 : 	for(uint uiCiv = 0; uiCiv < readFrom.m_aaPlayerStealableTechList.size(); uiCiv++)

	mov	ecx, DWORD PTR _uiCiv$224751[esp+16]
	inc	ecx
	add	ebp, 20					; 00000014H
	mov	DWORD PTR _uiCiv$224751[esp+16], ecx
	cmp	ecx, DWORD PTR [esi+268]
	jb	SHORT $LL201@operator@4
$LN22@operator@4:

; 3863 : 		}
; 3864 : 	}
; 3865 : 
; 3866 : 	saveTo << readFrom.m_aiNumTechsToStealList.size();

	mov	edx, DWORD PTR [esi+724]
	lea	eax, DWORD PTR $T234499[esp+16]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T234499[esp+20], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3867 : 	for(uint uiCiv = 0; uiCiv < readFrom.m_aiNumTechsToStealList.size(); uiCiv++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+724], ebx
	jbe	SHORT $LN16@operator@4
	npad	9
$LL18@operator@4:
	mov	ecx, DWORD PTR [esi+720]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 3868 : 	{
; 3869 : 		saveTo << readFrom.m_aiNumTechsToStealList[uiCiv];

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+724]
	jb	SHORT $LL18@operator@4
$LN16@operator@4:

; 3870 : 	}
; 3871 : 
; 3872 : 	saveTo << MAX_MAJOR_CIVS;

	lea	eax, DWORD PTR $T234500[esp+16]
	mov	ebp, 22					; 00000016H
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T234500[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ebx, DWORD PTR [esi+824]
$LL15@operator@4:

; 3873 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 3874 : 	{
; 3875 : 		saveTo << readFrom.m_aiMaxTechCost[ui];

	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL15@operator@4

; 3876 : 	}
; 3877 : 
; 3878 : 	saveTo << MAX_MAJOR_CIVS;

	lea	ecx, DWORD PTR $T234501[esp+16]
	push	ecx
	mov	ebp, 22					; 00000016H
	mov	ecx, edi
	mov	DWORD PTR $T234501[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ebx, DWORD PTR [esi+916]
	mov	DWORD PTR tv634[esp+16], ebp
$LL200@operator@4:

; 3880 : 	{
; 3881 : 		saveTo << readFrom.m_aHeistLocations[uiCiv].size();

	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR $T234502[esp+16]
	sar	edx, 3
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T234502[esp+20], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3882 : 		for(uint ui = 0; ui < readFrom.m_aHeistLocations[uiCiv].size(); ui++)

	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
	xor	ebp, ebp
	sar	ecx, 3
	test	ecx, ecx
	jbe	SHORT $LN11@operator@4
	npad	6
$LL9@operator@4:
	mov	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ebp*8]
	add	edx, eax

; 3883 : 		{
; 3884 : 			saveTo << readFrom.m_aHeistLocations[uiCiv][ui].m_iX;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3885 : 			saveTo << readFrom.m_aHeistLocations[uiCiv][ui].m_iY;

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax+ebp*8+4]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [ebx]
	inc	ebp
	sar	edx, 3
	cmp	ebp, edx
	jb	SHORT $LL9@operator@4
$LN11@operator@4:

; 3879 : 	for(uint uiCiv = 0; uiCiv < MAX_MAJOR_CIVS; uiCiv++)

	add	ebx, 16					; 00000010H
	sub	DWORD PTR tv634[esp+16], 1
	jne	SHORT $LL200@operator@4

; 3886 : 		}
; 3887 : 	}
; 3888 : 
; 3889 : 	saveTo << readFrom.m_aSpyNotificationMessages.size();

	mov	ecx, DWORD PTR [esi+1272]
	sub	ecx, DWORD PTR [esi+1268]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T234503[esp+16]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T234503[esp+20], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3890 : 	for(uint ui = 0; ui < readFrom.m_aSpyNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [esi+1272]
	sub	ecx, DWORD PTR [esi+1268]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebp, ebp
	add	eax, edx
	je	$LN4@operator@4

; 3886 : 		}
; 3887 : 	}
; 3888 : 
; 3889 : 	saveTo << readFrom.m_aSpyNotificationMessages.size();

	xor	ebx, ebx
	npad	4
$LL6@operator@4:

; 3891 : 	{
; 3892 : #ifdef AUI_WARNING_FIXES
; 3893 : 		const SpyNotificationMessage& kSpyNotificationMessage = readFrom.m_aSpyNotificationMessages[ui];
; 3894 : 		saveTo << kSpyNotificationMessage.m_iCityX;
; 3895 : 		saveTo << kSpyNotificationMessage.m_iCityY;
; 3896 : 		saveTo << kSpyNotificationMessage.m_eAttackingPlayer;
; 3897 : 		saveTo << kSpyNotificationMessage.m_iSpyResult;
; 3898 : 		saveTo << kSpyNotificationMessage.m_eStolenTech;
; 3899 : #else
; 3900 : 		saveTo << readFrom.m_aSpyNotificationMessages[ui].m_iCityX;

	mov	ecx, DWORD PTR [esi+1268]
	add	ecx, ebx
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3901 : 		saveTo << readFrom.m_aSpyNotificationMessages[ui].m_iCityY;

	mov	edx, DWORD PTR [esi+1268]
	lea	eax, DWORD PTR [ebx+edx+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3902 : 		saveTo << readFrom.m_aSpyNotificationMessages[ui].m_eAttackingPlayer;

	mov	ecx, DWORD PTR [esi+1268]
	lea	edx, DWORD PTR [ebx+ecx+8]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 3903 : 		saveTo << readFrom.m_aSpyNotificationMessages[ui].m_iSpyResult;

	mov	eax, DWORD PTR [esi+1268]
	lea	ecx, DWORD PTR [ebx+eax+12]
	add	esp, 8
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3904 : 		saveTo << readFrom.m_aSpyNotificationMessages[ui].m_eStolenTech;

	mov	edx, DWORD PTR [esi+1268]
	lea	eax, DWORD PTR [ebx+edx+16]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z ; operator<<
	mov	ecx, DWORD PTR [esi+1272]
	sub	ecx, DWORD PTR [esi+1268]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	ebp
	add	ecx, edx
	add	esp, 8
	add	ebx, 20					; 00000014H
	cmp	ebp, ecx
	jb	$LL6@operator@4
$LN4@operator@4:

; 3905 : #endif
; 3906 : 	}
; 3907 : 
; 3908 : 	saveTo << readFrom.m_aIntrigueNotificationMessages.size();

	mov	ecx, DWORD PTR [esi+1288]
	sub	ecx, DWORD PTR [esi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T234504[esp+16]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T234504[esp+20], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3909 : 	for(uint ui = 0; ui < readFrom.m_aIntrigueNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [esi+1288]
	sub	ecx, DWORD PTR [esi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebp, ebp
	add	eax, edx
	je	$LN199@operator@4

; 3905 : #endif
; 3906 : 	}
; 3907 : 
; 3908 : 	saveTo << readFrom.m_aIntrigueNotificationMessages.size();

	xor	ebx, ebx
	npad	7
$LL3@operator@4:

; 3910 : 	{
; 3911 : #ifdef AUI_WARNING_FIXES
; 3912 : 		const IntrigueNotificationMessage& kIntrigueNotificationMessage = readFrom.m_aIntrigueNotificationMessages[ui];
; 3913 : 		saveTo << kIntrigueNotificationMessage.m_eDiscoveringPlayer;
; 3914 : 		saveTo << kIntrigueNotificationMessage.m_eSourcePlayer;
; 3915 : 		saveTo << kIntrigueNotificationMessage.m_eTargetPlayer;
; 3916 : 		saveTo << kIntrigueNotificationMessage.m_eBuilding;
; 3917 : 		saveTo << kIntrigueNotificationMessage.m_eProject;
; 3918 : 		saveTo << kIntrigueNotificationMessage.m_iIntrigueType;
; 3919 : 		saveTo << kIntrigueNotificationMessage.m_iTurnNum;
; 3920 : 		saveTo << kIntrigueNotificationMessage.m_iCityX;
; 3921 : 		saveTo << kIntrigueNotificationMessage.m_iCityY;
; 3922 : 		saveTo << kIntrigueNotificationMessage.m_strSpyName;
; 3923 : 		saveTo << kIntrigueNotificationMessage.m_bShared;
; 3924 : #else
; 3925 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_eDiscoveringPlayer;

	mov	ecx, DWORD PTR [esi+1284]
	add	ecx, ebx
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 3926 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_eSourcePlayer;

	mov	edx, DWORD PTR [esi+1284]
	lea	eax, DWORD PTR [edx+ebx+4]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 3927 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_eTargetPlayer;

	mov	ecx, DWORD PTR [esi+1284]
	lea	edx, DWORD PTR [ecx+ebx+8]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 3928 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_eBuilding;

	mov	eax, DWORD PTR [esi+1284]
	lea	ecx, DWORD PTR [eax+ebx+12]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4BuildingTypes@@@Z ; operator<<

; 3929 : 		saveTo << (int)(readFrom.m_aIntrigueNotificationMessages[ui].m_eProject);

	mov	edx, DWORD PTR [esi+1284]
	mov	eax, DWORD PTR [edx+ebx+16]
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T234505[esp+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T234505[esp+20], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3930 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_iIntrigueType;

	mov	edx, DWORD PTR [esi+1284]
	lea	eax, DWORD PTR [edx+ebx+20]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3931 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_iTurnNum;

	mov	ecx, DWORD PTR [esi+1284]
	lea	edx, DWORD PTR [ecx+ebx+24]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3932 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_iCityX;

	mov	eax, DWORD PTR [esi+1284]
	lea	ecx, DWORD PTR [eax+ebx+28]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3933 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_iCityY;

	mov	edx, DWORD PTR [esi+1284]
	lea	eax, DWORD PTR [edx+ebx+32]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3934 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_strSpyName;

	mov	ecx, DWORD PTR [esi+1284]
	lea	edx, DWORD PTR [ecx+ebx+36]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 3935 : 		saveTo << readFrom.m_aIntrigueNotificationMessages[ui].m_bShared;

	mov	eax, DWORD PTR [esi+1284]
	lea	ecx, DWORD PTR [eax+ebx+64]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	mov	ecx, DWORD PTR [esi+1288]
	sub	ecx, DWORD PTR [esi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebp
	add	eax, edx
	add	ebx, 68					; 00000044H
	cmp	ebp, eax
	jb	$LL3@operator@4
$LN199@operator@4:

; 3936 : #endif
; 3937 : 	}
; 3938 : 
; 3939 : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3940 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerEspionage@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	?Reset@CvCityEspionage@@QAEXXZ			; CvCityEspionage::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvCityEspionage@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvCityEspionage@@QAEXXZ PROC			; CvCityEspionage::Reset, COMDAT
; _this$ = ecx

; 3974 : {

	push	esi

; 3975 : 	m_pCity = NULL;

	xor	esi, esi
	mov	DWORD PTR [ecx], esi
	lea	eax, DWORD PTR [ecx+92]
	lea	edx, DWORD PTR [esi+22]
	or	ecx, -1
	npad	2
$LL3@Reset:

; 3976 : 
; 3977 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 3978 : 	{
; 3979 : 		m_aiSpyAssignment[ui] = -1;

	mov	DWORD PTR [eax-88], ecx

; 3980 : 		m_aiAmount[ui] = -1;

	mov	DWORD PTR [eax], ecx

; 3981 : 		m_aiRate[ui] = -1;

	mov	DWORD PTR [eax+88], ecx

; 3982 : 		m_aiGoal[ui] = -1;

	mov	DWORD PTR [eax+176], ecx

; 3983 : 		m_aiLastProgress[ui] = -1;

	mov	DWORD PTR [eax+264], ecx

; 3984 : 		m_aiLastPotential[ui] = -1;

	mov	DWORD PTR [eax+352], ecx

; 3985 : 		m_aiLastBasePotential[ui] = -1;

	mov	DWORD PTR [eax+440], ecx

; 3986 : 		m_aiResult[ui] = SPY_RESULT_UNDETECTED;

	mov	DWORD PTR [eax+528], esi

; 3987 : 		m_aiNumTimesCityRobbed[ui] = 0;

	mov	DWORD PTR [eax+616], esi
	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL3@Reset
	pop	esi

; 3988 : 	}
; 3989 : }

	ret	0
?Reset@CvCityEspionage@@QAEXXZ ENDP			; CvCityEspionage::Reset
_TEXT	ENDS
PUBLIC	?SetActivity@CvCityEspionage@@QAEXW4PlayerTypes@@HHH@Z ; CvCityEspionage::SetActivity
; Function compile flags: /Ogtpy
;	COMDAT ?SetActivity@CvCityEspionage@@QAEXW4PlayerTypes@@HHH@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iAmount$ = 12						; size = 4
_iRate$ = 16						; size = 4
_iGoal$ = 20						; size = 4
?SetActivity@CvCityEspionage@@QAEXW4PlayerTypes@@HHH@Z PROC ; CvCityEspionage::SetActivity, COMDAT
; _this$ = ecx

; 3994 : 	CvAssertMsg(m_aiAmount[ePlayer] == -1, "Amount has not been reset");
; 3995 : 	CvAssertMsg(m_aiRate[ePlayer] == -1, "Rate has not been reset");
; 3996 : 	CvAssertMsg(m_aiGoal[ePlayer] == -1, "Goal has not been reset");
; 3997 : 	m_aiAmount[ePlayer] = iAmount;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	edx, DWORD PTR _iAmount$[esp-4]
	mov	DWORD PTR [ecx+eax*4+92], edx

; 3998 : 	m_aiRate[ePlayer] = iRate;

	mov	edx, DWORD PTR _iRate$[esp-4]
	mov	DWORD PTR [ecx+eax*4+180], edx

; 3999 : 	m_aiGoal[ePlayer] = iGoal;

	mov	edx, DWORD PTR _iGoal$[esp-4]
	mov	DWORD PTR [ecx+eax*4+268], edx

; 4000 : }

	ret	16					; 00000010H
?SetActivity@CvCityEspionage@@QAEXW4PlayerTypes@@HHH@Z ENDP ; CvCityEspionage::SetActivity
_TEXT	ENDS
PUBLIC	?Process@CvCityEspionage@@QAEXW4PlayerTypes@@@Z	; CvCityEspionage::Process
; Function compile flags: /Ogtpy
;	COMDAT ?Process@CvCityEspionage@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?Process@CvCityEspionage@@QAEXW4PlayerTypes@@@Z PROC	; CvCityEspionage::Process, COMDAT
; _this$ = ecx

; 4005 : 	CvAssertMsg(m_aiAmount[ePlayer] != -1, "Amount has not been set");
; 4006 : 	CvAssertMsg(m_aiRate[ePlayer] != -1, "Rate has not been set");
; 4007 : 	CvAssertMsg(m_aiGoal[ePlayer] != -1, "Goal has not been set");
; 4008 : 	m_aiAmount[ePlayer] += m_aiRate[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	edx, DWORD PTR [ecx+eax*4+180]
	add	DWORD PTR [ecx+eax*4+92], edx

; 4009 : }

	ret	4
?Process@CvCityEspionage@@QAEXW4PlayerTypes@@@Z ENDP	; CvCityEspionage::Process
_TEXT	ENDS
PUBLIC	?HasReachedGoal@CvCityEspionage@@QAE_NW4PlayerTypes@@@Z ; CvCityEspionage::HasReachedGoal
; Function compile flags: /Ogtpy
;	COMDAT ?HasReachedGoal@CvCityEspionage@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?HasReachedGoal@CvCityEspionage@@QAE_NW4PlayerTypes@@@Z PROC ; CvCityEspionage::HasReachedGoal, COMDAT
; _this$ = ecx

; 4014 : 	CvAssertMsg(m_aiAmount[ePlayer] != -1, "Amount has not been set");
; 4015 : 	CvAssertMsg(m_aiRate[ePlayer] != -1, "Rate has not been set");
; 4016 : 	CvAssertMsg(m_aiGoal[ePlayer] != -1, "Goal has not been set");
; 4017 : 	return m_aiAmount[ePlayer] >= m_aiGoal[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	edx, DWORD PTR [ecx+eax*4+92]
	push	ebx
	xor	ebx, ebx
	cmp	edx, DWORD PTR [ecx+eax*4+268]
	setge	bl
	mov	al, bl
	pop	ebx

; 4018 : }

	ret	4
?HasReachedGoal@CvCityEspionage@@QAE_NW4PlayerTypes@@@Z ENDP ; CvCityEspionage::HasReachedGoal
_TEXT	ENDS
PUBLIC	?ResetProgress@CvCityEspionage@@QAEXW4PlayerTypes@@@Z ; CvCityEspionage::ResetProgress
; Function compile flags: /Ogtpy
;	COMDAT ?ResetProgress@CvCityEspionage@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?ResetProgress@CvCityEspionage@@QAEXW4PlayerTypes@@@Z PROC ; CvCityEspionage::ResetProgress, COMDAT
; _this$ = ecx

; 4023 : 	m_aiAmount[ePlayer] = -1;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	or	edx, -1
	mov	DWORD PTR [ecx+eax*4+92], edx

; 4024 : 	m_aiGoal[ePlayer] = -1;

	mov	DWORD PTR [ecx+eax*4+268], edx

; 4025 : 	m_aiRate[ePlayer] = -1;

	mov	DWORD PTR [ecx+eax*4+180], edx

; 4026 : }

	ret	4
?ResetProgress@CvCityEspionage@@QAEXW4PlayerTypes@@@Z ENDP ; CvCityEspionage::ResetProgress
_TEXT	ENDS
PUBLIC	?SetLastProgress@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ; CvCityEspionage::SetLastProgress
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastProgress@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iProgress$ = 12					; size = 4
?SetLastProgress@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z PROC ; CvCityEspionage::SetLastProgress, COMDAT
; _this$ = ecx

; 4031 : 	m_aiLastProgress[ePlayer] = iProgress;

	mov	eax, DWORD PTR _iProgress$[esp-4]
	mov	edx, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+edx*4+356], eax

; 4032 : }

	ret	8
?SetLastProgress@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ENDP ; CvCityEspionage::SetLastProgress
_TEXT	ENDS
PUBLIC	?SetLastPotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ; CvCityEspionage::SetLastPotential
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastPotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iPotential$ = 12					; size = 4
?SetLastPotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z PROC ; CvCityEspionage::SetLastPotential, COMDAT
; _this$ = ecx

; 4037 : 	m_aiLastPotential[ePlayer] = iPotential;

	mov	eax, DWORD PTR _iPotential$[esp-4]
	mov	edx, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+edx*4+444], eax

; 4038 : }

	ret	8
?SetLastPotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ENDP ; CvCityEspionage::SetLastPotential
_TEXT	ENDS
PUBLIC	?SetLastBasePotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ; CvCityEspionage::SetLastBasePotential
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastBasePotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_iPotential$ = 12					; size = 4
?SetLastBasePotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z PROC ; CvCityEspionage::SetLastBasePotential, COMDAT
; _this$ = ecx

; 4043 : 	m_aiLastBasePotential[ePlayer] = iPotential;

	mov	eax, DWORD PTR _iPotential$[esp-4]
	mov	edx, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+edx*4+532], eax

; 4044 : }

	ret	8
?SetLastBasePotential@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ENDP ; CvCityEspionage::SetLastBasePotential
_TEXT	ENDS
PUBLIC	?SetSpyResult@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ; CvCityEspionage::SetSpyResult
; Function compile flags: /Ogtpy
;	COMDAT ?SetSpyResult@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eSpyOwner$ = 8						; size = 4
_iResult$ = 12						; size = 4
?SetSpyResult@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z PROC ; CvCityEspionage::SetSpyResult, COMDAT
; _this$ = ecx

; 4049 : 	m_aiResult[eSpyOwner] = iResult;

	mov	eax, DWORD PTR _iResult$[esp-4]
	mov	edx, DWORD PTR _eSpyOwner$[esp-4]
	mov	DWORD PTR [ecx+edx*4+620], eax

; 4050 : }

	ret	8
?SetSpyResult@CvCityEspionage@@QAEXW4PlayerTypes@@H@Z ENDP ; CvCityEspionage::SetSpyResult
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvCityEspionage@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvCityEspionage@@@Z
_TEXT	SEGMENT
_uiNumSpyAssignment$ = -32				; size = 4
_uiNumAmounts$ = -28					; size = 4
_uiNumRates$ = -24					; size = 4
_uiNumGoals$ = -20					; size = 4
_iNumLastProgresses$ = -16				; size = 4
_iNumLastPotential$ = -12				; size = 4
_iNumLastBasePotential$ = -8				; size = 4
_uiVersion$ = -4					; size = 4
_iNumResults$ = 8					; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvCityEspionage@@@Z PROC	; operator>>, COMDAT

; 4060 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi

; 4061 : 	uint uiVersion;
; 4062 : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp+40]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+48]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4063 : 
; 4064 : 	uint uiNumSpyAssignment;
; 4065 : 	loadFrom >> uiNumSpyAssignment;

	lea	ecx, DWORD PTR _uiNumSpyAssignment$[esp+48]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4066 : 	for(uint ui = 0; ui < uiNumSpyAssignment; ui++)

	mov	ebp, DWORD PTR _writeTo$[esp+44]
	xor	edi, edi
	cmp	DWORD PTR _uiNumSpyAssignment$[esp+48], edi
	jbe	SHORT $LN25@operator@5

; 4061 : 	uint uiVersion;
; 4062 : 	loadFrom >> uiVersion;

	lea	ebx, DWORD PTR [ebp+4]
$LL27@operator@5:

; 4067 : 	{
; 4068 : 		loadFrom >> writeTo.m_aiSpyAssignment[ui];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _uiNumSpyAssignment$[esp+48]
	jb	SHORT $LL27@operator@5
$LN25@operator@5:

; 4069 : 	}
; 4070 : 
; 4071 : 	// amount
; 4072 : 	uint uiNumAmounts;
; 4073 : 	loadFrom >> uiNumAmounts;

	lea	edx, DWORD PTR _uiNumAmounts$[esp+48]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4074 : 	for(uint ui = 0; ui < uiNumAmounts; ui++)

	xor	edi, edi
	cmp	DWORD PTR _uiNumAmounts$[esp+48], edi
	jbe	SHORT $LN22@operator@5

; 4069 : 	}
; 4070 : 
; 4071 : 	// amount
; 4072 : 	uint uiNumAmounts;
; 4073 : 	loadFrom >> uiNumAmounts;

	lea	ebx, DWORD PTR [ebp+92]
	npad	5
$LL24@operator@5:

; 4075 : 	{
; 4076 : 		loadFrom >> writeTo.m_aiAmount[ui];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _uiNumAmounts$[esp+48]
	jb	SHORT $LL24@operator@5
$LN22@operator@5:

; 4077 : 	}
; 4078 : 
; 4079 : 	// rate
; 4080 : 	uint uiNumRates;
; 4081 : 	loadFrom >> uiNumRates;

	lea	eax, DWORD PTR _uiNumRates$[esp+48]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4082 : 	for(uint ui = 0; ui < uiNumRates; ui++)

	xor	edi, edi
	cmp	DWORD PTR _uiNumRates$[esp+48], edi
	jbe	SHORT $LN19@operator@5

; 4077 : 	}
; 4078 : 
; 4079 : 	// rate
; 4080 : 	uint uiNumRates;
; 4081 : 	loadFrom >> uiNumRates;

	lea	ebx, DWORD PTR [ebp+180]
	npad	4
$LL21@operator@5:

; 4083 : 	{
; 4084 : 		loadFrom >> writeTo.m_aiRate[ui];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _uiNumRates$[esp+48]
	jb	SHORT $LL21@operator@5
$LN19@operator@5:

; 4085 : 	}
; 4086 : 
; 4087 : 	// goal
; 4088 : 	uint uiNumGoals;
; 4089 : 	loadFrom >> uiNumGoals;

	lea	ecx, DWORD PTR _uiNumGoals$[esp+48]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4090 : 	for(uint ui = 0; ui < uiNumGoals; ui++)

	xor	edi, edi
	cmp	DWORD PTR _uiNumGoals$[esp+48], edi
	jbe	SHORT $LN16@operator@5

; 4085 : 	}
; 4086 : 
; 4087 : 	// goal
; 4088 : 	uint uiNumGoals;
; 4089 : 	loadFrom >> uiNumGoals;

	lea	ebx, DWORD PTR [ebp+268]
	npad	4
$LL18@operator@5:

; 4091 : 	{
; 4092 : 		loadFrom >> writeTo.m_aiGoal[ui];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _uiNumGoals$[esp+48]
	jb	SHORT $LL18@operator@5
$LN16@operator@5:

; 4093 : 	}
; 4094 : 
; 4095 : 	// last progress
; 4096 : 	int iNumLastProgresses;
; 4097 : 	loadFrom >> iNumLastProgresses;

	lea	edx, DWORD PTR _iNumLastProgresses$[esp+48]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4098 : 	for(int i = 0; i < iNumLastProgresses; i++)

	xor	edi, edi
	cmp	DWORD PTR _iNumLastProgresses$[esp+48], edi
	jle	SHORT $LN13@operator@5

; 4093 : 	}
; 4094 : 
; 4095 : 	// last progress
; 4096 : 	int iNumLastProgresses;
; 4097 : 	loadFrom >> iNumLastProgresses;

	lea	ebx, DWORD PTR [ebp+356]
	npad	4
$LL15@operator@5:

; 4099 : 	{
; 4100 : 		loadFrom >> writeTo.m_aiLastProgress[i];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _iNumLastProgresses$[esp+48]
	jl	SHORT $LL15@operator@5
$LN13@operator@5:

; 4101 : 	}
; 4102 : 
; 4103 : 	// last potential
; 4104 : 	int iNumLastPotential;
; 4105 : 	loadFrom >> iNumLastPotential;

	lea	eax, DWORD PTR _iNumLastPotential$[esp+48]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4106 : 	for (int i = 0; i < iNumLastPotential; i++)

	xor	edi, edi
	cmp	DWORD PTR _iNumLastPotential$[esp+48], edi
	jle	SHORT $LN10@operator@5

; 4101 : 	}
; 4102 : 
; 4103 : 	// last potential
; 4104 : 	int iNumLastPotential;
; 4105 : 	loadFrom >> iNumLastPotential;

	lea	ebx, DWORD PTR [ebp+444]
	npad	4
$LL12@operator@5:

; 4107 : 	{
; 4108 : 		loadFrom >> writeTo.m_aiLastPotential[i];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _iNumLastPotential$[esp+48]
	jl	SHORT $LL12@operator@5
$LN10@operator@5:

; 4109 : 	}
; 4110 : 
; 4111 : 	// last base potential
; 4112 : 	int iNumLastBasePotential;
; 4113 : 	loadFrom >> iNumLastBasePotential;

	lea	ecx, DWORD PTR _iNumLastBasePotential$[esp+48]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4114 : 	for (int i = 0; i < iNumLastBasePotential; i++)

	xor	edi, edi
	cmp	DWORD PTR _iNumLastBasePotential$[esp+48], edi
	jle	SHORT $LN7@operator@5

; 4109 : 	}
; 4110 : 
; 4111 : 	// last base potential
; 4112 : 	int iNumLastBasePotential;
; 4113 : 	loadFrom >> iNumLastBasePotential;

	lea	ebx, DWORD PTR [ebp+532]
	npad	4
$LL9@operator@5:

; 4115 : 	{
; 4116 : 		loadFrom >> writeTo.m_aiLastBasePotential[i];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _iNumLastBasePotential$[esp+48]
	jl	SHORT $LL9@operator@5
$LN7@operator@5:

; 4117 : 	}
; 4118 : 
; 4119 : 	// results
; 4120 : 	int iNumResults;
; 4121 : 	loadFrom >> iNumResults;

	lea	edx, DWORD PTR _iNumResults$[esp+44]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4122 : 	for(int i = 0; i < iNumResults; i++)

	xor	edi, edi
	cmp	DWORD PTR _iNumResults$[esp+44], edi
	jle	SHORT $LN4@operator@5

; 4117 : 	}
; 4118 : 
; 4119 : 	// results
; 4120 : 	int iNumResults;
; 4121 : 	loadFrom >> iNumResults;

	lea	ebx, DWORD PTR [ebp+620]
	npad	4
$LL6@operator@5:

; 4123 : 	{
; 4124 : 		loadFrom >> writeTo.m_aiResult[i];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _iNumResults$[esp+44]
	jl	SHORT $LL6@operator@5
$LN4@operator@5:

; 4125 : 	}
; 4126 : 
; 4127 : 	// num times robbed
; 4128 : 	loadFrom >> iNumResults;

	lea	eax, DWORD PTR _iNumResults$[esp+44]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4129 : 	for (int i = 0; i < iNumResults; i++)

	xor	edi, edi
	cmp	DWORD PTR _iNumResults$[esp+44], edi
	jle	SHORT $LN104@operator@5

; 4125 : 	}
; 4126 : 
; 4127 : 	// num times robbed
; 4128 : 	loadFrom >> iNumResults;

	lea	ebx, DWORD PTR [ebp+708]
	npad	4
$LL3@operator@5:

; 4130 : 	{
; 4131 : 		loadFrom >> writeTo.m_aiNumTimesCityRobbed[i];

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR _iNumResults$[esp+44]
	jl	SHORT $LL3@operator@5
$LN104@operator@5:
	pop	edi

; 4132 : 	}
; 4133 : 
; 4134 : 	return loadFrom;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 4135 : }

	add	esp, 32					; 00000020H
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvCityEspionage@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvCityEspionage@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvCityEspionage@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T234992 = 8						; size = 4
$T234991 = 8						; size = 4
$T234990 = 8						; size = 4
$T234989 = 8						; size = 4
$T234988 = 8						; size = 4
$T234987 = 8						; size = 4
$T234986 = 8						; size = 4
$T234985 = 8						; size = 4
$T234984 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvCityEspionage@@@Z PROC	; operator<<, COMDAT

; 4139 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 4140 : 	uint uiVersion = 0;
; 4141 : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+24], 0
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4142 : 
; 4143 : 	saveTo << MAX_MAJOR_CIVS;

	lea	ecx, DWORD PTR $T234984[esp+16]
	push	ecx
	mov	ebp, 22					; 00000016H
	mov	ecx, esi
	mov	DWORD PTR $T234984[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	ebx, DWORD PTR _readFrom$[esp+16]
	lea	edi, DWORD PTR [ebx+4]
	npad	7
$LL27@operator@6:

; 4144 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4145 : 	{
; 4146 : 		saveTo << readFrom.m_aiSpyAssignment[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL27@operator@6

; 4147 : 	}
; 4148 : 
; 4149 : 	// amount
; 4150 : 	saveTo << MAX_MAJOR_CIVS;

	lea	edx, DWORD PTR $T234985[esp+16]
	mov	ebp, 22					; 00000016H
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T234985[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+92]
$LL24@operator@6:

; 4151 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4152 : 	{
; 4153 : 		saveTo << readFrom.m_aiAmount[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL24@operator@6

; 4154 : 	}
; 4155 : 
; 4156 : 	// rate
; 4157 : 	saveTo << MAX_MAJOR_CIVS;

	lea	eax, DWORD PTR $T234986[esp+16]
	mov	ebp, 22					; 00000016H
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T234986[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+180]
$LL21@operator@6:

; 4158 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4159 : 	{
; 4160 : 		saveTo << readFrom.m_aiRate[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL21@operator@6

; 4161 : 	}
; 4162 : 
; 4163 : 	// goal
; 4164 : 	saveTo << MAX_MAJOR_CIVS;

	lea	ecx, DWORD PTR $T234987[esp+16]
	push	ecx
	mov	ebp, 22					; 00000016H
	mov	ecx, esi
	mov	DWORD PTR $T234987[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+268]
	npad	2
$LL18@operator@6:

; 4165 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4166 : 	{
; 4167 : 		saveTo << readFrom.m_aiGoal[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL18@operator@6

; 4168 : 	}
; 4169 : 
; 4170 : 	// last progress
; 4171 : 	saveTo << MAX_MAJOR_CIVS;

	lea	edx, DWORD PTR $T234988[esp+16]
	mov	ebp, 22					; 00000016H
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T234988[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+356]
	npad	5
$LL15@operator@6:

; 4172 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4173 : 	{
; 4174 : 		saveTo << readFrom.m_aiLastProgress[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL15@operator@6

; 4175 : 	}
; 4176 : 
; 4177 : 	// last potential
; 4178 : 	saveTo << MAX_MAJOR_CIVS;

	lea	eax, DWORD PTR $T234989[esp+16]
	mov	ebp, 22					; 00000016H
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T234989[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+444]
	npad	5
$LL12@operator@6:

; 4179 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4180 : 	{
; 4181 : 		saveTo << readFrom.m_aiLastPotential[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL12@operator@6

; 4182 : 	}
; 4183 : 
; 4184 : 	// last base potential
; 4185 : 	saveTo << MAX_MAJOR_CIVS;

	lea	ecx, DWORD PTR $T234990[esp+16]
	push	ecx
	mov	ebp, 22					; 00000016H
	mov	ecx, esi
	mov	DWORD PTR $T234990[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+532]
	npad	5
$LL9@operator@6:

; 4186 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4187 : 	{
; 4188 : 		saveTo << readFrom.m_aiLastBasePotential[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL9@operator@6

; 4189 : 	}
; 4190 : 
; 4191 : 	// results
; 4192 : 	saveTo << MAX_MAJOR_CIVS;

	lea	edx, DWORD PTR $T234991[esp+16]
	mov	ebp, 22					; 00000016H
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T234991[esp+20], ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+620]
	npad	5
$LL6@operator@6:

; 4193 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4194 : 	{
; 4195 : 		saveTo << readFrom.m_aiResult[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL6@operator@6

; 4196 : 	}
; 4197 : 
; 4198 : 	// num times robbed
; 4199 : 	saveTo << MAX_MAJOR_CIVS;

	lea	eax, DWORD PTR $T234992[esp+16]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T234992[esp+20], 22		; 00000016H
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edi, DWORD PTR [ebx+708]
	lea	ebx, DWORD PTR [ebp+22]
	npad	3
$LL3@operator@6:

; 4200 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4201 : 	{
; 4202 : 		saveTo << readFrom.m_aiNumTimesCityRobbed[ui];

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@6
	pop	edi

; 4203 : 	}
; 4204 : 
; 4205 : 	return saveTo;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 4206 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvCityEspionage@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ	; CvEspionageAI::EvaluateDiplomatSpies
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z:PROC	; CvCivilizationInfo::getSpyNames
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ:PROC ; CvPlayer::GetEspionage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ$1
__ehfuncinfo$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
tv235 = -72						; size = 4
_strMsg$226485 = -68					; size = 28
$T235098 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ PROC	; CvEspionageAI::EvaluateDiplomatSpies, COMDAT
; _this$ = ecx

; 5627 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	mov	ebx, ecx

; 5628 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	edi, eax

; 5629 : 	for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [edi+8], ebp
	jbe	$LN4@EvaluateDi
	mov	DWORD PTR tv235[esp+84], ebp
	push	esi
	npad	10
$LL6@EvaluateDi:

; 5630 : 	{
; 5631 : 		CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[ui]);

	mov	esi, DWORD PTR [edi+4]
	add	esi, DWORD PTR tv235[esp+88]

; 5632 : 		// don't process dead spies
; 5633 : 		if (pSpy->m_eSpyState == SPY_STATE_DEAD)

	cmp	DWORD PTR [esi+16], 8
	je	$LN5@EvaluateDi

; 5634 : 		{
; 5635 : 			continue;
; 5636 : 		}
; 5637 : 
; 5638 : 		if (pSpy->m_bIsDiplomat)

	cmp	BYTE PTR [esi+24], 0
	je	$LN5@EvaluateDi

; 5639 : 		{
; 5640 : 			pSpy->m_bEvaluateReassignment = true;
; 5641 : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [esi+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@EvaluateDi

; 5642 : 			{
; 5643 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$226485[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5644 : 				strMsg.Format("Re-eval: diplomat spy, %d,", ui);

	push	ebp
	lea	eax, DWORD PTR _strMsg$226485[esp+92]
	push	OFFSET $SG226486
	push	eax
	mov	DWORD PTR __$EHRec$[esp+108], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 5645 : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	ecx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	edx, DWORD PTR $T235098[esp+92]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$226485[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235098[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5646 : 				pEspionage->LogEspionageMsg(strMsg);

	lea	eax, DWORD PTR _strMsg$226485[esp+88]
	push	eax
	mov	ecx, edi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 5647 : 			}

	lea	ecx, DWORD PTR _strMsg$226485[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@EvaluateDi:
	add	DWORD PTR tv235[esp+88], 28		; 0000001cH
	inc	ebp
	cmp	ebp, DWORD PTR [edi+8]
	jb	$LL6@EvaluateDi
	pop	esi
$LN4@EvaluateDi:

; 5648 : 
; 5649 : 		}
; 5650 : 	}
; 5651 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMsg$226485[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T235098[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ ENDP	; CvEspionageAI::EvaluateDiplomatSpies
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvEspionageAI@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvEspionageAI@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T235138 = 8						; size = 4
$T235137 = 8						; size = 4
$T235136 = 8						; size = 4
$T235135 = 8						; size = 4
$T235134 = 8						; size = 4
$T235133 = 8						; size = 4
$T235132 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvEspionageAI@@@Z PROC	; operator<<, COMDAT

; 5718 : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 5719 : 	uint uiVersion = 0;
; 5720 : 	saveTo << uiVersion;

	mov	edi, DWORD PTR _saveTo$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 0
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5721 : 
; 5722 : 	saveTo << readFrom.m_aiCivOutOfTechTurn.size();

	mov	esi, DWORD PTR _readFrom$[esp+12]
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T235132[esp+12]
	mov	DWORD PTR $T235132[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5723 : 	for(uint ui = 0; ui < readFrom.m_aiCivOutOfTechTurn.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jbe	SHORT $LN19@operator@7
	npad	6
$LL21@operator@7:
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+ebx*4]

; 5724 : 	{
; 5725 : 		saveTo << readFrom.m_aiCivOutOfTechTurn[ui];

	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jb	SHORT $LL21@operator@7
$LN19@operator@7:

; 5726 : 	}
; 5727 : 
; 5728 : 	saveTo << readFrom.m_aiNumSpiesCaught.size();

	mov	edx, DWORD PTR [esi+112]
	lea	eax, DWORD PTR $T235133[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T235133[esp+16], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5729 : 	for(uint ui = 0; ui < readFrom.m_aiNumSpiesCaught.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+112], ebx
	jbe	SHORT $LN16@operator@7
	npad	2
$LL18@operator@7:
	mov	ecx, DWORD PTR [esi+108]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 5730 : 	{
; 5731 : 		saveTo << readFrom.m_aiNumSpiesCaught[ui];

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+112]
	jb	SHORT $LL18@operator@7
$LN16@operator@7:

; 5732 : 	}
; 5733 : 
; 5734 : 	saveTo << readFrom.m_aiNumSpiesKilled.size();

	mov	eax, DWORD PTR [esi+216]
	lea	ecx, DWORD PTR $T235134[esp+12]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T235134[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5735 : 	for(uint ui = 0; ui < readFrom.m_aiNumSpiesKilled.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+216], ebx
	jbe	SHORT $LN13@operator@7
$LL15@operator@7:
	mov	edx, DWORD PTR [esi+212]
	lea	eax, DWORD PTR [edx+ebx*4]

; 5736 : 	{
; 5737 : 		saveTo << readFrom.m_aiNumSpiesKilled[ui];

	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+216]
	jb	SHORT $LL15@operator@7
$LN13@operator@7:

; 5738 : 	}
; 5739 : 
; 5740 : 	saveTo << readFrom.m_aiNumSpiesDied.size();

	mov	ecx, DWORD PTR [esi+320]
	lea	edx, DWORD PTR $T235135[esp+12]
	mov	DWORD PTR $T235135[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5741 : 	for(uint ui = 0; ui < readFrom.m_aiNumSpiesDied.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+320], ebx
	jbe	SHORT $LN10@operator@7
	npad	2
$LL12@operator@7:
	mov	eax, DWORD PTR [esi+316]
	lea	ecx, DWORD PTR [eax+ebx*4]

; 5742 : 	{
; 5743 : 		saveTo << readFrom.m_aiNumSpiesDied[ui];

	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+320]
	jb	SHORT $LL12@operator@7
$LN10@operator@7:

; 5744 : 	}
; 5745 : 
; 5746 : 	saveTo << readFrom.m_aiTurnLastSpyCaught.size();

	mov	edx, DWORD PTR [esi+424]
	lea	eax, DWORD PTR $T235136[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T235136[esp+16], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5747 : 	for(uint ui = 0; ui < readFrom.m_aiTurnLastSpyCaught.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+424], ebx
	jbe	SHORT $LN7@operator@7
	npad	6
$LL9@operator@7:
	mov	ecx, DWORD PTR [esi+420]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 5748 : 	{
; 5749 : 		saveTo << readFrom.m_aiTurnLastSpyCaught[ui];

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+424]
	jb	SHORT $LL9@operator@7
$LN7@operator@7:

; 5750 : 	}
; 5751 : 
; 5752 : 	saveTo << readFrom.m_aiTurnLastSpyKilled.size();

	mov	eax, DWORD PTR [esi+528]
	lea	ecx, DWORD PTR $T235137[esp+12]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T235137[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5753 : 	for(uint ui = 0; ui < readFrom.m_aiTurnLastSpyKilled.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+528], ebx
	jbe	SHORT $LN4@operator@7
	npad	6
$LL6@operator@7:
	mov	edx, DWORD PTR [esi+524]
	lea	eax, DWORD PTR [edx+ebx*4]

; 5754 : 	{
; 5755 : 		saveTo << readFrom.m_aiTurnLastSpyKilled[ui];

	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+528]
	jb	SHORT $LL6@operator@7
$LN4@operator@7:

; 5756 : 	}
; 5757 : 
; 5758 : 	saveTo << readFrom.m_aiTurnLastSpyDied.size();

	mov	ecx, DWORD PTR [esi+632]
	lea	edx, DWORD PTR $T235138[esp+12]
	mov	DWORD PTR $T235138[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5759 : 	for(uint ui = 0; ui < readFrom.m_aiTurnLastSpyDied.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+632], ebx
	jbe	SHORT $LN1@operator@7
	npad	6
$LL3@operator@7:
	mov	eax, DWORD PTR [esi+628]
	lea	ecx, DWORD PTR [eax+ebx*4]

; 5760 : 	{
; 5761 : 		saveTo << readFrom.m_aiTurnLastSpyDied[ui];

	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+632]
	jb	SHORT $LL3@operator@7
$LN1@operator@7:

; 5762 : 	}
; 5763 : 
; 5764 : 	saveTo << readFrom.m_bUNCountdownStarted;

	lea	edx, DWORD PTR [esi+732]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 5765 : 	saveTo << readFrom.m_iTurnEspionageStarted;

	add	esi, 736				; 000002e0H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5766 : 
; 5767 : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 5768 : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvEspionageAI@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@H$0A@@@QAEXXZ		; BaseVector<int,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@H$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@H$0A@@@QAEXXZ PROC			; BaseVector<int,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@H$0A@@@QAEXXZ ENDP			; BaseVector<int,0>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvEspionageSpy,8,0,297,0>::FStaticVector<CvEspionageSpy,8,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvEspionageSpy,8,0,297,0>::FStaticVector<CvEspionageSpy,8,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvEspionageSpy,8,0,297,0>::FStaticVector<CvEspionageSpy,8,0,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvEspionageSpy@@$0A@@@QAEXXZ ; BaseVector<CvEspionageSpy,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvEspionageSpy@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvEspionageSpy@@$0A@@@QAEXXZ PROC	; BaseVector<CvEspionageSpy,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvEspionageSpy@@$0A@@@QAEXXZ ENDP	; BaseVector<CvEspionageSpy,0>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 22			; 00000016H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@W4TechTypes@@$0A@@@QAEXXZ	; BaseVector<enum TechTypes,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@W4TechTypes@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@W4TechTypes@@$0A@@@QAEXXZ PROC	; BaseVector<enum TechTypes,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@W4TechTypes@@$0A@@@QAEXXZ ENDP	; BaseVector<enum TechTypes,0>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,22,0,297,0>::FStaticVector<int,22,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,22,0,297,0>::FStaticVector<int,22,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 22			; 00000016H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,22,0,297,0>::FStaticVector<int,22,0,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEAAUIntrigueNotificationMessage@@XZ ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEAAUIntrigueNotificationMessage@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEAAUIntrigueNotificationMessage@@XZ PROC ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEAAUIntrigueNotificationMessage@@XZ ENDP ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 68			; 00000044H

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::_Vector_val<HeistLocation,std::allocator<HeistLocation> >::~_Vector_val<HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<HeistLocation,std::allocator<HeistLocation> >::~_Vector_val<HeistLocation,std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<HeistLocation,std::allocator<HeistLocation> >::~_Vector_val<HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ; std::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ; std::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXPAVCvEspionageSpy@@I@Z ; FStaticVector<CvEspionageSpy,8,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXPAVCvEspionageSpy@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXPAVCvEspionageSpy@@I@Z PROC ; FStaticVector<CvEspionageSpy,8,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXPAVCvEspionageSpy@@I@Z ENDP ; FStaticVector<CvEspionageSpy,8,0,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@ABV0@@Z PROC ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>, COMDAT
; _this$ = ecx

; 591  : 	FStaticVector(const THIS_TYPE& RHS)

	push	ebx

; 592  : 	{
; 593  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebx, DWORD PTR _RHS$[esp]
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax

; 594  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	mov	DWORD PTR [esi+8], ecx

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebx+8]
	cmp	edi, 1
	jbe	SHORT $LN6@FStaticVec@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	edx, DWORD PTR [edi*4]
	push	4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@W4TechTypes@@$0A@@@IAEXABV1@@Z ; BaseVector<enum TechTypes,0>::Copy
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

$LN6@FStaticVec@2:
	lea	eax, DWORD PTR [esi+12]

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 1
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@W4TechTypes@@$0A@@@IAEXABV1@@Z ; BaseVector<enum TechTypes,0>::Copy
	pop	edi

; 600  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXPAW4TechTypes@@I@Z ; FStaticVector<enum TechTypes,1,0,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXPAW4TechTypes@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXPAW4TechTypes@@I@Z PROC ; FStaticVector<enum TechTypes,1,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@3:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXPAW4TechTypes@@I@Z ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,22,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	5
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN33@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 22			; 00000016H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN1@GrowSize
	mov	ecx, ebp
$LL3@GrowSize:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN2@GrowSize
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN2@GrowSize:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize
$LN1@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN37@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN37@GrowSize:
	pop	edi

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+100], 1
	pop	esi
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,22,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z ; std::_Vector_val<HeistLocation,std::allocator<HeistLocation> >::_Vector_val<HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z PROC ; std::_Vector_val<HeistLocation,std::allocator<HeistLocation> >::_Vector_val<HeistLocation,std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE@V?$allocator@UHeistLocation@@@1@@Z ENDP ; std::_Vector_val<HeistLocation,std::allocator<HeistLocation> >::_Vector_val<HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z ; std::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z PROC ; std::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE@V?$allocator@USpyNotificationMessage@@@1@@Z ENDP ; std::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_val<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z ; std::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z PROC ; std::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE@V?$allocator@UIntrigueNotificationMessage@@@1@@Z ENDP ; std::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_val<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z PROC ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@PAUIntrigueNotificationMessage@@@Z ENDP ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z ; std::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z PROC ; std::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE@V?$allocator@UScoreCityEntry@@@1@@Z ENDP ; std::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_val<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@PAUScoreCityEntry@@@Z ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBEIXZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UHeistLocation@@@std@@QAEPAUHeistLocation@@I@Z ; std::allocator<HeistLocation>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UHeistLocation@@@std@@QAEPAUHeistLocation@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UHeistLocation@@@std@@QAEPAUHeistLocation@@I@Z PROC ; std::allocator<HeistLocation>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UHeistLocation@@@std@@YAPAUHeistLocation@@IPAU1@@Z ; std::_Allocate<HeistLocation>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UHeistLocation@@@std@@QAEPAUHeistLocation@@I@Z ENDP ; std::allocator<HeistLocation>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 214748364				; 0cccccccH

; 732  : 		}

	ret	0
?max_size@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@USpyNotificationMessage@@@std@@QAEPAUSpyNotificationMessage@@I@Z ; std::allocator<SpyNotificationMessage>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@USpyNotificationMessage@@@std@@QAEPAUSpyNotificationMessage@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@USpyNotificationMessage@@@std@@QAEPAUSpyNotificationMessage@@I@Z PROC ; std::allocator<SpyNotificationMessage>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@USpyNotificationMessage@@@std@@YAPAUSpyNotificationMessage@@IPAU1@@Z ; std::_Allocate<SpyNotificationMessage>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@USpyNotificationMessage@@@std@@QAEPAUSpyNotificationMessage@@I@Z ENDP ; std::allocator<SpyNotificationMessage>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 63161283				; 03c3c3c3H

; 732  : 		}

	ret	0
?max_size@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBEIXZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEPAUIntrigueNotificationMessage@@I@Z ; std::allocator<IntrigueNotificationMessage>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEPAUIntrigueNotificationMessage@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEPAUIntrigueNotificationMessage@@I@Z PROC ; std::allocator<IntrigueNotificationMessage>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UIntrigueNotificationMessage@@@std@@YAPAUIntrigueNotificationMessage@@IPAU1@@Z ; std::_Allocate<IntrigueNotificationMessage>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UIntrigueNotificationMessage@@@std@@QAEPAUIntrigueNotificationMessage@@I@Z ENDP ; std::allocator<IntrigueNotificationMessage>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UScoreCityEntry@@@std@@QAEPAUScoreCityEntry@@I@Z ; std::allocator<ScoreCityEntry>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UScoreCityEntry@@@std@@QAEPAUScoreCityEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UScoreCityEntry@@@std@@QAEPAUScoreCityEntry@@I@Z PROC ; std::allocator<ScoreCityEntry>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UScoreCityEntry@@@std@@YAPAUScoreCityEntry@@IPAU1@@Z ; std::_Allocate<ScoreCityEntry>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UScoreCityEntry@@@std@@QAEPAUScoreCityEntry@@I@Z ENDP ; std::allocator<ScoreCityEntry>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z PROC ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@PAUHeistLocation@@@Z ENDP ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<HeistLocation,std::allocator<HeistLocation> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z PROC ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@PAUSpyNotificationMessage@@@Z ENDP ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
_TEXT	ENDS
PUBLIC	??0IntrigueNotificationMessage@@QAE@ABU0@@Z	; IntrigueNotificationMessage::IntrigueNotificationMessage
; Function compile flags: /Ogtpy
;	COMDAT ??0IntrigueNotificationMessage@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0IntrigueNotificationMessage@@QAE@ABU0@@Z PROC	; IntrigueNotificationMessage::IntrigueNotificationMessage, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	lea	eax, DWORD PTR [edi+36]
	push	eax
	lea	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+32], edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	cl, BYTE PTR [edi+64]
	pop	edi
	mov	BYTE PTR [esi+64], cl
	mov	eax, esi
	pop	esi
	ret	4
??0IntrigueNotificationMessage@@QAE@ABU0@@Z ENDP	; IntrigueNotificationMessage::IntrigueNotificationMessage
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235791 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235791[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 503  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 504  : 
; 505  : 	size_t bytes = 0;
; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 507  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 508  : 	str.assign(szComposedString, bytes);
; 509  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235791[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	mov	eax, DWORD PTR $T235791[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T235791[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z ; GetLocalizedText<char const *,char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T235811 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z PROC ; GetLocalizedText<char const *,char const *,char const *>, COMDAT

; 527  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 528  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T235811[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 529  : 	text << arg1 << arg2 << arg3;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 530  : 
; 531  : 	size_t bytes = 0;
; 532  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 533  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 534  : 	str.assign(szComposedString, bytes);
; 535  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T235811[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z$1:
	mov	eax, DWORD PTR $T235811[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@3
	and	DWORD PTR $T235811[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z ENDP ; GetLocalizedText<char const *,char const *,char const *>
PUBLIC	??$unchecked_copy@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z ; stdext::unchecked_copy<HeistLocation *,HeistLocation *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z PROC ; stdext::unchecked_copy<HeistLocation *,HeistLocation *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z ENDP ; stdext::unchecked_copy<HeistLocation *,HeistLocation *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z ; stdext::unchecked_copy<SpyNotificationMessage *,SpyNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z
_TEXT	SEGMENT
$T235862 = -4						; size = 1
__Cat$235867 = -4					; size = 1
$T235864 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z PROC ; stdext::unchecked_copy<SpyNotificationMessage *,SpyNotificationMessage *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T235862[esp+4], 0
	mov	eax, DWORD PTR $T235862[esp+4]
	mov	ecx, DWORD PTR __Cat$235867[esp+4]
	mov	edx, DWORD PTR $T235864[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z ENDP ; stdext::unchecked_copy<SpyNotificationMessage *,SpyNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvCity * *,CvCity * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z ; std::fill<HeistLocation *,HeistLocation>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z PROC ; std::fill<HeistLocation *,HeistLocation>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z ENDP ; std::fill<HeistLocation *,HeistLocation>
_TEXT	ENDS
PUBLIC	??$fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z ; std::fill<SpyNotificationMessage *,SpyNotificationMessage>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z PROC ; std::fill<SpyNotificationMessage *,SpyNotificationMessage>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z ; std::_Fill<SpyNotificationMessage *,SpyNotificationMessage>
??$fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z ENDP ; std::fill<SpyNotificationMessage *,SpyNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::fill<CvCity * *,CvCity *>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z ; std::fill<ScoreCityEntry *,ScoreCityEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z PROC ; std::fill<ScoreCityEntry *,ScoreCityEntry>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z ENDP ; std::fill<ScoreCityEntry *,ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator!=
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUHeistLocation@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<HeistLocation *,HeistLocation *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T235979 = -4						; size = 1
__Cat$235983 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T235979[esp+4], 0
	mov	eax, DWORD PTR $T235979[esp+4]
	mov	ecx, DWORD PTR __Cat$235983[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<ScoreCityEntry *,ScoreCityEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<ScoreCityEntry *,ScoreCityEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@3
	push	esi
$LL6@Move_backw@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@3
	pop	esi
$LN5@Move_backw@3:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUScoreCityEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<ScoreCityEntry *,ScoreCityEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??4IntrigueNotificationMessage@@QAEAAU0@ABU0@@Z	; IntrigueNotificationMessage::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4IntrigueNotificationMessage@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4IntrigueNotificationMessage@@QAEAAU0@ABU0@@Z PROC	; IntrigueNotificationMessage::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	lea	eax, DWORD PTR [edi+36]
	push	eax
	lea	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+32], edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	cl, BYTE PTR [edi+64]
	pop	edi
	mov	BYTE PTR [esi+64], cl
	mov	eax, esi
	pop	esi
	ret	4
??4IntrigueNotificationMessage@@QAEAAU0@ABU0@@Z ENDP	; IntrigueNotificationMessage::operator=
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@ABU3@@Z ; std::allocator<HeistLocation>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@ABU3@@Z PROC ; std::allocator<HeistLocation>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@ABU3@@Z ENDP ; std::allocator<HeistLocation>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@@Z ; std::allocator<HeistLocation>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@@Z PROC ; std::allocator<HeistLocation>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UHeistLocation@@@std@@QAEXPAUHeistLocation@@@Z ENDP ; std::allocator<HeistLocation>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@ABU3@@Z ; std::allocator<SpyNotificationMessage>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@ABU3@@Z PROC ; std::allocator<SpyNotificationMessage>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@ABU3@@Z ENDP ; std::allocator<SpyNotificationMessage>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@@Z ; std::allocator<SpyNotificationMessage>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@@Z PROC ; std::allocator<SpyNotificationMessage>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@USpyNotificationMessage@@@std@@QAEXPAUSpyNotificationMessage@@@Z ENDP ; std::allocator<SpyNotificationMessage>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@ABU3@@Z ; std::allocator<ScoreCityEntry>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@ABU3@@Z PROC ; std::allocator<ScoreCityEntry>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@ABU3@@Z ENDP ; std::allocator<ScoreCityEntry>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@@Z ; std::allocator<ScoreCityEntry>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@@Z PROC ; std::allocator<ScoreCityEntry>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UScoreCityEntry@@@std@@QAEXPAUScoreCityEntry@@@Z ENDP ; std::allocator<ScoreCityEntry>::destroy
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@XZ ; std::_Temp_iterator<ScoreCityEntry>::~_Temp_iterator<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@XZ PROC	; std::_Temp_iterator<ScoreCityEntry>::~_Temp_iterator<ScoreCityEntry>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<ScoreCityEntry>::~_Temp_iterator<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN11@Copy_backw@6
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@6:

; 2676 : 		*--_Dest = *--_Last;

	mov	eax, DWORD PTR [esi-68]
	sub	esi, 68					; 00000044H
	sub	edi, 68					; 00000044H
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], edx
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], ecx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], edx
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+28], ecx
	mov	edx, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [esi+36]
	push	eax
	lea	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [edi+32], edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	cl, BYTE PTR [esi+64]
	mov	BYTE PTR [edi+64], cl
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@6

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN11@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z ; std::_Construct<IntrigueNotificationMessage,IntrigueNotificationMessage>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z$0
__ehfuncinfo$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z
_TEXT	SEGMENT
$T236136 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z PROC ; std::_Construct<IntrigueNotificationMessage,IntrigueNotificationMessage>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T236136[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@4
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0IntrigueNotificationMessage@@QAE@ABU0@@Z
$LN3@Construct@4:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T236136[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@UIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@ABU1@@Z ENDP ; std::_Construct<IntrigueNotificationMessage,IntrigueNotificationMessage>
PUBLIC	??_GIntrigueNotificationMessage@@QAEPAXI@Z	; IntrigueNotificationMessage::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GIntrigueNotificationMessage@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GIntrigueNotificationMessage@@QAEPAXI@Z PROC		; IntrigueNotificationMessage::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+36]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GIntrigueNotificationMessage@@QAEPAXI@Z ENDP		; IntrigueNotificationMessage::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@3
	pop	esi
$LN3@Fill_n@3:

; 3243 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@UScoreCityEntry@@@std@@YA?AU?$pair@PAUScoreCityEntry@@H@0@H@Z ; std::get_temporary_buffer<ScoreCityEntry>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@UScoreCityEntry@@@std@@YA?AU?$pair@PAUScoreCityEntry@@H@0@H@Z
_TEXT	SEGMENT
$T236212 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T236216 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UScoreCityEntry@@@std@@YA?AU?$pair@PAUScoreCityEntry@@H@0@H@Z PROC ; std::get_temporary_buffer<ScoreCityEntry>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
	npad	12
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi*8]
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 8
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T236216[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T236212[esp+20]
	mov	DWORD PTR $T236216[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T236212[esp+20]
	push	ecx
	mov	DWORD PTR $T236212[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@UScoreCityEntry@@@std@@YA?AU?$pair@PAUScoreCityEntry@@H@0@H@Z ENDP ; std::get_temporary_buffer<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEAAUScoreCityEntry@@XZ ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEAAUScoreCityEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEAAUScoreCityEntry@@XZ PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBEAAUScoreCityEntry@@XZ ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<ScoreCityEntry>::_Temp_iterator<ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<ScoreCityEntry>::_Temp_iterator<ScoreCityEntry>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<ScoreCityEntry>::_Temp_iterator<ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$_Advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR __Left$[esp-4]
	push	esi
	mov	edx, ecx
	mov	esi, eax
	cmp	eax, ecx
	je	SHORT $LN11@iter_swap
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ebx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [edx], edi
	pop	edi
	mov	DWORD PTR [edx+4], eax
	pop	ebx
$LN11@iter_swap:
	pop	esi

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop@3:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL6@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
$LN5@Uninit_cop@4:
	add	ecx, 20					; 00000014H
	add	eax, 20					; 00000014H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
$LL6@Uninit_cop@5:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop@5:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 8

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -8			; fffffff8H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator--
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T236415 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T236415[esp+12], edi
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN1@Copy_opt@5
	lea	esi, DWORD PTR [edi+8]
$LL13@Copy_opt@5:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+24]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN26@Copy_opt@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+24]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@5
$LN26@Copy_opt@5:
	cmp	eax, edi
	je	SHORT $LN31@Copy_opt@5
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+24]
$LN31@Copy_opt@5:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@5:
	mov	ecx, DWORD PTR __First$[esp+8]
	add	ecx, esi
	mov	DWORD PTR __First$[esp+8], ecx
	cmp	ecx, DWORD PTR __Last$[esp+8]
	jne	SHORT $LL13@Copy_opt@5
$LN1@Copy_opt@5:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	cmp	eax, edi
	je	SHORT $LN53@Copy_opt@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Copy_opt@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@7
	npad	6
$LL2@Copy_backw@7:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last$[esp-4], eax
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@7

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@7:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@H@Z ; std::advance<ScoreCityEntry *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@H@Z PROC ; std::advance<ScoreCityEntry *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAUScoreCityEntry@@H@std@@YAXAAPAUScoreCityEntry@@H@Z ENDP ; std::advance<ScoreCityEntry *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	cmp	eax, DWORD PTR __Last$[esp-4]
	je	SHORT $LN28@Copy_opt@6
	mov	ecx, 8
	push	esi
$LL12@Copy_opt@6:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR __First$[esp]
	add	DWORD PTR __Dest$[esp], ecx
	add	eax, ecx
	mov	DWORD PTR __First$[esp], eax
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LL12@Copy_opt@6

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN28@Copy_opt@6:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	edx, eax
	je	SHORT $LN15@Copy_backw@8
	push	esi
	npad	3
$LL2@Copy_backw@8:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	esi, DWORD PTR [eax-8]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Dest$[esp], ecx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], ecx
	cmp	eax, edx
	jne	SHORT $LL2@Copy_backw@8

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], edx
	pop	esi

; 2678 : 	}

	ret	0
$LN15@Copy_backw@8:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN16@Copy_opt@7
	push	esi
	mov	edx, 8
	push	edi
$LL3@Copy_opt@7:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], esi
	add	DWORD PTR __Dest$[esp+4], edx
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LL3@Copy_opt@7

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN16@Copy_opt@7:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@4
	pop	esi
$LN3@fill@4:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@4
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@4:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@4
	pop	esi
$LN3@Fill_n@4:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
;	COMDAT ?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z PROC ; CvPlayerEspionage::GetCityWithSpy, COMDAT
; _this$ = ecx

; 998  : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "uiSpyIndex is out of bounds");
; 999  : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	edx, DWORD PTR _uiSpyIndex$[esp-4]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN3@GetCityWit

; 1000 : 	{
; 1001 : #ifdef AUI_WARNING_FIXES
; 1002 : 		return NULL;
; 1003 : #else
; 1004 : 		return false;

	xor	eax, eax

; 1019 : 		CvAssertMsg(pCity, "Spy is pointing to empty city, what's up with that");
; 1020 : 	}
; 1021 : 
; 1022 : 	return pCity;
; 1023 : }

	ret	4
$LN3@GetCityWit:

; 1005 : #endif
; 1006 : 	}
; 1007 : 
; 1008 : 	if(m_aSpyList[uiSpyIndex].m_iCityX == -1 && m_aSpyList[uiSpyIndex].m_iCityY == -1)

	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+4]
	add	eax, eax
	add	eax, eax
	push	esi
	add	edx, eax
	or	esi, -1
	cmp	DWORD PTR [edx+4], esi
	jne	SHORT $LN2@GetCityWit
	cmp	DWORD PTR [edx+8], esi

; 1009 : 	{
; 1010 : 		return NULL;

	je	$LN56@GetCityWit
$LN2@GetCityWit:

; 1011 : 	}
; 1012 : 
; 1013 : 	CvPlot* pCityPlot = GC.getMap().plot(m_aSpyList[uiSpyIndex].m_iCityX, m_aSpyList[uiSpyIndex].m_iCityY);

	mov	ecx, DWORD PTR [ecx+4]
	add	eax, ecx
	push	ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ebp
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN18@GetCityWit
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN18@GetCityWit
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN62@GetCityWit
	test	eax, eax
	jge	SHORT $LN30@GetCityWit
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN32@GetCityWit
$LN30@GetCityWit:
	cmp	eax, ecx
	jl	SHORT $LN62@GetCityWit
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN32@GetCityWit
$LN62@GetCityWit:
	mov	esi, eax
$LN32@GetCityWit:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN63@GetCityWit
	test	ebx, ebx
	jge	SHORT $LN40@GetCityWit
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN42@GetCityWit
$LN40@GetCityWit:
	cmp	ebx, edi
	jl	SHORT $LN63@GetCityWit
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN42@GetCityWit
$LN63@GetCityWit:
	mov	edx, ebx
$LN42@GetCityWit:
	test	esi, esi
	jl	SHORT $LN18@GetCityWit
	cmp	esi, ecx
	jge	SHORT $LN18@GetCityWit
	test	edx, edx
	jl	SHORT $LN18@GetCityWit
	cmp	edx, edi
	jge	SHORT $LN18@GetCityWit
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	jmp	SHORT $LN20@GetCityWit
$LN18@GetCityWit:
	xor	ecx, ecx
$LN20@GetCityWit:
	pop	edi

; 1014 : 	CvAssertMsg(pCityPlot, "pCityPlot is null. This should have been caught above");
; 1015 : 	CvCity* pCity = NULL;

	xor	eax, eax
	pop	ebp
	pop	ebx

; 1016 : 	if(pCityPlot)

	test	ecx, ecx
	je	SHORT $LN64@GetCityWit

; 1017 : 	{
; 1018 : 		pCity = pCityPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN56@GetCityWit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN56@GetCityWit
	mov	edx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	pop	esi
	mov	DWORD PTR _uiSpyIndex$[esp-4], edx
	mov	ecx, eax
	jmp	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
$LN56@GetCityWit:
	xor	eax, eax
$LN64@GetCityWit:
	pop	esi

; 1019 : 		CvAssertMsg(pCity, "Spy is pointing to empty city, what's up with that");
; 1020 : 	}
; 1021 : 
; 1022 : 	return pCity;
; 1023 : }

	ret	4
?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ENDP ; CvPlayerEspionage::GetCityWithSpy
_TEXT	ENDS
PUBLIC	?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z ; CvPlayerEspionage::GetSpyIndexInCity
EXTRN	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ:PROC ; CvCity::GetCityEspionage
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z PROC ; CvPlayerEspionage::GetSpyIndexInCity, COMDAT
; _this$ = ecx

; 1027 : {

	mov	eax, ecx

; 1028 : 	CvAssertMsg(pCity, "pCity is null. Can't do much with this");
; 1029 : 	if(!pCity)

	mov	ecx, DWORD PTR _pCity$[esp-4]
	test	ecx, ecx
	jne	SHORT $LN1@GetSpyInde

; 1030 : 	{
; 1031 : 		return -1;

	or	eax, -1

; 1035 : }

	ret	4
$LN1@GetSpyInde:

; 1032 : 	}
; 1033 : 
; 1034 : 	return pCity->GetCityEspionage()->m_aiSpyAssignment[m_pPlayer->GetID()];

	mov	eax, DWORD PTR [eax+1296]
	push	esi
	mov	esi, DWORD PTR [eax+44]
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 1035 : }

	ret	4
?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z ENDP ; CvPlayerEspionage::GetSpyIndexInCity
_TEXT	ENDS
PUBLIC	?CanEverMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::CanEverMoveSpyTo
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
; Function compile flags: /Ogtpy
;	COMDAT ?CanEverMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?CanEverMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z PROC ; CvPlayerEspionage::CanEverMoveSpyTo, COMDAT
; _this$ = ecx

; 1040 : {

	push	ebx

; 1041 : 	// allow moving into empty spaces
; 1042 : 	if(!pCity)

	mov	ebx, DWORD PTR _pCity$[esp]
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	jne	SHORT $LN4@CanEverMov
	pop	edi

; 1043 : 	{
; 1044 : 		return true;

	mov	al, 1
	pop	ebx

; 1061 : 	{
; 1062 : 		return false;
; 1063 : 	}
; 1064 : 
; 1065 : 	return true;
; 1066 : }

	ret	4
$LN4@CanEverMov:
	push	ebp

; 1045 : 	}
; 1046 : 
; 1047 : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ebp, eax

; 1048 : 	CvAssertMsg(pPlot, "No plot() for pCity");
; 1049 : 	if(!pPlot)

	test	ebp, ebp

; 1050 : 	{
; 1051 : 		return false;

	je	SHORT $LN32@CanEverMov

; 1052 : 	}
; 1053 : 
; 1054 : 	if(!GET_TEAM(m_pPlayer->getTeam()).isHasMet(pCity->getTeam()))

	mov	eax, DWORD PTR [edi+1296]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN11@CanEverMov
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN12@CanEverMov
$LN11@CanEverMov:
	or	eax, -1
$LN12@CanEverMov:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, ebx
	mov	esi, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, esi
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	pop	esi
	test	al, al
	jne	SHORT $LN2@CanEverMov
$LN32@CanEverMov:
	pop	ebp
	pop	edi

; 1055 : 	{
; 1056 : 		return false;

	xor	al, al
	pop	ebx

; 1061 : 	{
; 1062 : 		return false;
; 1063 : 	}
; 1064 : 
; 1065 : 	return true;
; 1066 : }

	ret	4
$LN2@CanEverMov:

; 1057 : 	}
; 1058 : 
; 1059 : 	// check to see if the plot can be seen
; 1060 : 	if(!pPlot->isRevealed(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [edi+1296]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN22@CanEverMov
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN23@CanEverMov
$LN22@CanEverMov:
	or	ecx, -1
$LN23@CanEverMov:
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [ebp+eax*4+8]
	pop	ebp
	pop	edi
	setne	al
	pop	ebx

; 1061 : 	{
; 1062 : 		return false;
; 1063 : 	}
; 1064 : 
; 1065 : 	return true;
; 1066 : }

	ret	4
?CanEverMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ENDP ; CvPlayerEspionage::CanEverMoveSpyTo
_TEXT	ENDS
PUBLIC	?CanMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::CanMoveSpyTo
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
; Function compile flags: /Ogtpy
;	COMDAT ?CanMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_uiSpyIndex$ = 12					; size = 4
_bAsDiplomat$ = 16					; size = 1
?CanMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z PROC ; CvPlayerEspionage::CanMoveSpyTo, COMDAT
; _this$ = ecx

; 1070 : {

	push	esi
	push	edi

; 1071 : 	// This allows the player to move the spy off the board
; 1072 : 	if(!pCity)

	mov	edi, DWORD PTR _pCity$[esp+4]
	mov	esi, ecx
	test	edi, edi

; 1073 : 	{
; 1074 : 		return true;

	je	SHORT $LN1@CanMoveSpy

; 1075 : 	}
; 1076 : 
; 1077 : 	if(!CanEverMoveSpyTo(pCity))

	push	edi
	call	?CanEverMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::CanEverMoveSpyTo
	test	al, al
	jne	SHORT $LN8@CanMoveSpy
$LN30@CanMoveSpy:
	pop	edi

; 1078 : 	{
; 1079 : 		return false;

	xor	al, al
	pop	esi

; 1117 : }

	ret	12					; 0000000cH
$LN8@CanMoveSpy:

; 1080 : 	}
; 1081 : 
; 1082 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 1083 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp+4]
	cmp	eax, DWORD PTR [esi+8]

; 1084 : 	{
; 1085 : 		return false;

	jae	SHORT $LN30@CanMoveSpy

; 1086 : 	}
; 1087 : 
; 1088 : 	// check to see if there is someone already there
; 1089 : 	CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, edi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 1090 : 	CvAssertMsg(pCityEspionage, "pCityEspionage is null");
; 1091 : 	if(!pCityEspionage)

	test	eax, eax

; 1092 : 	{
; 1093 : 		return false;

	je	SHORT $LN30@CanMoveSpy

; 1094 : 	}
; 1095 : 
; 1096 : 	PlayerTypes ePlayerID = m_pPlayer->GetID();
; 1097 : 	if(pCityEspionage->m_aiSpyAssignment[ePlayerID] != -1)

	mov	ecx, DWORD PTR [esi+1296]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [eax+edx*4+4], -1

; 1098 : 	{
; 1099 : 		return false;

	jne	SHORT $LN30@CanMoveSpy

; 1100 : 	}
; 1101 : 
; 1102 : 	if (bAsDiplomat)

	cmp	BYTE PTR _bAsDiplomat$[esp+4], 0
	je	SHORT $LN1@CanMoveSpy

; 1103 : 	{
; 1104 : 		// diplomatic spy must be in capital
; 1105 : 		if (!pCity->isCapital() || pCity->getOwner() == m_pPlayer->GetID())

	mov	ecx, edi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN30@CanMoveSpy
	mov	ecx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edi+84]
	cmp	eax, DWORD PTR [ecx+44]
	je	SHORT $LN30@CanMoveSpy

; 1106 : 		{
; 1107 : 			return false;
; 1108 : 		}
; 1109 : 
; 1110 : 		if (GET_TEAM(m_pPlayer->getTeam()).isAtWar(pCity->getTeam()))

	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	esi, eax
	imul	esi, 2980				; 00000ba4H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, edi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, esi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 1111 : 		{
; 1112 : 			return false;

	jne	SHORT $LN30@CanMoveSpy
$LN1@CanMoveSpy:
	pop	edi

; 1113 : 		}
; 1114 : 	}
; 1115 : 
; 1116 : 	return true;

	mov	al, 1
	pop	esi

; 1117 : }

	ret	12					; 0000000cH
?CanMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ENDP ; CvPlayerEspionage::CanMoveSpyTo
_TEXT	ENDS
PUBLIC	?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z		; CvPlayerEspionage::LevelUpSpy
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z$1
__ehfuncinfo$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z
_TEXT	SEGMENT
_szNewPromotion$223295 = -76				; size = 4
_szOldPromotion$223294 = -72				; size = 4
_strSummary$223308 = -68				; size = 28
_strBuffer$223296 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_szSpyName$223293 = 8					; size = 4
_uiSpyIndex$ = 8					; size = 4
?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z PROC		; CvPlayerEspionage::LevelUpSpy, COMDAT
; _this$ = ecx

; 1265 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 1266 : 	// if the spy can level up and it's not dead
; 1267 : 	if(m_aSpyList[uiSpyIndex].m_eRank < NUM_SPY_RANKS - 1 && m_aSpyList[uiSpyIndex].m_eSpyState != SPY_STATE_DEAD)

	mov	eax, DWORD PTR _uiSpyIndex$[esp+8]
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*8]
	sub	edi, eax
	add	edi, edi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	add	edi, edi
	add	eax, edi
	cmp	DWORD PTR [eax+12], 2
	jge	$LN1@LevelUpSpy
	cmp	DWORD PTR [eax+16], 8
	je	$LN1@LevelUpSpy

; 1268 : 	{
; 1269 : 		CvSpyRank eOriginalRank = m_aSpyList[uiSpyIndex].m_eRank;

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [ecx+edi+12]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax]

; 1270 : 
; 1271 : 		// announce promotion through notification
; 1272 : 		m_aSpyList[uiSpyIndex].m_eRank = (CvSpyRank)(m_aSpyList[uiSpyIndex].m_eRank + 1);

	lea	edx, DWORD PTR [ebp+1]
	mov	DWORD PTR [eax], edx

; 1273 : 
; 1274 : 		CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 1275 : 		if(pNotifications)

	test	ebx, ebx
	je	$LN32@LevelUpSpy

; 1276 : 		{
; 1277 : 			const char* szSpyName = m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+1296]
	add	eax, edi
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames

; 1278 : 			const char* szOldPromotion = GetSpyRankName(eOriginalRank);

	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _szSpyName$223293[esp+92], eax
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName

; 1279 : 			const char* szNewPromotion = GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+edi+12]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _szOldPromotion$223294[esp+96], eax
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	mov	DWORD PTR _szNewPromotion$223295[esp+92], eax

; 1280 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_PROMOTED", szSpyName, szOldPromotion, szNewPromotion);

	lea	eax, DWORD PTR _szNewPromotion$223295[esp+92]
	push	eax
	lea	ecx, DWORD PTR _szOldPromotion$223294[esp+96]
	push	ecx
	lea	edx, DWORD PTR _szSpyName$223293[esp+96]
	push	edx
	lea	eax, DWORD PTR _strBuffer$223296[esp+104]
	push	OFFSET $SG223307
	push	eax
	call	??$GetLocalizedText@PBDPBDPBD@@YA?AVCvString@@PBDABQBD11@Z ; GetLocalizedText<char const *,char const *,char const *>

; 1281 : 			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_SPY_PROMOTED", szSpyName);

	mov	ecx, DWORD PTR _szSpyName$223293[esp+108]
	push	ecx
	lea	edx, DWORD PTR _strSummary$223308[esp+116]
	push	OFFSET $SG223310
	push	edx
	mov	DWORD PTR __$EHRec$[esp+132], 0
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 32					; 00000020H

; 1282 : 			pNotifications->Add(NOTIFICATION_SPY_PROMOTION, strBuffer, strSummary, -1, -1, 0);

	lea	ecx, DWORD PTR _strSummary$223308[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	0
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$223296[esp+112]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	180382033				; 0ac06951H
	mov	ecx, ebx
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 1283 : 		}

	lea	ecx, DWORD PTR _strSummary$223308[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$223296[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN32@LevelUpSpy:
	pop	ebp
	pop	ebx
$LN1@LevelUpSpy:

; 1284 : 	}
; 1285 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z$0:
	lea	ecx, DWORD PTR _strBuffer$223296[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z$1:
	lea	ecx, DWORD PTR _strSummary$223308[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z ENDP		; CvPlayerEspionage::LevelUpSpy
PUBLIC	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn
EXTRN	?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus
EXTRN	?GetInfluenceMajorCivSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceMajorCivSpyRankBonus
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?GetEspionageModifier@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetEspionageModifier
EXTRN	?GetEspionageModifier@CvCity@@QBEHXZ:PROC	; CvCity::GetEspionageModifier
EXTRN	?getSpyRatePercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getSpyRatePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z
_TEXT	SEGMENT
_iFinalModifier$223349 = 8				; size = 4
_iCityEspionageModifier$223345 = 8			; size = 4
_iSpyState$ = 8						; size = 4
$T237287 = 12						; size = 4
$T237275 = 12						; size = 4
_iPlayerEspionageModifier$223346 = 12			; size = 4
_pCity$ = 12						; size = 4
_iSpyIndex$ = 16					; size = 4
?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z PROC ; CvPlayerEspionage::CalcPerTurn, COMDAT
; _this$ = ecx

; 1354 : 	CvAssertMsg(pCity, "pCity is null");
; 1355 : 	switch(iSpyState)

	mov	eax, DWORD PTR _iSpyState$[esp-4]
	push	ebp
	dec	eax
	push	esi
	push	edi
	mov	ebp, ecx
	cmp	eax, 6
	ja	$LN12@CalcPerTur
	jmp	DWORD PTR $LN42@CalcPerTur[eax*4]
$LN11@CalcPerTur:
	pop	edi
	pop	esi

; 1356 : 	{
; 1357 : 	case SPY_STATE_TRAVELLING:
; 1358 : 	{
; 1359 : 		return 1;

	mov	eax, 1
	pop	ebp

; 1443 : }

	ret	12					; 0000000cH
$LN9@CalcPerTur:

; 1360 : 	}
; 1361 : 	break;
; 1362 : 	case SPY_STATE_SURVEILLANCE:
; 1363 : 	{
; 1364 : 		return 1;
; 1365 : 	}
; 1366 : 	break;
; 1367 : 	case SPY_STATE_GATHERING_INTEL:
; 1368 : 	{
; 1369 : 		if(pCity)

	mov	edi, DWORD PTR _pCity$[esp+8]
	test	edi, edi
	je	$LN12@CalcPerTur
	push	ebx

; 1370 : 		{
; 1371 : 			PlayerTypes eCityOwner = pCity->getOwner();

	mov	ebx, DWORD PTR [edi+84]

; 1372 : 			int iBaseYieldRate = pCity->getYieldRateTimes100(YIELD_SCIENCE, false);

	push	0
	push	3
	mov	ecx, edi
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100

; 1373 : 			iBaseYieldRate *= GC.getESPIONAGE_GATHERING_INTEL_RATE_BASE_PERCENT();
; 1374 : 			iBaseYieldRate *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7932
	mov	DWORD PTR $T237287[esp+12], eax
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getSpyRatePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getSpyRatePercent
	mov	ecx, eax
	imul	ecx, DWORD PTR $T237287[esp+12]

; 1375 : 			iBaseYieldRate /= 10000;

	imul	ecx, esi
	mov	eax, 1759218605				; 68db8badH
	imul	ecx
	sar	edx, 12					; 0000000cH
	mov	esi, edx
	shr	esi, 31					; 0000001fH

; 1376 : 			int iCityEspionageModifier = pCity->GetEspionageModifier();

	mov	ecx, edi
	add	esi, edx
	call	?GetEspionageModifier@CvCity@@QBEHXZ	; CvCity::GetEspionageModifier

; 1377 : 			int iPlayerEspionageModifier = GET_PLAYER(eCityOwner).GetEspionageModifier();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
	add	ecx, edi
	mov	DWORD PTR _iCityEspionageModifier$223345[esp+12], eax
	call	?GetEspionageModifier@CvPlayer@@QBEHXZ	; CvPlayer::GetEspionageModifier

; 1378 : 			int iTheirPoliciesEspionageModifier = GET_PLAYER(eCityOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_STEAL_TECH_SLOWER_MODIFIER);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	push	20					; 00000014H
	mov	DWORD PTR _iPlayerEspionageModifier$223346[esp+16], eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 1379 : 			int iMyPoliciesEspionageModifier = m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_STEAL_TECH_FASTER_MODIFIER);

	mov	ecx, DWORD PTR [ebp+1296]
	push	40					; 00000028H
	mov	edi, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 1380 : 			int iFinalModifier = (iBaseYieldRate * (100 + iCityEspionageModifier + iPlayerEspionageModifier + iTheirPoliciesEspionageModifier + iMyPoliciesEspionageModifier)) / 100;

	mov	ecx, DWORD PTR _iCityEspionageModifier$223345[esp+12]
	add	eax, edi
	add	eax, DWORD PTR _iPlayerEspionageModifier$223346[esp+12]

; 1381 : 
; 1382 : 			int iResult = max(iFinalModifier, 1);

	mov	DWORD PTR $T237275[esp+12], 1
	lea	ecx, DWORD PTR [eax+ecx+100]
	imul	ecx, esi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iFinalModifier$223349[esp+12], eax
	cmp	eax, 1
	lea	eax, DWORD PTR $T237275[esp+12]
	jl	SHORT $LN31@CalcPerTur
	lea	eax, DWORD PTR _iFinalModifier$223349[esp+12]
$LN31@CalcPerTur:
	mov	edi, DWORD PTR [eax]

; 1383 : 			if(iSpyIndex >= 0)

	mov	eax, DWORD PTR _iSpyIndex$[esp+12]
	test	eax, eax
	jl	SHORT $LN7@CalcPerTur

; 1384 : 			{
; 1385 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1386 : 				int iSpyRank = m_aSpyList[iSpyIndex].m_eCachedRank;
; 1387 : 				iSpyRank += m_aSpyList[iSpyIndex].m_iInfluenceMajorCivSpyRankBonusCached;
; 1388 : 				iMyPoliciesEspionageModifier = m_aSpyList[iSpyIndex].m_iMyPoliciesEspionageModifierCached;
; 1389 : 				iFinalModifier = (iBaseYieldRate * (100 + iCityEspionageModifier + iPlayerEspionageModifier + iTheirPoliciesEspionageModifier + iMyPoliciesEspionageModifier)) / 100;
; 1390 : 
; 1391 : 				iResult = MAX(iFinalModifier, 1);
; 1392 : #else
; 1393 : 				int iSpyRank = m_aSpyList[iSpyIndex].m_eRank;
; 1394 : 				iSpyRank += m_pPlayer->GetCulture()->GetInfluenceMajorCivSpyRankBonus(eCityOwner);

	mov	ecx, DWORD PTR [ebp+1296]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [eax+edx*4+12]
	push	ebx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceMajorCivSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceMajorCivSpyRankBonus

; 1395 : #endif
; 1396 : 				iResult *= 100 + (GC.getESPIONAGE_GATHERING_INTEL_RATE_BY_SPY_RANK_PERCENT() * iSpyRank);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7928
	add	esi, eax
	imul	ecx, esi
	add	ecx, 100				; 00000064H
	imul	ecx, edi

; 1397 : 				iResult /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edi, ecx
$LN7@CalcPerTur:
	pop	ebx

; 1398 : 			}
; 1399 : 
; 1400 : 			return iResult;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 1443 : }

	ret	12					; 0000000cH
$LN6@CalcPerTur:

; 1401 : 		}
; 1402 : 	}
; 1403 : 	break;
; 1404 : 	case SPY_STATE_RIG_ELECTION:
; 1405 : 	{
; 1406 : 		if(pCity)

	mov	edx, DWORD PTR _pCity$[esp+8]
	test	edx, edx
	je	SHORT $LN12@CalcPerTur

; 1407 : 		{
; 1408 : 			int iResult = 1;
; 1409 : 			if(iSpyIndex >= 0)

	mov	ecx, DWORD PTR _iSpyIndex$[esp+8]
	mov	eax, 1
	test	ecx, ecx
	jl	SHORT $LN14@CalcPerTur

; 1410 : 			{
; 1411 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1412 : 				int iSpyRank = m_aSpyList[iSpyIndex].m_eCachedRank;
; 1413 : 				iSpyRank += m_aSpyList[iSpyIndex].m_iInfluenceCityStateSpyRankBonusCached;
; 1414 : #else
; 1415 : 				int iSpyRank = m_aSpyList[iSpyIndex].m_eRank;

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [ecx+eax*4+12]

; 1416 : 				iSpyRank += m_pPlayer->GetCulture()->GetInfluenceCityStateSpyRankBonus(pCity->getOwner());

	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR [ebp+1296]
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus
	add	esi, eax
	pop	edi

; 1417 : #endif
; 1418 : 				iResult = (iSpyRank + 1) * (iSpyRank + 1);

	lea	eax, DWORD PTR [esi+1]
	pop	esi
	imul	eax, eax
	pop	ebp

; 1443 : }

	ret	12					; 0000000cH
$LN3@CalcPerTur:
	pop	edi
	pop	esi

; 1419 : 			}
; 1420 : 			return iResult;
; 1421 : 		}
; 1422 : 	}
; 1423 : 	break;
; 1424 : 	case SPY_STATE_COUNTER_INTEL:
; 1425 : 	{
; 1426 : 		return 0;

	xor	eax, eax
	pop	ebp

; 1443 : }

	ret	12					; 0000000cH
$LN12@CalcPerTur:

; 1427 : 	}
; 1428 : 	break;
; 1429 : 	case SPY_STATE_MAKING_INTRODUCTIONS:
; 1430 : 	{
; 1431 : 		return 1;
; 1432 : 	}
; 1433 : 	break;
; 1434 : 	case SPY_STATE_SCHMOOZE:
; 1435 : 	{
; 1436 : 		return 0;
; 1437 : 	}
; 1438 : 	break;
; 1439 : 	}
; 1440 : 
; 1441 : 	CvAssertMsg(false, "CalcPerTurn cannot handle that iSpyState");
; 1442 : 	return -1;

	or	eax, -1
$LN14@CalcPerTur:
	pop	edi
	pop	esi
	pop	ebp

; 1443 : }

	ret	12					; 0000000cH
$LN42@CalcPerTur:
	DD	$LN11@CalcPerTur
	DD	$LN11@CalcPerTur
	DD	$LN9@CalcPerTur
	DD	$LN6@CalcPerTur
	DD	$LN3@CalcPerTur
	DD	$LN11@CalcPerTur
	DD	$LN3@CalcPerTur
?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ENDP ; CvPlayerEspionage::CalcPerTurn
_TEXT	ENDS
PUBLIC	?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcRequired
EXTRN	?getLeaguePercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getLeaguePercent
EXTRN	?GetTurnsUntilMinorCivElection@CvGame@@QAEHXZ:PROC ; CvGame::GetTurnsUntilMinorCivElection
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceSurveillanceTime
; Function compile flags: /Ogtpy
;	COMDAT ?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z
_TEXT	SEGMENT
_iSpyState$ = 8						; size = 4
_pCity$ = 12						; size = 4
___formal$ = 16						; size = 4
?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z PROC ; CvPlayerEspionage::CalcRequired, COMDAT
; _this$ = ecx

; 1459 : #endif
; 1460 : 
; 1461 : 	switch(iSpyState)

	mov	eax, DWORD PTR _iSpyState$[esp-4]
	dec	eax
	push	ebx
	mov	ebx, ecx
	cmp	eax, 5
	ja	$LN10@CalcRequir
	jmp	DWORD PTR $LN36@CalcRequir[eax*4]
$LN9@CalcRequir:

; 1462 : 	{
; 1463 : 	case SPY_STATE_TRAVELLING:
; 1464 : 	{
; 1465 : 		return iSpyTurnsToTravel;

	mov	eax, 1
	pop	ebx

; 1521 : }

	ret	12					; 0000000cH
$LN8@CalcRequir:

; 1466 : 	}
; 1467 : 	break;
; 1468 : 	case SPY_STATE_SURVEILLANCE:
; 1469 : 	{
; 1470 : 		int iTime = 3;
; 1471 : 		if (pCity)

	mov	ecx, DWORD PTR _pCity$[esp]
	mov	eax, 3
	test	ecx, ecx
	je	SHORT $LN12@CalcRequir

; 1472 : 		{
; 1473 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1474 : 			if (iSpyIndex >= 0)
; 1475 : 			{
; 1476 : 				iTime = m_aSpyList[iSpyIndex].m_iInfluenceSurveillanceTimeCached;
; 1477 : 			}
; 1478 : #else
; 1479 : 			iTime = m_pPlayer->GetCulture()->GetInfluenceSurveillanceTime(pCity->getOwner());

	mov	eax, DWORD PTR [ecx+84]
	mov	ecx, DWORD PTR [ebx+1296]
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceSurveillanceTime
	pop	ebx

; 1521 : }

	ret	12					; 0000000cH
$LN6@CalcRequir:

; 1480 : #endif
; 1481 : 		}
; 1482 : 		return iTime;
; 1483 : 	}
; 1484 : 	break;
; 1485 : 	case SPY_STATE_GATHERING_INTEL:
; 1486 : 	{
; 1487 : 		if(pCity)

	mov	eax, DWORD PTR _pCity$[esp]
	test	eax, eax
	je	$LN10@CalcRequir
	push	esi
	push	edi

; 1488 : 		{
; 1489 : 			PlayerTypes ePlayer = pCity->getOwner();

	mov	edi, DWORD PTR [eax+84]

; 1490 : 			CvAssertMsg(!GET_PLAYER(ePlayer).isMinorCiv(), "Can't spy on a minor civ");
; 1491 : 			CvAssertMsg(!GET_PLAYER(ePlayer).isBarbarian(), "Can't spy on barbarians");
; 1492 : 			if(GET_PLAYER(ePlayer).isMinorCiv() || GET_PLAYER(ePlayer).isBarbarian())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, edi
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN3@CalcRequir
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN3@CalcRequir

; 1495 : 			}
; 1496 : 
; 1497 : 			CvAssertMsg(m_aiMaxTechCost[ePlayer] >= 0, "m_aiMaxTechCost[ePlayer] is below zero");
; 1498 : 			uint uiMaxTechCostAdjusted = m_aiMaxTechCost[ePlayer];			
; 1499 : 			uiMaxTechCostAdjusted *= GC.getESPIONAGE_GATHERING_INTEL_COST_PERCENT();

	mov	edx, DWORD PTR [ebx+edi*4+824]
	imul	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7924

; 1500 : 			uiMaxTechCostAdjusted /= 100;

	mov	eax, 1374389535				; 51eb851fH
	mul	edx
	mov	eax, edx
	pop	edi
	shr	eax, 5
	pop	esi
$LN12@CalcRequir:
	pop	ebx

; 1521 : }

	ret	12					; 0000000cH
$LN3@CalcRequir:
	pop	edi
	pop	esi

; 1493 : 			{
; 1494 : 				return -1;

	or	eax, -1
	pop	ebx

; 1521 : }

	ret	12					; 0000000cH
$LN2@CalcRequir:

; 1501 : 			int iMaxTechCostAdjusted = uiMaxTechCostAdjusted;
; 1502 : 			CvAssertMsg(m_aiMaxTechCost[ePlayer] >= 0, "iMaxTechCostAdjusted is below zero. Overflow!");
; 1503 : 			return iMaxTechCostAdjusted;
; 1504 : 		}
; 1505 : 	}
; 1506 : 	break;
; 1507 : 	case SPY_STATE_RIG_ELECTION:
; 1508 : 	{
; 1509 : 		return GC.getGame().GetTurnsUntilMinorCivElection();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTurnsUntilMinorCivElection@CvGame@@QAEHXZ ; CvGame::GetTurnsUntilMinorCivElection
	pop	ebx

; 1521 : }

	ret	12					; 0000000cH
$LN1@CalcRequir:

; 1510 : 	}
; 1511 : 	break;
; 1512 : 	case SPY_STATE_MAKING_INTRODUCTIONS:
; 1513 : 	{
; 1514 : 		return (iSpyTurnsToMakeIntroductions * GC.getGame().getGameSpeedInfo().getLeaguePercent()) / 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getLeaguePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getLeaguePercent
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	ebx

; 1521 : }

	ret	12					; 0000000cH
$LN10@CalcRequir:

; 1515 : 	}
; 1516 : 	break;
; 1517 : 	}
; 1518 : 
; 1519 : 	CvAssertMsg(false, "CalcRequired cannot handle that iSpyState");
; 1520 : 	return -1;

	or	eax, -1
	pop	ebx

; 1521 : }

	ret	12					; 0000000cH
$LN36@CalcRequir:
	DD	$LN9@CalcRequir
	DD	$LN8@CalcRequir
	DD	$LN6@CalcRequir
	DD	$LN2@CalcRequir
	DD	$LN10@CalcRequir
	DD	$LN1@CalcRequir
?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ENDP ; CvPlayerEspionage::CalcRequired
_TEXT	ENDS
PUBLIC	?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::HasEstablishedSurveillance
; Function compile flags: /Ogtpy
;	COMDAT ?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z PROC ; CvPlayerEspionage::HasEstablishedSurveillance, COMDAT
; _this$ = ecx

; 1546 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 1547 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp-4]
	push	edi
	mov	edi, ecx
	cmp	eax, DWORD PTR [edi+8]
	jb	SHORT $LN7@HasEstabli

; 1548 : 	{
; 1549 : 		return false;

	xor	al, al
	pop	edi

; 1572 : }

	ret	4
$LN7@HasEstabli:

; 1550 : 	}
; 1551 : 
; 1552 : 	if(!IsSpyInCity(uiSpyIndex))

	mov	ecx, DWORD PTR [edi+4]
	push	esi
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	add	esi, esi
	add	esi, esi
	add	ecx, esi
	or	edx, -1
	cmp	DWORD PTR [ecx+4], edx
	je	SHORT $LN43@HasEstabli
	cmp	DWORD PTR [ecx+8], edx

; 1553 : 	{
; 1554 : 		return false;

	je	SHORT $LN43@HasEstabli

; 1555 : 	}
; 1556 : 
; 1557 : 	CvCity* pCity = GetCityWithSpy(uiSpyIndex);

	push	eax
	mov	ecx, edi
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 1558 : 	if(pCity == NULL)

	test	eax, eax

; 1559 : 		return false;

	je	SHORT $LN43@HasEstabli

; 1560 : 
; 1561 : 	CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 1562 : 	if(m_aSpyList[uiSpyIndex].m_eSpyState == SPY_STATE_SURVEILLANCE && pCityEspionage->HasReachedGoal(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [esi+edx+16]
	cmp	esi, 2
	jne	SHORT $LN4@HasEstabli
	mov	ecx, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR [eax+ecx*4+92]
	cmp	edx, DWORD PTR [eax+ecx*4+268]

; 1563 : 	{
; 1564 : 		return true;

	jge	SHORT $LN1@HasEstabli
$LN4@HasEstabli:

; 1565 : 	}
; 1566 : 	else if(m_aSpyList[uiSpyIndex].m_eSpyState == SPY_STATE_GATHERING_INTEL || m_aSpyList[uiSpyIndex].m_eSpyState == SPY_STATE_RIG_ELECTION || m_aSpyList[uiSpyIndex].m_eSpyState == SPY_STATE_SCHMOOZE)

	cmp	esi, 3
	je	SHORT $LN1@HasEstabli
	cmp	esi, 4
	je	SHORT $LN1@HasEstabli
	cmp	esi, 7
	je	SHORT $LN1@HasEstabli
$LN43@HasEstabli:
	pop	esi

; 1569 : 	}
; 1570 : 
; 1571 : 	return false;

	xor	al, al
	pop	edi

; 1572 : }

	ret	4
$LN1@HasEstabli:
	pop	esi

; 1567 : 	{
; 1568 : 		return true;

	mov	al, 1
	pop	edi

; 1572 : }

	ret	4
?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ENDP ; CvPlayerEspionage::HasEstablishedSurveillance
_TEXT	ENDS
PUBLIC	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
; Function compile flags: /Ogtpy
;	COMDAT ?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z
_TEXT	SEGMENT
_iY$ = 8						; size = 4
_pCity$ = 8						; size = 4
?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z PROC ; CvPlayerEspionage::HasEstablishedSurveillanceInCity, COMDAT
; _this$ = ecx

; 1577 : 	CvAssertMsg(pCity, "pCity is null");
; 1578 : 	if(!pCity)

	mov	eax, DWORD PTR _pCity$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN5@HasEstabli@2

; 1579 : 	{
; 1580 : 		return false;

	xor	al, al
	pop	esi

; 1595 : }

	ret	4
$LN5@HasEstabli@2:
	push	ebx
	push	ebp

; 1581 : 	}
; 1582 : 
; 1583 : 	int iX = pCity->getX();

	mov	ebp, DWORD PTR [eax+96]

; 1584 : 	int iY = pCity->getY();

	mov	eax, DWORD PTR [eax+108]
	push	edi

; 1585 : 
; 1586 : 	for(uint uiSpy = 0; uiSpy < m_aSpyList.size(); uiSpy++)

	xor	edi, edi
	mov	DWORD PTR _iY$[esp+12], eax
	cmp	DWORD PTR [esi+8], edi
	jbe	SHORT $LN2@HasEstabli@2

; 1581 : 	}
; 1582 : 
; 1583 : 	int iX = pCity->getX();

	xor	ebx, ebx
	npad	9
$LL25@HasEstabli@2:

; 1587 : 	{
; 1588 : 		if(m_aSpyList[uiSpy].m_iCityX == iX && m_aSpyList[uiSpy].m_iCityY == iY && HasEstablishedSurveillance(uiSpy))

	mov	ecx, DWORD PTR [esi+4]
	cmp	DWORD PTR [ebx+ecx+4], ebp
	lea	eax, DWORD PTR [ebx+ecx]
	jne	SHORT $LN3@HasEstabli@2
	mov	edx, DWORD PTR _iY$[esp+12]
	cmp	DWORD PTR [eax+8], edx
	jne	SHORT $LN3@HasEstabli@2
	push	edi
	mov	ecx, esi
	call	?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::HasEstablishedSurveillance
	test	al, al
	jne	SHORT $LN23@HasEstabli@2
$LN3@HasEstabli@2:

; 1585 : 
; 1586 : 	for(uint uiSpy = 0; uiSpy < m_aSpyList.size(); uiSpy++)

	inc	edi
	add	ebx, 28					; 0000001cH
	cmp	edi, DWORD PTR [esi+8]
	jb	SHORT $LL25@HasEstabli@2
$LN2@HasEstabli@2:
	pop	edi
	pop	ebp
	pop	ebx

; 1591 : 		}
; 1592 : 	}
; 1593 : 
; 1594 : 	return false;

	xor	al, al
	pop	esi

; 1595 : }

	ret	4
$LN23@HasEstabli@2:
	pop	edi
	pop	ebp
	pop	ebx

; 1589 : 		{
; 1590 : 			return true;

	mov	al, 1
	pop	esi

; 1595 : }

	ret	4
?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ENDP ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
_TEXT	ENDS
PUBLIC	?IsAnySurveillanceEstablished@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ; CvPlayerEspionage::IsAnySurveillanceEstablished
; Function compile flags: /Ogtpy
;	COMDAT ?IsAnySurveillanceEstablished@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_uiSpy$223429 = -12					; size = 4
_this$ = -8						; size = 4
tv467 = -4						; size = 4
_eTargetPlayer$ = 8					; size = 4
?IsAnySurveillanceEstablished@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlayerEspionage::IsAnySurveillanceEstablished, COMDAT
; _this$ = ecx

; 1599 : {

	sub	esp, 12					; 0000000cH

; 1600 : 	for(uint uiSpy = 0; uiSpy < m_aSpyList.size(); uiSpy++)

	mov	eax, DWORD PTR [ecx+8]
	push	ebx
	push	ebp
	push	esi
	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+28], ecx
	mov	DWORD PTR _uiSpy$223429[esp+28], esi
	test	eax, eax
	jbe	$LN5@IsAnySurve
	xor	edx, edx
	mov	DWORD PTR tv467[esp+28], edx

; 1601 : 	{
; 1602 : 		// can't have established surveillance when not in a city
; 1603 : 		if(!IsSpyInCity(uiSpy))

	cmp	esi, eax
	jae	$LN6@IsAnySurve
$LN86@IsAnySurve:
	mov	eax, DWORD PTR [ecx+4]
	add	eax, edx
	or	edi, -1
	cmp	DWORD PTR [eax+4], edi
	je	$LN6@IsAnySurve
	cmp	DWORD PTR [eax+8], edi
	je	$LN6@IsAnySurve

; 1604 : 		{
; 1605 : 			continue;
; 1606 : 		}
; 1607 : 
; 1608 : 		CvPlot* pPlot = GC.getMap().plot(m_aSpyList[uiSpy].m_iCityX, m_aSpyList[uiSpy].m_iCityY);

	mov	ecx, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [ecx+edx+8]
	lea	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN5@IsAnySurve
	cmp	ebx, -2147483647			; 80000001H
	je	$LN5@IsAnySurve
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN39@IsAnySurve
	test	eax, eax
	jge	SHORT $LN41@IsAnySurve
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN43@IsAnySurve
$LN41@IsAnySurve:
	cmp	eax, ecx
	jl	SHORT $LN39@IsAnySurve
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN43@IsAnySurve
$LN39@IsAnySurve:
	mov	esi, eax
$LN43@IsAnySurve:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN49@IsAnySurve
	test	ebx, ebx
	jge	SHORT $LN51@IsAnySurve
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN53@IsAnySurve
$LN51@IsAnySurve:
	cmp	ebx, edi
	jl	SHORT $LN49@IsAnySurve
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN53@IsAnySurve
$LN49@IsAnySurve:
	mov	edx, ebx
$LN53@IsAnySurve:
	test	esi, esi
	jl	$LN5@IsAnySurve
	cmp	esi, ecx
	jge	$LN5@IsAnySurve
	test	edx, edx
	jl	SHORT $LN5@IsAnySurve
	cmp	edx, edi
	jge	SHORT $LN5@IsAnySurve
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 1609 : 		CvAssertMsg(pPlot, "Spy coordinates did not point to plot");
; 1610 : 		if(!pPlot)

	je	SHORT $LN5@IsAnySurve

; 1611 : 		{
; 1612 : 			return false;
; 1613 : 		}
; 1614 : 		CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN5@IsAnySurve
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN5@IsAnySurve
	mov	edx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 1615 : 		CvAssertMsg(pCity, "There is not a city at the specified plot");
; 1616 : 		if(!pCity)

	test	esi, esi
	je	SHORT $LN5@IsAnySurve

; 1617 : 		{
; 1618 : 			return false;
; 1619 : 		}
; 1620 : 		if(HasEstablishedSurveillance(uiSpy) && pCity->getOwner() == eTargetPlayer)

	mov	eax, DWORD PTR _uiSpy$223429[esp+28]
	mov	ecx, DWORD PTR _this$[esp+28]
	push	eax
	call	?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::HasEstablishedSurveillance
	test	al, al
	je	SHORT $LN84@IsAnySurve
	mov	ecx, DWORD PTR _eTargetPlayer$[esp+24]
	cmp	DWORD PTR [esi+84], ecx
	je	SHORT $LN79@IsAnySurve
$LN84@IsAnySurve:
	mov	esi, DWORD PTR _uiSpy$223429[esp+28]
	mov	edx, DWORD PTR tv467[esp+28]
	mov	ecx, DWORD PTR _this$[esp+28]
$LN6@IsAnySurve:
	mov	eax, DWORD PTR [ecx+8]
	inc	esi
	add	edx, 28					; 0000001cH
	mov	DWORD PTR _uiSpy$223429[esp+28], esi
	mov	DWORD PTR tv467[esp+28], edx
	cmp	esi, eax
	jb	$LN86@IsAnySurve
$LN5@IsAnySurve:
	pop	edi
	pop	esi
	pop	ebp

; 1623 : 		}
; 1624 : 	}
; 1625 : 
; 1626 : 	return false;

	xor	al, al
	pop	ebx

; 1627 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN79@IsAnySurve:
	pop	edi
	pop	esi
	pop	ebp

; 1621 : 		{
; 1622 : 			return true;

	mov	al, 1
	pop	ebx

; 1627 : }

	add	esp, 12					; 0000000cH
	ret	4
?IsAnySurveillanceEstablished@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlayerEspionage::IsAnySurveillanceEstablished
_TEXT	ENDS
PUBLIC	?IsAnySchmoozing@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::IsAnySchmoozing
; Function compile flags: /Ogtpy
;	COMDAT ?IsAnySchmoozing@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiSpy$223455 = -8					; size = 4
tv473 = -4						; size = 4
_pCity$ = 8						; size = 4
?IsAnySchmoozing@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z PROC ; CvPlayerEspionage::IsAnySchmoozing, COMDAT
; _this$ = ecx

; 1659 : {

	sub	esp, 12					; 0000000cH

; 1660 : 	for(uint uiSpy = 0; uiSpy < m_aSpyList.size(); uiSpy++)

	mov	eax, DWORD PTR [ecx+8]
	push	ebx
	push	ebp
	push	esi
	xor	esi, esi
	push	edi
	mov	DWORD PTR _this$[esp+28], ecx
	mov	DWORD PTR _uiSpy$223455[esp+28], esi
	test	eax, eax
	jbe	$LN5@IsAnySchmo
	xor	edx, edx
	mov	DWORD PTR tv473[esp+28], edx

; 1661 : 	{
; 1662 : 		// can't have established surveillance when not in a city
; 1663 : 		if(!IsSpyInCity(uiSpy))

	cmp	esi, eax
	jae	$LN6@IsAnySchmo
$LN92@IsAnySchmo:
	mov	eax, DWORD PTR [ecx+4]
	add	eax, edx
	or	edi, -1
	cmp	DWORD PTR [eax+4], edi
	je	$LN6@IsAnySchmo
	cmp	DWORD PTR [eax+8], edi
	je	$LN6@IsAnySchmo

; 1664 : 		{
; 1665 : 			continue;
; 1666 : 		}
; 1667 : 
; 1668 : 		CvPlot* pPlot = GC.getMap().plot(m_aSpyList[uiSpy].m_iCityX, m_aSpyList[uiSpy].m_iCityY);

	mov	ecx, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [ecx+edx+8]
	lea	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN5@IsAnySchmo
	cmp	ebx, -2147483647			; 80000001H
	je	$LN5@IsAnySchmo
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN39@IsAnySchmo
	test	eax, eax
	jge	SHORT $LN41@IsAnySchmo
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN43@IsAnySchmo
$LN41@IsAnySchmo:
	cmp	eax, ecx
	jl	SHORT $LN39@IsAnySchmo
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN43@IsAnySchmo
$LN39@IsAnySchmo:
	mov	esi, eax
$LN43@IsAnySchmo:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN49@IsAnySchmo
	test	ebx, ebx
	jge	SHORT $LN51@IsAnySchmo
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN53@IsAnySchmo
$LN51@IsAnySchmo:
	cmp	ebx, edi
	jl	SHORT $LN49@IsAnySchmo
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN53@IsAnySchmo
$LN49@IsAnySchmo:
	mov	edx, ebx
$LN53@IsAnySchmo:
	test	esi, esi
	jl	$LN5@IsAnySchmo
	cmp	esi, ecx
	jge	$LN5@IsAnySchmo
	test	edx, edx
	jl	$LN5@IsAnySchmo
	cmp	edx, edi
	jge	$LN5@IsAnySchmo
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 1669 : 		CvAssertMsg(pPlot, "Spy coordinates did not point to plot");
; 1670 : 		if(!pPlot)

	je	SHORT $LN5@IsAnySchmo

; 1671 : 		{
; 1672 : 			return false;
; 1673 : 		}
; 1674 : 		CvCity* pPlotCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN5@IsAnySchmo
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN5@IsAnySchmo
	mov	edx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 1675 : 		CvAssertMsg(pPlotCity, "There is not a city at the specified plot");
; 1676 : 		if(!pPlotCity)

	test	eax, eax
	je	SHORT $LN5@IsAnySchmo

; 1677 : 		{
; 1678 : 			return false;
; 1679 : 		}
; 1680 : 		if(pCity == pPlotCity && IsSchmoozing(uiSpy))

	cmp	DWORD PTR _pCity$[esp+24], eax
	jne	SHORT $LN90@IsAnySchmo
	mov	eax, DWORD PTR _uiSpy$223455[esp+28]
	mov	ecx, DWORD PTR _this$[esp+28]
	cmp	eax, DWORD PTR [ecx+8]
	jae	SHORT $LN90@IsAnySchmo
	mov	edx, ecx
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR tv473[esp+28]
	cmp	DWORD PTR [eax+ecx+16], 7
	je	SHORT $LN84@IsAnySchmo
$LN90@IsAnySchmo:
	mov	esi, DWORD PTR _uiSpy$223455[esp+28]
	mov	edx, DWORD PTR tv473[esp+28]
	mov	ecx, DWORD PTR _this$[esp+28]
$LN6@IsAnySchmo:
	mov	eax, DWORD PTR [ecx+8]
	inc	esi
	add	edx, 28					; 0000001cH
	mov	DWORD PTR _uiSpy$223455[esp+28], esi
	mov	DWORD PTR tv473[esp+28], edx
	cmp	esi, eax
	jb	$LN92@IsAnySchmo
$LN5@IsAnySchmo:
	pop	edi
	pop	esi
	pop	ebp

; 1683 : 		}
; 1684 : 	}
; 1685 : 
; 1686 : 	return false;

	xor	al, al
	pop	ebx

; 1687 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN84@IsAnySchmo:
	pop	edi
	pop	esi
	pop	ebp

; 1681 : 		{
; 1682 : 			return true;

	mov	al, 1
	pop	ebx

; 1687 : }

	add	esp, 12					; 0000000cH
	ret	4
?IsAnySchmoozing@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ENDP ; CvPlayerEspionage::IsAnySchmoozing
_TEXT	ENDS
PUBLIC	?CanStageCoup@CvPlayerEspionage@@QAE_NI@Z	; CvPlayerEspionage::CanStageCoup
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
; Function compile flags: /Ogtpy
;	COMDAT ?CanStageCoup@CvPlayerEspionage@@QAE_NI@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?CanStageCoup@CvPlayerEspionage@@QAE_NI@Z PROC		; CvPlayerEspionage::CanStageCoup, COMDAT
; _this$ = ecx

; 1691 : {

	push	ebx
	push	esi

; 1692 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 1693 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	esi, DWORD PTR _uiSpyIndex$[esp+4]
	mov	ebx, ecx
	cmp	esi, DWORD PTR [ebx+8]
	jb	SHORT $LN6@CanStageCo

; 1694 : 	{
; 1695 : 		return false;
; 1696 : 	}
; 1697 : 
; 1698 : 	if(!IsSpyInCity(uiSpyIndex))

$LN12@CanStageCo:
	pop	esi
	xor	al, al
	pop	ebx

; 1730 : }

	ret	4
$LN6@CanStageCo:

; 1694 : 	{
; 1695 : 		return false;
; 1696 : 	}
; 1697 : 
; 1698 : 	if(!IsSpyInCity(uiSpyIndex))

	mov	ecx, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	cmp	DWORD PTR [ecx+eax*4+4], -1
	lea	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN12@CanStageCo
	cmp	DWORD PTR [eax+8], -1

; 1699 : 	{
; 1700 : 		return false;

	je	SHORT $LN12@CanStageCo
	push	edi

; 1701 : 	}
; 1702 : 
; 1703 : 	CvCity* pCity = GetCityWithSpy(uiSpyIndex);

	push	esi
	mov	ecx, ebx
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy
	mov	edi, eax

; 1704 : 	CvAssertMsg(pCity, "pCity is null!");
; 1705 : 	if(!pCity)

	test	edi, edi

; 1706 : 	{
; 1707 : 		return false;

	je	SHORT $LN1@CanStageCo

; 1708 : 	}
; 1709 : 
; 1710 : 	if(!HasEstablishedSurveillance(uiSpyIndex))

	push	esi
	mov	ecx, ebx
	call	?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::HasEstablishedSurveillance
	test	al, al

; 1711 : 	{
; 1712 : 		return false;

	je	SHORT $LN1@CanStageCo

; 1713 : 	}
; 1714 : 
; 1715 : 	PlayerTypes eCityOwner = pCity->getOwner();

	mov	esi, DWORD PTR [edi+84]

; 1716 : 	if(!GET_PLAYER(eCityOwner).isMinorCiv())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 1717 : 	{
; 1718 : 		return false;

	je	SHORT $LN1@CanStageCo

; 1719 : 	}
; 1720 : 
; 1721 : 	CvMinorCivAI* pMinorCivAI = GET_PLAYER(eCityOwner).GetMinorCivAI();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI

; 1722 : 	PlayerTypes eMinorCivAlly = pMinorCivAI->GetAlly();

	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 1723 : 
; 1724 : 	if(eMinorCivAlly != NO_PLAYER && eMinorCivAlly != m_pPlayer->GetID())

	cmp	eax, -1
	je	SHORT $LN1@CanStageCo
	mov	ecx, DWORD PTR [ebx+1296]
	cmp	eax, DWORD PTR [ecx+44]
	je	SHORT $LN1@CanStageCo
	pop	edi
	pop	esi

; 1725 : 	{
; 1726 : 		return true;

	mov	al, 1
	pop	ebx

; 1730 : }

	ret	4
$LN1@CanStageCo:
	pop	edi
	pop	esi

; 1727 : 	}
; 1728 : 
; 1729 : 	return false;

	xor	al, al
	pop	ebx

; 1730 : }

	ret	4
?CanStageCoup@CvPlayerEspionage@@QAE_NI@Z ENDP		; CvPlayerEspionage::CanStageCoup
_TEXT	ENDS
PUBLIC	__real@42c80000
PUBLIC	?GetCoupChanceOfSuccess@CvPlayerEspionage@@QAEHI@Z ; CvPlayerEspionage::GetCoupChanceOfSuccess
EXTRN	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT __real@42c80000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
CONST	ENDS
;	COMDAT ?GetCoupChanceOfSuccess@CvPlayerEspionage@@QAEHI@Z
_TEXT	SEGMENT
_bNoAllySpy$ = -41					; size = 1
_fMySpyValue$ = -40					; size = 4
_fAllySpyValue$ = -36					; size = 4
_iAllySpyRank$ = -32					; size = 4
_fSpyLevelDeltaTwo$ = -28				; size = 4
_fSpyLevelDeltaOne$ = -24				; size = 4
_fSpyLevelDeltaZero$ = -20				; size = 4
_eCityOwner$ = -16					; size = 4
_fMultiplyConstant$ = -12				; size = 4
_fNobodyBonus$ = -8					; size = 4
_iDeltaInfluence$ = -4					; size = 4
_fSpyMultipier$ = 8					; size = 4
_uiSpyIndex$ = 8					; size = 4
?GetCoupChanceOfSuccess@CvPlayerEspionage@@QAEHI@Z PROC	; CvPlayerEspionage::GetCoupChanceOfSuccess, COMDAT
; _this$ = ecx

; 1734 : {

	sub	esp, 44					; 0000002cH
	push	ebp
	push	esi

; 1735 : 	// if you can't stage a coup, then the likelihood is zero!
; 1736 : 	if(!CanStageCoup(uiSpyIndex))

	mov	esi, DWORD PTR _uiSpyIndex$[esp+48]
	push	esi
	mov	ebp, ecx
	call	?CanStageCoup@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::CanStageCoup
	test	al, al
	jne	SHORT $LN22@GetCoupCha
$LN65@GetCoupCha:
	pop	esi

; 1737 : 	{
; 1738 : 		return 0;

	xor	eax, eax
	pop	ebp

; 1878 : }

	add	esp, 44					; 0000002cH
	ret	4
$LN22@GetCoupCha:

; 1739 : 	}
; 1740 : 
; 1741 : 	CvCity* pCity = GetCityWithSpy(uiSpyIndex);

	push	esi
	mov	ecx, ebp
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy
	mov	esi, eax

; 1742 : 	CvAssertMsg(pCity, "No city");
; 1743 : 	if(!pCity)

	test	esi, esi

; 1744 : 	{
; 1745 : 		return 0;

	je	SHORT $LN65@GetCoupCha
	push	ebx

; 1746 : 	}
; 1747 : 
; 1748 : 	CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	ebx, eax

; 1749 : 	CvAssertMsg(pCityEspionage, "No city espionage");
; 1750 : 	if(!pCityEspionage)

	test	ebx, ebx

; 1751 : 	{
; 1752 : 		return 0;

	je	SHORT $LN64@GetCoupCha

; 1753 : 	}
; 1754 : 
; 1755 : 	PlayerTypes eCityOwner = pCity->getOwner();

	mov	esi, DWORD PTR [esi+84]

; 1756 : 	CvAssertMsg(GET_PLAYER(eCityOwner).isMinorCiv(), "Owner is not a minor civ");
; 1757 : 	if(!GET_PLAYER(eCityOwner).isMinorCiv())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _eCityOwner$[esp+56], esi
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN19@GetCoupCha
$LN64@GetCoupCha:
	pop	ebx
	pop	esi

; 1758 : 	{
; 1759 : 		return 0;

	xor	eax, eax
	pop	ebp

; 1878 : }

	add	esp, 44					; 0000002cH
	ret	4
$LN19@GetCoupCha:

; 1760 : 	}
; 1761 : 
; 1762 : 	CvMinorCivAI* pMinorCivAI = GET_PLAYER(eCityOwner).GetMinorCivAI();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	add	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	edi, eax

; 1763 : 	CvAssertMsg(pMinorCivAI, "pMinorCivAI is null");
; 1764 : 	if(!pMinorCivAI)

	test	edi, edi
	jne	SHORT $LN18@GetCoupCha
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 1878 : }

	add	esp, 44					; 0000002cH
	ret	4
$LN18@GetCoupCha:

; 1765 : 	{
; 1766 : 		return 0;
; 1767 : 	}
; 1768 : 
; 1769 : 	PlayerTypes eAllyPlayer = pMinorCivAI->GetAlly();

	mov	ecx, edi
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	esi, eax

; 1770 : 	int iAllySpyRank = 0;
; 1771 : 	bool bNoAllySpy = true;
; 1772 : 	if(pCityEspionage->m_aiSpyAssignment[eAllyPlayer] != -1)

	mov	ebx, DWORD PTR [ebx+esi*4+4]
	mov	DWORD PTR _iAllySpyRank$[esp+60], 0
	mov	BYTE PTR _bNoAllySpy$[esp+60], 1
	cmp	ebx, -1
	je	SHORT $LN17@GetCoupCha

; 1773 : 	{
; 1774 : 		int iAllySpyIndex = pCityEspionage->m_aiSpyAssignment[eAllyPlayer];
; 1775 : 		iAllySpyRank = GET_PLAYER(eAllyPlayer).GetEspionage()->m_aSpyList[iAllySpyIndex].m_eRank;

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [ebx*8]
	sub	edx, ebx
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	DWORD PTR _iAllySpyRank$[esp+60], ecx

; 1776 : #ifdef AUI_ESPIONAGE_FIX_RESTORE_ENEMY_SPY_COUP_MALUS
; 1777 : 		bNoAllySpy = false;

	mov	BYTE PTR _bNoAllySpy$[esp+60], 0
$LN17@GetCoupCha:

; 1778 : #else
; 1779 : 		bNoAllySpy = true;
; 1780 : #endif
; 1781 : 	}
; 1782 : 
; 1783 : 	int iAllyInfluence = pMinorCivAI->GetEffectiveFriendshipWithMajorTimes100(eAllyPlayer);

	push	esi
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100

; 1784 : #ifdef NQ_COUP_FORMULA_USES_BASE_FRIENDSHIP_NOT_EFFECTIVE_FRIENDSHIP
; 1785 : 	int iMyInfluence = pMinorCivAI->GetBaseFriendshipWithMajorTimes100(m_pPlayer->GetID());
; 1786 : #else
; 1787 : 	int iMyInfluence = pMinorCivAI->GetEffectiveFriendshipWithMajorTimes100(m_pPlayer->GetID());

	mov	edx, DWORD PTR [ebp+1296]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100

; 1788 : #endif
; 1789 : 	int iDeltaInfluence = iAllyInfluence - iMyInfluence;
; 1790 : 
; 1791 : 	//float fNobodyBonus = 0.5;
; 1792 : 	//float fMultiplyConstant = 3.0f;
; 1793 : 	//float fSpyLevelDeltaZero = 0.0f;
; 1794 : 	//float fSpyLevelDeltaOne = 1.5f;
; 1795 : 	//float fSpyLevelDeltaTwo = 2.25;
; 1796 : 	//float fSpyLevelDeltaThree = 3.0f;
; 1797 : 
; 1798 : 	float fNobodyBonus = GC.getESPIONAGE_COUP_NOBODY_BONUS();
; 1799 : 	float fMultiplyConstant = GC.getESPIONAGE_COUP_MULTIPLY_CONSTANT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8160

; 1800 : 	float fSpyLevelDeltaZero = GC.getESPIONAGE_COUP_SPY_LEVEL_DELTA_ZERO();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8164

; 1801 : 	float fSpyLevelDeltaOne = GC.getESPIONAGE_COUP_SPY_LEVEL_DELTA_ONE();
; 1802 : 	float fSpyLevelDeltaTwo = GC.getESPIONAGE_COUP_SPY_LEVEL_DELTA_TWO();
; 1803 : #ifndef NQM_PRUNING
; 1804 : 	float fSpyLevelDeltaThree = GC.getESPIONAGE_COUP_SPY_LEVEL_DELTA_THREE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8176

; 1805 : 	float fSpyLevelDeltaFour = GC.getESPIONAGE_COUP_SPY_LEVEL_DELTA_FOUR();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8180
	sub	esi, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8156
	mov	DWORD PTR _fNobodyBonus$[esp+60], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8168
	mov	DWORD PTR _fSpyLevelDeltaOne$[esp+60], eax

; 1806 : #endif
; 1807 : 
; 1808 : 	float fAllySpyValue = 0.0f;

	xor	eax, eax
	mov	DWORD PTR _fMultiplyConstant$[esp+60], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8172
	mov	DWORD PTR _fAllySpyValue$[esp+60], eax

; 1809 : 	float fMySpyValue = 0.0;

	mov	DWORD PTR _fMySpyValue$[esp+60], eax

; 1810 : 
; 1811 : 	int iMySpyRank = m_aSpyList[uiSpyIndex].m_eRank;

	mov	eax, DWORD PTR _uiSpyIndex$[esp+56]
	mov	DWORD PTR _fSpyLevelDeltaZero$[esp+60], edx
	mov	DWORD PTR _fSpyLevelDeltaTwo$[esp+60], ecx

; 1812 : 	iMySpyRank += m_pPlayer->GetCulture()->GetInfluenceCityStateSpyRankBonus(eCityOwner);

	mov	ecx, DWORD PTR _eCityOwner$[esp+60]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ebp+4]
	push	ecx
	mov	ecx, DWORD PTR [ebp+1296]
	mov	DWORD PTR _iDeltaInfluence$[esp+64], esi
	mov	esi, DWORD PTR [eax+edx*4+12]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus
	add	eax, esi

; 1813 : 	switch (iMySpyRank)

	cmp	eax, 4
	ja	SHORT $LN61@GetCoupCha
	jmp	DWORD PTR $LN66@GetCoupCha[eax*4]
$LN14@GetCoupCha:

; 1814 : 	{
; 1815 : 	case 0:
; 1816 : 		fMySpyValue = fSpyLevelDeltaZero;

	mov	edx, DWORD PTR _fSpyLevelDeltaZero$[esp+60]
	mov	DWORD PTR _fMySpyValue$[esp+60], edx

; 1817 : 		break;

	jmp	SHORT $LN61@GetCoupCha
$LN13@GetCoupCha:

; 1818 : 	case 1:
; 1819 : 		fMySpyValue = fSpyLevelDeltaOne;

	mov	eax, DWORD PTR _fSpyLevelDeltaOne$[esp+60]
	mov	DWORD PTR _fMySpyValue$[esp+60], eax

; 1820 : 		break;

	jmp	SHORT $LN61@GetCoupCha
$LN12@GetCoupCha:

; 1821 : 	case 2:
; 1822 : 		fMySpyValue = fSpyLevelDeltaTwo;

	mov	ecx, DWORD PTR _fSpyLevelDeltaTwo$[esp+60]
	mov	DWORD PTR _fMySpyValue$[esp+60], ecx

; 1823 : 		break;

	jmp	SHORT $LN61@GetCoupCha
$LN11@GetCoupCha:

; 1824 : #ifndef NQM_PRUNING
; 1825 : 	case 3:
; 1826 : 		fMySpyValue = fSpyLevelDeltaThree;

	mov	DWORD PTR _fMySpyValue$[esp+60], edi

; 1827 : 		break;

	jmp	SHORT $LN61@GetCoupCha
$LN10@GetCoupCha:

; 1828 : 	case 4:
; 1829 : 		fMySpyValue = fSpyLevelDeltaFour;

	mov	DWORD PTR _fMySpyValue$[esp+60], ebx
$LN61@GetCoupCha:

; 1830 : 		break;
; 1831 : #endif
; 1832 : 	}
; 1833 : 
; 1834 : 	switch (iAllySpyRank)

	mov	eax, DWORD PTR _iAllySpyRank$[esp+60]
	sub	eax, 0
	je	SHORT $LN7@GetCoupCha
	sub	eax, 1
	je	SHORT $LN6@GetCoupCha
	sub	eax, 1
	jne	SHORT $LN8@GetCoupCha

; 1842 : 	case 2:
; 1843 : 		fAllySpyValue = fSpyLevelDeltaTwo;

	mov	edx, DWORD PTR _fSpyLevelDeltaTwo$[esp+60]
	mov	DWORD PTR _fAllySpyValue$[esp+60], edx

; 1844 : 		break;

	jmp	SHORT $LN8@GetCoupCha
$LN6@GetCoupCha:

; 1838 : 		break;
; 1839 : 	case 1:
; 1840 : 		fAllySpyValue = fSpyLevelDeltaOne;

	mov	eax, DWORD PTR _fSpyLevelDeltaOne$[esp+60]
	mov	DWORD PTR _fAllySpyValue$[esp+60], eax

; 1841 : 		break;

	jmp	SHORT $LN8@GetCoupCha
$LN7@GetCoupCha:

; 1835 : 	{
; 1836 : 	case 0:
; 1837 : 		fAllySpyValue = fSpyLevelDeltaZero;

	mov	ecx, DWORD PTR _fSpyLevelDeltaZero$[esp+60]
	mov	DWORD PTR _fAllySpyValue$[esp+60], ecx
$LN8@GetCoupCha:

; 1845 : 	}	
; 1846 : 
; 1847 : 	float fSpyMultipier = fAllySpyValue - fMySpyValue + fMultiplyConstant;
; 1848 : 	if (bNoAllySpy)

	cmp	BYTE PTR _bNoAllySpy$[esp+60], 0
	fld	DWORD PTR _fAllySpyValue$[esp+60]
	fsub	DWORD PTR _fMySpyValue$[esp+60]
	fadd	DWORD PTR _fMultiplyConstant$[esp+60]
	fstp	DWORD PTR _fSpyMultipier$[esp+56]
	je	SHORT $LN4@GetCoupCha

; 1849 : 	{
; 1850 : 		fSpyMultipier *= fNobodyBonus;

	fld	DWORD PTR _fSpyMultipier$[esp+56]
	fmul	DWORD PTR _fNobodyBonus$[esp+60]
	fstp	DWORD PTR _fSpyMultipier$[esp+56]
$LN4@GetCoupCha:

; 1851 : 	}
; 1852 : 
; 1853 : 	int iResultPercentage = 100 - (int)((iDeltaInfluence * fSpyMultipier) / 100);
; 1854 : 
; 1855 : #ifdef NQ_COUP_CHANCE_MODIFIER_FROM_POLICIES
; 1856 : 	iResultPercentage += m_pPlayer->GetPlayerPolicies()->GetNumericModifier(POLICYMOD_COUP_CHANCE_MODIFIER);

	mov	ecx, DWORD PTR [ebp+1296]
	push	54					; 00000036H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	fild	DWORD PTR _iDeltaInfluence$[esp+60]
	mov	esi, eax
	fmul	DWORD PTR _fSpyMultipier$[esp+56]
	fdiv	DWORD PTR __real@42c80000
	call	__ftol2_sse_excpt
	mov	edx, 100				; 00000064H
	sub	edx, eax
	add	esi, edx

; 1857 : #endif
; 1858 : 
; 1859 : 	if(iResultPercentage > 85)

	cmp	esi, 85					; 00000055H
	jle	SHORT $LN3@GetCoupCha
	pop	edi

; 1860 : 	{
; 1861 : 		iResultPercentage = 85;

	mov	esi, 85					; 00000055H
	pop	ebx

; 1866 : 	}
; 1867 : 
; 1868 : 	//int iAdjustedAllyInfluenceTimes100 = iAllyInfluence * (100 + m_aSpyList[uiSpyIndex].m_eRank * 100);
; 1869 : 	//int iAdjustedAllyInfluence = iAdjustedAllyInfluenceTimes100 / 100;
; 1870 : 	//int iResultPercentage = 0;
; 1871 : 	//if (iAdjustedAllyInfluence != 0)
; 1872 : 	//{
; 1873 : 	//	iResultPercentage = 100 - ((iDeltaInfluence * 100) / iAdjustedAllyInfluence);
; 1874 : 	//}
; 1875 : 
; 1876 : 
; 1877 : 	return iResultPercentage;

	mov	eax, esi
	pop	esi
	pop	ebp

; 1878 : }

	add	esp, 44					; 0000002cH
	ret	4
$LN3@GetCoupCha:

; 1862 : 	}
; 1863 : 	else if(iResultPercentage < 0)

	test	esi, esi
	jge	SHORT $LN1@GetCoupCha

; 1864 : 	{
; 1865 : 		iResultPercentage = 0;

	xor	esi, esi
$LN1@GetCoupCha:
	pop	edi
	pop	ebx

; 1866 : 	}
; 1867 : 
; 1868 : 	//int iAdjustedAllyInfluenceTimes100 = iAllyInfluence * (100 + m_aSpyList[uiSpyIndex].m_eRank * 100);
; 1869 : 	//int iAdjustedAllyInfluence = iAdjustedAllyInfluenceTimes100 / 100;
; 1870 : 	//int iResultPercentage = 0;
; 1871 : 	//if (iAdjustedAllyInfluence != 0)
; 1872 : 	//{
; 1873 : 	//	iResultPercentage = 100 - ((iDeltaInfluence * 100) / iAdjustedAllyInfluence);
; 1874 : 	//}
; 1875 : 
; 1876 : 
; 1877 : 	return iResultPercentage;

	mov	eax, esi
	pop	esi
	pop	ebp

; 1878 : }

	add	esp, 44					; 0000002cH
	ret	4
	npad	1
$LN66@GetCoupCha:
	DD	$LN14@GetCoupCha
	DD	$LN13@GetCoupCha
	DD	$LN12@GetCoupCha
	DD	$LN11@GetCoupCha
	DD	$LN10@GetCoupCha
?GetCoupChanceOfSuccess@CvPlayerEspionage@@QAEHI@Z ENDP	; CvPlayerEspionage::GetCoupChanceOfSuccess
_TEXT	ENDS
PUBLIC	?GetTurnsUntilStateComplete@CvPlayerEspionage@@QAEHI@Z ; CvPlayerEspionage::GetTurnsUntilStateComplete
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnsUntilStateComplete@CvPlayerEspionage@@QAEHI@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?GetTurnsUntilStateComplete@CvPlayerEspionage@@QAEHI@Z PROC ; CvPlayerEspionage::GetTurnsUntilStateComplete, COMDAT
; _this$ = ecx

; 2099 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 2100 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jb	SHORT $LN11@GetTurnsUn

; 2101 : 	{
; 2102 : 		return -2;

	mov	eax, -2					; fffffffeH

; 2153 : }

	ret	4
$LN11@GetTurnsUn:

; 2103 : 	}
; 2104 : 
; 2105 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	edx, DWORD PTR [ecx+1296]
	push	ebx

; 2106 : 	CvCity* pCity;
; 2107 : 	CvCityEspionage* pCityEspionage;
; 2108 : 	int iAmountLeft = 0;
; 2109 : 	int iTurnsLeft = 0;
; 2110 : 
; 2111 : 	switch(m_aSpyList[uiSpyIndex].m_eSpyState)

	mov	ebx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [edx+44]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+16]
	push	edi
	xor	edi, edi
	cmp	edx, 8
	ja	SHORT $LN9@GetTurnsUn
	jmp	DWORD PTR $LN37@GetTurnsUn[edx*4]
$LN7@GetTurnsUn:

; 2112 : 	{
; 2113 : 	case SPY_STATE_UNASSIGNED:
; 2114 : 		// no end time
; 2115 : 		return -1;
; 2116 : 		break;
; 2117 : 	case SPY_STATE_TRAVELLING:
; 2118 : 	case SPY_STATE_SURVEILLANCE:
; 2119 : 	case SPY_STATE_GATHERING_INTEL:
; 2120 : 	case SPY_STATE_MAKING_INTRODUCTIONS:
; 2121 : 		pCity = GetCityWithSpy(uiSpyIndex);

	push	eax
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 2122 : 		CvAssertMsg(pCity, "GetCityWithSpy returned null. Has the wrong task");
; 2123 : 		if(!pCity)

	test	eax, eax

; 2124 : 		{
; 2125 : 			return -1;

	je	SHORT $LN9@GetTurnsUn

; 2126 : 		}
; 2127 : 		pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 2128 : 		iAmountLeft = pCityEspionage->m_aiGoal[ePlayer] - pCityEspionage->m_aiAmount[ePlayer];

	mov	ecx, DWORD PTR [eax+esi*4+268]
	sub	ecx, DWORD PTR [eax+esi*4+92]

; 2129 : 		if(pCityEspionage->m_aiRate[ePlayer] != 0)

	cmp	DWORD PTR [eax+esi*4+180], edi
	je	SHORT $LN4@GetTurnsUn

; 2130 : 		{
; 2131 : 			iTurnsLeft = iAmountLeft / pCityEspionage->m_aiRate[ePlayer];

	mov	esi, DWORD PTR [eax+esi*4+180]
	mov	eax, ecx
	cdq
	idiv	esi
	mov	edi, eax

; 2132 : 			if(iAmountLeft % pCityEspionage->m_aiRate[ePlayer] > 0)

	test	edx, edx
	jle	SHORT $LN4@GetTurnsUn

; 2133 : 			{
; 2134 : 				iTurnsLeft++;

	inc	edi
$LN4@GetTurnsUn:

; 2135 : 			}
; 2136 : 		}
; 2137 : 		return iTurnsLeft;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2153 : }

	ret	4
$LN3@GetTurnsUn:

; 2138 : 	case SPY_STATE_RIG_ELECTION:
; 2139 : 		return GC.getGame().GetTurnsUntilMinorCivElection();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTurnsUntilMinorCivElection@CvGame@@QAEHXZ ; CvGame::GetTurnsUntilMinorCivElection
	pop	edi
	pop	esi
	pop	ebx

; 2153 : }

	ret	4
$LN9@GetTurnsUn:
	pop	edi
	pop	esi

; 2140 : 		break;
; 2141 : 	case SPY_STATE_COUNTER_INTEL:
; 2142 : 	case SPY_STATE_SCHMOOZE:
; 2143 : 		// no end time
; 2144 : 		return -1;
; 2145 : 		break;
; 2146 : 	case SPY_STATE_DEAD:
; 2147 : 		// no end time
; 2148 : 		return -1;
; 2149 : 		break;
; 2150 : 	}
; 2151 : 
; 2152 : 	return -1;

	or	eax, -1
	pop	ebx

; 2153 : }

	ret	4
	npad	3
$LN37@GetTurnsUn:
	DD	$LN9@GetTurnsUn
	DD	$LN7@GetTurnsUn
	DD	$LN7@GetTurnsUn
	DD	$LN7@GetTurnsUn
	DD	$LN3@GetTurnsUn
	DD	$LN9@GetTurnsUn
	DD	$LN7@GetTurnsUn
	DD	$LN9@GetTurnsUn
	DD	$LN9@GetTurnsUn
?GetTurnsUntilStateComplete@CvPlayerEspionage@@QAEHI@Z ENDP ; CvPlayerEspionage::GetTurnsUntilStateComplete
_TEXT	ENDS
PUBLIC	?GetPercentOfStateComplete@CvPlayerEspionage@@QAEHI@Z ; CvPlayerEspionage::GetPercentOfStateComplete
EXTRN	?GetTurnsBetweenMinorCivElections@CvGame@@QAEHXZ:PROC ; CvGame::GetTurnsBetweenMinorCivElections
; Function compile flags: /Ogtpy
;	COMDAT ?GetPercentOfStateComplete@CvPlayerEspionage@@QAEHI@Z
_TEXT	SEGMENT
_uiSpyIndex$ = 8					; size = 4
?GetPercentOfStateComplete@CvPlayerEspionage@@QAEHI@Z PROC ; CvPlayerEspionage::GetPercentOfStateComplete, COMDAT
; _this$ = ecx

; 2158 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 2159 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jb	SHORT $LN12@GetPercent

; 2160 : 	{
; 2161 : 		return -2;

	mov	eax, -2					; fffffffeH

; 2220 : }

	ret	4
$LN12@GetPercent:

; 2162 : 	}
; 2163 : 
; 2164 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	edx, DWORD PTR [ecx+1296]
	push	esi
	mov	esi, DWORD PTR [edx+44]

; 2165 : 	CvCity* pCity = NULL;
; 2166 : 	CvCityEspionage* pCityEspionage = NULL;
; 2167 : #ifdef AUI_WARNING_FIXES
; 2168 : 	const CvGame& kGame = GC.getGame();
; 2169 : #endif
; 2170 : 
; 2171 : 	switch(m_aSpyList[uiSpyIndex].m_eSpyState)

	lea	edx, DWORD PTR [eax*8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	sub	edx, eax
	mov	edx, DWORD PTR [edi+edx*4+16]
	cmp	edx, 8
	ja	SHORT $LN10@GetPercent
	jmp	DWORD PTR $LN40@GetPercent[edx*4]
$LN8@GetPercent:

; 2172 : 	{
; 2173 : 	case SPY_STATE_UNASSIGNED:
; 2174 : 		// no end time
; 2175 : 		return -1;
; 2176 : 		break;
; 2177 : 	case SPY_STATE_TRAVELLING:
; 2178 : 	case SPY_STATE_SURVEILLANCE:
; 2179 : 	case SPY_STATE_GATHERING_INTEL:
; 2180 : 	case SPY_STATE_MAKING_INTRODUCTIONS:
; 2181 : 		pCity = GetCityWithSpy(uiSpyIndex);

	push	eax
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 2182 : 		if (pCity)

	test	eax, eax
	je	SHORT $LN10@GetPercent

; 2183 : 		{
; 2184 : 			pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 2185 : 			CvAssertMsg(pCityEspionage->m_aiGoal[ePlayer] != 0, "Trying to div by zero!");
; 2186 : 			if(pCityEspionage->m_aiGoal[ePlayer] != 0)

	mov	ecx, DWORD PTR [eax+esi*4+268]
	test	ecx, ecx
	je	SHORT $LN10@GetPercent

; 2187 : 			{
; 2188 : 				return (pCityEspionage->m_aiAmount[ePlayer] * 100) / pCityEspionage->m_aiGoal[ePlayer];

	mov	eax, DWORD PTR [eax+esi*4+92]
	imul	eax, 100				; 00000064H
	cdq
	pop	edi
	idiv	ecx
	pop	esi

; 2220 : }

	ret	4
$LN5@GetPercent:

; 2189 : 			}
; 2190 : 		}
; 2191 : 		return -1;
; 2192 : 	case SPY_STATE_RIG_ELECTION:
; 2193 : #ifdef AUI_WARNING_FIXES
; 2194 : 		if (kGame.GetTurnsBetweenMinorCivElections() != 0)
; 2195 : 		{
; 2196 : 			return ((kGame.GetTurnsBetweenMinorCivElections() - kGame.GetTurnsUntilMinorCivElection()) * 100) / kGame.GetTurnsBetweenMinorCivElections();
; 2197 : #else
; 2198 : 		if(GC.getGame().GetTurnsBetweenMinorCivElections() != 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTurnsBetweenMinorCivElections@CvGame@@QAEHXZ ; CvGame::GetTurnsBetweenMinorCivElections
	test	eax, eax
	je	SHORT $LN10@GetPercent

; 2199 : 		{
; 2200 : 			return ((GC.getGame().GetTurnsBetweenMinorCivElections() - GC.getGame().GetTurnsUntilMinorCivElection()) * 100) / GC.getGame().GetTurnsBetweenMinorCivElections();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	mov	esi, ecx
	mov	edi, ecx
	call	?GetTurnsUntilMinorCivElection@CvGame@@QAEHXZ ; CvGame::GetTurnsUntilMinorCivElection
	mov	ecx, esi
	mov	ebx, eax
	call	?GetTurnsBetweenMinorCivElections@CvGame@@QAEHXZ ; CvGame::GetTurnsBetweenMinorCivElections
	mov	esi, eax
	sub	esi, ebx
	mov	ecx, edi
	imul	esi, 100				; 00000064H
	call	?GetTurnsBetweenMinorCivElections@CvGame@@QAEHXZ ; CvGame::GetTurnsBetweenMinorCivElections
	mov	ecx, eax
	mov	eax, esi
	pop	ebx
	cdq
	pop	edi
	idiv	ecx
	pop	esi

; 2220 : }

	ret	4
$LN10@GetPercent:
	pop	edi

; 2201 : #endif
; 2202 : 		}
; 2203 : 		else
; 2204 : 		{
; 2205 : 			return -1;
; 2206 : 		}
; 2207 : 		break;
; 2208 : 	case SPY_STATE_COUNTER_INTEL:
; 2209 : 	case SPY_STATE_SCHMOOZE:
; 2210 : 		// no end time
; 2211 : 		return -1;
; 2212 : 		break;
; 2213 : 	case SPY_STATE_DEAD:
; 2214 : 		// no end time
; 2215 : 		return -1;
; 2216 : 		break;
; 2217 : 	}
; 2218 : 
; 2219 : 	return -1;

	or	eax, -1
	pop	esi

; 2220 : }

	ret	4
	npad	2
$LN40@GetPercent:
	DD	$LN10@GetPercent
	DD	$LN8@GetPercent
	DD	$LN8@GetPercent
	DD	$LN8@GetPercent
	DD	$LN5@GetPercent
	DD	$LN10@GetPercent
	DD	$LN8@GetPercent
	DD	$LN10@GetPercent
	DD	$LN10@GetPercent
?GetPercentOfStateComplete@CvPlayerEspionage@@QAEHI@Z ENDP ; CvPlayerEspionage::GetPercentOfStateComplete
_TEXT	ENDS
PUBLIC	?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ; CvPlayerEspionage::IsMyDiplomatVisitingThem
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bIncludeTravelling$ = 12				; size = 1
?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z PROC ; CvPlayerEspionage::IsMyDiplomatVisitingThem, COMDAT
; _this$ = ecx

; 2364 : {

	push	esi
	mov	esi, ecx

; 2365 : 	CvCity* pTheirCapital = GET_PLAYER(ePlayer).getCapitalCity();

	mov	ecx, DWORD PTR _ePlayer$[esp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 2366 : 	if (!pTheirCapital)

	test	eax, eax
	jne	SHORT $LN10@IsMyDiplom
$LN21@IsMyDiplom:

; 2367 : 	{
; 2368 : 		return false;

	xor	al, al
	pop	esi

; 2393 : }

	ret	8

; 2369 : 	}
; 2370 : 
; 2371 : 	int iSpyIndex = GetSpyIndexInCity(pTheirCapital);

$LN10@IsMyDiplom:
	mov	ecx, DWORD PTR [esi+1296]
	push	edi
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	mov	eax, DWORD PTR [eax+edi*4]
	pop	edi

; 2372 : 
; 2373 : 	if (iSpyIndex < 0)

	test	eax, eax

; 2374 : 	{
; 2375 : 		return false;

	jl	SHORT $LN21@IsMyDiplom

; 2376 : 	}
; 2377 : 
; 2378 : 	if (!m_aSpyList[iSpyIndex].m_bIsDiplomat)

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	cmp	BYTE PTR [ecx+edx*4+24], 0

; 2379 : 	{
; 2380 : 		return false;

	je	SHORT $LN21@IsMyDiplom

; 2381 : 	}
; 2382 : 
; 2383 : 	if (!bIncludeTravelling)

	cmp	BYTE PTR _bIncludeTravelling$[esp], 0
	jne	SHORT $LN1@IsMyDiplom

; 2384 : 	{
; 2385 : 		// If the spy is not schmoozing yet, then it doesn't count as a diplomat yet
; 2386 : 		if (!IsSchmoozing(iSpyIndex))

	push	eax
	mov	ecx, esi
	call	?IsSchmoozing@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::IsSchmoozing
	test	al, al

; 2387 : 		{
; 2388 : 			return false;

	je	SHORT $LN21@IsMyDiplom
$LN1@IsMyDiplom:

; 2389 : 		}
; 2390 : 	}
; 2391 : 
; 2392 : 	return true;

	mov	al, 1
	pop	esi

; 2393 : }

	ret	8
?IsMyDiplomatVisitingThem@CvPlayerEspionage@@QAE_NW4PlayerTypes@@_N@Z ENDP ; CvPlayerEspionage::IsMyDiplomatVisitingThem
_TEXT	ENDS
PUBLIC	?IsOtherDiplomatVisitingMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ; CvPlayerEspionage::IsOtherDiplomatVisitingMe
; Function compile flags: /Ogtpy
;	COMDAT ?IsOtherDiplomatVisitingMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsOtherDiplomatVisitingMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlayerEspionage::IsOtherDiplomatVisitingMe, COMDAT
; _this$ = ecx

; 2397 : 	return GET_PLAYER(ePlayer).GetEspionage()->IsMyDiplomatVisitingThem(m_pPlayer->GetID());

	mov	eax, DWORD PTR [ecx+1296]
	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, DWORD PTR [eax+44]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, eax
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	jne	SHORT $LN18@IsOtherDip
$LN29@IsOtherDip:
	pop	edi
	xor	al, al
	pop	esi

; 2398 : }

	ret	4

; 2397 : 	return GET_PLAYER(ePlayer).GetEspionage()->IsMyDiplomatVisitingThem(m_pPlayer->GetID());

$LN18@IsOtherDip:
	mov	ecx, DWORD PTR [edi+1296]
	mov	esi, DWORD PTR [ecx+44]
	mov	ecx, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	jl	SHORT $LN29@IsOtherDip
	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	cmp	BYTE PTR [ecx+edx*4+24], 0
	je	SHORT $LN29@IsOtherDip
	push	eax
	mov	ecx, edi
	call	?IsSchmoozing@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::IsSchmoozing
	test	al, al
	pop	edi
	setne	al
	pop	esi

; 2398 : }

	ret	4
?IsOtherDiplomatVisitingMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlayerEspionage::IsOtherDiplomatVisitingMe
_TEXT	ENDS
PUBLIC	?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z ; CvPlayerEspionage::GetIntrigueMessage
EXTRN	__imp_??0String@Localization@@QAE@ABV01@@Z:PROC
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
EXTRN	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z:PROC ; CvGlobals::getProjectInfo
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationAdjectiveKey
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	?getNickName@CvPlayer@@QBEQBDXZ:PROC		; CvPlayer::getNickName
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??0String@Localization@@QAE@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
xdata$x	SEGMENT
__ehfuncinfo$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$11
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$13
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$14
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$15
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$16
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$17
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$18
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$19
	DD	01H
	DD	FLAT:__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$20
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z
_TEXT	SEGMENT
_pCity$ = -1624						; size = 4
$T238381 = -1620					; size = 4
_strResult$ = -1616					; size = 80
$T238237 = -1536					; size = 4
$T238194 = -1532					; size = 80
$T238204 = -1452					; size = 80
$T238205 = -1372					; size = 80
$T238176 = -1292					; size = 80
$T238208 = -1212					; size = 80
$T238184 = -1132					; size = 80
$T238212 = -1052					; size = 80
$T238191 = -972						; size = 80
$T238215 = -892						; size = 80
$T238199 = -812						; size = 80
$T238220 = -732						; size = 80
$T238181 = -652						; size = 80
$T238225 = -572						; size = 80
$T238170 = -492						; size = 80
$T238226 = -412						; size = 80
$T238187 = -332						; size = 80
$T238229 = -252						; size = 80
$T238173 = -172						; size = 80
$T238230 = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_uiIndex$ = 12						; size = 4
?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z PROC ; CvPlayerEspionage::GetIntrigueMessage, COMDAT
; _this$ = ecx

; 3200 : {

	push	-1
	push	__ehhandler$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1612				; 0000064cH
	push	ebx
	push	ebp

; 3201 : 	CvAssertMsg(uiIndex < m_aIntrigueNotificationMessages.size(), "uiIndex out of bounds");
; 3202 : 	if(uiIndex >= m_aIntrigueNotificationMessages.size())

	mov	ebp, DWORD PTR _uiIndex$[esp+1628]
	push	esi
	xor	ebx, ebx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T238237[esp+1640], ebx
	mov	ecx, DWORD PTR [edi+1288]
	sub	ecx, DWORD PTR [edi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	jb	SHORT $LN81@GetIntrigu

; 3203 : 	{
; 3204 : 		return "";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+1636]
	push	OFFSET $SG224235
	mov	ecx, esi
	call	DWORD PTR __imp_??0String@Localization@@QAE@PBD@Z
	jmp	$LN571@GetIntrigu
$LN81@GetIntrigu:

; 3205 : 	}
; 3206 : 
; 3207 : 	Localization::String strResult = "";

	push	OFFSET $SG224237
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	DWORD PTR __imp_??0String@Localization@@QAE@PBD@Z

; 3208 : 
; 3209 : 	// get the city if it exists
; 3210 : 	CvCity* pCity = NULL;
; 3211 : 	if(m_aIntrigueNotificationMessages[uiIndex].m_iCityX != -1 && m_aIntrigueNotificationMessages[uiIndex].m_iCityY)

	mov	ecx, DWORD PTR [edi+1284]
	mov	esi, ebp
	shl	esi, 4
	add	esi, ebp
	add	esi, esi
	add	esi, esi
	cmp	DWORD PTR [ecx+esi+28], -1
	lea	eax, DWORD PTR [ecx+esi]
	mov	DWORD PTR __$EHRec$[esp+1648], 1
	mov	DWORD PTR _pCity$[esp+1640], ebx
	je	$LN79@GetIntrigu
	cmp	DWORD PTR [eax+32], ebx
	je	$LN79@GetIntrigu

; 3212 : 	{
; 3213 : 		CvPlot* pPlot = GC.getMap().plot(m_aIntrigueNotificationMessages[uiIndex].m_iCityX, m_aIntrigueNotificationMessages[uiIndex].m_iCityY);

	mov	edx, ecx
	mov	ecx, DWORD PTR [edx+esi+32]
	lea	eax, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR $T238381[esp+1640], ecx
	cmp	eax, -2147483647			; 80000001H
	je	$LN79@GetIntrigu
	cmp	ecx, -2147483647			; 80000001H
	je	$LN79@GetIntrigu
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN128@GetIntrigu
	cmp	eax, ebx
	jge	SHORT $LN130@GetIntrigu
	cdq
	idiv	ecx
	mov	ebp, edx
	add	ebp, ecx
	jmp	SHORT $LN132@GetIntrigu
$LN130@GetIntrigu:
	cmp	eax, ecx
	jl	SHORT $LN128@GetIntrigu
	cdq
	idiv	ecx
	mov	ebp, edx
	jmp	SHORT $LN132@GetIntrigu
$LN128@GetIntrigu:
	mov	ebp, eax
$LN132@GetIntrigu:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebx, DWORD PTR [edx+4024]
	mov	edx, DWORD PTR $T238381[esp+1640]
	test	al, al
	je	SHORT $LN138@GetIntrigu
	test	edx, edx
	jge	SHORT $LN140@GetIntrigu
	mov	eax, edx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN138@GetIntrigu
$LN140@GetIntrigu:
	cmp	edx, ebx
	jl	SHORT $LN138@GetIntrigu
	mov	eax, edx
	cdq
	idiv	ebx
$LN138@GetIntrigu:
	test	ebp, ebp
	jl	SHORT $LN79@GetIntrigu
	cmp	ebp, ecx
	jge	SHORT $LN79@GetIntrigu
	test	edx, edx
	jl	SHORT $LN79@GetIntrigu
	cmp	edx, ebx
	jge	SHORT $LN79@GetIntrigu
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, ebp
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]

; 3214 : 		if(pPlot)

	test	ecx, ecx
	je	SHORT $LN79@GetIntrigu

; 3215 : 		{
; 3216 : 			pCity = pPlot->getPlotCity();

	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[esp+1640], eax
$LN79@GetIntrigu:

; 3217 : 		}
; 3218 : 	}
; 3219 : 
; 3220 : 	switch(m_aIntrigueNotificationMessages[uiIndex].m_iIntrigueType)

	mov	ecx, DWORD PTR [edi+1284]
	lea	eax, DWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, 5
	ja	$LN568@GetIntrigu
	jmp	DWORD PTR $LN602@GetIntrigu[ecx*4]
$LN76@GetIntrigu:

; 3221 : 	{
; 3222 : 	case INTRIGUE_TYPE_DECEPTION:
; 3223 : 		if(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer == m_pPlayer->GetID())  // if we found intrigue related to us

	mov	edx, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, ecx
	jne	$LN75@GetIntrigu

; 3224 : 		{
; 3225 : 			strResult = Localization::Lookup("TXT_KEY_INTRIGUE_PLOTTING_AGAINST_YOU");

	lea	eax, DWORD PTR $T238170[esp+1640]
	push	OFFSET $SG224249
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 2
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238170[esp+1640]
$LN593@GetIntrigu:
	mov	BYTE PTR __$EHRec$[esp+1648], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3226 : 			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	$LN62@GetIntrigu
	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN62@GetIntrigu

; 3227 : 			{
; 3228 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();

	mov	edi, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [edi+esi+4]
	add	edi, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3229 : 			}
; 3230 : 			else

	jmp	$LN568@GetIntrigu
$LN75@GetIntrigu:

; 3231 : 			{
; 3232 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3233 : 			}
; 3234 : 		}
; 3235 : 		else if(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer == NO_PLAYER)  // if we don't know who the intrigue information is about

	cmp	eax, -1
	jne	SHORT $LN71@GetIntrigu

; 3236 : 		{
; 3237 : 			strResult = Localization::Lookup("TXT_KEY_INTRIGUE_PLOTTING_AGAINST_UNKNOWN");

	lea	ecx, DWORD PTR $T238173[esp+1640]
	push	OFFSET $SG224257
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 3
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238173[esp+1640]

; 3238 : 			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3239 : 			{
; 3240 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3241 : 			}
; 3242 : 			else

	jmp	$LN593@GetIntrigu
$LN71@GetIntrigu:

; 3243 : 			{
; 3244 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3245 : 			}
; 3246 : 		}
; 3247 : 		else // if we found intrigue related to another player
; 3248 : 		{
; 3249 : 			strResult = Localization::Lookup("TXT_KEY_INTRIGUE_PLOTTING_AGAINST_KNOWN");

	lea	edx, DWORD PTR $T238176[esp+1640]
	push	OFFSET $SG224264
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238176[esp+1640]
$LN601@GetIntrigu:
	mov	BYTE PTR __$EHRec$[esp+1648], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3250 : 			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN67@GetIntrigu
	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN67@GetIntrigu

; 3251 : 			{
; 3252 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();

	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3253 : 			}
; 3254 : 			else

	jmp	SHORT $LN572@GetIntrigu
$LN67@GetIntrigu:

; 3255 : 			{
; 3256 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();

	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN572@GetIntrigu:
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	ebp

; 3257 : 			}
; 3258 : 
; 3259 : 			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN65@GetIntrigu
	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+8]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN65@GetIntrigu

; 3260 : 			{
; 3261 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getNickName();

	mov	edi, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [edi+esi+8]
	add	edi, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3262 : 			}
; 3263 : 			else

	jmp	$LN573@GetIntrigu
$LN65@GetIntrigu:

; 3264 : 			{
; 3265 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getNameKey();

	mov	edi, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [edi+esi+8]
	add	edi, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey

; 3266 : 			}
; 3267 : 		}
; 3268 : 		break;

	jmp	$LN573@GetIntrigu
$LN63@GetIntrigu:

; 3269 : 	case INTRIGUE_TYPE_BUILDING_ARMY:
; 3270 : 		strResult = Localization::Lookup("TXT_KEY_INTRIGUE_BUILDING_ARMY");

	lea	eax, DWORD PTR $T238181[esp+1640]
	push	OFFSET $SG224275
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238181[esp+1640]

; 3271 : 		if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3272 : 		{
; 3273 : 			strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3274 : 		}
; 3275 : 		else

	jmp	$LN593@GetIntrigu
$LN62@GetIntrigu:

; 3276 : 		{
; 3277 : 			strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();

	mov	edi, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [edi+esi+4]
	add	edi, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 3278 : 		}
; 3279 : 		break;

	jmp	$LN568@GetIntrigu
$LN60@GetIntrigu:

; 3280 : 	case INTRIGUE_TYPE_BUILDING_AMPHIBIOUS_ARMY:
; 3281 : 		strResult = Localization::Lookup("TXT_KEY_INTRIGUE_BUILDING_AMPHIBIOUS_ARMY");

	lea	ecx, DWORD PTR $T238184[esp+1640]
	push	OFFSET $SG224282
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 6
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238184[esp+1640]

; 3282 : 		if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3283 : 		{
; 3284 : 			strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3285 : 		}
; 3286 : 		else

	jmp	$LN593@GetIntrigu
$LN57@GetIntrigu:

; 3287 : 		{
; 3288 : 			strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3289 : 		}
; 3290 : 		break;
; 3291 : 	case INTRIGUE_TYPE_ARMY_SNEAK_ATTACK:
; 3292 : 		// player is target
; 3293 : 		if(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer == m_pPlayer->GetID())

	mov	edx, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, ecx
	jne	$LN56@GetIntrigu

; 3294 : 		{
; 3295 : 			if(pCity)

	mov	ebx, DWORD PTR _pCity$[esp+1640]
	test	ebx, ebx
	je	$LN55@GetIntrigu

; 3296 : 			{
; 3297 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_KNOWN");

	lea	eax, DWORD PTR $T238187[esp+1640]
	push	OFFSET $SG224291
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 7
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238187[esp+1640]
$LN599@GetIntrigu:
	mov	BYTE PTR __$EHRec$[esp+1648], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3298 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN54@GetIntrigu
	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN54@GetIntrigu

; 3299 : 				{
; 3300 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();

	mov	edi, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [edi+esi+4]
	add	edi, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3301 : 				}
; 3302 : 				else

	jmp	SHORT $LN574@GetIntrigu
$LN54@GetIntrigu:

; 3303 : 				{
; 3304 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();

	mov	edi, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [edi+esi+4]
	add	edi, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN574@GetIntrigu:
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	esi

; 3305 : 				}
; 3306 : 				strResult << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	esi

; 3307 : 			}
; 3308 : 			else

	jmp	$LN568@GetIntrigu
$LN55@GetIntrigu:

; 3309 : 			{
; 3310 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_UNKNOWN");

	lea	ecx, DWORD PTR $T238191[esp+1640]
	push	OFFSET $SG224299
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238191[esp+1640]

; 3311 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3312 : 				{
; 3313 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3314 : 				}
; 3315 : 				else

	jmp	$LN593@GetIntrigu
$LN56@GetIntrigu:

; 3316 : 				{
; 3317 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3318 : 				}
; 3319 : 			}
; 3320 : 		}
; 3321 : 		// other player is target
; 3322 : 		else if(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer != NO_PLAYER && m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer != MAX_MAJOR_CIVS)

	cmp	eax, -1
	je	$LN48@GetIntrigu
	cmp	eax, 22					; 00000016H
	je	$LN576@GetIntrigu

; 3323 : 		{
; 3324 : 			if(pCity)

	mov	ebx, DWORD PTR _pCity$[esp+1640]
	test	ebx, ebx
	je	$LN47@GetIntrigu

; 3325 : 			{
; 3326 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_KNOWN");

	lea	edx, DWORD PTR $T238194[esp+1640]
	push	OFFSET $SG224308
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238194[esp+1640]
$LN600@GetIntrigu:
	mov	BYTE PTR __$EHRec$[esp+1648], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3327 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN46@GetIntrigu
	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN46@GetIntrigu

; 3328 : 				{
; 3329 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();

	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3330 : 				}
; 3331 : 				else

	jmp	SHORT $LN577@GetIntrigu
$LN46@GetIntrigu:

; 3332 : 				{
; 3333 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();

	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN577@GetIntrigu:
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	ebp

; 3334 : 				}
; 3335 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getCivilizationAdjectiveKey();

	mov	edi, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [edi+esi+8]
	add	edi, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	ebp

; 3336 : 				strResult << pCity->getNameKey();
; 3337 : 			}
; 3338 : 			else

	jmp	$LN578@GetIntrigu
$LN47@GetIntrigu:

; 3339 : 			{
; 3340 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_UNKNOWN");

	lea	eax, DWORD PTR $T238199[esp+1640]
	push	OFFSET $SG224317
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 10	; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238199[esp+1640]

; 3341 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3342 : 				{
; 3343 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3344 : 				}
; 3345 : 				else

	jmp	$LN601@GetIntrigu
$LN48@GetIntrigu:

; 3346 : 				{
; 3347 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3348 : 				}
; 3349 : 
; 3350 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).isHuman())
; 3351 : 				{
; 3352 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getNickName();
; 3353 : 				}
; 3354 : 				else
; 3355 : 				{
; 3356 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getNameKey();
; 3357 : 				}
; 3358 : 			}
; 3359 : 		}
; 3360 : 		// unknown player is target
; 3361 : 		else
; 3362 : 		{
; 3363 : 			if (m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer == MAX_MAJOR_CIVS)

	cmp	eax, 22					; 00000016H
	jne	SHORT $LN38@GetIntrigu
$LN576@GetIntrigu:

; 3364 : 			{
; 3365 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_SOMEONE");

	lea	ecx, DWORD PTR $T238204[esp+1640]
	push	OFFSET $SG224329
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 11	; 0000000bH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238204[esp+1640]

; 3366 : 			}
; 3367 : 			else

	jmp	$LN593@GetIntrigu
$LN38@GetIntrigu:

; 3368 : 			{
; 3369 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_UNKNOWN");

	lea	edx, DWORD PTR $T238205[esp+1640]
	push	OFFSET $SG224332
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 12	; 0000000cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238205[esp+1640]

; 3370 : 			}
; 3371 : 			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3372 : 			{
; 3373 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3374 : 			}
; 3375 : 			else

	jmp	$LN593@GetIntrigu
$LN34@GetIntrigu:

; 3376 : 			{
; 3377 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3378 : 			}
; 3379 : 		}
; 3380 : 		break;
; 3381 : 	case INTRIGUE_TYPE_AMPHIBIOUS_SNEAK_ATTACK:
; 3382 : 		// player is target
; 3383 : 		if(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer == m_pPlayer->GetID())

	mov	ecx, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, ecx
	jne	SHORT $LN33@GetIntrigu

; 3384 : 		{
; 3385 : 			if(pCity)

	mov	ebx, DWORD PTR _pCity$[esp+1640]
	test	ebx, ebx
	je	SHORT $LN32@GetIntrigu

; 3386 : 			{
; 3387 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_KNOWN");

	lea	edx, DWORD PTR $T238208[esp+1640]
	push	OFFSET $SG224341
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 13	; 0000000dH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238208[esp+1640]

; 3388 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3389 : 				{
; 3390 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3391 : 				}
; 3392 : 				else

	jmp	$LN599@GetIntrigu
$LN32@GetIntrigu:

; 3393 : 				{
; 3394 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3395 : 				}
; 3396 : 				strResult << pCity->getNameKey();
; 3397 : 			}
; 3398 : 			else
; 3399 : 			{
; 3400 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_UNKNOWN");

	lea	eax, DWORD PTR $T238212[esp+1640]
	push	OFFSET $SG224349
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 14	; 0000000eH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238212[esp+1640]

; 3401 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3402 : 				{
; 3403 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3404 : 				}
; 3405 : 				else

	jmp	$LN593@GetIntrigu
$LN33@GetIntrigu:

; 3406 : 				{
; 3407 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3408 : 				}
; 3409 : 			}
; 3410 : 		}
; 3411 : 		// other player is target
; 3412 : 		else if(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer != NO_PLAYER && m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer != MAX_MAJOR_CIVS)

	cmp	eax, -1
	je	SHORT $LN25@GetIntrigu
	cmp	eax, 22					; 00000016H
	je	SHORT $LN583@GetIntrigu

; 3413 : 		{
; 3414 : 			if(pCity)

	mov	ebx, DWORD PTR _pCity$[esp+1640]
	test	ebx, ebx
	je	SHORT $LN24@GetIntrigu

; 3415 : 			{
; 3416 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_KNOWN");

	lea	ecx, DWORD PTR $T238215[esp+1640]
	push	OFFSET $SG224358
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 15	; 0000000fH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238215[esp+1640]

; 3417 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3418 : 				{
; 3419 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3420 : 				}
; 3421 : 				else

	jmp	$LN600@GetIntrigu
$LN24@GetIntrigu:

; 3422 : 				{
; 3423 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3424 : 				}
; 3425 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getCivilizationAdjectiveKey();
; 3426 : 				strResult << pCity->getNameKey();
; 3427 : 			}
; 3428 : 			else
; 3429 : 			{
; 3430 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_UNKNOWN");

	lea	edx, DWORD PTR $T238220[esp+1640]
	push	OFFSET $SG224367
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 16	; 00000010H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238220[esp+1640]

; 3431 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3432 : 				{
; 3433 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3434 : 				}
; 3435 : 				else

	jmp	$LN601@GetIntrigu
$LN25@GetIntrigu:

; 3436 : 				{
; 3437 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3438 : 				}
; 3439 : 
; 3440 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).isHuman())
; 3441 : 				{
; 3442 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getNickName();
; 3443 : 				}
; 3444 : 				else
; 3445 : 				{
; 3446 : 					strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer).getNameKey();
; 3447 : 				}
; 3448 : 			}
; 3449 : 		}
; 3450 : 		// unknown player is target
; 3451 : 		else
; 3452 : 		{
; 3453 : 			if (m_aIntrigueNotificationMessages[uiIndex].m_eTargetPlayer == MAX_MAJOR_CIVS)

	cmp	eax, 22					; 00000016H
	jne	SHORT $LN15@GetIntrigu
$LN583@GetIntrigu:

; 3454 : 			{
; 3455 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_SOMEONE");

	lea	eax, DWORD PTR $T238225[esp+1640]
	push	OFFSET $SG224379
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 17	; 00000011H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238225[esp+1640]

; 3456 : 			}
; 3457 : 			else

	jmp	$LN593@GetIntrigu
$LN15@GetIntrigu:

; 3458 : 			{
; 3459 : 				strResult = Localization::Lookup("TXT_KEY_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_UNKNOWN");

	lea	ecx, DWORD PTR $T238226[esp+1640]
	push	OFFSET $SG224382
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 18	; 00000012H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238226[esp+1640]

; 3460 : 			}
; 3461 : 
; 3462 : 			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())
; 3463 : 			{
; 3464 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();
; 3465 : 			}
; 3466 : 			else

	jmp	$LN593@GetIntrigu
$LN11@GetIntrigu:

; 3467 : 			{
; 3468 : 				strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();
; 3469 : 			}
; 3470 : 		}
; 3471 : 		break;
; 3472 : 	case INTRIGUE_TYPE_CONSTRUCTING_WONDER:
; 3473 : 		if (pCity)

	mov	ebx, DWORD PTR _pCity$[esp+1640]
	test	ebx, ebx
	je	SHORT $LN10@GetIntrigu

; 3474 : 		{
; 3475 : 			strResult = Localization::Lookup("TXT_KEY_INTRIGUE_CONSTRUCT_WONDER");

	lea	edx, DWORD PTR $T238229[esp+1640]
	push	OFFSET $SG224390
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 19	; 00000013H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238229[esp+1640]

; 3476 : 		}
; 3477 : 		else

	jmp	SHORT $LN587@GetIntrigu
$LN10@GetIntrigu:

; 3478 : 		{
; 3479 : 			strResult = Localization::Lookup("TXT_KEY_INTRIGUE_CONSTRUCT_WONDER_WO_CITY");

	lea	eax, DWORD PTR $T238230[esp+1640]
	push	OFFSET $SG224393
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	mov	BYTE PTR __$EHRec$[esp+1652], 20	; 00000014H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T238230[esp+1640]
$LN587@GetIntrigu:
	mov	BYTE PTR __$EHRec$[esp+1648], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3480 : 		}
; 3481 : 		if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN8@GetIntrigu
	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN8@GetIntrigu

; 3482 : 		{
; 3483 : 			strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNickName();

	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3484 : 		}
; 3485 : 		else

	jmp	SHORT $LN588@GetIntrigu
$LN8@GetIntrigu:

; 3486 : 		{
; 3487 : 			strResult << GET_PLAYER(m_aIntrigueNotificationMessages[uiIndex].m_eSourcePlayer).getNameKey();

	mov	eax, DWORD PTR [edi+1284]
	mov	ecx, DWORD PTR [eax+esi+4]
	add	eax, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN588@GetIntrigu:
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	ebp

; 3488 : 		}
; 3489 : 		if (m_aIntrigueNotificationMessages[uiIndex].m_eBuilding != NO_BUILDING)

	mov	ecx, DWORD PTR [edi+1284]
	lea	eax, DWORD PTR [ecx+esi]
	or	ecx, -1
	cmp	DWORD PTR [eax+12], ecx
	je	SHORT $LN6@GetIntrigu

; 3490 : 		{
; 3491 : 			CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(m_aIntrigueNotificationMessages[uiIndex].m_eBuilding);

	mov	edx, DWORD PTR [eax+12]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3492 : 			CvAssertMsg(pBuildingInfo, "pBuildingInfo is null");
; 3493 : 			if (pBuildingInfo)
; 3494 : 			{
; 3495 : 				strResult << pBuildingInfo->GetTextKey();
; 3496 : 			}
; 3497 : 		}

	jmp	SHORT $LN590@GetIntrigu
$LN6@GetIntrigu:

; 3498 : 		else if (m_aIntrigueNotificationMessages[uiIndex].m_eProject != NO_PROJECT)

	cmp	DWORD PTR [eax+16], ecx
	je	SHORT $LN569@GetIntrigu

; 3499 : 		{
; 3500 : 			CvProjectEntry* pProjectInfo = GC.getProjectInfo(m_aIntrigueNotificationMessages[uiIndex].m_eProject);

	mov	eax, DWORD PTR [eax+16]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
$LN590@GetIntrigu:

; 3501 : 			CvAssertMsg(pProjectInfo, "pProjectInfo is null");
; 3502 : 			if (pProjectInfo)

	test	eax, eax
	je	SHORT $LN569@GetIntrigu

; 3503 : 			{
; 3504 : 				strResult << pProjectInfo->GetTextKey();

	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	ebp
$LN569@GetIntrigu:

; 3505 : 			}
; 3506 : 		}
; 3507 : 
; 3508 : 		if (pCity)

	test	ebx, ebx
	je	SHORT $LN568@GetIntrigu
$LN578@GetIntrigu:

; 3509 : 		{
; 3510 : 			strResult << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
$LN573@GetIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strResult$[esp+1644]
	call	ebp
$LN568@GetIntrigu:

; 3511 : 		}
; 3512 : 		break;
; 3513 : 	}
; 3514 : 
; 3515 : 	return strResult;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+1636]
	lea	ecx, DWORD PTR _strResult$[esp+1640]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_??0String@Localization@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR _strResult$[esp+1640]
	mov	DWORD PTR $T238237[esp+1640], 1
	mov	BYTE PTR __$EHRec$[esp+1648], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN571@GetIntrigu:

; 3516 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1640]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1624				; 00000658H
	ret	8
	npad	1
$LN602@GetIntrigu:
	DD	$LN76@GetIntrigu
	DD	$LN63@GetIntrigu
	DD	$LN60@GetIntrigu
	DD	$LN57@GetIntrigu
	DD	$LN34@GetIntrigu
	DD	$LN11@GetIntrigu
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$0:
	mov	eax, DWORD PTR $T238237[ebp]
	and	eax, 1
	je	$LN85@GetIntrigu
	and	DWORD PTR $T238237[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN85@GetIntrigu:
	ret	0
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$1:
	lea	ecx, DWORD PTR _strResult$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$2:
	lea	ecx, DWORD PTR $T238170[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$3:
	lea	ecx, DWORD PTR $T238173[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$4:
	lea	ecx, DWORD PTR $T238176[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$5:
	lea	ecx, DWORD PTR $T238181[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$6:
	lea	ecx, DWORD PTR $T238184[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$7:
	lea	ecx, DWORD PTR $T238187[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$8:
	lea	ecx, DWORD PTR $T238191[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$9:
	lea	ecx, DWORD PTR $T238194[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$10:
	lea	ecx, DWORD PTR $T238199[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$11:
	lea	ecx, DWORD PTR $T238204[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$12:
	lea	ecx, DWORD PTR $T238205[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$13:
	lea	ecx, DWORD PTR $T238208[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$14:
	lea	ecx, DWORD PTR $T238212[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$15:
	lea	ecx, DWORD PTR $T238215[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$16:
	lea	ecx, DWORD PTR $T238220[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$17:
	lea	ecx, DWORD PTR $T238225[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$18:
	lea	ecx, DWORD PTR $T238226[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$19:
	lea	ecx, DWORD PTR $T238229[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z$20:
	lea	ecx, DWORD PTR $T238230[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetIntrigueMessage@CvPlayerEspionage@@QAE?AVString@Localization@@I@Z ENDP ; CvPlayerEspionage::GetIntrigueMessage
PUBLIC	?HasRecentIntrigueAbout@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ; CvPlayerEspionage::HasRecentIntrigueAbout
; Function compile flags: /Ogtpy
;	COMDAT ?HasRecentIntrigueAbout@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eTargetPlayer$ = 8					; size = 4
?HasRecentIntrigueAbout@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlayerEspionage::HasRecentIntrigueAbout, COMDAT
; _this$ = ecx

; 3521 : 	IntrigueNotificationMessage* pMessage = GetRecentIntrigueInfo(eTargetPlayer);

	mov	eax, DWORD PTR _eTargetPlayer$[esp-4]
	push	eax
	call	?GetRecentIntrigueInfo@CvPlayerEspionage@@QAEPAUIntrigueNotificationMessage@@W4PlayerTypes@@@Z ; CvPlayerEspionage::GetRecentIntrigueInfo

; 3522 : 	if(pMessage && pMessage->m_eSourcePlayer != NO_PLAYER && pMessage->m_iIntrigueType != NUM_INTRIGUE_TYPES)

	test	eax, eax
	je	SHORT $LN2@HasRecentI
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN2@HasRecentI
	cmp	DWORD PTR [eax+20], 6
	je	SHORT $LN2@HasRecentI

; 3523 : 	{
; 3524 : 		return true;

	mov	al, 1

; 3529 : 	}
; 3530 : }

	ret	4
$LN2@HasRecentI:

; 3525 : 	}
; 3526 : 	else
; 3527 : 	{
; 3528 : 		return false;

	xor	al, al

; 3529 : 	}
; 3530 : }

	ret	4
?HasRecentIntrigueAbout@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlayerEspionage::HasRecentIntrigueAbout
_TEXT	ENDS
PUBLIC	?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0W4CvIntrigueType@@@Z ; CvPlayerEspionage::HasSharedIntrigue
; Function compile flags: /Ogtpy
;	COMDAT ?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0W4CvIntrigueType@@@Z
_TEXT	SEGMENT
_eTargetPlayer$ = 8					; size = 4
_eSourcePlayer$ = 12					; size = 4
_eIntrigueType$ = 16					; size = 4
?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0W4CvIntrigueType@@@Z PROC ; CvPlayerEspionage::HasSharedIntrigue, COMDAT
; _this$ = ecx

; 3564 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3565 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [esi+1288]
	sub	ecx, DWORD PTR [esi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebx, ebx
	add	eax, edx
	push	edi
	je	SHORT $LN7@HasSharedI
	xor	ebp, ebp
	npad	7
$LL9@HasSharedI:

; 3566 : 	{
; 3567 : 		IntrigueNotificationMessage* pMessage = &(m_aIntrigueNotificationMessages[ui]);

	mov	ecx, DWORD PTR [esi+1284]

; 3568 : 
; 3569 : 		// if we HAVE NOT shared this information, don't count it
; 3570 : 		if(!pMessage->m_bShared)

	cmp	BYTE PTR [ecx+ebp+64], 0
	lea	edi, DWORD PTR [ecx+ebp]
	je	SHORT $LN8@HasSharedI

; 3571 : 		{
; 3572 : 			continue;
; 3573 : 		}
; 3574 : 
; 3575 : 		// if we did not discover the message, we cannot share the intrigue
; 3576 : 		if (pMessage->m_eDiscoveringPlayer != m_pPlayer->GetID())

	mov	edx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx+44]
	jne	SHORT $LN8@HasSharedI

; 3577 : 		{
; 3578 : 			continue;
; 3579 : 		}
; 3580 : 
; 3581 : 		if(pMessage->m_eTargetPlayer != eTargetPlayer)

	mov	ecx, DWORD PTR _eTargetPlayer$[esp+12]
	cmp	DWORD PTR [edi+8], ecx
	jne	SHORT $LN8@HasSharedI

; 3582 : 		{
; 3583 : 			continue;
; 3584 : 		}
; 3585 : 
; 3586 : 		if(pMessage->m_eSourcePlayer != eSourcePlayer)

	mov	edx, DWORD PTR _eSourcePlayer$[esp+12]
	cmp	DWORD PTR [edi+4], edx
	jne	SHORT $LN8@HasSharedI

; 3587 : 		{
; 3588 : 			continue;
; 3589 : 		}
; 3590 : 
; 3591 : 		if(pMessage->m_iIntrigueType != eIntrigueType)

	mov	eax, DWORD PTR _eIntrigueType$[esp+12]
	cmp	DWORD PTR [edi+20], eax
	jne	SHORT $LN8@HasSharedI

; 3592 : 		{
; 3593 : 			continue;
; 3594 : 		}
; 3595 : 
; 3596 : 		// has this intrigue been shared the last 30 turns?
; 3597 : 		if((GC.getGame().getGameTurn() - m_aIntrigueNotificationMessages[ui].m_iTurnNum) > 30)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR [edi+24]
	cmp	eax, 30					; 0000001eH
	jle	SHORT $LN1@HasSharedI
$LN8@HasSharedI:

; 3565 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [esi+1288]
	sub	ecx, DWORD PTR [esi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	ebx
	add	ecx, edx
	add	ebp, 68					; 00000044H
	cmp	ebx, ecx
	jb	SHORT $LL9@HasSharedI
$LN7@HasSharedI:
	pop	edi
	pop	esi
	pop	ebp

; 3603 : 	}
; 3604 : 
; 3605 : 	return false;

	xor	al, al
	pop	ebx

; 3606 : }

	ret	12					; 0000000cH
$LN1@HasSharedI:
	pop	edi
	pop	esi
	pop	ebp

; 3598 : 		{
; 3599 : 			continue;
; 3600 : 		}
; 3601 : 
; 3602 : 		return true;

	mov	al, 1
	pop	ebx

; 3606 : }

	ret	12					; 0000000cH
?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0W4CvIntrigueType@@@Z ENDP ; CvPlayerEspionage::HasSharedIntrigue
_TEXT	ENDS
PUBLIC	?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0@Z ; CvPlayerEspionage::HasSharedIntrigue
; Function compile flags: /Ogtpy
;	COMDAT ?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_eTargetPlayer$ = 8					; size = 4
_eSourcePlayer$ = 12					; size = 4
?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0@Z PROC ; CvPlayerEspionage::HasSharedIntrigue, COMDAT
; _this$ = ecx

; 3611 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	edx, DWORD PTR [ecx+1288]
	sub	edx, DWORD PTR [ecx+1284]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	push	ebx
	push	ebp
	sar	edx, 5
	push	esi
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	xor	edi, edi
	add	eax, edx
	je	SHORT $LN5@HasSharedI@2
	mov	edx, DWORD PTR [ecx+1288]
	sub	edx, DWORD PTR [ecx+1284]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	mov	eax, DWORD PTR [ecx+1284]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	edx, DWORD PTR _eSourcePlayer$[esp+12]
	npad	4
$LL21@HasSharedI@2:

; 3612 : 	{
; 3613 : 		IntrigueNotificationMessage* pMessage = &(m_aIntrigueNotificationMessages[ui]);
; 3614 : 
; 3615 : 		// if we HAVE NOT shared this information, don't count it
; 3616 : 		if(!pMessage->m_bShared)

	cmp	BYTE PTR [eax+64], 0
	je	SHORT $LN6@HasSharedI@2

; 3617 : 		{
; 3618 : 			continue;
; 3619 : 		}
; 3620 : 
; 3621 : 		// can't share intrigue we didn't discover
; 3622 : 		if (pMessage->m_eDiscoveringPlayer != m_pPlayer->GetID())

	mov	ebx, DWORD PTR [ecx+1296]
	mov	ebp, DWORD PTR [eax]
	cmp	ebp, DWORD PTR [ebx+44]
	jne	SHORT $LN6@HasSharedI@2

; 3623 : 		{
; 3624 : 			continue;
; 3625 : 		}
; 3626 : 
; 3627 : 		if(pMessage->m_eTargetPlayer != eTargetPlayer)

	mov	ebx, DWORD PTR _eTargetPlayer$[esp+12]
	cmp	DWORD PTR [eax+8], ebx
	jne	SHORT $LN6@HasSharedI@2

; 3628 : 		{
; 3629 : 			continue;
; 3630 : 		}
; 3631 : 
; 3632 : 		if(pMessage->m_eSourcePlayer != eSourcePlayer)

	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN1@HasSharedI@2
$LN6@HasSharedI@2:

; 3611 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	inc	edi
	add	eax, 68					; 00000044H
	cmp	edi, esi
	jb	SHORT $LL21@HasSharedI@2
$LN5@HasSharedI@2:
	pop	edi
	pop	esi
	pop	ebp

; 3638 : 	}
; 3639 : 
; 3640 : 	return false;

	xor	al, al
	pop	ebx

; 3641 : }

	ret	8
$LN1@HasSharedI@2:
	pop	edi
	pop	esi
	pop	ebp

; 3633 : 		{
; 3634 : 			continue;
; 3635 : 		}
; 3636 : 
; 3637 : 		return true;

	mov	al, 1
	pop	ebx

; 3641 : }

	ret	8
?HasSharedIntrigue@CvPlayerEspionage@@QAE_NW4PlayerTypes@@0@Z ENDP ; CvPlayerEspionage::HasSharedIntrigue
_TEXT	ENDS
PUBLIC	?MarkRecentIntrigueAsShared@CvPlayerEspionage@@QAEHW4PlayerTypes@@0W4CvIntrigueType@@@Z ; CvPlayerEspionage::MarkRecentIntrigueAsShared
; Function compile flags: /Ogtpy
;	COMDAT ?MarkRecentIntrigueAsShared@CvPlayerEspionage@@QAEHW4PlayerTypes@@0W4CvIntrigueType@@@Z
_TEXT	SEGMENT
_eTargetPlayer$ = 8					; size = 4
_eSourcePlayer$ = 12					; size = 4
_eIntrigueType$ = 16					; size = 4
?MarkRecentIntrigueAsShared@CvPlayerEspionage@@QAEHW4PlayerTypes@@0W4CvIntrigueType@@@Z PROC ; CvPlayerEspionage::MarkRecentIntrigueAsShared, COMDAT
; _this$ = ecx

; 3647 : 	int iNumShared = 0;
; 3648 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	edx, DWORD PTR [ecx+1288]
	sub	edx, DWORD PTR [ecx+1284]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	push	ebp
	mov	eax, edx
	push	esi
	shr	eax, 31					; 0000001fH
	xor	ebp, ebp
	xor	esi, esi
	add	eax, edx
	je	SHORT $LN21@MarkRecent
	push	ebx
	push	edi
	xor	edi, edi
	npad	7
$LL23@MarkRecent:

; 3649 : 	{
; 3650 : 		IntrigueNotificationMessage* pMessage = &(m_aIntrigueNotificationMessages[ui]);

	mov	eax, DWORD PTR [ecx+1284]
	add	eax, edi

; 3651 : 		if(pMessage->m_bShared)

	cmp	BYTE PTR [eax+64], 0
	jne	SHORT $LN7@MarkRecent

; 3652 : 		{
; 3653 : 			continue;
; 3654 : 		}
; 3655 : 
; 3656 : 		// can't share intrigue messages we don't own
; 3657 : 		if (pMessage->m_eDiscoveringPlayer != m_pPlayer->GetID())

	mov	edx, DWORD PTR [ecx+1296]
	mov	ebx, DWORD PTR [eax]
	cmp	ebx, DWORD PTR [edx+44]
	jne	SHORT $LN7@MarkRecent

; 3658 : 		{
; 3659 : 			continue;
; 3660 : 		}
; 3661 : 
; 3662 : 		if(pMessage->m_eTargetPlayer != eTargetPlayer)

	mov	edx, DWORD PTR _eTargetPlayer$[esp+12]
	cmp	DWORD PTR [eax+8], edx
	jne	SHORT $LN7@MarkRecent

; 3663 : 		{
; 3664 : 			continue;
; 3665 : 		}
; 3666 : 
; 3667 : 		if(pMessage->m_eSourcePlayer != eSourcePlayer)

	mov	edx, DWORD PTR _eSourcePlayer$[esp+12]
	cmp	DWORD PTR [eax+4], edx
	jne	SHORT $LN7@MarkRecent

; 3668 : 		{
; 3669 : 			continue;
; 3670 : 		}
; 3671 : 
; 3672 : 		if(pMessage->m_iIntrigueType != eIntrigueType)

	mov	edx, DWORD PTR _eIntrigueType$[esp+12]
	cmp	DWORD PTR [eax+20], edx
	jne	SHORT $LN7@MarkRecent

; 3673 : 		{
; 3674 : 			continue;
; 3675 : 		}
; 3676 : 
; 3677 : 		// this message has not been shared. Marking it as shared.
; 3678 : 		pMessage->m_bShared = true;

	mov	BYTE PTR [eax+64], 1

; 3679 : 		iNumShared++;

	inc	ebp
$LN7@MarkRecent:
	mov	edx, DWORD PTR [ecx+1288]
	sub	edx, DWORD PTR [ecx+1284]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	add	edi, 68					; 00000044H
	cmp	esi, eax
	jb	SHORT $LL23@MarkRecent
	pop	edi
	pop	ebx
$LN21@MarkRecent:
	pop	esi

; 3680 : 	}
; 3681 : 
; 3682 : 	return iNumShared;

	mov	eax, ebp
	pop	ebp

; 3683 : }

	ret	12					; 0000000cH
?MarkRecentIntrigueAsShared@CvPlayerEspionage@@QAEHW4PlayerTypes@@0W4CvIntrigueType@@@Z ENDP ; CvPlayerEspionage::MarkRecentIntrigueAsShared
_TEXT	ENDS
PUBLIC	??0CvCityEspionage@@QAE@XZ			; CvCityEspionage::CvCityEspionage
; Function compile flags: /Ogtpy
;	COMDAT ??0CvCityEspionage@@QAE@XZ
_TEXT	SEGMENT
??0CvCityEspionage@@QAE@XZ PROC				; CvCityEspionage::CvCityEspionage, COMDAT
; _this$ = ecx

; 3949 : {

	push	esi
	mov	esi, ecx

; 3950 : 	Reset();

	call	?Reset@CvCityEspionage@@QAEXXZ		; CvCityEspionage::Reset

; 3951 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvCityEspionage@@QAE@XZ ENDP				; CvCityEspionage::CvCityEspionage
_TEXT	ENDS
PUBLIC	?Init@CvCityEspionage@@QAEXPAVCvCity@@@Z	; CvCityEspionage::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvCityEspionage@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?Init@CvCityEspionage@@QAEXPAVCvCity@@@Z PROC		; CvCityEspionage::Init, COMDAT
; _this$ = ecx

; 3960 : {

	push	esi
	mov	esi, ecx

; 3961 : 	Reset();

	call	?Reset@CvCityEspionage@@QAEXXZ		; CvCityEspionage::Reset

; 3962 : 
; 3963 : 	m_pCity = pCity;

	mov	eax, DWORD PTR _pCity$[esp]
	mov	DWORD PTR [esi], eax
	pop	esi

; 3964 : }

	ret	4
?Init@CvCityEspionage@@QAEXPAVCvCity@@@Z ENDP		; CvCityEspionage::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvCityEspionage@@QAEXXZ			; CvCityEspionage::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvCityEspionage@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvCityEspionage@@QAEXXZ PROC			; CvCityEspionage::Uninit, COMDAT
; _this$ = ecx

; 3969 : 	Reset();

	jmp	?Reset@CvCityEspionage@@QAEXXZ		; CvCityEspionage::Reset
?Uninit@CvCityEspionage@@QAEXXZ ENDP			; CvCityEspionage::Uninit
_TEXT	ENDS
PUBLIC	?HasCounterSpy@CvCityEspionage@@QAE_NXZ		; CvCityEspionage::HasCounterSpy
; Function compile flags: /Ogtpy
;	COMDAT ?HasCounterSpy@CvCityEspionage@@QAE_NXZ
_TEXT	SEGMENT
?HasCounterSpy@CvCityEspionage@@QAE_NXZ PROC		; CvCityEspionage::HasCounterSpy, COMDAT
; _this$ = ecx

; 4055 : 	return m_aiSpyAssignment[m_pCity->getOwner()] != -1;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+84]
	xor	eax, eax
	cmp	DWORD PTR [ecx+edx*4+4], -1
	setne	al

; 4056 : }

	ret	0
?HasCounterSpy@CvCityEspionage@@QAE_NXZ ENDP		; CvCityEspionage::HasCounterSpy
_TEXT	ENDS
PUBLIC	??0CvEspionageAI@@QAE@XZ			; CvEspionageAI::CvEspionageAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??0CvEspionageAI@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0CvEspionageAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvEspionageAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEspionageAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvEspionageAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvEspionageAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvEspionageAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvEspionageAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvEspionageAI@@QAE@XZ$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvEspionageAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEspionageAI@@QAE@XZ PROC				; CvEspionageAI::CvEspionageAI, COMDAT
; _this$ = ecx

; 4216 : {

	push	-1
	push	__ehhandler$??0CvEspionageAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	push	esi
	mov	DWORD PTR [eax], ecx
	lea	esi, DWORD PTR [eax+16]
	mov	edx, 22					; 00000016H
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+4], esi
	lea	esi, DWORD PTR [eax+120]
	mov	DWORD PTR [eax+112], ecx
	mov	DWORD PTR [eax+116], edx
	mov	DWORD PTR [eax+108], esi
	lea	esi, DWORD PTR [eax+224]
	mov	DWORD PTR [eax+216], ecx
	mov	DWORD PTR [eax+220], edx
	mov	DWORD PTR [eax+212], esi
	lea	esi, DWORD PTR [eax+328]
	mov	DWORD PTR [eax+320], ecx
	mov	DWORD PTR [eax+324], edx
	mov	DWORD PTR [eax+316], esi
	lea	esi, DWORD PTR [eax+432]
	mov	DWORD PTR [eax+424], ecx
	mov	DWORD PTR [eax+428], edx
	mov	DWORD PTR [eax+420], esi
	lea	esi, DWORD PTR [eax+536]
	mov	DWORD PTR [eax+528], ecx
	mov	DWORD PTR [eax+532], edx
	mov	DWORD PTR [eax+524], esi
	mov	DWORD PTR [eax+632], ecx
	lea	esi, DWORD PTR [eax+640]
	mov	DWORD PTR [eax+628], esi
	mov	DWORD PTR [eax+636], edx
	mov	BYTE PTR [eax+732], cl

; 4217 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [eax+736], -1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEspionageAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??0CvEspionageAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??0CvEspionageAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??0CvEspionageAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??0CvEspionageAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 420				; 000001a4H
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??0CvEspionageAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__ehhandler$??0CvEspionageAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvEspionageAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEspionageAI@@QAE@XZ ENDP				; CvEspionageAI::CvEspionageAI
PUBLIC	?GetCityStatePlan@CvEspionageAI@@QAEHPAW4PlayerTypes@@@Z ; CvEspionageAI::GetCityStatePlan
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStatePlan@CvEspionageAI@@QAEHPAW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iCurrentPlan$ = -92					; size = 4
_aiMajorCivVotes$226390 = -88				; size = 88
_peDiploThreat$ = 8					; size = 4
?GetCityStatePlan@CvEspionageAI@@QAEHPAW4PlayerTypes@@@Z PROC ; CvEspionageAI::GetCityStatePlan, COMDAT
; _this$ = ecx

; 5465 : {

	sub	esp, 92					; 0000005cH
	push	ebp
	push	edi
	mov	ebp, ecx

; 5466 : 	int iCurrentPlan = PLAN_PLAY_NORMAL; 
; 5467 : 	PlayerTypes eCurrentDiploThreat = NO_PLAYER;

	or	edi, -1

; 5468 : 	if (m_bUNCountdownStarted)

	cmp	BYTE PTR [ebp+732], 0
	mov	DWORD PTR _iCurrentPlan$[esp+100], 3
	je	$LN48@GetCitySta

; 5469 : 	{
; 5470 : 		int aiMajorCivVotes[MAX_MAJOR_CIVS];
; 5471 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 5472 : 		{
; 5473 : 			aiMajorCivVotes[ui] = 0;

	xor	eax, eax
	push	ebx
	push	esi
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+108], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+112], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+116], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+120], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+124], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+128], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+132], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+136], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+140], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+144], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+148], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+152], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+156], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+160], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+164], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+168], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+172], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+176], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+180], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+184], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+188], eax
	mov	DWORD PTR _aiMajorCivVotes$226390[esp+192], eax

; 5474 : 		}
; 5475 : 
; 5476 : 		int iAliveMinorCivs = 0;

	xor	ebx, ebx
	mov	esi, 1391192				; 00153a58H
$LL17@GetCitySta:

; 5477 : 
; 5478 : 		for(uint ui = MAX_MAJOR_CIVS; ui < MAX_CIV_PLAYERS; ui++)
; 5479 : 		{
; 5480 : 			PlayerTypes eTargetPlayer = (PlayerTypes)ui;
; 5481 : 
; 5482 : 			// only count minor civs
; 5483 : 			if (!GET_PLAYER(eTargetPlayer).isMinorCiv())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN16@GetCitySta

; 5536 : 	}
; 5537 : 	return iCurrentPlan;

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN16@GetCitySta
	inc	ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	je	SHORT $LN16@GetCitySta
	inc	DWORD PTR _aiMajorCivVotes$226390[esp+eax*4+108]
	lea	eax, DWORD PTR _aiMajorCivVotes$226390[esp+eax*4+108]
$LN16@GetCitySta:
	add	esi, 63236				; 0000f704H
	cmp	esi, 3983868				; 003cc9fcH
	jb	SHORT $LL17@GetCitySta
	xor	ecx, ecx
	xor	eax, eax
$LL11@GetCitySta:
	mov	edx, DWORD PTR _aiMajorCivVotes$226390[esp+eax*4+108]
	cmp	edx, ecx
	jle	SHORT $LN10@GetCitySta
	mov	ecx, edx
	mov	edi, eax
$LN10@GetCitySta:
	mov	edx, DWORD PTR _aiMajorCivVotes$226390[esp+eax*4+112]
	cmp	edx, ecx
	jle	SHORT $LN45@GetCitySta
	mov	ecx, edx
	lea	edi, DWORD PTR [eax+1]
$LN45@GetCitySta:
	add	eax, 2
	cmp	eax, 22					; 00000016H
	jb	SHORT $LL11@GetCitySta

; 5484 : 			{
; 5485 : 				continue;
; 5486 : 			}
; 5487 : 
; 5488 : 			if (!GET_PLAYER(eTargetPlayer).isAlive())
; 5489 : 			{
; 5490 : 				continue;
; 5491 : 			}
; 5492 : 
; 5493 : 			iAliveMinorCivs++;
; 5494 : 
; 5495 : 			PlayerTypes eAllyPlayer = GET_PLAYER(eTargetPlayer).GetMinorCivAI()->GetAlly();
; 5496 : 			if (eAllyPlayer != NO_PLAYER)
; 5497 : 			{
; 5498 : 				aiMajorCivVotes[eAllyPlayer]++;
; 5499 : 			}
; 5500 : 		}
; 5501 : 
; 5502 : 		int iMaxVotes = 0;
; 5503 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 5504 : 		{
; 5505 : 			PlayerTypes eTargetPlayer = (PlayerTypes)ui;
; 5506 : 			if (aiMajorCivVotes[eTargetPlayer] > iMaxVotes)
; 5507 : 			{
; 5508 : 				iMaxVotes = aiMajorCivVotes[eTargetPlayer];
; 5509 : 				eCurrentDiploThreat = eTargetPlayer;
; 5510 : 			}
; 5511 : 		}
; 5512 : 
; 5513 : 		if (eCurrentDiploThreat != NO_PLAYER)

	cmp	edi, -1
	je	SHORT $LN50@GetCitySta

; 5514 : 		{
; 5515 : 			if (iMaxVotes >= iAliveMinorCivs / 2)

	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jl	SHORT $LN6@GetCitySta

; 5516 : 			{
; 5517 : 				if (eCurrentDiploThreat == m_pPlayer->GetID())

	mov	edx, DWORD PTR [ebp]
	xor	eax, eax
	cmp	edi, DWORD PTR [edx+44]
	setne	al
	mov	DWORD PTR _iCurrentPlan$[esp+108], eax

; 5518 : 				{
; 5519 : 					iCurrentPlan = PLAN_DEFEND_CS_FOR_WIN;
; 5520 : 				}
; 5521 : 				else
; 5522 : 				{
; 5523 : 					iCurrentPlan = PLAN_ATTACK_CS_TO_PREVENT_DEFEAT;
; 5524 : 				}

	jmp	SHORT $LN50@GetCitySta
$LN6@GetCitySta:

; 5525 : 			}
; 5526 : 			else if (iMaxVotes >= iAliveMinorCivs / 4)

	mov	eax, ebx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	ecx, eax
	jl	SHORT $LN50@GetCitySta

; 5527 : 			{
; 5528 : 				iCurrentPlan = PLAN_COLLECT_VOTES;

	mov	DWORD PTR _iCurrentPlan$[esp+108], 2
$LN50@GetCitySta:
	pop	esi
	pop	ebx
$LN48@GetCitySta:

; 5529 : 			}
; 5530 : 		}
; 5531 : 	}
; 5532 : 
; 5533 : 	if (peDiploThreat)

	mov	eax, DWORD PTR _peDiploThreat$[esp+96]
	test	eax, eax
	je	SHORT $LN46@GetCitySta

; 5534 : 	{
; 5535 : 		*peDiploThreat = eCurrentDiploThreat;

	mov	DWORD PTR [eax], edi
$LN46@GetCitySta:

; 5536 : 	}
; 5537 : 	return iCurrentPlan;

	mov	eax, DWORD PTR _iCurrentPlan$[esp+100]
	pop	edi
	pop	ebp

; 5538 : }

	add	esp, 92					; 0000005cH
	ret	4
?GetCityStatePlan@CvEspionageAI@@QAEHPAW4PlayerTypes@@@Z ENDP ; CvEspionageAI::GetCityStatePlan
_TEXT	ENDS
PUBLIC	?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z ; CvEspionageAI::EvaluateSpiesAssignedToTargetPlayer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z$1
__ehfuncinfo$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv239 = -72						; size = 4
_strMsg$226435 = -68					; size = 28
$T239502 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_ePlayer$ = 8						; size = 4
?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z PROC ; CvEspionageAI::EvaluateSpiesAssignedToTargetPlayer, COMDAT
; _this$ = ecx

; 5542 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	mov	ebx, ecx

; 5543 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	edi, eax

; 5544 : 	for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [edi+8], ebp
	jbe	$LN4@EvaluateSp
	mov	DWORD PTR tv239[esp+84], ebp
	push	esi
	npad	10
$LL6@EvaluateSp:

; 5545 : 	{
; 5546 : 		CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[ui]);

	mov	esi, DWORD PTR [edi+4]
	add	esi, DWORD PTR tv239[esp+88]

; 5547 : 		// don't process dead spies
; 5548 : 		if (pSpy->m_eSpyState == SPY_STATE_DEAD)

	cmp	DWORD PTR [esi+16], 8
	je	$LN5@EvaluateSp

; 5549 : 		{
; 5550 : 			continue;
; 5551 : 		}
; 5552 : 
; 5553 : 		CvCity* pCity = pEspionage->GetCityWithSpy(ui);

	push	ebp
	mov	ecx, edi
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 5554 : 		if (pCity && pCity->getOwner() == ePlayer)

	test	eax, eax
	je	$LN5@EvaluateSp
	mov	ecx, DWORD PTR _ePlayer$[esp+84]
	cmp	DWORD PTR [eax+84], ecx
	jne	$LN5@EvaluateSp

; 5555 : 		{
; 5556 : 			pSpy->m_bEvaluateReassignment = true;
; 5557 : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [esi+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@EvaluateSp

; 5558 : 			{
; 5559 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$226435[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5560 : 				strMsg.Format("Re-eval: assigned to promise player, %d,", ui);

	push	ebp
	lea	edx, DWORD PTR _strMsg$226435[esp+92]
	push	OFFSET $SG226436
	push	edx
	mov	DWORD PTR __$EHRec$[esp+108], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 5561 : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR $T239502[esp+92]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$226435[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239502[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5562 : 				pEspionage->LogEspionageMsg(strMsg);

	lea	edx, DWORD PTR _strMsg$226435[esp+88]
	push	edx
	mov	ecx, edi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 5563 : 			}

	lea	ecx, DWORD PTR _strMsg$226435[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@EvaluateSp:
	add	DWORD PTR tv239[esp+88], 28		; 0000001cH
	inc	ebp
	cmp	ebp, DWORD PTR [edi+8]
	jb	$LL6@EvaluateSp
	pop	esi
$LN4@EvaluateSp:

; 5564 : 		}
; 5565 : 	}
; 5566 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$226435[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR $T239502[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvaluateSpiesAssignedToTargetPlayer@CvEspionageAI@@QAEXW4PlayerTypes@@@Z ENDP ; CvEspionageAI::EvaluateSpiesAssignedToTargetPlayer
PUBLIC	?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ	; CvEspionageAI::EvaluateUnassignedSpies
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ$1
__ehfuncinfo$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
tv234 = -72						; size = 4
_strMsg$226452 = -68					; size = 28
$T239545 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ PROC	; CvEspionageAI::EvaluateUnassignedSpies, COMDAT
; _this$ = ecx

; 5570 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	mov	ebx, ecx

; 5571 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	edi, eax

; 5572 : 	for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [edi+8], ebp
	jbe	$LN4@EvaluateUn
	mov	DWORD PTR tv234[esp+84], ebp
	push	esi
	npad	10
$LL6@EvaluateUn:

; 5573 : 	{
; 5574 : 		CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[ui]);

	mov	esi, DWORD PTR [edi+4]
	add	esi, DWORD PTR tv234[esp+88]

; 5575 : 		// don't process dead spies
; 5576 : 		if (pSpy->m_eSpyState == SPY_STATE_DEAD)

	cmp	DWORD PTR [esi+16], 8
	je	$LN5@EvaluateUn

; 5577 : 		{
; 5578 : 			continue;
; 5579 : 		}
; 5580 : 
; 5581 : 		CvCity* pCity = pEspionage->GetCityWithSpy(ui);

	push	ebp
	mov	ecx, edi
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 5582 : 		if (!pCity)

	test	eax, eax
	jne	$LN5@EvaluateUn

; 5583 : 		{
; 5584 : 			pSpy->m_bEvaluateReassignment = true;
; 5585 : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [esi+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@EvaluateUn

; 5586 : 			{
; 5587 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$226452[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5588 : 				strMsg.Format("Re-eval: unassigned spy, %d,", ui);

	push	ebp
	lea	eax, DWORD PTR _strMsg$226452[esp+92]
	push	OFFSET $SG226453
	push	eax
	mov	DWORD PTR __$EHRec$[esp+108], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 5589 : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	ecx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	edx, DWORD PTR $T239545[esp+92]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$226452[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239545[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5590 : 				pEspionage->LogEspionageMsg(strMsg);

	lea	eax, DWORD PTR _strMsg$226452[esp+88]
	push	eax
	mov	ecx, edi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 5591 : 			}

	lea	ecx, DWORD PTR _strMsg$226452[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@EvaluateUn:
	add	DWORD PTR tv234[esp+88], 28		; 0000001cH
	inc	ebp
	cmp	ebp, DWORD PTR [edi+8]
	jb	$LL6@EvaluateUn
	pop	esi
$LN4@EvaluateUn:

; 5592 : 		}
; 5593 : 	}
; 5594 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMsg$226452[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T239545[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ ENDP	; CvEspionageAI::EvaluateUnassignedSpies
PUBLIC	?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ	; CvEspionageAI::EvaluateDefensiveSpies
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ$1
__ehfuncinfo$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
tv275 = -72						; size = 4
_strMsg$226469 = -68					; size = 28
$T239579 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ PROC	; CvEspionageAI::EvaluateDefensiveSpies, COMDAT
; _this$ = ecx

; 5598 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	mov	ebx, ecx

; 5599 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	edi, eax

; 5600 : 	for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [edi+8], ebp
	jbe	$LN4@EvaluateDe
	mov	DWORD PTR tv275[esp+84], ebp
	push	esi
	npad	10
$LL6@EvaluateDe:

; 5601 : 	{
; 5602 : 		CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[ui]);

	mov	esi, DWORD PTR [edi+4]
	add	esi, DWORD PTR tv275[esp+88]

; 5603 : 		// don't process dead spies
; 5604 : 		if (pSpy->m_eSpyState == SPY_STATE_DEAD)

	cmp	DWORD PTR [esi+16], 8
	je	$LN5@EvaluateDe

; 5605 : 		{
; 5606 : 			continue;
; 5607 : 		}
; 5608 : 
; 5609 : 		CvCity* pCity = pEspionage->GetCityWithSpy(ui);

	push	ebp
	mov	ecx, edi
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 5610 : 		if (pCity && pCity->getOwner() == m_pPlayer->GetID())

	test	eax, eax
	je	$LN5@EvaluateDe
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ecx+44]
	jne	$LN5@EvaluateDe

; 5611 : 		{
; 5612 : 			pSpy->m_bEvaluateReassignment = true;
; 5613 : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [esi+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@EvaluateDe

; 5614 : 			{
; 5615 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$226469[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5616 : 				strMsg.Format("Re-eval: defensive spy, %d,", ui);

	push	ebp
	lea	edx, DWORD PTR _strMsg$226469[esp+92]
	push	OFFSET $SG226470
	push	edx
	mov	DWORD PTR __$EHRec$[esp+108], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 5617 : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR $T239579[esp+92]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$226469[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T239579[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5618 : 				pEspionage->LogEspionageMsg(strMsg);

	lea	edx, DWORD PTR _strMsg$226469[esp+88]
	push	edx
	mov	ecx, edi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 5619 : 			}

	lea	ecx, DWORD PTR _strMsg$226469[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@EvaluateDe:
	add	DWORD PTR tv275[esp+88], 28		; 0000001cH
	inc	ebp
	cmp	ebp, DWORD PTR [edi+8]
	jb	$LL6@EvaluateDe
	pop	esi
$LN4@EvaluateDe:

; 5620 : 
; 5621 : 		}
; 5622 : 	}
; 5623 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMsg$226469[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T239579[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ ENDP	; CvEspionageAI::EvaluateDefensiveSpies
PUBLIC	??1?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvEspionageSpy,8,0,297,0>::~FStaticVector<CvEspionageSpy,8,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvEspionageSpy,8,0,297,0>::~FStaticVector<CvEspionageSpy,8,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvEspionageSpy,8,0,297,0>::~FStaticVector<CvEspionageSpy,8,0,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum TechTypes,1,0,297,0>::~FStaticVector<enum TechTypes,1,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum TechTypes,1,0,297,0>::~FStaticVector<enum TechTypes,1,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@4:

; 619  : 	};

	ret	0
??1?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::~FStaticVector<enum TechTypes,1,0,297,0>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,22,0,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,22,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,22,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	?begin@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@XZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@XZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::end
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvEspionageSpy,8,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_pRet$239754 = 8					; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvEspionageSpy,8,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [ebp+8], 0
	jne	SHORT $LN38@GrowSize@2
	mov	DWORD PTR [ebp+8], 1
$LN38@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp]
	cmp	edx, DWORD PTR [ebp+8]
	jb	SHORT $LN7@GrowSize@2
	npad	7
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [ebp+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [ebp+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN33@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [ebp+8], edx
$LN7@GrowSize@2:
	push	ebx
	push	esi

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	esi, DWORD PTR [ebp+8]
	cmp	esi, 8
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239754[esp+8], eax
	mov	DWORD PTR [ebp+8], esi
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR _pRet$239754[esp+8], ecx
	mov	DWORD PTR [ebp+8], 8
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp+4], ebx
	jbe	SHORT $LN1@GrowSize@2
	mov	eax, DWORD PTR _pRet$239754[esp+8]
	xor	edx, edx
	push	edi
$LL39@GrowSize@2:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	eax, eax
	je	SHORT $LN2@GrowSize@2
	mov	esi, DWORD PTR [ebp]
	add	esi, edx
	mov	ecx, 7
	mov	edi, eax
	rep movsd
$LN2@GrowSize@2:
	inc	ebx
	add	edx, 28					; 0000001cH
	add	eax, 28					; 0000001cH
	cmp	ebx, DWORD PTR [ebp+4]
	jb	SHORT $LL39@GrowSize@2
	pop	edi
$LN1@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ebp]
	lea	edx, DWORD PTR [ebp+12]
	pop	esi
	pop	ebx
	cmp	eax, edx
	je	SHORT $LN37@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _pRet$239754[esp+4]
	add	esp, 4
	mov	DWORD PTR [ebp], eax

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [ebp+236], 1
	pop	ebp

; 772  : 	};

	ret	4
$LN37@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _pRet$239754[esp]
	mov	DWORD PTR [ebp], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [ebp+236], 1
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvEspionageSpy,8,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum TechTypes,1,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum TechTypes,1,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	mov	ebx, 1
	jne	SHORT $LN30@GrowSize@3
	mov	DWORD PTR [esi+8], ebx
$LN30@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
	npad	4
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN33@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:
	push	edi

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, ebx
	jbe	SHORT $LN15@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN14@GrowSize@3
$LN15@GrowSize@3:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], ebx
$LN14@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	pop	edi
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN1@GrowSize@3
	mov	ecx, ebp
$LL3@GrowSize@3:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN2@GrowSize@3
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN2@GrowSize@3:
	add	eax, ebx
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize@3
$LN1@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN37@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN37@GrowSize@3:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+16], bl
	mov	DWORD PTR [esi], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?begin@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@XZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE_NI@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE_NI@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UHeistLocation@@@std@@YAPAUHeistLocation@@IPAU1@@Z ; std::_Allocate<HeistLocation>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@XZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE_NI@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE_NI@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 214748364				; 0cccccccH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@USpyNotificationMessage@@@std@@YAPAUSpyNotificationMessage@@IPAU1@@Z ; std::_Allocate<SpyNotificationMessage>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*4]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE_NI@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE_NI@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 63161283				; 03c3c3c3H
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UIntrigueNotificationMessage@@@std@@YAPAUIntrigueNotificationMessage@@IPAU1@@Z ; std::_Allocate<IntrigueNotificationMessage>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	ecx, edi
	shl	ecx, 4
	add	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE_NI@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@5
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Xlen
$LN16@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UScoreCityEntry@@@std@@YAPAUScoreCityEntry@@IPAU1@@Z ; std::_Allocate<ScoreCityEntry>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@5:
?_Buy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Buy
_TEXT	ENDS
PUBLIC	??_G?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEPAXI@Z ; FStaticVector<enum TechTypes,1,0,297,0>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEPAXI@Z PROC ; FStaticVector<enum TechTypes,1,0,297,0>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN6@scalar@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN6@scalar@5:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN20@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEPAXI@Z ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Make_iter
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	edx, eax
	shl	edx, 4
	add	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::operator+
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<HeistLocation,std::allocator<HeistLocation> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z ; stdext::_Unchecked_move_backward<HeistLocation *,HeistLocation *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<HeistLocation *,HeistLocation *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<HeistLocation *,HeistLocation *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z ; stdext::_Unchecked_move_backward<SpyNotificationMessage *,SpyNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z
_TEXT	SEGMENT
$T240241 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240244 = 16					; size = 1
$T240223 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<SpyNotificationMessage *,SpyNotificationMessage *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240244[esp]
	mov	edx, DWORD PTR $T240223[esp]
	mov	BYTE PTR $T240241[esp+4], 0
	mov	eax, DWORD PTR $T240241[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<SpyNotificationMessage *,SpyNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUScoreCityEntry@@PAU1@@stdext@@YAPAUScoreCityEntry@@PAU1@00@Z ; stdext::_Unchecked_move_backward<ScoreCityEntry *,ScoreCityEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUScoreCityEntry@@PAU1@@stdext@@YAPAUScoreCityEntry@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUScoreCityEntry@@PAU1@@stdext@@YAPAUScoreCityEntry@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<ScoreCityEntry *,ScoreCityEntry *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@3
	push	esi
$LL12@Unchecked_@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@3
	pop	esi
$LN11@Unchecked_@3:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUScoreCityEntry@@PAU1@@stdext@@YAPAUScoreCityEntry@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<ScoreCityEntry *,ScoreCityEntry *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 20					; 00000014H
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN12@Copy_opt@8
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@8:

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], edx
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], ecx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], edx
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+28], ecx
	mov	edx, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [esi+36]
	push	eax
	lea	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [edi+32], edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	cl, BYTE PTR [esi+64]
	mov	BYTE PTR [edi+64], cl
	add	esi, 68					; 00000044H
	add	edi, 68					; 00000044H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@8

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN12@Copy_opt@8:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@3:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@3
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil@3:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@3
	pop	esi
$LN4@Uninit_fil@3:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<HeistLocation> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<SpyNotificationMessage> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z ; std::_Fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z PROC ; std::_Fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	ebp, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebp
	je	SHORT $LN1@Fill@6
	push	ebx
	push	edi
	mov	edi, DWORD PTR __Val$[esp+12]
	lea	ebx, DWORD PTR [edi+36]
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	push	ebx
	lea	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+32], edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	al, BYTE PTR [edi+64]
	mov	BYTE PTR [esi+64], al
	add	esi, 68					; 00000044H
	cmp	esi, ebp
	jne	SHORT $LL3@Fill@6
	pop	edi
	pop	ebx
$LN1@Fill@6:
	pop	esi
	pop	ebp

; 3160 : 	}

	ret	0
??$_Fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z ENDP ; std::_Fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240501 = -4						; size = 1
__Cat$240505 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T240501[esp+4], 0
	mov	eax, DWORD PTR $T240501[esp+4]
	mov	ecx, DWORD PTR __Cat$240505[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ScoreCityEntry> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z ; std::allocator<IntrigueNotificationMessage>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z$0
__ehfuncinfo$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z
_TEXT	SEGMENT
$T240528 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$240525 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z PROC ; std::allocator<IntrigueNotificationMessage>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$240525[esp+12], ecx
	mov	DWORD PTR $T240528[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@4
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0IntrigueNotificationMessage@@QAE@ABU0@@Z
$LN5@construct@4:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z$0:
	mov	eax, DWORD PTR __Vptr$240525[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T240528[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@ABU3@@Z ENDP ; std::allocator<IntrigueNotificationMessage>::construct
PUBLIC	??$_Distance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAH@Z ; std::_Distance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAH@Z PROC ; std::_Distance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0AAH@Z ENDP ; std::_Distance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@6:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@6
	pop	esi
$LN7@unchecked_@6:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy@UIntrigueNotificationMessage@@@std@@YAXPAUIntrigueNotificationMessage@@@Z ; std::_Destroy<IntrigueNotificationMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UIntrigueNotificationMessage@@@std@@YAXPAUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UIntrigueNotificationMessage@@@std@@YAXPAUIntrigueNotificationMessage@@@Z PROC ; std::_Destroy<IntrigueNotificationMessage>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@UIntrigueNotificationMessage@@@std@@YAXPAUIntrigueNotificationMessage@@@Z ENDP ; std::_Destroy<IntrigueNotificationMessage>
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$230240 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ PROC ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$230240[esp+16]
	push	eax
	call	??$get_temporary_buffer@UScoreCityEntry@@@std@@YA?AU?$pair@PAUScoreCityEntry@@H@0@H@Z ; std::get_temporary_buffer<ScoreCityEntry>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230240[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$230240[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
_TEXT	ENDS
PUBLIC	??$advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@H@Z ; std::advance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@H@Z PROC ; std::advance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@H@Z ENDP ; std::advance<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z ; stdext::unchecked_uninitialized_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z
_TEXT	SEGMENT
$T240686 = -4						; size = 1
__Cat$240691 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240686[esp+4], 0
	mov	eax, DWORD PTR $T240686[esp+4]
	mov	ecx, DWORD PTR __Cat$240691[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z ; stdext::unchecked_uninitialized_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z
_TEXT	SEGMENT
$T240695 = -4						; size = 1
__Cat$240700 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240695[esp+4], 0
	mov	eax, DWORD PTR $T240695[esp+4]
	mov	ecx, DWORD PTR __Cat$240700[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z
_TEXT	SEGMENT
$T240704 = -4						; size = 1
__Cat$240709 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240704[esp+4], 0
	mov	eax, DWORD PTR $T240704[esp+4]
	mov	ecx, DWORD PTR __Cat$240709[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
$T240713 = -4						; size = 1
$T240720 = -4						; size = 4
$T240716 = -4						; size = 4
__Cat$240725 = 8					; size = 1
$T240715 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T240720[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240725[esp+4]
	mov	edx, DWORD PTR $T240715[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T240713[esp+12], bl
	mov	eax, DWORD PTR $T240713[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T240716[esp+44], esp
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@7:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T240764 = -4						; size = 1
__Cat$240770 = 8					; size = 1
$T240766 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240770[esp]
	mov	edx, DWORD PTR $T240766[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T240764[esp+8], 0
	mov	eax, DWORD PTR $T240764[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Lower_boun:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);
; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	cmp	DWORD PTR [esi+eax*8+4], edi
	jle	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN38@Lower_boun:

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2306 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Upper_boun:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);
; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	cmp	edi, DWORD PTR [esi+eax*8+4]
	jg	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN38@Upper_boun:

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2377 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T240964 = -4						; size = 1
__Cat$240969 = 8					; size = 1
$T240966 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240969[esp]
	mov	edx, DWORD PTR $T240966[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T240964[esp+8], 0
	mov	eax, DWORD PTR $T240964[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z ; stdext::unchecked_copy_backward<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z
_TEXT	SEGMENT
$T240978 = -4						; size = 1
__Cat$240984 = 8					; size = 1
$T240980 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z PROC ; stdext::unchecked_copy_backward<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240984[esp]
	mov	edx, DWORD PTR $T240980[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T240978[esp+8], 0
	mov	eax, DWORD PTR $T240978[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z ENDP ; stdext::unchecked_copy_backward<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z ; stdext::unchecked_copy<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z
_TEXT	SEGMENT
$T240992 = -4						; size = 1
__Cat$240998 = 8					; size = 1
$T240994 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z PROC ; stdext::unchecked_copy<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240998[esp]
	mov	edx, DWORD PTR $T240994[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T240992[esp+8], 0
	mov	eax, DWORD PTR $T240992[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@@Z ENDP ; stdext::unchecked_copy<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T241151 = 12						; size = 1
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$241155 = 28					; size = 1
$T241153 = 28						; size = 1
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	cmp	eax, esi
	je	SHORT $LN44@Merge
$LL10@Merge:
	mov	edx, DWORD PTR __First2$[esp+4]
	cmp	edx, DWORD PTR __Last2$[esp+4]
	je	SHORT $LN68@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [edx+4]
	cmp	ebx, DWORD PTR [eax+4]
	jge	SHORT $LN2@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	DWORD PTR __First2$[esp+4], 8

; 2600 : 		else

	jmp	SHORT $LN4@Merge
$LN2@Merge:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
$LN4@Merge:
	mov	ecx, DWORD PTR __Dest$[esp+4]
	add	ecx, 8
	mov	DWORD PTR __Dest$[esp+4], ecx
	cmp	eax, esi
	jne	SHORT $LL10@Merge
$LN68@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN44@Merge
	npad	3
$LL46@Merge:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	add	eax, 8
	add	ecx, 8
	cmp	eax, esi
	jne	SHORT $LL46@Merge
$LN44@Merge:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR __Dest$[esp+4], ecx
	mov	edx, DWORD PTR __Cat$241155[esp+4]
	mov	BYTE PTR $T241151[esp+4], 0
	mov	eax, DWORD PTR $T241151[esp+4]
	push	eax
	mov	eax, DWORD PTR $T241153[esp+8]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+20]
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241215 = -4						; size = 1
$T241191 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$241219 = 16					; size = 1
$T241217 = 16						; size = 1
__Cat$241195 = 16					; size = 1
$T241193 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ecx

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __First1$[esp]
	mov	ecx, DWORD PTR __Last1$[esp]
	mov	eax, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+4]
	push	edi
	cmp	edx, ecx
	je	SHORT $LN61@Merge_back
$LL8@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	cmp	esi, eax
	je	$LN62@Merge_back

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	edx, DWORD PTR [eax-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN2@Merge_back

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[esp+8]
	sub	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx

; 2847 : 		else

	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	eax, 8
	jmp	SHORT $LN57@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
$LN57@Merge_back:
	mov	edx, DWORD PTR __First1$[esp+8]
	cmp	edx, ecx
	jne	SHORT $LL8@Merge_back
$LN61@Merge_back:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$241195[esp+8]
	mov	BYTE PTR $T241191[esp+12], 0
	mov	ecx, DWORD PTR $T241191[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T241193[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	push	esi
	call	??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
$LN62@Merge_back:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T241215[esp+12], 0
	mov	eax, DWORD PTR $T241215[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$241219[esp+12]
	push	eax
	mov	eax, DWORD PTR $T241217[esp+16]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Lower_boun@2
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Lower_boun@2:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);
; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	cmp	DWORD PTR [esi+eax*8+4], edi
	jge	SHORT $LN2@Lower_boun@2

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun@2
$LN2@Lower_boun@2:

; 2303 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun@2:

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun@2
	pop	edi
$LN38@Lower_boun@2:

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2306 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Upper_boun@2
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Upper_boun@2:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);
; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	cmp	edi, DWORD PTR [esi+eax*8+4]
	jl	SHORT $LN2@Upper_boun@2

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun@2
$LN2@Upper_boun@2:

; 2374 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun@2:

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun@2
	pop	edi
$LN38@Upper_boun@2:

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2377 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryHighEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryHighEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241499 = -24						; size = 4
$T241493 = -24						; size = 4
$T241491 = -24						; size = 4
$T241492 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryHighEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	sub	esp, 24					; 00000018H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp+20]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T241499[esp+32], edi
	cmp	eax, DWORD PTR __Last1$[esp+28]
	je	$LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[esp+28]
	lea	esi, DWORD PTR [edi+8]
$LL4@Merge@2:
	cmp	ecx, DWORD PTR __Last2$[esp+28]
	je	$LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+44]
	jle	SHORT $LN2@Merge@2
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN41@Merge@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

$LN41@Merge@2:
	cmp	eax, edi
	je	SHORT $LN46@Merge@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN46@Merge@2:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge@2
$LN2@Merge@2:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN61@Merge@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN60@Merge@2
$LN61@Merge@2:
	cmp	eax, edi
	je	SHORT $LN66@Merge@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN66@Merge@2:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN60@Merge@2:
	mov	eax, DWORD PTR __First1$[esp+28]
	mov	ecx, DWORD PTR __First2$[esp+28]
	add	eax, esi
	mov	DWORD PTR __First1$[esp+28], eax
$LN72@Merge@2:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+28]
	jne	$LL4@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+48]
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR $T241491[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T241492[esp+60]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T241492[esp+64]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+44], edx
	cmp	eax, edi
	je	SHORT $LN88@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN88@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+48]
	mov	eax, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR $T241493[esp+52], esp
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN109@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN109@Merge@2:

; 2605 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryHighEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	ecx, esi
	je	SHORT $LN28@Merge@3
	npad	5
$LL10@Merge@3:
	cmp	eax, edi
	je	SHORT $LN3@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [eax+4]
	add	eax, 8

; 2600 : 		else

	jmp	SHORT $LN68@Merge@3
$LN2@Merge@3:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [ecx+4]
	add	ecx, 8
$LN68@Merge@3:
	mov	ebx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ebx+4], edx
	mov	edx, DWORD PTR __Dest$[esp+8]
	add	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	cmp	ecx, esi
	jne	SHORT $LL10@Merge@3
$LN3@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	ecx, esi
	je	SHORT $LN28@Merge@3
	npad	4
$LL30@Merge@3:
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	add	ecx, 8
	add	edx, 8
	cmp	ecx, esi
	jne	SHORT $LL30@Merge@3
$LN28@Merge@3:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	cmp	eax, edi
	je	SHORT $LN66@Merge@3
$LL49@Merge@3:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
	add	edx, 8
	cmp	eax, edi
	jne	SHORT $LL49@Merge@3
$LN66@Merge@3:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00PAHPAUScoreCityEntry@@@Z ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00PAHPAUScoreCityEntry@@@Z
_TEXT	SEGMENT
$T241893 = -24						; size = 4
__Shift$ = -20						; size = 4
$T241897 = -16						; size = 4
$T241898 = -12						; size = 4
__Holeval$231939 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00PAHPAUScoreCityEntry@@@Z PROC ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 24					; 00000018H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;
; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Mid$[esp+24]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+32]
	sub	ebx, edi
	sar	ebx, 3
	sub	ecx, edi
	sar	ecx, 3
	mov	DWORD PTR __Shift$[esp+36], ebx
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate
	add	ebx, ebx
	add	ebx, ebx
	push	ebp
	add	ebx, ebx
	jmp	SHORT $LN5@Rotate
	npad	4
$LL93@Rotate:
	mov	edi, DWORD PTR __First$[esp+36]
$LN5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [edi+eax*8+4]
	mov	ebp, DWORD PTR [edi+eax*8]
	lea	esi, DWORD PTR [edi+eax*8]
	mov	DWORD PTR __Holeval$231939[esp+44], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [ebx+esi]
	mov	edi, esi
	cmp	ecx, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN11@Rotate
	lea	ecx, DWORD PTR __First$[esp+36]
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	DWORD PTR $T241893[esp+40], ecx
	lea	ecx, DWORD PTR $T241893[esp+40]
$LN12@Rotate:
	mov	ecx, DWORD PTR [ecx]

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, esi
	je	SHORT $LN1@Rotate
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edi], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+4], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+36]
	sub	edx, ecx
	sar	edx, 3
	cmp	DWORD PTR __Shift$[esp+40], edx
	mov	edi, ecx
	jge	SHORT $LN13@Rotate
	add	ecx, ebx
	mov	DWORD PTR $T241897[esp+40], ecx
	lea	ecx, DWORD PTR $T241897[esp+40]
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	ecx, ebx
	sub	ecx, edx
	add	ecx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR $T241898[esp+40], ecx
	lea	ecx, DWORD PTR $T241898[esp+40]
$LN14@Rotate:
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, esi
	jne	SHORT $LL2@Rotate
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	edx, DWORD PTR __Holeval$231939[esp+44]
	dec	eax
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+4], edx
	test	eax, eax
	jg	$LL93@Rotate
	pop	ebp
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00PAHPAUScoreCityEntry@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryLowEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryLowEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T242083 = -24						; size = 4
$T242077 = -24						; size = 4
$T242075 = -24						; size = 4
$T242076 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryLowEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	sub	esp, 24					; 00000018H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp+20]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T242083[esp+32], edi
	cmp	eax, DWORD PTR __Last1$[esp+28]
	je	$LN3@Merge@4
	mov	ecx, DWORD PTR __First2$[esp+28]
	lea	esi, DWORD PTR [edi+8]
$LL4@Merge@4:
	cmp	ecx, DWORD PTR __Last2$[esp+28]
	je	$LN3@Merge@4

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+44]
	jge	SHORT $LN2@Merge@4
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN41@Merge@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge@4

; 2599 : 			*_Dest = *_First2, ++_First2;

$LN41@Merge@4:
	cmp	eax, edi
	je	SHORT $LN46@Merge@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN46@Merge@4:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge@4
$LN2@Merge@4:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN61@Merge@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN60@Merge@4
$LN61@Merge@4:
	cmp	eax, edi
	je	SHORT $LN66@Merge@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN66@Merge@4:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN60@Merge@4:
	mov	eax, DWORD PTR __First1$[esp+28]
	mov	ecx, DWORD PTR __First2$[esp+28]
	add	eax, esi
	mov	DWORD PTR __First1$[esp+28], eax
$LN72@Merge@4:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+28]
	jne	$LL4@Merge@4
$LN3@Merge@4:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+48]
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR $T242075[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T242076[esp+60]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T242076[esp+64]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+44], edx
	cmp	eax, edi
	je	SHORT $LN88@Merge@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN88@Merge@4:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+48]
	mov	eax, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR $T242077[esp+52], esp
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN109@Merge@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN109@Merge@4:

; 2605 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryLowEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	ecx, esi
	je	SHORT $LN28@Merge@5
	npad	5
$LL10@Merge@5:
	cmp	eax, edi
	je	SHORT $LN3@Merge@5

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [ecx+4]
	jge	SHORT $LN2@Merge@5

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [eax+4]
	add	eax, 8

; 2600 : 		else

	jmp	SHORT $LN68@Merge@5
$LN2@Merge@5:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [ecx+4]
	add	ecx, 8
$LN68@Merge@5:
	mov	ebx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ebx+4], edx
	mov	edx, DWORD PTR __Dest$[esp+8]
	add	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	cmp	ecx, esi
	jne	SHORT $LL10@Merge@5
$LN3@Merge@5:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	ecx, esi
	je	SHORT $LN28@Merge@5
	npad	4
$LL30@Merge@5:
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	add	ecx, 8
	add	edx, 8
	cmp	ecx, esi
	jne	SHORT $LL30@Merge@5
$LN28@Merge@5:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	cmp	eax, edi
	je	SHORT $LN66@Merge@5
$LL49@Merge@5:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
	add	edx, 8
	cmp	eax, edi
	jne	SHORT $LL49@Merge@5
$LN66@Merge@5:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@6
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@6:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@4:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@8
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@8:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@8
	pop	esi
$LN7@unchecked_@8:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?ExtractSpyFromCity@CvPlayerEspionage@@QAE_NI@Z	; CvPlayerEspionage::ExtractSpyFromCity
EXTRN	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z:PROC ; CvPlot::changeAdjacentSight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
;	COMDAT ?ExtractSpyFromCity@CvPlayerEspionage@@QAE_NI@Z
_TEXT	SEGMENT
_bHadSurveillance$ = 8					; size = 1
_uiSpyIndex$ = 8					; size = 4
?ExtractSpyFromCity@CvPlayerEspionage@@QAE_NI@Z PROC	; CvPlayerEspionage::ExtractSpyFromCity, COMDAT
; _this$ = ecx

; 1217 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 1218 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR _uiSpyIndex$[esp-4]
	push	edi
	mov	edi, ecx
	cmp	eax, DWORD PTR [edi+8]
	jb	SHORT $LN5@ExtractSpy

; 1219 : 	{
; 1220 : 		return false;

	xor	al, al
	pop	edi

; 1261 : }

	ret	4
$LN5@ExtractSpy:

; 1221 : 	}
; 1222 : 
; 1223 : 	if(!IsSpyInCity(uiSpyIndex))

	mov	ecx, DWORD PTR [edi+4]
	push	ebx
	push	esi
	lea	esi, DWORD PTR [eax*8]
	sub	esi, eax
	add	esi, esi
	add	esi, esi
	add	ecx, esi
	or	ebx, -1
	cmp	DWORD PTR [ecx+4], ebx
	je	SHORT $LN11@ExtractSpy
	cmp	DWORD PTR [ecx+8], ebx
	jne	SHORT $LN4@ExtractSpy
$LN11@ExtractSpy:
	pop	esi
	pop	ebx

; 1224 : 	{
; 1225 : 		return true;

	mov	al, 1
	pop	edi

; 1261 : }

	ret	4
$LN4@ExtractSpy:
	push	ebp

; 1226 : 	}
; 1227 : 
; 1228 : 	bool bHadSurveillance = HasEstablishedSurveillance(uiSpyIndex);

	push	eax
	mov	ecx, edi
	call	?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::HasEstablishedSurveillance

; 1229 : 
; 1230 : 	int iCityX = m_aSpyList[uiSpyIndex].m_iCityX;

	mov	edx, DWORD PTR [edi+4]

; 1231 : 	int iCityY = m_aSpyList[uiSpyIndex].m_iCityY;

	mov	ebp, DWORD PTR [esi+edx+8]
	lea	ecx, DWORD PTR [esi+edx]
	mov	BYTE PTR _bHadSurveillance$[esp+12], al
	mov	eax, DWORD PTR [ecx+4]

; 1232 : 
; 1233 : 	m_aSpyList[uiSpyIndex].m_iCityX = -1;

	mov	DWORD PTR [ecx+4], ebx

; 1234 : 	m_aSpyList[uiSpyIndex].m_iCityY = -1;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+ecx+8], ebx

; 1235 : 	m_aSpyList[uiSpyIndex].m_eSpyState = SPY_STATE_UNASSIGNED;

	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+edx+16], 0

; 1236 : 
; 1237 : 	CvPlot* pPlot = GC.getMap().plot(iCityX, iCityY);

	cmp	eax, -2147483647			; 80000001H
	je	$LN99@ExtractSpy
	cmp	ebp, -2147483647			; 80000001H
	je	$LN99@ExtractSpy
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN43@ExtractSpy
	test	eax, eax
	jge	SHORT $LN45@ExtractSpy
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN47@ExtractSpy
$LN45@ExtractSpy:
	cmp	eax, ecx
	jl	SHORT $LN43@ExtractSpy
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN47@ExtractSpy
$LN43@ExtractSpy:
	mov	esi, eax
$LN47@ExtractSpy:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebx, DWORD PTR [edx+4024]
	je	SHORT $LN53@ExtractSpy
	test	ebp, ebp
	jge	SHORT $LN55@ExtractSpy
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN57@ExtractSpy
$LN55@ExtractSpy:
	cmp	ebp, ebx
	jl	SHORT $LN53@ExtractSpy
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN57@ExtractSpy
$LN53@ExtractSpy:
	mov	edx, ebp
$LN57@ExtractSpy:
	test	esi, esi
	jl	SHORT $LN99@ExtractSpy
	cmp	esi, ecx
	jge	SHORT $LN99@ExtractSpy
	test	edx, edx
	jl	SHORT $LN99@ExtractSpy
	cmp	edx, ebx
	jge	SHORT $LN99@ExtractSpy
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]

; 1238 : 	CvAssertMsg(pPlot, "Spy coordinates did not point to plot");
; 1239 : 	if(!pPlot)

	test	ecx, ecx

; 1240 : 	{
; 1241 : 		return false;

	je	SHORT $LN99@ExtractSpy

; 1242 : 	}
; 1243 : 
; 1244 : 	CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN99@ExtractSpy
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN99@ExtractSpy
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 1245 : 	CvAssertMsg(pCity, "No city in plot pointed to by spy");
; 1246 : 	if(!pCity)

	test	esi, esi
	jne	SHORT $LN2@ExtractSpy
$LN99@ExtractSpy:
	pop	ebp
	pop	esi
	pop	ebx

; 1247 : 	{
; 1248 : 		return false;

	xor	al, al
	pop	edi

; 1261 : }

	ret	4
$LN2@ExtractSpy:

; 1249 : 	}
; 1250 : 
; 1251 : 	// turn off visibility of city
; 1252 : 	if(bHadSurveillance)
; 1253 : 	{
; 1254 : 		pCity->plot()->changeAdjacentSight(m_pPlayer->getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), false, NO_INVISIBLE, NO_DIRECTION, false);

	or	ebx, -1
	cmp	BYTE PTR _bHadSurveillance$[esp+12], 0
	je	SHORT $LN1@ExtractSpy
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	mov	ecx, DWORD PTR [edi+1296]
	push	0
	push	ebx
	push	ebx
	push	0
	push	edx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN1@ExtractSpy:

; 1255 : 	}
; 1256 : 
; 1257 : 	pCity->GetCityEspionage()->m_aiSpyAssignment[m_pPlayer->GetID()] = -1;

	mov	eax, DWORD PTR [edi+1296]
	mov	ebp, DWORD PTR [eax+44]
	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	DWORD PTR [eax+ebp*4+4], ebx

; 1258 : 	pCity->GetCityEspionage()->ResetProgress(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [edi+1296]
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	pop	ebp
	mov	DWORD PTR [eax+edi*4+92], ebx
	mov	DWORD PTR [eax+edi*4+268], ebx
	mov	DWORD PTR [eax+edi*4+180], ebx
	pop	esi
	pop	ebx

; 1259 : 
; 1260 : 	return true;

	mov	al, 1
	pop	edi

; 1261 : }

	ret	4
?ExtractSpyFromCity@CvPlayerEspionage@@QAE_NI@Z ENDP	; CvPlayerEspionage::ExtractSpyFromCity
_TEXT	ENDS
PUBLIC	?UpdateCity@CvPlayerEspionage@@QAEXPAVCvCity@@@Z ; CvPlayerEspionage::UpdateCity
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateCity@CvPlayerEspionage@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
$T242910 = -4						; size = 4
_pCity$ = 8						; size = 4
?UpdateCity@CvPlayerEspionage@@QAEXPAVCvCity@@@Z PROC	; CvPlayerEspionage::UpdateCity, COMDAT
; _this$ = ecx

; 1302 : {

	push	ecx
	push	ebx

; 1303 : 	CvAssertMsg(pCity, "pCity is null");
; 1304 : 	if(pCity == NULL)

	mov	ebx, DWORD PTR _pCity$[esp+4]
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	je	$LN4@UpdateCity

; 1305 : 	{
; 1306 : 		return;
; 1307 : 	}
; 1308 : 
; 1309 : 	int iSpyIndex = GetSpyIndexInCity(pCity);

	mov	eax, DWORD PTR [esi+1296]
	push	ebp
	push	edi
	mov	edi, DWORD PTR [eax+44]
	mov	ecx, ebx
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	ebp, DWORD PTR [eax+edi*4+4]
	add	eax, 4

; 1310 : 
; 1311 : 	// if there isn't a spy in the city, bail out
; 1312 : 	if(iSpyIndex == -1)

	cmp	ebp, -1
	je	$LN43@UpdateCity

; 1313 : 	{
; 1314 : 		return;
; 1315 : 	}
; 1316 : 
; 1317 : 	CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, ebx
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	ebx, eax

; 1318 : 	CvAssertMsg(pCityEspionage, "pCityEspionage is null");
; 1319 : 	if(pCityEspionage == NULL)

	test	ebx, ebx
	je	SHORT $LN43@UpdateCity

; 1320 : 	{
; 1321 : 		return;
; 1322 : 	}
; 1323 : 	pCityEspionage->m_aiLastBasePotential[m_pPlayer->GetID()] = CalcPerTurn(m_aSpyList[iSpyIndex].m_eSpyState, pCity, -1);

	mov	ecx, DWORD PTR [esi+1296]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _pCity$[esp+16]
	lea	edi, DWORD PTR [ebp*8]
	sub	edi, ebp
	add	edi, edi
	add	edi, edi
	push	-1
	add	eax, edi
	mov	DWORD PTR $T242910[esp+24], edx
	mov	edx, DWORD PTR [eax+16]
	push	ecx
	push	edx
	mov	ecx, esi
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn
	mov	ecx, DWORD PTR $T242910[esp+20]
	mov	DWORD PTR [ebx+ecx*4+532], eax

; 1324 : 	pCityEspionage->m_aiLastPotential[m_pPlayer->GetID()] = CalcPerTurn(m_aSpyList[iSpyIndex].m_eSpyState, pCity, iSpyIndex);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+1296]
	mov	ecx, DWORD PTR _pCity$[esp+16]
	add	eax, edi
	mov	edi, DWORD PTR [edx+44]
	mov	edx, DWORD PTR [eax+16]
	push	ebp
	push	ecx
	push	edx
	mov	ecx, esi
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn
	mov	DWORD PTR [ebx+edi*4+444], eax

; 1325 : 	pCityEspionage->m_aiRate[m_pPlayer->GetID()] = pCityEspionage->m_aiLastPotential[m_pPlayer->GetID()];

	mov	eax, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR [ebx+eax*4+444]
	mov	DWORD PTR [ebx+eax*4+180], ecx
$LN43@UpdateCity:
	pop	edi
	pop	ebp
$LN4@UpdateCity:
	pop	esi
	pop	ebx

; 1326 : }

	pop	ecx
	ret	4
?UpdateCity@CvPlayerEspionage@@QAEXPAVCvCity@@@Z ENDP	; CvPlayerEspionage::UpdateCity
_TEXT	ENDS
PUBLIC	?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z	; CvPlayerEspionage::AttemptCoup
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z:PROC ; CvMinorCivAI::SetFriendshipWithMajorTimes100
EXTRN	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsFriends
EXTRN	?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::GetFriendshipAnchorWithMajor
EXTRN	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
EXTRN	?SetDisableNotifications@CvMinorCivAI@@QAEX_N@Z:PROC ; CvMinorCivAI::SetDisableNotifications
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__ehfuncinfo$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$10
	DD	09H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$11
	DD	09H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$12
	DD	09H
	DD	FLAT:__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$13
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z
_TEXT	SEGMENT
_bAttemptSuccess$ = -594				; size = 1
_bNotify$223578 = -593					; size = 1
_ui$223569 = -592					; size = 4
_iNewInfluence$223566 = -592				; size = 4
tv1355 = -588						; size = 4
$T242960 = -588						; size = 4
_eNotification$223614 = -584				; size = 4
_eNotification$223589 = -584				; size = 4
_iRelationshipAnchor$223580 = -584			; size = 4
_iRandRoll$ = -584					; size = 4
_pMinorCivAI$ = -580					; size = 4
_bMetMinor$223577 = -573				; size = 1
$T243188 = -572						; size = 4
_pNotifications$ = -572					; size = 4
_pNotifications$223587 = -572				; size = 4
_iFriendship$223579 = -572				; size = 4
_ePreviousAlly$ = -568					; size = 4
tv946 = -564						; size = 4
tv933 = -560						; size = 4
_strSummary$223615 = -556				; size = 80
$T242971 = -556						; size = 80
$T242968 = -556						; size = 80
$T242964 = -556						; size = 80
$T242961 = -556						; size = 80
$T242982 = -476						; size = 80
$T242977 = -476						; size = 80
$T242975 = -476						; size = 80
_strSummary$223590 = -476				; size = 80
_strMsg$223552 = -396					; size = 28
_strNotification$223616 = -368				; size = 80
_strNotification$223591 = -288				; size = 80
_aiNewInfluenceValueTimes100$ = -208			; size = 88
$T242959 = -120						; size = 28
$T242984 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_uiSpyIndex$ = 8					; size = 4
?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z PROC		; CvPlayerEspionage::AttemptCoup, COMDAT
; _this$ = ecx

; 1882 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 584				; 00000248H
	push	ebp

; 1883 : 	// if you're not allowed to stage a coup here, the coup fails
; 1884 : 	if(!CanStageCoup(uiSpyIndex))

	mov	ebp, DWORD PTR _uiSpyIndex$[esp+596]
	push	edi
	push	ebp
	mov	edi, ecx
	call	?CanStageCoup@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::CanStageCoup
	test	al, al
	je	$LN31@AttemptCou
$LN30@AttemptCou:
	push	ebx

; 1885 : 	{
; 1886 : 		return false;
; 1887 : 	}
; 1888 : 
; 1889 : 	CvCity* pCity = GetCityWithSpy(uiSpyIndex);

	push	ebp
	mov	ecx, edi
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy
	mov	ebx, eax

; 1890 : 	CvAssertMsg(pCity, "Spy isn't in a city.");
; 1891 : 	if(!pCity)

	test	ebx, ebx
	jne	SHORT $LN29@AttemptCou

; 1892 : 	{
; 1893 : 		return false;

	xor	al, al
	jmp	$LN261@AttemptCou
$LN29@AttemptCou:

; 1894 : 	}
; 1895 : 
; 1896 : 	PlayerTypes eCityOwner = pCity->getOwner();
; 1897 : 	if(!GET_PLAYER(eCityOwner).isMinorCiv())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, DWORD PTR [ebx+84]
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR tv933[esp+612], esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 1898 : 	{
; 1899 : 		// this city state is not a minor civ
; 1900 : 		return false;

	je	SHORT $LN265@AttemptCou

; 1901 : 	}
; 1902 : 
; 1903 : 	CvMinorCivAI* pMinorCivAI = GET_PLAYER(eCityOwner).GetMinorCivAI();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI

; 1904 : 
; 1905 : 	PlayerTypes ePreviousAlly = pMinorCivAI->GetAlly();

	mov	ecx, eax
	mov	DWORD PTR _pMinorCivAI$[esp+612], eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR _ePreviousAlly$[esp+612], eax

; 1906 : 	CvAssertMsg(ePreviousAlly != NO_PLAYER, "City state has no ally. Something's going wrong");
; 1907 : 	if(ePreviousAlly == NO_PLAYER)

	cmp	eax, -1
	jne	SHORT $LN27@AttemptCou
$LN265@AttemptCou:

; 1908 : 	{
; 1909 : 		return false;

	xor	al, al
	jmp	$LN262@AttemptCou
$LN27@AttemptCou:

; 1910 : 	}
; 1911 : 
; 1912 : 	int aiNewInfluenceValueTimes100[MAX_MAJOR_CIVS];
; 1913 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	esi, esi
$LL26@AttemptCou:

; 1914 : 	{
; 1915 : #ifdef NQ_COUP_FORMULA_USES_BASE_FRIENDSHIP_NOT_EFFECTIVE_FRIENDSHIP
; 1916 : 		aiNewInfluenceValueTimes100[ui] = pMinorCivAI->GetBaseFriendshipWithMajorTimes100((PlayerTypes)ui);
; 1917 : #else
; 1918 : 		aiNewInfluenceValueTimes100[ui] = pMinorCivAI->GetEffectiveFriendshipWithMajorTimes100((PlayerTypes)ui);

	mov	ecx, DWORD PTR _pMinorCivAI$[esp+612]
	push	esi
	call	?GetEffectiveFriendshipWithMajorTimes100@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajorTimes100
	mov	DWORD PTR _aiNewInfluenceValueTimes100$[esp+esi*4+612], eax
	inc	esi
	cmp	esi, 22					; 00000016H
	jb	SHORT $LL26@AttemptCou

; 1919 : #endif
; 1920 : 	}
; 1921 : 
; 1922 : 	m_aSpyList[uiSpyIndex].m_bEvaluateReassignment = true; // flag for reassignment

	mov	edx, DWORD PTR [edi+4]
	lea	esi, DWORD PTR [ebp*8]
	sub	esi, ebp
	add	esi, esi
	add	esi, esi

; 1923 : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR tv946[esp+612], esi
	mov	BYTE PTR [esi+edx+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@AttemptCou

; 1924 : 	{
; 1925 : 		CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223552[esp+612]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1926 : 		strMsg.Format("Re-eval: attempting coup, %d,", uiSpyIndex);

	push	ebp
	lea	eax, DWORD PTR _strMsg$223552[esp+616]
	push	OFFSET $SG223553
	push	eax
	mov	DWORD PTR __$EHRec$[esp+632], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1927 : 		strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName));

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+esi]
	add	eax, esi
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	edx, DWORD PTR $T242959[esp+616]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$223552[esp+616]
	mov	BYTE PTR __$EHRec$[esp+624], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242959[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1928 : 		LogEspionageMsg(strMsg);

	lea	eax, DWORD PTR _strMsg$223552[esp+612]
	push	eax
	mov	ecx, edi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 1929 : 	}

	lea	ecx, DWORD PTR _strMsg$223552[esp+612]
	mov	DWORD PTR __$EHRec$[esp+620], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN23@AttemptCou:

; 1930 : 
; 1931 : 	bool bAttemptSuccess = false;
; 1932 : 	int iRandRoll = GC.getGame().getJonRandNum(100, "Roll for the result of an attempted coup");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG223557
	push	100					; 00000064H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 1933 : 	if(iRandRoll <= GetCoupChanceOfSuccess(uiSpyIndex))

	push	ebp
	mov	ecx, edi
	mov	DWORD PTR _iRandRoll$[esp+616], eax
	call	?GetCoupChanceOfSuccess@CvPlayerEspionage@@QAEHI@Z ; CvPlayerEspionage::GetCoupChanceOfSuccess
	cmp	DWORD PTR _iRandRoll$[esp+612], eax

; 1934 : 	{
; 1935 : 		// swap influence from ally to 2nd place ally
; 1936 : 		int iInfluenceTemp = aiNewInfluenceValueTimes100[ePreviousAlly];
; 1937 : 		aiNewInfluenceValueTimes100[ePreviousAlly] = aiNewInfluenceValueTimes100[m_pPlayer->GetID()];

	mov	ecx, DWORD PTR [edi+1296]
	jg	$LN22@AttemptCou
	mov	ecx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _ePreviousAlly$[esp+612]
	mov	esi, DWORD PTR _aiNewInfluenceValueTimes100$[esp+ecx*4+612]
	mov	edx, DWORD PTR _aiNewInfluenceValueTimes100$[esp+eax*4+612]
	lea	eax, DWORD PTR _aiNewInfluenceValueTimes100$[esp+eax*4+612]
	mov	DWORD PTR [eax], esi

; 1938 : 		aiNewInfluenceValueTimes100[m_pPlayer->GetID()] = iInfluenceTemp;

	mov	DWORD PTR _aiNewInfluenceValueTimes100$[esp+ecx*4+612], edx

; 1939 : 
; 1940 : 		// reduce the influence of all the other players
; 1941 : #ifdef AUI_WARNING_FIXES
; 1942 : 		for (int ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 1943 : #else
; 1944 : 		for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 1945 : #endif
; 1946 : 		{
; 1947 : 			if(ui == m_pPlayer->GetID())

	mov	edx, DWORD PTR [edi+1296]
	mov	edx, DWORD PTR [edx+44]
	xor	esi, esi
	xor	ecx, ecx
$LL259@AttemptCou:
	cmp	ecx, edx
	je	SHORT $LN20@AttemptCou

; 1948 : 			{
; 1949 : 				continue;
; 1950 : 			}
; 1951 : 
; 1952 : 			// only drop the influence if they have positive influence
; 1953 : 			if(aiNewInfluenceValueTimes100[ui] > 0)

	mov	eax, DWORD PTR _aiNewInfluenceValueTimes100$[esp+ecx*4+612]
	cmp	eax, esi
	jle	SHORT $LN20@AttemptCou

; 1954 : 			{
; 1955 : 				int iNewInfluence = aiNewInfluenceValueTimes100[ui] - (GC.getESPIONAGE_COUP_OTHER_PLAYERS_INFLUENCE_DROP() * 100);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7952
	imul	ebp, 100				; 00000064H
	sub	eax, ebp
	mov	DWORD PTR _iNewInfluence$223566[esp+612], eax

; 1956 : 				iNewInfluence = max(iNewInfluence, 0);

	mov	DWORD PTR $T242960[esp+612], esi
	lea	eax, DWORD PTR $T242960[esp+612]
	js	SHORT $LN87@AttemptCou
	lea	eax, DWORD PTR _iNewInfluence$223566[esp+612]
$LN87@AttemptCou:

; 1957 : #ifdef NQ_COUP_FORMULA_USES_BASE_FRIENDSHIP_NOT_EFFECTIVE_FRIENDSHIP
; 1958 : 				// cap all others at the ally threshold of 60 though (it's further reduced by 20 later)
; 1959 : 				iNewInfluence = min(iNewInfluence, GC.getFRIENDSHIP_THRESHOLD_ALLIES() * 100);
; 1960 : #endif
; 1961 : 				aiNewInfluenceValueTimes100[ui] = iNewInfluence;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _aiNewInfluenceValueTimes100$[esp+ecx*4+612], eax
$LN20@AttemptCou:
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, edx
	je	SHORT $LN256@AttemptCou
	mov	eax, DWORD PTR _aiNewInfluenceValueTimes100$[esp+ecx*4+616]
	cmp	eax, esi
	jle	SHORT $LN256@AttemptCou
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7952
	imul	ebp, 100				; 00000064H
	sub	eax, ebp
	mov	DWORD PTR _iNewInfluence$223566[esp+612], eax
	mov	DWORD PTR $T242960[esp+612], esi
	lea	eax, DWORD PTR $T242960[esp+612]
	js	SHORT $LN255@AttemptCou

; 1956 : 				iNewInfluence = max(iNewInfluence, 0);

	lea	eax, DWORD PTR _iNewInfluence$223566[esp+612]
$LN255@AttemptCou:

; 1957 : #ifdef NQ_COUP_FORMULA_USES_BASE_FRIENDSHIP_NOT_EFFECTIVE_FRIENDSHIP
; 1958 : 				// cap all others at the ally threshold of 60 though (it's further reduced by 20 later)
; 1959 : 				iNewInfluence = min(iNewInfluence, GC.getFRIENDSHIP_THRESHOLD_ALLIES() * 100);
; 1960 : #endif
; 1961 : 				aiNewInfluenceValueTimes100[ui] = iNewInfluence;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _aiNewInfluenceValueTimes100$[esp+ecx*4+616], eax
$LN256@AttemptCou:
	add	ecx, 2
	cmp	ecx, 22					; 00000016H
	jb	SHORT $LL259@AttemptCou

; 1962 : 			}
; 1963 : 		}
; 1964 : 
; 1965 : 		bAttemptSuccess = true;

	mov	BYTE PTR _bAttemptSuccess$[esp+612], 1

; 1966 : 	}
; 1967 : 	else

	jmp	SHORT $LN16@AttemptCou
$LN22@AttemptCou:

; 1968 : 	{
; 1969 : 		// reduce influence of player
; 1970 : 		// right now move the influence into a negative space
; 1971 : 		aiNewInfluenceValueTimes100[m_pPlayer->GetID()] = (-10 * 100);

	mov	eax, DWORD PTR [ecx+44]

; 1972 : 		bAttemptSuccess = false;
; 1973 : 
; 1974 : 		// kill the spy
; 1975 : 		ExtractSpyFromCity(uiSpyIndex); // move the dead body out so that someone else can move in

	push	ebp
	mov	ecx, edi
	mov	DWORD PTR _aiNewInfluenceValueTimes100$[esp+eax*4+616], -1000 ; fffffc18H
	mov	BYTE PTR _bAttemptSuccess$[esp+616], 0
	call	?ExtractSpyFromCity@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::ExtractSpyFromCity

; 1976 : 		m_aSpyList[uiSpyIndex].m_eSpyState = SPY_STATE_DEAD; // have to official kill him after the extraction

	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+edx+16], 8
	xor	esi, esi
$LN16@AttemptCou:

; 1977 : 	}
; 1978 : 
; 1979 : 	// do others influence first so that the potential coup person will be the ally
; 1980 : 	pMinorCivAI->SetDisableNotifications(true);

	mov	ecx, DWORD PTR _pMinorCivAI$[esp+612]
	push	1
	call	?SetDisableNotifications@CvMinorCivAI@@QAEX_N@Z ; CvMinorCivAI::SetDisableNotifications
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	eax, eax

; 1981 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$223569[esp+612], esi
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	mov	DWORD PTR tv1355[esp+612], eax
	npad	4
$LL15@AttemptCou:

; 1982 : 	{
; 1983 : 		PlayerTypes ePlayer = (PlayerTypes)ui;
; 1984 : 		if(!GET_PLAYER(ePlayer).isAlive())

	cmp	BYTE PTR [eax+edx+2256], 0
	je	$LN14@AttemptCou

; 1985 : 		{
; 1986 : 			continue;
; 1987 : 		}
; 1988 : 
; 1989 : 		// skip the spy player
; 1990 : 		if(ePlayer == m_pPlayer->GetID())

	mov	eax, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR _ui$223569[esp+612]
	cmp	ecx, DWORD PTR [eax+44]
	je	$LN14@AttemptCou

; 1991 : 		{
; 1992 : 			continue;
; 1993 : 		}
; 1994 : 
; 1995 : 		// send notification to other civs if they have met this minor
; 1996 : 		bool bMetMinor = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(GET_PLAYER(eCityOwner).getTeam());

	mov	eax, DWORD PTR tv933[esp+612]
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN110@AttemptCou
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN111@AttemptCou
$LN110@AttemptCou:
	or	ecx, -1
$LN111@AttemptCou:
	mov	eax, DWORD PTR tv1355[esp+612]
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN121@AttemptCou
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN122@AttemptCou
$LN121@AttemptCou:
	or	eax, -1
$LN122@AttemptCou:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet

; 1997 : 		bool bNotify = false;
; 1998 : 		int iFriendship = pMinorCivAI->GetEffectiveFriendshipWithMajor(ePlayer);

	mov	ecx, DWORD PTR _pMinorCivAI$[esp+612]
	mov	BYTE PTR _bMetMinor$223577[esp+612], al
	mov	eax, DWORD PTR _ui$223569[esp+612]
	push	eax
	mov	BYTE PTR _bNotify$223578[esp+616], 0
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor

; 1999 : 		int iRelationshipAnchor = pMinorCivAI->GetFriendshipAnchorWithMajor(ePlayer);

	mov	ecx, DWORD PTR _ui$223569[esp+612]
	push	ecx
	mov	ecx, DWORD PTR _pMinorCivAI$[esp+616]
	mov	DWORD PTR _iFriendship$223579[esp+616], eax
	call	?GetFriendshipAnchorWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetFriendshipAnchorWithMajor

; 2000 : 		bool bFriends = pMinorCivAI->IsFriends(ePlayer);

	mov	edx, DWORD PTR _ui$223569[esp+612]
	mov	ecx, DWORD PTR _pMinorCivAI$[esp+612]
	push	edx
	mov	DWORD PTR _iRelationshipAnchor$223580[esp+616], eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends

; 2001 : 
; 2002 : 		if (iFriendship > iRelationshipAnchor || bFriends)

	mov	ecx, DWORD PTR _iRelationshipAnchor$223580[esp+612]
	cmp	DWORD PTR _iFriendship$223579[esp+612], ecx
	jg	SHORT $LN9@AttemptCou
	test	al, al
	je	SHORT $LN10@AttemptCou
$LN9@AttemptCou:

; 2003 : 		{
; 2004 : 			bNotify = true;

	mov	BYTE PTR _bNotify$223578[esp+612], 1
$LN10@AttemptCou:

; 2005 : 		}
; 2006 : 
; 2007 : 		CvPlayerEspionage* pOtherEspionage = GET_PLAYER(ePlayer).GetEspionage();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1355[esp+612]
	lea	ecx, DWORD PTR [eax+edx]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage

; 2008 : 		int iSpyIndex = pOtherEspionage->GetSpyIndexInCity(pCity);

	mov	ecx, DWORD PTR [eax+1296]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, ebx
	mov	DWORD PTR $T243188[esp+612], edx
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 2009 : 		if (iSpyIndex >= 0)

	mov	ecx, DWORD PTR $T243188[esp+612]
	add	eax, 4
	cmp	DWORD PTR [eax+ecx*4], 0
	jl	SHORT $LN8@AttemptCou

; 2010 : 		{
; 2011 : 			bNotify = true;

	mov	BYTE PTR _bNotify$223578[esp+612], 1
$LN8@AttemptCou:

; 2012 : 		}
; 2013 : 
; 2014 : 		pMinorCivAI->SetFriendshipWithMajorTimes100(ePlayer, aiNewInfluenceValueTimes100[ui]);

	mov	eax, DWORD PTR _ui$223569[esp+612]
	mov	edx, DWORD PTR _aiNewInfluenceValueTimes100$[esp+eax*4+612]
	mov	ecx, DWORD PTR _pMinorCivAI$[esp+612]
	push	0
	push	edx
	push	eax
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100

; 2015 : 
; 2016 : 		CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv1355[esp+612]
	add	ecx, eax
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$223587[esp+612], eax

; 2017 : 		if(pNotifications && bMetMinor && bNotify)

	test	eax, eax
	je	$LN257@AttemptCou
	cmp	BYTE PTR _bMetMinor$223577[esp+612], 0
	je	$LN257@AttemptCou
	cmp	BYTE PTR _bNotify$223578[esp+612], 0
	je	$LN257@AttemptCou

; 2018 : 		{
; 2019 : 			NotificationTypes eNotification;
; 2020 : 			Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$223590[esp+612]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2021 : 			Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223591[esp+612]
	mov	DWORD PTR __$EHRec$[esp+620], 2
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2022 : 			if(bAttemptSuccess)

	cmp	BYTE PTR _bAttemptSuccess$[esp+612], 0
	mov	BYTE PTR __$EHRec$[esp+620], 3
	je	$LN6@AttemptCou

; 2023 : 			{
; 2024 : 				eNotification = NOTIFICATION_SPY_STAGE_COUP_SUCCESS;
; 2025 : 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_SUCCESS_S");

	lea	edx, DWORD PTR $T242961[esp+612]
	push	OFFSET $SG223594
	push	edx
	mov	DWORD PTR _eNotification$223589[esp+620], -20047341 ; fece1a13H
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223590[esp+616]
	mov	BYTE PTR __$EHRec$[esp+624], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242961[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 3
	call	ebp

; 2026 : 				strSummary << m_pPlayer->getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223590[esp+616]
	call	esi

; 2027 : 				strSummary << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223590[esp+616]
	call	esi

; 2028 : 				strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_SUCCESS");

	lea	eax, DWORD PTR $T242964[esp+612]
	push	OFFSET $SG223598
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+620], 5

; 2029 : 				strNotification << m_pPlayer->getCivilizationShortDescriptionKey();
; 2030 : 				strNotification << pCity->getNameKey();
; 2031 : 				strNotification << GET_PLAYER(ePreviousAlly).getCivilizationAdjectiveKey();
; 2032 : 			}
; 2033 : 			else

	jmp	$LN263@AttemptCou
$LN6@AttemptCou:

; 2034 : 			{
; 2035 : 				eNotification = NOTIFICATION_SPY_STAGE_COUP_FAILURE;
; 2036 : 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_FAILURE_S");

	lea	ecx, DWORD PTR $T242968[esp+612]
	push	OFFSET $SG223604
	push	ecx
	mov	DWORD PTR _eNotification$223589[esp+620], -1336555936 ; b055c660H
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223590[esp+616]
	mov	BYTE PTR __$EHRec$[esp+624], 6
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242968[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 3
	call	ebp

; 2037 : 				strSummary << m_pPlayer->getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223590[esp+616]
	call	esi

; 2038 : 				strSummary << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223590[esp+616]
	call	esi

; 2039 : 				strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_STAGE_COUP_FAILURE");

	lea	edx, DWORD PTR $T242971[esp+612]
	push	OFFSET $SG223608
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[esp+620], 7
$LN263@AttemptCou:
	push	eax
	lea	ecx, DWORD PTR _strNotification$223591[esp+616]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242971[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 3
	call	ebp

; 2040 : 				strNotification << m_pPlayer->getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223591[esp+616]
	call	esi

; 2041 : 				strNotification << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223591[esp+616]
	call	esi

; 2042 : 				strNotification << GET_PLAYER(ePreviousAlly).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _ePreviousAlly$[esp+612]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223591[esp+616]
	call	esi

; 2043 : 			}
; 2044 : 			pNotifications->Add(eNotification, strNotification.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	-1
	push	-1
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$223590[esp+628]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$223591[esp+632]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotifications$223587[esp+632]
	push	eax
	mov	eax, DWORD PTR _eNotification$223589[esp+636]
	push	eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2045 : 		}

	lea	ecx, DWORD PTR _strNotification$223591[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 2
	call	ebp
	lea	ecx, DWORD PTR _strSummary$223590[esp+612]
	mov	DWORD PTR __$EHRec$[esp+620], -1
	call	ebp
$LN257@AttemptCou:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN14@AttemptCou:

; 1981 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	eax, DWORD PTR tv1355[esp+612]
	inc	DWORD PTR _ui$223569[esp+612]
	add	eax, 63236				; 0000f704H
	mov	DWORD PTR tv1355[esp+612], eax
	cmp	eax, 1391192				; 00153a58H
	jb	$LL15@AttemptCou

; 2046 : 	}
; 2047 : 	
; 2048 : 	pMinorCivAI->SetFriendshipWithMajorTimes100(m_pPlayer->GetID(), aiNewInfluenceValueTimes100[m_pPlayer->GetID()]);

	mov	ecx, DWORD PTR [edi+1296]
	mov	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _aiNewInfluenceValueTimes100$[esp+eax*4+612]
	mov	ecx, DWORD PTR _pMinorCivAI$[esp+612]
	push	0
	push	edx
	push	eax
	call	?SetFriendshipWithMajorTimes100@CvMinorCivAI@@QAEXW4PlayerTypes@@H_N@Z ; CvMinorCivAI::SetFriendshipWithMajorTimes100

; 2049 : 	pMinorCivAI->SetDisableNotifications(false);

	mov	ecx, DWORD PTR _pMinorCivAI$[esp+612]
	push	0
	call	?SetDisableNotifications@CvMinorCivAI@@QAEX_N@Z ; CvMinorCivAI::SetDisableNotifications

; 2050 : 
; 2051 : 	// send notification to player
; 2052 : 	CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [edi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$[esp+612], eax

; 2053 : 	if(pNotifications)

	test	eax, eax
	je	$LN4@AttemptCou

; 2054 : 	{
; 2055 : 		NotificationTypes eNotification;
; 2056 : 		Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$223615[esp+612]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2057 : 		Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223616[esp+612]
	mov	DWORD PTR __$EHRec$[esp+620], 8
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2058 : 		if(bAttemptSuccess)

	cmp	BYTE PTR _bAttemptSuccess$[esp+612], 0
	mov	BYTE PTR __$EHRec$[esp+620], 9
	je	$LN3@AttemptCou

; 2059 : 		{
; 2060 : 			eNotification = NOTIFICATION_SPY_YOU_STAGE_COUP_SUCCESS;
; 2061 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_SUCCESS_S");

	lea	eax, DWORD PTR $T242975[esp+612]
	push	OFFSET $SG223619
	push	eax
	mov	DWORD PTR _eNotification$223614[esp+620], -887564073 ; cb18d8d7H
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223615[esp+616]
	mov	BYTE PTR __$EHRec$[esp+624], 10		; 0000000aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242975[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 9
	call	ebp

; 2062 : 			strSummary << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223615[esp+616]
	call	esi

; 2063 : 			strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_SUCCESS");

	lea	ecx, DWORD PTR $T242977[esp+612]
	push	OFFSET $SG223622
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	mov	BYTE PTR __$EHRec$[esp+624], 11		; 0000000bH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242977[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 9
	call	ebp

; 2064 : 			strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR tv946[esp+612]
	mov	eax, DWORD PTR [eax+edx+12]
	sub	eax, 0
	je	SHORT $LN187@AttemptCou
	sub	eax, 1
	je	SHORT $LN186@AttemptCou
	sub	eax, 1
	je	SHORT $LN185@AttemptCou
	mov	eax, OFFSET $SG223399
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2065 : 			strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	add	eax, DWORD PTR tv946[esp+612]
	mov	ecx, DWORD PTR [eax]
	push	ecx

; 2066 : 			strNotification << pCity->getNameKey();
; 2067 : 			strNotification << GET_PLAYER(ePreviousAlly).getCivilizationAdjectiveKey();
; 2068 : 		}
; 2069 : 		else

	jmp	$LN264@AttemptCou

; 2064 : 			strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

$LN185@AttemptCou:
	mov	eax, OFFSET $SG223398
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2065 : 			strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	add	eax, DWORD PTR tv946[esp+612]
	mov	ecx, DWORD PTR [eax]
	push	ecx

; 2066 : 			strNotification << pCity->getNameKey();
; 2067 : 			strNotification << GET_PLAYER(ePreviousAlly).getCivilizationAdjectiveKey();
; 2068 : 		}
; 2069 : 		else

	jmp	$LN264@AttemptCou

; 2064 : 			strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

$LN186@AttemptCou:
	mov	eax, OFFSET $SG223396
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2065 : 			strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	add	eax, DWORD PTR tv946[esp+612]
	mov	ecx, DWORD PTR [eax]
	push	ecx

; 2066 : 			strNotification << pCity->getNameKey();
; 2067 : 			strNotification << GET_PLAYER(ePreviousAlly).getCivilizationAdjectiveKey();
; 2068 : 		}
; 2069 : 		else

	jmp	$LN264@AttemptCou

; 2064 : 			strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

$LN187@AttemptCou:
	mov	eax, OFFSET $SG223394
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2065 : 			strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	add	eax, DWORD PTR tv946[esp+612]
	mov	ecx, DWORD PTR [eax]
	push	ecx

; 2066 : 			strNotification << pCity->getNameKey();
; 2067 : 			strNotification << GET_PLAYER(ePreviousAlly).getCivilizationAdjectiveKey();
; 2068 : 		}
; 2069 : 		else

	jmp	$LN264@AttemptCou
$LN3@AttemptCou:

; 2070 : 		{
; 2071 : 			eNotification = NOTIFICATION_SPY_YOU_STAGE_COUP_FAILURE;
; 2072 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_FAILURE_S");

	lea	edx, DWORD PTR $T242982[esp+612]
	push	OFFSET $SG223629
	push	edx
	mov	DWORD PTR _eNotification$223614[esp+620], -2055011164 ; 858304a4H
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223615[esp+616]
	mov	BYTE PTR __$EHRec$[esp+624], 12		; 0000000cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242982[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 9
	call	ebp

; 2073 : 			strSummary << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223615[esp+616]
	call	esi

; 2074 : 			strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_YOU_STAGE_COUP_FAILURE");

	lea	eax, DWORD PTR $T242984[esp+612]
	push	OFFSET $SG223632
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	mov	BYTE PTR __$EHRec$[esp+624], 13		; 0000000dH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242984[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 9
	call	ebp

; 2075 : 			strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR tv946[esp+612]
	mov	eax, DWORD PTR [edx+ecx+12]
	sub	eax, 0
	je	SHORT $LN210@AttemptCou
	sub	eax, 1
	je	SHORT $LN209@AttemptCou
	sub	eax, 1
	je	SHORT $LN208@AttemptCou
	mov	eax, OFFSET $SG223399
	jmp	SHORT $LN213@AttemptCou
$LN208@AttemptCou:
	mov	eax, OFFSET $SG223398
	jmp	SHORT $LN213@AttemptCou
$LN209@AttemptCou:
	mov	eax, OFFSET $SG223396
	jmp	SHORT $LN213@AttemptCou
$LN210@AttemptCou:
	mov	eax, OFFSET $SG223394
$LN213@AttemptCou:
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2076 : 			strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	add	eax, DWORD PTR tv946[esp+612]
	mov	eax, DWORD PTR [eax]
	push	eax
$LN264@AttemptCou:
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2077 : 			strNotification << pCity->getNameKey();

	mov	ecx, ebx
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2078 : 			strNotification << GET_PLAYER(ePreviousAlly).getCivilizationAdjectiveKey();

	mov	eax, DWORD PTR _ePreviousAlly$[esp+612]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+616]
	call	esi

; 2079 : 		}
; 2080 : 		pNotifications->Add(eNotification, strNotification.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);

	mov	eax, DWORD PTR [ebx+108]
	mov	ebx, DWORD PTR [ebx+96]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _strSummary$223615[esp+628]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$223616[esp+632]
	call	esi
	mov	ecx, DWORD PTR _eNotification$223614[esp+632]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _pNotifications$[esp+640]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2081 : 	}

	lea	ecx, DWORD PTR _strNotification$223616[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 8
	call	ebp
	lea	ecx, DWORD PTR _strSummary$223615[esp+612]
	mov	DWORD PTR __$EHRec$[esp+620], -1
	call	ebp
$LN4@AttemptCou:

; 2082 : 
; 2083 : 	//Achievements!
; 2084 : 	if(bAttemptSuccess && m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	bl, BYTE PTR _bAttemptSuccess$[esp+612]
	test	bl, bl
	je	SHORT $LN1@AttemptCou
	mov	edx, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edx+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN1@AttemptCou

; 2085 : 	{
; 2086 : 		gDLL->UnlockAchievement(ACHIEVEMENT_XP1_13);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	203					; 000000cbH
	call	edx
$LN1@AttemptCou:

; 2087 : 	}
; 2088 : 
; 2089 : 	// Update City banners and game info
; 2090 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	11					; 0000000bH
	call	edx

; 2091 : 	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	18					; 00000012H
	call	edx

; 2092 : 
; 2093 : 	return bAttemptSuccess;

	mov	al, bl
$LN262@AttemptCou:
	pop	esi
$LN261@AttemptCou:
	pop	ebx
$LN31@AttemptCou:

; 2094 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+604]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 596				; 00000254H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$0:
	lea	ecx, DWORD PTR _strMsg$223552[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$1:
	lea	ecx, DWORD PTR $T242959[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$2:
	lea	ecx, DWORD PTR _strSummary$223590[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$3:
	lea	ecx, DWORD PTR _strNotification$223591[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$4:
	lea	ecx, DWORD PTR $T242961[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$5:
	lea	ecx, DWORD PTR $T242964[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$6:
	lea	ecx, DWORD PTR $T242968[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$7:
	lea	ecx, DWORD PTR $T242971[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$8:
	lea	ecx, DWORD PTR _strSummary$223615[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$9:
	lea	ecx, DWORD PTR _strNotification$223616[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$10:
	lea	ecx, DWORD PTR $T242975[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$11:
	lea	ecx, DWORD PTR $T242977[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$12:
	lea	ecx, DWORD PTR $T242982[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z$13:
	lea	ecx, DWORD PTR $T242984[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z:
	mov	eax, OFFSET __ehfuncinfo$?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z ENDP		; CvPlayerEspionage::AttemptCoup
PUBLIC	?HasSharedIntrigueAboutMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ; CvPlayerEspionage::HasSharedIntrigueAboutMe
; Function compile flags: /Ogtpy
;	COMDAT ?HasSharedIntrigueAboutMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eFromPlayer$ = 8					; size = 4
?HasSharedIntrigueAboutMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlayerEspionage::HasSharedIntrigueAboutMe, COMDAT
; _this$ = ecx

; 3687 : 	for(std::vector<IntrigueNotificationMessage>::iterator it = m_aIntrigueNotificationMessages.begin();

	mov	eax, DWORD PTR [ecx+1284]
	mov	ecx, DWORD PTR [ecx+1288]

; 3688 : 		it != m_aIntrigueNotificationMessages.end(); ++it)

	cmp	eax, ecx
	je	SHORT $LN2@HasSharedI@3
	mov	edx, DWORD PTR _eFromPlayer$[esp-4]
$LL15@HasSharedI@3:

; 3689 : 	{
; 3690 : 		if((*it).m_eDiscoveringPlayer == eFromPlayer)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN32@HasSharedI@3
	add	eax, 68					; 00000044H
	cmp	eax, ecx
	jne	SHORT $LL15@HasSharedI@3
$LN2@HasSharedI@3:

; 3692 : 	}
; 3693 : 
; 3694 : 	return false;

	xor	al, al

; 3695 : }

	ret	4
$LN32@HasSharedI@3:

; 3691 : 			return true;

	mov	al, 1

; 3695 : }

	ret	4
?HasSharedIntrigueAboutMe@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlayerEspionage::HasSharedIntrigueAboutMe
_TEXT	ENDS
PUBLIC	?Reset@CvEspionageAI@@QAEXXZ			; CvEspionageAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvEspionageAI@@QAEXXZ PROC			; CvEspionageAI::Reset, COMDAT
; _this$ = ecx

; 4241 : {

	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 4242 : 	m_aiCivOutOfTechTurn.clear();

	xor	ebx, ebx
	lea	esi, DWORD PTR [ebp+4]
	push	edi
	mov	DWORD PTR [esi+4], ebx
	lea	edi, DWORD PTR [ebx+22]
$LL21@Reset@2:

; 4243 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4244 : 	{
; 4245 : 		m_aiCivOutOfTechTurn.push_back(-1);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN32@Reset@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN32@Reset@2:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebx
	je	SHORT $LN35@Reset@2
	mov	DWORD PTR [eax], -1
$LN35@Reset@2:
	inc	DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL21@Reset@2

; 4246 : 	}
; 4247 : 
; 4248 : 	m_aiNumSpiesCaught.clear();

	lea	esi, DWORD PTR [ebp+108]
	mov	DWORD PTR [esi+4], ebx
	mov	edi, 22					; 00000016H
	npad	7
$LL18@Reset@2:

; 4249 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4250 : 	{
; 4251 : 		m_aiNumSpiesCaught.push_back(0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN47@Reset@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN47@Reset@2:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	eax, ebx
	je	SHORT $LN50@Reset@2
	mov	DWORD PTR [eax], ebx
$LN50@Reset@2:
	inc	DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL18@Reset@2

; 4252 : 	}
; 4253 : 
; 4254 : 	m_aiNumSpiesKilled.clear();

	lea	esi, DWORD PTR [ebp+212]
	mov	DWORD PTR [esi+4], ebx
	mov	edi, 22					; 00000016H
$LL15@Reset@2:

; 4255 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4256 : 	{
; 4257 : 		m_aiNumSpiesKilled.push_back(0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN62@Reset@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN62@Reset@2:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN65@Reset@2
	mov	DWORD PTR [eax], ebx
$LN65@Reset@2:
	inc	DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL15@Reset@2

; 4258 : 	}
; 4259 : 
; 4260 : 	m_aiNumSpiesDied.clear();

	lea	esi, DWORD PTR [ebp+316]
	mov	DWORD PTR [esi+4], ebx
	mov	edi, 22					; 00000016H
	npad	2
$LL12@Reset@2:

; 4261 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4262 : 	{
; 4263 : 		m_aiNumSpiesDied.push_back(0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN77@Reset@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN77@Reset@2:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebx
	je	SHORT $LN80@Reset@2
	mov	DWORD PTR [eax], ebx
$LN80@Reset@2:
	inc	DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL12@Reset@2

; 4264 : 	}
; 4265 : 
; 4266 : 	m_aiTurnLastSpyCaught.clear();

	lea	esi, DWORD PTR [ebp+420]
	mov	DWORD PTR [esi+4], ebx
	mov	edi, 22					; 00000016H
$LL9@Reset@2:

; 4267 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4268 : 	{
; 4269 : 		m_aiTurnLastSpyCaught.push_back(-1);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN92@Reset@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN92@Reset@2:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	eax, ebx
	je	SHORT $LN95@Reset@2
	mov	DWORD PTR [eax], -1
$LN95@Reset@2:
	inc	DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL9@Reset@2

; 4270 : 	}
; 4271 : 
; 4272 : 	m_aiTurnLastSpyKilled.clear();

	lea	esi, DWORD PTR [ebp+524]
	mov	DWORD PTR [esi+4], ebx
	mov	edi, 22					; 00000016H
$LL6@Reset@2:

; 4273 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4274 : 	{
; 4275 : 		m_aiTurnLastSpyKilled.push_back(-1);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN107@Reset@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN107@Reset@2:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN110@Reset@2
	mov	DWORD PTR [eax], -1
$LN110@Reset@2:
	inc	DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL6@Reset@2

; 4276 : 	}
; 4277 : 
; 4278 : 	m_aiTurnLastSpyDied.clear();

	lea	esi, DWORD PTR [ebp+628]
	mov	DWORD PTR [esi+4], ebx
	mov	edi, 22					; 00000016H
	npad	3
$LL3@Reset@2:

; 4279 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4280 : 	{
; 4281 : 		m_aiTurnLastSpyDied.push_back(-1);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN122@Reset@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN122@Reset@2:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebx
	je	SHORT $LN125@Reset@2
	mov	DWORD PTR [eax], -1
$LN125@Reset@2:
	inc	DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL3@Reset@2
	pop	edi
	pop	esi

; 4282 : 	}
; 4283 : 
; 4284 : 	m_bUNCountdownStarted = false;

	mov	BYTE PTR [ebp+732], bl

; 4285 : 	m_iTurnEspionageStarted = -1;

	mov	DWORD PTR [ebp+736], -1
	pop	ebp
	pop	ebx

; 4286 : }

	ret	0
?Reset@CvEspionageAI@@QAEXXZ ENDP			; CvEspionageAI::Reset
_TEXT	ENDS
PUBLIC	?AttemptCoups@CvEspionageAI@@QAEXXZ		; CvEspionageAI::AttemptCoups
EXTRN	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDoFAccepted
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
; Function compile flags: /Ogtpy
;	COMDAT ?AttemptCoups@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
?AttemptCoups@CvEspionageAI@@QAEXXZ PROC		; CvEspionageAI::AttemptCoups, COMDAT
; _this$ = ecx

; 4689 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 4690 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ebx, eax

; 4691 : 	for(uint uiSpy = 0; uiSpy < pEspionage->m_aSpyList.size(); uiSpy++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+8], edi
	jbe	$LN6@AttemptCou@2
	push	esi
	npad	5
$LL8@AttemptCou@2:

; 4692 : 	{
; 4693 : 		if (!pEspionage->CanStageCoup(uiSpy))

	push	edi
	mov	ecx, ebx
	call	?CanStageCoup@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::CanStageCoup
	test	al, al
	je	$LN7@AttemptCou@2

; 4694 : 		{
; 4695 : 			continue;
; 4696 : 		}
; 4697 : 	
; 4698 : 		// special Lena fix: no couping on CS that are allies with your friend
; 4699 : 		CvCity* pCity = pEspionage->GetCityWithSpy(uiSpy);

	push	edi
	mov	ecx, ebx
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy
	mov	esi, eax

; 4700 : 		if (pCity && GET_PLAYER(pCity->getOwner()).isMinorCiv())

	test	esi, esi
	je	SHORT $LN2@AttemptCou@2
	mov	ecx, DWORD PTR [esi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN2@AttemptCou@2

; 4701 : 		{
; 4702 : 			CvMinorCivAI* pMinorCivAI = GET_PLAYER(pCity->getOwner()).GetMinorCivAI();

	mov	ecx, DWORD PTR [esi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI

; 4703 : 			if (pMinorCivAI)

	test	eax, eax
	je	SHORT $LN2@AttemptCou@2

; 4704 : 			{
; 4705 : 				PlayerTypes eCurrentAlly = pMinorCivAI->GetAlly();

	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 4706 : 				if (eCurrentAlly != NO_PLAYER && eCurrentAlly != m_pPlayer->GetID() && m_pPlayer->GetDiplomacyAI()->IsDoFAccepted(eCurrentAlly))

	cmp	eax, -1
	je	SHORT $LN2@AttemptCou@2
	mov	ecx, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [ecx+44]
	je	SHORT $LN2@AttemptCou@2
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	jne	SHORT $LN7@AttemptCou@2
$LN2@AttemptCou@2:

; 4707 : 				{
; 4708 : 					continue;
; 4709 : 				}
; 4710 : 			}
; 4711 : 		}
; 4712 : 
; 4713 : 		int iChanceOfSuccess = pEspionage->GetCoupChanceOfSuccess(uiSpy);

	push	edi
	mov	ecx, ebx
	call	?GetCoupChanceOfSuccess@CvPlayerEspionage@@QAEHI@Z ; CvPlayerEspionage::GetCoupChanceOfSuccess

; 4714 : 		int iRoll = GC.getGame().getJonRandNum(100, "Random roll to see if we should attempt a coup");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG225543
	push	100					; 00000064H
	mov	esi, eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 4715 : 		if (iRoll < iChanceOfSuccess)

	cmp	eax, esi
	jge	SHORT $LN7@AttemptCou@2

; 4716 : 		{
; 4717 : 			pEspionage->AttemptCoup(uiSpy);

	push	edi
	mov	ecx, ebx
	call	?AttemptCoup@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::AttemptCoup
$LN7@AttemptCou@2:
	inc	edi
	cmp	edi, DWORD PTR [ebx+8]
	jb	$LL8@AttemptCou@2
	pop	esi
$LN6@AttemptCou@2:
	pop	edi
	pop	ebp
	pop	ebx

; 4718 : 		}
; 4719 : 	}
; 4720 : }

	ret	0
?AttemptCoups@CvEspionageAI@@QAEXXZ ENDP		; CvEspionageAI::AttemptCoups
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvEspionageAI@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvEspionageAI@@@Z
_TEXT	SEGMENT
_iValue$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_uiCount$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvEspionageAI@@@Z PROC	; operator>>, COMDAT

; 5655 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 5656 : 	uint uiVersion;
; 5657 : 	loadFrom >> uiVersion;

	mov	edi, DWORD PTR _loadFrom$[esp+20]
	lea	eax, DWORD PTR _uiVersion$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5658 : 
; 5659 : 	uint uiCount;
; 5660 : 	loadFrom >> uiCount;

	lea	ecx, DWORD PTR _uiCount$[esp+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5661 : 	int iValue;
; 5662 : 	for(uint ui = 0; ui < uiCount; ui++)

	xor	ebx, ebx
	xor	ebp, ebp
	cmp	DWORD PTR _uiCount$[esp+20], ebx
	jbe	SHORT $LN19@operator@8
	mov	esi, DWORD PTR _writeTo$[esp+20]
	add	esi, 4
$LL21@operator@8:

; 5663 : 	{
; 5664 : 		loadFrom >> iValue;

	lea	edx, DWORD PTR _iValue$[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5665 : 		writeTo.m_aiCivOutOfTechTurn.push_back(iValue);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN30@operator@8
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN30@operator@8:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, ebx
	je	SHORT $LN33@operator@8
	mov	edx, DWORD PTR _iValue$[esp+24]
	mov	DWORD PTR [eax], edx
$LN33@operator@8:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _uiCount$[esp+20]
	jb	SHORT $LL21@operator@8
$LN19@operator@8:

; 5666 : 	}
; 5667 : 
; 5668 : 	loadFrom >> uiCount;

	lea	eax, DWORD PTR _uiCount$[esp+20]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5669 : 	for(uint ui = 0; ui < uiCount; ui++)

	xor	ebp, ebp
	cmp	DWORD PTR _uiCount$[esp+20], ebx
	jbe	SHORT $LN16@operator@8
	mov	esi, DWORD PTR _writeTo$[esp+20]
	add	esi, 108				; 0000006cH
	npad	6
$LL18@operator@8:

; 5670 : 	{
; 5671 : 		loadFrom >> iValue;

	lea	ecx, DWORD PTR _iValue$[esp+24]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5672 : 		writeTo.m_aiNumSpiesCaught.push_back(iValue);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN41@operator@8
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN41@operator@8:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	eax, ebx
	je	SHORT $LN44@operator@8
	mov	ecx, DWORD PTR _iValue$[esp+24]
	mov	DWORD PTR [eax], ecx
$LN44@operator@8:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _uiCount$[esp+20]
	jb	SHORT $LL18@operator@8
$LN16@operator@8:

; 5673 : 	}
; 5674 : 
; 5675 : 	loadFrom >> uiCount;

	lea	edx, DWORD PTR _uiCount$[esp+20]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5676 : 	for(uint ui = 0; ui < uiCount; ui++)

	xor	ebp, ebp
	cmp	DWORD PTR _uiCount$[esp+20], ebx
	jbe	SHORT $LN13@operator@8
	mov	esi, DWORD PTR _writeTo$[esp+20]
	add	esi, 212				; 000000d4H
	npad	7
$LL15@operator@8:

; 5677 : 	{
; 5678 : 		loadFrom >> iValue;

	lea	eax, DWORD PTR _iValue$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5679 : 		writeTo.m_aiNumSpiesKilled.push_back(iValue);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN52@operator@8
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN52@operator@8:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN55@operator@8
	mov	ecx, DWORD PTR _iValue$[esp+24]
	mov	DWORD PTR [eax], ecx
$LN55@operator@8:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _uiCount$[esp+20]
	jb	SHORT $LL15@operator@8
$LN13@operator@8:

; 5680 : 	}
; 5681 : 
; 5682 : 	loadFrom >> uiCount;

	lea	edx, DWORD PTR _uiCount$[esp+20]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5683 : 	for(uint ui = 0; ui < uiCount; ui++)

	xor	ebp, ebp
	cmp	DWORD PTR _uiCount$[esp+20], ebx
	jbe	SHORT $LN10@operator@8
	mov	esi, DWORD PTR _writeTo$[esp+20]
	add	esi, 316				; 0000013cH
	npad	7
$LL12@operator@8:

; 5684 : 	{
; 5685 : 		loadFrom >> iValue;

	lea	eax, DWORD PTR _iValue$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5686 : 		writeTo.m_aiNumSpiesDied.push_back(iValue);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN63@operator@8
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN63@operator@8:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN66@operator@8
	mov	ecx, DWORD PTR _iValue$[esp+24]
	mov	DWORD PTR [eax], ecx
$LN66@operator@8:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _uiCount$[esp+20]
	jb	SHORT $LL12@operator@8
$LN10@operator@8:

; 5687 : 	}
; 5688 : 
; 5689 : 	loadFrom >> uiCount;

	lea	edx, DWORD PTR _uiCount$[esp+20]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5690 : 	for(uint ui = 0; ui < uiCount; ui++)

	xor	ebp, ebp
	cmp	DWORD PTR _uiCount$[esp+20], ebx
	jbe	SHORT $LN7@operator@8
	mov	esi, DWORD PTR _writeTo$[esp+20]
	add	esi, 420				; 000001a4H
	npad	7
$LL9@operator@8:

; 5691 : 	{
; 5692 : 		loadFrom >> iValue;

	lea	eax, DWORD PTR _iValue$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5693 : 		writeTo.m_aiTurnLastSpyCaught.push_back(iValue);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN74@operator@8
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN74@operator@8:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN77@operator@8
	mov	ecx, DWORD PTR _iValue$[esp+24]
	mov	DWORD PTR [eax], ecx
$LN77@operator@8:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _uiCount$[esp+20]
	jb	SHORT $LL9@operator@8
$LN7@operator@8:

; 5694 : 	}
; 5695 : 
; 5696 : 	loadFrom >> uiCount;

	lea	edx, DWORD PTR _uiCount$[esp+20]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5697 : 	for(uint ui = 0; ui < uiCount; ui++)

	xor	ebp, ebp
	cmp	DWORD PTR _uiCount$[esp+20], ebx
	jbe	SHORT $LN4@operator@8
	mov	esi, DWORD PTR _writeTo$[esp+20]
	add	esi, 524				; 0000020cH
	npad	7
$LL6@operator@8:

; 5698 : 	{
; 5699 : 		loadFrom >> iValue;

	lea	eax, DWORD PTR _iValue$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5700 : 		writeTo.m_aiTurnLastSpyKilled.push_back(iValue);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN85@operator@8
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN85@operator@8:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN88@operator@8
	mov	ecx, DWORD PTR _iValue$[esp+24]
	mov	DWORD PTR [eax], ecx
$LN88@operator@8:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _uiCount$[esp+20]
	jb	SHORT $LL6@operator@8
$LN4@operator@8:

; 5701 : 	}
; 5702 : 
; 5703 : 	loadFrom >> uiCount;

	lea	edx, DWORD PTR _uiCount$[esp+20]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5704 : 	for(uint ui = 0; ui < uiCount; ui++)

	xor	ebp, ebp
	cmp	DWORD PTR _uiCount$[esp+20], ebx
	jbe	SHORT $LN1@operator@8
	mov	esi, DWORD PTR _writeTo$[esp+20]
	add	esi, 628				; 00000274H
	npad	7
$LL3@operator@8:

; 5705 : 	{
; 5706 : 		loadFrom >> iValue;

	lea	eax, DWORD PTR _iValue$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5707 : 		writeTo.m_aiTurnLastSpyDied.push_back(iValue);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN96@operator@8
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN96@operator@8:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, ebx
	je	SHORT $LN99@operator@8
	mov	ecx, DWORD PTR _iValue$[esp+24]
	mov	DWORD PTR [eax], ecx
$LN99@operator@8:
	inc	DWORD PTR [esi+4]
	inc	ebp
	cmp	ebp, DWORD PTR _uiCount$[esp+20]
	jb	SHORT $LL3@operator@8
$LN1@operator@8:

; 5708 : 	}
; 5709 : 
; 5710 : 	loadFrom >> writeTo.m_bUNCountdownStarted;

	mov	esi, DWORD PTR _writeTo$[esp+20]
	lea	edx, DWORD PTR [esi+732]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 5711 : 	loadFrom >> writeTo.m_iTurnEspionageStarted;

	add	esi, 736				; 000002e0H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5712 : 	
; 5713 : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5714 : }

	add	esp, 8
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvEspionageAI@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAEIABVCvEspionageSpy@@@Z ; FStaticVector<CvEspionageSpy,8,0,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAEIABVCvEspionageSpy@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAEIABVCvEspionageSpy@@@Z PROC ; FStaticVector<CvEspionageSpy,8,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebx
	mov	ebx, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [ebx+8]
	push	edi
	mov	BYTE PTR [ebx+236], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvEspionageSpy,8,0,297,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edi, DWORD PTR [edx+ecx*4]
	test	edi, edi
	je	SHORT $LN4@push_back@2
	push	esi
	mov	esi, DWORD PTR _element$[esp+8]
	mov	ecx, 7
	rep movsd
	pop	esi
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	pop	ebx

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAEIABVCvEspionageSpy@@@Z ENDP ; FStaticVector<CvEspionageSpy,8,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEIABW4TechTypes@@@Z ; FStaticVector<enum TechTypes,1,0,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEIABW4TechTypes@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEIABW4TechTypes@@@Z PROC ; FStaticVector<enum TechTypes,1,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+16], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum TechTypes,1,0,297,0>::GrowSize
$LN1@push_back@3:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@3
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAEIABW4TechTypes@@@Z ENDP ; FStaticVector<enum TechTypes,1,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::vector<HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::vector<HeistLocation,std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::vector<HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??0?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	npad	2
$LL3@Destroy:

; 223  : 				pVal[i].~T();

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN12@Destroy
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN12@Destroy:
	add	esi, 20					; 00000014H
	sub	edi, 1
	jne	SHORT $LL3@Destroy
	pop	esi
$LN1@Destroy:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::Destroy
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@0@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@0@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@0@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@std@@@Z
_TEXT	SEGMENT
$T244682 = -4						; size = 1
__Cat$244686 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244682[esp+4], 0
	mov	eax, DWORD PTR $T244682[esp+4]
	mov	ecx, DWORD PTR __Cat$244686[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@std@@@Z
_TEXT	SEGMENT
$T244691 = -4						; size = 1
__Cat$244695 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244691[esp+4], 0
	mov	eax, DWORD PTR $T244691[esp+4]
	mov	ecx, DWORD PTR __Cat$244695[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z ; stdext::unchecked_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z
_TEXT	SEGMENT
$T244700 = -4						; size = 1
__Cat$244705 = -4					; size = 1
$T244702 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z PROC ; stdext::unchecked_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T244700[esp+4], 0
	mov	eax, DWORD PTR $T244700[esp+4]
	mov	ecx, DWORD PTR __Cat$244705[esp+4]
	mov	edx, DWORD PTR $T244702[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z ENDP ; stdext::unchecked_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@std@@@Z
_TEXT	SEGMENT
$T244714 = -4						; size = 1
__Cat$244718 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244714[esp+4], 0
	mov	eax, DWORD PTR $T244714[esp+4]
	mov	ecx, DWORD PTR __Cat$244718[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@@Z ; std::_Destroy_range<std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@@Z PROC ; std::_Destroy_range<std::allocator<HeistLocation> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@0AAV?$allocator@UHeistLocation@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@@Z ; std::_Destroy_range<std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SpyNotificationMessage> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@0AAV?$allocator@USpyNotificationMessage@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z ; std::fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z PROC ; std::fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z ; std::_Fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>
??$fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z ENDP ; std::fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z ; stdext::_Unchecked_move_backward<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z
_TEXT	SEGMENT
$T244762 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244766 = 16					; size = 1
$T244745 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<IntrigueNotificationMessage *,IntrigueNotificationMessage *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244766[esp]
	mov	edx, DWORD PTR $T244745[esp]
	mov	BYTE PTR $T244762[esp+4], 0
	mov	eax, DWORD PTR $T244762[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<IntrigueNotificationMessage *,IntrigueNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@@Z ; std::_Destroy_range<std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ScoreCityEntry> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@0AAV?$allocator@UScoreCityEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@4
	pop	esi
$LN9@Uninit_fil@4:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@@Z ; std::allocator<IntrigueNotificationMessage>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@@Z PROC ; std::allocator<IntrigueNotificationMessage>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@UIntrigueNotificationMessage@@@std@@QAEXPAUIntrigueNotificationMessage@@@Z ENDP ; std::allocator<IntrigueNotificationMessage>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<HeistLocation *,HeistLocation *,std::allocator<HeistLocation>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244931 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244934 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<HeistLocation *,HeistLocation *,std::allocator<HeistLocation>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$244934[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244931[esp+4], 0
	mov	eax, DWORD PTR $T244931[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@U_Undefined_move_tag@3@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<HeistLocation *,HeistLocation *,std::allocator<HeistLocation>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244950 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244953 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$244953[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244950[esp+4], 0
	mov	eax, DWORD PTR $T244950[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244968 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244971 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$244971[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244968[esp+4], 0
	mov	eax, DWORD PTR $T244968[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,ScoreCityEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z
_TEXT	SEGMENT
$T245044 = -8						; size = 1
$T244979 = -4						; size = 4
__Cat$245048 = 8					; size = 1
$T245046 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,ScoreCityEntry>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 8
	cmp	edx, eax
	je	SHORT $LN6@Insertion_
	push	esi

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	je	SHORT $LN73@Insertion_
	push	ebx
	mov	ebx, DWORD PTR $T245046[esp+12]
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_
$LL72@Insertion_:
	mov	edx, DWORD PTR __First$[esp+20]
$LN7@Insertion_:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi+4]

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	cmp	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [esi]
	mov	ecx, esi
	jle	SHORT $LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T245044[esp+24], 0
	mov	ecx, DWORD PTR $T245044[esp+24]
	push	ecx
	mov	ecx, DWORD PTR __Cat$245048[esp+24]
	push	ecx
	push	ebx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	push	esi
	push	edx
	lea	edx, DWORD PTR $T244979[esp+48]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[esp+48]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR __First$[esp+48]
	add	esp, 28					; 0000001cH

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN75@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-4]
	lea	eax, DWORD PTR [esi-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, eax
	sub	eax, 8
	cmp	edi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebp
$LN75@Insertion_:

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	esi, 8

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx+4], edi
	cmp	esi, DWORD PTR __Last$[esp+20]
	jne	SHORT $LL72@Insertion_
	pop	edi
	pop	ebp
	pop	ebx
$LN73@Insertion_:
	pop	esi
$LN6@Insertion_:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	add	esp, 8
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ; std::lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T245118 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z PROC ; std::lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryHighEval>, COMDAT

; 2313 : 	{	// find first element not before _Val, using _Pred

	push	ecx

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T245118[esp+24]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2317 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ; std::upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T245125 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z PROC ; std::upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryHighEval>, COMDAT

; 2384 : 	{	// find first element that _Val is before, using _Pred

	push	ecx

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T245125[esp+24]
	push	ecx
	call	??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2388 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,ScoreCityEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z
_TEXT	SEGMENT
$T245197 = -8						; size = 1
$T245132 = -4						; size = 4
__Cat$245201 = 8					; size = 1
$T245199 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,ScoreCityEntry>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 8
	cmp	edx, eax
	je	SHORT $LN6@Insertion_@2
	push	esi

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	je	SHORT $LN73@Insertion_@2
	push	ebx
	mov	ebx, DWORD PTR $T245199[esp+12]
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_@2
$LL72@Insertion_@2:
	mov	edx, DWORD PTR __First$[esp+20]
$LN7@Insertion_@2:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi+4]

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	cmp	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [esi]
	mov	ecx, esi
	jge	SHORT $LN5@Insertion_@2

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T245197[esp+24], 0
	mov	ecx, DWORD PTR $T245197[esp+24]
	push	ecx
	mov	ecx, DWORD PTR __Cat$245201[esp+24]
	push	ecx
	push	ebx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	push	esi
	push	edx
	lea	edx, DWORD PTR $T245132[esp+48]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[esp+48]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR __First$[esp+48]
	add	esp, 28					; 0000001cH

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN75@Insertion_@2
$LN5@Insertion_@2:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-4]
	lea	eax, DWORD PTR [esi-8]
	jge	SHORT $LN1@Insertion_@2
$LL3@Insertion_@2:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, eax
	sub	eax, 8
	cmp	edi, DWORD PTR [eax+4]
	jl	SHORT $LL3@Insertion_@2
$LN1@Insertion_@2:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebp
$LN75@Insertion_@2:

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	esi, 8

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx+4], edi
	cmp	esi, DWORD PTR __Last$[esp+20]
	jne	SHORT $LL72@Insertion_@2
	pop	edi
	pop	ebp
	pop	ebx
$LN73@Insertion_@2:
	pop	esi
$LN6@Insertion_@2:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	add	esp, 8
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryLowEval@@@Z ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T245271 = -4						; size = 1
$T245272 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryLowEval@@@Z PROC ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T245272[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245271[esp+8], 0
	mov	eax, DWORD PTR $T245271[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryLowEval@@@Z ENDP ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T245280 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245280[esp+8], 0
	mov	eax, DWORD PTR $T245280[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5229 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ; std::lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T245284 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z PROC ; std::lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryLowEval>, COMDAT

; 2313 : 	{	// find first element not before _Val, using _Pred

	push	ecx

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T245284[esp+24]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2317 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ; std::upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T245291 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z PROC ; std::upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryLowEval>, COMDAT

; 2384 : 	{	// find first element that _Val is before, using _Pred

	push	ecx

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T245291[esp+24]
	push	ecx
	call	??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2388 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7
__unwindtable$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T245340 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$245350 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@6:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	$LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$245350[ebp], esi
	mov	DWORD PTR $T245340[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@6
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	lea	eax, DWORD PTR [edi+36]
	lea	ecx, DWORD PTR [esi+36]
	push	eax
	mov	DWORD PTR [esi+32], edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	cl, BYTE PTR [edi+64]
	mov	BYTE PTR [esi+64], cl
$LN18@Uninit_cop@6:
	add	esi, 68					; 00000044H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 68					; 00000044H
	jmp	SHORT $LL6@Uninit_cop@6
__catch$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@6
$LL3@Uninit_cop@6:
	lea	ecx, DWORD PTR [esi+36]

; 134  : 		_Al.destroy(_Next);

	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN48@Uninit_cop@6:
$LN4@Uninit_cop@6:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@Uninit_cop@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$245350[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245340[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >
PUBLIC	??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T245553 = 12						; size = 1
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$245557 = 28					; size = 1
$T245555 = 28						; size = 1
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	cmp	eax, esi
	je	SHORT $LN44@Merge@6
$LL10@Merge@6:
	mov	edx, DWORD PTR __First2$[esp+4]
	cmp	edx, DWORD PTR __Last2$[esp+4]
	je	SHORT $LN68@Merge@6

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [edx+4]
	cmp	ebx, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@6

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	DWORD PTR __First2$[esp+4], 8

; 2600 : 		else

	jmp	SHORT $LN4@Merge@6
$LN2@Merge@6:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
$LN4@Merge@6:
	mov	ecx, DWORD PTR __Dest$[esp+4]
	add	ecx, 8
	mov	DWORD PTR __Dest$[esp+4], ecx
	cmp	eax, esi
	jne	SHORT $LL10@Merge@6
$LN68@Merge@6:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN44@Merge@6
	npad	3
$LL46@Merge@6:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	add	eax, 8
	add	ecx, 8
	cmp	eax, esi
	jne	SHORT $LL46@Merge@6
$LN44@Merge@6:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR __Dest$[esp+4], ecx
	mov	edx, DWORD PTR __Cat$245557[esp+4]
	mov	BYTE PTR $T245553[esp+4], 0
	mov	eax, DWORD PTR $T245553[esp+4]
	push	eax
	mov	eax, DWORD PTR $T245555[esp+8]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+20]
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T245618 = -4						; size = 1
$T245593 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$245622 = 16					; size = 1
$T245620 = 16						; size = 1
__Cat$245597 = 16					; size = 1
$T245595 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ecx

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __First1$[esp]
	mov	ecx, DWORD PTR __Last1$[esp]
	mov	eax, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+4]
	push	edi
	cmp	edx, ecx
	je	SHORT $LN61@Merge_back@2
$LL8@Merge_back@2:

; 2843 : 		else if (_First2 == _Last2)

	cmp	esi, eax
	je	$LN62@Merge_back@2

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	edx, DWORD PTR [eax-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge_back@2

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[esp+8]
	sub	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx

; 2847 : 		else

	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	eax, 8
	jmp	SHORT $LN57@Merge_back@2
$LN2@Merge_back@2:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
$LN57@Merge_back@2:
	mov	edx, DWORD PTR __First1$[esp+8]
	cmp	edx, ecx
	jne	SHORT $LL8@Merge_back@2
$LN61@Merge_back@2:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$245597[esp+8]
	mov	BYTE PTR $T245593[esp+12], 0
	mov	ecx, DWORD PTR $T245593[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T245595[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	push	esi
	call	??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
$LN62@Merge_back@2:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T245618[esp+12], 0
	mov	eax, DWORD PTR $T245618[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$245622[esp+12]
	push	eax
	mov	eax, DWORD PTR $T245620[esp+16]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryHighEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T245707 = -4						; size = 1
$T245713 = -4						; size = 4
$T245709 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T245708 = 48						; size = 1
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryHighEval@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx
	push	ebx
	push	esi
	xor	ebx, ebx
	mov	DWORD PTR $T245713[esp+12], ebx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T245708[esp+8]
	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T245707[esp+12], bl
	mov	eax, DWORD PTR $T245707[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+40]
	mov	eax, DWORD PTR __First2$[esp+40]
	mov	ecx, DWORD PTR __Last1$[esp+40]
	mov	DWORD PTR $T245709[esp+44], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+44]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryHighEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@9:
	mov	eax, esi

; 5160 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryHighEval@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryHighEval@@@Z ; stdext::unchecked_merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T245753 = -4						; size = 1
$T245754 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryHighEval@@@Z PROC ; stdext::unchecked_merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T245754[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245753[esp+8], 0
	mov	eax, DWORD PTR $T245753[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryHighEval@@@Z ENDP ; stdext::unchecked_merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00PAHPAUScoreCityEntry@@@Z ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryLowEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T245771 = -4						; size = 1
$T245777 = -4						; size = 4
$T245773 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T245772 = 48						; size = 1
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryLowEval@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx
	push	ebx
	push	esi
	xor	ebx, ebx
	mov	DWORD PTR $T245777[esp+12], ebx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T245772[esp+8]
	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T245771[esp+12], bl
	mov	eax, DWORD PTR $T245771[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+40]
	mov	eax, DWORD PTR __First2$[esp+40]
	mov	ecx, DWORD PTR __Last1$[esp+40]
	mov	DWORD PTR $T245773[esp+44], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+44]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@0@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@000V10@UScoreCityEntryLowEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@10
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@10:
	mov	eax, esi

; 5160 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryLowEval@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryLowEval@@@Z ; stdext::unchecked_merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T245817 = -4						; size = 1
$T245818 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryLowEval@@@Z PROC ; stdext::unchecked_merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T245818[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245817[esp+8], 0
	mov	eax, DWORD PTR $T245817[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@000V12@UScoreCityEntryLowEval@@@Z ENDP ; stdext::unchecked_merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@5
	pop	esi
$LN9@Uninit_fil@5:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?CreateSpy@CvPlayerEspionage@@QAEXXZ		; CvPlayerEspionage::CreateSpy
EXTRN	?GetStartingSpyRank@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetStartingSpyRank
EXTRN	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ:PROC ; CvPlayer::GetEspionageAI
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?CreateSpy@CvPlayerEspionage@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$3
__ehfuncinfo$?CreateSpy@CvPlayerEspionage@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?CreateSpy@CvPlayerEspionage@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateSpy@CvPlayerEspionage@@QAEXXZ
_TEXT	SEGMENT
_strSummary$222842 = -124				; size = 28
_kNewSpy$ = -124					; size = 28
_strMsg$222846 = -96					; size = 28
_strBuffer$222834 = -68					; size = 28
$T246126 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?CreateSpy@CvPlayerEspionage@@QAEXXZ PROC		; CvPlayerEspionage::CreateSpy, COMDAT
; _this$ = ecx

; 203  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CreateSpy@CvPlayerEspionage@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	esi
	mov	esi, ecx

; 204  : 	// don't create spies if espionage is disabled
; 205  : 	if(GC.getGame().isOption(GAMEOPTION_NO_ESPIONAGE))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222827
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	jne	$LN1@CreateSpy

; 206  : 	{
; 207  : 		return;
; 208  : 	}
; 209  : 
; 210  : 	if (m_pPlayer->GetEspionageAI()->m_iTurnEspionageStarted == -1)

	mov	ecx, DWORD PTR [esi+1296]
	push	ebx
	push	edi
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	or	edi, -1
	cmp	DWORD PTR [eax+736], edi
	jne	SHORT $LN3@CreateSpy

; 211  : 	{
; 212  : 		m_pPlayer->GetEspionageAI()->m_iTurnEspionageStarted = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+1296]
	mov	ebx, eax
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	mov	DWORD PTR [eax+736], ebx
$LN3@CreateSpy:

; 213  : 	}
; 214  : 
; 215  : 	CvEspionageSpy kNewSpy;
; 216  : 	kNewSpy.m_eRank = (CvSpyRank)m_pPlayer->GetStartingSpyRank();

	mov	ecx, DWORD PTR [esi+1296]
	xor	ebx, ebx
	push	ebp
	mov	DWORD PTR _kNewSpy$[esp+144], edi
	mov	DWORD PTR _kNewSpy$[esp+148], edi
	mov	DWORD PTR _kNewSpy$[esp+160], ebx
	mov	BYTE PTR _kNewSpy$[esp+164], bl
	call	?GetStartingSpyRank@CvPlayer@@QBEHXZ	; CvPlayer::GetStartingSpyRank

; 217  : 	kNewSpy.m_eSpyState = SPY_STATE_UNASSIGNED;
; 218  : 	kNewSpy.m_iName = GetNextSpyName();

	mov	ecx, esi
	mov	DWORD PTR _kNewSpy$[esp+152], eax
	mov	DWORD PTR _kNewSpy$[esp+156], ebx
	call	?GetNextSpyName@CvPlayerEspionage@@QAEHXZ ; CvPlayerEspionage::GetNextSpyName
	mov	ebp, eax

; 219  : 	kNewSpy.m_bEvaluateReassignment = true;
; 220  : 
; 221  : 	m_aSpyList.push_back(kNewSpy);

	lea	eax, DWORD PTR _kNewSpy$[esp+140]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _kNewSpy$[esp+144], ebp
	mov	BYTE PTR _kNewSpy$[esp+169], 1
	call	?push_back@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAEIABVCvEspionageSpy@@@Z ; FStaticVector<CvEspionageSpy,8,0,297,0>::push_back

; 222  : 
; 223  : 	CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebx, eax

; 224  : 	if(pNotifications)

	test	ebx, ebx
	je	$LN2@CreateSpy

; 225  : 	{
; 226  : 		const char* szSpyName = m_pPlayer->getCivilizationInfo().getSpyNames(kNewSpy.m_iName);

	mov	ecx, DWORD PTR [esi+1296]
	push	ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	mov	edi, eax

; 227  : 		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_CREATED", szSpyName);

	push	edi
	lea	ecx, DWORD PTR _strBuffer$222834[esp+144]
	push	OFFSET $SG222841
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>

; 228  : 		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_SPY_CREATED", szSpyName);

	push	edi
	lea	edx, DWORD PTR _strSummary$222842[esp+156]
	push	OFFSET $SG222844
	push	edx
	mov	DWORD PTR __$EHRec$[esp+172], 0
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 24					; 00000018H

; 229  : 		pNotifications->Add(NOTIFICATION_SPY_CREATED_ACTIVE_PLAYER, strBuffer, strSummary, -1, -1, 0);

	lea	ecx, DWORD PTR _strSummary$222842[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	0
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$222834[esp+160]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-433658102				; e626e70aH
	mov	ecx, ebx
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 230  : 	}

	lea	ecx, DWORD PTR _strSummary$222842[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$222834[esp+140]
	mov	DWORD PTR __$EHRec$[esp+148], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	or	edi, -1
$LN2@CreateSpy:

; 231  : 
; 232  : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN41@CreateSpy

; 233  : 	{
; 234  : 		CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222846[esp+140]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 235  : 		strMsg.Format("New Spy, %d,", m_aSpyList.size() - 1);

	mov	eax, DWORD PTR [esi+8]
	dec	eax
	push	eax
	lea	eax, DWORD PTR _strMsg$222846[esp+144]
	push	OFFSET $SG222847
	mov	ebx, 2
	push	eax
	mov	DWORD PTR __$EHRec$[esp+160], ebx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 236  : 		strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(kNewSpy.m_iName));

	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR $T246126[esp+144]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$222846[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 3
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T246126[esp+140]
	mov	BYTE PTR __$EHRec$[esp+148], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 237  : 		LogEspionageMsg(strMsg);

	lea	edx, DWORD PTR _strMsg$222846[esp+140]
	push	edx
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 238  : 	}

	lea	ecx, DWORD PTR _strMsg$222846[esp+140]
	mov	DWORD PTR __$EHRec$[esp+148], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN41@CreateSpy:
	pop	ebp
	pop	edi
	pop	ebx
$LN1@CreateSpy:

; 239  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$222834[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$222842[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strMsg$222846[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateSpy@CvPlayerEspionage@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T246126[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CreateSpy@CvPlayerEspionage@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?CreateSpy@CvPlayerEspionage@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateSpy@CvPlayerEspionage@@QAEXXZ ENDP		; CvPlayerEspionage::CreateSpy
PUBLIC	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$3
__ehfuncinfo$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z
_TEXT	SEGMENT
_strMsg$223249 = -68					; size = 28
$T246187 = -40						; size = 28
$T246186 = -40						; size = 28
$T246185 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
_pOldCity$ = 12						; size = 4
_uiSpyIndex$ = 12					; size = 4
_bAsDiplomat$ = 16					; size = 1
?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z PROC ; CvPlayerEspionage::MoveSpyTo, COMDAT
; _this$ = ecx

; 1121 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi
	mov	esi, ecx

; 1122 : 	CvAssertMsg(uiSpyIndex < m_aSpyList.size(), "iSpyIndex is out of bounds");
; 1123 : 	if(uiSpyIndex >= m_aSpyList.size())

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR _uiSpyIndex$[esp+72]
	cmp	edi, eax
	jb	SHORT $LN13@MoveSpyTo
	pop	edi

; 1124 : 	{
; 1125 : 		return false;

	xor	al, al
	pop	esi

; 1210 : 
; 1211 : 	return true;
; 1212 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
$LN13@MoveSpyTo:

; 1126 : 	}
; 1127 : 
; 1128 : 	if(!CanMoveSpyTo(pCity, uiSpyIndex, bAsDiplomat))

	mov	eax, DWORD PTR _bAsDiplomat$[esp+72]
	push	ebp
	mov	ebp, DWORD PTR _pCity$[esp+76]
	push	eax
	push	edi
	push	ebp
	call	?CanMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::CanMoveSpyTo
	test	al, al
	jne	SHORT $LN12@MoveSpyTo
	pop	ebp
	pop	edi
	pop	esi

; 1210 : 
; 1211 : 	return true;
; 1212 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
$LN12@MoveSpyTo:

; 1129 : 	{
; 1130 : 		return false;
; 1131 : 	}
; 1132 : 
; 1133 : 	CvCity* pOldCity = NULL;
; 1134 : 
; 1135 : 	if(IsSpyInCity(uiSpyIndex))

	mov	eax, DWORD PTR [esi+8]
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR _pOldCity$[esp+80], ebx
	cmp	edi, eax
	jae	SHORT $LN171@MoveSpyTo
	mov	edx, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	lea	eax, DWORD PTR [edx+ecx*4]
	or	ecx, -1
	cmp	DWORD PTR [eax+4], ecx
	je	SHORT $LN171@MoveSpyTo
	cmp	DWORD PTR [eax+8], ecx
	je	SHORT $LN171@MoveSpyTo

; 1136 : 	{
; 1137 : 		pOldCity = GetCityWithSpy(uiSpyIndex);

	push	edi
	mov	ecx, esi
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy
	mov	ebx, eax
	mov	DWORD PTR _pOldCity$[esp+80], ebx

; 1138 : 		// trying to move into a city where the spy is already at
; 1139 : 		if(pCity == pOldCity)

	cmp	ebp, ebx

; 1140 : 		{
; 1141 : 			return true;

	je	$LN6@MoveSpyTo

; 1142 : 		}
; 1143 : 
; 1144 : 		if(!ExtractSpyFromCity(uiSpyIndex))

	push	edi
	mov	ecx, esi
	call	?ExtractSpyFromCity@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::ExtractSpyFromCity
	test	al, al

; 1145 : 		{
; 1146 : 			CvAssertMsg(false, "Failed to extract spy");
; 1147 : 			return false;

	je	SHORT $LN175@MoveSpyTo
$LN171@MoveSpyTo:

; 1148 : 		}
; 1149 : 	}
; 1150 : 
; 1151 : 	if(pCity)

	test	ebp, ebp
	je	$LN133@MoveSpyTo

; 1152 : 	{
; 1153 : 		CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, ebp
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 1154 : 		CvAssertMsg(pCityEspionage, "Could not get CvCityEspionage from pCity");
; 1155 : 		if(!pCityEspionage)

	test	eax, eax
	jne	SHORT $LN7@MoveSpyTo
$LN175@MoveSpyTo:
	pop	ebx
	pop	ebp
	pop	edi

; 1156 : 		{
; 1157 : 			return false;

	xor	al, al
	pop	esi

; 1210 : 
; 1211 : 	return true;
; 1212 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
$LN7@MoveSpyTo:

; 1158 : 		}
; 1159 : 
; 1160 : 		m_aSpyList[uiSpyIndex].m_iCityX = pCity->getX();

	mov	edx, DWORD PTR [ebp+96]
	mov	ebx, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [ebx+ecx+4], edx

; 1161 : 		m_aSpyList[uiSpyIndex].m_iCityY = pCity->getY();

	mov	ebx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ebp+108]
	mov	DWORD PTR [ebx+ecx+8], edx

; 1162 : 		pCityEspionage->m_aiSpyAssignment[m_pPlayer->GetID()] = uiSpyIndex;

	mov	edx, DWORD PTR [esi+1296]
	mov	edx, DWORD PTR [edx+44]

; 1163 : 		m_aSpyList[uiSpyIndex].m_eSpyState = SPY_STATE_TRAVELLING;
; 1164 : 		m_aSpyList[uiSpyIndex].m_bIsDiplomat = bAsDiplomat;

	mov	bl, BYTE PTR _bAsDiplomat$[esp+80]
	mov	DWORD PTR [eax+edx*4+4], edi
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+ecx+16], 1
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR [edx+ecx+24], bl

; 1165 : 		int iRate = CalcPerTurn(SPY_STATE_TRAVELLING, pCity, uiSpyIndex);
; 1166 : 		int iGoal = CalcRequired(SPY_STATE_TRAVELLING, pCity, uiSpyIndex);
; 1167 : 		pCityEspionage->SetActivity(m_pPlayer->GetID(), 0, iRate, iGoal);

	mov	ecx, DWORD PTR [esi+1296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	ebx, DWORD PTR _pOldCity$[esp+80]
	mov	edx, 1
	mov	DWORD PTR [eax+ecx*4+92], 0
	mov	DWORD PTR [eax+ecx*4+180], edx
	mov	DWORD PTR [eax+ecx*4+268], edx
$LN133@MoveSpyTo:

; 1168 : 	}
; 1169 : 
; 1170 : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@MoveSpyTo

; 1171 : 	{
; 1172 : 		CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223249[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1173 : 		strMsg.Format("Moving spy, %d,", uiSpyIndex);

	push	edi
	lea	edx, DWORD PTR _strMsg$223249[esp+88]
	push	OFFSET $SG223250
	push	edx
	mov	DWORD PTR __$EHRec$[esp+104], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1174 : 		strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName));

	mov	ecx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	mov	edx, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	eax, DWORD PTR $T246185[esp+88]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T246185[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1175 : 		strMsg += ",";

	push	OFFSET $SG223252
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1176 : 		if(pOldCity)

	test	ebx, ebx
	je	SHORT $LN5@MoveSpyTo

; 1177 : 		{
; 1178 : 			strMsg += GET_PLAYER(pOldCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [ebx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1179 : 			strMsg += ",";

	push	OFFSET $SG223254
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1180 : 			strMsg += pOldCity->getName();

	lea	ecx, DWORD PTR $T246186[esp+84]
	push	ecx
	mov	ecx, ebx
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 2
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T246186[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1181 : 		}
; 1182 : 		else

	jmp	SHORT $LN4@MoveSpyTo
$LN5@MoveSpyTo:

; 1183 : 		{
; 1184 : 			strMsg += "Unassigned";

	push	OFFSET $SG223257
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1185 : 			strMsg += ",";

	push	OFFSET $SG223258
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN4@MoveSpyTo:

; 1186 : 		}
; 1187 : 		strMsg += ",";

	push	OFFSET $SG223259
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1188 : 
; 1189 : 		if(pCity)

	test	ebp, ebp
	je	SHORT $LN3@MoveSpyTo

; 1190 : 		{
; 1191 : 			strMsg += GET_PLAYER(pCity->getOwner()).getCivilizationShortDescription();

	mov	eax, DWORD PTR [ebp+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1192 : 			strMsg += ",";

	push	OFFSET $SG223261
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1193 : 			strMsg += pCity->getName();

	lea	edx, DWORD PTR $T246187[esp+84]
	push	edx
	mov	ecx, ebp
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 3
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T246187[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1194 : 		}
; 1195 : 		else

	jmp	SHORT $LN2@MoveSpyTo
$LN3@MoveSpyTo:

; 1196 : 		{
; 1197 : 			strMsg += "Unassigned";

	push	OFFSET $SG223264
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1198 : 			strMsg += ",";

	push	OFFSET $SG223265
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@MoveSpyTo:

; 1199 : 		}
; 1200 : 		strMsg += ",";

	push	OFFSET $SG223266
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1201 : 
; 1202 : 		if (bAsDiplomat)

	cmp	BYTE PTR _bAsDiplomat$[esp+80], 0
	je	SHORT $LN1@MoveSpyTo

; 1203 : 		{
; 1204 : 			strMsg += "Diplomat";

	push	OFFSET $SG223268
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@MoveSpyTo:

; 1205 : 		}
; 1206 : 		strMsg += ",";

	push	OFFSET $SG223269
	lea	ecx, DWORD PTR _strMsg$223249[esp+88]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1207 : 
; 1208 : 		LogEspionageMsg(strMsg);

	lea	eax, DWORD PTR _strMsg$223249[esp+84]
	push	eax
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 1209 : 	}

	lea	ecx, DWORD PTR _strMsg$223249[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@MoveSpyTo:

; 1210 : 
; 1211 : 	return true;
; 1212 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	ebx
	pop	ebp
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$0:
	lea	ecx, DWORD PTR _strMsg$223249[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$1:
	lea	ecx, DWORD PTR $T246185[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$2:
	lea	ecx, DWORD PTR $T246186[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z$3:
	lea	ecx, DWORD PTR $T246187[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ENDP ; CvPlayerEspionage::MoveSpyTo
PUBLIC	?UpdateSpies@CvPlayerEspionage@@QAEXXZ		; CvPlayerEspionage::UpdateSpies
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateSpies@CvPlayerEspionage@@QAEXXZ
_TEXT	SEGMENT
?UpdateSpies@CvPlayerEspionage@@QAEXXZ PROC		; CvPlayerEspionage::UpdateSpies, COMDAT
; _this$ = ecx

; 1289 : {

	push	esi
	push	edi
	mov	esi, ecx

; 1290 : 	for(uint uiSpy = 0; uiSpy < m_aSpyList.size(); uiSpy++)

	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jbe	SHORT $LN2@UpdateSpie
	npad	5
$LL4@UpdateSpie:

; 1291 : 	{
; 1292 : 		CvCity* pCity = GetCityWithSpy(uiSpy);

	push	edi
	mov	ecx, esi
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 1293 : 		if (pCity)

	test	eax, eax
	je	SHORT $LN3@UpdateSpie

; 1294 : 		{
; 1295 : 			UpdateCity(pCity);

	push	eax
	mov	ecx, esi
	call	?UpdateCity@CvPlayerEspionage@@QAEXPAVCvCity@@@Z ; CvPlayerEspionage::UpdateCity
$LN3@UpdateSpie:
	inc	edi
	cmp	edi, DWORD PTR [esi+8]
	jb	SHORT $LL4@UpdateSpie
$LN2@UpdateSpie:
	pop	edi
	pop	esi

; 1296 : 		}
; 1297 : 	}
; 1298 : }

	ret	0
?UpdateSpies@CvPlayerEspionage@@QAEXXZ ENDP		; CvPlayerEspionage::UpdateSpies
_TEXT	ENDS
PUBLIC	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ; CvPlayerEspionage::BuildStealableTechList
EXTRN	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z:PROC ; CvPlayerTechs::GetResearchCost
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetNumTechs@CvTechXMLEntries@@QAEHXZ:PROC	; CvTechXMLEntries::GetNumTechs
EXTRN	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ:PROC ; CvPlayerTechs::GetTechs
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
; Function compile flags: /Ogtpy
;	COMDAT ?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iMaxTechCost$ = -16					; size = 4
_pMyPlayerTechs$ = -12					; size = 4
tv295 = -8						; size = 4
_pOtherPlayerTechs$ = -4				; size = 4
_ePlayer$ = 8						; size = 4
?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z PROC ; CvPlayerEspionage::BuildStealableTechList, COMDAT
; _this$ = ecx

; 2272 : {

	sub	esp, 16					; 00000010H
	push	ebp
	push	esi

; 2273 : 	CvAssertMsg((uint)ePlayer < m_aaPlayerStealableTechList.size(), "ePlayer out of bounds");
; 2274 : 	if((uint)ePlayer >= m_aaPlayerStealableTechList.size())

	mov	esi, DWORD PTR _ePlayer$[esp+20]
	mov	ebp, ecx
	cmp	esi, DWORD PTR [ebp+268]
	jae	$LN9@BuildSteal

; 2275 : 	{
; 2276 : 		return;
; 2277 : 	}
; 2278 : 
; 2279 : 	m_aaPlayerStealableTechList[ePlayer].clear();

	mov	eax, DWORD PTR [ebp+264]
	push	ebx

; 2280 : 
; 2281 : 	if(!GET_PLAYER(ePlayer).isAlive())

	mov	ebx, esi
	lea	ecx, DWORD PTR [esi+esi*4]
	imul	ebx, 63236				; 0000f704H
	add	ecx, ecx
	add	ecx, ecx
	add	eax, ecx
	push	edi
	xor	edi, edi
	mov	DWORD PTR [eax+4], edi
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [ebx+eax+2256], 0
	mov	DWORD PTR tv295[esp+32], ecx
	je	$LN61@BuildSteal

; 2282 : 	{
; 2283 : 		return;
; 2284 : 	}
; 2285 : 
; 2286 : 	int iMaxTechCost = -1;
; 2287 : 
; 2288 : 	CvPlayerTechs* pMyPlayerTechs = m_pPlayer->GetPlayerTechs();

	mov	ecx, DWORD PTR [ebp+1296]
	mov	DWORD PTR _iMaxTechCost$[esp+32], -1
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs

; 2289 : 	CvPlayerTechs* pOtherPlayerTechs = GET_PLAYER(ePlayer).GetPlayerTechs();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebx
	mov	DWORD PTR _pMyPlayerTechs$[esp+32], eax
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs

; 2290 : #ifdef AUI_WARNING_FIXES
; 2291 : 	for (uint iTechLoop = 0; iTechLoop < pOtherPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 2292 : #else
; 2293 : 	for(int iTechLoop = 0; iTechLoop < pOtherPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, eax
	mov	DWORD PTR _pOtherPlayerTechs$[esp+32], eax
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	$LN4@BuildSteal
	npad	6
$LL60@BuildSteal:

; 2294 : #endif
; 2295 : 	{
; 2296 : 		TechTypes eTech = (TechTypes)iTechLoop;
; 2297 : 
; 2298 : 		// Does the other player already have this tech?
; 2299 : 		if(!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ebx+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN37@BuildSteal
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN38@BuildSteal
$LN37@BuildSteal:
	or	eax, -1
$LN38@BuildSteal:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN5@BuildSteal

; 2300 : 		{
; 2301 : 			continue;
; 2302 : 		}
; 2303 : 
; 2304 : 		// can we not research this tech?
; 2305 : 		if(!pMyPlayerTechs->CanResearch(eTech))

	mov	ecx, DWORD PTR _pMyPlayerTechs$[esp+32]
	push	0
	push	edi
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN5@BuildSteal

; 2306 : 		{
; 2307 : 			continue;
; 2308 : 		}
; 2309 : 
; 2310 : 		// can it be stolen? ~EAP
; 2311 : 		//CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
; 2312 : 		//if (pkTechInfo->IsDisableTechSteal())
; 2313 : 		//{
; 2314 : 		//	continue;
; 2315 : 		//}
; 2316 : 
; 2317 : 		// add to list!
; 2318 : 		m_aaPlayerStealableTechList[ePlayer].push_back(eTech);

	mov	esi, DWORD PTR [ebp+264]
	add	esi, DWORD PTR tv295[esp+32]
	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+16], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN46@BuildSteal
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum TechTypes,1,0,297,0>::GrowSize
$LN46@BuildSteal:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN49@BuildSteal
	mov	DWORD PTR [eax], edi
$LN49@BuildSteal:
	inc	DWORD PTR [esi+4]

; 2319 : 
; 2320 : 		// try to find the most expensive tech that can be researched
; 2321 : 		int iTechCost = m_pPlayer->GetPlayerTechs()->GetResearchCost(eTech) * 100;

	mov	ecx, DWORD PTR [ebp+1296]
	push	edi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	imul	eax, 100				; 00000064H

; 2322 : 		if(iTechCost > iMaxTechCost)

	cmp	eax, DWORD PTR _iMaxTechCost$[esp+32]
	jle	SHORT $LN5@BuildSteal

; 2323 : 		{
; 2324 : 			iMaxTechCost = iTechCost;

	mov	DWORD PTR _iMaxTechCost$[esp+32], eax
$LN5@BuildSteal:

; 2290 : #ifdef AUI_WARNING_FIXES
; 2291 : 	for (uint iTechLoop = 0; iTechLoop < pOtherPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 2292 : #else
; 2293 : 	for(int iTechLoop = 0; iTechLoop < pOtherPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, DWORD PTR _pOtherPlayerTechs$[esp+32]
	inc	edi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	edi, eax
	jl	$LL60@BuildSteal
	mov	esi, DWORD PTR _ePlayer$[esp+28]
$LN4@BuildSteal:

; 2325 : 		}
; 2326 : 	}
; 2327 : 
; 2328 : 	m_aiMaxTechCost[ePlayer] = iMaxTechCost;

	mov	edx, DWORD PTR _iMaxTechCost$[esp+32]
	mov	DWORD PTR [ebp+esi*4+824], edx
$LN61@BuildSteal:
	pop	edi
	pop	ebx
$LN9@BuildSteal:
	pop	esi
	pop	ebp

; 2329 : }

	add	esp, 16					; 00000010H
	ret	4
?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlayerEspionage::BuildStealableTechList
_TEXT	ENDS
PUBLIC	?Init@CvEspionageAI@@QAEXPAVCvPlayer@@@Z	; CvEspionageAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvEspionageAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvEspionageAI@@QAEXPAVCvPlayer@@@Z PROC		; CvEspionageAI::Init, COMDAT
; _this$ = ecx

; 4228 : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	mov	DWORD PTR [ecx], eax

; 4229 : 
; 4230 : 	Reset();

	call	?Reset@CvEspionageAI@@QAEXXZ		; CvEspionageAI::Reset

; 4231 : }

	ret	4
?Init@CvEspionageAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvEspionageAI::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvEspionageAI@@QAEXXZ			; CvEspionageAI::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvEspionageAI@@QAEXXZ PROC			; CvEspionageAI::Uninit, COMDAT
; _this$ = ecx

; 4236 : 	Reset();

	jmp	?Reset@CvEspionageAI@@QAEXXZ		; CvEspionageAI::Reset
?Uninit@CvEspionageAI@@QAEXXZ ENDP			; CvEspionageAI::Uninit
_TEXT	ENDS
PUBLIC	?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ	; CvEspionageAI::UpdateCivOutOfTechTurn
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ$0
__ehfuncinfo$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T246685 = -44						; size = 4
_strMsg$225521 = -40					; size = 28
__$EHRec$ = -12						; size = 12
?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ PROC	; CvEspionageAI::UpdateCivOutOfTechTurn, COMDAT
; _this$ = ecx

; 4650 : {

	push	-1
	push	__ehhandler$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+60], ecx

; 4651 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ecx]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage

; 4652 : 
; 4653 : 	// determine which civs have run out of techs to steal
; 4654 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	esi, esi
	xor	ebx, ebx
	mov	edi, eax
	xor	ebp, ebp
	npad	1
$LL7@UpdateCivO:

; 4655 : 	{
; 4656 : 		PlayerTypes eOtherPlayer = (PlayerTypes)ui;
; 4657 : 
; 4658 : 		if(m_pPlayer->GetID() == eOtherPlayer)

	mov	eax, DWORD PTR _this$[esp+64]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+44], esi
	je	$LN6@UpdateCivO

; 4659 : 		{
; 4660 : 			continue;
; 4661 : 		}
; 4662 : 
; 4663 : 		// if surveillance has not been established, continue
; 4664 : 		if(!pEspionage->IsAnySurveillanceEstablished(eOtherPlayer))

	push	esi
	mov	ecx, edi
	call	?IsAnySurveillanceEstablished@CvPlayerEspionage@@QAE_NW4PlayerTypes@@@Z ; CvPlayerEspionage::IsAnySurveillanceEstablished
	test	al, al
	je	$LN6@UpdateCivO

; 4665 : 		{
; 4666 : 			continue;
; 4667 : 		}
; 4668 : 
; 4669 : 		pEspionage->BuildStealableTechList(eOtherPlayer);

	push	esi
	mov	ecx, edi
	call	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ; CvPlayerEspionage::BuildStealableTechList

; 4670 : 		if(pEspionage->m_aaPlayerStealableTechList[eOtherPlayer].size() > 0)

	mov	edx, DWORD PTR [edi+264]
	cmp	DWORD PTR [edx+ebp+4], 0
	ja	$LN6@UpdateCivO
	mov	eax, DWORD PTR _this$[esp+64]
	mov	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [ecx+esi*4]

; 4671 : 		{
; 4672 : 			continue;
; 4673 : 		}
; 4674 : 		m_aiCivOutOfTechTurn[eOtherPlayer] = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T246685[esp+64], edx
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T246685[esp+64]
	mov	DWORD PTR [ecx], eax

; 4675 : 		if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@UpdateCivO

; 4676 : 		{
; 4677 : 			CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225521[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4678 : 			strMsg.Format("AI no more tech to steal,");

	lea	edx, DWORD PTR _strMsg$225521[esp+64]
	push	OFFSET $SG225522
	push	edx
	mov	DWORD PTR __$EHRec$[esp+80], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4679 : 			strMsg += ",";

	push	OFFSET $SG225523
	lea	ecx, DWORD PTR _strMsg$225521[esp+68]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4680 : 			strMsg += ",";

	push	OFFSET $SG225524
	lea	ecx, DWORD PTR _strMsg$225521[esp+68]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4681 : 			strMsg += GET_PLAYER(eOtherPlayer).getCivilizationShortDescription();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strMsg$225521[esp+68]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4682 : 			strMsg += ",";

	push	OFFSET $SG225525
	lea	ecx, DWORD PTR _strMsg$225521[esp+68]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 4683 : 			pEspionage->LogEspionageMsg(strMsg);

	lea	ecx, DWORD PTR _strMsg$225521[esp+64]
	push	ecx
	mov	ecx, edi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 4684 : 		}

	lea	ecx, DWORD PTR _strMsg$225521[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@UpdateCivO:
	add	ebp, 20					; 00000014H
	inc	esi
	add	ebx, 63236				; 0000f704H
	cmp	ebp, 440				; 000001b8H
	jb	$LL7@UpdateCivO

; 4685 : 	}
; 4686 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMsg$225521[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ ENDP	; CvEspionageAI::UpdateCivOutOfTechTurn
PUBLIC	?clear@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ PROC ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	ebx
	mov	ebx, ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	mov	esi, DWORD PTR [ebx]
	test	eax, eax
	jbe	SHORT $LN30@clear
	push	edi
	mov	edi, eax
$LL5@clear:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN14@clear
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN14@clear:
	add	esi, 20					; 00000014H
	sub	edi, 1
	jne	SHORT $LL5@clear
	pop	edi
$LN30@clear:
	pop	esi

; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ebx+4], 0
	pop	ebx

; 123  : 	};

	ret	0
?clear@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ ENDP ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::clear
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@2
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@2:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@2:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::clear
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z PROC ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, DWORD PTR _uiNumElements$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pVal$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?Destroy@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::Destroy

; 811  : 		if( pVal != (T*)m_aData )

	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN1@Free@4

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free@4:
	pop	edi
	pop	esi

; 813  : 	};

	ret	8
?Free@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ENDP ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU3@IABU3@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T246990 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$246993 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU3@IABU3@@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$246993[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T246990[esp+12], 0
	mov	eax, DWORD PTR $T246990[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU3@IABU3@@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU3@IABU3@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T247007 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$247010 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU3@IABU3@@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$247010[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T247007[esp+12], 0
	mov	eax, DWORD PTR $T247007[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*4]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU3@IABU3@@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU3@IABU3@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T247025 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$247028 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU3@IABU3@@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$247028[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T247025[esp+12], 0
	mov	eax, DWORD PTR $T247025[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU3@IABU3@@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXPAUHeistLocation@@0@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXPAUHeistLocation@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXPAUHeistLocation@@0@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXPAUHeistLocation@@0@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXPAUSpyNotificationMessage@@0@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXPAUSpyNotificationMessage@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXPAUSpyNotificationMessage@@0@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXPAUSpyNotificationMessage@@0@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXPAUScoreCityEntry@@0@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXPAUScoreCityEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXPAUScoreCityEntry@@0@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXPAUScoreCityEntry@@0@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@11
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@11:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@11
	pop	esi
$LN13@unchecked_@11:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$7
__unwindtable$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T247241 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$247251 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	push	edi
	mov	edi, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LL6@Uninit_fil@6:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ebx, ebx
	jbe	$LN4@Uninit_fil@6

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$247251[ebp], esi
	mov	DWORD PTR $T247241[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN18@Uninit_fil@6
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], ecx
	mov	edx, DWORD PTR [edi+32]
	lea	eax, DWORD PTR [edi+36]
	lea	ecx, DWORD PTR [esi+36]
	push	eax
	mov	DWORD PTR [esi+32], edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	cl, BYTE PTR [edi+64]
	mov	BYTE PTR [esi+64], cl
$LN18@Uninit_fil@6:
	dec	ebx
	add	esi, 68					; 00000044H
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@6
__catch$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@6
	npad	8
$LL3@Uninit_fil@6:
	lea	ecx, DWORD PTR [esi+36]

; 407  : 		_Al.destroy(_Next);

	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@6
$LN1@Uninit_fil@6:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN48@Uninit_fil@6:
$LN4@Uninit_fil@6:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@Uninit_fil@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$247251[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247241[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
PUBLIC	??$_Unchecked_uninitialized_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z
_TEXT	SEGMENT
$T247336 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247339 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$247339[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247336[esp+4], 0
	mov	eax, DWORD PTR $T247336[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@stdext@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z
_TEXT	SEGMENT
$T247373 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247376 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$247376[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247373[esp+4], 0
	mov	eax, DWORD PTR $T247373[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<IntrigueNotificationMessage> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
	npad	2
$LL3@Destroy_ra:
	lea	ecx, DWORD PTR [esi+36]

; 234  : 		_Al.destroy(_First);

	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z
_TEXT	SEGMENT
$T247456 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247459 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$247459[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247456[esp+4], 0
	mov	eax, DWORD PTR $T247456[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@stdext@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z ; std::_Insertion_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,ScoreCityEntry>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z ; std::_Insertion_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,ScoreCityEntry>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z ; stdext::unchecked_uninitialized_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z
_TEXT	SEGMENT
$T247479 = -4						; size = 1
__Cat$247483 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247479[esp+4], 0
	mov	eax, DWORD PTR $T247479[esp+4]
	mov	ecx, DWORD PTR __Cat$247483[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryHighEval@@@Z ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T247488 = -4						; size = 1
$T247489 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryHighEval@@@Z PROC ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T247489[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T247488[esp+8], 0
	mov	eax, DWORD PTR $T247488[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@11UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryHighEval@@@Z ENDP ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T247497 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T247497[esp+8], 0
	mov	eax, DWORD PTR $T247497[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5229 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T247506 = -20						; size = 20
$T247504 = -20						; size = 20
$T247502 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T247501 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T247505 = 40						; size = 4
$T247503 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __First$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	ebp, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	ebp, DWORD PTR __Count$[esp+32]
	jg	SHORT $LN3@Chunked_me
	npad	6
$LL5@Chunked_me:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [esi+edi*8]
	mov	DWORD PTR $T247501[esp+56], esp
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+76]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+68]
	push	eax
	lea	ecx, DWORD PTR $T247502[esp+76]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryHighEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T247502[esp+80]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+48], edx
	cmp	eax, ebx
	je	SHORT $LN49@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Chunked_me:
	mov	eax, DWORD PTR __Count$[esp+32]
	sub	eax, ebp
	cmp	eax, ebp

; 3443 : 		_First = _Mid2;

	mov	DWORD PTR __First$[esp+32], esi
	mov	DWORD PTR __Count$[esp+32], eax
	jge	SHORT $LL5@Chunked_me
$LN3@Chunked_me:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	DWORD PTR __Count$[esp+32], edi
	jg	SHORT $LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+52]
	mov	eax, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T247503[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T247504[esp+64]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	add	esp, 32					; 00000020H

; 3448 : 	else

	jmp	SHORT $LN111@Chunked_me
$LN2@Chunked_me:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+32]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	DWORD PTR $T247505[esp+56], esp
	push	eax
	lea	ecx, DWORD PTR [esi+edi*8]
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+68]
	push	ecx
	lea	edx, DWORD PTR $T247506[esp+76]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryHighEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryHighEval>
	add	esp, 44					; 0000002cH
$LN111@Chunked_me:
	mov	eax, DWORD PTR $T247506[esp+36]
	cmp	eax, ebx
	je	SHORT $LN87@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Chunked_me:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN97@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T247736 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T247782 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T247889 = 24						; size = 1
$T247890 = 24						; size = 1
$T247783 = 24						; size = 1
$T247738 = 24						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ecx

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	eax, DWORD PTR __First$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+12]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, ecx
	jg	SHORT $LN3@Chunked_me@2
	push	ebx
	npad	4
$LL58@Chunked_me@2:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T247782[esp+16], 0
	mov	ebx, DWORD PTR $T247782[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T247783[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+24]
	push	ebx
	lea	ecx, DWORD PTR [eax+edi*8]
	push	edx
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	push	ecx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T247736[esp+52]
	push	eax
	call	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
	mov	ecx, DWORD PTR __Count$[esp+52]
	mov	edx, DWORD PTR $T247736[esp+56]
	sub	ecx, ebp
	add	esp, 36					; 00000024H
	cmp	ecx, ebp
	mov	DWORD PTR __Dest$[esp+16], edx

; 3443 : 		_First = _Mid2;

	mov	eax, esi
	mov	DWORD PTR __Count$[esp+16], ecx
	jge	SHORT $LL58@Chunked_me@2
	pop	ebx
$LN3@Chunked_me@2:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	ecx, edi
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+12]
	cmp	eax, ecx
	je	SHORT $LN49@Chunked_me@2
$LL32@Chunked_me@2:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	add	eax, 8
	add	edx, 8
	cmp	eax, ecx
	jne	SHORT $LL32@Chunked_me@2
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@2:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	BYTE PTR $T247889[esp+12], 0
	mov	ecx, DWORD PTR $T247889[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T247890[esp+16]
	push	ecx
	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	lea	edi, DWORD PTR [eax+edi*8]
	push	edi
	push	edi
	push	eax
	lea	eax, DWORD PTR $T247738[esp+44]
	push	eax
	call	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryHighEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
$LN49@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00@Z ; std::rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00@Z PROC ; std::rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN14@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN14@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00PAHPAUScoreCityEntry@@@Z ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>
	add	esp, 20					; 00000014H
$LN14@rotate:

; 1721 : 	}

	ret	0
??$rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00@Z ENDP ; std::rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> > >
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T247954 = -20						; size = 20
$T247952 = -20						; size = 20
$T247950 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T247949 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T247953 = 40						; size = 4
$T247951 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __First$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	ebp, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	ebp, DWORD PTR __Count$[esp+32]
	jg	SHORT $LN3@Chunked_me@3
	npad	6
$LL5@Chunked_me@3:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [esi+edi*8]
	mov	DWORD PTR $T247949[esp+56], esp
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+76]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+68]
	push	eax
	lea	ecx, DWORD PTR $T247950[esp+76]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryLowEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T247950[esp+80]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+48], edx
	cmp	eax, ebx
	je	SHORT $LN49@Chunked_me@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Chunked_me@3:
	mov	eax, DWORD PTR __Count$[esp+32]
	sub	eax, ebp
	cmp	eax, ebp

; 3443 : 		_First = _Mid2;

	mov	DWORD PTR __First$[esp+32], esi
	mov	DWORD PTR __Count$[esp+32], eax
	jge	SHORT $LL5@Chunked_me@3
$LN3@Chunked_me@3:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	DWORD PTR __Count$[esp+32], edi
	jg	SHORT $LN2@Chunked_me@3

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+52]
	mov	eax, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T247951[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T247952[esp+64]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	add	esp, 32					; 00000020H

; 3448 : 	else

	jmp	SHORT $LN111@Chunked_me@3
$LN2@Chunked_me@3:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+32]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	DWORD PTR $T247953[esp+56], esp
	push	eax
	lea	ecx, DWORD PTR [esi+edi*8]
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+68]
	push	ecx
	lea	edx, DWORD PTR $T247954[esp+76]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@V?$_Temp_iterator@UScoreCityEntry@@@2@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@000V12@UScoreCityEntryLowEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,ScoreCityEntryLowEval>
	add	esp, 44					; 0000002cH
$LN111@Chunked_me@3:
	mov	eax, DWORD PTR $T247954[esp+36]
	cmp	eax, ebx
	je	SHORT $LN87@Chunked_me@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Chunked_me@3:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN97@Chunked_me@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@Chunked_me@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T248184 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T248229 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T248338 = 24						; size = 1
$T248339 = 24						; size = 1
$T248230 = 24						; size = 1
$T248186 = 24						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ecx

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	eax, DWORD PTR __First$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+12]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, ecx
	jg	SHORT $LN3@Chunked_me@4
	push	ebx
	npad	4
$LL58@Chunked_me@4:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T248229[esp+16], 0
	mov	ebx, DWORD PTR $T248229[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T248230[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+24]
	push	ebx
	lea	ecx, DWORD PTR [eax+edi*8]
	push	edx
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	push	ecx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T248184[esp+52]
	push	eax
	call	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
	mov	ecx, DWORD PTR __Count$[esp+52]
	mov	edx, DWORD PTR $T248184[esp+56]
	sub	ecx, ebp
	add	esp, 36					; 00000024H
	cmp	ecx, ebp
	mov	DWORD PTR __Dest$[esp+16], edx

; 3443 : 		_First = _Mid2;

	mov	eax, esi
	mov	DWORD PTR __Count$[esp+16], ecx
	jge	SHORT $LL58@Chunked_me@4
	pop	ebx
$LN3@Chunked_me@4:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	ecx, edi
	jg	SHORT $LN2@Chunked_me@4

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+12]
	cmp	eax, ecx
	je	SHORT $LN49@Chunked_me@4
$LL32@Chunked_me@4:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	add	eax, 8
	add	edx, 8
	cmp	eax, ecx
	jne	SHORT $LL32@Chunked_me@4
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@4:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	BYTE PTR $T248338[esp+12], 0
	mov	ecx, DWORD PTR $T248338[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T248339[esp+16]
	push	ecx
	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	lea	edi, DWORD PTR [eax+edi*8]
	push	edi
	push	edi
	push	eax
	lea	eax, DWORD PTR $T248186[esp+44]
	push	eax
	call	??$_Merge@PAUScoreCityEntry@@PAU1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@000V10@UScoreCityEntryLowEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<ScoreCityEntry *,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
$LN49@Chunked_me@4:
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear@3
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear@3
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear@3:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear@3:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@12
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@12:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@12
	pop	esi
$LN13@unchecked_@12:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??1CvEspionageAI@@QAE@XZ			; CvEspionageAI::~CvEspionageAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvEspionageAI@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??1CvEspionageAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvEspionageAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEspionageAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvEspionageAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvEspionageAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvEspionageAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvEspionageAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvEspionageAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvEspionageAI@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvEspionageAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEspionageAI@@QAE@XZ PROC				; CvEspionageAI::~CvEspionageAI, COMDAT
; _this$ = ecx

; 4221 : {

	push	-1
	push	__ehhandler$??1CvEspionageAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR __$EHRec$[esp+28], 6

; 4222 : 	Uninit();

	call	?Reset@CvEspionageAI@@QAEXXZ		; CvEspionageAI::Reset

; 4223 : }

	mov	eax, DWORD PTR [esi+628]
	lea	ecx, DWORD PTR [esi+640]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	cmp	eax, ecx
	je	SHORT $LN14@CvEspionag
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN14@CvEspionag:
	mov	eax, DWORD PTR [esi+524]
	lea	edx, DWORD PTR [esi+536]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	cmp	eax, edx
	je	SHORT $LN28@CvEspionag
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN28@CvEspionag:
	mov	eax, DWORD PTR [esi+420]
	lea	ecx, DWORD PTR [esi+432]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	cmp	eax, ecx
	je	SHORT $LN42@CvEspionag
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN42@CvEspionag:
	mov	eax, DWORD PTR [esi+316]
	lea	edx, DWORD PTR [esi+328]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	cmp	eax, edx
	je	SHORT $LN56@CvEspionag
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN56@CvEspionag:
	mov	eax, DWORD PTR [esi+212]
	lea	ecx, DWORD PTR [esi+224]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	cmp	eax, ecx
	je	SHORT $LN70@CvEspionag
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN70@CvEspionag:
	mov	eax, DWORD PTR [esi+108]
	lea	edx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	cmp	eax, edx
	je	SHORT $LN84@CvEspionag
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN84@CvEspionag:
	mov	eax, DWORD PTR [esi+4]
	add	esi, 16					; 00000010H
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	esi
	je	SHORT $LN98@CvEspionag
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN98@CvEspionag:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEspionageAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??1CvEspionageAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??1CvEspionageAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??1CvEspionageAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??1CvEspionageAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 420				; 000001a4H
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??1CvEspionageAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??1CvEspionageAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__ehhandler$??1CvEspionageAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvEspionageAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEspionageAI@@QAE@XZ ENDP				; CvEspionageAI::~CvEspionageAI
PUBLIC	??1?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	esi
	mov	esi, ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	push	eax
	push	edi
	call	?Destroy@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN3@FStaticVec@5
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@FStaticVec@5:
	pop	edi
	pop	esi

; 619  : 	};

	ret	0
??1?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::GrowSize
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_pTemp$ = -20						; size = 4
$T249025 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T249156 = 8						; size = 4
_i$227353 = 8						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN58@GrowSize@4
	mov	DWORD PTR [esi+8], 1
$LN58@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+28]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@4
$LL8@GrowSize@4:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN52@GrowSize@4

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@4

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@4
$LN52@GrowSize@4:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@4:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 22					; 00000016H
	jbe	SHORT $LN16@GrowSize@4
	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*4]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@GrowSize@4
$LN16@GrowSize@4:
	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 22			; 00000016H
$LN15@GrowSize@4:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	edi, edi
	push	ebp
	mov	DWORD PTR _pTemp$[esp+36], ebx
	mov	DWORD PTR _i$227353[esp+32], edi
	cmp	DWORD PTR [esi+4], edi
	jbe	SHORT $LN1@GrowSize@4
	or	ebp, -1
$LL3@GrowSize@4:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	lea	eax, DWORD PTR [edi+edi*4]
	add	eax, eax
	add	eax, eax
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR $T249025[esp+36], ecx
	mov	DWORD PTR __$EHRec$[esp+44], 0
	test	ecx, ecx
	je	SHORT $LN12@GrowSize@4
	mov	edx, DWORD PTR [esi]
	add	edx, eax
	push	edx
	call	??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>
$LN12@GrowSize@4:
	inc	edi
	mov	DWORD PTR __$EHRec$[esp+44], ebp
	mov	DWORD PTR _i$227353[esp+32], edi
	cmp	edi, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize@4
$LN1@GrowSize@4:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T249156[esp+32], ecx
	test	eax, eax
	jbe	SHORT $LN25@GrowSize@4
	mov	edi, ecx
	mov	ebp, eax
$LL27@GrowSize@4:
	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [edi+12]
	cmp	eax, edx
	je	SHORT $LN36@GrowSize@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR $T249156[esp+36]
	add	esp, 4
$LN36@GrowSize@4:
	add	edi, 20					; 00000014H
	sub	ebp, 1
	jne	SHORT $LL27@GrowSize@4
$LN25@GrowSize@4:
	lea	eax, DWORD PTR [esi+12]
	pop	ebp
	cmp	ecx, eax
	je	SHORT $LN57@GrowSize@4
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN57@GrowSize@4:

; 769  : 		m_pData = pTemp;
; 770  : 
; 771  : 		m_bIsResized = true;
; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR [esi], ebx
	pop	edi
	mov	BYTE PTR [esi+452], 1
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$227353[ebp-4]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249025[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::GrowSize
PUBLIC	?erase@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@0@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@0@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@3
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@3
	push	ebx
	npad	4
$LL28@erase@3:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	add	edx, 8
	add	esi, 8
	cmp	edx, edi
	jne	SHORT $LL28@erase@3
	pop	ebx
$LN26@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@3:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@0@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXXZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXXZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@0@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@0@Z
_TEXT	SEGMENT
$T249323 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$249327 = 12					; size = 1
$T249325 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@0@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [edi], eax
	cmp	eax, edx
	je	SHORT $LN26@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	BYTE PTR $T249323[esp+8], 0
	mov	ebx, DWORD PTR $T249323[esp+8]
	push	ebx
	mov	ebx, DWORD PTR __Cat$249327[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T249325[esp+16]
	push	ebx
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], eax
	pop	ebx
$LN26@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@0@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXXZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXXZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXXZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$228066 = 16					; size = 4
__Tmp$228056 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$228056[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$228056[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$228056[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$228066[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z
_TEXT	SEGMENT
$T249544 = -4						; size = 1
__Cat$249548 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T249544[esp+4], 0
	mov	eax, DWORD PTR $T249544[esp+4]
	mov	ecx, DWORD PTR __Cat$249548[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUHeistLocation@@@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU2@00@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Umove<HeistLocation *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUHeistLocation@@@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU2@00@Z
_TEXT	SEGMENT
$T249599 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$249602 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUHeistLocation@@@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU2@00@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Umove<HeistLocation *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$249602[esp]
	mov	BYTE PTR $T249599[esp+4], 0
	mov	eax, DWORD PTR $T249599[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUHeistLocation@@@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU2@00@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Umove<HeistLocation *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUSpyNotificationMessage@@@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU2@00@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Umove<SpyNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUSpyNotificationMessage@@@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU2@00@Z
_TEXT	SEGMENT
$T249654 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$249657 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUSpyNotificationMessage@@@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU2@00@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Umove<SpyNotificationMessage *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$249657[esp]
	mov	BYTE PTR $T249654[esp+4], 0
	mov	eax, DWORD PTR $T249654[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUSpyNotificationMessage@@@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU2@00@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Umove<SpyNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@@Z ; std::_Destroy_range<std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@@Z PROC ; std::_Destroy_range<std::allocator<IntrigueNotificationMessage> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@2
	npad	2
$LL7@Destroy_ra@2:
	lea	ecx, DWORD PTR [esi+36]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@2
$LN5@Destroy_ra@2:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@0AAV?$allocator@UIntrigueNotificationMessage@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUScoreCityEntry@@@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU2@00@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Umove<ScoreCityEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUScoreCityEntry@@@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU2@00@Z
_TEXT	SEGMENT
$T249779 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$249782 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUScoreCityEntry@@@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU2@00@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Umove<ScoreCityEntry *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$249782[esp]
	mov	BYTE PTR $T249779[esp+4], 0
	mov	eax, DWORD PTR $T249779[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUScoreCityEntry@@@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU2@00@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Umove<ScoreCityEntry *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249797 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$249800 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$249800[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T249797[esp+4], 0
	mov	eax, DWORD PTR $T249797[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@U_Undefined_move_tag@3@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryHighEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T249807 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T249808 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryHighEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T249807[esp+8], bl
	mov	eax, DWORD PTR $T249807[esp+8]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+8]
	push	ecx
	push	edx
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T249808[esp+40], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>

; 5287 : 	}

	mov	eax, DWORD PTR __Dest$[esp+48]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@7:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryHighEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryHighEval@@@Z ; stdext::_Unchecked_chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T249844 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryHighEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T249844[esp+4], 0
	mov	eax, DWORD PTR $T249844[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryHighEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z
_TEXT	SEGMENT
$T249852 = -20						; size = 20
$T249849 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
$T250025 = 24						; size = 1
__Cat$250030 = 24					; size = 1
$T250027 = 24						; size = 1
$T249991 = 24						; size = 1
__Cat$249996 = 24					; size = 1
$T249993 = 24						; size = 1
$T249936 = 24						; size = 1
__Cat$249941 = 24					; size = 1
$T249938 = 24						; size = 1
$T249902 = 24						; size = 1
__Cat$249907 = 24					; size = 1
$T249904 = 24						; size = 1
$T249853 = 24						; size = 4
$T249851 = 24						; size = 4
$T249850 = 24						; size = 4
$T249848 = 24						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Count2$[esp+24]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebp
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+52]
	mov	ecx, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T249848[esp+52], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T249849[esp+64]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR $T249849[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T249902[esp+32], bl
	mov	eax, DWORD PTR $T249902[esp+32]
	mov	ecx, DWORD PTR __Cat$249907[esp+32]
	mov	edx, DWORD PTR $T249904[esp+32]
	push	eax
	mov	eax, DWORD PTR __First$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+40]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+44]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T249850[esp+56]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T249936[esp+60], bl
	mov	ecx, DWORD PTR $T249936[esp+60]
	mov	edx, DWORD PTR __Cat$249941[esp+60]
	mov	eax, DWORD PTR $T249938[esp+60]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+64]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	ebp, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+52]
	mov	ecx, DWORD PTR __Mid$[esp+52]
	mov	DWORD PTR $T249851[esp+52], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T249852[esp+64]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR $T249852[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T249991[esp+32], bl
	mov	eax, DWORD PTR $T249991[esp+32]
	mov	ecx, DWORD PTR __Cat$249996[esp+32]
	mov	edx, DWORD PTR $T249993[esp+32]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+40]
	push	edx
	mov	edx, DWORD PTR __First$[esp+44]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T249853[esp+56]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T250025[esp+60], bl
	mov	ecx, DWORD PTR $T250025[esp+60]
	mov	edx, DWORD PTR __Cat$250030[esp+60]
	mov	eax, DWORD PTR $T250027[esp+60]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+64]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@PAUScoreCityEntry@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __First$[esp+32]
	mov	ecx, DWORD PTR __Mid$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r
	mov	edx, DWORD PTR __Last$[esp+32]
	cmp	ecx, edx
	je	SHORT $LN88@Buffered_r
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00PAHPAUScoreCityEntry@@@Z ; std::_Rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>
	mov	eax, DWORD PTR __First$[esp+52]
	add	esp, 20					; 00000014H
$LN88@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	ecx, DWORD PTR [eax+ebp*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryLowEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T250139 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T250140 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryLowEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T250139[esp+8], bl
	mov	eax, DWORD PTR $T250139[esp+8]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+8]
	push	ecx
	push	edx
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T250140[esp+40], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>

; 5287 : 	}

	mov	eax, DWORD PTR __Dest$[esp+48]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@8:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@stdext@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@0V?$_Temp_iterator@UScoreCityEntry@@@2@HHUScoreCityEntryLowEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryLowEval@@@Z ; stdext::_Unchecked_chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T250176 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryLowEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T250176[esp+4], 0
	mov	eax, DWORD PTR $T250176[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@stdext@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HHUScoreCityEntryLowEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill@2
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill@2
	pop	ebx
$LN22@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214850 = 16					; size = 4
__Tmp$214840 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@2
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214840[esp+16], edx
	jae	SHORT $LN3@Insert_n@2
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214840[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214840[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214850[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@2:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@2:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::push_back
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T250370 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z PROC ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+24], esi
	mov	BYTE PTR [esi+452], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::GrowSize
$LN1@push_back@4:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T250370[esp+24], ecx
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	ecx, ecx
	je	SHORT $LN4@push_back@4
	mov	edx, DWORD PTR _element$[esp+20]
	push	edx
	call	??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>
$LN4@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], ecx

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T250370[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAEIABV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@@Z ENDP ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::push_back
PUBLIC	??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::~vector<HeistLocation,std::allocator<HeistLocation> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::~vector<HeistLocation,std::allocator<HeistLocation> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::~vector<HeistLocation,std::allocator<HeistLocation> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXXZ PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	je	SHORT $LN15@clear@4
	mov	eax, esi
	cmp	esi, esi
	je	SHORT $LN40@clear@4
	push	edi
$LL42@clear@4:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL42@clear@4
	pop	edi
$LN40@clear@4:
	mov	DWORD PTR [ecx+8], edx
$LN15@clear@4:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXXZ ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T250700 = -4						; size = 1
$T250702 = -4						; size = 1
__Cat$250704 = -4					; size = 1
?clear@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXXZ PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx
	push	esi
	mov	esi, ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN15@clear@5
	mov	BYTE PTR $T250700[esp+8], 0
	mov	edx, DWORD PTR $T250700[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$250704[esp+12]
	push	edx
	mov	edx, DWORD PTR $T250702[esp+16]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN15@clear@5:
	pop	esi

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXXZ ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU3@IABU3@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T250735 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$250738 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU3@IABU3@@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$250738[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T250735[esp+12], 0
	mov	eax, DWORD PTR $T250735[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, esi
	add	esp, 24					; 00000018H
	shl	ecx, 4
	add	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU3@IABU3@@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Ufill
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$2
__catchsym$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$0
__unwindtable$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z
_TEXT	SEGMENT
__Tmp$227833 = -24					; size = 8
__Tmp$227823 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$251007 = 8					; size = 1
__Cat$250925 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$227808 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T251003 = 16						; size = 1
$T250928 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@KAXXZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Xlen
$LN87@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UHeistLocation@@@std@@YAPAUHeistLocation@@IPAU1@@Z ; std::_Allocate<HeistLocation>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$227808[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU3@IABU3@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$250925[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T250928[ebp], 0
	mov	ecx, DWORD PTR $T250928[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227808[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T251003[ebp], 0
	mov	edx, DWORD PTR $T251003[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$251007[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$227808[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUHeistLocation@@PAU1@V?$allocator@UHeistLocation@@@std@@@std@@YAPAUHeistLocation@@PAU1@00AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<HeistLocation *,HeistLocation *,std::allocator<HeistLocation> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227808[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$227823[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227823[ebp], edx
	call	??$_Umove@PAUHeistLocation@@@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU2@00@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Umove<HeistLocation *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$227823[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU3@IABU3@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$227823[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z ; std::fill<HeistLocation *,HeistLocation>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$227833[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227833[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAUHeistLocation@@@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEPAUHeistLocation@@PAU2@00@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Umove<HeistLocation *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAUHeistLocation@@PAU1@@stdext@@YAPAUHeistLocation@@PAU1@00@Z ; stdext::_Unchecked_move_backward<HeistLocation *,HeistLocation *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$227833[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAUHeistLocation@@U1@@std@@YAXPAUHeistLocation@@0ABU1@@Z ; std::fill<HeistLocation *,HeistLocation>
	add	esp, 24					; 00000018H
$LN1@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$2
__catchsym$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$0
__unwindtable$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
__Tmp$227908 = -40					; size = 20
__Tmp$227898 = -40					; size = 20
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$251243 = 8					; size = 1
__Cat$251170 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$227883 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T251240 = 16						; size = 1
$T251167 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@4
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@4
$LN29@Insert_n@4:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN85@Insert_n@4

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 214748364				; 0cccccccH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@KAXXZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Xlen
$LN91@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 214748364				; 0cccccccH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@USpyNotificationMessage@@@std@@YAPAUSpyNotificationMessage@@IPAU1@@Z ; std::_Allocate<SpyNotificationMessage>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 3
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*4]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$227883[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU3@IABU3@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$251170[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T251167[ebp], 0
	mov	ecx, DWORD PTR $T251167[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227883[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$227883[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*4]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T251240[ebp], 0
	mov	edx, DWORD PTR $T251240[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$251243[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUSpyNotificationMessage@@PAU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<SpyNotificationMessage *,SpyNotificationMessage *,std::allocator<SpyNotificationMessage> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR __Newvec$227883[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*4]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227883[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n@4:
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$227898[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$227898[ebp+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$227898[ebp+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$227898[ebp+16], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*4]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227898[ebp+12], edx
	call	??$_Umove@PAUSpyNotificationMessage@@@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU2@00@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Umove<SpyNotificationMessage *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$227898[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU3@IABU3@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$227898[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$_Fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z ; std::_Fill<SpyNotificationMessage *,SpyNotificationMessage>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@4:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$227908[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$227908[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*4]
	mov	DWORD PTR __Tmp$227908[ebp+16], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$227908[ebp+8], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227908[ebp+12], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAUSpyNotificationMessage@@@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEPAUSpyNotificationMessage@@PAU2@00@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Umove<SpyNotificationMessage *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUSpyNotificationMessage@@PAU1@@stdext@@YAPAUSpyNotificationMessage@@PAU1@00@Z ; stdext::_Unchecked_move_backward<SpyNotificationMessage *,SpyNotificationMessage *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$227908[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAUSpyNotificationMessage@@U1@@std@@YAXPAUSpyNotificationMessage@@0ABU1@@Z ; std::_Fill<SpyNotificationMessage *,SpyNotificationMessage>
	add	esp, 24					; 00000018H
$LN85@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Insert_n
PUBLIC	?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy@2
	npad	2
$LL9@Destroy@2:
	lea	ecx, DWORD PTR [esi+36]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL9@Destroy@2
$LN7@Destroy@2:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$2
__catchsym$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$0
__unwindtable$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z
_TEXT	SEGMENT
__Tmp$228137 = -24					; size = 8
__Tmp$228127 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$251580 = 8					; size = 1
__Cat$251508 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$228112 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T251577 = 16						; size = 1
$T251505 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@5
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@5
$LN29@Insert_n@5:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@KAXXZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Xlen
$LN87@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UScoreCityEntry@@@std@@YAPAUScoreCityEntry@@IPAU1@@Z ; std::_Allocate<ScoreCityEntry>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$228112[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU3@IABU3@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$251508[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T251505[ebp], 0
	mov	ecx, DWORD PTR $T251505[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$228112[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T251577[ebp], 0
	mov	edx, DWORD PTR $T251577[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$251580[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$228112[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUScoreCityEntry@@PAU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAPAUScoreCityEntry@@PAU1@00AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ScoreCityEntry *,ScoreCityEntry *,std::allocator<ScoreCityEntry> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$228112[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$228127[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$228127[ebp], edx
	call	??$_Umove@PAUScoreCityEntry@@@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU2@00@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Umove<ScoreCityEntry *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$228127[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU3@IABU3@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$228127[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z ; std::fill<ScoreCityEntry *,ScoreCityEntry>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@5:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$228137[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$228137[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAUScoreCityEntry@@@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEPAUScoreCityEntry@@PAU2@00@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Umove<ScoreCityEntry *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAUScoreCityEntry@@PAU1@@stdext@@YAPAUScoreCityEntry@@PAU1@00@Z ; stdext::_Unchecked_move_backward<ScoreCityEntry *,ScoreCityEntry *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$228137[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAUScoreCityEntry@@U1@@std@@YAXPAUScoreCityEntry@@0ABU1@@Z ; std::fill<ScoreCityEntry *,ScoreCityEntry>
	add	esp, 24					; 00000018H
$LN1@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Insert_n
PUBLIC	??$_Unchecked_uninitialized_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z
_TEXT	SEGMENT
$T251638 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$251641 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$251641[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T251638[esp+4], 0
	mov	eax, DWORD PTR $T251638[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
$T251776 = -8						; size = 1
$T251747 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T251746 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>, COMDAT

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ebx
	push	ecx
	lea	esi, DWORD PTR [eax+256]
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,ScoreCityEntry>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m
$LN4@Buffered_m:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,ScoreCityEntry>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
	npad	2
$LL3@Buffered_m:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T251746[esp+20], bl
	mov	eax, DWORD PTR $T251746[esp+20]
	push	eax
	push	edx
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T251747[esp+60], esp
	push	eax
	push	ecx
	call	??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryHighEval>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	eax, DWORD PTR [ebp+16]
	mov	BYTE PTR $T251776[esp+68], bl
	mov	edx, DWORD PTR $T251776[esp+68]
	push	edx
	mov	edx, DWORD PTR __First$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryHighEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryHighEval>
	add	esi, esi
	add	esp, 72					; 00000048H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m
$LN1@Buffered_m:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
tv518 = -24						; size = 4
$T252097 = -24						; size = 4
$T252007 = -24						; size = 4
$T251790 = -20						; size = 20
$T251787 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T251938 = 20						; size = 1
__Midn$230416 = 20					; size = 4
$T251791 = 20						; size = 4
$T251789 = 20						; size = 4
$T251788 = 20						; size = 4
$T251786 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+4]
	jle	$LN3@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	edx, ecx
	cmp	ecx, eax
	je	$LN3@Buffered_m@2
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m@2:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m@2
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m@2

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T251786[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T251787[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR $T251787[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN53@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Buffered_m@2:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+36]
	mov	ecx, DWORD PTR __First$[esp+36]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T251788[esp+60]
	push	eax
	call	??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryHighEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryHighEval@@@Z ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
	add	esp, 28					; 0000001cH

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m@2:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m@2

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T251789[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T251790[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR $T251790[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN73@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN73@Buffered_m@2:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	BYTE PTR $T251938[esp+36], bl
	mov	eax, DWORD PTR $T251938[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+48]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T251791[esp+64]
	push	ecx
	call	??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryHighEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
	add	esp, 32					; 00000020H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m@2:

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	push	0
	jge	SHORT $LN2@Buffered_m@2
	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	edi, eax
	mov	eax, DWORD PTR __Pred$[esp+40]
	push	eax
	sar	edi, 1
	lea	ebp, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR __Mid$[esp+44]
	push	ebp
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T252007[esp+60]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>
	mov	ebx, DWORD PTR [eax]

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+60]
	add	esp, 24					; 00000018H
	sar	esi, 3

; 2918 : 			}
; 2919 : 		else

	jmp	SHORT $LN139@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+40]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	sar	esi, 1
	lea	ebx, DWORD PTR [eax+esi*8]
	push	ebx
	push	eax
	push	edx
	lea	eax, DWORD PTR $T252097[esp+60]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryHighEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryHighEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryHighEval>
	mov	ebp, DWORD PTR [eax]

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+60]
	add	esp, 24					; 00000018H
	sar	edi, 3
$LN139@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	mov	DWORD PTR tv518[esp+60], eax
	lea	eax, DWORD PTR __Midn$230416[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	edx, DWORD PTR __Tempbuf$[esp+64]
	mov	eax, DWORD PTR __First$[esp+64]
	push	ecx
	push	edx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Midn$230416[esp+80]
	push	edi
	push	ebp
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+92]
	mov	edx, DWORD PTR __Tempbuf$[esp+92]
	mov	eax, DWORD PTR __Count2$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+96]
	push	edx
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR tv518[esp+108]
	push	eax
	push	ecx
	push	ebx
	push	edi
	call	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
	add	esp, 84					; 00000054H
$LN3@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
$T252274 = -8						; size = 1
$T252245 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T252244 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>, COMDAT

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@3
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@3:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ebx
	push	ecx
	lea	esi, DWORD PTR [eax+256]
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,ScoreCityEntry>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@3
$LN4@Buffered_m@3:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,ScoreCityEntry>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@3
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
	npad	2
$LL3@Buffered_m@3:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T252244[esp+20], bl
	mov	eax, DWORD PTR $T252244[esp+20]
	push	eax
	push	edx
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T252245[esp+60], esp
	push	eax
	push	ecx
	call	??$_Chunked_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@HUScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0V?$_Temp_iterator@UScoreCityEntry@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry>,int,ScoreCityEntryLowEval>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	eax, DWORD PTR [ebp+16]
	mov	BYTE PTR $T252274[esp+68], bl
	mov	edx, DWORD PTR $T252274[esp+68]
	push	edx
	mov	edx, DWORD PTR __First$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntryLowEval@@@std@@YAXPAUScoreCityEntry@@0V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@HHUScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntryLowEval>
	add	esi, esi
	add	esp, 72					; 00000048H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@3
$LN1@Buffered_m@3:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
tv518 = -24						; size = 4
$T252596 = -24						; size = 4
$T252506 = -24						; size = 4
$T252289 = -20						; size = 20
$T252286 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T252437 = 20						; size = 1
__Midn$230541 = 20					; size = 4
$T252290 = 20						; size = 4
$T252288 = 20						; size = 4
$T252287 = 20						; size = 4
$T252285 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@4

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+4]
	jge	$LN3@Buffered_m@4

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	edx, ecx
	cmp	ecx, eax
	je	$LN3@Buffered_m@4
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m@4:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m@4
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m@4

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T252285[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T252286[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR $T252286[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN53@Buffered_m@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Buffered_m@4:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+36]
	mov	ecx, DWORD PTR __First$[esp+36]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T252287[esp+60]
	push	eax
	call	??$unchecked_merge@PAUScoreCityEntry@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V23@UScoreCityEntryLowEval@@@stdext@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@0V12@11UScoreCityEntryLowEval@@@Z ; stdext::unchecked_merge<ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
	add	esp, 28					; 0000001cH

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m@4:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m@4

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T252288[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T252289[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@V?$_Temp_iterator@UScoreCityEntry@@@2@@stdext@@YA?AV?$_Temp_iterator@UScoreCityEntry@@@std@@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,std::_Temp_iterator<ScoreCityEntry> >
	mov	eax, DWORD PTR $T252289[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN73@Buffered_m@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN73@Buffered_m@4:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	BYTE PTR $T252437[esp+36], bl
	mov	eax, DWORD PTR $T252437[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+48]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T252290[esp+64]
	push	ecx
	call	??$_Merge_backward@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@PAUScoreCityEntry@@V12@UScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0PAUScoreCityEntry@@10UScoreCityEntryLowEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry *,std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
	add	esp, 32					; 00000020H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m@4:

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	push	0
	jge	SHORT $LN2@Buffered_m@4
	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	edi, eax
	mov	eax, DWORD PTR __Pred$[esp+40]
	push	eax
	sar	edi, 1
	lea	ebp, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR __Mid$[esp+44]
	push	ebp
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T252506[esp+60]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>
	mov	ebx, DWORD PTR [eax]

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+60]
	add	esp, 24					; 00000018H
	sar	esi, 3

; 2918 : 			}
; 2919 : 		else

	jmp	SHORT $LN139@Buffered_m@4
$LN2@Buffered_m@4:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+40]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	sar	esi, 1
	lea	ebx, DWORD PTR [eax+esi*8]
	push	ebx
	push	eax
	push	edx
	lea	eax, DWORD PTR $T252596[esp+60]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntry@@HUScoreCityEntryLowEval@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@0ABUScoreCityEntry@@UScoreCityEntryLowEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntry,int,ScoreCityEntryLowEval>
	mov	ebp, DWORD PTR [eax]

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+60]
	add	esp, 24					; 00000018H
	sar	edi, 3
$LN139@Buffered_m@4:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	mov	DWORD PTR tv518[esp+60], eax
	lea	eax, DWORD PTR __Midn$230541[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@@std@@YA?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	edx, DWORD PTR __Tempbuf$[esp+64]
	mov	eax, DWORD PTR __First$[esp+64]
	push	ecx
	push	edx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Midn$230541[esp+80]
	push	edi
	push	ebp
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+92]
	mov	edx, DWORD PTR __Tempbuf$[esp+92]
	mov	eax, DWORD PTR __Count2$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+96]
	push	edx
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR tv518[esp+108]
	push	eax
	push	ecx
	push	ebx
	push	edi
	call	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
	add	esp, 84					; 00000054H
$LN3@Buffered_m@4:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??0?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??0?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ
_TEXT	SEGMENT
??0?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ PROC ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>, COMDAT
; _this$ = ecx
	push	esi
	push	OFFSET ??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::~vector<HeistLocation,std::allocator<HeistLocation> >
	push	OFFSET ??0?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::vector<HeistLocation,std::allocator<HeistLocation> >
	push	22					; 00000016H
	mov	esi, ecx
	push	16					; 00000010H
	push	esi
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, esi
	pop	esi
	ret	0
??0?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ ENDP ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>
_TEXT	ENDS
PUBLIC	??1?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::~Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??1?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ
_TEXT	SEGMENT
??1?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ PROC ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::~Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>, COMDAT
; _this$ = ecx
	push	OFFSET ??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::~vector<HeistLocation,std::allocator<HeistLocation> >
	push	22					; 00000016H
	push	16					; 00000010H
	push	ecx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
??1?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ ENDP ; Firaxis::Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>::~Array<std::vector<HeistLocation,std::allocator<HeistLocation> >,22>
_TEXT	ENDS
PUBLIC	?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::ProcessSpyMessages
EXTRN	?getAdjectiveKey@CvCivilizationInfo@@QBEPBDXZ:PROC ; CvCivilizationInfo::getAdjectiveKey
EXTRN	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ:PROC ; CvCivilizationBaseInfo::getShortDescriptionKey
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?countHumanPlayersEverAlive@CvGame@@QBEHXZ:PROC	; CvGame::countHumanPlayersEverAlive
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ DD 019930522H
	DD	014H
	DD	FLAT:__unwindtable$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$5
	DD	06H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$6
	DD	07H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$9
	DD	0aH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$11
	DD	0cH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$12
	DD	0dH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$15
	DD	010H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$16
	DD	011H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$18
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ
_TEXT	SEGMENT
tv1621 = -544						; size = 4
tv1285 = -544						; size = 4
$T253070 = -544						; size = 4
_iDefendingSpy$223832 = -544				; size = 4
_pTechEntry$223796 = -544				; size = 4
_iMapX$253067 = -540					; size = 4
_pCity$223790 = -540					; size = 4
_bMultiplayer$ = -534					; size = 1
$T252989 = -533						; size = 1
_pNotifications$ = -532					; size = 4
$T252940 = -528						; size = 1
_ui$223785 = -528					; size = 4
__Cat$252944 = -524					; size = 1
$T252942 = -524						; size = 1
_pEspionageAI$ = -524					; size = 4
_strNotification$223872 = -520				; size = 80
_strNotification$223857 = -520				; size = 80
_strNotification$223838 = -520				; size = 80
_strNotification$223822 = -520				; size = 80
_strNotification$223809 = -520				; size = 80
_strSummary$223867 = -440				; size = 80
_strSummary$223853 = -440				; size = 80
_strSummary$223834 = -440				; size = 80
_strSummary$223818 = -440				; size = 80
_strSummary$223806 = -440				; size = 80
$T252716 = -360						; size = 28
$T252737 = -332						; size = 80
$T252718 = -332						; size = 80
$T252731 = -252						; size = 80
$T252722 = -252						; size = 80
$T252738 = -172						; size = 80
$T252717 = -172						; size = 80
$T252732 = -92						; size = 80
$T252721 = -92						; size = 80
__$EHRec$ = -12						; size = 12
?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ PROC	; CvPlayerEspionage::ProcessSpyMessages, COMDAT
; _this$ = ecx

; 2429 : {

	push	-1
	push	__ehhandler$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 532				; 00000214H
	push	ebx
	push	esi
	mov	esi, ecx

; 2430 : 	CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications

; 2431 : 	if(!pNotifications)

	xor	ebx, ebx
	mov	DWORD PTR _pNotifications$[esp+552], eax
	cmp	eax, ebx
	jne	SHORT $LN34@ProcessSpy

; 2432 : 	{
; 2433 : 		m_aSpyNotificationMessages.clear();

	mov	ecx, DWORD PTR [esi+1268]
	mov	eax, DWORD PTR [esi+1272]
	cmp	ecx, eax
	je	$LN299@ProcessSpy
	mov	BYTE PTR $T252940[esp+552], bl
	mov	edx, DWORD PTR $T252940[esp+552]
	push	edx
	mov	edx, DWORD PTR __Cat$252944[esp+556]
	push	edx
	mov	edx, DWORD PTR $T252942[esp+560]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAUSpyNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUSpyNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<SpyNotificationMessage *,SpyNotificationMessage *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+1272], eax
	pop	esi
	pop	ebx

; 2602 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+544]
	mov	DWORD PTR fs:0, ecx
	add	esp, 544				; 00000220H
	ret	0
$LN34@ProcessSpy:

; 2434 : 		return;
; 2435 : 	}
; 2436 : 
; 2437 : 	bool bMultiplayer = GC.getGame().countHumanPlayersEverAlive() > 1;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?countHumanPlayersEverAlive@CvGame@@QBEHXZ ; CvGame::countHumanPlayersEverAlive

; 2438 : 	CvEspionageAI* pEspionageAI = m_pPlayer->GetEspionageAI();

	mov	ecx, DWORD PTR [esi+1296]
	cmp	eax, 1
	setg	BYTE PTR _bMultiplayer$[esp+556]
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI

; 2439 : 
; 2440 : 	for(uint ui = 0; ui < m_aSpyNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [esi+1272]
	sub	ecx, DWORD PTR [esi+1268]
	mov	DWORD PTR _pEspionageAI$[esp+556], eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _ui$223785[esp+556], ebx
	je	$LN31@ProcessSpy
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	ebp
	npad	12
$LL336@ProcessSpy:

; 2441 : 	{
; 2442 : 		CvPlot* pPlot = GC.getMap().plot(m_aSpyNotificationMessages[ui].m_iCityX, m_aSpyNotificationMessages[ui].m_iCityY);

	mov	ecx, DWORD PTR [esi+1268]
	mov	ebp, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [ecx+ebx+4]
	add	ecx, ebx
	mov	DWORD PTR $T253070[esp+560], eax
	cmp	ebp, -2147483647			; 80000001H
	je	$LN32@ProcessSpy
	cmp	eax, -2147483647			; 80000001H
	je	$LN32@ProcessSpy
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN337@ProcessSpy
	test	ebp, ebp
	jge	SHORT $LN117@ProcessSpy
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	eax, DWORD PTR $T253070[esp+560]
	mov	ebp, edx
	add	ebp, ecx
$LN337@ProcessSpy:
	mov	DWORD PTR _iMapX$253067[esp+560], ebp
$LN119@ProcessSpy:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edx+4057]
	mov	BYTE PTR $T252989[esp+560], dl
	cmp	BYTE PTR $T252989[esp+560], 0
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edx, DWORD PTR [edx+4024]
	mov	DWORD PTR tv1621[esp+560], edx
	je	SHORT $LN339@ProcessSpy
	test	eax, eax
	jge	SHORT $LN127@ProcessSpy
	mov	ebp, DWORD PTR tv1621[esp+560]
	cdq
	idiv	ebp
	add	edx, ebp
	mov	ebp, DWORD PTR _iMapX$253067[esp+560]
	jmp	SHORT $LN129@ProcessSpy
$LN117@ProcessSpy:
	cmp	ebp, ecx
	jl	SHORT $LN337@ProcessSpy
	mov	eax, ebp
	cdq
	idiv	ecx
	mov	eax, DWORD PTR $T253070[esp+560]
	mov	ebp, edx
	mov	DWORD PTR _iMapX$253067[esp+560], edx
	jmp	SHORT $LN119@ProcessSpy
$LN127@ProcessSpy:
	cmp	eax, edx
	jl	SHORT $LN339@ProcessSpy
	mov	ebp, DWORD PTR _iMapX$253067[esp+560]
	cdq
	idiv	DWORD PTR tv1621[esp+560]
	jmp	SHORT $LN129@ProcessSpy
$LN339@ProcessSpy:
	mov	edx, eax
$LN129@ProcessSpy:
	test	ebp, ebp
	jl	$LN32@ProcessSpy
	cmp	ebp, ecx
	jge	$LN32@ProcessSpy
	test	edx, edx
	jl	$LN32@ProcessSpy
	cmp	edx, DWORD PTR tv1621[esp+560]
	jge	$LN32@ProcessSpy
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, ebp
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]

; 2443 : 		CvCity* pCity = NULL;
; 2444 : 		CvCityEspionage* pCityEspionage = NULL;
; 2445 : 		CvAssertMsg(pPlot, "Could not find plot location for SpyNotificationMessages");
; 2446 : 		if(pPlot)

	test	ecx, ecx
	je	$LN32@ProcessSpy

; 2447 : 		{
; 2448 : 			pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	$LN32@ProcessSpy
	cmp	eax, 64					; 00000040H
	jge	$LN32@ProcessSpy
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pCity$223790[esp+560], eax

; 2449 : 			CvAssertMsg(pCity, "Plot does not contain a city");
; 2450 : 			if(pCity)

	test	eax, eax
	je	$LN32@ProcessSpy

; 2451 : 			{
; 2452 : 				CvAssertMsg(pCity->getOwner() == m_pPlayer->GetID(), "City does not belong to player. This is very strange");
; 2453 : 				pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, eax
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	ebp, eax

; 2454 : 			}
; 2455 : 		}
; 2456 : 
; 2457 : 		if(!pCity || !pCityEspionage)

	test	ebp, ebp
	je	$LN32@ProcessSpy

; 2458 : 		{
; 2459 : 			continue;
; 2460 : 		}
; 2461 : 
; 2462 : 		CvTechEntry* pTechEntry = NULL;
; 2463 : 		if(m_aSpyNotificationMessages[ui].m_eStolenTech != NO_TECH)

	mov	edx, DWORD PTR [esi+1268]
	cmp	DWORD PTR [ebx+edx+16], -1
	lea	eax, DWORD PTR [ebx+edx]
	mov	DWORD PTR _pTechEntry$223796[esp+560], 0
	je	SHORT $LN26@ProcessSpy

; 2464 : 		{
; 2465 : 			pTechEntry = GC.getTechInfo(m_aSpyNotificationMessages[ui].m_eStolenTech);

	mov	eax, DWORD PTR [eax+16]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pTechEntry$223796[esp+560], eax
$LN26@ProcessSpy:

; 2466 : 		}
; 2467 : 
; 2468 : 		if(bMultiplayer || !pTechEntry)

	cmp	BYTE PTR _bMultiplayer$[esp+560], 0
	jne	$LN24@ProcessSpy
	cmp	DWORD PTR _pTechEntry$223796[esp+560], 0
	je	$LN24@ProcessSpy

; 2538 : 			}
; 2539 : 		}
; 2540 : 		else
; 2541 : 		{
; 2542 : 			switch(m_aSpyNotificationMessages[ui].m_iSpyResult)

	mov	ecx, DWORD PTR [esi+1268]
	mov	eax, DWORD PTR [ebx+ecx+12]
	sub	eax, 1
	je	$LN7@ProcessSpy
	sub	eax, 1
	jne	$LN32@ProcessSpy

; 2567 : 			case SPY_RESULT_IDENTIFIED:
; 2568 : 			{
; 2569 : 				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_S");

	lea	edx, DWORD PTR _strSummary$223867[esp+560]
	push	OFFSET $SG223869
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 2570 : 				strSummary << GET_PLAYER(m_aSpyNotificationMessages[ui].m_eAttackingPlayer).getCivilizationInfo().getShortDescriptionKey();

	mov	eax, DWORD PTR [esi+1268]
	mov	ecx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+568], 16	; 00000010H
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223867[esp+564]
	call	edi

; 2571 : 				strSummary << pTechEntry->GetDescriptionKey();

	mov	ecx, DWORD PTR _pTechEntry$223796[esp+560]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR tv1285[esp+560], ecx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strSummary$223867[esp+564]
	call	edi

; 2572 : 
; 2573 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223872[esp+560]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2574 : 				if(pCityEspionage->m_aiSpyAssignment[m_pPlayer->GetID()] == -1)  // no defensive spy

	mov	eax, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [eax+44]
	cmp	DWORD PTR [ebp+eax*4+4], -1
	mov	BYTE PTR __$EHRec$[esp+568], 17		; 00000011H
	jne	SHORT $LN3@ProcessSpy

; 2575 : 				{
; 2576 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_W_TIP");

	lea	ecx, DWORD PTR $T252737[esp+560]
	push	OFFSET $SG223875
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223872[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 18		; 00000012H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252737[esp+560]

; 2577 : 				}
; 2578 : 				else

	jmp	SHORT $LN342@ProcessSpy
$LN3@ProcessSpy:

; 2579 : 				{
; 2580 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED");

	lea	edx, DWORD PTR $T252738[esp+560]
	push	OFFSET $SG223878
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223872[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 19		; 00000013H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252738[esp+560]
$LN342@ProcessSpy:
	mov	BYTE PTR __$EHRec$[esp+568], 17		; 00000011H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2581 : 				}
; 2582 : 				strNotification << GET_PLAYER(m_aSpyNotificationMessages[ui].m_eAttackingPlayer).getCivilizationInfo().getAdjectiveKey();

	mov	eax, DWORD PTR [esi+1268]
	mov	ecx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getAdjectiveKey@CvCivilizationInfo@@QBEPBDXZ ; CvCivilizationInfo::getAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223872[esp+564]
	call	edi

; 2583 : 				strNotification << pTechEntry->GetDescriptionKey();

	mov	ecx, DWORD PTR tv1285[esp+560]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$223872[esp+564]
	call	edi

; 2584 : 				strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$223790[esp+560]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223872[esp+564]
	call	edi

; 2585 : 				pNotifications->Add(NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, m_aSpyNotificationMessages[ui].m_eAttackingPlayer);

	mov	eax, DWORD PTR [esi+1268]
	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	add	eax, ebx
	mov	eax, DWORD PTR [eax+8]
	push	-1
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223867[esp+576]
	call	ebp
	push	eax
	lea	ecx, DWORD PTR _strNotification$223872[esp+580]
	call	ebp
	mov	ecx, DWORD PTR _pNotifications$[esp+580]
	push	eax
	push	-720689320				; d50b2758H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2586 : 
; 2587 : 				pEspionageAI->m_aiNumSpiesCaught[m_aSpyNotificationMessages[ui].m_eAttackingPlayer]++;

	mov	ecx, DWORD PTR [esi+1268]
	mov	edx, DWORD PTR [ebx+ecx+8]
	mov	ecx, DWORD PTR _pEspionageAI$[esp+560]
	mov	eax, DWORD PTR [ecx+108]
	inc	DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 2588 : 				pEspionageAI->m_aiTurnLastSpyCaught[m_aSpyNotificationMessages[ui].m_eAttackingPlayer] = GC.getGame().getGameTurn();

	mov	eax, DWORD PTR [esi+1268]
	mov	edx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	mov	eax, DWORD PTR [ecx+420]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	ebp, DWORD PTR [eax+edx*4]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [ebp], eax

; 2589 : 			}

	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[esp+568], 16		; 00000010H

; 2590 : 			break;

	jmp	$LN343@ProcessSpy
$LN7@ProcessSpy:

; 2543 : 			{
; 2544 : 			case SPY_RESULT_UNDETECTED:
; 2545 : 				// nothing happens, nobody is notified
; 2546 : 				break;
; 2547 : 			case SPY_RESULT_DETECTED:
; 2548 : 			{
; 2549 : 				// notify defending player that a spy of unknown origin stole a tech
; 2550 : 				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_S");

	lea	ecx, DWORD PTR _strSummary$223853[esp+560]
	push	OFFSET $SG223855
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 2551 : 				strSummary << pTechEntry->GetDescriptionKey();

	mov	ecx, DWORD PTR _pTechEntry$223796[esp+560]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR __$EHRec$[esp+568], 12	; 0000000cH
	mov	DWORD PTR tv1285[esp+560], ecx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strSummary$223853[esp+564]
	call	edi

; 2552 : 
; 2553 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223857[esp+560]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2554 : 				if(pCityEspionage->m_aiSpyAssignment[m_pPlayer->GetID()] == -1)  // no defensive spy

	mov	edx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [ebp+eax*4+4], -1
	mov	BYTE PTR __$EHRec$[esp+568], 13		; 0000000dH
	jne	SHORT $LN6@ProcessSpy

; 2555 : 				{
; 2556 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_W_TIP");

	lea	eax, DWORD PTR $T252731[esp+560]
	push	OFFSET $SG223860
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223857[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 14		; 0000000eH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T252731[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 13		; 0000000dH
	call	ebp

; 2557 : 				}
; 2558 : 				else // defensive spy

	jmp	SHORT $LN5@ProcessSpy
$LN6@ProcessSpy:

; 2559 : 				{
; 2560 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED");

	lea	ecx, DWORD PTR $T252732[esp+560]
	push	OFFSET $SG223863
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223857[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 15		; 0000000fH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252732[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 13		; 0000000dH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN5@ProcessSpy:

; 2561 : 				}
; 2562 : 				strNotification << pTechEntry->GetDescriptionKey();

	mov	ecx, DWORD PTR tv1285[esp+560]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$223857[esp+564]
	call	edi

; 2563 : 				strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$223790[esp+560]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223857[esp+564]
	call	edi

; 2564 : 				pNotifications->Add(NOTIFICATION_TECH_STOLEN_SPY_DETECTED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223853[esp+576]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$223857[esp+580]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotifications$[esp+580]
	push	eax
	push	57220132				; 03691c24H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2565 : 			}

	mov	BYTE PTR __$EHRec$[esp+568], 12		; 0000000cH

; 2566 : 			break;

	jmp	$LN343@ProcessSpy
$LN24@ProcessSpy:

; 2469 : 		{
; 2470 : 			switch(m_aSpyNotificationMessages[ui].m_iSpyResult)

	mov	edx, DWORD PTR [esi+1268]
	mov	eax, DWORD PTR [ebx+edx+12]
	sub	eax, 1
	je	$LN20@ProcessSpy
	sub	eax, 1
	je	$LN17@ProcessSpy
	sub	eax, 1
	jne	$LN32@ProcessSpy

; 2513 : 			case SPY_RESULT_KILLED:
; 2514 : 				// notify defending player that they killed a spy
; 2515 : 			{
; 2516 : 				int iDefendingSpy = pCityEspionage->m_aiSpyAssignment[m_pPlayer->GetID()];

	mov	eax, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ebp+eax*4+4]
	mov	DWORD PTR _iDefendingSpy$223832[esp+560], eax

; 2517 : 				CvAssertMsg(iDefendingSpy >= 0, "iDefendingSpy value is out of bounds");
; 2518 : 				if(iDefendingSpy >= 0)

	test	eax, eax
	jl	$LN32@ProcessSpy

; 2519 : 				{
; 2520 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_KILLED_A_SPY_S");

	mov	ebp, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	ecx, DWORD PTR _strSummary$223834[esp+560]
	push	OFFSET $SG223836
	push	ecx
	call	ebp
	add	esp, 8

; 2521 : 					strSummary << GET_PLAYER(m_aSpyNotificationMessages[ui].m_eAttackingPlayer).getCivilizationAdjectiveKey();

	mov	eax, DWORD PTR [esi+1268]
	mov	ecx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+568], 10	; 0000000aH
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223834[esp+564]
	call	edi

; 2522 : 					Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_KILLED_A_SPY");

	lea	edx, DWORD PTR _strNotification$223838[esp+560]
	push	OFFSET $SG223840
	push	edx
	call	ebp
	add	esp, 8

; 2523 : 					strNotification << GetSpyRankName(m_aSpyList[iDefendingSpy].m_eRank);

	mov	ebp, DWORD PTR _iDefendingSpy$223832[esp+560]
	mov	eax, DWORD PTR [esi+4]
	add	ebp, ebp
	add	ebp, ebp
	add	ebp, ebp
	sub	ebp, DWORD PTR _iDefendingSpy$223832[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 11		; 0000000bH
	add	ebp, ebp
	add	ebp, ebp
	mov	ecx, DWORD PTR [eax+ebp+12]
	push	ecx
	mov	ecx, esi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$223838[esp+564]
	call	edi

; 2524 : 					strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[iDefendingSpy].m_iName);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+ebp]
	mov	ecx, DWORD PTR [esi+1296]
	add	eax, ebp
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223838[esp+564]
	call	edi

; 2525 : 					strNotification << GET_PLAYER(m_aSpyNotificationMessages[ui].m_eAttackingPlayer).getCivilizationAdjectiveKey();

	mov	eax, DWORD PTR [esi+1268]
	mov	ecx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223838[esp+564]
	call	edi

; 2526 : 					strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$223790[esp+560]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223838[esp+564]
	call	edi

; 2527 : 
; 2528 : 					pNotifications->Add(NOTIFICATION_SPY_KILLED_A_SPY, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, m_aSpyNotificationMessages[ui].m_eAttackingPlayer);

	mov	eax, DWORD PTR [esi+1268]
	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	add	eax, ebx
	mov	eax, DWORD PTR [eax+8]
	push	-1
	push	eax
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223834[esp+576]
	call	ebp
	push	eax
	lea	ecx, DWORD PTR _strNotification$223838[esp+580]
	call	ebp
	mov	ecx, DWORD PTR _pNotifications$[esp+580]
	push	eax
	push	-54118376				; fcc63818H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2529 : 				
; 2530 : 					//Achievements
; 2531 : 					if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR [esi+1296]
	mov	ebp, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	jne	SHORT $LN12@ProcessSpy

; 2532 : 					{
; 2533 : 						gDLL->UnlockAchievement(ACHIEVEMENT_XP1_15);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	205					; 000000cdH
	call	eax
$LN12@ProcessSpy:

; 2534 : 					}
; 2535 : 				}

	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[esp+568], 10		; 0000000aH

; 2536 : 			}
; 2537 : 			break;

	jmp	$LN343@ProcessSpy
$LN17@ProcessSpy:

; 2492 : 			break;
; 2493 : 			case SPY_RESULT_IDENTIFIED:
; 2494 : 				// notify defending player that a spy of known origin stole something
; 2495 : 			{
; 2496 : 				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_WO_TECH_S");

	lea	ecx, DWORD PTR _strSummary$223818[esp+560]
	push	OFFSET $SG223820
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 2497 : 				strSummary << GET_PLAYER(m_aSpyNotificationMessages[ui].m_eAttackingPlayer).getCivilizationInfo().getShortDescriptionKey();

	mov	eax, DWORD PTR [esi+1268]
	mov	ecx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+568], 6
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$223818[esp+564]
	call	edi

; 2498 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223822[esp+560]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2499 : 
; 2500 : 				if(pCityEspionage->m_aiSpyAssignment[m_pPlayer->GetID()] == -1)

	mov	edx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [ebp+eax*4+4], -1
	mov	BYTE PTR __$EHRec$[esp+568], 7
	jne	SHORT $LN16@ProcessSpy

; 2501 : 				{
; 2502 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_WO_TECH_W_TIP");

	lea	eax, DWORD PTR $T252721[esp+560]
	push	OFFSET $SG223825
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223822[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T252721[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 7
	call	ebp

; 2503 : 				}
; 2504 : 				else

	jmp	SHORT $LN15@ProcessSpy
$LN16@ProcessSpy:

; 2505 : 				{
; 2506 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED_WO_TECH");

	lea	ecx, DWORD PTR $T252722[esp+560]
	push	OFFSET $SG223828
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223822[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252722[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 7
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN15@ProcessSpy:

; 2507 : 				}
; 2508 : 				strNotification << GET_PLAYER(m_aSpyNotificationMessages[ui].m_eAttackingPlayer).getCivilizationInfo().getAdjectiveKey();

	mov	eax, DWORD PTR [esi+1268]
	mov	ecx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getAdjectiveKey@CvCivilizationInfo@@QBEPBDXZ ; CvCivilizationInfo::getAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223822[esp+564]
	call	edi

; 2509 : 				strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$223790[esp+560]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223822[esp+564]
	call	edi

; 2510 : 				pNotifications->Add(NOTIFICATION_TECH_STOLEN_SPY_IDENTIFIED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, m_aSpyNotificationMessages[ui].m_eAttackingPlayer);

	mov	eax, DWORD PTR [esi+1268]
	mov	edx, DWORD PTR [eax+ebx+8]
	add	eax, ebx
	push	-1
	push	edx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223818[esp+576]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$223822[esp+580]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotifications$[esp+580]
	push	eax
	push	-720689320				; d50b2758H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2511 : 			}

	mov	BYTE PTR __$EHRec$[esp+568], 6

; 2512 : 			break;

	jmp	$LN343@ProcessSpy
$LN20@ProcessSpy:

; 2471 : 			{
; 2472 : 			case SPY_RESULT_UNDETECTED:
; 2473 : 				// do nothing
; 2474 : 				break;
; 2475 : 			case SPY_RESULT_DETECTED:
; 2476 : 				// notify defending player that a spy of unknown origin stole something
; 2477 : 			{
; 2478 : 				Localization::String strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_WO_TECH_S");;

	lea	eax, DWORD PTR $T252716[esp+560]
	push	OFFSET $SG223808
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+568], 0
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strSummary$223806[esp+564]
	call	DWORD PTR __imp_??0String@Localization@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T252716[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2479 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223809[esp+560]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2480 : 
; 2481 : 				if(pCityEspionage->m_aiSpyAssignment[m_pPlayer->GetID()] == -1)

	mov	ecx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [ecx+44]
	cmp	DWORD PTR [ebp+eax*4+4], -1
	mov	BYTE PTR __$EHRec$[esp+568], 3
	jne	SHORT $LN19@ProcessSpy

; 2482 : 				{
; 2483 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_WO_TECH_W_TIP");

	lea	edx, DWORD PTR $T252717[esp+560]
	push	OFFSET $SG223812
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223809[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR $T252717[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 3
	call	ebp

; 2484 : 				}
; 2485 : 				else

	jmp	SHORT $LN18@ProcessSpy
$LN19@ProcessSpy:

; 2486 : 				{
; 2487 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_TECH_STOLEN_SPY_DETECTED_WO_TECH");

	lea	eax, DWORD PTR $T252718[esp+560]
	push	OFFSET $SG223815
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223809[esp+564]
	mov	BYTE PTR __$EHRec$[esp+572], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T252718[esp+560]
	mov	BYTE PTR __$EHRec$[esp+568], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN18@ProcessSpy:

; 2488 : 				}
; 2489 : 				strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$223790[esp+560]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223809[esp+564]
	call	edi

; 2490 : 				pNotifications->Add(NOTIFICATION_TECH_STOLEN_SPY_DETECTED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223806[esp+576]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$223809[esp+580]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotifications$[esp+580]
	push	eax
	push	57220132				; 03691c24H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2491 : 			}

	mov	BYTE PTR __$EHRec$[esp+568], 2
$LN343@ProcessSpy:
	lea	ecx, DWORD PTR _strNotification$223809[esp+560]
	call	ebp
	lea	ecx, DWORD PTR _strSummary$223806[esp+560]
	mov	DWORD PTR __$EHRec$[esp+568], -1
	call	ebp
$LN32@ProcessSpy:
	mov	ecx, DWORD PTR [esi+1272]
	sub	ecx, DWORD PTR [esi+1268]
	inc	DWORD PTR _ui$223785[esp+560]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ebx, 20					; 00000014H
	cmp	DWORD PTR _ui$223785[esp+560], ecx
	jb	$LL336@ProcessSpy
	pop	ebp
$LN31@ProcessSpy:

; 2591 : 			case SPY_RESULT_KILLED:
; 2592 : 				// notify defending player that they killed a spy
; 2593 : 			{
; 2594 : 				CvAssertMsg(false, "This code was not expected to be called");
; 2595 : 			}
; 2596 : 			break;
; 2597 : 			}
; 2598 : 		}
; 2599 : 	}
; 2600 : 
; 2601 : 	m_aSpyNotificationMessages.clear();

	mov	ecx, DWORD PTR [esi+1268]
	mov	edx, DWORD PTR [esi+1272]
	cmp	ecx, edx
	je	SHORT $LN341@ProcessSpy
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN324@ProcessSpy
	npad	5
$LL326@ProcessSpy:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edi
	mov	edi, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edi
	add	eax, 20					; 00000014H
	add	ecx, 20					; 00000014H
	cmp	eax, edx
	jne	SHORT $LL326@ProcessSpy
$LN324@ProcessSpy:
	mov	DWORD PTR [esi+1272], ecx
$LN341@ProcessSpy:
	pop	edi
$LN299@ProcessSpy:

; 2602 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+552]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 544				; 00000220H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$15:
	lea	ecx, DWORD PTR _strSummary$223867[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$16:
	lea	ecx, DWORD PTR _strNotification$223872[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$17:
	lea	ecx, DWORD PTR $T252737[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$18:
	lea	ecx, DWORD PTR $T252738[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$11:
	lea	ecx, DWORD PTR _strSummary$223853[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$12:
	lea	ecx, DWORD PTR _strNotification$223857[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$13:
	lea	ecx, DWORD PTR $T252731[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$14:
	lea	ecx, DWORD PTR $T252732[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$9:
	lea	ecx, DWORD PTR _strSummary$223834[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$10:
	lea	ecx, DWORD PTR _strNotification$223838[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$5:
	lea	ecx, DWORD PTR _strSummary$223818[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$6:
	lea	ecx, DWORD PTR _strNotification$223822[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T252721[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T252722[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$0:
	lea	ecx, DWORD PTR $T252716[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strSummary$223806[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strNotification$223809[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T252717[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T252718[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ ENDP	; CvPlayerEspionage::ProcessSpyMessages
PUBLIC	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@5
	xor	eax, eax
	jmp	SHORT $LN10@push_back@5
$LN9@push_back@5:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@5:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@5
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@5:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@ABUHeistLocation@@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@ABUHeistLocation@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@ABUHeistLocation@@@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE?AV?$_Vector_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@V?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@ABUHeistLocation@@@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@ABUSpyNotificationMessage@@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@ABUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@ABUSpyNotificationMessage@@@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@IABUSpyNotificationMessage@@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*4]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@ABUSpyNotificationMessage@@@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@0@Z
_TEXT	SEGMENT
$T253987 = -4						; size = 1
__Cat$253992 = 8					; size = 1
$T253989 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@0@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR __First_arg$[esp+4]
	mov	DWORD PTR [eax], ecx
	cmp	ecx, edx
	je	SHORT $LN1@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [ebp+8]
	push	ebx
	push	esi
	push	edi
	mov	BYTE PTR $T253987[esp+20], 0
	mov	esi, DWORD PTR $T253987[esp+20]
	push	esi
	mov	esi, DWORD PTR __Cat$253992[esp+20]
	push	esi
	mov	esi, DWORD PTR $T253989[esp+24]
	push	esi
	push	ecx
	push	eax
	push	edx
	call	??$_Copy_opt@PAUIntrigueNotificationMessage@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::random_access_iterator_tag>

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebx, DWORD PTR [ebp+8]
	mov	edi, eax
	add	esp, 24					; 00000018H
	mov	esi, edi
	cmp	edi, ebx
	je	SHORT $LN32@erase@5
$LL34@erase@5:
	lea	ecx, DWORD PTR [esi+36]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 68					; 00000044H
	cmp	esi, ebx
	jne	SHORT $LL34@erase@5
$LN32@erase@5:

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [ebp+8], edi
	pop	edi
	pop	esi
	pop	ebx
$LN1@erase@5:
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@0@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXXZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN28@Tidy@6
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@6
$LL12@Tidy@6:
	lea	ecx, DWORD PTR [esi+36]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@6
$LN10@Tidy@6:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN28@Tidy@6:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXXZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Tidy
_TEXT	ENDS
PUBLIC	?insert@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@V?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@ABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@V?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@ABUScoreCityEntry@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@V?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@ABUScoreCityEntry@@@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@5
	xor	esi, esi
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert@5:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@V?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@ABUScoreCityEntry@@@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::insert
_TEXT	ENDS
PUBLIC	??$_Umove@PAUIntrigueNotificationMessage@@@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU2@00@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Umove<IntrigueNotificationMessage *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUIntrigueNotificationMessage@@@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU2@00@Z
_TEXT	SEGMENT
$T254355 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$254358 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUIntrigueNotificationMessage@@@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU2@00@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Umove<IntrigueNotificationMessage *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$254358[esp]
	mov	BYTE PTR $T254355[esp+4], 0
	mov	eax, DWORD PTR $T254355[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUIntrigueNotificationMessage@@@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU2@00@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Umove<IntrigueNotificationMessage *>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	edi

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval,ScoreCityEntry>
	add	esp, 16					; 00000010H
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+esi*8]
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	ebx
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN21@Stable_sor
$LN2@Stable_sor:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+12]
	mov	eax, DWORD PTR __First$[esp+12]
	push	edx
	push	ebp
	push	esi
	push	ebx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Last$[esp+32]
	push	ecx
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
$LN21@Stable_sor:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	eax, DWORD PTR __Pred$[esp+52]
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	eax
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
	add	esp, 28					; 0000001cH
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	edi

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@UScoreCityEntry@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@PAUScoreCityEntry@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval,ScoreCityEntry>
	add	esp, 16					; 00000010H
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor@2:
	push	ebx

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+esi*8]
	call	?_Maxlen@?$_Temp_iterator@UScoreCityEntry@@@std@@QAEHXZ ; std::_Temp_iterator<ScoreCityEntry>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor@2

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	ebx
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN21@Stable_sor@2
$LN2@Stable_sor@2:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+12]
	mov	eax, DWORD PTR __First$[esp+12]
	push	edx
	push	ebp
	push	esi
	push	ebx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Last$[esp+32]
	push	ecx
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
$LN21@Stable_sor@2:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	eax, DWORD PTR __Pred$[esp+52]
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	eax
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@00HHAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
	add	esp, 28					; 0000001cH
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@6
	xor	eax, eax
	jmp	SHORT $LN10@push_back@6
$LN9@push_back@6:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@6:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@6
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@6:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z ; CvEspionageAI::FindTargetSpyNumbers
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForSpaceshipVictory
EXTRN	?GetMaxPropagandaDiplomatsWanted@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetMaxPropagandaDiplomatsWanted
EXTRN	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForCultureVictory
EXTRN	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ:PROC ; CvMinorCivAI::GetTrait
EXTRN	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForWorldConquest
EXTRN	?GetDiplomatUsefulnessAtCiv@CvLeagueAI@@QAE?AW4DiplomatUsefulnessLevels@1@W4PlayerTypes@@@Z:PROC ; CvLeagueAI::GetDiplomatUsefulnessAtCiv
EXTRN	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ:PROC ; CvPlayer::GetLeagueAI
EXTRN	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ:PROC ; CvDiplomacyAI::IsGoingForDiploVictory
EXTRN	?GetTechRatio@CvTechAI@@QAEMXZ:PROC		; CvTechAI::GetTechRatio
EXTRN	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ:PROC ; CvPlayerTechs::GetTechAI
;	COMDAT __real@3e800000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z$0
__ehfuncinfo$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z
_TEXT	SEGMENT
_bAllocatedOffensiveSpies$ = -49			; size = 1
_iNumDiplomats$225614 = -48				; size = 4
_iNumRemainingSpies$ = -48				; size = 4
tv1648 = -44						; size = 4
$T254753 = -44						; size = 4
$T254758 = -44						; size = 4
_iCount$254716 = -44					; size = 4
$T254705 = -44						; size = 4
$T254704 = -44						; size = 4
_iNumDiplomats$225579 = -44				; size = 4
_fNumDiplomats$225561 = -44				; size = 4
_this$ = -40						; size = 4
_fTechPositionRatio$ = -36				; size = 4
_iLoop$ = -32						; size = 4
_apOtherCityList$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_piTargetOffensiveSpies$ = 8				; size = 4
_piTargetDefensiveSpies$ = 12				; size = 4
tv1577 = 16						; size = 4
$T255096 = 16						; size = 4
$T255090 = 16						; size = 4
$T255095 = 16						; size = 4
_ui$225630 = 16						; size = 4
_piTargetCityStateSpies$ = 16				; size = 4
tv1632 = 20						; size = 4
tv1609 = 20						; size = 4
$T254926 = 20						; size = 4
$T254920 = 20						; size = 4
$T254925 = 20						; size = 4
$T254778 = 20						; size = 4
$T254772 = 20						; size = 4
$T254777 = 20						; size = 4
_pLoopCity$ = 20					; size = 4
_iNumMilitaristicCityStates$225601 = 20			; size = 4
_iNumCityStates$225587 = 20				; size = 4
_piTargetDiplomatSpies$ = 20				; size = 4
?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z PROC	; CvEspionageAI::FindTargetSpyNumbers, COMDAT
; _this$ = ecx

; 4724 : {

	push	-1
	push	__ehhandler$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	mov	ebx, ecx

; 4725 : 	CvDiplomacyAI* pDiploAI = m_pPlayer->GetDiplomacyAI();

	mov	ecx, DWORD PTR [ebx]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+64], ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI

; 4726 : 
; 4727 : 	int iNumRemainingSpies = m_pPlayer->GetEspionage()->GetNumAliveSpies();

	mov	ecx, DWORD PTR [ebx]
	mov	edi, eax
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	edx, DWORD PTR [eax+8]
	xor	esi, esi
	xor	ecx, ecx
	mov	DWORD PTR _iCount$254716[esp+64], esi
	test	edx, edx
	jbe	SHORT $LN58@FindTarget
	mov	eax, DWORD PTR [eax+4]
	add	eax, 16					; 00000010H
$LL60@FindTarget:
	cmp	DWORD PTR [eax], 8
	je	SHORT $LN59@FindTarget
	inc	esi
$LN59@FindTarget:
	inc	ecx
	add	eax, 28					; 0000001cH
	cmp	ecx, edx
	jb	SHORT $LL60@FindTarget
	mov	DWORD PTR _iCount$254716[esp+64], esi
$LN58@FindTarget:
	mov	DWORD PTR _iNumRemainingSpies$[esp+64], esi

; 4728 : 	if(iNumRemainingSpies == 0)

	test	esi, esi
	jne	SHORT $LN53@FindTarget

; 4729 : 	{
; 4730 : 		*piTargetDefensiveSpies = 0;

	mov	eax, DWORD PTR _piTargetDefensiveSpies$[esp+60]

; 4731 : 		*piTargetOffensiveSpies = 0;

	mov	ecx, DWORD PTR _piTargetOffensiveSpies$[esp+60]

; 4732 : 		*piTargetCityStateSpies = 0;

	mov	edx, DWORD PTR _piTargetCityStateSpies$[esp+60]
	mov	DWORD PTR [eax], esi

; 4733 : 		*piTargetDiplomatSpies  = 0;

	mov	eax, DWORD PTR _piTargetDiplomatSpies$[esp+60]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [edx], esi
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 4942 : 		}
; 4943 : 	}
; 4944 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
$LN53@FindTarget:

; 4734 : 		return;
; 4735 : 	}
; 4736 : 
; 4737 : 	bool bAllocatedOffensiveSpies = false;
; 4738 : 	bool bAllocatedDefensiveSpies = false;
; 4739 : 	bool bAllocatedCityStateSpies = false;
; 4740 : 	bool bAllocatedDiplomatSpies  = false;
; 4741 : 	float fTechPositionRatio = m_pPlayer->GetPlayerTechs()->GetTechAI()->GetTechRatio();

	mov	ecx, DWORD PTR [ebx]
	push	ebp
	mov	BYTE PTR _bAllocatedOffensiveSpies$[esp+68], 0
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ ; CvPlayerTechs::GetTechAI
	mov	ecx, eax
	call	?GetTechRatio@CvTechAI@@QAEMXZ		; CvTechAI::GetTechRatio
	fstp	DWORD PTR _fTechPositionRatio$[esp+68]

; 4742 : 
; 4743 : 	// if going for diplo or conquest, evaluate the offensive spies before assigning CS spies
; 4744 : 	if (pDiploAI->IsGoingForDiploVictory())

	mov	ecx, edi
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	test	al, al
	je	$LN52@FindTarget

; 4745 : 	{
; 4746 : 		// find out how many diplomats we need
; 4747 : 		float fNumDiplomats = 0.0f;

	xor	ebp, ebp
	mov	DWORD PTR _fNumDiplomats$225561[esp+68], ebp

; 4748 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	edi, edi
$LL51@FindTarget:

; 4749 : 		{
; 4750 : 			PlayerTypes ePlayer = (PlayerTypes)ui;
; 4751 : 			// must not be me and must be alive
; 4752 : 			if (ePlayer == m_pPlayer->GetID() || !GET_PLAYER(ePlayer).isAlive())

	mov	ecx, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [ecx+44]
	je	SHORT $LN50@FindTarget
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edx+ebp+2256], 0
	je	SHORT $LN50@FindTarget

; 4753 : 			{
; 4754 : 				continue;
; 4755 : 			}
; 4756 : 
; 4757 : 			CvLeagueAI::DiplomatUsefulnessLevels eUsefulnessLevel = m_pPlayer->GetLeagueAI()->GetDiplomatUsefulnessAtCiv(ePlayer);

	push	edi
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?GetDiplomatUsefulnessAtCiv@CvLeagueAI@@QAE?AW4DiplomatUsefulnessLevels@1@W4PlayerTypes@@@Z ; CvLeagueAI::GetDiplomatUsefulnessAtCiv

; 4758 : 			switch (eUsefulnessLevel)

	sub	eax, 1
	je	SHORT $LN42@FindTarget
	sub	eax, 1
	je	SHORT $LN43@FindTarget
	sub	eax, 1
	jne	SHORT $LN50@FindTarget

; 4759 : 			{
; 4760 : 			case CvLeagueAI::DIPLOMAT_USEFULNESS_HIGH:
; 4761 : 				fNumDiplomats += 1.0f;

	fld	DWORD PTR _fNumDiplomats$225561[esp+68]
	fld1
	faddp	ST(1), ST(0)

; 4762 : 				break;

	jmp	SHORT $LN373@FindTarget
$LN43@FindTarget:

; 4763 : 			case CvLeagueAI::DIPLOMAT_USEFULNESS_MEDIUM:
; 4764 : 				fNumDiplomats += 0.5f;

	fld	DWORD PTR _fNumDiplomats$225561[esp+68]
	fadd	DWORD PTR __real@3f000000

; 4765 : 				break;

	jmp	SHORT $LN373@FindTarget
$LN42@FindTarget:

; 4766 : 			case CvLeagueAI::DIPLOMAT_USEFULNESS_LOW:
; 4767 : 				fNumDiplomats += 0.25f;

	fld	DWORD PTR _fNumDiplomats$225561[esp+68]
	fadd	DWORD PTR __real@3e800000
$LN373@FindTarget:
	fstp	DWORD PTR _fNumDiplomats$225561[esp+68]
$LN50@FindTarget:

; 4748 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	add	ebp, 63236				; 0000f704H
	inc	edi
	cmp	ebp, 1391192				; 00153a58H
	jb	SHORT $LL51@FindTarget

; 4768 : 				break;
; 4769 : 			case CvLeagueAI::DIPLOMAT_USEFULNESS_NONE:
; 4770 : 				break;
; 4771 : 			}
; 4772 : 		}
; 4773 : 
; 4774 : 		// assign spies to be diplomats
; 4775 : 		int iNumDiplomats = (int)floor(fNumDiplomats);

	fld	DWORD PTR _fNumDiplomats$225561[esp+68]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__floor
	fstp	DWORD PTR tv1648[esp+76]
	add	esp, 8
	fld	DWORD PTR tv1648[esp+68]
	fstp	DWORD PTR $T254753[esp+68]
	mov	eax, DWORD PTR $T254753[esp+68]
	mov	DWORD PTR $T254758[esp+68], eax
	fld	DWORD PTR $T254758[esp+68]
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iNumDiplomats$225579[esp+68], eax

; 4776 : 		*piTargetDiplomatSpies = min(iNumRemainingSpies, iNumDiplomats);

	cmp	eax, esi
	lea	eax, DWORD PTR _iNumDiplomats$225579[esp+68]
	jl	SHORT $LN84@FindTarget
	lea	eax, DWORD PTR _iNumRemainingSpies$[esp+68]
$LN84@FindTarget:
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _piTargetDiplomatSpies$[esp+64]

; 4777 : 		bAllocatedDiplomatSpies = true;
; 4778 : 		iNumRemainingSpies -= *piTargetDiplomatSpies;

	sub	esi, eax
	mov	DWORD PTR _iNumRemainingSpies$[esp+68], esi

; 4779 : 
; 4780 : 		// assign offensive spies according to tech position
; 4781 : 		*piTargetOffensiveSpies = (int)ceil(fTechPositionRatio * iNumRemainingSpies);

	fild	DWORD PTR _iNumRemainingSpies$[esp+68]
	sub	esp, 8
	mov	DWORD PTR [ecx], eax
	fmul	DWORD PTR _fTechPositionRatio$[esp+76]
	fstp	DWORD PTR $T254777[esp+72]
	fld	DWORD PTR $T254777[esp+72]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv1632[esp+72]
	add	esp, 8
	fld	DWORD PTR tv1632[esp+64]
	fstp	DWORD PTR $T254772[esp+64]
	mov	edx, DWORD PTR $T254772[esp+64]
	mov	DWORD PTR $T254778[esp+64], edx
	fld	DWORD PTR $T254778[esp+64]
	call	__ftol2_sse_excpt
	mov	ecx, DWORD PTR _piTargetOffensiveSpies$[esp+64]

; 4782 : 		bAllocatedOffensiveSpies = true;
; 4783 : 		iNumRemainingSpies -= *piTargetOffensiveSpies;

	sub	esi, eax

; 4784 : 
; 4785 : 		int iNumCityStates = 0;

	xor	ebp, ebp
	mov	DWORD PTR [ecx], eax
	mov	BYTE PTR _bAllocatedOffensiveSpies$[esp+68], 1
	mov	DWORD PTR _iNumRemainingSpies$[esp+68], esi
	mov	DWORD PTR _iNumCityStates$225587[esp+64], ebp
	mov	edi, 1391192				; 00153a58H
	npad	2
$LL40@FindTarget:

; 4787 : 		{
; 4788 : 			PlayerTypes ePlayer = (PlayerTypes)ui;
; 4789 : 			if (!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+eax+2256], 0
	je	$LN39@FindTarget

; 4790 : 			{
; 4791 : 				continue;
; 4792 : 			}
; 4793 : 
; 4794 : 			if(!GET_TEAM(m_pPlayer->getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))

	mov	eax, DWORD PTR [edi+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN101@FindTarget
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN102@FindTarget
$LN101@FindTarget:
	or	ecx, -1
$LN102@FindTarget:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN110@FindTarget
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN111@FindTarget
$LN110@FindTarget:
	or	eax, -1
$LN111@FindTarget:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN39@FindTarget

; 4795 : 			{
; 4796 : 				continue;
; 4797 : 			}
; 4798 : 
; 4799 : 			// don't interact with city-states that are at war with us
; 4800 : 			if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN121@FindTarget
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN122@FindTarget
$LN121@FindTarget:
	or	ecx, -1
$LN122@FindTarget:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN132@FindTarget
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN133@FindTarget
$LN132@FindTarget:
	or	eax, -1
$LN133@FindTarget:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN39@FindTarget

; 4801 : 			{
; 4802 : 				continue;
; 4803 : 			}
; 4804 : 
; 4805 : 			if (GET_PLAYER(ePlayer).isMinorCiv())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN39@FindTarget

; 4806 : 			{
; 4807 : 				iNumCityStates++;

	inc	ebp
$LN39@FindTarget:

; 4786 : 		for(uint ui = MAX_MAJOR_CIVS; ui < MAX_CIV_PLAYERS; ui++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jb	$LL40@FindTarget

; 4808 : 			}
; 4809 : 		}
; 4810 : 
; 4811 : 		*piTargetCityStateSpies = min(iNumRemainingSpies, iNumCityStates);

	cmp	ebp, esi
	mov	DWORD PTR _iNumCityStates$225587[esp+64], ebp
	lea	eax, DWORD PTR _iNumCityStates$225587[esp+64]
	jl	SHORT $LN144@FindTarget
	lea	eax, DWORD PTR _iNumRemainingSpies$[esp+68]
$LN144@FindTarget:
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _piTargetCityStateSpies$[esp+64]
	mov	DWORD PTR [edx], ecx

; 4812 : 		bAllocatedCityStateSpies = true;

	jmp	$LN371@FindTarget
$LN52@FindTarget:

; 4813 : 	}
; 4814 : 	else if (pDiploAI->IsGoingForWorldConquest())

	mov	ecx, edi
	call	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForWorldConquest
	test	al, al
	je	$LN32@FindTarget

; 4815 : 	{
; 4816 : 		// assign offensive spies according to tech position
; 4817 : 		*piTargetOffensiveSpies = (int)ceil(fTechPositionRatio * iNumRemainingSpies);

	fild	DWORD PTR _iCount$254716[esp+68]
	sub	esp, 8
	fmul	DWORD PTR _fTechPositionRatio$[esp+76]
	fstp	DWORD PTR $T254925[esp+72]
	fld	DWORD PTR $T254925[esp+72]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv1609[esp+72]
	add	esp, 8
	fld	DWORD PTR tv1609[esp+64]
	fstp	DWORD PTR $T254920[esp+64]
	mov	eax, DWORD PTR $T254920[esp+64]
	mov	DWORD PTR $T254926[esp+64], eax
	fld	DWORD PTR $T254926[esp+64]
	call	__ftol2_sse_excpt
	mov	ecx, DWORD PTR _piTargetOffensiveSpies$[esp+64]

; 4818 : 		bAllocatedOffensiveSpies = true;
; 4819 : 		iNumRemainingSpies -= *piTargetOffensiveSpies;

	sub	esi, eax

; 4820 : 
; 4821 : 		// Assign the rest to militaristic city-states
; 4822 : 		// for now, assign spies to the militaristic city states
; 4823 : 		int iNumMilitaristicCityStates = 0;

	xor	ebp, ebp
	mov	DWORD PTR [ecx], eax
	mov	BYTE PTR _bAllocatedOffensiveSpies$[esp+68], 1
	mov	DWORD PTR _iNumRemainingSpies$[esp+68], esi
	mov	DWORD PTR _iNumMilitaristicCityStates$225601[esp+64], ebp
	mov	edi, 1391192				; 00153a58H
	npad	2
$LL31@FindTarget:

; 4825 : 		{
; 4826 : 			PlayerTypes ePlayer = (PlayerTypes)ui;
; 4827 : 			if (!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+eax+2256], 0
	je	$LN30@FindTarget

; 4828 : 			{
; 4829 : 				continue;
; 4830 : 			}
; 4831 : 
; 4832 : 			if(!GET_TEAM(m_pPlayer->getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))

	mov	eax, DWORD PTR [edi+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN161@FindTarget
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN162@FindTarget
$LN161@FindTarget:
	or	ecx, -1
$LN162@FindTarget:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN170@FindTarget
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN171@FindTarget
$LN170@FindTarget:
	or	eax, -1
$LN171@FindTarget:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN30@FindTarget

; 4833 : 			{
; 4834 : 				continue;
; 4835 : 			}
; 4836 : 
; 4837 : 			// don't interact with city-states that are at war with us
; 4838 : 			if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isAtWar(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN181@FindTarget
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN182@FindTarget
$LN181@FindTarget:
	or	ecx, -1
$LN182@FindTarget:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN192@FindTarget
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN193@FindTarget
$LN192@FindTarget:
	or	eax, -1
$LN193@FindTarget:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN30@FindTarget

; 4839 : 			{
; 4840 : 				continue;
; 4841 : 			}
; 4842 : 
; 4843 : 			if (GET_PLAYER(ePlayer).isMinorCiv() && GET_PLAYER(ePlayer).GetMinorCivAI()->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN30@FindTarget
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
	cmp	eax, 1
	jne	SHORT $LN30@FindTarget

; 4844 : 			{
; 4845 : 				iNumMilitaristicCityStates++;

	inc	ebp
$LN30@FindTarget:

; 4824 : 		for(uint ui = MAX_MAJOR_CIVS; ui < MAX_CIV_PLAYERS; ui++)

	add	edi, 63236				; 0000f704H
	cmp	edi, 3983868				; 003cc9fcH
	jb	$LL31@FindTarget

; 4846 : 			}
; 4847 : 		}
; 4848 : 
; 4849 : 		*piTargetCityStateSpies = min(iNumRemainingSpies, iNumMilitaristicCityStates);

	cmp	ebp, esi
	mov	DWORD PTR _iNumMilitaristicCityStates$225601[esp+64], ebp
	lea	eax, DWORD PTR _iNumMilitaristicCityStates$225601[esp+64]
	jl	SHORT $LN206@FindTarget
	lea	eax, DWORD PTR _iNumRemainingSpies$[esp+68]
$LN206@FindTarget:
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _piTargetCityStateSpies$[esp+64]
	mov	DWORD PTR [eax], edx

; 4850 : 		bAllocatedCityStateSpies = true;

	jmp	$LN371@FindTarget
$LN32@FindTarget:

; 4851 : 	}
; 4852 : 	else if (pDiploAI->IsGoingForCultureVictory())

	mov	ecx, edi
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	je	SHORT $LN23@FindTarget

; 4853 : 	{
; 4854 : 		// assign two spies to be diplomats
; 4855 : 		int iNumDiplomats = min(iNumRemainingSpies, 2);

	cmp	esi, 2
	mov	DWORD PTR $T254704[esp+68], 2
	lea	eax, DWORD PTR $T254704[esp+68]
	jg	SHORT $LN210@FindTarget
	lea	eax, DWORD PTR _iNumRemainingSpies$[esp+68]
$LN210@FindTarget:
	mov	edi, DWORD PTR [eax]

; 4856 : 		iNumDiplomats = min(iNumDiplomats, m_pPlayer->GetCulture()->GetMaxPropagandaDiplomatsWanted());

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _iNumDiplomats$225614[esp+68], edi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetMaxPropagandaDiplomatsWanted@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetMaxPropagandaDiplomatsWanted
	mov	DWORD PTR $T254705[esp+68], eax
	cmp	eax, edi
	lea	eax, DWORD PTR $T254705[esp+68]
	jl	SHORT $LN214@FindTarget
	lea	eax, DWORD PTR _iNumDiplomats$225614[esp+68]
$LN214@FindTarget:
	mov	eax, DWORD PTR [eax]

; 4857 : 		*piTargetDiplomatSpies = iNumDiplomats;

	mov	ecx, DWORD PTR _piTargetDiplomatSpies$[esp+64]
	mov	DWORD PTR [ecx], eax

; 4858 : 
; 4859 : 		if (iNumDiplomats > 0)

	test	eax, eax
	jle	SHORT $LN371@FindTarget

; 4860 : 		{
; 4861 : 			bAllocatedDiplomatSpies = true;
; 4862 : 			iNumRemainingSpies -= *piTargetDiplomatSpies;

	sub	esi, eax

; 4863 : 		}
; 4864 : 	}

	jmp	SHORT $LN371@FindTarget
$LN23@FindTarget:

; 4865 : 	else if (pDiploAI->IsGoingForSpaceshipVictory())

	mov	ecx, edi
	call	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForSpaceshipVictory
	test	al, al
	je	SHORT $LN20@FindTarget

; 4866 : 	{
; 4867 : 		// assign none to CS
; 4868 : 		*piTargetCityStateSpies = 0;

	mov	edx, DWORD PTR _piTargetCityStateSpies$[esp+64]
	mov	DWORD PTR [edx], 0

; 4869 : 		bAllocatedCityStateSpies = true;
; 4870 : 	}
; 4871 : 	else

	jmp	SHORT $LN371@FindTarget
$LN20@FindTarget:

; 4872 : 	{
; 4873 : 		// assign 1/3rd to CS
; 4874 : 		*piTargetCityStateSpies = iNumRemainingSpies / 3;

	mov	ecx, DWORD PTR _piTargetCityStateSpies$[esp+64]
	mov	eax, 1431655766				; 55555556H
	imul	esi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [ecx], eax
$LN371@FindTarget:

; 4875 : 		bAllocatedCityStateSpies = true;
; 4876 : 	}
; 4877 : 
; 4878 : 	iNumRemainingSpies -= *piTargetCityStateSpies;

	mov	edx, DWORD PTR _piTargetCityStateSpies$[esp+64]
	sub	esi, DWORD PTR [edx]

; 4879 : 	if (!bAllocatedOffensiveSpies)

	cmp	BYTE PTR _bAllocatedOffensiveSpies$[esp+68], 0
	mov	DWORD PTR _iNumRemainingSpies$[esp+68], esi
	jne	SHORT $LN18@FindTarget

; 4880 : 	{
; 4881 : 		*piTargetOffensiveSpies = (int)ceil(fTechPositionRatio * iNumRemainingSpies);

	fild	DWORD PTR _iNumRemainingSpies$[esp+68]
	sub	esp, 8
	fmul	DWORD PTR _fTechPositionRatio$[esp+76]
	fstp	DWORD PTR $T255095[esp+72]
	fld	DWORD PTR $T255095[esp+72]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__ceil
	fstp	DWORD PTR tv1577[esp+72]
	add	esp, 8
	fld	DWORD PTR tv1577[esp+64]
	fstp	DWORD PTR $T255090[esp+64]
	mov	eax, DWORD PTR $T255090[esp+64]
	mov	DWORD PTR $T255096[esp+64], eax
	fld	DWORD PTR $T255096[esp+64]
	call	__ftol2_sse_excpt
	mov	ecx, DWORD PTR _piTargetOffensiveSpies$[esp+64]
	mov	DWORD PTR [ecx], eax

; 4882 : 		bAllocatedOffensiveSpies = true;
; 4883 : 		iNumRemainingSpies -= *piTargetOffensiveSpies;

	sub	esi, eax
$LN18@FindTarget:

; 4884 : 	}
; 4885 : 
; 4886 : 	*piTargetDefensiveSpies = iNumRemainingSpies;

	mov	ebx, DWORD PTR _piTargetDefensiveSpies$[esp+64]

; 4887 : 	bAllocatedDefensiveSpies = true;
; 4888 : 
; 4889 : 	// rationalization
; 4890 : 	std::vector<CvCity*> apOtherCityList;

	xor	edi, edi
	mov	DWORD PTR [ebx], esi
	mov	DWORD PTR _apOtherCityList$[esp+72], edi
	mov	DWORD PTR _apOtherCityList$[esp+76], edi
	mov	DWORD PTR _apOtherCityList$[esp+80], edi
	mov	DWORD PTR __$EHRec$[esp+76], edi

; 4891 : 	CvCity* pLoopCity = NULL;
; 4892 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[esp+68], edi

; 4893 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$225630[esp+64], edi
	xor	ebp, ebp
$LL17@FindTarget:

; 4894 : 	{
; 4895 : 		PlayerTypes eTargetPlayer = (PlayerTypes)ui;
; 4896 : 
; 4897 : 		// don't count the player's own cities
; 4898 : 		if(eTargetPlayer == m_pPlayer->GetID())

	mov	edx, DWORD PTR _this$[esp+68]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$225630[esp+64]
	cmp	ecx, DWORD PTR [eax+44]
	je	$LN16@FindTarget

; 4899 : 		{
; 4900 : 			continue;
; 4901 : 		}
; 4902 : 
; 4903 : 		for(pLoopCity = GET_PLAYER(eTargetPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eTargetPlayer).nextCity(&iLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+72]
	lea	ecx, DWORD PTR [edx+ebp]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	mov	DWORD PTR _pLoopCity$[esp+64], esi
	test	esi, esi
	je	$LN16@FindTarget
	npad	4
$LL13@FindTarget:

; 4904 : 		{
; 4905 : 			CvPlot* pCityPlot = pLoopCity->plot();

	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 4906 : 			CvAssertMsg(pCityPlot, "City plot is null!");
; 4907 : 			if(pCityPlot)

	test	eax, eax
	je	$LN12@FindTarget

; 4908 : 			{
; 4909 : 				if(pCityPlot->isRevealed(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR _this$[esp+68]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN268@FindTarget
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN269@FindTarget
$LN268@FindTarget:
	or	ecx, -1
$LN269@FindTarget:
	mov	edx, ecx
	shr	edx, 5
	mov	ebx, edx
	shl	ebx, 5
	sub	ecx, ebx
	mov	ebx, 1
	shl	ebx, cl
	test	ebx, DWORD PTR [eax+edx*4+8]
	je	SHORT $LN368@FindTarget

; 4910 : 				{
; 4911 : 					apOtherCityList.push_back(pLoopCity);

	mov	ecx, DWORD PTR _apOtherCityList$[esp+72]
	test	ecx, ecx
	jne	SHORT $LN285@FindTarget
	xor	eax, eax
	jmp	SHORT $LN286@FindTarget
$LN285@FindTarget:
	mov	eax, DWORD PTR _apOtherCityList$[esp+80]
	sub	eax, ecx
	sar	eax, 2
$LN286@FindTarget:
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN278@FindTarget
	mov	DWORD PTR [edi], esi
	add	edi, 4
	mov	DWORD PTR _apOtherCityList$[esp+76], edi
	jmp	SHORT $LN368@FindTarget
$LN278@FindTarget:
	lea	eax, DWORD PTR _pLoopCity$[esp+64]
	push	eax
	push	1
	push	edi
	lea	ecx, DWORD PTR _apOtherCityList$[esp+80]
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
	mov	edi, DWORD PTR _apOtherCityList$[esp+76]
$LN368@FindTarget:
	mov	ebx, DWORD PTR _piTargetDefensiveSpies$[esp+64]
$LN12@FindTarget:

; 4899 : 		{
; 4900 : 			continue;
; 4901 : 		}
; 4902 : 
; 4903 : 		for(pLoopCity = GET_PLAYER(eTargetPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eTargetPlayer).nextCity(&iLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+72]
	add	ecx, ebp
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	mov	DWORD PTR _pLoopCity$[esp+64], esi
	test	esi, esi
	jne	$LL13@FindTarget
$LN16@FindTarget:

; 4893 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	inc	DWORD PTR _ui$225630[esp+64]
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 1391192				; 00153a58H
	jb	$LL17@FindTarget

; 4912 : 				}
; 4913 : 			}
; 4914 : 		}
; 4915 : 	}
; 4916 : 
; 4917 : 	while(*piTargetDefensiveSpies > m_pPlayer->getNumCities())

	mov	eax, DWORD PTR _this$[esp+68]
	mov	ecx, DWORD PTR [eax]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	DWORD PTR [ebx], eax
	mov	ebp, DWORD PTR _piTargetOffensiveSpies$[esp+64]
	jle	SHORT $LN357@FindTarget
	mov	esi, edi
	sub	esi, DWORD PTR _apOtherCityList$[esp+72]
	sar	esi, 2
	npad	1
$LL8@FindTarget:

; 4918 : 	{
; 4919 : 		if(*piTargetOffensiveSpies < (int)apOtherCityList.size())

	cmp	DWORD PTR [ebp], esi
	jge	SHORT $LN6@FindTarget

; 4920 : 		{
; 4921 : 			(*piTargetDefensiveSpies)--;

	dec	DWORD PTR [ebx]

; 4922 : 			(*piTargetOffensiveSpies)++;

	inc	DWORD PTR [ebp]

; 4923 : 		}
; 4924 : 		else

	jmp	SHORT $LN5@FindTarget
$LN6@FindTarget:

; 4925 : 		{
; 4926 : 			// spies will be unused
; 4927 : 			(*piTargetDefensiveSpies)--;

	dec	DWORD PTR [ebx]
$LN5@FindTarget:

; 4912 : 				}
; 4913 : 			}
; 4914 : 		}
; 4915 : 	}
; 4916 : 
; 4917 : 	while(*piTargetDefensiveSpies > m_pPlayer->getNumCities())

	mov	ecx, DWORD PTR _this$[esp+68]
	mov	ecx, DWORD PTR [ecx]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	DWORD PTR [ebx], eax
	jg	SHORT $LL8@FindTarget
$LN357@FindTarget:

; 4928 : 		}
; 4929 : 	}
; 4930 : 
; 4931 : 	while(*piTargetOffensiveSpies > (int)apOtherCityList.size())

	sub	edi, DWORD PTR _apOtherCityList$[esp+72]
	sar	edi, 2
	cmp	DWORD PTR [ebp], edi
	jle	SHORT $LN3@FindTarget
	npad	7
$LL4@FindTarget:

; 4932 : 	{
; 4933 : 		if(*piTargetDefensiveSpies < m_pPlayer->getNumCities())

	mov	edx, DWORD PTR _this$[esp+68]
	mov	ecx, DWORD PTR [edx]
	mov	esi, DWORD PTR [ebx]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	esi, eax
	jge	SHORT $LN2@FindTarget

; 4934 : 		{
; 4935 : 			(*piTargetDefensiveSpies)++;

	inc	esi
	mov	DWORD PTR [ebx], esi
$LN2@FindTarget:

; 4936 : 			(*piTargetOffensiveSpies)--;
; 4937 : 		}
; 4938 : 		else
; 4939 : 		{
; 4940 : 			// spies will be unused
; 4941 : 			(*piTargetOffensiveSpies)--;

	dec	DWORD PTR [ebp]
	cmp	DWORD PTR [ebp], edi
	jg	SHORT $LL4@FindTarget
$LN3@FindTarget:

; 4942 : 		}
; 4943 : 	}
; 4944 : }

	cmp	DWORD PTR _apOtherCityList$[esp+72], 0
	pop	ebp
	je	SHORT $LN347@FindTarget
	mov	eax, DWORD PTR _apOtherCityList$[esp+68]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN347@FindTarget:
	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z$0:
	lea	ecx, DWORD PTR _apOtherCityList$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__ehhandler$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z ENDP	; CvEspionageAI::FindTargetSpyNumbers
PUBLIC	?push_back@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXABUHeistLocation@@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXABUHeistLocation@@@Z
_TEXT	SEGMENT
$T255703 = -4						; size = 1
__Cat$255706 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXABUHeistLocation@@@Z PROC ; std::vector<HeistLocation,std::allocator<HeistLocation> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@7
	xor	eax, eax
	jmp	SHORT $LN10@push_back@7
$LN9@push_back@7:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@7:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@7

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$255706[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T255703[esp+12], 0
	mov	eax, DWORD PTR $T255703[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@7:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXABUHeistLocation@@@Z ENDP ; std::vector<HeistLocation,std::allocator<HeistLocation> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXABUSpyNotificationMessage@@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXABUSpyNotificationMessage@@@Z
_TEXT	SEGMENT
$T255851 = -4						; size = 1
__Cat$255854 = 8					; size = 1
$T255820 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXABUSpyNotificationMessage@@@Z PROC ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@8
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@8
$LN9@push_back@8:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@8:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@8

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$255854[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T255851[esp+16], 0
	mov	ecx, DWORD PTR $T255851[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUSpyNotificationMessage@@IU1@V?$allocator@USpyNotificationMessage@@@std@@@std@@YAXPAUSpyNotificationMessage@@IABU1@AAV?$allocator@USpyNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<SpyNotificationMessage *,unsigned int,SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
	add	esp, 24					; 00000018H
	add	edi, 20					; 00000014H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@8:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T255820[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@2@ABUSpyNotificationMessage@@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXABUSpyNotificationMessage@@@Z ENDP ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::push_back
_TEXT	ENDS
PUBLIC	??1?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Tidy
??1?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T255884 = -4						; size = 4
?clear@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXXZ PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T255884[esp+12]
	push	eax
	call	?erase@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXXZ ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEXABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEXABUScoreCityEntry@@@Z
_TEXT	SEGMENT
$T255953 = -4						; size = 1
__Cat$255956 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEXABUScoreCityEntry@@@Z PROC ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@9
	xor	eax, eax
	jmp	SHORT $LN10@push_back@9
$LN9@push_back@9:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@9:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@9

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$255956[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T255953[esp+12], 0
	mov	eax, DWORD PTR $T255953[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@9:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEXABUScoreCityEntry@@@Z ENDP ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$2
__catchsym$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$10
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$11
__unwindtable$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
__Tmp$227983 = -84					; size = 68
__$EHRec$ = -16						; size = 16
__Tmp$227973 = 0					; size = 68
__Whereoff$227959 = 68					; size = 4
__Ncopied$227960 = 72					; size = 4
_this$ = 76						; size = 4
__Newvec$227958 = 80					; size = 4
__Capacity$ = 84					; size = 4
__Cat$256272 = 96					; size = 1
__Cat$256200 = 96					; size = 1
__Where$ = 96						; size = 4
tv525 = 100						; size = 4
__Count$ = 100						; size = 4
$T256269 = 104						; size = 1
$T256196 = 104						; size = 1
__Val$ = 104						; size = 4
?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	lea	ebp, DWORD PTR [esp-88]
	sub	esp, 88					; 00000058H
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@6
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@6
$LN31@Insert_n@6:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@6:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@6

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 63161283				; 03c3c3c3H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@KAXXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Xlen
$LN107@Insert_n@6:
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 63161283				; 03c3c3c3H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@6:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UIntrigueNotificationMessage@@@std@@YAPAUIntrigueNotificationMessage@@IPAU1@@Z ; std::_Allocate<IntrigueNotificationMessage>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Ncopied$227960[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	add	esp, 8
	mov	eax, ebx
	shl	eax, 4
	push	edx
	mov	DWORD PTR __Newvec$227958[ebp], ecx
	add	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$227959[ebp], ebx
	call	?_Ufill@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU3@IABU3@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$256200[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T256196[ebp], 0
	mov	edx, DWORD PTR $T256196[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$227958[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$227960[ebp], 1
	call	??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$227958[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	mov	edx, ebx
	shl	edx, 4
	add	edx, ebx
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T256269[ebp], 0
	mov	edx, DWORD PTR $T256269[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$256272[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$227960[ebp], 2
	call	??$_Uninit_copy@PAUIntrigueNotificationMessage@@PAU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAPAUIntrigueNotificationMessage@@PAU1@00AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<IntrigueNotificationMessage *,IntrigueNotificationMessage *,std::allocator<IntrigueNotificationMessage> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN83@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, eax
	shl	ecx, 4
	add	ecx, eax
	mov	eax, DWORD PTR __Newvec$227958[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, edi
	shl	ecx, 4
	add	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax
	jmp	$LN1@Insert_n@6
__catch$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$227960[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$227959[ebp]
	mov	edi, DWORD PTR __Newvec$227958[ebp]
	jle	SHORT $LN7@Insert_n@6
	mov	eax, esi
	shl	eax, 4
	add	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Destroy
$LN7@Insert_n@6:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@6

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	mov	ecx, eax
	shl	ecx, 4
	add	ecx, eax
	mov	eax, esi
	lea	edx, DWORD PTR [edi+ecx*4]
	shl	eax, 4
	add	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Destroy
$LN6@Insert_n@6:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN108@Insert_n@6:
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, 2021161081				; 78787879H
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$227973[ebp]
	call	??0IntrigueNotificationMessage@@QAE@ABU0@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, edi
	shl	ebx, 4
	add	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAUIntrigueNotificationMessage@@@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU2@00@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Umove<IntrigueNotificationMessage *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR __Tmp$227973[ebp]
	push	edx
	mov	edx, ecx
	sub	edx, DWORD PTR __Where$[ebp]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU3@IABU3@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$227973[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z ; std::_Fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$227973[ebp+36]

; 1233 : 		else

	jmp	$LN106@Insert_n@6
__catch$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, ecx
	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXPAUIntrigueNotificationMessage@@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN109@Insert_n@6:
$LN3@Insert_n@6:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$227983[ebp]
	call	??0IntrigueNotificationMessage@@QAE@ABU0@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ebx, edi
	shl	ebx, 4
	add	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAUIntrigueNotificationMessage@@@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEPAUIntrigueNotificationMessage@@PAU2@00@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Umove<IntrigueNotificationMessage *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUIntrigueNotificationMessage@@PAU1@@stdext@@YAPAUIntrigueNotificationMessage@@PAU1@00@Z ; stdext::_Unchecked_move_backward<IntrigueNotificationMessage *,IntrigueNotificationMessage *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$227983[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$_Fill@PAUIntrigueNotificationMessage@@U1@@std@@YAXPAUIntrigueNotificationMessage@@0ABU1@@Z ; std::_Fill<IntrigueNotificationMessage *,IntrigueNotificationMessage>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$227983[ebp+36]
$LN106@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Insert_n@6:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	ebp, 88					; 00000058H
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN105@Insert_n@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$227973[ebp]
	jmp	??1IntrigueNotificationMessage@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$227983[ebp]
	jmp	??1IntrigueNotificationMessage@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Insert_n
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+40]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>

; 3565 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+64]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN24@Stable_sor@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Stable_sor@3:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@XZ ; std::_Temp_iterator<ScoreCityEntry>::~_Temp_iterator<ScoreCityEntry>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+40]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0HAAV?$_Temp_iterator@UScoreCityEntry@@@0@UScoreCityEntryLowEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>

; 3565 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+64]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN24@Stable_sor@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Stable_sor@4:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UScoreCityEntry@@@std@@QAE@XZ ; std::_Temp_iterator<ScoreCityEntry>::~_Temp_iterator<ScoreCityEntry>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
PUBLIC	?Reset@CvPlayerEspionage@@QAEXXZ		; CvPlayerEspionage::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
;	COMDAT ?Reset@CvPlayerEspionage@@QAEXXZ
_TEXT	SEGMENT
$T256775 = -4						; size = 4
?Reset@CvPlayerEspionage@@QAEXXZ PROC			; CvPlayerEspionage::Reset, COMDAT
; _this$ = ecx

; 168  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 169  : 	m_pPlayer = NULL;

	xor	ebp, ebp
	mov	DWORD PTR [esi+1296], ebp

; 170  : 	m_aSpyList.clear();

	mov	DWORD PTR [esi+8], ebp

; 171  : 	m_aiSpyListNameOrder.clear();

	mov	ecx, DWORD PTR [esi+252]
	push	edi
	mov	edi, DWORD PTR [esi+248]
	cmp	edi, ecx
	je	SHORT $LN28@Reset@3
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, ebp
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+edi]
	jle	SHORT $LN53@Reset@3
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN53@Reset@3:
	mov	DWORD PTR [esi+252], ebx
$LN28@Reset@3:

; 172  : 	m_iSpyListNameOrderIndex = -1;

	mov	DWORD PTR [esi+260], -1

; 173  : 	m_aiNumTechsToStealList.clear();
; 174  : 	m_aIntrigueNotificationMessages.clear();

	lea	ecx, DWORD PTR [esi+1280]
	mov	DWORD PTR [esi+724], ebp
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T256775[esp+28]
	push	eax
	call	?erase@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@0@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::erase

; 175  : 	m_aaPlayerStealableTechList.clear();

	lea	ecx, DWORD PTR [esi+264]
	call	?clear@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@QAEXXZ ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::clear
	lea	edi, DWORD PTR [esi+824]
	add	esi, 920				; 00000398H
	mov	ebx, 22					; 00000016H
	npad	2
$LL3@Reset@3:

; 177  : 	{
; 178  : 		m_aiMaxTechCost[ui] = -1;

	mov	DWORD PTR [edi], -1

; 179  : 		m_aHeistLocations[ui].clear();

	mov	ecx, DWORD PTR [esi-4]
	mov	edx, DWORD PTR [esi]
	cmp	ecx, edx
	je	SHORT $LN2@Reset@3
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN121@Reset@3
$LL123@Reset@3:
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL123@Reset@3
$LN121@Reset@3:
	mov	DWORD PTR [esi], ecx
$LN2@Reset@3:

; 176  : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	add	edi, 4
	add	esi, 16					; 00000010H
	sub	ebx, 1
	jne	SHORT $LL3@Reset@3
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 180  : 	}
; 181  : }

	pop	ecx
	ret	0
?Reset@CvPlayerEspionage@@QAEXXZ ENDP			; CvPlayerEspionage::Reset
_TEXT	ENDS
PUBLIC	?AddSpyMessage@CvPlayerEspionage@@QAEXHHW4PlayerTypes@@HW4TechTypes@@@Z ; CvPlayerEspionage::AddSpyMessage
; Function compile flags: /Ogtpy
;	COMDAT ?AddSpyMessage@CvPlayerEspionage@@QAEXHHW4PlayerTypes@@HW4TechTypes@@@Z
_TEXT	SEGMENT
_kMessage$ = -20					; size = 20
_iCityX$ = 8						; size = 4
_iCityY$ = 12						; size = 4
_eAttackingPlayer$ = 16					; size = 4
_iSpyResult$ = 20					; size = 4
_eStolenTech$ = 24					; size = 4
?AddSpyMessage@CvPlayerEspionage@@QAEXHHW4PlayerTypes@@HW4TechTypes@@@Z PROC ; CvPlayerEspionage::AddSpyMessage, COMDAT
; _this$ = ecx

; 2404 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 2405 : 	// go through all messages to see if this is an update
; 2406 : 	for(uint ui = 0; ui < m_aSpyNotificationMessages.size(); ui++)

	mov	ebx, DWORD PTR _eAttackingPlayer$[esp+24]
	push	esi
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [edi+1272]
	sub	edx, DWORD PTR [edi+1268]
	lea	ecx, DWORD PTR [edi+1264]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	esi, esi
	add	eax, edx
	je	SHORT $LN2@AddSpyMess
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [edi+1268]
$LL24@AddSpyMess:

; 2407 : 	{
; 2408 : 		if(m_aSpyNotificationMessages[ui].m_iCityX == iCityX && m_aSpyNotificationMessages[ui].m_iCityY == iCityY && m_aSpyNotificationMessages[ui].m_eAttackingPlayer == eAttackingPlayer)

	mov	ebp, DWORD PTR _iCityX$[esp+32]
	cmp	DWORD PTR [edx], ebp
	jne	SHORT $LN3@AddSpyMess
	mov	ebp, DWORD PTR [edx+4]
	cmp	ebp, DWORD PTR _iCityY$[esp+32]
	jne	SHORT $LN3@AddSpyMess
	cmp	DWORD PTR [edx+8], ebx
	je	SHORT $LN20@AddSpyMess
$LN3@AddSpyMess:

; 2405 : 	// go through all messages to see if this is an update
; 2406 : 	for(uint ui = 0; ui < m_aSpyNotificationMessages.size(); ui++)

	inc	esi
	add	edx, 20					; 00000014H
	cmp	esi, eax
	jb	SHORT $LL24@AddSpyMess
$LN2@AddSpyMess:

; 2412 : 			// found the appropriate message, now leaving the function
; 2413 : 			return;
; 2414 : 		}
; 2415 : 	}
; 2416 : 
; 2417 : 	// no matching message found so adding it to the back of the list
; 2418 : 	SpyNotificationMessage kMessage;
; 2419 : 	kMessage.m_iCityX = iCityX;

	mov	eax, DWORD PTR _iCityX$[esp+32]

; 2420 : 	kMessage.m_iCityY = iCityY;

	mov	edx, DWORD PTR _iCityY$[esp+32]
	mov	DWORD PTR _kMessage$[esp+36], eax

; 2421 : 	kMessage.m_eAttackingPlayer = eAttackingPlayer;
; 2422 : 	kMessage.m_iSpyResult = iSpyResult;

	mov	eax, DWORD PTR _iSpyResult$[esp+32]
	mov	DWORD PTR _kMessage$[esp+48], eax
	mov	DWORD PTR _kMessage$[esp+40], edx

; 2423 : 	kMessage.m_eStolenTech = eStolenTech;

	mov	edx, DWORD PTR _eStolenTech$[esp+32]

; 2424 : 	m_aSpyNotificationMessages.push_back(kMessage);

	lea	eax, DWORD PTR _kMessage$[esp+36]
	push	eax
	mov	DWORD PTR _kMessage$[esp+48], ebx
	mov	DWORD PTR _kMessage$[esp+56], edx
	call	?push_back@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXABUSpyNotificationMessage@@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::push_back
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2425 : }

	add	esp, 20					; 00000014H
	ret	20					; 00000014H
$LN20@AddSpyMess:

; 2409 : 		{
; 2410 : 			m_aSpyNotificationMessages[ui].m_iSpyResult = iSpyResult;

	mov	ecx, DWORD PTR [edi+1268]
	mov	edx, DWORD PTR _iSpyResult$[esp+32]
	lea	eax, DWORD PTR [esi+esi*4]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR [ecx+eax+12], edx

; 2411 : 			m_aSpyNotificationMessages[ui].m_eStolenTech = eStolenTech;

	mov	ecx, DWORD PTR [edi+1268]
	mov	edx, DWORD PTR _eStolenTech$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+eax+16], edx
	pop	ebx

; 2425 : }

	add	esp, 20					; 00000014H
	ret	20					; 00000014H
?AddSpyMessage@CvPlayerEspionage@@QAEXHHW4PlayerTypes@@HW4TechTypes@@@Z ENDP ; CvPlayerEspionage::AddSpyMessage
_TEXT	ENDS
PUBLIC	?StealTechnology@CvEspionageAI@@QAEXXZ		; CvEspionageAI::StealTechnology
EXTRN	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z:PROC ; CvTeamTechs::SetNoTradeTech
EXTRN	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:PROC ; CvTeam::setHasTech
; Function compile flags: /Ogtpy
;	COMDAT ?StealTechnology@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
_uiDefendingPlayer$225484 = -28				; size = 4
tv670 = -24						; size = 4
tv720 = -20						; size = 4
tv693 = -16						; size = 4
tv689 = -12						; size = 4
_this$ = -8						; size = 4
_pEspionage$ = -4					; size = 4
?StealTechnology@CvEspionageAI@@QAEXXZ PROC		; CvEspionageAI::StealTechnology, COMDAT
; _this$ = ecx

; 4594 : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+40], ecx

; 4595 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ecx]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ebx, eax

; 4596 : 
; 4597 : 	// try to steal technologies
; 4598 : 	for(uint uiDefendingPlayer = 0; uiDefendingPlayer < MAX_MAJOR_CIVS; uiDefendingPlayer++)

	xor	eax, eax
	xor	ebp, ebp
	lea	ecx, DWORD PTR [ebx+916]
	mov	DWORD PTR _pEspionage$[esp+44], ebx
	mov	DWORD PTR _uiDefendingPlayer$225484[esp+44], eax
	mov	DWORD PTR tv689[esp+44], eax
	mov	DWORD PTR tv693[esp+44], ebp
	mov	DWORD PTR tv720[esp+44], ecx
$LL11@StealTechn:

; 4602 : 		while(pEspionage->m_aiNumTechsToStealList[uiDefendingPlayer] > 0)

	mov	edx, DWORD PTR [ebx+720]
	mov	ecx, DWORD PTR _uiDefendingPlayer$225484[esp+44]
	cmp	DWORD PTR [edx+ecx*4], eax
	jle	$LN10@StealTechn

; 4599 : 	{
; 4600 : 		PlayerTypes eDefendingPlayer = (PlayerTypes)uiDefendingPlayer;
; 4601 : 		int iHeistLocationCounter = 0;

	mov	DWORD PTR tv670[esp+44], eax
	npad	7
$LL8@StealTechn:

; 4603 : 		{
; 4604 : 			// steal a tech
; 4605 : 			CvAssertMsg(pEspionage->m_aaPlayerStealableTechList[uiDefendingPlayer].size() > 0, "pEspionage->m_aaPlayerStealableTechList[uiPlayer] list is empty. Not good");
; 4606 : 			TeamTypes eTeam = m_pPlayer->getTeam();

	mov	edx, DWORD PTR _this$[esp+44]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN20@StealTechn
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN21@StealTechn
$LN20@StealTechn:
	or	esi, -1
$LN21@StealTechn:

; 4607 : 			TechTypes eStolenTech = pEspionage->m_aaPlayerStealableTechList[uiDefendingPlayer][0];

	mov	ecx, DWORD PTR [ebx+264]

; 4608 : 			GET_TEAM(eTeam).setHasTech(eStolenTech, true, m_pPlayer->GetID(), true, true);

	imul	esi, 2980				; 00000ba4H
	mov	edx, DWORD PTR [ecx+ebp]
	mov	edi, DWORD PTR [edx]
	push	1
	push	1
	push	eax
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	edi
	lea	ecx, DWORD PTR [esi+eax]
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech

; 4609 : 			GET_TEAM(eTeam).GetTeamTechs()->SetNoTradeTech(eStolenTech, true);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	add	ecx, esi
	push	edi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech

; 4610 : 
; 4611 : 			// send out notifications to the parties that were stolen from
; 4612 : 			CvPlot* pPlot = GC.getMap().plot(pEspionage->m_aHeistLocations[uiDefendingPlayer][iHeistLocationCounter].m_iX, pEspionage->m_aHeistLocations[uiDefendingPlayer][iHeistLocationCounter].m_iY);

	mov	edx, DWORD PTR tv720[esp+44]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv670[esp+44]
	mov	esi, DWORD PTR [eax+ecx+4]
	add	eax, ecx
	mov	eax, DWORD PTR [eax]
	cmp	eax, -2147483647			; 80000001H
	je	$LN3@StealTechn
	cmp	esi, -2147483647			; 80000001H
	je	$LN3@StealTechn
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN57@StealTechn
	test	eax, eax
	jge	SHORT $LN59@StealTechn
	cdq
	idiv	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ebx, ecx
	jmp	SHORT $LN61@StealTechn
$LN59@StealTechn:
	cmp	eax, ecx
	jl	SHORT $LN57@StealTechn
	cdq
	idiv	ecx
	mov	ebx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN61@StealTechn
$LN57@StealTechn:
	mov	ebx, eax
$LN61@StealTechn:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebp, DWORD PTR [edx+4024]
	je	SHORT $LN124@StealTechn
	test	esi, esi
	jge	SHORT $LN69@StealTechn
	mov	eax, esi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN71@StealTechn
$LN69@StealTechn:
	cmp	esi, ebp
	jl	SHORT $LN124@StealTechn
	mov	eax, esi
	cdq
	idiv	ebp
	jmp	SHORT $LN71@StealTechn
$LN124@StealTechn:
	mov	edx, esi
$LN71@StealTechn:
	test	ebx, ebx
	jl	$LN125@StealTechn
	cmp	ebx, ecx
	jge	$LN125@StealTechn
	test	edx, edx
	jl	$LN125@StealTechn
	cmp	edx, ebp
	jge	$LN125@StealTechn
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, ebx
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]

; 4613 : 			CvAssertMsg(pPlot, "Could not find plot location for HeistLocation");
; 4614 : 			if(pPlot)

	test	ecx, ecx
	je	SHORT $LN125@StealTechn

; 4615 : 			{
; 4616 : 				CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN125@StealTechn
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN125@StealTechn
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 4617 : 				CvAssertMsg(pCity, "Plot does not contain a city");
; 4618 : 				if(pCity)

	test	esi, esi
	je	SHORT $LN125@StealTechn

; 4619 : 				{
; 4620 : 					CvAssertMsg(pCity->getOwner() == uiDefendingPlayer, "City does not belong to player. This is very strange");
; 4621 : 					CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	ebx, eax

; 4622 : 					CvAssertMsg(pCityEspionage, "City did not have CityEspionage data");
; 4623 : 					if(pCityEspionage)

	test	ebx, ebx
	je	SHORT $LN125@StealTechn

; 4624 : 					{
; 4625 : 						CvPlayerEspionage* pDefendingPlayerEspionage = GET_PLAYER(eDefendingPlayer).GetEspionage();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv689[esp+44]
	lea	ecx, DWORD PTR [eax+edx]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage

; 4626 : 						if(pDefendingPlayerEspionage)

	test	eax, eax
	je	SHORT $LN125@StealTechn

; 4627 : 						{
; 4628 : 							pDefendingPlayerEspionage->AddSpyMessage(pCity->getX(), pCity->getY(), m_pPlayer->GetID(), pCityEspionage->m_aiResult[m_pPlayer->GetID()], eStolenTech);

	mov	ecx, DWORD PTR _this$[esp+44]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ebx+edx*4+620]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi+96]
	push	edx
	mov	edx, DWORD PTR [esi+108]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?AddSpyMessage@CvPlayerEspionage@@QAEXHHW4PlayerTypes@@HW4TechTypes@@@Z ; CvPlayerEspionage::AddSpyMessage
$LN125@StealTechn:
	mov	ebp, DWORD PTR tv693[esp+44]
	mov	ebx, DWORD PTR _pEspionage$[esp+44]
$LN3@StealTechn:

; 4629 : 						}
; 4630 : 					}
; 4631 : 				}
; 4632 : 			}
; 4633 : 			iHeistLocationCounter++;
; 4634 : 
; 4635 : 			// recalculate the num techs to steal list
; 4636 : 			pEspionage->BuildStealableTechList((PlayerTypes)uiDefendingPlayer);

	mov	esi, DWORD PTR _uiDefendingPlayer$225484[esp+44]
	add	DWORD PTR tv670[esp+44], 8
	push	esi
	mov	ecx, ebx
	call	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ; CvPlayerEspionage::BuildStealableTechList

; 4637 : 			if(pEspionage->m_aaPlayerStealableTechList[uiDefendingPlayer].size() > 0 && pEspionage->m_aiNumTechsToStealList[uiDefendingPlayer] > 0)

	mov	edx, DWORD PTR [ebx+264]
	cmp	DWORD PTR [edx+ebp+4], 0
	jbe	SHORT $LN2@StealTechn
	mov	eax, DWORD PTR [ebx+720]
	cmp	DWORD PTR [eax+esi*4], 0
	lea	eax, DWORD PTR [eax+esi*4]
	jle	SHORT $LN2@StealTechn

; 4638 : 			{
; 4639 : 				pEspionage->m_aiNumTechsToStealList[uiDefendingPlayer]--;

	dec	DWORD PTR [eax]

; 4640 : 			}
; 4641 : 			else

	jmp	SHORT $LN1@StealTechn
$LN2@StealTechn:

; 4642 : 			{
; 4643 : 				pEspionage->m_aiNumTechsToStealList[uiDefendingPlayer] = 0;

	mov	ecx, DWORD PTR [ebx+720]
	mov	DWORD PTR [ecx+esi*4], 0
$LN1@StealTechn:
	mov	edx, DWORD PTR [ebx+720]
	cmp	DWORD PTR [edx+esi*4], 0
	jg	$LL8@StealTechn

; 4602 : 		while(pEspionage->m_aiNumTechsToStealList[uiDefendingPlayer] > 0)

	xor	eax, eax
$LN10@StealTechn:

; 4596 : 
; 4597 : 	// try to steal technologies
; 4598 : 	for(uint uiDefendingPlayer = 0; uiDefendingPlayer < MAX_MAJOR_CIVS; uiDefendingPlayer++)

	inc	DWORD PTR _uiDefendingPlayer$225484[esp+44]
	add	DWORD PTR tv720[esp+44], 16		; 00000010H
	add	DWORD PTR tv689[esp+44], 63236		; 0000f704H
	add	ebp, 20					; 00000014H
	mov	DWORD PTR tv693[esp+44], ebp
	cmp	ebp, 440				; 000001b8H
	jb	$LL11@StealTechn
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4644 : 			}
; 4645 : 		}
; 4646 : 	}
; 4647 : }

	add	esp, 28					; 0000001cH
	ret	0
?StealTechnology@CvEspionageAI@@QAEXXZ ENDP		; CvEspionageAI::StealTechnology
_TEXT	ENDS
PUBLIC	?insert@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@ABUIntrigueNotificationMessage@@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@ABUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@ABUIntrigueNotificationMessage@@@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@6
	xor	esi, esi
	jmp	SHORT $LN4@insert@6
$LN3@insert@6:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@6:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXV?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@IABUIntrigueNotificationMessage@@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, esi
	shl	edx, 4
	add	edx, esi
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@ABUIntrigueNotificationMessage@@@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::insert
_TEXT	ENDS
PUBLIC	??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z ; std::stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z PROC ; std::stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
	add	esp, 20					; 00000014H
$LN1@stable_sor:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryHighEval@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryHighEval>
_TEXT	ENDS
PUBLIC	??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z ; std::stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z PROC ; std::stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@2

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
	add	esp, 20					; 00000014H
$LN1@stable_sor@2:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0UScoreCityEntryLowEval@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,ScoreCityEntryLowEval>
_TEXT	ENDS
PUBLIC	??0CvPlayerEspionage@@QAE@XZ			; CvPlayerEspionage::CvPlayerEspionage
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__ehfuncinfo$??0CvPlayerEspionage@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvPlayerEspionage@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvPlayerEspionage@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlayerEspionage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlayerEspionage@@QAE@XZ PROC			; CvPlayerEspionage::CvPlayerEspionage, COMDAT
; _this$ = ecx

; 111  : {

	push	-1
	push	__ehhandler$??0CvPlayerEspionage@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	xor	edi, edi
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], 8
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi+248], edi
	mov	DWORD PTR [esi+252], edi
	mov	DWORD PTR [esi+256], edi
	lea	eax, DWORD PTR [esi+276]
	mov	ecx, 22					; 00000016H
	mov	DWORD PTR [esi+268], edi
	mov	DWORD PTR [esi+272], ecx
	mov	DWORD PTR [esi+264], eax
	lea	eax, DWORD PTR [esi+732]
	mov	DWORD PTR [esi+724], edi
	mov	DWORD PTR [esi+728], ecx
	mov	DWORD PTR [esi+720], eax
	push	OFFSET ??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::~vector<HeistLocation,std::allocator<HeistLocation> >
	push	OFFSET ??0?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::vector<HeistLocation,std::allocator<HeistLocation> >
	push	ecx
	lea	eax, DWORD PTR [esi+912]
	push	16					; 00000010H
	push	eax
	mov	BYTE PTR __$EHRec$[esp+52], 3
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	DWORD PTR [esi+1268], edi
	mov	DWORD PTR [esi+1272], edi
	mov	DWORD PTR [esi+1276], edi
	mov	DWORD PTR [esi+1284], edi
	mov	DWORD PTR [esi+1288], edi
	mov	DWORD PTR [esi+1292], edi

; 112  : 	Reset();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+32], 6
	call	?Reset@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::Reset

; 113  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvEspionageSpy,8,0,297,0>::~FStaticVector<CvEspionageSpy,8,0,297,0>
__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 244				; 000000f4H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	jmp	??1?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>
__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 720				; 000002d0H
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 912				; 00000390H
	jmp	??1?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ
__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1264				; 000004f0H
	jmp	??1?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
__unwindfunclet$??0CvPlayerEspionage@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1280				; 00000500H
	jmp	??1?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
__ehhandler$??0CvPlayerEspionage@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPlayerEspionage@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlayerEspionage@@QAE@XZ ENDP			; CvPlayerEspionage::CvPlayerEspionage
PUBLIC	??1CvPlayerEspionage@@QAE@XZ			; CvPlayerEspionage::~CvPlayerEspionage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvPlayerEspionage@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??1CvPlayerEspionage@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvPlayerEspionage@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlayerEspionage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlayerEspionage@@QAE@XZ PROC			; CvPlayerEspionage::~CvPlayerEspionage, COMDAT
; _this$ = ecx

; 117  : {

	push	-1
	push	__ehhandler$??1CvPlayerEspionage@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR __$EHRec$[esp+32], 6

; 118  : 	Reset();

	call	?Reset@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::Reset

; 119  : }

	lea	ecx, DWORD PTR [esi+1280]
	mov	BYTE PTR __$EHRec$[esp+32], 5
	call	?_Tidy@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@IAEXXZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::_Tidy
	mov	eax, DWORD PTR [esi+1268]
	xor	ebp, ebp
	cmp	eax, ebp
	je	SHORT $LN17@CvPlayerEs
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@CvPlayerEs:
	push	OFFSET ??1?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAE@XZ ; std::vector<HeistLocation,std::allocator<HeistLocation> >::~vector<HeistLocation,std::allocator<HeistLocation> >
	push	22					; 00000016H
	lea	eax, DWORD PTR [esi+912]
	push	16					; 00000010H
	push	eax
	mov	DWORD PTR [esi+1268], ebp
	mov	DWORD PTR [esi+1272], ebp
	mov	DWORD PTR [esi+1276], ebp
	mov	BYTE PTR __$EHRec$[esp+48], 3
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	eax, DWORD PTR [esi+720]
	lea	ecx, DWORD PTR [esi+732]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	cmp	eax, ecx
	je	SHORT $LN24@CvPlayerEs
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN24@CvPlayerEs:
	mov	eax, DWORD PTR [esi+268]
	push	ebx
	mov	ebx, DWORD PTR [esi+264]
	push	edi
	lea	edi, DWORD PTR [esi+264]
	push	eax
	push	ebx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+48], 1
	call	?Destroy@?$BaseVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0A@@@IAEXPAV?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@I@Z ; BaseVector<FStaticVector<enum TechTypes,1,0,297,0>,0>::Destroy
	add	edi, 12					; 0000000cH
	cmp	ebx, edi
	je	SHORT $LN38@CvPlayerEs
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN38@CvPlayerEs:
	mov	eax, DWORD PTR [esi+248]
	pop	edi
	pop	ebx
	cmp	eax, ebp
	je	SHORT $LN49@CvPlayerEs
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@CvPlayerEs:
	mov	DWORD PTR [esi+248], ebp
	mov	DWORD PTR [esi+252], ebp
	mov	DWORD PTR [esi+256], ebp
	mov	eax, DWORD PTR [esi+4]
	add	esi, 16					; 00000010H
	cmp	eax, esi
	pop	esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	ebp
	je	SHORT $LN53@CvPlayerEs
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN53@CvPlayerEs:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvEspionageSpy,8,0,297,0>::~FStaticVector<CvEspionageSpy,8,0,297,0>
__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 244				; 000000f4H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	jmp	??1?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::~FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>
__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 720				; 000002d0H
	jmp	??1?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,22,0,297,0>::~FStaticVector<int,22,0,297,0>
__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 912				; 00000390H
	jmp	??1?$Array@V?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@$0BG@@Firaxis@@QAE@XZ
__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1264				; 000004f0H
	jmp	??1?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::~vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >
__unwindfunclet$??1CvPlayerEspionage@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1280				; 00000500H
	jmp	??1?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE@XZ ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::~vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
__ehhandler$??1CvPlayerEspionage@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPlayerEspionage@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlayerEspionage@@QAE@XZ ENDP			; CvPlayerEspionage::~CvPlayerEspionage
PUBLIC	?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z	; CvPlayerEspionage::Init
EXTRN	?getNumSpyNames@CvCivilizationInfo@@QBEHXZ:PROC	; CvCivilizationInfo::getNumSpyNames
EXTRN	?isPlayable@CvCivilizationBaseInfo@@QBE_NXZ:PROC ; CvCivilizationBaseInfo::isPlayable
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z$1
__ehfuncinfo$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T258449 = -40						; size = 4
$T258444 = -36						; size = 4
_aTechList$222795 = -32					; size = 20
__$EHRec$ = -12						; size = 12
tv497 = 8						; size = 4
_i$222780 = 8						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z PROC	; CvPlayerEspionage::Init, COMDAT
; _this$ = ecx

; 123  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	esi, ecx

; 124  : 	Reset();

	call	?Reset@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::Reset

; 125  : 	m_pPlayer = pPlayer;

	mov	ecx, DWORD PTR _pPlayer$[esp+40]
	mov	DWORD PTR [esi+1296], ecx

; 126  : 
; 127  : 	// catching empty players, minor civs, and barbarians
; 128  : 	if(m_pPlayer->getCivilizationType() == NO_CIVILIZATION || !m_pPlayer->getCivilizationInfo().isPlayable())

	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	eax, -1
	je	$LN13@Init
	mov	ecx, DWORD PTR [esi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?isPlayable@CvCivilizationBaseInfo@@QBE_NXZ ; CvCivilizationBaseInfo::isPlayable
	test	al, al
	je	$LN13@Init

; 129  : 	{
; 130  : 		return;
; 131  : 	}
; 132  : 
; 133  : 	// create m_aiSpyListNameOrder list
; 134  : 	for(int i = 0; i < m_pPlayer->getCivilizationInfo().getNumSpyNames(); i++)

	mov	ecx, DWORD PTR [esi+1296]
	push	ebx
	push	ebp
	xor	ebp, ebp
	push	edi
	mov	DWORD PTR _i$222780[esp+52], ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getNumSpyNames@CvCivilizationInfo@@QBEHXZ ; CvCivilizationInfo::getNumSpyNames
	lea	ebx, DWORD PTR [ebp+1]
	test	eax, eax
	jle	SHORT $LN10@Init
	lea	edi, DWORD PTR [esi+244]
	npad	6
$LL142@Init:

; 135  : 	{
; 136  : 		m_aiSpyListNameOrder.push_back(i);

	mov	edx, DWORD PTR [edi+4]
	test	edx, edx
	jne	SHORT $LN26@Init
	xor	eax, eax
	jmp	SHORT $LN27@Init
$LN26@Init:
	mov	eax, DWORD PTR [edi+12]
	sub	eax, edx
	sar	eax, 2
$LN27@Init:
	mov	ecx, DWORD PTR [edi+8]
	mov	ebx, ecx
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, eax
	mov	ebx, 1
	jae	SHORT $LN19@Init
	mov	DWORD PTR [ecx], ebp
	add	ecx, 4
	mov	DWORD PTR [edi+8], ecx
	jmp	SHORT $LN11@Init
$LN19@Init:
	lea	eax, DWORD PTR _i$222780[esp+52]
	push	eax
	push	ebx
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN11@Init:
	mov	ecx, DWORD PTR [esi+1296]
	add	ebp, ebx
	mov	DWORD PTR _i$222780[esp+52], ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getNumSpyNames@CvCivilizationInfo@@QBEHXZ ; CvCivilizationInfo::getNumSpyNames
	cmp	ebp, eax
	jl	SHORT $LL142@Init
$LN10@Init:

; 137  : 	}
; 138  : 
; 139  : 	for(uint ui = 0; ui < m_aiSpyListNameOrder.size(); ui++)

	mov	ecx, DWORD PTR [esi+252]
	sub	ecx, DWORD PTR [esi+248]
	xor	edi, edi
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN7@Init
	npad	1
$LL9@Init:

; 140  : 	{
; 141  : 		uint uiTempValue;
; 142  : 		uint uiTargetSlot = GC.getGame().getJonRandNum(m_aiSpyListNameOrder.size(), "Randomizing m_aiSpyListNameOrder list");

	mov	eax, DWORD PTR [esi+252]
	sub	eax, DWORD PTR [esi+248]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sar	eax, 2
	push	OFFSET $SG222790
	push	eax
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 143  : 		uiTempValue = m_aiSpyListNameOrder[ui];

	mov	ecx, DWORD PTR [esi+248]
	mov	edx, DWORD PTR [ecx+edi*4]

; 144  : 		m_aiSpyListNameOrder[ui] = m_aiSpyListNameOrder[uiTargetSlot];

	mov	ebp, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+edi*4], ebp

; 145  : 		m_aiSpyListNameOrder[uiTargetSlot] = uiTempValue;

	mov	ecx, DWORD PTR [esi+248]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	edx, DWORD PTR [esi+252]
	sub	edx, DWORD PTR [esi+248]
	add	edi, ebx
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LL9@Init
$LN7@Init:

; 146  : 	}
; 147  : 	m_iSpyListNameOrderIndex = 0;

	xor	ebp, ebp
	lea	edi, DWORD PTR [esi+264]
	mov	DWORD PTR [esi+260], ebp

; 150  : 	{
; 151  : 		TechList aTechList;
; 152  : 		m_aaPlayerStealableTechList.push_back(aTechList);

	mov	DWORD PTR $T258449[esp+56], edi
	mov	DWORD PTR tv497[esp+52], 22		; 00000016H
	npad	9
$LL6@Init:
	lea	eax, DWORD PTR _aTechList$222795[esp+68]
	mov	DWORD PTR _aTechList$222795[esp+60], ebp
	mov	DWORD PTR _aTechList$222795[esp+64], ebx
	mov	DWORD PTR _aTechList$222795[esp+56], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __$EHRec$[esp+64], ebp
	mov	BYTE PTR [edi+452], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN101@Init
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::GrowSize
$LN101@Init:
	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T258444[esp+56], ecx
	mov	BYTE PTR __$EHRec$[esp+64], bl
	cmp	ecx, ebp
	je	SHORT $LN104@Init
	lea	eax, DWORD PTR _aTechList$222795[esp+56]
	push	eax
	call	??0?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<enum TechTypes,1,0,297,0>::FStaticVector<enum TechTypes,1,0,297,0>
$LN104@Init:

; 153  : 	}

	mov	eax, DWORD PTR _aTechList$222795[esp+56]
	add	DWORD PTR [edi+4], ebx
	lea	ecx, DWORD PTR _aTechList$222795[esp+68]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	cmp	eax, ecx
	je	SHORT $LN5@Init
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@Init:

; 148  : 
; 149  : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	sub	DWORD PTR tv497[esp+52], ebx
	jne	SHORT $LL6@Init
	add	esi, 720				; 000002d0H

; 154  : 
; 155  : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	edi, 22					; 00000016H
	npad	3
$LL3@Init:

; 156  : 	{
; 157  : 		m_aiNumTechsToStealList.push_back(0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN123@Init
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN123@Init:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	eax, ebp
	je	SHORT $LN126@Init
	mov	DWORD PTR [eax], ebp
$LN126@Init:
	add	DWORD PTR [esi+4], ebx
	sub	edi, ebx
	jne	SHORT $LL3@Init
	pop	edi
	pop	ebp
	pop	ebx
$LN13@Init:

; 158  : 	}
; 159  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR _aTechList$222795[ebp]
	jmp	??1?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum TechTypes,1,0,297,0>::~FStaticVector<enum TechTypes,1,0,297,0>
__unwindfunclet$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z$1:
	mov	eax, DWORD PTR $T258449[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR $T258449[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T258444[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvPlayerEspionage@@QAEXPAVCvPlayer@@@Z ENDP	; CvPlayerEspionage::Init
PUBLIC	?Uninit@CvPlayerEspionage@@QAEXXZ		; CvPlayerEspionage::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvPlayerEspionage@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvPlayerEspionage@@QAEXXZ PROC			; CvPlayerEspionage::Uninit, COMDAT
; _this$ = ecx

; 164  : 	Reset();

	jmp	?Reset@CvPlayerEspionage@@QAEXXZ	; CvPlayerEspionage::Reset
?Uninit@CvPlayerEspionage@@QAEXXZ ENDP			; CvPlayerEspionage::Uninit
_TEXT	ENDS
PUBLIC	?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildDiplomatCityList
EXTRN	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z:PROC	; CvCity::isRevealed
EXTRN	?WantsDiplomatDoingPropaganda@CvPlayerCulture@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::WantsDiplomatDoingPropaganda
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0
__ehfuncinfo$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
_TEXT	SEGMENT
$T258533 = -40						; size = 4
_this$ = -40						; size = 4
_kEntry$226018 = -36					; size = 8
_pCulture$ = -36					; size = 4
_aCityScores$226005 = -28				; size = 16
__$EHRec$ = -12						; size = 12
tv727 = 8						; size = 4
$T258534 = 8						; size = 1
_ui$225695 = 8						; size = 4
_aDiplomatCityList$ = 8					; size = 4
?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z PROC ; CvEspionageAI::BuildDiplomatCityList, COMDAT
; _this$ = ecx

; 4969 : {

	push	-1
	push	__ehhandler$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp

; 4970 : 	aDiplomatCityList.clear();

	mov	ebp, DWORD PTR _aDiplomatCityList$[esp+44]
	mov	edx, DWORD PTR [ebp+4]
	mov	ebx, ecx
	mov	ecx, DWORD PTR [ebp+8]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+56], ebx
	cmp	edx, ecx
	je	SHORT $LN290@BuildDiplo
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [esi+edx]
	test	eax, eax
	jle	SHORT $LN60@BuildDiplo
	push	esi
	push	ecx
	push	esi
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN60@BuildDiplo:
	mov	DWORD PTR [ebp+8], edi
$LN290@BuildDiplo:

; 4971 : 	CvPlayerCulture* pCulture = m_pPlayer->GetCulture();

	mov	ecx, DWORD PTR [ebx]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture

; 4972 : 	CvDiplomacyAI* pDiploAI = m_pPlayer->GetDiplomacyAI();

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _pCulture$[esp+56], eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI

; 4973 : 
; 4974 : 	if (pDiploAI->IsGoingForCultureVictory())

	mov	ecx, eax
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	je	$LN17@BuildDiplo

; 4975 : 	{
; 4976 : 		for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	edi, edi
	mov	DWORD PTR _ui$225695[esp+52], edi
	npad	4
$LL292@BuildDiplo:

; 4977 : 		{
; 4978 : 			PlayerTypes eTargetPlayer = (PlayerTypes)ui;
; 4979 : 			if (pCulture->WantsDiplomatDoingPropaganda(eTargetPlayer))

	mov	eax, DWORD PTR _ui$225695[esp+52]
	mov	ecx, DWORD PTR _pCulture$[esp+56]
	push	eax
	call	?WantsDiplomatDoingPropaganda@CvPlayerCulture@@QBE_NW4PlayerTypes@@@Z ; CvPlayerCulture::WantsDiplomatDoingPropaganda
	test	al, al
	je	SHORT $LN15@BuildDiplo

; 4980 : 			{
; 4981 : 				aDiplomatCityList.push_back(GET_PLAYER(eTargetPlayer).getCapitalCity());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T258533[esp+56], eax
	test	ecx, ecx
	jne	SHORT $LN73@BuildDiplo
	xor	edx, edx
	jmp	SHORT $LN74@BuildDiplo
$LN73@BuildDiplo:
	mov	edx, DWORD PTR [ebp+12]
	sub	edx, ecx
	sar	edx, 2
$LN74@BuildDiplo:
	mov	esi, DWORD PTR [ebp+8]
	mov	ebx, esi
	sub	ebx, ecx
	sar	ebx, 2
	cmp	ebx, edx
	jae	SHORT $LN66@BuildDiplo
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR [ebp+8], esi
	jmp	SHORT $LN15@BuildDiplo
$LN66@BuildDiplo:
	lea	edx, DWORD PTR $T258533[esp+56]
	push	edx
	push	1
	push	esi
	mov	ecx, ebp
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
$LN15@BuildDiplo:
	inc	DWORD PTR _ui$225695[esp+52]
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jb	SHORT $LL292@BuildDiplo
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5030 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
$LN17@BuildDiplo:

; 4982 : 			}
; 4983 : 		}
; 4984 : 	}
; 4985 : 	else // Going for diplo victory and others
; 4986 : 	{
; 4987 : 		std::vector<ScoreCityEntry> aCityScores;

	xor	ebx, ebx
	mov	DWORD PTR _aCityScores$226005[esp+60], ebx
	mov	DWORD PTR _aCityScores$226005[esp+64], ebx
	mov	DWORD PTR _aCityScores$226005[esp+68], ebx
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	xor	edi, edi
	npad	8
$LL11@BuildDiplo:

; 4988 : 		for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4989 : 		{
; 4990 : 			PlayerTypes eTargetPlayer = (PlayerTypes)ui;
; 4991 : 
; 4992 : 			// don't count the player's own cities
; 4993 : 			if(eTargetPlayer == m_pPlayer->GetID() || !GET_PLAYER(eTargetPlayer).isAlive())

	mov	eax, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [eax]
	cmp	ebx, DWORD PTR [ecx+44]
	je	$LN10@BuildDiplo
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+edx+2256], 0
	je	SHORT $LN10@BuildDiplo

; 4994 : 			{
; 4995 : 				continue;
; 4996 : 			}
; 4997 : 
; 4998 : 			if (m_pPlayer->GetLeagueAI()->GetDiplomatUsefulnessAtCiv(eTargetPlayer) == CvLeagueAI::DIPLOMAT_USEFULNESS_NONE)

	push	ebx
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?GetDiplomatUsefulnessAtCiv@CvLeagueAI@@QAE?AW4DiplomatUsefulnessLevels@1@W4PlayerTypes@@@Z ; CvLeagueAI::GetDiplomatUsefulnessAtCiv
	test	eax, eax
	je	SHORT $LN10@BuildDiplo

; 4999 : 			{
; 5000 : 				continue;
; 5001 : 			}
; 5002 : 
; 5003 : 			CvCity* pCapitalCity = GET_PLAYER(eTargetPlayer).getCapitalCity();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	esi, eax

; 5004 : 			if (!pCapitalCity)

	test	esi, esi
	je	SHORT $LN10@BuildDiplo

; 5005 : 			{
; 5006 : 				continue;
; 5007 : 			}
; 5008 : 
; 5009 : 			// if we can't see it, we can't move a diplomat there.
; 5010 : 			if (!pCapitalCity->isRevealed(m_pPlayer->getTeam(), false))

	mov	ecx, DWORD PTR _this$[esp+56]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN179@BuildDiplo
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN180@BuildDiplo
$LN179@BuildDiplo:
	or	eax, -1
$LN180@BuildDiplo:
	push	0
	push	eax
	mov	ecx, esi
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN10@BuildDiplo

; 5011 : 			{
; 5012 : 				continue;
; 5013 : 			}
; 5014 : 
; 5015 : 			ScoreCityEntry kEntry;
; 5016 : 			kEntry.m_pCity = pCapitalCity;
; 5017 : 			kEntry.m_iScore = m_pPlayer->GetLeagueAI()->GetDiplomatUsefulnessAtCiv(eTargetPlayer);

	mov	eax, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	DWORD PTR _kEntry$226018[esp+60], esi
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?GetDiplomatUsefulnessAtCiv@CvLeagueAI@@QAE?AW4DiplomatUsefulnessLevels@1@W4PlayerTypes@@@Z ; CvLeagueAI::GetDiplomatUsefulnessAtCiv

; 5018 : 			aCityScores.push_back(kEntry);

	lea	ecx, DWORD PTR _kEntry$226018[esp+56]
	push	ecx
	lea	ecx, DWORD PTR _aCityScores$226005[esp+60]
	mov	DWORD PTR _kEntry$226018[esp+64], eax
	call	?push_back@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEXABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::push_back
$LN10@BuildDiplo:
	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 1391192				; 00153a58H
	jb	$LL11@BuildDiplo

; 5019 : 		}
; 5020 : 
; 5021 : 		// sort
; 5022 : 		std::stable_sort(aCityScores.begin(), aCityScores.end(), ScoreCityEntryHighEval());

	mov	ebx, DWORD PTR _aCityScores$226005[esp+60]
	mov	esi, DWORD PTR _aCityScores$226005[esp+64]
	mov	BYTE PTR $T258534[esp+52], 0
	cmp	ebx, esi
	je	SHORT $LN291@BuildDiplo
	mov	edx, DWORD PTR $T258534[esp+52]
	push	edx
	push	0
	push	0
	push	esi
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
	add	esp, 20					; 00000014H
$LN291@BuildDiplo:

; 5023 : 
; 5024 : 		// transfer values to OffenseCityList
; 5025 : 		for(uint ui = 0; ui < aCityScores.size(); ui++)

	sub	esi, ebx
	sar	esi, 3
	test	esi, esi
	jbe	SHORT $LN1@BuildDiplo
	mov	edi, ebx
	mov	DWORD PTR tv727[esp+52], esi
	npad	1
$LL3@BuildDiplo:

; 5026 : 		{
; 5027 : 			aDiplomatCityList.push_back(aCityScores[ui].m_pCity);

	mov	edx, DWORD PTR [ebp+4]
	test	edx, edx
	jne	SHORT $LN219@BuildDiplo
	xor	ecx, ecx
	jmp	SHORT $LN220@BuildDiplo
$LN219@BuildDiplo:
	mov	ecx, DWORD PTR [ebp+12]
	sub	ecx, edx
	sar	ecx, 2
$LN220@BuildDiplo:
	mov	eax, DWORD PTR [ebp+8]
	mov	esi, eax
	sub	esi, edx
	sar	esi, 2
	cmp	esi, ecx
	jae	SHORT $LN212@BuildDiplo
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR [ebp+8], eax
	jmp	SHORT $LN2@BuildDiplo
$LN212@BuildDiplo:
	push	edi
	push	1
	push	eax
	mov	ecx, ebp
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
$LN2@BuildDiplo:
	add	edi, 8
	sub	DWORD PTR tv727[esp+52], 1
	jne	SHORT $LL3@BuildDiplo
$LN1@BuildDiplo:

; 5028 : 		}
; 5029 : 	}

	test	ebx, ebx
	je	SHORT $LN277@BuildDiplo
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN277@BuildDiplo:

; 5030 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _aCityScores$226005[ebp]
	jmp	??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
__ehhandler$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ENDP ; CvEspionageAI::BuildDiplomatCityList
PUBLIC	?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildOffenseCityList
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasDefensivePact
EXTRN	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsHasResearchAgreement
EXTRN	?IsDenouncedPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDenouncedPlayer
EXTRN	?IsPlayerStopSpyingRequestAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsPlayerStopSpyingRequestAccepted
EXTRN	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarGoal
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0
__ehfuncinfo$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
_TEXT	SEGMENT
_ui$226208 = -96					; size = 4
$T260099 = -92						; size = 4
tv1602 = -88						; size = 4
_iMaxTechCost$ = -84					; size = 4
_pDiploAI$ = -80					; size = 4
_ePlayer$ = -76						; size = 4
$T259934 = -72						; size = 4
_this$ = -68						; size = 4
tv1551 = -64						; size = 4
_pEspionage$ = -60					; size = 4
_iLoop$ = -56						; size = 4
tv1137 = -52						; size = 4
_pTargetDiploAI$226216 = -48				; size = 4
tv1612 = -44						; size = 4
$T259692 = -40						; size = 1
$T260424 = -40						; size = 1
_kEntry$226250 = -36					; size = 8
_aCityScores$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
__Cat$260428 = 8					; size = 1
_aOffenseCityList$ = 8					; size = 4
?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z PROC ; CvEspionageAI::BuildOffenseCityList, COMDAT
; _this$ = ecx

; 5033 : {

	push	-1
	push	__ehhandler$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	mov	ebp, ecx

; 5034 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ebp]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+112], ebp
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ebx, eax

; 5035 : 
; 5036 : 	aOffenseCityList.clear();

	mov	eax, DWORD PTR _aOffenseCityList$[esp+108]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _pEspionage$[esp+112], ebx
	cmp	edx, ecx
	je	SHORT $LN383@BuildOffen
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN85@BuildOffen
	push	esi
	push	ecx
	push	esi
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN85@BuildOffen:
	mov	eax, DWORD PTR _aOffenseCityList$[esp+108]
	mov	DWORD PTR [eax+8], edi
$LN383@BuildOffen:

; 5037 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+44]

; 5038 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _ePlayer$[esp+112], eax
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv1137[esp+112], eax
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN98@BuildOffen
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T259934[esp+112], eax
	jmp	SHORT $LN99@BuildOffen
$LN98@BuildOffen:
	mov	DWORD PTR $T259934[esp+112], -1
$LN99@BuildOffen:

; 5039 : 	CvDiplomacyAI* pDiploAI = m_pPlayer->GetDiplomacyAI();

	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI

; 5040 : 
; 5041 : 	// find the most expensive available research
; 5042 : 	int iMaxTechCost = -1;
; 5043 : 	CvPlayerTechs* pMyPlayerTechs = m_pPlayer->GetPlayerTechs();

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _pDiploAI$[esp+112], eax
	mov	DWORD PTR _iMaxTechCost$[esp+112], -1
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs

; 5044 : 
; 5045 : #ifdef AUI_WARNING_FIXES
; 5046 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 5047 : #else
; 5048 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN40@BuildOffen
	npad	1
$LL42@BuildOffen:

; 5049 : #endif
; 5050 : 	{
; 5051 : 		const TechTypes eTech = static_cast<TechTypes>(iTechLoop);
; 5052 : 		CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 5053 : 		if(!pkTechInfo)

	test	eax, eax
	je	SHORT $LN41@BuildOffen

; 5054 : 		{
; 5055 : 			continue;
; 5056 : 		}
; 5057 : 		
; 5058 : 		//check if it is disabled for spy stealing
; 5059 : 		//if (!pkTechInfo->IsDisableTechSteal())
; 5060 : 		//{
; 5061 : 		//	continue;
; 5062 : 		//}
; 5063 : 
; 5064 : 		// try to find the most expensive tech that can be researched
; 5065 : 		if(pMyPlayerTechs->CanResearch(eTech))

	push	0
	push	esi
	mov	ecx, edi
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN41@BuildOffen

; 5066 : 		{
; 5067 : 			int iTechCost = m_pPlayer->GetPlayerTechs()->GetResearchCost(eTech) * 100;

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	imul	eax, 100				; 00000064H

; 5068 : 			if(iTechCost > iMaxTechCost)

	cmp	eax, DWORD PTR _iMaxTechCost$[esp+112]
	jle	SHORT $LN41@BuildOffen

; 5069 : 			{
; 5070 : 				iMaxTechCost = iTechCost;

	mov	DWORD PTR _iMaxTechCost$[esp+112], eax
$LN41@BuildOffen:

; 5044 : 
; 5045 : #ifdef AUI_WARNING_FIXES
; 5046 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 5047 : #else
; 5048 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	SHORT $LL42@BuildOffen
$LN40@BuildOffen:

; 5071 : 			}
; 5072 : 		}
; 5073 : 	}
; 5074 : 
; 5075 : 	std::vector<ScoreCityEntry> aCityScores;

	xor	ebp, ebp
	xor	edi, edi
	mov	DWORD PTR _aCityScores$[esp+116], ebp
	mov	DWORD PTR _aCityScores$[esp+120], edi
	mov	DWORD PTR _aCityScores$[esp+124], ebp
	xor	esi, esi
	mov	eax, -824				; fffffcc8H
	lea	ecx, DWORD PTR [ebx+824]
	sub	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+120], ebp

; 5076 : 	CvCity* pLoopCity = NULL;
; 5077 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[esp+112], ebp

; 5078 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$226208[esp+112], ebp
	mov	DWORD PTR tv1551[esp+112], esi
	mov	DWORD PTR tv1602[esp+112], ecx
	mov	DWORD PTR tv1612[esp+112], eax
	jmp	SHORT $LN36@BuildOffen
$LL388@BuildOffen:

; 5071 : 			}
; 5072 : 		}
; 5073 : 	}
; 5074 : 
; 5075 : 	std::vector<ScoreCityEntry> aCityScores;

	xor	ebp, ebp
$LN36@BuildOffen:

; 5079 : 	{
; 5080 : 		PlayerTypes eTargetPlayer = (PlayerTypes)ui;
; 5081 : 
; 5082 : 		// don't count the player's own cities
; 5083 : 		if(eTargetPlayer == ePlayer)

	mov	edx, DWORD PTR _ui$226208[esp+112]
	cmp	edx, DWORD PTR _ePlayer$[esp+112]
	je	$LN35@BuildOffen

; 5084 : 		{
; 5085 : 			continue;
; 5086 : 		}
; 5087 : 
; 5088 : 		TeamTypes eTargetTeam = GET_PLAYER(eTargetPlayer).getTeam();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN146@BuildOffen
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T260099[esp+112], eax
	jmp	SHORT $LN147@BuildOffen
$LN146@BuildOffen:
	mov	DWORD PTR $T260099[esp+112], -1
$LN147@BuildOffen:

; 5089 : 		CvDiplomacyAI* pTargetDiploAI = GET_PLAYER(eTargetPlayer).GetDiplomacyAI();

	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI

; 5090 : 
; 5091 : 		for(pLoopCity = GET_PLAYER(eTargetPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eTargetPlayer).nextCity(&iLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	lea	edx, DWORD PTR _iLoop$[esp+116]
	add	ecx, esi
	push	edx
	mov	DWORD PTR _pTargetDiploAI$226216[esp+120], eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebp, eax
	test	ebp, ebp
	je	$LN35@BuildOffen
$LL389@BuildOffen:

; 5092 : 		{
; 5093 : 			CvPlot* pCityPlot = pLoopCity->plot();

	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 5094 : 			CvAssertMsg(pCityPlot, "City plot is null!");
; 5095 : 			if(!pCityPlot)

	test	eax, eax
	je	$LN31@BuildOffen

; 5096 : 			{
; 5097 : 				continue;
; 5098 : 			}
; 5099 : 
; 5100 : 			if(!pCityPlot->isRevealed(GET_PLAYER(ePlayer).getTeam()))

	mov	ecx, DWORD PTR tv1137[esp+112]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR [ecx+edx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN163@BuildOffen
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN164@BuildOffen
$LN163@BuildOffen:
	or	ecx, -1
$LN164@BuildOffen:
	mov	edx, ecx
	shr	edx, 5
	mov	edi, edx
	shl	edi, 5
	sub	ecx, edi
	mov	edi, 1
	shl	edi, cl
	test	edi, DWORD PTR [eax+edx*4+8]
	je	$LN31@BuildOffen

; 5101 : 			{
; 5102 : 				continue;
; 5103 : 			}
; 5104 : 
; 5105 : 			CvCityEspionage* pCityEspionage = pLoopCity->GetCityEspionage();

	mov	ecx, ebp
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	esi, eax

; 5106 : 
; 5107 : 			int iNumRemainingTurns = MAX_INT;

	mov	ebx, 2147483647				; 7fffffffH

; 5108 : 			int iSpyIndex = pEspionage->GetSpyIndexInCity(pLoopCity);

	test	ebp, ebp
	je	SHORT $LN384@BuildOffen
	mov	eax, DWORD PTR _pEspionage$[esp+112]
	mov	ecx, DWORD PTR [eax+1296]
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, ebp
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	mov	eax, DWORD PTR [eax+edi*4]

; 5109 : 			// if there is a spy currently stealing there, use the actual data
; 5110 : 			if(iSpyIndex >= 0 && pEspionage->m_aSpyList[iSpyIndex].m_eSpyState == SPY_STATE_GATHERING_INTEL)

	test	eax, eax
	jl	SHORT $LN384@BuildOffen
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _pEspionage$[esp+112]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+edx*4+16], 3
	jne	SHORT $LN384@BuildOffen

; 5111 : 			{
; 5112 : 				if(pCityEspionage->m_aiRate[ePlayer] != 0)

	mov	edx, DWORD PTR _ePlayer$[esp+112]
	mov	ecx, DWORD PTR [esi+edx*4+180]
	test	ecx, ecx
	je	SHORT $LN385@BuildOffen

; 5113 : 				{
; 5114 : 					iNumRemainingTurns = (pCityEspionage->m_aiGoal[ePlayer] - pCityEspionage->m_aiAmount[ePlayer]) / pCityEspionage->m_aiRate[ePlayer];

	mov	eax, DWORD PTR [esi+edx*4+268]
	sub	eax, DWORD PTR [esi+edx*4+92]

; 5115 : 				}
; 5116 : 			}

	jmp	SHORT $LN392@BuildOffen
$LN384@BuildOffen:

; 5117 : 			// if we have any history with the city, use that data instead
; 5118 : 			else if(pCityEspionage->m_aiLastBasePotential[m_pPlayer->GetID()] > 0)

	mov	edx, DWORD PTR _this$[esp+112]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	esi, DWORD PTR [esi+ecx*4+532]
	test	esi, esi
	jle	SHORT $LN24@BuildOffen

; 5119 : 			{
; 5120 : 				int iCost = iMaxTechCost;
; 5121 : 				if(pEspionage->m_aiMaxTechCost[eTargetPlayer] > 0)

	mov	edx, DWORD PTR tv1602[esp+112]
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _iMaxTechCost$[esp+112]
	test	ecx, ecx
	jle	SHORT $LN23@BuildOffen

; 5122 : 				{
; 5123 : 					iCost = pEspionage->m_aiMaxTechCost[eTargetPlayer];

	mov	eax, ecx
$LN23@BuildOffen:

; 5124 : 				}
; 5125 : 
; 5126 : 				iNumRemainingTurns = iCost / pCityEspionage->m_aiLastBasePotential[m_pPlayer->GetID()];

	cdq
	idiv	esi

; 5127 : 			}
; 5128 : 			// estimate the number of turns using the population
; 5129 : 			else

	jmp	SHORT $LN393@BuildOffen
$LN24@BuildOffen:

; 5130 : 			{
; 5131 : 				int iCost = iMaxTechCost;
; 5132 : 				if(pEspionage->m_aiMaxTechCost[eTargetPlayer] > 0)

	mov	eax, DWORD PTR tv1602[esp+112]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR _iMaxTechCost$[esp+112]
	test	eax, eax
	jle	SHORT $LN21@BuildOffen

; 5133 : 				{
; 5134 : 					iCost = pEspionage->m_aiMaxTechCost[eTargetPlayer];

	mov	esi, eax
$LN21@BuildOffen:

; 5135 : 				}
; 5136 : 				if(pLoopCity->getPopulation() > 0)

	mov	ecx, ebp
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	test	eax, eax
	jle	SHORT $LN385@BuildOffen

; 5137 : 				{
; 5138 : 					iNumRemainingTurns = iCost / (pLoopCity->getPopulation() * 100);

	mov	ecx, ebp
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ecx, eax
	imul	ecx, 100				; 00000064H
	mov	eax, esi
$LN392@BuildOffen:
	cdq
	idiv	ecx
$LN393@BuildOffen:
	mov	ebx, eax
$LN385@BuildOffen:

; 5139 : 				}
; 5140 : 			}
; 5141 : 
; 5142 : 			int iDiploModifier = 1;
; 5143 : 			if (pDiploAI->GetWarGoal(eTargetPlayer) == WAR_GOAL_PREPARE)

	mov	edx, DWORD PTR _ui$226208[esp+112]
	mov	ecx, DWORD PTR _pDiploAI$[esp+112]
	push	edx
	call	?GetWarGoal@CvDiplomacyAI@@QBE?AW4WarGoalTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarGoal
	cmp	eax, 1
	jne	SHORT $LN19@BuildOffen

; 5144 : 			{
; 5145 : 				iDiploModifier = 1;

	mov	esi, eax
	jmp	$LN386@BuildOffen
$LN19@BuildOffen:

; 5146 : 			}
; 5147 : 			else if (GET_TEAM(eTeam).isAtWar(eTargetTeam))

	mov	edi, DWORD PTR $T259934[esp+112]
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	edi, 2980				; 00000ba4H
	mov	edx, DWORD PTR $T260099[esp+112]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN17@BuildOffen

; 5148 : 			{
; 5149 : 				// ignore promises
; 5150 : 				// bonus targeting!
; 5151 : 				iDiploModifier = 1;

	mov	esi, 1

; 5152 : 			}
; 5153 : 			else // we're not at war with them, so look at other factors

	jmp	$LN386@BuildOffen
$LN17@BuildOffen:

; 5154 : 			{
; 5155 : 				// raise our diplo modifier by a scale of 10 so that we're less likely to target those we aren't at war with
; 5156 : 				iDiploModifier = 10;
; 5157 : 				// if we promised not to spy, make it less likely that we will spy
; 5158 : 				if (pDiploAI->IsPlayerStopSpyingRequestAccepted(eTargetPlayer))

	mov	eax, DWORD PTR _ui$226208[esp+112]
	mov	ecx, DWORD PTR _pDiploAI$[esp+112]
	push	eax
	mov	esi, 10					; 0000000aH
	call	?IsPlayerStopSpyingRequestAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsPlayerStopSpyingRequestAccepted
	test	al, al
	je	SHORT $LN15@BuildOffen

; 5159 : 				{
; 5160 : 					// target far less frequently
; 5161 : 					iDiploModifier *= 100;

	mov	esi, 1000				; 000003e8H
$LN15@BuildOffen:

; 5162 : 				}
; 5163 : 
; 5164 : 				// if we've denounced them or they've denounced us, spy bonus!
; 5165 : 				if (pDiploAI->IsDenouncedPlayer(eTargetPlayer) || pTargetDiploAI->IsDenouncedPlayer(ePlayer))

	mov	ecx, DWORD PTR _ui$226208[esp+112]
	push	ecx
	mov	ecx, DWORD PTR _pDiploAI$[esp+116]
	call	?IsDenouncedPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDenouncedPlayer
	test	al, al
	jne	SHORT $LN13@BuildOffen
	mov	edx, DWORD PTR _ePlayer$[esp+112]
	mov	ecx, DWORD PTR _pTargetDiploAI$226216[esp+112]
	push	edx
	call	?IsDenouncedPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDenouncedPlayer
	test	al, al
	jne	SHORT $LN13@BuildOffen

; 5168 : 				}
; 5169 : 				else if (pDiploAI->IsDoFAccepted(eTargetPlayer))

	mov	eax, DWORD PTR _ui$226208[esp+112]
	mov	ecx, DWORD PTR _pDiploAI$[esp+112]
	push	eax
	call	?IsDoFAccepted@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDoFAccepted
	test	al, al
	je	SHORT $LN11@BuildOffen

; 5170 : 				{
; 5171 : 					iDiploModifier *= 50;

	imul	esi, 50					; 00000032H
	jmp	SHORT $LN11@BuildOffen
$LN13@BuildOffen:

; 5166 : 				{
; 5167 : 					iDiploModifier /= 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
$LN11@BuildOffen:

; 5172 : 				}
; 5173 : 
; 5174 : 				if (GET_TEAM(eTeam).IsHasResearchAgreement(eTargetTeam))

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR $T260099[esp+112]
	add	ecx, edi
	push	edx
	call	?IsHasResearchAgreement@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasResearchAgreement
	test	al, al
	je	SHORT $LN10@BuildOffen

; 5175 : 				{
; 5176 : 					iDiploModifier *= 5;

	lea	esi, DWORD PTR [esi+esi*4]
$LN10@BuildOffen:

; 5177 : 				}
; 5178 : 
; 5179 : 				if (GET_TEAM(eTeam).IsHasDefensivePact(eTargetTeam))

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR $T260099[esp+112]
	lea	ecx, DWORD PTR [edi+eax]
	push	edx
	call	?IsHasDefensivePact@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsHasDefensivePact
	test	al, al
	je	SHORT $LN9@BuildOffen

; 5180 : 				{
; 5181 : 					iDiploModifier *= 50;

	imul	esi, 50					; 00000032H
$LN9@BuildOffen:

; 5182 : 				}
; 5183 : 
; 5184 : 				if (GET_TEAM(eTeam).IsAllowsOpenBordersToTeam(eTargetTeam))

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [edi+eax]
	mov	edi, DWORD PTR $T260099[esp+112]
	push	edi
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN8@BuildOffen

; 5185 : 				{
; 5186 : 					iDiploModifier *= 2;

	add	esi, esi
$LN8@BuildOffen:

; 5187 : 				}
; 5188 : 
; 5189 : 				if (GET_TEAM(eTargetTeam).IsAllowsOpenBordersToTeam(eTeam))

	mov	edx, DWORD PTR $T259934[esp+112]
	mov	ecx, edi
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN386@BuildOffen

; 5190 : 				{
; 5191 : 					iDiploModifier *= 2;

	add	esi, esi
$LN386@BuildOffen:

; 5192 : 				}
; 5193 : 			}
; 5194 : 
; 5195 : 			ScoreCityEntry kEntry;
; 5196 : 			kEntry.m_pCity = pLoopCity;
; 5197 : 
; 5198 : 			int iScore = iNumRemainingTurns * iDiploModifier;
; 5199 : 			if (m_aiCivOutOfTechTurn[eTargetPlayer] == GC.getGame().getGameTurn())

	mov	eax, DWORD PTR tv1612[esp+112]
	imul	esi, ebx
	mov	ecx, DWORD PTR tv1602[esp+112]
	mov	edx, DWORD PTR _this$[esp+112]
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR _kEntry$226250[esp+112], ebp
	lea	ebp, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	edi, ebp
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN6@BuildOffen

; 5200 : 			{
; 5201 : 				iScore = MAX_INT;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN4@BuildOffen
$LN6@BuildOffen:

; 5202 : 			}
; 5203 : 			else if(m_aiCivOutOfTechTurn[eTargetPlayer] > 0)

	mov	eax, DWORD PTR _this$[esp+112]
	mov	ecx, DWORD PTR [eax+4]
	mov	ebp, DWORD PTR [ecx+ebp]
	test	ebp, ebp
	jle	SHORT $LN4@BuildOffen

; 5204 : 			{
; 5205 : 				iScore = iScore * m_aiCivOutOfTechTurn[eTargetPlayer];

	imul	ebp, esi
	mov	esi, ebp
$LN4@BuildOffen:

; 5206 : 			}
; 5207 : 
; 5208 : 			kEntry.m_iScore = iScore;
; 5209 : 
; 5210 : 			aCityScores.push_back(kEntry);

	mov	ecx, DWORD PTR _aCityScores$[esp+116]
	mov	DWORD PTR _kEntry$226250[esp+116], esi
	test	ecx, ecx
	jne	SHORT $LN237@BuildOffen
	xor	eax, eax
	jmp	SHORT $LN238@BuildOffen
$LN237@BuildOffen:
	mov	eax, DWORD PTR _aCityScores$[esp+124]
	sub	eax, ecx
	sar	eax, 3
$LN238@BuildOffen:
	mov	esi, DWORD PTR _aCityScores$[esp+120]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN230@BuildOffen
	mov	ecx, DWORD PTR __Cat$260428[esp+108]
	mov	BYTE PTR $T260424[esp+112], 0
	mov	eax, DWORD PTR $T260424[esp+112]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _aCityScores$[esp+120]
	push	edx
	lea	eax, DWORD PTR _kEntry$226250[esp+124]
	push	eax
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
	add	esp, 24					; 00000018H
	add	esi, 8
	mov	DWORD PTR _aCityScores$[esp+120], esi
	jmp	SHORT $LN394@BuildOffen
$LN230@BuildOffen:
	lea	ecx, DWORD PTR _kEntry$226250[esp+112]
	push	ecx
	push	1
	push	esi
	lea	ecx, DWORD PTR _aCityScores$[esp+124]
	call	?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Insert_n
$LN394@BuildOffen:
	mov	esi, DWORD PTR tv1551[esp+112]
$LN31@BuildOffen:

; 5090 : 
; 5091 : 		for(pLoopCity = GET_PLAYER(eTargetPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eTargetPlayer).nextCity(&iLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+116]
	lea	ecx, DWORD PTR [esi+edx]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL389@BuildOffen
	mov	edi, DWORD PTR _aCityScores$[esp+120]
$LN35@BuildOffen:

; 5078 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	inc	DWORD PTR _ui$226208[esp+112]
	add	DWORD PTR tv1602[esp+112], 4
	add	esi, 63236				; 0000f704H
	mov	DWORD PTR tv1551[esp+112], esi
	cmp	esi, 1391192				; 00153a58H
	jb	$LL388@BuildOffen

; 5211 : 		}
; 5212 : 	}
; 5213 : 
; 5214 : 	// sort
; 5215 : 	std::stable_sort(aCityScores.begin(), aCityScores.end(), ScoreCityEntryLowEval());

	mov	esi, DWORD PTR _aCityScores$[esp+116]
	mov	BYTE PTR $T259692[esp+112], 0
	cmp	esi, edi
	je	SHORT $LN390@BuildOffen
	mov	ecx, DWORD PTR $T259692[esp+112]
	push	ecx
	push	0
	push	0
	push	edi
	push	esi
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryLowEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryLowEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryLowEval>
	add	esp, 20					; 00000014H
$LN390@BuildOffen:

; 5216 : 
; 5217 : 	// transfer values to OffenseCityList
; 5218 : 	for(uint ui = 0; ui < aCityScores.size(); ui++)

	sub	edi, esi
	mov	eax, edi
	sar	eax, 3
	test	eax, eax
	jbe	SHORT $LN1@BuildOffen
	mov	edi, eax
$LL3@BuildOffen:

; 5219 : 	{
; 5220 : 		aOffenseCityList.push_back(aCityScores[ui].m_pCity);

	mov	ebx, DWORD PTR _aOffenseCityList$[esp+108]
	mov	edx, DWORD PTR [ebx+4]
	test	edx, edx
	jne	SHORT $LN312@BuildOffen
	xor	ecx, ecx
	jmp	SHORT $LN313@BuildOffen
$LN312@BuildOffen:
	mov	ecx, DWORD PTR [ebx+12]
	sub	ecx, edx
	sar	ecx, 2
$LN313@BuildOffen:
	mov	eax, DWORD PTR [ebx+8]
	mov	ebp, eax
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, ecx
	jae	SHORT $LN305@BuildOffen
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	add	eax, 4
	mov	DWORD PTR [ebx+8], eax
	jmp	SHORT $LN2@BuildOffen
$LN305@BuildOffen:
	push	esi
	push	1
	push	eax
	mov	ecx, ebx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
$LN2@BuildOffen:
	add	esi, 8
	sub	edi, 1
	jne	SHORT $LL3@BuildOffen
$LN1@BuildOffen:

; 5221 : 	}
; 5222 : }

	mov	eax, DWORD PTR _aCityScores$[esp+116]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	test	eax, eax
	je	SHORT $LN370@BuildOffen
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN370@BuildOffen:
	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _aCityScores$[ebp]
	jmp	??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
__ehhandler$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ENDP ; CvEspionageAI::BuildOffenseCityList
PUBLIC	?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildDefenseCityList
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0
__ehfuncinfo$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
_TEXT	SEGMENT
_iLoop$ = -44						; size = 4
_pEspionage$ = -40					; size = 4
_kEntry$226285 = -36					; size = 8
_aCityScores$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
$T260908 = 8						; size = 1
$T261437 = 8						; size = 1
__Cat$261441 = 8					; size = 1
tv174 = 8						; size = 4
_aDefenseCityList$ = 8					; size = 4
?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z PROC ; CvEspionageAI::BuildDefenseCityList, COMDAT
; _this$ = ecx

; 5225 : {

	push	-1
	push	__ehhandler$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 5226 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage

; 5227 : 
; 5228 : 	aDefenseCityList.clear();

	mov	ebx, DWORD PTR _aDefenseCityList$[esp+56]
	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR _pEspionage$[esp+60], eax
	cmp	edx, ecx
	je	SHORT $LN24@BuildDefen
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edi, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edi+edx]
	test	eax, eax
	jle	SHORT $LN49@BuildDefen
	push	edi
	push	ecx
	push	edi
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN49@BuildDefen:
	mov	DWORD PTR [ebx+8], ebp
$LN24@BuildDefen:

; 5229 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+44]

; 5230 : 
; 5231 : 	std::vector<ScoreCityEntry> aCityScores;

	xor	esi, esi
	xor	ebp, ebp
	mov	DWORD PTR _aCityScores$[esp+64], ebp
	mov	DWORD PTR _aCityScores$[esp+68], esi
	mov	DWORD PTR _aCityScores$[esp+72], esi

; 5232 : 
; 5233 : 	CvCity* pLoopCity = NULL;
; 5234 : 	int iLoop = 0;
; 5235 : 	for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	imul	edi, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	lea	edx, DWORD PTR _iLoop$[esp+64]
	add	ecx, edi
	push	edx
	mov	DWORD PTR __$EHRec$[esp+76], esi
	mov	DWORD PTR _iLoop$[esp+68], esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	$LN4@BuildDefen
	npad	6
$LL6@BuildDefen:

; 5236 : 	{
; 5237 : 		ScoreCityEntry kEntry;
; 5238 : 		kEntry.m_pCity = pLoopCity;
; 5239 : 		kEntry.m_iScore = pEspionage->CalcPerTurn(SPY_STATE_GATHERING_INTEL, pLoopCity, -1);

	mov	ecx, DWORD PTR _pEspionage$[esp+60]
	push	-1
	push	eax
	push	3
	mov	DWORD PTR _kEntry$226285[esp+72], eax
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn
	mov	DWORD PTR _kEntry$226285[esp+64], eax

; 5240 : 		aCityScores.push_back(kEntry);

	test	ebp, ebp
	jne	SHORT $LN105@BuildDefen
	xor	eax, eax
	jmp	SHORT $LN106@BuildDefen
$LN105@BuildDefen:
	mov	eax, DWORD PTR _aCityScores$[esp+72]
	sub	eax, ebp
	sar	eax, 3
$LN106@BuildDefen:
	mov	ecx, esi
	sub	ecx, ebp
	sar	ecx, 3
	cmp	ecx, eax
	lea	ecx, DWORD PTR _aCityScores$[esp+60]
	jae	SHORT $LN98@BuildDefen
	mov	BYTE PTR $T261437[esp+56], 0
	mov	edx, DWORD PTR $T261437[esp+56]
	mov	eax, DWORD PTR __Cat$261441[esp+56]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _kEntry$226285[esp+72]
	push	edx
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAUScoreCityEntry@@IU1@V?$allocator@UScoreCityEntry@@@std@@@std@@YAXPAUScoreCityEntry@@IABU1@AAV?$allocator@UScoreCityEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ScoreCityEntry *,unsigned int,ScoreCityEntry,std::allocator<ScoreCityEntry> >
	add	esp, 24					; 00000018H
	add	esi, 8
	mov	DWORD PTR _aCityScores$[esp+68], esi
	jmp	SHORT $LN5@BuildDefen
$LN98@BuildDefen:
	lea	eax, DWORD PTR _kEntry$226285[esp+60]
	push	eax
	push	1
	push	esi
	call	?_Insert_n@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@2@IABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::_Insert_n
	mov	esi, DWORD PTR _aCityScores$[esp+68]
	mov	ebp, DWORD PTR _aCityScores$[esp+64]
$LN5@BuildDefen:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+64]
	add	ecx, edi
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	$LL6@BuildDefen
$LN4@BuildDefen:

; 5241 : 	}
; 5242 : 
; 5243 : 	// sort
; 5244 : 	std::stable_sort(aCityScores.begin(), aCityScores.end(), ScoreCityEntryHighEval());

	mov	BYTE PTR $T260908[esp+56], 0
	cmp	ebp, esi
	je	SHORT $LN157@BuildDefen
	mov	eax, DWORD PTR $T260908[esp+56]
	push	eax
	push	0
	push	0
	push	esi
	push	ebp
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
	add	esp, 20					; 00000014H
$LN157@BuildDefen:

; 5245 : 
; 5246 : 	// transfer values to aDefenseCityList
; 5247 : 	for(uint ui = 0; ui < aCityScores.size(); ui++)

	sub	esi, ebp
	sar	esi, 3
	test	esi, esi
	jbe	SHORT $LN1@BuildDefen
	mov	edi, ebp
	mov	DWORD PTR tv174[esp+56], esi
	npad	5
$LL246@BuildDefen:

; 5248 : 	{
; 5249 : 		aDefenseCityList.push_back(aCityScores[ui].m_pCity);

	mov	edx, DWORD PTR [ebx+4]
	test	edx, edx
	jne	SHORT $LN180@BuildDefen
	xor	ecx, ecx
	jmp	SHORT $LN181@BuildDefen
$LN180@BuildDefen:
	mov	ecx, DWORD PTR [ebx+12]
	sub	ecx, edx
	sar	ecx, 2
$LN181@BuildDefen:
	mov	eax, DWORD PTR [ebx+8]
	mov	esi, eax
	sub	esi, edx
	sar	esi, 2
	cmp	esi, ecx
	jae	SHORT $LN173@BuildDefen
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR [ebx+8], eax
	jmp	SHORT $LN2@BuildDefen
$LN173@BuildDefen:
	push	edi
	push	1
	push	eax
	mov	ecx, ebx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
$LN2@BuildDefen:
	add	edi, 8
	sub	DWORD PTR tv174[esp+56], 1
	jne	SHORT $LL246@BuildDefen
$LN1@BuildDefen:

; 5250 : 	}
; 5251 : }

	test	ebp, ebp
	je	SHORT $LN238@BuildDefen
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN238@BuildDefen:
	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _aCityScores$[ebp]
	jmp	??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
__ehhandler$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ENDP ; CvEspionageAI::BuildDefenseCityList
PUBLIC	?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildMinorCityList
EXTRN	?IsCloseToNotBeingAllies@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsCloseToNotBeingAllies
EXTRN	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsAllies
EXTRN	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsRecentlyBulliedByMajor
EXTRN	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z:PROC ; CvPlayer::GetProximityToPlayer
EXTRN	?GetPersonality@CvMinorCivAI@@QBE?AW4MinorCivPersonalityTypes@@XZ:PROC ; CvMinorCivAI::GetPersonality
EXTRN	?GetNumResourcesMajorLacks@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::GetNumResourcesMajorLacks
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ:PROC	; CvMinorCivInfo::GetMinorCivTrait
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z:PROC ; CvGlobals::getMinorCivInfo
EXTRN	?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ:PROC ; CvMinorCivAI::GetMinorCivType
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0
__ehfuncinfo$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
_TEXT	SEGMENT
_bAlreadyScoredCity$226325 = -85			; size = 1
_pDiploAI$ = -84					; size = 4
_ui$226311 = -80					; size = 4
_eCurrentDiploThreat$ = -76				; size = 4
_iFriendshipWithMinor$226324 = -72			; size = 4
_pMinorInfo$226322 = -68				; size = 4
_eApproach$226323 = -64					; size = 4
_iLoop$ = -60						; size = 4
_pEspionage$ = -56					; size = 4
_iCityStatePlan$ = -52					; size = 4
$T261906 = -48						; size = 4
$T261907 = -44						; size = 4
$T261908 = -40						; size = 1
_iGrowthFlavor$ = -40					; size = 4
_kEntry$226331 = -36					; size = 8
_aCityScores$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_aMinorCityList$ = 8					; size = 4
?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z PROC ; CvEspionageAI::BuildMinorCityList, COMDAT
; _this$ = ecx

; 5254 : {

	push	-1
	push	__ehhandler$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 5255 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage

; 5256 : 	CvDiplomacyAI* pDiploAI = m_pPlayer->GetDiplomacyAI();

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _pEspionage$[esp+104], eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pDiploAI$[esp+104], eax

; 5257 : 
; 5258 : 	aMinorCityList.clear();

	mov	eax, DWORD PTR _aMinorCityList$[esp+100]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+4]
	xor	ebx, ebx
	cmp	edx, ecx
	je	SHORT $LN71@BuildMinor
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, ebx
	lea	esi, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [esi+edx]
	jle	SHORT $LN96@BuildMinor
	push	esi
	push	ecx
	push	esi
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN96@BuildMinor:
	mov	eax, DWORD PTR _aMinorCityList$[esp+100]
	mov	DWORD PTR [eax+8], edi
$LN71@BuildMinor:

; 5259 : 
; 5260 : 	int iGrowthFlavor = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) GC.getInfoTypeForString("FLAVOR_GROWTH"));

	push	ebx
	push	OFFSET $SG226301
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 5261 : 	PlayerTypes eCurrentDiploThreat = NO_PLAYER;
; 5262 : 	int iCityStatePlan = GetCityStatePlan(&eCurrentDiploThreat);

	lea	ecx, DWORD PTR _eCurrentDiploThreat$[esp+104]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR _iGrowthFlavor$[esp+108], eax
	mov	DWORD PTR _eCurrentDiploThreat$[esp+108], -1
	call	?GetCityStatePlan@CvEspionageAI@@QAEHPAW4PlayerTypes@@@Z ; CvEspionageAI::GetCityStatePlan
	mov	DWORD PTR _iCityStatePlan$[esp+104], eax

; 5263 : 
; 5264 : 	std::vector<ScoreCityEntry> aCityScores;

	mov	DWORD PTR _aCityScores$[esp+108], ebx
	mov	DWORD PTR _aCityScores$[esp+112], ebx
	mov	DWORD PTR _aCityScores$[esp+116], ebx
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR __$EHRec$[esp+112], ebx

; 5265 : 	CvCity* pLoopCity = NULL;
; 5266 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[esp+104], ebx

; 5267 : 	for(uint ui = MAX_MAJOR_CIVS; ui < MAX_CIV_PLAYERS; ui++)

	mov	DWORD PTR _ui$226311[esp+104], 22	; 00000016H
	mov	ebx, 1391192				; 00153a58H
$LL351@BuildMinor:

; 5268 : 	{
; 5269 : 		PlayerTypes eTargetPlayer = (PlayerTypes)ui;
; 5270 : 
; 5271 : 		// only count minor civs
; 5272 : 		if (!GET_PLAYER(eTargetPlayer).isMinorCiv())

	lea	ecx, DWORD PTR [ebx+eax]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN349@BuildMinor
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5273 : 		{
; 5274 : 			continue;
; 5275 : 		}
; 5276 : 
; 5277 : 		if (!GET_PLAYER(eTargetPlayer).isAlive())

	cmp	BYTE PTR [ebx+eax+2256], 0
	je	$LN52@BuildMinor

; 5278 : 		{
; 5279 : 			continue;
; 5280 : 		}
; 5281 : 
; 5282 : 		// if we haven't met the civ, ignore
; 5283 : 		if(!GET_TEAM(m_pPlayer->getTeam()).isHasMet((GET_PLAYER(eTargetPlayer).getTeam())))

	mov	eax, DWORD PTR [ebx+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN150@BuildMinor
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN151@BuildMinor
$LN150@BuildMinor:
	or	ecx, -1
$LN151@BuildMinor:
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN159@BuildMinor
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN160@BuildMinor
$LN159@BuildMinor:
	or	eax, -1
$LN160@BuildMinor:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	$LN349@BuildMinor

; 5284 : 		{
; 5285 : 			continue;
; 5286 : 		}
; 5287 : 
; 5288 : 		// if at war with the minor civ, do not try to assign a spy in the city
; 5289 : 		if (GET_TEAM(m_pPlayer->getTeam()).isAtWar(GET_PLAYER(eTargetPlayer).getTeam()))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ebx+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN172@BuildMinor
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN173@BuildMinor
$LN172@BuildMinor:
	or	ecx, -1
$LN173@BuildMinor:
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN181@BuildMinor
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN182@BuildMinor
$LN181@BuildMinor:
	or	eax, -1
$LN182@BuildMinor:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	$LN349@BuildMinor

; 5290 : 		{
; 5291 : 			continue;
; 5292 : 		}
; 5293 : 
; 5294 : 		CvMinorCivAI* pMinorCivAI = GET_PLAYER(eTargetPlayer).GetMinorCivAI();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	edi, eax

; 5295 : 		CvMinorCivInfo* pMinorInfo = GC.getMinorCivInfo(pMinorCivAI->GetMinorCivType());

	mov	ecx, edi
	call	?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ ; CvMinorCivAI::GetMinorCivType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo

; 5296 : 		MinorCivApproachTypes eApproach = pDiploAI->GetMinorCivApproach(eTargetPlayer);

	mov	ecx, DWORD PTR _ui$226311[esp+104]
	push	ecx
	mov	ecx, DWORD PTR _pDiploAI$[esp+108]
	mov	DWORD PTR _pMinorInfo$226322[esp+108], eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach

; 5297 : 		int iFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(m_pPlayer->GetID());

	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR _eApproach$226323[esp+104], eax
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
	mov	DWORD PTR _iFriendshipWithMinor$226324[esp+104], eax

; 5298 : 		
; 5299 : 		bool bAlreadyScoredCity = false;
; 5300 : 		for (pLoopCity = GET_PLAYER(eTargetPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eTargetPlayer).nextCity(&iLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+108]
	lea	ecx, DWORD PTR [ebx+eax]
	push	edx
	mov	BYTE PTR _bAlreadyScoredCity$226325[esp+112], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN349@BuildMinor
	npad	3
$LL46@BuildMinor:

; 5301 : 		{
; 5302 : 			if(!pEspionage->CanEverMoveSpyTo(pLoopCity))

	mov	ecx, DWORD PTR _pEspionage$[esp+104]
	push	esi
	call	?CanEverMoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::CanEverMoveSpyTo
	test	al, al
	je	$LN45@BuildMinor

; 5303 : 			{
; 5304 : 				continue;
; 5305 : 			}
; 5306 : 
; 5307 : 			// if we've already scored a city for this minor civ, we don't need to score another because the values would be the same
; 5308 : 			if (bAlreadyScoredCity)

	cmp	BYTE PTR _bAlreadyScoredCity$226325[esp+104], 0
	jne	$LN349@BuildMinor

; 5309 : 			{
; 5310 : 				break;
; 5311 : 			}
; 5312 : 			bAlreadyScoredCity = true;
; 5313 : 
; 5314 : 			ScoreCityEntry kEntry;
; 5315 : 			kEntry.m_pCity = pLoopCity;
; 5316 : 
; 5317 : 			int iValue = 100;
; 5318 : 			switch (iCityStatePlan)

	mov	eax, DWORD PTR _iCityStatePlan$[esp+104]
	mov	DWORD PTR _kEntry$226331[esp+104], esi
	mov	BYTE PTR _bAlreadyScoredCity$226325[esp+104], 1
	mov	esi, 100				; 00000064H
	cmp	eax, 3
	ja	$LN4@BuildMinor
	jmp	DWORD PTR $LN354@BuildMinor[eax*4]
$LN39@BuildMinor:

; 5319 : 			{
; 5320 : 			case PLAN_PLAY_NORMAL:
; 5321 : 				// If we're not protective or friendly, then don't bother with minor diplo
; 5322 : 				if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE || eApproach == MINOR_CIV_APPROACH_FRIENDLY)

	mov	eax, DWORD PTR _eApproach$226323[esp+104]
	cmp	eax, 2
	je	SHORT $LN37@BuildMinor
	cmp	eax, 1
	jne	$LN23@BuildMinor
$LN37@BuildMinor:

; 5323 : 				{
; 5324 : 					// Nearly everyone likes to grow
; 5325 : 					if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MARITIME && !m_pPlayer->IsEmpireUnhappy())

	mov	ecx, DWORD PTR _pMinorInfo$226322[esp+104]
	call	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ ; CvMinorCivInfo::GetMinorCivTrait
	cmp	eax, 2
	jne	SHORT $LN36@BuildMinor
	mov	ecx, DWORD PTR [ebp]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	test	al, al
	jne	SHORT $LN36@BuildMinor

; 5326 : 					{
; 5327 : 						iValue += /*20*/ GC.getMC_GIFT_WEIGHT_MARITIME_GROWTH() * iGrowthFlavor * max(1, m_pPlayer->getNumCities() / 3);

	mov	ecx, DWORD PTR [ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	ecx, eax
	mov	eax, 1431655766				; 55555556H
	imul	ecx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR $T261906[esp+104], eax
	cmp	eax, 1
	mov	DWORD PTR $T261907[esp+104], 1
	lea	eax, DWORD PTR $T261906[esp+104]
	jg	SHORT $LN203@BuildMinor
	lea	eax, DWORD PTR $T261907[esp+104]
$LN203@BuildMinor:
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3460
	imul	esi, DWORD PTR _iGrowthFlavor$[esp+104]
	imul	esi, DWORD PTR [eax]
	add	esi, 100				; 00000064H
$LN36@BuildMinor:

; 5328 : 					}
; 5329 : 
; 5330 : 					// Slight negative weight towards militaristic
; 5331 : 					if(pMinorInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MILITARISTIC && !pDiploAI->IsGoingForWorldConquest())

	mov	ecx, DWORD PTR _pMinorInfo$226322[esp+104]
	call	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ ; CvMinorCivInfo::GetMinorCivTrait
	cmp	eax, 1
	jne	SHORT $LN35@BuildMinor
	mov	ecx, DWORD PTR _pDiploAI$[esp+104]
	call	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForWorldConquest
	test	al, al
	jne	SHORT $LN35@BuildMinor

; 5332 : 					{
; 5333 : 						iValue += /*-50*/ GC.getMC_GIFT_WEIGHT_MILITARISTIC();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3476
$LN35@BuildMinor:

; 5334 : 					}
; 5335 : 
; 5336 : 					// If they have a resource we don't have, add extra weight
; 5337 : 					int iResourcesWeLack = pMinorCivAI->GetNumResourcesMajorLacks(m_pPlayer->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?GetNumResourcesMajorLacks@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetNumResourcesMajorLacks

; 5338 : 					if(iResourcesWeLack > 0)

	test	eax, eax
	jle	SHORT $LN34@BuildMinor

; 5339 : 					{
; 5340 : 						iValue += (iResourcesWeLack* /*80*/ GC.getMC_GIFT_WEIGHT_RESOURCE_WE_NEED());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3480
	imul	ecx, eax
	add	esi, ecx
$LN34@BuildMinor:

; 5341 : 					}
; 5342 : 
; 5343 : 					// If we're protective this is worth more than if we're friendly
; 5344 : 					if(eApproach == MINOR_CIV_APPROACH_PROTECTIVE)

	cmp	DWORD PTR _eApproach$226323[esp+104], 2
	jne	SHORT $LN33@BuildMinor

; 5345 : 					{
; 5346 : 						iValue += /*10*/ GC.getMC_GIFT_WEIGHT_PROTECTIVE();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3488
$LN33@BuildMinor:

; 5347 : 					}
; 5348 : 
; 5349 : 					// If the minor is hostile, then reduce the weighting
; 5350 : 					if(pMinorCivAI->GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)

	mov	ecx, edi
	call	?GetPersonality@CvMinorCivAI@@QBE?AW4MinorCivPersonalityTypes@@XZ ; CvMinorCivAI::GetPersonality
	cmp	eax, 2
	jne	SHORT $LN32@BuildMinor

; 5351 : 					{
; 5352 : 						iValue += /*-20*/ GC.getMC_GIFT_WEIGHT_HOSTILE();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3492
$LN32@BuildMinor:

; 5353 : 					}
; 5354 : 
; 5355 : 					// The closer we are the better
; 5356 : 					if(m_pPlayer->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_NEIGHBORS)

	mov	edx, DWORD PTR _ui$226311[esp+104]
	mov	ecx, DWORD PTR [ebp]
	push	edx
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, 3
	jne	SHORT $LN31@BuildMinor

; 5357 : 						iValue += /*5*/ GC.getMC_GIFT_WEIGHT_NEIGHBORS();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3496
	jmp	SHORT $LN27@BuildMinor
$LN31@BuildMinor:

; 5358 : 					else if(m_pPlayer->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_CLOSE)

	mov	eax, DWORD PTR _ui$226311[esp+104]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, 2
	jne	SHORT $LN29@BuildMinor

; 5359 : 						iValue += /*4*/ GC.getMC_GIFT_WEIGHT_CLOSE();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3500
	jmp	SHORT $LN27@BuildMinor
$LN29@BuildMinor:

; 5360 : 					else if(m_pPlayer->GetProximityToPlayer(eTargetPlayer) == PLAYER_PROXIMITY_FAR)

	mov	ecx, DWORD PTR _ui$226311[esp+104]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, 1
	jne	SHORT $LN27@BuildMinor

; 5361 : 						iValue += /*3*/ GC.getMC_GIFT_WEIGHT_FAR();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+3504
$LN27@BuildMinor:

; 5362 : 
; 5363 : 					// Did we bully you recently?  If so, giving you gold now would be very odd.
; 5364 : 					if(pMinorCivAI->IsRecentlyBulliedByMajor(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, edi
	call	?IsRecentlyBulliedByMajor@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsRecentlyBulliedByMajor
	test	al, al
	je	SHORT $LN26@BuildMinor

; 5365 : 					{
; 5366 : 						iValue -= 100; //antonjs: todo: constant/XML

	sub	esi, 100				; 00000064H
$LN26@BuildMinor:

; 5367 : 					}
; 5368 : 
; 5369 : 					// if we're allies
; 5370 : 					if (pMinorCivAI->IsAllies(m_pPlayer->GetID()))

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAllies
	test	al, al
	je	SHORT $LN25@BuildMinor

; 5371 : 					{
; 5372 : 						// and we're secure as their allies, ignore the scoring
; 5373 : 						if (!pMinorCivAI->IsCloseToNotBeingAllies(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	mov	ecx, edi
	call	?IsCloseToNotBeingAllies@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsCloseToNotBeingAllies
	test	al, al
	jne	SHORT $LN23@BuildMinor

; 5374 : 						{
; 5375 : 							iValue = 0;

	xor	esi, esi

; 5376 : 						}
; 5377 : 					}
; 5378 : 					else

	jmp	SHORT $LN23@BuildMinor
$LN25@BuildMinor:

; 5379 : 					{
; 5380 : 						// count however much we've invested into the friendship toward maintaining the friendship
; 5381 : 						iValue += iFriendshipWithMinor;

	add	esi, DWORD PTR _iFriendshipWithMinor$226324[esp+104]
$LN23@BuildMinor:

; 5382 : 					}
; 5383 : 				}
; 5384 : 
; 5385 : 				if (pDiploAI->IsGoingForCultureVictory())

	mov	ecx, DWORD PTR _pDiploAI$[esp+104]
	call	?IsGoingForCultureVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForCultureVictory
	test	al, al
	jne	$LN4@BuildMinor

; 5386 : 				{
; 5387 : 					// no modifiers
; 5388 : 				}
; 5389 : 				else if (pDiploAI->IsGoingForWorldConquest())

	mov	ecx, DWORD PTR _pDiploAI$[esp+104]
	call	?IsGoingForWorldConquest@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForWorldConquest
	test	al, al
	je	SHORT $LN20@BuildMinor

; 5390 : 				{
; 5391 : 					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)

	mov	ecx, edi
	call	?GetTrait@CvMinorCivAI@@QBE?AW4MinorCivTraitTypes@@XZ ; CvMinorCivAI::GetTrait
	cmp	eax, 1
	jne	$LN4@BuildMinor

; 5392 : 					{
; 5393 : 						iValue += 999;

	add	esi, 999				; 000003e7H

; 5394 : 					}
; 5395 : 				}

	jmp	$LN4@BuildMinor
$LN20@BuildMinor:

; 5396 : 				else if (pDiploAI->IsGoingForDiploVictory())

	mov	ecx, DWORD PTR _pDiploAI$[esp+104]
	call	?IsGoingForDiploVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForDiploVictory
	test	al, al
	jne	$LN4@BuildMinor

; 5397 : 				{
; 5398 : 					// no modifiers
; 5399 : 				}
; 5400 : 				else if (pDiploAI->IsGoingForSpaceshipVictory())

	mov	ecx, DWORD PTR _pDiploAI$[esp+104]
	call	?IsGoingForSpaceshipVictory@CvDiplomacyAI@@QAE_NXZ ; CvDiplomacyAI::IsGoingForSpaceshipVictory

; 5401 : 				{
; 5402 : 					// no modifiers
; 5403 : 				}
; 5404 : 				else // the player doesn't know how they're going to try to win yet
; 5405 : 				{
; 5406 : 					// no modifiers
; 5407 : 				}
; 5408 : 				break;

	jmp	SHORT $LN4@BuildMinor
$LN13@BuildMinor:

; 5409 : 
; 5410 : 			case PLAN_COLLECT_VOTES:
; 5411 : 				// if we're allies
; 5412 : 				if (pMinorCivAI->IsAllies(m_pPlayer->GetID()))

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, edi
	call	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAllies

; 5413 : 				{
; 5414 : 					// and we're secure as their allies, ignore the scoring
; 5415 : 					if (!pMinorCivAI->IsCloseToNotBeingAllies(m_pPlayer->GetID()))

	mov	ecx, edi
	test	al, al
	je	SHORT $LN12@BuildMinor
	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?IsCloseToNotBeingAllies@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsCloseToNotBeingAllies
	test	al, al
	jne	SHORT $LN4@BuildMinor

; 5416 : 					{
; 5417 : 						iValue = 0;

	xor	esi, esi

; 5418 : 					}
; 5419 : 				}
; 5420 : 				else

	jmp	SHORT $LN4@BuildMinor
$LN12@BuildMinor:

; 5421 : 				{
; 5422 : 					// if the minor is allied with someone else
; 5423 : 					if (pMinorCivAI->GetAlly() != NO_PLAYER)

	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 5424 : 					{
; 5425 : 						iValue += iFriendshipWithMinor;

	mov	esi, DWORD PTR _iFriendshipWithMinor$226324[esp+104]
	cmp	eax, -1
	je	SHORT $LN9@BuildMinor
	add	esi, 100				; 00000064H

; 5426 : 					}
; 5427 : 					else

	jmp	SHORT $LN4@BuildMinor
$LN9@BuildMinor:

; 5428 : 					{
; 5429 : 						// count however much we've invested into the friendship toward maintaining the friendship
; 5430 : 						iValue += iFriendshipWithMinor * 2;

	lea	esi, DWORD PTR [esi+esi+100]

; 5431 : 					}
; 5432 : 				}
; 5433 : 				break;

	jmp	SHORT $LN4@BuildMinor
$LN7@BuildMinor:

; 5434 : 			case PLAN_ATTACK_CS_TO_PREVENT_DEFEAT:
; 5435 : 				// attack the least protected cities
; 5436 : 				if (pMinorCivAI->IsAllies(eCurrentDiploThreat))

	mov	ecx, DWORD PTR _eCurrentDiploThreat$[esp+104]
	push	ecx
	mov	ecx, edi
	call	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAllies
	test	al, al
	je	SHORT $LN4@BuildMinor

; 5437 : 				{
; 5438 : 					iValue = MAX_INT - pMinorCivAI->GetEffectiveFriendshipWithMajor(eCurrentDiploThreat);

	mov	edx, DWORD PTR _eCurrentDiploThreat$[esp+104]
	push	edx

; 5439 : 				}
; 5440 : 				break;

	jmp	SHORT $LN353@BuildMinor
$LN5@BuildMinor:

; 5441 : 			case PLAN_DEFEND_CS_FOR_WIN:
; 5442 : 				// defend the least defended cities!
; 5443 : 				if (pMinorCivAI->IsAllies(eCurrentDiploThreat))

	mov	eax, DWORD PTR _eCurrentDiploThreat$[esp+104]
	push	eax
	mov	ecx, edi
	call	?IsAllies@CvMinorCivAI@@QBE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsAllies
	test	al, al
	je	SHORT $LN4@BuildMinor

; 5444 : 				{
; 5445 : 					iValue = MAX_INT - pMinorCivAI->GetEffectiveFriendshipWithMajor(eCurrentDiploThreat);

	mov	ecx, DWORD PTR _eCurrentDiploThreat$[esp+104]
	push	ecx
$LN353@BuildMinor:
	mov	ecx, edi
	call	?GetEffectiveFriendshipWithMajor@CvMinorCivAI@@QAEHW4PlayerTypes@@@Z ; CvMinorCivAI::GetEffectiveFriendshipWithMajor
	mov	esi, 2147483647				; 7fffffffH
	sub	esi, eax
$LN4@BuildMinor:

; 5446 : 				}
; 5447 : 			}
; 5448 : 
; 5449 : 			kEntry.m_iScore = iValue;
; 5450 : 			aCityScores.push_back(kEntry);

	lea	edx, DWORD PTR _kEntry$226331[esp+104]
	push	edx
	lea	ecx, DWORD PTR _aCityScores$[esp+108]
	mov	DWORD PTR _kEntry$226331[esp+112], esi
	call	?push_back@?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAEXABUScoreCityEntry@@@Z ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::push_back
$LN45@BuildMinor:
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+108]
	lea	ecx, DWORD PTR [ebx+eax]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	$LL46@BuildMinor
$LN349@BuildMinor:

; 5298 : 		
; 5299 : 		bool bAlreadyScoredCity = false;
; 5300 : 		for (pLoopCity = GET_PLAYER(eTargetPlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eTargetPlayer).nextCity(&iLoop))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
$LN52@BuildMinor:

; 5267 : 	for(uint ui = MAX_MAJOR_CIVS; ui < MAX_CIV_PLAYERS; ui++)

	inc	DWORD PTR _ui$226311[esp+104]
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 3983868				; 003cc9fcH
	jb	$LL351@BuildMinor

; 5451 : 		}
; 5452 : 	}
; 5453 : 
; 5454 : 	// sort
; 5455 : 	std::stable_sort(aCityScores.begin(), aCityScores.end(), ScoreCityEntryHighEval());

	mov	ebp, DWORD PTR _aCityScores$[esp+108]
	mov	esi, DWORD PTR _aCityScores$[esp+112]
	mov	BYTE PTR $T261908[esp+104], 0
	cmp	ebp, esi
	je	SHORT $LN350@BuildMinor
	mov	eax, DWORD PTR $T261908[esp+104]
	push	eax
	push	0
	push	0
	push	esi
	push	ebp
	call	??$_Stable_sort@V?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@HUScoreCityEntry@@UScoreCityEntryHighEval@@@std@@YAXV?$_Vector_iterator@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@0@0PAHPAUScoreCityEntry@@UScoreCityEntryHighEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<ScoreCityEntry,std::allocator<ScoreCityEntry> >,int,ScoreCityEntry,ScoreCityEntryHighEval>
	add	esp, 20					; 00000014H
$LN350@BuildMinor:

; 5456 : 
; 5457 : 	// transfer values to OffenseCityList
; 5458 : 	for(uint ui = 0; ui < aCityScores.size(); ui++)

	sub	esi, ebp
	sar	esi, 3
	test	esi, esi
	jbe	SHORT $LN1@BuildMinor
	mov	edi, ebp
$LL347@BuildMinor:

; 5459 : 	{
; 5460 : 		aMinorCityList.push_back(aCityScores[ui].m_pCity);

	mov	eax, DWORD PTR _aMinorCityList$[esp+100]
	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	jne	SHORT $LN277@BuildMinor
	xor	ecx, ecx
	jmp	SHORT $LN278@BuildMinor
$LN277@BuildMinor:
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, edx
	sar	ecx, 2
$LN278@BuildMinor:
	mov	eax, DWORD PTR [eax+8]
	mov	ebx, eax
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, ecx
	jae	SHORT $LN270@BuildMinor
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _aMinorCityList$[esp+100]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN2@BuildMinor
$LN270@BuildMinor:
	mov	ecx, DWORD PTR _aMinorCityList$[esp+100]
	push	edi
	push	1
	push	eax
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
$LN2@BuildMinor:
	add	edi, 8
	sub	esi, 1
	jne	SHORT $LL347@BuildMinor
$LN1@BuildMinor:

; 5461 : 	}
; 5462 : }

	test	ebp, ebp
	je	SHORT $LN335@BuildMinor
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN335@BuildMinor:
	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	4
	npad	3
$LN354@BuildMinor:
	DD	$LN5@BuildMinor
	DD	$LN7@BuildMinor
	DD	$LN13@BuildMinor
	DD	$LN39@BuildMinor
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _aCityScores$[ebp]
	jmp	??1?$vector@UScoreCityEntry@@V?$allocator@UScoreCityEntry@@@std@@@std@@QAE@XZ ; std::vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >::~vector<ScoreCityEntry,std::allocator<ScoreCityEntry> >
__ehhandler$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ENDP ; CvEspionageAI::BuildMinorCityList
PUBLIC	?push_back@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXABUIntrigueNotificationMessage@@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXABUIntrigueNotificationMessage@@@Z
_TEXT	SEGMENT
$T262973 = -4						; size = 1
__Cat$262976 = 8					; size = 1
$T262942 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXABUIntrigueNotificationMessage@@@Z PROC ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@10
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@10
$LN9@push_back@10:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@10:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@10

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$262976[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T262973[esp+16], 0
	mov	ecx, DWORD PTR $T262973[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUIntrigueNotificationMessage@@IU1@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@YAXPAUIntrigueNotificationMessage@@IABU1@AAV?$allocator@UIntrigueNotificationMessage@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<IntrigueNotificationMessage *,unsigned int,IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >
	add	esp, 24					; 00000018H
	add	edi, 68					; 00000044H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@10:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T262942[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAE?AV?$_Vector_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@V?$_Vector_const_iterator@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@2@ABUIntrigueNotificationMessage@@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXABUIntrigueNotificationMessage@@@Z ENDP ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::push_back
_TEXT	ENDS
PUBLIC	?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z ; CvPlayerEspionage::AddIntrigueMessage
EXTRN	?getCivilizationDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationDescriptionKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z DD 019930522H
	DD	030H
	DD	FLAT:__unwindtable$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$16
	DD	0fH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$18
	DD	012H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$19
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$20
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$21
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$22
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$23
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$24
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$25
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$26
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$27
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$28
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$29
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$30
	DD	013H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$31
	DD	00H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$32
	DD	020H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$33
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$34
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$35
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$36
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$37
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$38
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$39
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$40
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$41
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$42
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$43
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$44
	DD	021H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$45
	DD	00H
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$46
	DD	02eH
	DD	FLAT:__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$47
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z
_TEXT	SEGMENT
tv3172 = -2968						; size = 4
_eNotification$224108 = -2968				; size = 4
_eNotification$224025 = -2968				; size = 4
_iCityX$ = -2968					; size = 4
_pNotifications$223919 = -2964				; size = 4
_iCityY$ = -2964					; size = 4
_kMessage$ = -2960					; size = 68
_strSummary$224189 = -2892				; size = 80
_strNotification$224107 = -2892				; size = 80
_strNotification$224024 = -2892				; size = 80
_strSummary$224006 = -2892				; size = 80
_strSummary$223989 = -2892				; size = 80
_strNotification$223927 = -2892				; size = 80
_strNotification$224205 = -2812				; size = 80
_strSummary$224106 = -2812				; size = 80
_strSummary$224023 = -2812				; size = 80
_strNotification$224007 = -2812				; size = 80
_strNotification$223990 = -2812				; size = 80
_strSummary$223926 = -2812				; size = 80
_str$223913 = -2812					; size = 80
$T263063 = -2732					; size = 80
$T263078 = -2652					; size = 80
$T263003 = -2572					; size = 80
$T263083 = -2492					; size = 80
$T263012 = -2412					; size = 80
$T263084 = -2332					; size = 80
$T263023 = -2252					; size = 80
$T263085 = -2172					; size = 80
$T263034 = -2092					; size = 80
$T263086 = -2012					; size = 80
$T263042 = -1932					; size = 80
$T263092 = -1852					; size = 80
$T263051 = -1772					; size = 80
$T263096 = -1692					; size = 80
$T263059 = -1612					; size = 80
$T263101 = -1532					; size = 80
$T263067 = -1452					; size = 80
$T263104 = -1372					; size = 80
$T263009 = -1292					; size = 80
$T263108 = -1212					; size = 80
$T263031 = -1132					; size = 80
$T263112 = -1052					; size = 80
$T263047 = -972						; size = 80
$T263118 = -892						; size = 80
$T263000 = -812						; size = 80
$T263123 = -732						; size = 80
$T263018 = -652						; size = 80
$T263128 = -572						; size = 80
$T263056 = -492						; size = 80
$T263129 = -412						; size = 80
$T263039 = -332						; size = 80
$T263130 = -252						; size = 80
$T263073 = -172						; size = 80
$T263131 = -92						; size = 80
__$EHRec$ = -12						; size = 12
_eDiscoveringPlayer$ = 8				; size = 4
_eSourcePlayer$ = 12					; size = 4
_eTargetPlayer$ = 16					; size = 4
_eBuilding$ = 20					; size = 4
_eProject$ = 24						; size = 4
_eIntrigueType$ = 28					; size = 4
_uiSpyIndex$ = 32					; size = 4
_pCity$ = 36						; size = 4
_bShowNotification$ = 40				; size = 1
?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z PROC ; CvPlayerEspionage::AddIntrigueMessage, COMDAT
; _this$ = ecx

; 2607 : {

	push	-1
	push	__ehhandler$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 2956				; 00000b8cH
	push	ebx

; 2608 : 	CvAssertMsg(GetNumSpies() > 0, "How can you add an intrigue message when there are no spies?");
; 2609 : 
; 2610 : 	int iCityX = -1;

	or	eax, -1
	push	ebp
	mov	DWORD PTR _iCityX$[esp+2976], eax

; 2611 : 	int iCityY = -1;

	mov	DWORD PTR _iCityY$[esp+2976], eax

; 2612 : 	if(pCity)

	mov	eax, DWORD PTR _pCity$[esp+2972]
	push	esi
	push	edi
	mov	edi, ecx
	test	eax, eax
	je	SHORT $LN167@AddIntrigu

; 2613 : 	{
; 2614 : 		iCityX = pCity->getX();

	mov	ecx, DWORD PTR [eax+96]

; 2615 : 		iCityY = pCity->getY();

	mov	edx, DWORD PTR [eax+108]
	mov	DWORD PTR _iCityX$[esp+2984], ecx
	mov	DWORD PTR _iCityY$[esp+2984], edx
$LN167@AddIntrigu:

; 2616 : 	}
; 2617 : 
; 2618 : 	// go through all the intrigue messages to see if there is a duplicate
; 2619 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [edi+1288]
	sub	ecx, DWORD PTR [edi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebx, ebx
	add	eax, edx
	je	$LN109@AddIntrigu
	xor	ebp, ebp
	npad	4
$LL111@AddIntrigu:

; 2620 : 	{
; 2621 : 		if (m_aIntrigueNotificationMessages[ui].m_eSourcePlayer == eSourcePlayer &&
; 2622 : 			m_aIntrigueNotificationMessages[ui].m_eTargetPlayer == eTargetPlayer &&
; 2623 : 			m_aIntrigueNotificationMessages[ui].m_iIntrigueType == eIntrigueType)

	mov	ecx, DWORD PTR [edi+1284]
	mov	edx, DWORD PTR _eSourcePlayer$[esp+2980]
	cmp	DWORD PTR [ecx+ebp+4], edx
	lea	esi, DWORD PTR [ecx+ebp]
	jne	$LN110@AddIntrigu
	mov	eax, DWORD PTR _eTargetPlayer$[esp+2980]
	cmp	DWORD PTR [esi+8], eax
	jne	SHORT $LN110@AddIntrigu
	mov	ecx, DWORD PTR _eIntrigueType$[esp+2980]
	cmp	DWORD PTR [esi+20], ecx
	jne	SHORT $LN110@AddIntrigu

; 2624 : 		{
; 2625 : 			bool bDuplicateTimer = GC.getGame().getGameTurn() - m_aIntrigueNotificationMessages[ui].m_iTurnNum < 30;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR [esi+24]
	cmp	eax, 30					; 0000001eH
	setl	cl

; 2626 : 
; 2627 : 			if (eIntrigueType == INTRIGUE_TYPE_DECEPTION || eIntrigueType == INTRIGUE_TYPE_BUILDING_ARMY || eIntrigueType == INTRIGUE_TYPE_BUILDING_AMPHIBIOUS_ARMY)

	cmp	DWORD PTR _eIntrigueType$[esp+2980], 0
	je	SHORT $LN106@AddIntrigu
	mov	eax, DWORD PTR _eIntrigueType$[esp+2980]
	cmp	eax, 1
	je	SHORT $LN106@AddIntrigu
	cmp	eax, 2
	je	SHORT $LN106@AddIntrigu

; 2630 : 				{
; 2631 : 					// if duplicate is found, exit the function
; 2632 : 					return;
; 2633 : 				}
; 2634 : 			}
; 2635 : 			else if (m_aIntrigueNotificationMessages[ui].m_eBuilding == eBuilding &&
; 2636 : 					 m_aIntrigueNotificationMessages[ui].m_eProject == eProject &&
; 2637 : 					 m_aIntrigueNotificationMessages[ui].m_iCityX == iCityX &&
; 2638 : 					 m_aIntrigueNotificationMessages[ui].m_iCityY == iCityY)

	mov	edx, DWORD PTR [edi+1284]
	lea	eax, DWORD PTR [edx+ebp]
	mov	edx, DWORD PTR _eBuilding$[esp+2980]
	cmp	DWORD PTR [eax+12], edx
	jne	SHORT $LN110@AddIntrigu
	mov	edx, DWORD PTR _eProject$[esp+2980]
	cmp	DWORD PTR [eax+16], edx
	jne	SHORT $LN110@AddIntrigu
	mov	edx, DWORD PTR _iCityX$[esp+2984]
	cmp	DWORD PTR [eax+28], edx
	jne	SHORT $LN110@AddIntrigu
	mov	edx, DWORD PTR _iCityY$[esp+2984]
	cmp	DWORD PTR [eax+32], edx
	jne	SHORT $LN110@AddIntrigu
$LN106@AddIntrigu:

; 2628 : 			{
; 2629 : 				if(bDuplicateTimer)

	test	cl, cl
	jne	$LN113@AddIntrigu
$LN110@AddIntrigu:

; 2616 : 	}
; 2617 : 
; 2618 : 	// go through all the intrigue messages to see if there is a duplicate
; 2619 : 	for(uint ui = 0; ui < m_aIntrigueNotificationMessages.size(); ui++)

	mov	ecx, DWORD PTR [edi+1288]
	sub	ecx, DWORD PTR [edi+1284]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	add	ebp, 68					; 00000044H
	cmp	ebx, eax
	jb	$LL111@AddIntrigu
$LN109@AddIntrigu:

; 2639 : 			{
; 2640 : 				if(bDuplicateTimer)
; 2641 : 				{
; 2642 : 					// if duplicate is found, exit the function
; 2643 : 					return;
; 2644 : 				}
; 2645 : 			}
; 2646 : 		}
; 2647 : 	}
; 2648 : 
; 2649 : 	// no matching message found so adding it to the list
; 2650 : 	IntrigueNotificationMessage kMessage;

	lea	ecx, DWORD PTR _kMessage$[esp+3020]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2651 : 	kMessage.m_eDiscoveringPlayer = eDiscoveringPlayer;
; 2652 : 	kMessage.m_eSourcePlayer = eSourcePlayer;

	mov	ecx, DWORD PTR _eSourcePlayer$[esp+2980]

; 2653 : 	kMessage.m_eTargetPlayer = eTargetPlayer;

	mov	edx, DWORD PTR _eTargetPlayer$[esp+2980]

; 2654 : 	kMessage.m_eBuilding = eBuilding;

	mov	eax, DWORD PTR _eBuilding$[esp+2980]
	mov	esi, DWORD PTR _eDiscoveringPlayer$[esp+2980]
	mov	DWORD PTR _kMessage$[esp+2988], ecx

; 2655 : 	kMessage.m_eProject = eProject;

	mov	ecx, DWORD PTR _eProject$[esp+2980]
	mov	DWORD PTR _kMessage$[esp+3000], ecx

; 2656 : 	kMessage.m_iIntrigueType = eIntrigueType;
; 2657 : 	kMessage.m_iCityX = iCityX;
; 2658 : 	kMessage.m_iCityY = iCityY;

	mov	ecx, DWORD PTR _iCityY$[esp+2984]
	mov	DWORD PTR _kMessage$[esp+2992], edx
	mov	edx, DWORD PTR _eIntrigueType$[esp+2980]
	mov	DWORD PTR _kMessage$[esp+2996], eax
	mov	eax, DWORD PTR _iCityX$[esp+2984]
	mov	DWORD PTR _kMessage$[esp+3016], ecx

; 2659 : 	kMessage.m_iTurnNum = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR __$EHRec$[esp+2992], 0
	mov	DWORD PTR _kMessage$[esp+2984], esi
	mov	DWORD PTR _kMessage$[esp+3004], edx
	mov	DWORD PTR _kMessage$[esp+3012], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2660 : 	kMessage.m_strSpyName = "";

	push	OFFSET $SG223911
	lea	ecx, DWORD PTR _kMessage$[esp+3024]
	mov	DWORD PTR _kMessage$[esp+3012], eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 2661 : 	if (eDiscoveringPlayer == m_pPlayer->GetID())

	mov	edx, DWORD PTR [edi+1296]
	cmp	esi, DWORD PTR [edx+44]
	mov	ebp, DWORD PTR _uiSpyIndex$[esp+2980]
	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	jne	$LN101@AddIntrigu

; 2662 : 	{
; 2663 : 		Localization::String str = Localization::Lookup("TXT_KEY_SPY_FULL_NAME");

	lea	eax, DWORD PTR _str$223913[esp+2984]
	push	OFFSET $SG223915
	push	eax
	call	ebx
	add	esp, 8

; 2664 : 		str << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [ebp*8]
	sub	eax, ebp
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv3172[esp+2984], eax
	mov	eax, DWORD PTR [ecx+eax+12]
	sub	eax, 0
	mov	BYTE PTR __$EHRec$[esp+2992], 1
	je	SHORT $LN211@AddIntrigu
	sub	eax, 1
	je	SHORT $LN210@AddIntrigu
	sub	eax, 1
	je	SHORT $LN209@AddIntrigu
	mov	eax, OFFSET $SG223399
	jmp	SHORT $LN214@AddIntrigu
$LN209@AddIntrigu:
	mov	eax, OFFSET $SG223398
	jmp	SHORT $LN214@AddIntrigu
$LN210@AddIntrigu:
	mov	eax, OFFSET $SG223396
	jmp	SHORT $LN214@AddIntrigu
$LN211@AddIntrigu:
	mov	eax, OFFSET $SG223394
$LN214@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _str$223913[esp+2988]
	call	esi

; 2665 : 		str << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	add	eax, DWORD PTR tv3172[esp+2984]
	mov	ecx, DWORD PTR [edi+1296]
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _str$223913[esp+2988]
	call	esi

; 2666 : 		kMessage.m_strSpyName = str.toUTF8();

	lea	ecx, DWORD PTR _str$223913[esp+2984]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	lea	ecx, DWORD PTR _kMessage$[esp+3020]
	test	eax, eax
	je	SHORT $LN223@AddIntrigu
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN222@AddIntrigu
$LN223@AddIntrigu:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN222@AddIntrigu:

; 2667 : 	}

	lea	ecx, DWORD PTR _str$223913[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN101@AddIntrigu:

; 2668 : 	kMessage.m_bShared = false;
; 2669 : 	m_aIntrigueNotificationMessages.push_back(kMessage);

	lea	eax, DWORD PTR _kMessage$[esp+2984]
	push	eax
	lea	ecx, DWORD PTR [edi+1280]
	mov	BYTE PTR _kMessage$[esp+3052], 0
	call	?push_back@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXABUIntrigueNotificationMessage@@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::push_back

; 2670 : 
; 2671 : 	if (bShowNotification)

	cmp	BYTE PTR _bShowNotification$[esp+2980], 0
	je	$LN97@AddIntrigu

; 2672 : 	{
; 2673 : 		CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [edi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$223919[esp+2984], eax

; 2674 : 		CvAssertMsg(pNotifications, "No notifications found. This is wrong!");
; 2675 : 		if(!pNotifications)

	test	eax, eax

; 2676 : 		{
; 2677 : 			return;

	je	$LN97@AddIntrigu

; 2678 : 		}
; 2679 : 
; 2680 : 		switch(kMessage.m_iIntrigueType)

	mov	eax, DWORD PTR _kMessage$[esp+3004]
	cmp	eax, 5
	ja	$LN97@AddIntrigu
	jmp	DWORD PTR $LN825@AddIntrigu[eax*4]
$LN96@AddIntrigu:

; 2681 : 		{
; 2682 : 		case INTRIGUE_TYPE_DECEPTION:
; 2683 : 			{
; 2684 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$223926[esp+2984]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2685 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223927[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 2
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2686 : 				if(kMessage.m_eTargetPlayer == m_pPlayer->GetID())  // if we found intrigue related to us

	mov	ecx, DWORD PTR [edi+1296]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	mov	BYTE PTR __$EHRec$[esp+2992], 3
	cmp	ecx, eax
	jne	$LN95@AddIntrigu

; 2687 : 				{
; 2688 : 					strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_YOU_S");

	lea	edx, DWORD PTR $T263000[esp+2984]
	push	OFFSET $SG223930
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223926[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 4
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263000[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2689 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN94@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN94@AddIntrigu

; 2690 : 					{
; 2691 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2692 : 					}
; 2693 : 					else

	jmp	SHORT $LN785@AddIntrigu
$LN94@AddIntrigu:

; 2694 : 					{
; 2695 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN785@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$223926[esp+2988]
	call	esi

; 2696 : 					}
; 2697 : 
; 2698 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_YOU");

	lea	eax, DWORD PTR $T263003[esp+2984]
	push	OFFSET $SG223936
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 5
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263003[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2699 : 					strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ecx+ebx+12]
	push	edx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2700 : 					strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2701 : 					CvAssertMsg(pCity, "City should be defined but is null");
; 2702 : 					if(pCity)

	cmp	DWORD PTR _pCity$[esp+2980], 0
	je	SHORT $LN256@AddIntrigu

; 2703 : 					{
; 2704 : 						strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi
$LN256@AddIntrigu:

; 2705 : 					}
; 2706 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN91@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN91@AddIntrigu

; 2707 : 					{
; 2708 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
$LN792@AddIntrigu:
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2709 : 					}
; 2710 : 					else

	jmp	$LN786@AddIntrigu
$LN91@AddIntrigu:

; 2711 : 					{
; 2712 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]

; 2713 : 					}

	jmp	$LN787@AddIntrigu
$LN95@AddIntrigu:

; 2714 : 				}
; 2715 : 				else if(kMessage.m_eTargetPlayer == NO_PLAYER)  // if we don't know who the intrigue information is about

	cmp	ecx, -1
	jne	$LN88@AddIntrigu

; 2716 : 				{
; 2717 : 					strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_UNKNOWN_S");

	lea	ecx, DWORD PTR $T263009[esp+2984]
	push	OFFSET $SG223948
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223926[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 6
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263009[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2718 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN87@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN87@AddIntrigu

; 2719 : 					{
; 2720 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2721 : 					}
; 2722 : 					else

	jmp	SHORT $LN788@AddIntrigu
$LN87@AddIntrigu:

; 2723 : 					{
; 2724 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN788@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$223926[esp+2988]
	call	esi

; 2725 : 					}
; 2726 : 
; 2727 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_UNKNOWN");

	lea	edx, DWORD PTR $T263012[esp+2984]
	push	OFFSET $SG223954
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 7
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263012[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2728 : 					strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx+12]
	push	ecx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2729 : 					strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2730 : 					CvAssertMsg(pCity, "City should be defined but is null");
; 2731 : 					if(pCity)

	cmp	DWORD PTR _pCity$[esp+2980], 0
	je	SHORT $LN290@AddIntrigu

; 2732 : 					{
; 2733 : 						strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi
$LN290@AddIntrigu:

; 2734 : 					}
; 2735 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	$LN91@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN91@AddIntrigu

; 2736 : 					{
; 2737 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2738 : 					}
; 2739 : 					else

	jmp	$LN786@AddIntrigu
$LN88@AddIntrigu:

; 2740 : 					{
; 2741 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();
; 2742 : 					}
; 2743 : 				}
; 2744 : 				else // if we found intrigue related to another player
; 2745 : 				{
; 2746 : 					strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_KNOWN_S");

	lea	eax, DWORD PTR $T263018[esp+2984]
	push	OFFSET $SG223965
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223926[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 8
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263018[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2747 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN81@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN81@AddIntrigu

; 2748 : 					{
; 2749 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2750 : 					}
; 2751 : 					else

	jmp	SHORT $LN789@AddIntrigu
$LN81@AddIntrigu:

; 2752 : 					{
; 2753 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN789@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$223926[esp+2988]
	call	esi

; 2754 : 					}
; 2755 : 
; 2756 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eTargetPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN79@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN79@AddIntrigu

; 2757 : 					{
; 2758 : 						strSummary << GET_PLAYER(kMessage.m_eTargetPlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2759 : 					}
; 2760 : 					else

	jmp	SHORT $LN790@AddIntrigu
$LN79@AddIntrigu:

; 2761 : 					{
; 2762 : 						strSummary << GET_PLAYER(kMessage.m_eTargetPlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN790@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$223926[esp+2988]
	call	esi

; 2763 : 					}
; 2764 : 
; 2765 : 					strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_PLOTTING_AGAINST_KNOWN");

	lea	ecx, DWORD PTR $T263023[esp+2984]
	push	OFFSET $SG223975
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 9
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263023[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 3
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2766 : 					strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	edx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [edx+ebx+12]
	push	eax
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2767 : 					strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	ecx
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2768 : 					CvAssertMsg(pCity, "City should be defined but is null");
; 2769 : 					if(pCity)

	cmp	DWORD PTR _pCity$[esp+2980], 0
	je	SHORT $LN336@AddIntrigu

; 2770 : 					{
; 2771 : 						strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi
$LN336@AddIntrigu:

; 2772 : 					}
; 2773 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN76@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN76@AddIntrigu

; 2774 : 					{
; 2775 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2776 : 					}
; 2777 : 					else

	jmp	SHORT $LN791@AddIntrigu
$LN76@AddIntrigu:

; 2778 : 					{
; 2779 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN791@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2780 : 					}
; 2781 : 
; 2782 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eTargetPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN74@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN74@AddIntrigu

; 2783 : 					{
; 2784 : 						strNotification << GET_PLAYER(kMessage.m_eTargetPlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]

; 2785 : 					}
; 2786 : 					else

	jmp	$LN792@AddIntrigu
$LN74@AddIntrigu:

; 2787 : 					{
; 2788 : 						strNotification << GET_PLAYER(kMessage.m_eTargetPlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
$LN787@AddIntrigu:
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN786@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+2988]
	call	esi

; 2789 : 					}
; 2790 : 				}
; 2791 : 				pNotifications->Add(NOTIFICATION_INTRIGUE_DECEPTION, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, kMessage.m_eTargetPlayer);

	mov	edx, DWORD PTR _kMessage$[esp+2992]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	edx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223926[esp+3000]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$223927[esp+3004]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$223919[esp+3004]
	push	eax
	push	507398241				; 1e3e4861H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2792 : 			}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$223927[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 2
	call	esi
	lea	ecx, DWORD PTR _strSummary$223926[esp+2984]

; 2793 : 			break;

	jmp	$LN793@AddIntrigu
$LN72@AddIntrigu:

; 2794 : 		case INTRIGUE_TYPE_BUILDING_ARMY:
; 2795 : 			{
; 2796 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$223989[esp+2984]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2797 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$223990[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 10	; 0000000aH
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2798 : 
; 2799 : 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_ARMY_S");

	lea	eax, DWORD PTR $T263031[esp+2984]
	push	OFFSET $SG223992
	push	eax
	mov	BYTE PTR __$EHRec$[esp+3000], 11	; 0000000bH
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$223989[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 12	; 0000000cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263031[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 11	; 0000000bH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2800 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN71@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN71@AddIntrigu

; 2801 : 				{
; 2802 : 					strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2803 : 				}
; 2804 : 				else

	jmp	SHORT $LN794@AddIntrigu
$LN71@AddIntrigu:

; 2805 : 				{
; 2806 : 					strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN794@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$223989[esp+2988]
	call	esi

; 2807 : 				}
; 2808 : 
; 2809 : 				strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_ARMY");

	lea	ecx, DWORD PTR $T263034[esp+2984]
	push	OFFSET $SG223998
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$223990[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 13	; 0000000dH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263034[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 11	; 0000000bH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2810 : 				strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	edx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [edx+ebx+12]
	push	eax
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$223990[esp+2988]
	call	esi

; 2811 : 				strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	ecx
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223990[esp+2988]
	call	esi

; 2812 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN69@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN69@AddIntrigu

; 2813 : 				{
; 2814 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2815 : 				}
; 2816 : 				else

	jmp	SHORT $LN795@AddIntrigu
$LN69@AddIntrigu:

; 2817 : 				{
; 2818 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN795@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strNotification$223990[esp+2988]
	call	esi

; 2819 : 				}
; 2820 : 
; 2821 : 				pNotifications->Add(NOTIFICATION_INTRIGUE_BUILDING_SNEAK_ATTACK_ARMY, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223989[esp+3000]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$223990[esp+3004]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$223919[esp+3004]
	push	eax
	push	402583486				; 17feefbeH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2822 : 			}

	mov	BYTE PTR __$EHRec$[esp+2992], 10	; 0000000aH

; 2823 : 			break;

	jmp	$LN796@AddIntrigu
$LN67@AddIntrigu:

; 2824 : 		case INTRIGUE_TYPE_BUILDING_AMPHIBIOUS_ARMY:
; 2825 : 			{
; 2826 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$224006[esp+2984]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2827 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$224007[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 14	; 0000000eH
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2828 : 
; 2829 : 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_AMPHIBIOUS_ARMY_S");

	lea	edx, DWORD PTR $T263039[esp+2984]
	push	OFFSET $SG224009
	push	edx
	mov	BYTE PTR __$EHRec$[esp+3000], 15	; 0000000fH
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224006[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 16	; 00000010H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263039[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 15	; 0000000fH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2830 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN66@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN66@AddIntrigu

; 2831 : 				{
; 2832 : 					strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2833 : 				}
; 2834 : 				else

	jmp	SHORT $LN797@AddIntrigu
$LN66@AddIntrigu:

; 2835 : 				{
; 2836 : 					strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN797@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224006[esp+2988]
	call	esi

; 2837 : 				}
; 2838 : 
; 2839 : 				strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_BUILDING_AMPHIBIOUS_ARMY");

	lea	eax, DWORD PTR $T263042[esp+2984]
	push	OFFSET $SG224015
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224007[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 17	; 00000011H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263042[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 15	; 0000000fH
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2840 : 				strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ecx+ebx+12]
	push	edx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224007[esp+2988]
	call	esi

; 2841 : 				strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224007[esp+2988]
	call	esi

; 2842 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN64@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN64@AddIntrigu

; 2843 : 				{
; 2844 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2845 : 				}
; 2846 : 				else

	jmp	SHORT $LN798@AddIntrigu
$LN64@AddIntrigu:

; 2847 : 				{
; 2848 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN798@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strNotification$224007[esp+2988]
	call	esi

; 2849 : 				}
; 2850 : 
; 2851 : 				pNotifications->Add(NOTIFICATION_INTRIGUE_BUILDING_SNEAK_ATTACK_AMPHIBIOUS, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$224006[esp+3000]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$224007[esp+3004]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$223919[esp+3004]
	push	eax
	push	48950482				; 02eaecd2H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2852 : 			}

	mov	BYTE PTR __$EHRec$[esp+2992], 14	; 0000000eH

; 2853 : 			break;

	jmp	$LN796@AddIntrigu
$LN62@AddIntrigu:

; 2854 : 
; 2855 : 		case INTRIGUE_TYPE_ARMY_SNEAK_ATTACK:
; 2856 : 			{
; 2857 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$224023[esp+2984]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2858 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$224024[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 18	; 00000012H
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2859 : 				NotificationTypes eNotification;
; 2860 : 
; 2861 : 				// targeting me
; 2862 : 				if(kMessage.m_eTargetPlayer == m_pPlayer->GetID())

	mov	ecx, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _kMessage$[esp+2992]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	cmp	eax, ecx
	jne	$LN61@AddIntrigu

; 2863 : 				{
; 2864 : 					if(pCity)

	cmp	DWORD PTR _pCity$[esp+2980], 0
	je	$LN60@AddIntrigu

; 2865 : 					{
; 2866 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_KNOWN;
; 2867 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_KNOWN_S");

	lea	edx, DWORD PTR $T263047[esp+2984]
	push	OFFSET $SG224029
	push	edx
	mov	DWORD PTR _eNotification$224025[esp+2992], 617384028 ; 24cc885cH
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 20	; 00000014H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263047[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2868 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN59@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN59@AddIntrigu

; 2869 : 						{
; 2870 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2871 : 						}
; 2872 : 						else

	jmp	SHORT $LN799@AddIntrigu
$LN59@AddIntrigu:

; 2873 : 						{
; 2874 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN799@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2875 : 						}
; 2876 : 						strSummary << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2877 : 
; 2878 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_KNOWN");

	lea	eax, DWORD PTR $T263051[esp+2984]
	push	OFFSET $SG224036
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 21	; 00000015H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263051[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2879 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ecx+ebx+12]
	push	edx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2880 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2881 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
$LN808@AddIntrigu:
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2882 : 						strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey

; 2883 : 					}
; 2884 : 					else

	jmp	$LN800@AddIntrigu
$LN60@AddIntrigu:

; 2885 : 					{
; 2886 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_UNKNOWN;
; 2887 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_UNKNOWN_S");

	lea	ecx, DWORD PTR $T263056[esp+2984]
	push	OFFSET $SG224043
	push	ecx
	mov	DWORD PTR _eNotification$224025[esp+2992], 2135009779 ; 7f41a9f3H
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 22	; 00000016H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263056[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2888 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN56@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN56@AddIntrigu

; 2889 : 						{
; 2890 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2891 : 						}
; 2892 : 						else

	jmp	SHORT $LN801@AddIntrigu
$LN56@AddIntrigu:

; 2893 : 						{
; 2894 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN801@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2895 : 						}
; 2896 : 
; 2897 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_YOU_CITY_UNKNOWN");

	lea	edx, DWORD PTR $T263059[esp+2984]
	push	OFFSET $SG224049
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 23	; 00000017H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263059[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2898 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx+12]
	push	ecx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2899 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	edx

; 2900 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();
; 2901 : 					}

	jmp	$LN802@AddIntrigu
$LN61@AddIntrigu:

; 2902 : 				}
; 2903 : 				// targeting somebody else I know
; 2904 : 				else if(kMessage.m_eTargetPlayer != NO_PLAYER && kMessage.m_eTargetPlayer != MAX_MAJOR_CIVS)

	cmp	eax, -1
	je	$LN53@AddIntrigu
	cmp	eax, 22					; 00000016H
	je	$LN53@AddIntrigu

; 2905 : 				{
; 2906 : 					if(pCity)

	cmp	DWORD PTR _pCity$[esp+2980], 0
	je	$LN52@AddIntrigu

; 2907 : 					{
; 2908 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_KNOWN;
; 2909 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_KNOWN_S");

	lea	eax, DWORD PTR $T263063[esp+2984]
	push	OFFSET $SG224057
	push	eax
	mov	DWORD PTR _eNotification$224025[esp+2992], -1432015642 ; aaa52ce6H
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 24	; 00000018H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263063[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2910 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN51@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN51@AddIntrigu

; 2911 : 						{
; 2912 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2913 : 						}
; 2914 : 						else

	jmp	SHORT $LN803@AddIntrigu
$LN51@AddIntrigu:

; 2915 : 						{
; 2916 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN803@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2917 : 						}
; 2918 : 						strSummary << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2919 : 
; 2920 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_KNOWN");

	lea	ecx, DWORD PTR $T263067[esp+2984]
	push	OFFSET $SG224064
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 25	; 00000019H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263067[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2921 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	edx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [edx+ebx+12]
	push	eax
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2922 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	ecx
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2923 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2924 : 						strNotification << GET_PLAYER(kMessage.m_eTargetPlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]

; 2925 : 						strNotification << pCity->getNameKey();
; 2926 : 					}
; 2927 : 					else

	jmp	$LN808@AddIntrigu
$LN52@AddIntrigu:

; 2928 : 					{
; 2929 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_UNKNOWN;
; 2930 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_UNKNOWN_S");

	lea	edx, DWORD PTR $T263073[esp+2984]
	push	OFFSET $SG224072
	push	edx
	mov	DWORD PTR _eNotification$224025[esp+2992], -1328544167 ; b0d00659H
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 26	; 0000001aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263073[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2931 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN48@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN48@AddIntrigu

; 2932 : 						{
; 2933 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2934 : 						}
; 2935 : 						else

	jmp	SHORT $LN804@AddIntrigu
$LN48@AddIntrigu:

; 2936 : 						{
; 2937 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN804@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2938 : 						}
; 2939 : 
; 2940 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eTargetPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN46@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN46@AddIntrigu

; 2941 : 						{
; 2942 : 							strSummary << GET_PLAYER(kMessage.m_eTargetPlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2943 : 						}
; 2944 : 						else

	jmp	SHORT $LN805@AddIntrigu
$LN46@AddIntrigu:

; 2945 : 						{
; 2946 : 							strSummary << GET_PLAYER(kMessage.m_eTargetPlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN805@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2947 : 						}
; 2948 : 
; 2949 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_KNOWN_CITY_UNKNOWN");

	lea	eax, DWORD PTR $T263078[esp+2984]
	push	OFFSET $SG224082
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 27	; 0000001bH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263078[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2950 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ecx+ebx+12]
	push	edx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2951 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2952 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2953 : 						strNotification << GET_PLAYER(kMessage.m_eTargetPlayer).getCivilizationDescriptionKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationDescriptionKey

; 2954 : 					}
; 2955 : 				}
; 2956 : 				// targeting an unknown player
; 2957 : 				else

	jmp	$LN800@AddIntrigu
$LN53@AddIntrigu:

; 2958 : 				{
; 2959 : 					eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_UNKNOWN;

	mov	DWORD PTR _eNotification$224025[esp+2984], -265092093 ; f0330403H

; 2960 : 					// if the spy wasn't high enough rank to know who was being attacked
; 2961 : 					if (kMessage.m_eTargetPlayer == MAX_MAJOR_CIVS)

	cmp	eax, 22					; 00000016H
	jne	SHORT $LN43@AddIntrigu

; 2962 : 					{
; 2963 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_SOMEONE_S");

	lea	ecx, DWORD PTR $T263083[esp+2984]
	push	OFFSET $SG224090
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 28	; 0000001cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263083[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2964 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_SOMEONE");

	lea	edx, DWORD PTR $T263084[esp+2984]
	push	OFFSET $SG224092
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 29	; 0000001dH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263084[esp+2984]

; 2965 : 					}
; 2966 : 					else

	jmp	SHORT $LN806@AddIntrigu
$LN43@AddIntrigu:

; 2967 : 					{
; 2968 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_UNKNOWN_S");

	lea	eax, DWORD PTR $T263085[esp+2984]
	push	OFFSET $SG224095
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 30	; 0000001eH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263085[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2969 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_ARMY_AGAINST_UNKNOWN");

	lea	ecx, DWORD PTR $T263086[esp+2984]
	push	OFFSET $SG224097
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 31	; 0000001fH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263086[esp+2984]
$LN806@AddIntrigu:
	mov	BYTE PTR __$EHRec$[esp+2992], 19	; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 2970 : 					}
; 2971 : 
; 2972 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN41@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN41@AddIntrigu

; 2973 : 					{
; 2974 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 2975 : 					}
; 2976 : 					else

	jmp	SHORT $LN807@AddIntrigu
$LN41@AddIntrigu:

; 2977 : 					{
; 2978 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN807@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224023[esp+2988]
	call	esi

; 2979 : 					}
; 2980 : 
; 2981 : 					strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	edx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [edx+ebx+12]
	push	eax
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2982 : 					strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	ecx
$LN802@AddIntrigu:
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2983 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
$LN800@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+2988]
	call	esi

; 2984 : 				}
; 2985 : 
; 2986 : 				pNotifications->Add(eNotification, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, kMessage.m_eTargetPlayer);

	mov	edx, DWORD PTR _kMessage$[esp+2992]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	edx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$224023[esp+3000]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$224024[esp+3004]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$223919[esp+3004]
	push	eax
	mov	eax, DWORD PTR _eNotification$224025[esp+3008]
	push	eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2987 : 			}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$224024[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 18	; 00000012H
	call	esi
	lea	ecx, DWORD PTR _strSummary$224023[esp+2984]

; 2988 : 			break;

	jmp	$LN793@AddIntrigu
$LN39@AddIntrigu:

; 2989 : 		case INTRIGUE_TYPE_AMPHIBIOUS_SNEAK_ATTACK:
; 2990 : 			{
; 2991 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$224106[esp+2984]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2992 : 				Localization::String strNotification;

	lea	ecx, DWORD PTR _strNotification$224107[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 32	; 00000020H
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 2993 : 				NotificationTypes eNotification;
; 2994 : 
; 2995 : 				// targeting me
; 2996 : 				if(kMessage.m_eTargetPlayer == m_pPlayer->GetID())

	mov	ecx, DWORD PTR [edi+1296]
	mov	ecx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _kMessage$[esp+2992]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	cmp	eax, ecx
	jne	$LN38@AddIntrigu

; 2997 : 				{
; 2998 : 					if(pCity)

	cmp	DWORD PTR _pCity$[esp+2980], 0
	je	$LN37@AddIntrigu

; 2999 : 					{
; 3000 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_KNOWN;
; 3001 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_KNOWN_S");

	lea	edx, DWORD PTR $T263092[esp+2984]
	push	OFFSET $SG224112
	push	edx
	mov	DWORD PTR _eNotification$224108[esp+2992], -56440186 ; fca2ca86H
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 34	; 00000022H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263092[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3002 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN36@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN36@AddIntrigu

; 3003 : 						{
; 3004 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3005 : 						}
; 3006 : 						else

	jmp	SHORT $LN809@AddIntrigu
$LN36@AddIntrigu:

; 3007 : 						{
; 3008 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN809@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3009 : 						}
; 3010 : 						strSummary << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3011 : 
; 3012 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_KNOWN");

	lea	eax, DWORD PTR $T263096[esp+2984]
	push	OFFSET $SG224119
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 35	; 00000023H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263096[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3013 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ecx+ebx+12]
	push	edx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3014 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3015 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
$LN818@AddIntrigu:
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3016 : 						strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey

; 3017 : 					}
; 3018 : 					else

	jmp	$LN810@AddIntrigu
$LN37@AddIntrigu:

; 3019 : 					{
; 3020 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_UNKNOWN;
; 3021 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_UNKNOWN_S");

	lea	ecx, DWORD PTR $T263101[esp+2984]
	push	OFFSET $SG224126
	push	ecx
	mov	DWORD PTR _eNotification$224108[esp+2992], -1673233228 ; 9c447cb4H
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 36	; 00000024H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263101[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3022 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN33@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN33@AddIntrigu

; 3023 : 						{
; 3024 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3025 : 						}
; 3026 : 						else

	jmp	SHORT $LN811@AddIntrigu
$LN33@AddIntrigu:

; 3027 : 						{
; 3028 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN811@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3029 : 						}
; 3030 : 
; 3031 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_YOU_CITY_UNKNOWN");

	lea	edx, DWORD PTR $T263104[esp+2984]
	push	OFFSET $SG224132
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 37	; 00000025H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263104[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3032 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx+12]
	push	ecx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3033 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	edx

; 3034 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();
; 3035 : 					}

	jmp	$LN812@AddIntrigu
$LN38@AddIntrigu:

; 3036 : 				}
; 3037 : 				// targeting somebody else I know
; 3038 : 				else if(kMessage.m_eTargetPlayer != NO_PLAYER && kMessage.m_eTargetPlayer != MAX_MAJOR_CIVS)

	cmp	eax, -1
	je	$LN30@AddIntrigu
	cmp	eax, 22					; 00000016H
	je	$LN30@AddIntrigu

; 3039 : 				{
; 3040 : 					if(pCity)

	cmp	DWORD PTR _pCity$[esp+2980], 0
	je	$LN29@AddIntrigu

; 3041 : 					{
; 3042 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_KNOWN;
; 3043 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_KNOWN_S");

	lea	eax, DWORD PTR $T263108[esp+2984]
	push	OFFSET $SG224140
	push	eax
	mov	DWORD PTR _eNotification$224108[esp+2992], 1235286433 ; 49a0f9a1H
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 38	; 00000026H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263108[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3044 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN28@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN28@AddIntrigu

; 3045 : 						{
; 3046 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3047 : 						}
; 3048 : 						else

	jmp	SHORT $LN813@AddIntrigu
$LN28@AddIntrigu:

; 3049 : 						{
; 3050 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN813@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3051 : 						}
; 3052 : 						strSummary << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3053 : 
; 3054 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_KNOWN");

	lea	ecx, DWORD PTR $T263112[esp+2984]
	push	OFFSET $SG224147
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 39	; 00000027H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263112[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3055 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	edx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [edx+ebx+12]
	push	eax
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3056 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	ecx
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3057 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3058 : 						strNotification << GET_PLAYER(kMessage.m_eTargetPlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]

; 3059 : 						strNotification << pCity->getNameKey();
; 3060 : 					}
; 3061 : 					else

	jmp	$LN818@AddIntrigu
$LN29@AddIntrigu:

; 3062 : 					{
; 3063 : 						eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_UNKNOWN;
; 3064 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_UNKNOWN_S");

	lea	edx, DWORD PTR $T263118[esp+2984]
	push	OFFSET $SG224155
	push	edx
	mov	DWORD PTR _eNotification$224108[esp+2992], -112125243 ; f9511ac5H
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 40	; 00000028H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263118[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3065 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN25@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN25@AddIntrigu

; 3066 : 						{
; 3067 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3068 : 						}
; 3069 : 						else

	jmp	SHORT $LN814@AddIntrigu
$LN25@AddIntrigu:

; 3070 : 						{
; 3071 : 							strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN814@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3072 : 						}
; 3073 : 
; 3074 : 						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eTargetPlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN23@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN23@AddIntrigu

; 3075 : 						{
; 3076 : 							strSummary << GET_PLAYER(kMessage.m_eTargetPlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3077 : 						}
; 3078 : 						else

	jmp	SHORT $LN815@AddIntrigu
$LN23@AddIntrigu:

; 3079 : 						{
; 3080 : 							strSummary << GET_PLAYER(kMessage.m_eTargetPlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN815@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3081 : 						}
; 3082 : 
; 3083 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_KNOWN_CITY_UNKNOWN");

	lea	eax, DWORD PTR $T263123[esp+2984]
	push	OFFSET $SG224165
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 41	; 00000029H
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263123[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3084 : 						strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	ecx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ecx+ebx+12]
	push	edx
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3085 : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3086 : 						strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3087 : 						strNotification << GET_PLAYER(kMessage.m_eTargetPlayer).getCivilizationDescriptionKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2992]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationDescriptionKey

; 3088 : 					}
; 3089 : 				}
; 3090 : 				// targeting an unknown player
; 3091 : 				else

	jmp	$LN810@AddIntrigu
$LN30@AddIntrigu:

; 3092 : 				{
; 3093 : 					eNotification = NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_UNKNOWN;

	mov	DWORD PTR _eNotification$224108[esp+2984], 772849235 ; 2e10be53H

; 3094 : 
; 3095 : 					// if the spy wasn't high enough rank to know who was being attacked
; 3096 : 					if (kMessage.m_eTargetPlayer == MAX_MAJOR_CIVS)

	cmp	eax, 22					; 00000016H
	jne	SHORT $LN20@AddIntrigu

; 3097 : 					{
; 3098 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_SOMEONE_S");

	lea	ecx, DWORD PTR $T263128[esp+2984]
	push	OFFSET $SG224173
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 42	; 0000002aH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263128[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3099 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_SOMEONE");

	lea	edx, DWORD PTR $T263129[esp+2984]
	push	OFFSET $SG224175
	push	edx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 43	; 0000002bH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263129[esp+2984]

; 3100 : 					}
; 3101 : 					else

	jmp	SHORT $LN816@AddIntrigu
$LN20@AddIntrigu:

; 3102 : 					{
; 3103 : 						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_UNKNOWN_S");

	lea	eax, DWORD PTR $T263130[esp+2984]
	push	OFFSET $SG224178
	push	eax
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 44	; 0000002cH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263130[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3104 : 						strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_SNEAK_ATTACK_AMPHIB_AGAINST_UNKNOWN");

	lea	ecx, DWORD PTR $T263131[esp+2984]
	push	OFFSET $SG224180
	push	ecx
	call	ebx
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	mov	BYTE PTR __$EHRec$[esp+2996], 45	; 0000002dH
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T263131[esp+2984]
$LN816@AddIntrigu:
	mov	BYTE PTR __$EHRec$[esp+2992], 33	; 00000021H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3105 : 					}
; 3106 : 
; 3107 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN18@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN18@AddIntrigu

; 3108 : 					{
; 3109 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3110 : 					}
; 3111 : 					else

	jmp	SHORT $LN817@AddIntrigu
$LN18@AddIntrigu:

; 3112 : 					{
; 3113 : 						strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN817@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224106[esp+2988]
	call	esi

; 3114 : 					}
; 3115 : 
; 3116 : 					strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	edx, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	eax, DWORD PTR [edx+ebx+12]
	push	eax
	mov	ecx, edi
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3117 : 					strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	push	ecx
$LN812@AddIntrigu:
	mov	ecx, DWORD PTR [edi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3118 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
$LN810@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+2988]
	call	esi

; 3119 : 				}
; 3120 : 
; 3121 : 				pNotifications->Add(eNotification, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, kMessage.m_eTargetPlayer);

	mov	edx, DWORD PTR _kMessage$[esp+2992]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	edx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$224106[esp+3000]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$224107[esp+3004]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$223919[esp+3004]
	push	eax
	mov	eax, DWORD PTR _eNotification$224108[esp+3008]
	push	eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3122 : 			}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$224107[esp+2984]
	mov	BYTE PTR __$EHRec$[esp+2992], 32	; 00000020H
	call	esi
	lea	ecx, DWORD PTR _strSummary$224106[esp+2984]

; 3123 : 			break;

	jmp	$LN793@AddIntrigu
$LN16@AddIntrigu:

; 3124 : 		case INTRIGUE_TYPE_CONSTRUCTING_WONDER:
; 3125 : 			{
; 3126 : 				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_CONSTRUCT_WONDER_S");

	lea	ecx, DWORD PTR _strSummary$224189[esp+2984]
	push	OFFSET $SG224191
	push	ecx
	call	ebx
	add	esp, 8

; 3127 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+2992], 46	; 0000002eH
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN15@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN15@AddIntrigu

; 3128 : 				{
; 3129 : 					strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3130 : 				}
; 3131 : 				else

	jmp	SHORT $LN819@AddIntrigu
$LN15@AddIntrigu:

; 3132 : 				{
; 3133 : 					strSummary << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN819@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strSummary$224189[esp+2988]
	call	esi

; 3134 : 				}
; 3135 : 				
; 3136 : 				if (kMessage.m_eBuilding != NO_BUILDING)

	mov	eax, DWORD PTR _kMessage$[esp+2996]
	cmp	eax, -1
	je	SHORT $LN13@AddIntrigu

; 3137 : 				{
; 3138 : 					CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(kMessage.m_eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3139 : 					CvAssertMsg(pBuildingInfo, "pBuildingInfo is null");
; 3140 : 					if (pBuildingInfo)
; 3141 : 					{
; 3142 : 						strSummary << pBuildingInfo->GetTextKey();
; 3143 : 					}
; 3144 : 				}

	jmp	SHORT $LN821@AddIntrigu
$LN13@AddIntrigu:

; 3145 : 				else if (kMessage.m_eProject != NO_PROJECT)

	mov	eax, DWORD PTR _kMessage$[esp+3000]
	cmp	eax, -1
	je	SHORT $LN744@AddIntrigu

; 3146 : 				{
; 3147 : 					CvProjectEntry* pProjectInfo = GC.getProjectInfo(kMessage.m_eProject);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
$LN821@AddIntrigu:

; 3148 : 					CvAssertMsg(pProjectInfo, "pProjectInfo is null");
; 3149 : 					if (pProjectInfo)

	test	eax, eax
	je	SHORT $LN744@AddIntrigu

; 3150 : 					{
; 3151 : 						strSummary << pProjectInfo->GetTextKey();

	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$224189[esp+2988]
	call	esi
$LN744@AddIntrigu:

; 3152 : 					}
; 3153 : 				}
; 3154 : 
; 3155 : 				Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_INTRIGUE_CONSTRUCT_WONDER");

	lea	edx, DWORD PTR _strNotification$224205[esp+2984]
	push	OFFSET $SG224207
	push	edx
	call	ebx
	add	esp, 8

; 3156 : 				strNotification << GetSpyRankName(m_aSpyList[uiSpyIndex].m_eRank);

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ebp*8]
	sub	ebx, ebp
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [eax+ebx+12]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+2996], 47	; 0000002fH
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$224205[esp+2988]
	call	esi

; 3157 : 				strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [edi+1296]
	add	eax, ebx
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$224205[esp+2988]
	call	esi

; 3158 : 				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(kMessage.m_eSourcePlayer).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	je	SHORT $LN8@AddIntrigu
	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN8@AddIntrigu

; 3159 : 				{
; 3160 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNickName();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName

; 3161 : 				}
; 3162 : 				else

	jmp	SHORT $LN822@AddIntrigu
$LN8@AddIntrigu:

; 3163 : 				{
; 3164 : 					strNotification << GET_PLAYER(kMessage.m_eSourcePlayer).getNameKey();

	mov	ecx, DWORD PTR _kMessage$[esp+2988]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
$LN822@AddIntrigu:
	push	eax
	lea	ecx, DWORD PTR _strNotification$224205[esp+2988]
	call	esi

; 3165 : 				}
; 3166 : 
; 3167 : 				if (kMessage.m_eBuilding != NO_BUILDING)

	mov	eax, DWORD PTR _kMessage$[esp+2996]
	cmp	eax, -1
	je	SHORT $LN6@AddIntrigu

; 3168 : 				{
; 3169 : 					CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(kMessage.m_eBuilding);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 3170 : 					CvAssertMsg(pBuildingInfo, "pBuildingInfo is null");
; 3171 : 					if (pBuildingInfo)
; 3172 : 					{
; 3173 : 						strNotification << pBuildingInfo->GetTextKey();
; 3174 : 					}
; 3175 : 				}

	jmp	SHORT $LN824@AddIntrigu
$LN6@AddIntrigu:

; 3176 : 				else if (kMessage.m_eProject != NO_PROJECT)

	mov	eax, DWORD PTR _kMessage$[esp+3000]
	cmp	eax, -1
	je	SHORT $LN782@AddIntrigu

; 3177 : 				{
; 3178 : 					CvProjectEntry* pProjectInfo = GC.getProjectInfo(kMessage.m_eProject);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
$LN824@AddIntrigu:

; 3179 : 					CvAssertMsg(pProjectInfo, "pProjectInfo is null");
; 3180 : 					if (pProjectInfo)

	test	eax, eax
	je	SHORT $LN782@AddIntrigu

; 3181 : 					{
; 3182 : 						strNotification << pProjectInfo->GetTextKey();

	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224205[esp+2988]
	call	esi
$LN782@AddIntrigu:

; 3183 : 					}
; 3184 : 				}				
; 3185 : 
; 3186 : 				if (pCity)

	mov	ecx, DWORD PTR _pCity$[esp+2980]
	test	ecx, ecx
	je	SHORT $LN770@AddIntrigu

; 3187 : 				{
; 3188 : 					strNotification << pCity->getNameKey();

	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$224205[esp+2988]
	call	esi
$LN770@AddIntrigu:

; 3189 : 				}
; 3190 : 
; 3191 : 				pNotifications->Add(NOTIFICATION_INTRIGUE_CONSTRUCTING_WONDER, strNotification.toUTF8(), strSummary.toUTF8(), kMessage.m_iCityX, kMessage.m_iCityY, -1);

	mov	eax, DWORD PTR _kMessage$[esp+3016]
	mov	ecx, DWORD PTR _kMessage$[esp+3012]
	mov	esi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strSummary$224189[esp+3000]
	call	esi
	push	eax
	lea	ecx, DWORD PTR _strNotification$224205[esp+3004]
	call	esi
	mov	ecx, DWORD PTR _pNotifications$223919[esp+3004]
	push	eax
	push	1527505427				; 5b0be213H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3192 : 			}

	mov	BYTE PTR __$EHRec$[esp+2992], 46	; 0000002eH
$LN796@AddIntrigu:
	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$224205[esp+2984]
	call	esi
	lea	ecx, DWORD PTR _strSummary$224189[esp+2984]
$LN793@AddIntrigu:
	mov	BYTE PTR __$EHRec$[esp+2992], 0
	call	esi
$LN97@AddIntrigu:

; 3193 : 			break;
; 3194 : 		}
; 3195 : 	}
; 3196 : }

	lea	ecx, DWORD PTR _kMessage$[esp+3020]
	mov	DWORD PTR __$EHRec$[esp+2992], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN113@AddIntrigu:
	mov	ecx, DWORD PTR __$EHRec$[esp+2984]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 2968				; 00000b98H
	ret	36					; 00000024H
	npad	1
$LN825@AddIntrigu:
	DD	$LN96@AddIntrigu
	DD	$LN72@AddIntrigu
	DD	$LN67@AddIntrigu
	DD	$LN62@AddIntrigu
	DD	$LN39@AddIntrigu
	DD	$LN16@AddIntrigu
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$0:
	lea	ecx, DWORD PTR _kMessage$[ebp]
	jmp	??1IntrigueNotificationMessage@@QAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$1:
	lea	ecx, DWORD PTR _str$223913[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$2:
	lea	ecx, DWORD PTR _strSummary$223926[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$3:
	lea	ecx, DWORD PTR _strNotification$223927[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$4:
	lea	ecx, DWORD PTR $T263000[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$5:
	lea	ecx, DWORD PTR $T263003[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$6:
	lea	ecx, DWORD PTR $T263009[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$7:
	lea	ecx, DWORD PTR $T263012[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$8:
	lea	ecx, DWORD PTR $T263018[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$9:
	lea	ecx, DWORD PTR $T263023[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$10:
	lea	ecx, DWORD PTR _strSummary$223989[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$11:
	lea	ecx, DWORD PTR _strNotification$223990[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$12:
	lea	ecx, DWORD PTR $T263031[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$13:
	lea	ecx, DWORD PTR $T263034[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$14:
	lea	ecx, DWORD PTR _strSummary$224006[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$15:
	lea	ecx, DWORD PTR _strNotification$224007[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$16:
	lea	ecx, DWORD PTR $T263039[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$17:
	lea	ecx, DWORD PTR $T263042[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$18:
	lea	ecx, DWORD PTR _strSummary$224023[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$19:
	lea	ecx, DWORD PTR _strNotification$224024[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$20:
	lea	ecx, DWORD PTR $T263047[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$21:
	lea	ecx, DWORD PTR $T263051[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$22:
	lea	ecx, DWORD PTR $T263056[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$23:
	lea	ecx, DWORD PTR $T263059[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$24:
	lea	ecx, DWORD PTR $T263063[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$25:
	lea	ecx, DWORD PTR $T263067[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$26:
	lea	ecx, DWORD PTR $T263073[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$27:
	lea	ecx, DWORD PTR $T263078[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$28:
	lea	ecx, DWORD PTR $T263083[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$29:
	lea	ecx, DWORD PTR $T263084[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$30:
	lea	ecx, DWORD PTR $T263085[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$31:
	lea	ecx, DWORD PTR $T263086[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$32:
	lea	ecx, DWORD PTR _strSummary$224106[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$33:
	lea	ecx, DWORD PTR _strNotification$224107[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$34:
	lea	ecx, DWORD PTR $T263092[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$35:
	lea	ecx, DWORD PTR $T263096[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$36:
	lea	ecx, DWORD PTR $T263101[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$37:
	lea	ecx, DWORD PTR $T263104[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$38:
	lea	ecx, DWORD PTR $T263108[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$39:
	lea	ecx, DWORD PTR $T263112[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$40:
	lea	ecx, DWORD PTR $T263118[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$41:
	lea	ecx, DWORD PTR $T263123[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$42:
	lea	ecx, DWORD PTR $T263128[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$43:
	lea	ecx, DWORD PTR $T263129[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$44:
	lea	ecx, DWORD PTR $T263130[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$45:
	lea	ecx, DWORD PTR $T263131[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$46:
	lea	ecx, DWORD PTR _strSummary$224189[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z$47:
	lea	ecx, DWORD PTR _strNotification$224205[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z ENDP ; CvPlayerEspionage::AddIntrigueMessage
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z:PROC ; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z$1
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z
_TEXT	SEGMENT
_i$264796 = -196					; size = 4
$T264732 = -196						; size = 4
_iCiv$224701 = -196					; size = 4
_i$224670 = -196					; size = 4
tv1351 = -192						; size = 4
_iSpyNameIndex$224674 = -192				; size = 4
_i$224662 = -192					; size = 4
_iProjectType$224725 = -188				; size = 4
_i$224706 = -188					; size = 4
_uiCiv$224676 = -188					; size = 4
_iNumEntries$224705 = -184				; size = 4
_uiNumTechs$224681 = -184				; size = 4
_iNumMessages$ = -180					; size = 4
$T265079 = -176						; size = 1
_iNumTechsToSteal$224694 = -176				; size = 4
_eTech$224686 = -176					; size = 4
_uiNumCivs$ = -172					; size = 4
_kMessage$224716 = -168					; size = 20
_aTechList$224680 = -168				; size = 20
_iMaxTechCostEntries$ = -148				; size = 4
_iNumCivs$ = -144					; size = 4
_iNumSpyNames$ = -140					; size = 4
_iNumSpies$ = -136					; size = 4
__Cat$265082 = -132					; size = 1
$T264779 = -132						; size = 4
_kHeistLocation$224710 = -132				; size = 8
_kTempSpy$ = -124					; size = 28
$T264806 = -96						; size = 4
_uiVersion$ = -92					; size = 4
_kMessage$224721 = -88					; size = 68
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z PROC ; operator>>, COMDAT

; 3725 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 184				; 000000b8H
	push	ebx

; 3726 : 	uint uiVersion;
; 3727 : 	loadFrom >> uiVersion;

	mov	ebx, DWORD PTR _loadFrom$[ebp]
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+208]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3728 : 
; 3729 : 	int iNumSpies;
; 3730 : 	loadFrom >> iNumSpies;

	lea	ecx, DWORD PTR _iNumSpies$[esp+208]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3731 : 
; 3732 : 	CvEspionageSpy kTempSpy;

	or	eax, -1
	mov	DWORD PTR _kTempSpy$[esp+208], eax
	mov	DWORD PTR _kTempSpy$[esp+212], eax
	mov	DWORD PTR _kTempSpy$[esp+216], eax
	xor	eax, eax

; 3733 : 
; 3734 : 	for(int i = 0; i < iNumSpies; i++)

	cmp	DWORD PTR _iNumSpies$[esp+208], eax
	mov	DWORD PTR _kTempSpy$[esp+220], 3
	mov	DWORD PTR _kTempSpy$[esp+224], 9
	mov	DWORD PTR _kTempSpy$[esp+228], eax
	mov	BYTE PTR _kTempSpy$[esp+232], al
	mov	BYTE PTR _kTempSpy$[esp+233], 1
	mov	DWORD PTR _i$224662[esp+208], eax
	jle	SHORT $LN28@operator@9

; 3814 : 	for(int i = 0; i < iNumMessages; i++)

	mov	esi, DWORD PTR _writeTo$[ebp]
	add	esi, 4
$LN30@operator@9:
	lea	edx, DWORD PTR _kTempSpy$[esp+208]
	push	edx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAVCvEspionageSpy@@@Z ; operator>>
	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	mov	BYTE PTR [esi+236], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN41@operator@9
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvEspionageSpy@@$07$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvEspionageSpy,8,0,297,0>::GrowSize
$LN41@operator@9:
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN44@operator@9
	mov	ecx, 7
	lea	esi, DWORD PTR _kTempSpy$[esp+208]
	mov	edi, eax
	rep movsd
$LN44@operator@9:
	mov	esi, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR _i$224662[esp+208]
	inc	DWORD PTR [esi+8]
	add	esi, 4
	inc	eax
	cmp	eax, DWORD PTR _iNumSpies$[esp+208]
	mov	DWORD PTR _i$224662[esp+208], eax
	jl	SHORT $LN30@operator@9
$LN28@operator@9:

; 3735 : 	{
; 3736 : 		loadFrom >> kTempSpy;
; 3737 : 		writeTo.m_aSpyList.push_back(kTempSpy);
; 3738 : 	}
; 3739 : 
; 3740 : 	int iNumSpyNames;
; 3741 : 	loadFrom >> iNumSpyNames;

	lea	eax, DWORD PTR _iNumSpyNames$[esp+208]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3742 : 	for(int i = 0; i < iNumSpyNames; i++)

	cmp	DWORD PTR _iNumSpyNames$[esp+208], 0
	mov	DWORD PTR _i$224670[esp+208], 0
	jle	SHORT $LN25@operator@9
	mov	esi, DWORD PTR _writeTo$[ebp]
	add	esi, 244				; 000000f4H
$LN27@operator@9:

; 3743 : 	{
; 3744 : 		int iSpyNameIndex;
; 3745 : 		loadFrom >> iSpyNameIndex;

	lea	ecx, DWORD PTR _iSpyNameIndex$224674[esp+208]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3746 : 		writeTo.m_aiSpyListNameOrder.push_back(iSpyNameIndex);

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN60@operator@9
	xor	eax, eax
	jmp	SHORT $LN61@operator@9
$LN60@operator@9:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
$LN61@operator@9:
	mov	ecx, DWORD PTR [esi+8]
	mov	edi, ecx
	sub	edi, edx
	sar	edi, 2
	cmp	edi, eax
	jae	SHORT $LN53@operator@9
	mov	edx, DWORD PTR _iSpyNameIndex$224674[esp+208]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN26@operator@9
$LN53@operator@9:
	lea	eax, DWORD PTR _iSpyNameIndex$224674[esp+208]
	push	eax
	push	1
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN26@operator@9:
	mov	eax, DWORD PTR _i$224670[esp+208]
	inc	eax
	cmp	eax, DWORD PTR _iNumSpyNames$[esp+208]
	mov	DWORD PTR _i$224670[esp+208], eax
	jl	SHORT $LN27@operator@9
$LN25@operator@9:

; 3747 : 	}
; 3748 : 
; 3749 : 	loadFrom >> writeTo.m_iSpyListNameOrderIndex;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 260				; 00000104H
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3750 : 
; 3751 : 	uint uiNumCivs;
; 3752 : 	loadFrom >> uiNumCivs;

	lea	edx, DWORD PTR _uiNumCivs$[esp+208]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3753 : 	for(uint uiCiv = 0; uiCiv < uiNumCivs; uiCiv++)

	xor	eax, eax
	mov	DWORD PTR _uiCiv$224676[esp+208], eax
	cmp	DWORD PTR _uiNumCivs$[esp+208], eax
	jbe	$LN22@operator@9

; 3747 : 	}
; 3748 : 
; 3749 : 	loadFrom >> writeTo.m_iSpyListNameOrderIndex;

	mov	DWORD PTR tv1351[esp+208], eax
$LN24@operator@9:

; 3754 : 	{
; 3755 : 		TechList aTechList;

	xor	eax, eax
	lea	ecx, DWORD PTR _aTechList$224680[esp+220]
	mov	DWORD PTR _aTechList$224680[esp+212], eax
	mov	DWORD PTR _aTechList$224680[esp+216], 1
	mov	DWORD PTR _aTechList$224680[esp+208], ecx

; 3756 : 		writeTo.m_aaPlayerStealableTechList.push_back(aTechList);

	mov	edi, DWORD PTR _writeTo$[ebp]
	add	edi, 264				; 00000108H
	mov	DWORD PTR __$EHRec$[esp+216], eax
	mov	BYTE PTR [edi+452], al
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR $T264806[esp+208], edi
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN125@operator@9
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@V?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FStaticVector<enum TechTypes,1,0,297,0>,22,0,297,0>::GrowSize
$LN125@operator@9:
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi]
	lea	esi, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T264779[esp+208], esi
	xor	eax, eax
	mov	BYTE PTR __$EHRec$[esp+216], 1
	cmp	esi, eax
	je	$LN141@operator@9
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _aTechList$224680[esp+212]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR _aTechList$224680[esp+216]
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR _aTechList$224680[esp+216]
	mov	DWORD PTR $T264732[esp+208], eax
	cmp	eax, 1
	jbe	SHORT $LN138@operator@9
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ecx, DWORD PTR $T264732[esp+224]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN137@operator@9
$LN138@operator@9:
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 1
$LN137@operator@9:
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR _aTechList$224680[esp+212]
	xor	ecx, ecx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR _i$264796[esp+208], ecx
	cmp	DWORD PTR _aTechList$224680[esp+212], ecx
	jbe	SHORT $LN141@operator@9
	npad	1
$LL143@operator@9:
	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [ecx*4]
	add	eax, edx
	je	SHORT $LN142@operator@9
	mov	ecx, DWORD PTR _aTechList$224680[esp+208]
	mov	edx, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _i$264796[esp+208]
	mov	DWORD PTR [eax], edx
$LN142@operator@9:
	inc	ecx
	mov	DWORD PTR _i$264796[esp+208], ecx
	cmp	ecx, DWORD PTR [esi+4]
	jb	SHORT $LL143@operator@9
$LN141@operator@9:
	inc	DWORD PTR [edi+4]

; 3757 : 
; 3758 : 		uint uiNumTechs;
; 3759 : 		loadFrom >> uiNumTechs;

	lea	eax, DWORD PTR _uiNumTechs$224681[esp+208]
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+220], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3760 : 		for(uint uiTech = 0; uiTech < uiNumTechs; uiTech++)

	xor	edi, edi
	cmp	DWORD PTR _uiNumTechs$224681[esp+208], edi
	jbe	SHORT $LN19@operator@9
$LL21@operator@9:

; 3761 : 		{
; 3762 : 			TechTypes eTech;
; 3763 : 			loadFrom >> eTech;

	lea	ecx, DWORD PTR _eTech$224686[esp+208]
	push	ecx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z ; operator>>

; 3764 : 			writeTo.m_aaPlayerStealableTechList[uiCiv].push_back(eTech);

	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	esi, DWORD PTR [eax+264]
	add	esi, DWORD PTR tv1351[esp+216]
	add	eax, 264				; 00000108H
	mov	eax, DWORD PTR [esi+8]
	add	esp, 8
	mov	BYTE PTR [esi+16], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN156@operator@9
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum TechTypes,1,0,297,0>::GrowSize
$LN156@operator@9:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN159@operator@9
	mov	ecx, DWORD PTR _eTech$224686[esp+208]
	mov	DWORD PTR [eax], ecx
$LN159@operator@9:
	inc	DWORD PTR [esi+4]
	inc	edi
	cmp	edi, DWORD PTR _uiNumTechs$224681[esp+208]
	jb	SHORT $LL21@operator@9
$LN19@operator@9:

; 3765 : 		}
; 3766 : 	}

	mov	eax, DWORD PTR _aTechList$224680[esp+208]
	lea	edx, DWORD PTR _aTechList$224680[esp+220]
	mov	DWORD PTR __$EHRec$[esp+216], -1
	cmp	eax, edx
	je	SHORT $LN23@operator@9
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN23@operator@9:
	mov	eax, DWORD PTR _uiCiv$224676[esp+208]
	add	DWORD PTR tv1351[esp+208], 20		; 00000014H
	inc	eax
	mov	DWORD PTR _uiCiv$224676[esp+208], eax
	cmp	eax, DWORD PTR _uiNumCivs$[esp+208]
	jb	$LN24@operator@9
$LN22@operator@9:

; 3767 : 
; 3768 : 
; 3769 : 	loadFrom >> uiNumCivs;

	lea	eax, DWORD PTR _uiNumCivs$[esp+208]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3770 : 	for(uint uiCiv = 0; uiCiv < uiNumCivs; uiCiv++)

	xor	edi, edi
	cmp	DWORD PTR _uiNumCivs$[esp+208], edi
	jbe	SHORT $LN16@operator@9
	mov	esi, DWORD PTR _writeTo$[ebp]
	add	esi, 720				; 000002d0H
$LL18@operator@9:

; 3771 : 	{
; 3772 : 		int iNumTechsToSteal;
; 3773 : 		loadFrom >> iNumTechsToSteal;

	lea	ecx, DWORD PTR _iNumTechsToSteal$224694[esp+208]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3774 : 		writeTo.m_aiNumTechsToStealList.push_back(iNumTechsToSteal);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+100], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN181@operator@9
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$0BG@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,22,0,297,0>::GrowSize
$LN181@operator@9:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN184@operator@9
	mov	ecx, DWORD PTR _iNumTechsToSteal$224694[esp+208]
	mov	DWORD PTR [eax], ecx
$LN184@operator@9:
	inc	DWORD PTR [esi+4]
	inc	edi
	cmp	edi, DWORD PTR _uiNumCivs$[esp+208]
	jb	SHORT $LL18@operator@9
$LN16@operator@9:

; 3775 : 	}
; 3776 : 
; 3777 : 	int iMaxTechCostEntries;
; 3778 : 	loadFrom >> iMaxTechCostEntries;

	lea	edx, DWORD PTR _iMaxTechCostEntries$[esp+208]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3779 : 	for(int i = 0; i < iMaxTechCostEntries; i++)

	xor	esi, esi
	cmp	DWORD PTR _iMaxTechCostEntries$[esp+208], esi
	jle	SHORT $LN13@operator@9
	mov	edi, DWORD PTR _writeTo$[ebp]
	add	edi, 824				; 00000338H
$LL15@operator@9:

; 3780 : 	{
; 3781 : 		loadFrom >> writeTo.m_aiMaxTechCost[i];

	push	edi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _iMaxTechCostEntries$[esp+208]
	jl	SHORT $LL15@operator@9
$LN13@operator@9:

; 3782 : 	}
; 3783 : 
; 3784 : 
; 3785 : 	int iNumCivs;
; 3786 : 	loadFrom >> iNumCivs;

	lea	eax, DWORD PTR _iNumCivs$[esp+208]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3787 : 	for(int iCiv = 0; iCiv < iNumCivs; iCiv++)

	cmp	DWORD PTR _iNumCivs$[esp+208], 0
	mov	DWORD PTR _iCiv$224701[esp+208], 0
	jle	$LN10@operator@9
	mov	esi, DWORD PTR _writeTo$[ebp]
	add	esi, 912				; 00000390H
$LN12@operator@9:

; 3788 : 	{
; 3789 : 		int iNumEntries;
; 3790 : 		loadFrom >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$224705[esp+208]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3791 : 		for(int i = 0; i < iNumEntries; i++)

	cmp	DWORD PTR _iNumEntries$224705[esp+208], 0
	mov	DWORD PTR _i$224706[esp+208], 0
	jle	$LN11@operator@9
$LN9@operator@9:

; 3792 : 		{
; 3793 : 			HeistLocation kHeistLocation;
; 3794 : 			loadFrom >> kHeistLocation.m_iX;

	lea	edx, DWORD PTR _kHeistLocation$224710[esp+208]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3795 : 			loadFrom >> kHeistLocation.m_iY;

	lea	eax, DWORD PTR _kHeistLocation$224710[esp+212]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3796 : 			writeTo.m_aHeistLocations[iCiv].push_back(kHeistLocation);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN212@operator@9
	xor	eax, eax
	jmp	SHORT $LN213@operator@9
$LN212@operator@9:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN213@operator@9:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN205@operator@9
	mov	ecx, DWORD PTR __Cat$265082[esp+208]
	mov	BYTE PTR $T265079[esp+208], 0
	mov	eax, DWORD PTR $T265079[esp+208]
	push	eax
	push	ecx
	push	esi
	lea	edx, DWORD PTR _kHeistLocation$224710[esp+220]
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUHeistLocation@@IU1@V?$allocator@UHeistLocation@@@std@@@std@@YAXPAUHeistLocation@@IABU1@AAV?$allocator@UHeistLocation@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<HeistLocation *,unsigned int,HeistLocation,std::allocator<HeistLocation> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN8@operator@9
$LN205@operator@9:
	lea	eax, DWORD PTR _kHeistLocation$224710[esp+208]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@IAEXV?$_Vector_const_iterator@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@2@IABUHeistLocation@@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::_Insert_n
$LN8@operator@9:
	mov	eax, DWORD PTR _i$224706[esp+208]
	inc	eax
	cmp	eax, DWORD PTR _iNumEntries$224705[esp+208]
	mov	DWORD PTR _i$224706[esp+208], eax
	jl	SHORT $LN9@operator@9
$LN11@operator@9:

; 3787 : 	for(int iCiv = 0; iCiv < iNumCivs; iCiv++)

	mov	eax, DWORD PTR _iCiv$224701[esp+208]
	inc	eax
	add	esi, 16					; 00000010H
	cmp	eax, DWORD PTR _iNumCivs$[esp+208]
	mov	DWORD PTR _iCiv$224701[esp+208], eax
	jl	$LN12@operator@9
$LN10@operator@9:

; 3797 : 		}
; 3798 : 	}
; 3799 : 
; 3800 : 	int iNumMessages;
; 3801 : 	loadFrom >> iNumMessages;

	lea	ecx, DWORD PTR _iNumMessages$[esp+208]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3802 : 	for(int i = 0; i < iNumMessages; i++)

	xor	esi, esi
	cmp	DWORD PTR _iNumMessages$[esp+208], esi
	jle	SHORT $LN4@operator@9
	mov	edi, DWORD PTR _writeTo$[ebp]
	add	edi, 1264				; 000004f0H
	npad	4
$LL6@operator@9:

; 3803 : 	{
; 3804 : 		SpyNotificationMessage kMessage;
; 3805 : 		loadFrom >> kMessage.m_iCityX;

	lea	edx, DWORD PTR _kMessage$224716[esp+208]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3806 : 		loadFrom >> kMessage.m_iCityY;

	lea	eax, DWORD PTR _kMessage$224716[esp+212]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3807 : 		loadFrom >> kMessage.m_eAttackingPlayer;

	lea	ecx, DWORD PTR _kMessage$224716[esp+216]
	push	ecx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 3808 : 		loadFrom >> kMessage.m_iSpyResult;

	lea	edx, DWORD PTR _kMessage$224716[esp+220]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3809 : 		loadFrom >> kMessage.m_eStolenTech;

	lea	eax, DWORD PTR _kMessage$224716[esp+224]
	push	eax
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z ; operator>>
	add	esp, 8

; 3810 : 		writeTo.m_aSpyNotificationMessages.push_back(kMessage);

	lea	ecx, DWORD PTR _kMessage$224716[esp+208]
	push	ecx
	mov	ecx, edi
	call	?push_back@?$vector@USpyNotificationMessage@@V?$allocator@USpyNotificationMessage@@@std@@@std@@QAEXABUSpyNotificationMessage@@@Z ; std::vector<SpyNotificationMessage,std::allocator<SpyNotificationMessage> >::push_back
	inc	esi
	cmp	esi, DWORD PTR _iNumMessages$[esp+208]
	jl	SHORT $LL6@operator@9
$LN4@operator@9:

; 3811 : 	}
; 3812 : 
; 3813 : 	loadFrom >> iNumMessages;

	lea	edx, DWORD PTR _iNumMessages$[esp+208]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3814 : 	for(int i = 0; i < iNumMessages; i++)

	xor	esi, esi
	cmp	DWORD PTR _iNumMessages$[esp+208], esi
	jle	$LN314@operator@9
	mov	edi, DWORD PTR _writeTo$[ebp]
	add	edi, 1280				; 00000500H
	npad	12
$LL3@operator@9:

; 3815 : 	{
; 3816 : 		IntrigueNotificationMessage kMessage;

	lea	ecx, DWORD PTR _kMessage$224721[esp+244]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3817 : 		loadFrom >> kMessage.m_eDiscoveringPlayer;

	lea	eax, DWORD PTR _kMessage$224721[esp+208]
	push	eax
	push	ebx
	mov	DWORD PTR __$EHRec$[esp+224], 2
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 3818 : 		loadFrom >> kMessage.m_eSourcePlayer;

	lea	ecx, DWORD PTR _kMessage$224721[esp+220]
	push	ecx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 3819 : 		loadFrom >> kMessage.m_eTargetPlayer;

	lea	edx, DWORD PTR _kMessage$224721[esp+232]
	push	edx
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 3820 : 		loadFrom >> kMessage.m_eBuilding;

	lea	eax, DWORD PTR _kMessage$224721[esp+244]
	push	eax
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z ; operator>>
	add	esp, 32					; 00000020H

; 3821 : 		int iProjectType;
; 3822 : 		loadFrom >> iProjectType;

	lea	ecx, DWORD PTR _iProjectType$224725[esp+208]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3823 : 		kMessage.m_eProject = (ProjectTypes)iProjectType;

	mov	edx, DWORD PTR _iProjectType$224725[esp+208]

; 3824 : 		loadFrom >> kMessage.m_iIntrigueType;

	lea	eax, DWORD PTR _kMessage$224721[esp+228]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _kMessage$224721[esp+228], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3825 : 		loadFrom >> kMessage.m_iTurnNum;

	lea	ecx, DWORD PTR _kMessage$224721[esp+232]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3826 : 		loadFrom >> kMessage.m_iCityX;

	lea	edx, DWORD PTR _kMessage$224721[esp+236]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3827 : 		loadFrom >> kMessage.m_iCityY;

	lea	eax, DWORD PTR _kMessage$224721[esp+240]
	push	eax
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3828 : 		loadFrom >> kMessage.m_strSpyName;

	lea	ecx, DWORD PTR _kMessage$224721[esp+244]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 3829 : 		loadFrom >> kMessage.m_bShared;

	lea	edx, DWORD PTR _kMessage$224721[esp+272]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3830 : 		writeTo.m_aIntrigueNotificationMessages.push_back(kMessage);

	lea	eax, DWORD PTR _kMessage$224721[esp+208]
	push	eax
	mov	ecx, edi
	call	?push_back@?$vector@UIntrigueNotificationMessage@@V?$allocator@UIntrigueNotificationMessage@@@std@@@std@@QAEXABUIntrigueNotificationMessage@@@Z ; std::vector<IntrigueNotificationMessage,std::allocator<IntrigueNotificationMessage> >::push_back

; 3831 : 	}

	lea	ecx, DWORD PTR _kMessage$224721[esp+244]
	mov	DWORD PTR __$EHRec$[esp+216], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	esi
	cmp	esi, DWORD PTR _iNumMessages$[esp+208]
	jl	$LL3@operator@9
$LN314@operator@9:

; 3832 : 
; 3833 : 	return loadFrom;
; 3834 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+208]
	pop	edi
	pop	esi
	mov	eax, ebx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z$0:
	lea	ecx, DWORD PTR _aTechList$224680[ebp]
	jmp	??1?$FStaticVector@W4TechTypes@@$00$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum TechTypes,1,0,297,0>::~FStaticVector<enum TechTypes,1,0,297,0>
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z$2:
	mov	eax, DWORD PTR $T264806[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR $T264806[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T264779[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z$1:
	lea	ecx, DWORD PTR _kMessage$224721[ebp]
	jmp	??1IntrigueNotificationMessage@@QAE@XZ
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerEspionage@@@Z ENDP ; operator>>
PUBLIC	?DoTurn@CvEspionageAI@@QAEXXZ			; CvEspionageAI::DoTurn
EXTRN	?IsUnitedNationsActive@CvGame@@QAE_NXZ:PROC	; CvGame::IsUnitedNationsActive
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?DoTurn@CvEspionageAI@@QAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?DoTurn@CvEspionageAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DoTurn@CvEspionageAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoTurn@CvEspionageAI@@QAEXXZ
_TEXT	SEGMENT
_uiSpy$225437 = -144					; size = 4
_uiSpy$225398 = -144					; size = 4
tv1532 = -140						; size = 4
_iCorrectlyAssignedCityStateSpies$ = -140		; size = 4
_iCorrectlyAssignedDefenseSpies$ = -136			; size = 4
_iTargetOffensiveSpies$ = -132				; size = 4
tv1276 = -128						; size = 4
tv1263 = -128						; size = 4
tv1251 = -128						; size = 4
tv1235 = -128						; size = 4
_iTargetCityStateSpies$ = -124				; size = 4
_iTargetDefensiveSpies$ = -120				; size = 4
_iTargetDiplomatSpies$ = -116				; size = 4
_iCorrectlyAssignedOffenseSpies$ = -112			; size = 4
_iCorrectlyAssignedDiplomatSpies$ = -108		; size = 4
tv1692 = -104						; size = 4
_apCityDefense$ = -100					; size = 16
_apCityMinor$ = -84					; size = 16
_apCityDiplomat$ = -68					; size = 16
_strMsg$225067 = -68					; size = 28
_apCityOffense$ = -40					; size = 16
$T265225 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?DoTurn@CvEspionageAI@@QAEXXZ PROC			; CvEspionageAI::DoTurn, COMDAT
; _this$ = ecx

; 4312 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoTurn@CvEspionageAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 132				; 00000084H
	push	esi
	mov	esi, ecx

; 4313 : 	// no humans, minor civs, or barbarians allowed!
; 4314 : 	if(m_pPlayer->isHuman() || m_pPlayer->isMinorCiv() || m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [esi]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN352@DoTurn
	mov	ecx, DWORD PTR [esi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN352@DoTurn
	mov	ecx, DWORD PTR [esi]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	$LN352@DoTurn
	push	ebx
	push	ebp
	push	edi

; 4315 : 	{
; 4316 : 		return;
; 4317 : 	}
; 4318 : 
; 4319 : 	AI_PERF_FORMAT("AI-perf.csv", ("Espionage AI, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 4320 : 
; 4321 : 	StealTechnology();

	mov	ecx, esi
	call	?StealTechnology@CvEspionageAI@@QAEXXZ	; CvEspionageAI::StealTechnology

; 4322 : 	UpdateCivOutOfTechTurn();

	mov	ecx, esi
	call	?UpdateCivOutOfTechTurn@CvEspionageAI@@QAEXXZ ; CvEspionageAI::UpdateCivOutOfTechTurn

; 4323 : 	AttemptCoups();

	mov	ecx, esi
	call	?AttemptCoups@CvEspionageAI@@QAEXXZ	; CvEspionageAI::AttemptCoups

; 4324 : 
; 4325 : 	// mark these spies available to reassign
; 4326 : 	EvaluateUnassignedSpies();

	mov	ecx, esi
	call	?EvaluateUnassignedSpies@CvEspionageAI@@QAEXXZ ; CvEspionageAI::EvaluateUnassignedSpies

; 4327 : 	EvaluateDefensiveSpies();

	mov	ecx, esi
	call	?EvaluateDefensiveSpies@CvEspionageAI@@QAEXXZ ; CvEspionageAI::EvaluateDefensiveSpies

; 4328 : 	EvaluateDiplomatSpies();

	mov	ecx, esi
	call	?EvaluateDiplomatSpies@CvEspionageAI@@QAEXXZ ; CvEspionageAI::EvaluateDiplomatSpies

; 4329 : 
; 4330 : 	// when the UN countdown starts, mark all spies to be reassigned
; 4331 : 	if (!m_bUNCountdownStarted && GC.getGame().IsUnitedNationsActive())

	xor	ebx, ebx
	cmp	BYTE PTR [esi+732], bl
	jne	$LN64@DoTurn
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?IsUnitedNationsActive@CvGame@@QAE_NXZ	; CvGame::IsUnitedNationsActive
	test	al, al
	je	$LN64@DoTurn

; 4334 : 		CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [esi+732], 1
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ebp, eax

; 4335 : 		for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)

	cmp	DWORD PTR [ebp+8], ebx
	jbe	$LN64@DoTurn

; 4332 : 	{
; 4333 : 		m_bUNCountdownStarted = true;

	mov	DWORD PTR tv1532[esp+160], ebx
	npad	10
$LL66@DoTurn:

; 4336 : 		{
; 4337 : 			CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[ui]);

	mov	edi, DWORD PTR [ebp+4]
	add	edi, DWORD PTR tv1532[esp+160]

; 4338 : 			// don't process dead spies
; 4339 : 			if (pSpy->m_eSpyState == SPY_STATE_DEAD)

	cmp	DWORD PTR [edi+16], 8
	je	$LN65@DoTurn

; 4340 : 			{
; 4341 : 				continue;
; 4342 : 			}
; 4343 : 
; 4344 : 			pSpy->m_bEvaluateReassignment = true;
; 4345 : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [edi+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN65@DoTurn

; 4346 : 			{
; 4347 : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225067[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4348 : 				strMsg.Format("Re-eval: UN constructed/reassign, %d,", ui);

	push	ebx
	lea	eax, DWORD PTR _strMsg$225067[esp+164]
	push	OFFSET $SG225068
	push	eax
	mov	DWORD PTR __$EHRec$[esp+180], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4349 : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	ecx, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	edx, DWORD PTR $T265225[esp+164]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$225067[esp+164]
	mov	BYTE PTR __$EHRec$[esp+172], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T265225[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4350 : 				pEspionage->LogEspionageMsg(strMsg);

	lea	eax, DWORD PTR _strMsg$225067[esp+160]
	push	eax
	mov	ecx, ebp
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 4351 : 			}

	lea	ecx, DWORD PTR _strMsg$225067[esp+160]
	mov	DWORD PTR __$EHRec$[esp+168], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN65@DoTurn:
	add	DWORD PTR tv1532[esp+160], 28		; 0000001cH
	inc	ebx
	cmp	ebx, DWORD PTR [ebp+8]
	jb	$LL66@DoTurn
$LN64@DoTurn:

; 4352 : 		}
; 4353 : 	}
; 4354 : 
; 4355 : 	int iTargetOffensiveSpies = 0;
; 4356 : 	int iTargetDefensiveSpies = 0;
; 4357 : 	int iTargetCityStateSpies = 0;
; 4358 : 	int iTargetDiplomatSpies  = 0;
; 4359 : 	FindTargetSpyNumbers(&iTargetOffensiveSpies, &iTargetDefensiveSpies, &iTargetCityStateSpies, &iTargetDiplomatSpies);

	lea	ecx, DWORD PTR _iTargetDiplomatSpies$[esp+160]
	push	ecx
	lea	edx, DWORD PTR _iTargetCityStateSpies$[esp+164]
	push	edx
	lea	eax, DWORD PTR _iTargetDefensiveSpies$[esp+168]
	xor	edi, edi
	push	eax
	lea	ecx, DWORD PTR _iTargetOffensiveSpies$[esp+172]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _iTargetOffensiveSpies$[esp+176], edi
	mov	DWORD PTR _iTargetDefensiveSpies$[esp+176], edi
	mov	DWORD PTR _iTargetCityStateSpies$[esp+176], edi
	mov	DWORD PTR _iTargetDiplomatSpies$[esp+176], edi
	call	?FindTargetSpyNumbers@CvEspionageAI@@QAEXPAH000@Z ; CvEspionageAI::FindTargetSpyNumbers

; 4360 : 
; 4361 : 	std::vector<CvCity*> apCityDiplomat;

	mov	DWORD PTR _apCityDiplomat$[esp+164], edi
	mov	DWORD PTR _apCityDiplomat$[esp+168], edi
	mov	DWORD PTR _apCityDiplomat$[esp+172], edi
	mov	DWORD PTR __$EHRec$[esp+168], 2

; 4362 : 	std::vector<CvCity*> apCityOffense;

	mov	DWORD PTR _apCityOffense$[esp+164], edi
	mov	DWORD PTR _apCityOffense$[esp+168], edi
	mov	DWORD PTR _apCityOffense$[esp+172], edi

; 4363 : 	std::vector<CvCity*> apCityDefense;

	mov	DWORD PTR _apCityDefense$[esp+164], edi
	mov	DWORD PTR _apCityDefense$[esp+168], edi
	mov	DWORD PTR _apCityDefense$[esp+172], edi

; 4364 : 	std::vector<CvCity*> apCityMinor;

	mov	DWORD PTR _apCityMinor$[esp+164], edi
	mov	DWORD PTR _apCityMinor$[esp+168], edi
	mov	DWORD PTR _apCityMinor$[esp+172], edi

; 4365 : 	
; 4366 : 	if (iTargetDiplomatSpies > 0)

	cmp	DWORD PTR _iTargetDiplomatSpies$[esp+160], edi
	mov	BYTE PTR __$EHRec$[esp+168], 5
	jle	SHORT $LN61@DoTurn

; 4367 : 	{
; 4368 : 		BuildDiplomatCityList(apCityDiplomat);

	lea	edx, DWORD PTR _apCityDiplomat$[esp+160]
	push	edx
	mov	ecx, esi
	call	?BuildDiplomatCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildDiplomatCityList
$LN61@DoTurn:

; 4369 : 	}
; 4370 : 
; 4371 : 	if (iTargetOffensiveSpies > 0)

	cmp	DWORD PTR _iTargetOffensiveSpies$[esp+160], edi
	jle	SHORT $LN60@DoTurn

; 4372 : 	{
; 4373 : 		BuildOffenseCityList(apCityOffense);

	lea	eax, DWORD PTR _apCityOffense$[esp+160]
	push	eax
	mov	ecx, esi
	call	?BuildOffenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildOffenseCityList
$LN60@DoTurn:

; 4374 : 	}
; 4375 : 
; 4376 : 	if (iTargetDefensiveSpies > 0)

	cmp	DWORD PTR _iTargetDefensiveSpies$[esp+160], edi
	jle	SHORT $LN59@DoTurn

; 4377 : 	{
; 4378 : 		BuildDefenseCityList(apCityDefense);

	lea	ecx, DWORD PTR _apCityDefense$[esp+160]
	push	ecx
	mov	ecx, esi
	call	?BuildDefenseCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildDefenseCityList
$LN59@DoTurn:

; 4379 : 	}
; 4380 : 
; 4381 : 	if (iTargetCityStateSpies > 0)

	cmp	DWORD PTR _iTargetCityStateSpies$[esp+160], edi
	jle	SHORT $LN58@DoTurn

; 4382 : 	{
; 4383 : 		BuildMinorCityList(apCityMinor);

	lea	edx, DWORD PTR _apCityMinor$[esp+160]
	push	edx
	mov	ecx, esi
	call	?BuildMinorCityList@CvEspionageAI@@QAEXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvEspionageAI::BuildMinorCityList
$LN58@DoTurn:

; 4384 : 	}
; 4385 : 
; 4386 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	mov	ecx, DWORD PTR [esi]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ebp, eax

; 4387 : 
; 4388 : 	// loop through spies an extract all that aren't in a correct location
; 4389 : 	int iCorrectlyAssignedDiplomatSpies = 0;
; 4390 : 	int iCorrectlyAssignedDefenseSpies = 0;
; 4391 : 	int iCorrectlyAssignedOffenseSpies = 0;
; 4392 : 	int iCorrectlyAssignedCityStateSpies = 0;
; 4393 : 
; 4394 : 	for(uint uiSpy = 0; uiSpy < pEspionage->m_aSpyList.size(); uiSpy++)

	xor	eax, eax
	mov	DWORD PTR _iCorrectlyAssignedDiplomatSpies$[esp+160], edi
	mov	DWORD PTR _iCorrectlyAssignedDefenseSpies$[esp+160], edi
	mov	DWORD PTR _iCorrectlyAssignedOffenseSpies$[esp+160], edi
	mov	DWORD PTR _iCorrectlyAssignedCityStateSpies$[esp+160], edi
	mov	DWORD PTR _uiSpy$225398[esp+160], eax
	cmp	DWORD PTR [ebp+8], edi
	jbe	$LN55@DoTurn

; 4384 : 	}
; 4385 : 
; 4386 : 	CvPlayerEspionage* pEspionage = m_pPlayer->GetEspionage();

	xor	esi, esi
	npad	5
$LL403@DoTurn:

; 4395 : 	{
; 4396 : 		// dead spies are not processed
; 4397 : 		if(pEspionage->m_aSpyList[uiSpy].m_eSpyState == SPY_STATE_DEAD)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+esi+16], 8
	je	$LN56@DoTurn

; 4398 : 		{
; 4399 : 			continue;
; 4400 : 		}
; 4401 : 
; 4402 : 		CvCity* pSpyCity = pEspionage->GetCityWithSpy(uiSpy);

	push	eax
	mov	ecx, ebp
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 4403 : 
; 4404 : 		// spies that are not assigned don't need to be processed
; 4405 : 		if(!pSpyCity)

	cmp	eax, edi
	je	$LN56@DoTurn

; 4406 : 		{
; 4407 : 			continue;
; 4408 : 		}
; 4409 : 
; 4410 : 		bool bAlreadyAssigned = false;

	xor	bl, bl

; 4411 : 
; 4412 : 		// diplomat cities
; 4413 : 		if (!bAlreadyAssigned)
; 4414 : 		{
; 4415 : 			// see if the spy is in any of the diplomat cities
; 4416 : 			for(int iDiplomatIndex = 0; iDiplomatIndex < iTargetDiplomatSpies && iDiplomatIndex < (int)apCityDiplomat.size(); iDiplomatIndex++)

	xor	ecx, ecx
	cmp	DWORD PTR _iTargetDiplomatSpies$[esp+160], edi
	jle	SHORT $LN395@DoTurn
	mov	edx, DWORD PTR _apCityDiplomat$[esp+168]
	sub	edx, DWORD PTR _apCityDiplomat$[esp+164]
	sar	edx, 2
$LL394@DoTurn:
	cmp	ecx, edx
	jge	SHORT $LN395@DoTurn

; 4417 : 			{
; 4418 : 				if(pSpyCity == apCityDiplomat[iDiplomatIndex] && pEspionage->m_aSpyList[uiSpy].m_bIsDiplomat)

	mov	edi, DWORD PTR _apCityDiplomat$[esp+164]
	cmp	eax, DWORD PTR [edi+ecx*4]
	jne	SHORT $LN50@DoTurn
	mov	edi, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edi+esi+24], 0
	jne	$LN365@DoTurn
$LN50@DoTurn:

; 4411 : 
; 4412 : 		// diplomat cities
; 4413 : 		if (!bAlreadyAssigned)
; 4414 : 		{
; 4415 : 			// see if the spy is in any of the diplomat cities
; 4416 : 			for(int iDiplomatIndex = 0; iDiplomatIndex < iTargetDiplomatSpies && iDiplomatIndex < (int)apCityDiplomat.size(); iDiplomatIndex++)

	inc	ecx
	cmp	ecx, DWORD PTR _iTargetDiplomatSpies$[esp+160]
	jl	SHORT $LL394@DoTurn
$LN395@DoTurn:

; 4429 : 		{
; 4430 : 			// see if the spy is in any of the defensive cities
; 4431 : 			for(int iDefensiveIndex = 0; iDefensiveIndex < iTargetDefensiveSpies && iDefensiveIndex < (int)apCityDefense.size(); iDefensiveIndex++)

	xor	ecx, ecx
	cmp	DWORD PTR _iTargetDefensiveSpies$[esp+160], ecx
	jle	SHORT $LN397@DoTurn
	mov	edx, DWORD PTR _apCityDefense$[esp+168]
	sub	edx, DWORD PTR _apCityDefense$[esp+164]
	sar	edx, 2
$LL396@DoTurn:
	cmp	ecx, edx
	jge	SHORT $LN397@DoTurn

; 4432 : 			{
; 4433 : 				if(pSpyCity == apCityDefense[iDefensiveIndex])

	mov	edi, DWORD PTR _apCityDefense$[esp+164]
	cmp	eax, DWORD PTR [edi+ecx*4]
	je	SHORT $LN366@DoTurn
	inc	ecx
	cmp	ecx, DWORD PTR _iTargetDefensiveSpies$[esp+160]
	jl	SHORT $LL396@DoTurn
$LN397@DoTurn:

; 4444 : 		{
; 4445 : 			// see if the spy is in any of the offensive cities
; 4446 : 			for(int iOffensiveIndex = 0; iOffensiveIndex < iTargetOffensiveSpies && iOffensiveIndex < (int)apCityOffense.size(); iOffensiveIndex++)

	xor	ecx, ecx
	cmp	DWORD PTR _iTargetOffensiveSpies$[esp+160], ecx
	jle	SHORT $LN399@DoTurn
	mov	edx, DWORD PTR _apCityOffense$[esp+168]
	sub	edx, DWORD PTR _apCityOffense$[esp+164]
	sar	edx, 2
$LL398@DoTurn:
	cmp	ecx, edx
	jge	SHORT $LN399@DoTurn

; 4447 : 			{
; 4448 : 				if(pSpyCity == apCityOffense[iOffensiveIndex] && !pEspionage->m_aSpyList[uiSpy].m_bIsDiplomat)

	mov	edi, DWORD PTR _apCityOffense$[esp+164]
	cmp	eax, DWORD PTR [edi+ecx*4]
	jne	SHORT $LN40@DoTurn
	mov	edi, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edi+esi+24], 0
	je	SHORT $LN367@DoTurn
$LN40@DoTurn:

; 4444 : 		{
; 4445 : 			// see if the spy is in any of the offensive cities
; 4446 : 			for(int iOffensiveIndex = 0; iOffensiveIndex < iTargetOffensiveSpies && iOffensiveIndex < (int)apCityOffense.size(); iOffensiveIndex++)

	inc	ecx
	cmp	ecx, DWORD PTR _iTargetOffensiveSpies$[esp+160]
	jl	SHORT $LL398@DoTurn
$LN399@DoTurn:

; 4459 : 		{
; 4460 : 			// see if the spy is in any of the city-states
; 4461 : 			for (int iCityStateIndex = 0; iCityStateIndex < iTargetCityStateSpies && iCityStateIndex < (int)apCityMinor.size(); iCityStateIndex++)

	xor	ecx, ecx
	cmp	DWORD PTR _iTargetCityStateSpies$[esp+160], ecx
	jle	SHORT $LN401@DoTurn
	mov	edx, DWORD PTR _apCityMinor$[esp+168]
	sub	edx, DWORD PTR _apCityMinor$[esp+164]
	sar	edx, 2
$LL400@DoTurn:
	cmp	ecx, edx
	jge	SHORT $LN401@DoTurn

; 4462 : 			{
; 4463 : 				if (pSpyCity == apCityMinor[iCityStateIndex])

	mov	edi, DWORD PTR _apCityMinor$[esp+164]
	cmp	eax, DWORD PTR [edi+ecx*4]
	je	SHORT $LN368@DoTurn
	inc	ecx
	cmp	ecx, DWORD PTR _iTargetCityStateSpies$[esp+160]
	jl	SHORT $LL400@DoTurn
	jmp	SHORT $LN401@DoTurn
$LN365@DoTurn:

; 4419 : 				{
; 4420 : 					iCorrectlyAssignedDiplomatSpies++;

	inc	DWORD PTR _iCorrectlyAssignedDiplomatSpies$[esp+160]

; 4421 : 					bAlreadyAssigned = true;
; 4422 : 					break;
; 4423 : 				}
; 4424 : 			}
; 4425 : 		}
; 4426 : 
; 4427 : 		// defensive cities
; 4428 : 		if(!bAlreadyAssigned)

	jmp	SHORT $LN405@DoTurn
$LN366@DoTurn:

; 4434 : 				{
; 4435 : 					iCorrectlyAssignedDefenseSpies++;

	inc	DWORD PTR _iCorrectlyAssignedDefenseSpies$[esp+160]

; 4436 : 					bAlreadyAssigned = true;
; 4437 : 					break;
; 4438 : 				}
; 4439 : 			}
; 4440 : 		}
; 4441 : 
; 4442 : 		// offensive cities
; 4443 : 		if(!bAlreadyAssigned)

	jmp	SHORT $LN405@DoTurn
$LN367@DoTurn:

; 4449 : 				{
; 4450 : 					iCorrectlyAssignedOffenseSpies++;

	inc	DWORD PTR _iCorrectlyAssignedOffenseSpies$[esp+160]

; 4451 : 					bAlreadyAssigned = true;
; 4452 : 					break;
; 4453 : 				}
; 4454 : 			}
; 4455 : 		}
; 4456 : 
; 4457 : 		// city-states
; 4458 : 		if (!bAlreadyAssigned)

	jmp	SHORT $LN405@DoTurn
$LN368@DoTurn:

; 4464 : 				{
; 4465 : 					iCorrectlyAssignedCityStateSpies++;

	inc	DWORD PTR _iCorrectlyAssignedCityStateSpies$[esp+160]
$LN405@DoTurn:

; 4466 : 					bAlreadyAssigned = true;

	mov	bl, 1
$LN401@DoTurn:

; 4467 : 					break;
; 4468 : 				}
; 4469 : 			}
; 4470 : 		}
; 4471 : 
; 4472 : 		// if the spy is flagged to be reassigned
; 4473 : 		if (pEspionage->m_aSpyList[uiSpy].m_bEvaluateReassignment)

	mov	edx, DWORD PTR [ebp+4]
	lea	eax, DWORD PTR [edx+esi+25]

; 4479 : 			}
; 4480 : 			else

	xor	edi, edi
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN56@DoTurn

; 4474 : 		{
; 4475 : 			// if the spy is already assigned to a correct city, mark them as assigned
; 4476 : 			if (bAlreadyAssigned)

	test	bl, bl
	je	SHORT $LN31@DoTurn

; 4477 : 			{
; 4478 : 				pEspionage->m_aSpyList[uiSpy].m_bEvaluateReassignment = false;		

	mov	BYTE PTR [eax], 0

; 4479 : 			}
; 4480 : 			else

	jmp	SHORT $LN56@DoTurn
$LN31@DoTurn:

; 4481 : 			{
; 4482 : 				// move spy out of target city
; 4483 : 				pEspionage->MoveSpyTo(NULL, uiSpy, false);

	mov	eax, DWORD PTR _uiSpy$225398[esp+160]
	push	edi
	push	eax
	push	edi
	mov	ecx, ebp
	call	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo
$LN56@DoTurn:
	mov	eax, DWORD PTR _uiSpy$225398[esp+160]
	inc	eax
	add	esi, 28					; 0000001cH
	mov	DWORD PTR _uiSpy$225398[esp+160], eax
	cmp	eax, DWORD PTR [ebp+8]
	jb	$LL403@DoTurn
$LN55@DoTurn:

; 4484 : 			}
; 4485 : 		}
; 4486 : 	}
; 4487 : 
; 4488 : 	// go through spy list again and put spies in locations where they are needed
; 4489 : 	for(uint uiSpy = 0; uiSpy < pEspionage->m_aSpyList.size(); uiSpy++)

	mov	DWORD PTR _uiSpy$225437[esp+160], edi
	cmp	DWORD PTR [ebp+8], edi
	jbe	$LN27@DoTurn
	mov	DWORD PTR tv1692[esp+160], edi
	npad	4
$LL392@DoTurn:

; 4490 : 	{
; 4491 : 		// dead spies are not processed
; 4492 : 		if(pEspionage->m_aSpyList[uiSpy].m_eSpyState == SPY_STATE_DEAD)

	mov	ecx, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR tv1692[esp+160]
	cmp	DWORD PTR [ecx+edx+16], 8
	lea	eax, DWORD PTR [ecx+edx]
	je	$LN28@DoTurn

; 4493 : 		{
; 4494 : 			continue;
; 4495 : 		}
; 4496 : 
; 4497 : 		// if this spy is not to be re-evaluated
; 4498 : 		if (!pEspionage->m_aSpyList[uiSpy].m_bEvaluateReassignment)

	cmp	BYTE PTR [eax+25], 0
	je	$LN28@DoTurn

; 4499 : 		{
; 4500 : 			continue;
; 4501 : 		}
; 4502 : 
; 4503 : 		// we're assigning the spy now, so reset their evaluate statement
; 4504 : 		pEspionage->m_aSpyList[uiSpy].m_bEvaluateReassignment = false;

	mov	BYTE PTR [eax+25], 0

; 4505 : 
; 4506 : 		CvCity* pSpyCity = pEspionage->GetCityWithSpy(uiSpy);

	mov	eax, DWORD PTR _uiSpy$225437[esp+160]
	push	eax
	mov	ecx, ebp
	call	?GetCityWithSpy@CvPlayerEspionage@@QAEPAVCvCity@@I@Z ; CvPlayerEspionage::GetCityWithSpy

; 4507 : 
; 4508 : 		// spies that are already are in a city are assumed to be in the right place
; 4509 : 		if(pSpyCity)

	test	eax, eax
	jne	$LN28@DoTurn

; 4510 : 		{
; 4511 : 			continue;
; 4512 : 		}
; 4513 : 
; 4514 : 		// if we have remaining defensive spies to assign
; 4515 : 		if(iTargetDiplomatSpies > iCorrectlyAssignedDiplomatSpies)

	mov	eax, DWORD PTR _iTargetDiplomatSpies$[esp+160]
	cmp	eax, DWORD PTR _iCorrectlyAssignedDiplomatSpies$[esp+160]
	jle	SHORT $LN23@DoTurn

; 4516 : 		{
; 4517 : 			// walk through cities and an open spot for the spy
; 4518 : 			for(int iCity = 0; iCity < iTargetDiplomatSpies && iCity < (int)apCityDiplomat.size(); iCity++)

	xor	ebx, ebx
	test	eax, eax
	jle	$LN28@DoTurn
	mov	eax, DWORD PTR _apCityDiplomat$[esp+168]
	sub	eax, DWORD PTR _apCityDiplomat$[esp+164]
	sar	eax, 2
	mov	DWORD PTR tv1235[esp+160], eax
	npad	6
$LL22@DoTurn:
	cmp	ebx, eax
	jge	$LN28@DoTurn

; 4519 : 			{
; 4520 : 				CvCity* pCity = apCityDiplomat[iCity];

	mov	ecx, DWORD PTR _apCityDiplomat$[esp+164]
	mov	esi, DWORD PTR [ecx+ebx*4]

; 4521 : 
; 4522 : 				// if a spy is already in this city, skip it
; 4523 : 				if(pEspionage->GetSpyIndexInCity(pCity) != -1)

	test	esi, esi
	je	SHORT $LN393@DoTurn
	mov	edx, DWORD PTR [ebp+1296]
	mov	edi, DWORD PTR [edx+44]
	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	cmp	DWORD PTR [eax+edi*4], -1
	je	SHORT $LN393@DoTurn
	inc	ebx
	cmp	ebx, DWORD PTR _iTargetDiplomatSpies$[esp+160]
	jge	$LN28@DoTurn

; 4516 : 		{
; 4517 : 			// walk through cities and an open spot for the spy
; 4518 : 			for(int iCity = 0; iCity < iTargetDiplomatSpies && iCity < (int)apCityDiplomat.size(); iCity++)

	mov	eax, DWORD PTR tv1235[esp+160]
	jmp	SHORT $LL22@DoTurn
$LN393@DoTurn:

; 4524 : 				{
; 4525 : 					continue;
; 4526 : 				}
; 4527 : 
; 4528 : 				pEspionage->MoveSpyTo(pCity, uiSpy, true);

	mov	eax, DWORD PTR _uiSpy$225437[esp+160]
	push	1
	push	eax
	push	esi
	mov	ecx, ebp
	call	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo

; 4529 : 				iCorrectlyAssignedDefenseSpies++;

	inc	DWORD PTR _iCorrectlyAssignedDefenseSpies$[esp+160]

; 4530 : 				break;
; 4531 : 			}
; 4532 : 		}
; 4533 : 		// if we have remaining defensive spies to assign
; 4534 : 		else if(iTargetDefensiveSpies > iCorrectlyAssignedDefenseSpies)

	jmp	$LN28@DoTurn
$LN23@DoTurn:
	mov	ecx, DWORD PTR _iTargetDefensiveSpies$[esp+160]
	cmp	ecx, DWORD PTR _iCorrectlyAssignedDefenseSpies$[esp+160]
	jle	SHORT $LN17@DoTurn

; 4535 : 		{
; 4536 : 			// walk through cities and an open spot for the spy
; 4537 : 			for(int iCity = 0; iCity < iTargetDefensiveSpies && iCity < (int)apCityDefense.size(); iCity++)

	xor	ebx, ebx
	test	ecx, ecx
	jle	$LN28@DoTurn
	mov	eax, DWORD PTR _apCityDefense$[esp+168]
	sub	eax, DWORD PTR _apCityDefense$[esp+164]
	sar	eax, 2
	mov	DWORD PTR tv1251[esp+160], eax
$LL16@DoTurn:
	cmp	ebx, eax
	jge	$LN28@DoTurn

; 4538 : 			{
; 4539 : 				CvCity* pCity = apCityDefense[iCity];

	mov	edx, DWORD PTR _apCityDefense$[esp+164]
	mov	esi, DWORD PTR [edx+ebx*4]

; 4540 : 
; 4541 : 				// if a spy is already in this city, skip it
; 4542 : 				if(pEspionage->GetSpyIndexInCity(pCity) != -1)

	test	esi, esi
	je	SHORT $LN13@DoTurn
	mov	eax, DWORD PTR [ebp+1296]
	mov	edi, DWORD PTR [eax+44]
	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	cmp	DWORD PTR [eax+edi*4], -1
	je	SHORT $LN13@DoTurn
	inc	ebx
	cmp	ebx, DWORD PTR _iTargetDefensiveSpies$[esp+160]
	jge	$LN28@DoTurn

; 4535 : 		{
; 4536 : 			// walk through cities and an open spot for the spy
; 4537 : 			for(int iCity = 0; iCity < iTargetDefensiveSpies && iCity < (int)apCityDefense.size(); iCity++)

	mov	eax, DWORD PTR tv1251[esp+160]
	jmp	SHORT $LL16@DoTurn
$LN13@DoTurn:

; 4543 : 				{
; 4544 : 					continue;
; 4545 : 				}
; 4546 : 
; 4547 : 				pEspionage->MoveSpyTo(pCity, uiSpy, false);

	mov	ecx, DWORD PTR _uiSpy$225437[esp+160]
	push	0
	push	ecx
	push	esi
	mov	ecx, ebp
	call	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo

; 4548 : 				iCorrectlyAssignedDefenseSpies++;

	inc	DWORD PTR _iCorrectlyAssignedDefenseSpies$[esp+160]

; 4549 : 				break;
; 4550 : 			}
; 4551 : 		}
; 4552 : 		// if we have remaining offensive spies to assign
; 4553 : 		else if(iTargetOffensiveSpies > iCorrectlyAssignedOffenseSpies)

	jmp	$LN28@DoTurn
$LN17@DoTurn:
	mov	edx, DWORD PTR _iTargetOffensiveSpies$[esp+160]
	cmp	edx, DWORD PTR _iCorrectlyAssignedOffenseSpies$[esp+160]
	jle	SHORT $LN11@DoTurn

; 4554 : 		{
; 4555 : 			for(int iCity = 0; iCity < iTargetOffensiveSpies && iCity < (int)apCityOffense.size(); iCity++)

	xor	ebx, ebx
	test	edx, edx
	jle	$LN28@DoTurn
	mov	eax, DWORD PTR _apCityOffense$[esp+168]
	sub	eax, DWORD PTR _apCityOffense$[esp+164]
	sar	eax, 2
	mov	DWORD PTR tv1263[esp+160], eax
$LL10@DoTurn:
	cmp	ebx, eax
	jge	$LN28@DoTurn

; 4556 : 			{
; 4557 : 				CvCity* pCity = apCityOffense[iCity];

	mov	eax, DWORD PTR _apCityOffense$[esp+164]
	mov	esi, DWORD PTR [eax+ebx*4]

; 4558 : 
; 4559 : 				// if a spy is already in this city, skip it
; 4560 : 				if(pEspionage->GetSpyIndexInCity(pCity) != -1)

	test	esi, esi
	je	SHORT $LN7@DoTurn
	mov	ecx, DWORD PTR [ebp+1296]
	mov	edi, DWORD PTR [ecx+44]
	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	cmp	DWORD PTR [eax+edi*4], -1
	je	SHORT $LN7@DoTurn
	inc	ebx
	cmp	ebx, DWORD PTR _iTargetOffensiveSpies$[esp+160]
	jge	$LN28@DoTurn

; 4554 : 		{
; 4555 : 			for(int iCity = 0; iCity < iTargetOffensiveSpies && iCity < (int)apCityOffense.size(); iCity++)

	mov	eax, DWORD PTR tv1263[esp+160]
	jmp	SHORT $LL10@DoTurn
$LN7@DoTurn:

; 4561 : 				{
; 4562 : 					continue;
; 4563 : 				}
; 4564 : 
; 4565 : 				pEspionage->MoveSpyTo(pCity, uiSpy, false);

	mov	edx, DWORD PTR _uiSpy$225437[esp+160]
	push	0
	push	edx
	push	esi
	mov	ecx, ebp
	call	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo

; 4566 : 				iCorrectlyAssignedOffenseSpies++;

	inc	DWORD PTR _iCorrectlyAssignedOffenseSpies$[esp+160]

; 4567 : 				break;
; 4568 : 			}
; 4569 : 		}
; 4570 : 		// if we have remaining city-state spies to assign
; 4571 : 		else if (iTargetCityStateSpies > iCorrectlyAssignedCityStateSpies)

	jmp	SHORT $LN28@DoTurn
$LN11@DoTurn:
	mov	eax, DWORD PTR _iCorrectlyAssignedCityStateSpies$[esp+160]
	cmp	DWORD PTR _iTargetCityStateSpies$[esp+160], eax
	jle	SHORT $LN28@DoTurn

; 4572 : 		{
; 4573 : 			for (int iCity = 0; iCity < iTargetCityStateSpies && iCity < (int)apCityMinor.size(); iCity++)

	xor	ebx, ebx
	cmp	DWORD PTR _iTargetCityStateSpies$[esp+160], ebx
	jle	SHORT $LN28@DoTurn
	mov	eax, DWORD PTR _apCityMinor$[esp+168]
	sub	eax, DWORD PTR _apCityMinor$[esp+164]
	sar	eax, 2
	mov	DWORD PTR tv1276[esp+160], eax
$LL4@DoTurn:
	cmp	ebx, eax
	jge	SHORT $LN28@DoTurn

; 4574 : 			{
; 4575 : 				CvCity* pCity = apCityMinor[iCity];

	mov	ecx, DWORD PTR _apCityMinor$[esp+164]
	mov	esi, DWORD PTR [ecx+ebx*4]

; 4576 : 
; 4577 : 				// if a spy is already in this city, skip it
; 4578 : 				if (pEspionage->GetSpyIndexInCity(pCity) != -1)

	test	esi, esi
	je	SHORT $LN1@DoTurn
	mov	edx, DWORD PTR [ebp+1296]
	mov	edi, DWORD PTR [edx+44]
	mov	ecx, esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	add	eax, 4
	cmp	DWORD PTR [eax+edi*4], -1
	je	SHORT $LN1@DoTurn
	inc	ebx
	cmp	ebx, DWORD PTR _iTargetCityStateSpies$[esp+160]
	jge	SHORT $LN28@DoTurn

; 4572 : 		{
; 4573 : 			for (int iCity = 0; iCity < iTargetCityStateSpies && iCity < (int)apCityMinor.size(); iCity++)

	mov	eax, DWORD PTR tv1276[esp+160]
	jmp	SHORT $LL4@DoTurn
$LN1@DoTurn:

; 4579 : 				{
; 4580 : 					continue;
; 4581 : 				}
; 4582 : 
; 4583 : 				pEspionage->MoveSpyTo(pCity, uiSpy, false);

	mov	eax, DWORD PTR _uiSpy$225437[esp+160]
	push	0
	push	eax
	push	esi
	mov	ecx, ebp
	call	?MoveSpyTo@CvPlayerEspionage@@QAE_NPAVCvCity@@I_N@Z ; CvPlayerEspionage::MoveSpyTo

; 4584 : 				iCorrectlyAssignedCityStateSpies++;

	inc	DWORD PTR _iCorrectlyAssignedCityStateSpies$[esp+160]
$LN28@DoTurn:
	mov	eax, DWORD PTR _uiSpy$225437[esp+160]
	add	DWORD PTR tv1692[esp+160], 28		; 0000001cH
	inc	eax
	mov	DWORD PTR _uiSpy$225437[esp+160], eax
	cmp	eax, DWORD PTR [ebp+8]
	jb	$LL392@DoTurn
$LN27@DoTurn:

; 4585 : 				break;
; 4586 : 			}
; 4587 : 		}
; 4588 : 	}
; 4589 : }

	mov	eax, DWORD PTR _apCityMinor$[esp+164]
	pop	edi
	pop	ebp
	pop	ebx
	test	eax, eax
	je	SHORT $LN331@DoTurn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN331@DoTurn:
	mov	eax, DWORD PTR _apCityDefense$[esp+152]
	test	eax, eax
	je	SHORT $LN338@DoTurn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN338@DoTurn:
	mov	eax, DWORD PTR _apCityOffense$[esp+152]
	test	eax, eax
	je	SHORT $LN345@DoTurn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN345@DoTurn:
	mov	eax, DWORD PTR _apCityDiplomat$[esp+152]
	test	eax, eax
	je	SHORT $LN352@DoTurn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN352@DoTurn:
	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 144				; 00000090H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strMsg$225067[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T265225[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _apCityDiplomat$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _apCityOffense$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR _apCityDefense$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?DoTurn@CvEspionageAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR _apCityMinor$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__ehhandler$?DoTurn@CvEspionageAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvEspionageAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvEspionageAI@@QAEXXZ ENDP			; CvEspionageAI::DoTurn
PUBLIC	?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z	; CvPlayerEspionage::UncoverIntrigue
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ:PROC ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ:PROC ; CvCity::getProductionBuilding
EXTRN	?getProductionProject@CvCity@@QBE?AW4ProjectTypes@@XZ:PROC ; CvCity::getProductionProject
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ:PROC ; CvAIOperation::GetTargetPlot
EXTRN	?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z:PROC ; CvMilitaryAI::GetSneakAttackOperation
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z$0
__ehfuncinfo$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z
_TEXT	SEGMENT
_eCityOwner$ = -56					; size = 4
_this$ = -52						; size = 4
_pCity$ = -48						; size = 4
tv1168 = -44						; size = 4
_i$223099 = -44						; size = 4
_ui$223149 = -40					; size = 4
_eTargetPlayer$223116 = -40				; size = 4
tv1195 = -36						; size = 4
_pSneakAttackOperation$223120 = -36			; size = 4
tv1091 = -32						; size = 4
_aiMajorCivIndex$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_uiSpyIndex$ = 8					; size = 4
?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z PROC	; CvPlayerEspionage::UncoverIntrigue, COMDAT
; _this$ = ecx

; 751  : {

	push	-1
	push	__ehhandler$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH

; 752  : 	CvEspionageSpy* pSpy = &(m_aSpyList[uiSpyIndex]);

	mov	eax, DWORD PTR _uiSpyIndex$[esp+52]
	mov	edx, ecx
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	add	ecx, ecx
	add	ecx, ecx
	push	ebx
	add	eax, ecx
	push	ebp

; 753  : 	CvPlot* pCityPlot = GC.getMap().plot(pSpy->m_iCityX, pSpy->m_iCityY);

	mov	ebp, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+72], edx
	mov	DWORD PTR tv1091[esp+72], ecx
	cmp	eax, -2147483647			; 80000001H
	je	$LN58@UncoverInt
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN58@UncoverInt
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN380@UncoverInt
	test	eax, eax
	jge	SHORT $LN70@UncoverInt
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN72@UncoverInt
$LN70@UncoverInt:
	cmp	eax, ecx
	jl	SHORT $LN380@UncoverInt
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN72@UncoverInt
$LN380@UncoverInt:
	mov	esi, eax
$LN72@UncoverInt:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN383@UncoverInt
	test	ebp, ebp
	jge	SHORT $LN80@UncoverInt
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN82@UncoverInt
$LN80@UncoverInt:
	cmp	ebp, edi
	jl	SHORT $LN383@UncoverInt
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN82@UncoverInt
$LN383@UncoverInt:
	mov	edx, ebp
$LN82@UncoverInt:
	test	esi, esi
	jl	SHORT $LN58@UncoverInt
	cmp	esi, ecx
	jge	SHORT $LN58@UncoverInt
	test	edx, edx
	jl	SHORT $LN58@UncoverInt
	cmp	edx, edi
	jge	SHORT $LN58@UncoverInt
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	jmp	SHORT $LN60@UncoverInt
$LN58@UncoverInt:
	xor	ecx, ecx
$LN60@UncoverInt:

; 754  : 	CvCity* pCity = NULL;
; 755  : 	CvCityEspionage* pCityEspionage = NULL;
; 756  : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	eax, DWORD PTR _this$[esp+72]
	mov	edx, DWORD PTR [eax+1296]
	mov	edi, DWORD PTR [edx+44]

; 757  : 	PlayerTypes eCityOwner = NO_PLAYER;
; 758  : 	if(pCityPlot)

	test	ecx, ecx
	je	$LN364@UncoverInt

; 759  : 	{
; 760  : 		pCity = pCityPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	xor	ebx, ebx
	cmp	eax, ebx
	jl	SHORT $LN100@UncoverInt
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN100@UncoverInt
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN387@UncoverInt
$LN100@UncoverInt:
	xor	eax, eax
$LN387@UncoverInt:

; 761  : 		eCityOwner = pCity->getOwner();

	mov	esi, DWORD PTR [eax+84]

; 762  : 		pCityEspionage = pCity->GetCityEspionage();

	mov	ecx, eax
	mov	DWORD PTR _pCity$[esp+72], eax
	mov	DWORD PTR _eCityOwner$[esp+72], esi
	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage

; 763  : 	}
; 764  : 
; 765  : 	CvAssertMsg(pCity, "Spy needs to be in city to uncover intrigue");
; 766  : 	if(!pCity)
; 767  : 	{
; 768  : 		return;
; 769  : 	}
; 770  : 
; 771  : 	CvAssertMsg(ePlayer != eCityOwner, "Uncover intrigue should not occur when a spy is in their own city");
; 772  : 	if(ePlayer == eCityOwner)

	cmp	edi, esi
	je	$LN364@UncoverInt

; 773  : 	{
; 774  : 		return;
; 775  : 	}
; 776  : 
; 777  : 	// make a list of the active civs
; 778  : 	std::vector<int> aiMajorCivIndex;

	xor	edi, edi
	xor	eax, eax
	mov	DWORD PTR _aiMajorCivIndex$[esp+76], edi
	mov	DWORD PTR _aiMajorCivIndex$[esp+80], eax
	mov	DWORD PTR _aiMajorCivIndex$[esp+84], ebx

; 779  : 	for(int i = 0; i < MAX_MAJOR_CIVS; i++)

	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+80], ebx
	mov	DWORD PTR _i$223099[esp+72], esi
	npad	10
$LL385@UncoverInt:

; 780  : 	{
; 781  : 		if(GET_PLAYER((PlayerTypes)i).isAlive())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, esi
	imul	edx, 63236				; 0000f704H
	cmp	BYTE PTR [edx+ecx+2256], 0
	je	SHORT $LN46@UncoverInt

; 782  : 		{
; 783  : 			aiMajorCivIndex.push_back(i);

	cmp	edi, ebx
	jne	SHORT $LN160@UncoverInt
	xor	ecx, ecx
	jmp	SHORT $LN161@UncoverInt
$LN160@UncoverInt:
	mov	ecx, DWORD PTR _aiMajorCivIndex$[esp+84]
	sub	ecx, edi
	sar	ecx, 2
$LN161@UncoverInt:
	mov	edx, eax
	sub	edx, edi
	sar	edx, 2
	cmp	edx, ecx
	jae	SHORT $LN153@UncoverInt
	mov	DWORD PTR [eax], esi
	add	eax, 4
	mov	DWORD PTR _aiMajorCivIndex$[esp+80], eax
	jmp	SHORT $LN46@UncoverInt
$LN153@UncoverInt:
	lea	ecx, DWORD PTR _i$223099[esp+72]
	push	ecx
	push	1
	push	eax
	lea	ecx, DWORD PTR _aiMajorCivIndex$[esp+84]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	eax, DWORD PTR _aiMajorCivIndex$[esp+80]
	mov	edi, DWORD PTR _aiMajorCivIndex$[esp+76]
$LN46@UncoverInt:
	inc	esi
	cmp	esi, 22					; 00000016H
	mov	DWORD PTR _i$223099[esp+72], esi
	jl	SHORT $LL385@UncoverInt

; 784  : 		}
; 785  : 	}
; 786  : 
; 787  : 	// randomize that list
; 788  : 	for(uint ui = 0; ui < aiMajorCivIndex.size(); ui++)

	sub	eax, edi
	mov	ebx, eax
	sar	ebx, 2
	xor	esi, esi
	mov	DWORD PTR tv1168[esp+72], ebx
	test	ebx, ebx
	jbe	SHORT $LN41@UncoverInt
$LL43@UncoverInt:

; 789  : 	{
; 790  : 		int iTempValue;
; 791  : 		uint uiTargetSlot = GC.getGame().getJonRandNum(aiMajorCivIndex.size(), "Randomizing aiMajorCivIndex list within UncoverIntrigue");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG223111
	push	ebx
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 792  : 		iTempValue = aiMajorCivIndex[ui];

	mov	ecx, DWORD PTR [edi+esi*4]

; 793  : 		aiMajorCivIndex[ui] = aiMajorCivIndex[uiTargetSlot];

	mov	edx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [edi+esi*4], edx
	inc	esi

; 794  : 		aiMajorCivIndex[uiTargetSlot] = iTempValue;

	mov	DWORD PTR [edi+eax*4], ecx
	cmp	esi, ebx
	jb	SHORT $LL43@UncoverInt
$LN41@UncoverInt:

; 795  : 	}
; 796  : 
; 797  : 	// go through to determine any intrigue
; 798  : 
; 799  : 	// sending out a sneak attack
; 800  : 	for(uint ui = 0; ui < aiMajorCivIndex.size(); ui++)

	xor	edi, edi
	test	ebx, ebx
	jbe	$LN379@UncoverInt
	mov	ebp, DWORD PTR _eCityOwner$[esp+72]
$LL40@UncoverInt:

; 801  : 	{
; 802  : 		PlayerTypes eTargetPlayer = (PlayerTypes)aiMajorCivIndex[ui];

	mov	eax, DWORD PTR _aiMajorCivIndex$[esp+76]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _eTargetPlayer$223116[esp+72], ebx

; 803  : 		// a player shouldn't target themselves for a sneak attack. That's strange.
; 804  : 		if(eTargetPlayer == eCityOwner)

	cmp	ebx, ebp
	je	SHORT $LN39@UncoverInt

; 805  : 		{
; 806  : 			continue;
; 807  : 		}
; 808  : 
; 809  : 		// Don't tell other civs about what the shadow ai is thinking because that's incorrect information!
; 810  : 		if(GET_PLAYER(eCityOwner).isHuman())

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, ebp
	imul	esi, 63236				; 0000f704H
	add	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN39@UncoverInt

; 811  : 		{
; 812  : 			continue;
; 813  : 		}
; 814  : 
; 815  : 		CvAIOperation* pSneakAttackOperation = GET_PLAYER(eCityOwner).GetMilitaryAI()->GetSneakAttackOperation(eTargetPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	push	ebx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetSneakAttackOperation@CvMilitaryAI@@QAEPAVCvAIOperation@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetSneakAttackOperation
	mov	DWORD PTR _pSneakAttackOperation$223120[esp+72], eax

; 816  : 		if(!pSneakAttackOperation)

	test	eax, eax
	jne	SHORT $LN35@UncoverInt
$LN39@UncoverInt:

; 795  : 	}
; 796  : 
; 797  : 	// go through to determine any intrigue
; 798  : 
; 799  : 	// sending out a sneak attack
; 800  : 	for(uint ui = 0; ui < aiMajorCivIndex.size(); ui++)

	inc	edi
	cmp	edi, DWORD PTR tv1168[esp+72]
	jb	SHORT $LL40@UncoverInt

; 753  : 	CvPlot* pCityPlot = GC.getMap().plot(pSpy->m_iCityX, pSpy->m_iCityY);

	jmp	$LN379@UncoverInt
$LN35@UncoverInt:

; 817  : 		{
; 818  : 			continue;
; 819  : 		}
; 820  : 
; 821  : 		CvCity* pTargetCity = NULL;
; 822  : 		int iSpyRank = m_aSpyList[uiSpyIndex].m_eRank;

	mov	ebp, DWORD PTR _this$[esp+72]
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR tv1091[esp+72]

; 823  : 		iSpyRank += m_pPlayer->GetCulture()->GetInfluenceMajorCivSpyRankBonus(eCityOwner);

	mov	edx, DWORD PTR _eCityOwner$[esp+72]
	mov	esi, DWORD PTR [ecx+eax+12]
	mov	ecx, DWORD PTR [ebp+1296]
	push	edx
	xor	ebx, ebx
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceMajorCivSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceMajorCivSpyRankBonus
	add	esi, eax

; 824  : 
; 825  : 		if(iSpyRank >= SPY_RANK_AGENT)

	cmp	esi, 1
	jl	SHORT $LN238@UncoverInt

; 826  : 		{
; 827  : 			CvPlot* pPlot = pSneakAttackOperation->GetTargetPlot();

	mov	ecx, DWORD PTR _pSneakAttackOperation$223120[esp+72]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 828  : 			if(pPlot)

	test	eax, eax
	je	SHORT $LN238@UncoverInt

; 829  : 			{
; 830  : 				pTargetCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN237@UncoverInt
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN237@UncoverInt
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax
	jmp	SHORT $LN238@UncoverInt
$LN237@UncoverInt:
	xor	ebx, ebx
$LN238@UncoverInt:

; 831  : 			}
; 832  : 		}
; 833  : 
; 834  : 		PlayerTypes eRevealedTargetPlayer = NO_PLAYER;

	or	edi, -1

; 835  : 		if (iSpyRank == SPY_RANK_RECRUIT)

	test	esi, esi
	jne	SHORT $LN32@UncoverInt

; 836  : 		{
; 837  : 			eRevealedTargetPlayer = (PlayerTypes)MAX_MAJOR_CIVS; // hack to indicate that we shouldn't know the target due to our low spy rank

	lea	edi, DWORD PTR [esi+22]

; 838  : 		}
; 839  : 		else

	jmp	SHORT $LN30@UncoverInt
$LN32@UncoverInt:

; 840  : 		{
; 841  : 			if(GET_TEAM(m_pPlayer->getTeam()).isHasMet(GET_PLAYER(eTargetPlayer).getTeam()))

	mov	ecx, DWORD PTR _eTargetPlayer$223116[esp+72]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+edx+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN248@UncoverInt
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN249@UncoverInt
$LN248@UncoverInt:
	or	ecx, -1
$LN249@UncoverInt:
	mov	eax, DWORD PTR [ebp+1296]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN257@UncoverInt
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN258@UncoverInt
$LN257@UncoverInt:
	or	eax, -1
$LN258@UncoverInt:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	test	al, al
	je	SHORT $LN30@UncoverInt

; 842  : 			{
; 843  : 				eRevealedTargetPlayer = eTargetPlayer;

	mov	edi, DWORD PTR _eTargetPlayer$223116[esp+72]
$LN30@UncoverInt:

; 844  : 			}
; 845  : 		}
; 846  : 
; 847  : 		switch(pSneakAttackOperation->GetOperationType())

	mov	ecx, DWORD PTR _pSneakAttackOperation$223120[esp+72]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	cmp	eax, 6
	je	SHORT $LN27@UncoverInt
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN379@UncoverInt

; 852  : 		}
; 853  : 		break;
; 854  : 		case AI_OPERATION_NAVAL_SNEAK_ATTACK:
; 855  : 		{
; 856  : 			AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, eRevealedTargetPlayer, NO_BUILDING, NO_PROJECT, INTRIGUE_TYPE_AMPHIBIOUS_SNEAK_ATTACK, uiSpyIndex, pTargetCity, true);

	mov	eax, DWORD PTR _uiSpyIndex$[esp+68]
	mov	ecx, DWORD PTR _eCityOwner$[esp+72]
	mov	edx, DWORD PTR [ebp+1296]
	push	1
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edx+44]
	push	4
	push	-1
	push	-1
	push	edi
	push	ecx
	push	eax

; 857  : 		}
; 858  : 		break;

	jmp	SHORT $LN388@UncoverInt
$LN27@UncoverInt:

; 848  : 		{
; 849  : 		case AI_OPERATION_SNEAK_CITY_ATTACK:
; 850  : 		{
; 851  : 			AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, eRevealedTargetPlayer, NO_BUILDING, NO_PROJECT, INTRIGUE_TYPE_ARMY_SNEAK_ATTACK, uiSpyIndex, pTargetCity, true);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+68]
	mov	edx, DWORD PTR _eCityOwner$[esp+72]
	mov	eax, DWORD PTR [ebp+1296]
	push	1
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR [eax+44]
	push	3
	push	-1
	push	-1
	push	edi
	push	edx
	push	ecx
$LN388@UncoverInt:
	mov	ecx, ebp
	call	?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z ; CvPlayerEspionage::AddIntrigueMessage
$LN379@UncoverInt:

; 859  : 		}
; 860  : 
; 861  : 		// If a sneak attack is reported, bust out of the loop
; 862  : 		break;
; 863  : 	}
; 864  : 
; 865  : 	// building up an army
; 866  : 	if(!GET_PLAYER(eCityOwner).isHuman())

	mov	esi, DWORD PTR _eCityOwner$[esp+72]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, esi
	imul	edi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR tv1195[esp+72], edi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN382@UncoverInt

; 867  : 	{
; 868  : 		ArmyType eArmyType = GET_PLAYER(eCityOwner).GetMilitaryAI()->GetArmyBeingBuilt();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	eax, DWORD PTR [eax+44]

; 869  : 		if(eArmyType != NO_ARMY_TYPE)

	cmp	eax, -1
	je	SHORT $LN382@UncoverInt

; 870  : 		{
; 871  : 			switch(eArmyType)

	sub	eax, 0

; 875  : 				break;
; 876  : 			case ARMY_TYPE_NAVAL_INVASION:
; 877  : 				AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, NO_PLAYER, NO_BUILDING, NO_PROJECT, INTRIGUE_TYPE_BUILDING_AMPHIBIOUS_ARMY, uiSpyIndex, pCity, true);

	mov	ebx, DWORD PTR _this$[esp+72]
	je	SHORT $LN21@UncoverInt

; 870  : 		{
; 871  : 			switch(eArmyType)

	sub	eax, 1
	jne	SHORT $LN22@UncoverInt

; 875  : 				break;
; 876  : 			case ARMY_TYPE_NAVAL_INVASION:
; 877  : 				AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, NO_PLAYER, NO_BUILDING, NO_PROJECT, INTRIGUE_TYPE_BUILDING_AMPHIBIOUS_ARMY, uiSpyIndex, pCity, true);

	mov	ecx, DWORD PTR _pCity$[esp+72]
	mov	edx, DWORD PTR _uiSpyIndex$[esp+68]
	mov	eax, DWORD PTR [ebx+1296]
	push	1
	push	ecx
	mov	ecx, DWORD PTR [eax+44]
	push	edx
	push	2
	push	-1
	push	-1
	push	-1
	push	esi
	push	ecx
	mov	ecx, ebx
	call	?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z ; CvPlayerEspionage::AddIntrigueMessage

; 878  : 				break;

	jmp	SHORT $LN22@UncoverInt
$LN21@UncoverInt:

; 872  : 			{
; 873  : 			case ARMY_TYPE_LAND:
; 874  : 				AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, NO_PLAYER, NO_BUILDING, NO_PROJECT, INTRIGUE_TYPE_BUILDING_ARMY, uiSpyIndex, pCity, true);

	mov	edx, DWORD PTR _pCity$[esp+72]
	mov	eax, DWORD PTR _uiSpyIndex$[esp+68]
	mov	ecx, DWORD PTR [ebx+1296]
	push	1
	push	edx
	mov	edx, DWORD PTR [ecx+44]
	push	eax
	push	1
	push	-1
	push	-1
	push	-1
	push	esi
	push	edx
	mov	ecx, ebx
	call	?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z ; CvPlayerEspionage::AddIntrigueMessage
	jmp	SHORT $LN22@UncoverInt
$LN382@UncoverInt:
	mov	ebx, DWORD PTR _this$[esp+72]
$LN22@UncoverInt:

; 879  : 			}
; 880  : 		}
; 881  : 	}
; 882  : 
; 883  : 	// deception!
; 884  : 	CvDiplomacyAI* pTargetDiploAI = GET_PLAYER(eCityOwner).GetDiplomacyAI();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ebp, eax

; 885  : 	CvAssertMsg(pTargetDiploAI, "pTargetDiploAI is null");
; 886  : 	if(!pTargetDiploAI)

	test	ebp, ebp

; 887  : 	{
; 888  : 		return;

	je	$LN1@UncoverInt

; 889  : 	}
; 890  : 
; 891  : 	for(uint ui = 0; ui < aiMajorCivIndex.size(); ui++)

	xor	eax, eax
	mov	DWORD PTR _ui$223149[esp+72], eax
	cmp	DWORD PTR tv1168[esp+72], eax
	jbe	$LN7@UncoverInt
	jmp	SHORT $LN18@UncoverInt
	npad	1
$LL384@UncoverInt:
	mov	edi, DWORD PTR tv1195[esp+72]
$LN18@UncoverInt:

; 892  : 	{
; 893  : 		PlayerTypes eOtherOtherPlayer = (PlayerTypes)aiMajorCivIndex[ui];

	mov	ecx, DWORD PTR _aiMajorCivIndex$[esp+76]
	mov	esi, DWORD PTR [ecx+eax*4]

; 894  : 		// doesn't make sense for player to give information on themselves
; 895  : 		if(eOtherOtherPlayer == eCityOwner)

	cmp	esi, DWORD PTR _eCityOwner$[esp+72]
	je	$LN17@UncoverInt

; 896  : 		{
; 897  : 			continue;
; 898  : 		}
; 899  : 
; 900  : 		// Don't tell other civs about what the shadow ai is thinking because that's incorrect information!
; 901  : 		if(GET_PLAYER(eCityOwner).isHuman())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN17@UncoverInt

; 902  : 		{
; 903  : 			continue;
; 904  : 		}
; 905  : 
; 906  : 		MajorCivApproachTypes eSurfaceApproach = pTargetDiploAI->GetMajorCivApproach(eOtherOtherPlayer, true);

	push	1
	push	esi
	mov	ecx, ebp
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 907  : 		MajorCivApproachTypes eHonestApproach = pTargetDiploAI->GetMajorCivApproach(eOtherOtherPlayer, false);

	push	0
	push	esi
	mov	ecx, ebp
	mov	edi, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach

; 908  : 
; 909  : 		// if the current approach is a dangerous approach
; 910  : 		if(eHonestApproach == MAJOR_CIV_APPROACH_DECEPTIVE || eHonestApproach == MAJOR_CIV_APPROACH_WAR)

	cmp	eax, 2
	je	SHORT $LN12@UncoverInt
	test	eax, eax
	jne	SHORT $LN17@UncoverInt
$LN12@UncoverInt:

; 911  : 		{
; 912  : 			// if the surface approach hides this
; 913  : 			if(eSurfaceApproach == MAJOR_CIV_APPROACH_FRIENDLY || eSurfaceApproach == MAJOR_CIV_APPROACH_NEUTRAL)

	cmp	edi, 5
	je	SHORT $LN10@UncoverInt
	cmp	edi, 6

; 928  : 				}
; 929  : 				break; // we reported intrigue, now bail out
; 930  : 			}
; 931  : 		}
; 932  : 	}

	jne	SHORT $LN17@UncoverInt
$LN10@UncoverInt:

; 914  : 			{
; 915  : 				if(GET_TEAM(GET_PLAYER(eCityOwner).getTeam()).isAtWar(GET_PLAYER(eOtherOtherPlayer).getTeam()))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, esi
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN307@UncoverInt
	mov	edx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN308@UncoverInt
$LN307@UncoverInt:
	or	edx, -1
$LN308@UncoverInt:
	mov	eax, DWORD PTR tv1195[esp+72]
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN318@UncoverInt
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN319@UncoverInt
$LN318@UncoverInt:
	or	eax, -1
$LN319@UncoverInt:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN9@UncoverInt
$LN17@UncoverInt:

; 889  : 	}
; 890  : 
; 891  : 	for(uint ui = 0; ui < aiMajorCivIndex.size(); ui++)

	mov	eax, DWORD PTR _ui$223149[esp+72]
	inc	eax
	mov	DWORD PTR _ui$223149[esp+72], eax
	cmp	eax, DWORD PTR tv1168[esp+72]
	jb	$LL384@UncoverInt

; 753  : 	CvPlot* pCityPlot = GC.getMap().plot(pSpy->m_iCityX, pSpy->m_iCityY);

	jmp	$LN7@UncoverInt
$LN9@UncoverInt:

; 916  : 				{
; 917  : 					// If the teams are already at war, this isn't notable
; 918  : 					continue;
; 919  : 				}
; 920  : 
; 921  : 				if(GET_TEAM(m_pPlayer->getTeam()).isHasMet(GET_PLAYER(eOtherOtherPlayer).getTeam()))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, esi
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN331@UncoverInt
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN332@UncoverInt
$LN331@UncoverInt:
	or	ecx, -1
$LN332@UncoverInt:
	mov	eax, DWORD PTR [ebx+1296]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN340@UncoverInt
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN341@UncoverInt
$LN340@UncoverInt:
	or	eax, -1
$LN341@UncoverInt:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet

; 922  : 				{
; 923  : 					AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, eOtherOtherPlayer, NO_BUILDING, NO_PROJECT, INTRIGUE_TYPE_DECEPTION, uiSpyIndex, pCity, true);

	push	1
	test	al, al
	je	SHORT $LN8@UncoverInt
	mov	eax, DWORD PTR _pCity$[esp+76]
	mov	ecx, DWORD PTR _uiSpyIndex$[esp+72]
	mov	edx, DWORD PTR _eCityOwner$[esp+76]
	push	eax
	mov	eax, DWORD PTR [ebx+1296]
	push	ecx
	mov	ecx, DWORD PTR [eax+44]
	push	0
	push	-1
	push	-1
	push	esi
	push	edx
	push	ecx

; 924  : 				}
; 925  : 				else

	jmp	SHORT $LN390@UncoverInt
$LN8@UncoverInt:

; 926  : 				{
; 927  : 					AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, NO_PLAYER, NO_BUILDING, NO_PROJECT, INTRIGUE_TYPE_DECEPTION, uiSpyIndex, pCity, true);

	mov	edx, DWORD PTR _pCity$[esp+76]
	mov	eax, DWORD PTR _uiSpyIndex$[esp+72]
	mov	ecx, DWORD PTR _eCityOwner$[esp+76]
	push	edx
	mov	edx, DWORD PTR [ebx+1296]
	push	eax
	mov	eax, DWORD PTR [edx+44]
	push	0
	push	-1
	push	-1
	push	-1
	push	ecx
	push	eax
$LN390@UncoverInt:
	mov	ecx, ebx
	call	?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z ; CvPlayerEspionage::AddIntrigueMessage
$LN7@UncoverInt:

; 933  : 
; 934  : 	ProjectTypes eProject = pCity->getProductionProject();

	mov	ebp, DWORD PTR _pCity$[esp+72]
	mov	ecx, ebp
	call	?getProductionProject@CvCity@@QBE?AW4ProjectTypes@@XZ ; CvCity::getProductionProject

; 935  : 	BuildingTypes eBuilding = pCity->getProductionBuilding();

	mov	ecx, ebp
	mov	edi, eax
	call	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ ; CvCity::getProductionBuilding
	mov	esi, eax

; 936  : 	bool bNotifyAboutConstruction = false;
; 937  : 	if (eProject != NO_PROJECT)

	cmp	edi, -1

; 938  : 	{
; 939  : 		bNotifyAboutConstruction = true;

	jne	SHORT $LN377@UncoverInt

; 940  : 	}
; 941  : 	else if (eBuilding != NO_BUILDING)

	cmp	esi, edi
	je	SHORT $LN1@UncoverInt

; 942  : 	{
; 943  : 		CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo

; 944  : 		CvAssertMsg(pBuildingInfo, "pBuildingInfo is null");
; 945  : 		if (pBuildingInfo)

	test	eax, eax
	je	SHORT $LN1@UncoverInt

; 946  : 		{
; 947  : 			if (::isWorldWonderClass(pBuildingInfo->GetBuildingClassInfo()))

	mov	ecx, eax
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	test	al, al
	je	SHORT $LN1@UncoverInt
$LN377@UncoverInt:

; 948  : 			{
; 949  : 				bNotifyAboutConstruction = true;
; 950  : 			}
; 951  : 		}
; 952  : 	}
; 953  : 
; 954  : 	if (bNotifyAboutConstruction)
; 955  : 	{
; 956  : 		AddIntrigueMessage(m_pPlayer->GetID(), eCityOwner, NO_PLAYER, eBuilding, eProject, INTRIGUE_TYPE_CONSTRUCTING_WONDER, uiSpyIndex, pCity, true);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+68]
	mov	edx, DWORD PTR _eCityOwner$[esp+72]
	mov	eax, DWORD PTR [ebx+1296]
	push	1
	push	ebp
	push	ecx
	mov	ecx, DWORD PTR [eax+44]
	push	5
	push	edi
	push	esi
	push	-1
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?AddIntrigueMessage@CvPlayerEspionage@@QAEXW4PlayerTypes@@00W4BuildingTypes@@W4ProjectTypes@@W4CvIntrigueType@@IPAVCvCity@@_N@Z ; CvPlayerEspionage::AddIntrigueMessage
$LN1@UncoverInt:

; 957  : 	}
; 958  : }

	mov	eax, DWORD PTR _aiMajorCivIndex$[esp+76]
	test	eax, eax
	je	SHORT $LN364@UncoverInt
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN364@UncoverInt:
	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z$0:
	lea	ecx, DWORD PTR _aiMajorCivIndex$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z ENDP	; CvPlayerEspionage::UncoverIntrigue
PUBLIC	?ProcessSpy@CvPlayerEspionage@@QAEXI@Z		; CvPlayerEspionage::ProcessSpy
EXTRN	?ChangeNumTimesRobbedBy@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeNumTimesRobbedBy
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__ehfuncinfo$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z DD 019930522H
	DD	01eH
	DD	FLAT:__unwindtable$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$13
	DD	0cH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$18
	DD	013H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$20
	DD	015H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$21
	DD	015H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$23
	DD	018H
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$25
	DD	01aH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$26
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$27
	DD	01cH
	DD	FLAT:__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$28
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvespionageclasses.cpp
xdata$x	ENDS
;	COMDAT ?ProcessSpy@CvPlayerEspionage@@QAEXI@Z
_TEXT	SEGMENT
_pCity$ = -572						; size = 4
_eCityOwner$ = -568					; size = 4
$T267273 = -564						; size = 4
_pDefenderEspionageAI$223014 = -564			; size = 4
_pDefendingPlayerEspionage$222966 = -564		; size = 4
_kSpyOwner$222953 = -564				; size = 4
_iSpyResult$222944 = -564				; size = 4
tv3830 = -560						; size = 4
_pSpy$ = -560						; size = 4
tv4587 = -556						; size = 4
tv4568 = -556						; size = 4
$T268739 = -556						; size = 4
_pEspionageAI$222986 = -556				; size = 4
_pNotifications$222973 = -556				; size = 4
_iCounterspyIndex$222947 = -556				; size = 4
tv3648 = -552						; size = 4
_pNotifications$222929 = -552				; size = 4
_pNotifications$222892 = -552				; size = 4
_bLastQualified$ = -546					; size = 1
_bHadSurveillance$ = -545				; size = 1
_strMsg$223063 = -544					; size = 28
_strMsg$223032 = -544					; size = 28
_strMsg$223006 = -544					; size = 28
_strMsg$222994 = -544					; size = 28
_strMsg$222923 = -544					; size = 28
_strMsg$222918 = -544					; size = 28
_strMsg$222911 = -544					; size = 28
tv3982 = -516						; size = 4
$T268983 = -516						; size = 4
$T268931 = -516						; size = 4
$T268803 = -516						; size = 4
_pNotifications$223017 = -516				; size = 4
_iRate$223011 = -516					; size = 4
_kHeistLocation$222943 = -516				; size = 8
_strNotification$223071 = -508				; size = 80
_strNotification$223022 = -508				; size = 80
_strNotification$222979 = -508				; size = 80
_strNotification$222935 = -508				; size = 80
_strNotification$222903 = -508				; size = 80
_strSummary$223068 = -428				; size = 80
_strSummary$223019 = -428				; size = 80
_strSummary$222975 = -428				; size = 80
_strSummary$222931 = -428				; size = 80
_strSummary$222894 = -428				; size = 80
_strMsg$223077 = -348					; size = 28
$T267109 = -320						; size = 28
$T267129 = -292						; size = 28
$T267130 = -264						; size = 28
$T267122 = -236						; size = 28
$T267131 = -208						; size = 28
$T267124 = -180						; size = 28
$T267134 = -152						; size = 28
$T267123 = -124						; size = 28
$T267110 = -96						; size = 28
$T267121 = -68						; size = 28
$T267111 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_uiSpyIndex$ = 8					; size = 4
?ProcessSpy@CvPlayerEspionage@@QAEXI@Z PROC		; CvPlayerEspionage::ProcessSpy, COMDAT
; _this$ = ecx

; 243  : {

	push	-1
	push	__ehhandler$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 560				; 00000230H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 244  : 	CvEspionageSpy* pSpy = &(m_aSpyList[uiSpyIndex]);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+580]
	mov	ebx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	add	eax, eax
	add	eax, eax
	add	ebx, eax
	push	edi

; 245  : 	bool bLastQualified;
; 246  : 	CvPlot* pCityPlot = GC.getMap().plot(pSpy->m_iCityX, pSpy->m_iCityY);

	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR tv3648[esp+588], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _pSpy$[esp+588], ebx
	mov	DWORD PTR $T267273[esp+588], eax
	cmp	edi, -2147483647			; 80000001H
	je	$LN119@ProcessSpy@2
	cmp	eax, -2147483647			; 80000001H
	je	$LN119@ProcessSpy@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [eax+4056]
	mov	ecx, DWORD PTR [eax+4020]
	test	dl, dl
	je	SHORT $LN129@ProcessSpy@2
	test	edi, edi
	jge	SHORT $LN131@ProcessSpy@2
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN129@ProcessSpy@2
$LN131@ProcessSpy@2:
	cmp	edi, ecx
	jl	SHORT $LN129@ProcessSpy@2
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN129@ProcessSpy@2:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	mov	edx, DWORD PTR $T267273[esp+588]
	test	al, al
	je	SHORT $LN139@ProcessSpy@2
	test	edx, edx
	jge	SHORT $LN141@ProcessSpy@2
	mov	eax, edx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN139@ProcessSpy@2
$LN141@ProcessSpy@2:
	cmp	edx, ebp
	jl	SHORT $LN139@ProcessSpy@2
	mov	eax, edx
	cdq
	idiv	ebp
$LN139@ProcessSpy@2:
	test	edi, edi
	jl	SHORT $LN119@ProcessSpy@2
	cmp	edi, ecx
	jge	SHORT $LN119@ProcessSpy@2
	test	edx, edx
	jl	SHORT $LN119@ProcessSpy@2
	cmp	edx, ebp
	jge	SHORT $LN119@ProcessSpy@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN121@ProcessSpy@2
$LN119@ProcessSpy@2:
	xor	ecx, ecx
$LN121@ProcessSpy@2:

; 247  : 	CvCity* pCity = NULL;
; 248  : 	CvCityEspionage* pCityEspionage = NULL;
; 249  : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	edx, DWORD PTR [esi+1296]
	mov	ebp, DWORD PTR [edx+44]
	xor	edi, edi
	mov	DWORD PTR _pCity$[esp+588], edi

; 250  : 	PlayerTypes eCityOwner = NO_PLAYER;

	mov	DWORD PTR _eCityOwner$[esp+588], -1

; 251  : 	if(pCityPlot)

	cmp	ecx, edi
	je	SHORT $LN82@ProcessSpy@2

; 252  : 	{
; 253  : 		pCity = pCityPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	cmp	eax, edi
	jl	SHORT $LN161@ProcessSpy@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN161@ProcessSpy@2
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pCity$[esp+588], eax

; 254  : 		if(pCity)

	test	eax, eax
	je	SHORT $LN82@ProcessSpy@2

; 255  : 		{
; 256  : 			eCityOwner = pCity->getOwner();

	mov	ecx, eax
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _eCityOwner$[esp+588], edx

; 257  : 			pCityEspionage = pCity->GetCityEspionage();

	call	?GetCityEspionage@CvCity@@QBEPAVCvCityEspionage@@XZ ; CvCity::GetCityEspionage
	mov	edi, eax
$LN82@ProcessSpy@2:

; 258  : 		}
; 259  : 	}
; 260  : 
; 261  : 	bool bHadSurveillance = HasEstablishedSurveillance(uiSpyIndex);

	mov	eax, DWORD PTR _uiSpyIndex$[esp+584]
	push	eax
	mov	ecx, esi
	call	?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::HasEstablishedSurveillance
	mov	BYTE PTR _bHadSurveillance$[esp+588], al

; 262  : 
; 263  : 	switch(pSpy->m_eSpyState)

	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, 8
	ja	$LN2@ProcessSpy@2
	jmp	DWORD PTR $LN1036@ProcessSpy@2[eax*4]

; 252  : 	{
; 253  : 		pCity = pCityPlot->getPlotCity();

$LN161@ProcessSpy@2:
	mov	DWORD PTR _pCity$[esp+588], edi

; 254  : 		if(pCity)

	jmp	SHORT $LN82@ProcessSpy@2
$LN78@ProcessSpy@2:

; 264  : 	{
; 265  : 	case SPY_STATE_UNASSIGNED:
; 266  : 		// spy is idling
; 267  : 		return;
; 268  : 		break;
; 269  : 	case SPY_STATE_TRAVELLING:
; 270  : 		// spy is traveling to location
; 271  : 		CvAssertMsg(pCity, "pCity not defined. What?");
; 272  : 		if(!pCity)

	cmp	DWORD PTR _pCity$[esp+588], 0
	je	$LN1@ProcessSpy@2

; 273  : 		{
; 274  : 			return;
; 275  : 		}
; 276  : 		// if the spy has completed travelling, move to location
; 277  : 		pCityEspionage->Process(ePlayer);

	mov	ecx, DWORD PTR [edi+ebp*4+180]
	add	DWORD PTR [edi+ebp*4+92], ecx

; 278  : 		if(pCityEspionage->HasReachedGoal(ePlayer))

	mov	edx, DWORD PTR [edi+ebp*4+92]
	cmp	edx, DWORD PTR [edi+ebp*4+268]
	jl	$LN2@ProcessSpy@2

; 279  : 		{
; 280  : 			pCityEspionage->ResetProgress(ePlayer);

	or	eax, -1
	mov	DWORD PTR [edi+ebp*4+92], eax
	mov	DWORD PTR [edi+ebp*4+268], eax
	mov	DWORD PTR [edi+ebp*4+180], eax

; 281  : 			if (pSpy->m_bIsDiplomat)

	cmp	BYTE PTR [ebx+24], 0
	je	SHORT $LN75@ProcessSpy@2

; 282  : 			{
; 283  : 				pSpy->m_eSpyState = SPY_STATE_MAKING_INTRODUCTIONS;

	mov	DWORD PTR [ebx+16], 6

; 284  : 				int iRate = CalcPerTurn(SPY_STATE_MAKING_INTRODUCTIONS, pCity, uiSpyIndex);
; 285  : 				int iGoal = CalcRequired(SPY_STATE_MAKING_INTRODUCTIONS, pCity, uiSpyIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getLeaguePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getLeaguePercent
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 286  : 				pCityEspionage->SetActivity(ePlayer, 0, iRate, iGoal);				

	jmp	SHORT $LN1035@ProcessSpy@2
$LN75@ProcessSpy@2:

; 287  : 			}
; 288  : 			else if(pCity->getTeam() == m_pPlayer->getTeam())  // moved to a friendly city

	mov	ecx, DWORD PTR _pCity$[esp+588]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	ecx, DWORD PTR [esi+1296]
	mov	ebx, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	ebx, eax
	jne	SHORT $LN73@ProcessSpy@2

; 289  : 			{
; 290  : 				// moving to a defensive location
; 291  : 				pSpy->m_eSpyState = SPY_STATE_COUNTER_INTEL;

	mov	eax, DWORD PTR _pSpy$[esp+588]
	mov	DWORD PTR [eax+16], 5

; 292  : 			}
; 293  : 			else // moved to an opponent's city

	jmp	$LN2@ProcessSpy@2
$LN73@ProcessSpy@2:

; 294  : 			{
; 295  : 				pSpy->m_eSpyState = SPY_STATE_SURVEILLANCE;

	mov	ecx, DWORD PTR _pSpy$[esp+588]

; 296  : 				int iRate = CalcPerTurn(SPY_STATE_SURVEILLANCE, pCity, uiSpyIndex);
; 297  : 				int iGoal = CalcRequired(SPY_STATE_SURVEILLANCE, pCity, uiSpyIndex);

	mov	edx, DWORD PTR _pCity$[esp+588]
	mov	DWORD PTR [ecx+16], 2
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR [esi+1296]
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceSurveillanceTime
$LN1035@ProcessSpy@2:

; 298  : 				pCityEspionage->SetActivity(ePlayer, 0, iRate, iGoal);

	mov	DWORD PTR [edi+ebp*4+92], 0
	mov	DWORD PTR [edi+ebp*4+180], 1
	mov	DWORD PTR [edi+ebp*4+268], eax

; 299  : 			}
; 300  : 		}
; 301  : 		break;

	jmp	$LN2@ProcessSpy@2
$LN71@ProcessSpy@2:

; 302  : 	case SPY_STATE_SURVEILLANCE:
; 303  : 		CvAssertMsg(pCity, "pCity not defined. What?");
; 304  : 		if(!pCity)

	cmp	DWORD PTR _pCity$[esp+588], 0
	je	$LN1@ProcessSpy@2

; 305  : 		{
; 306  : 			return;
; 307  : 		}
; 308  : 
; 309  : 		bLastQualified = pCityEspionage->HasReachedGoal(ePlayer);

	mov	eax, DWORD PTR [edi+ebp*4+92]
	cmp	eax, DWORD PTR [edi+ebp*4+268]

; 310  : 		pCityEspionage->Process(ePlayer);

	mov	ecx, DWORD PTR [edi+ebp*4+180]
	setge	BYTE PTR _bLastQualified$[esp+588]
	add	DWORD PTR [edi+ebp*4+92], ecx

; 311  : 		if(pCityEspionage->HasReachedGoal(ePlayer))

	mov	edx, DWORD PTR [edi+ebp*4+92]
	cmp	edx, DWORD PTR [edi+ebp*4+268]
	jl	$LN2@ProcessSpy@2

; 312  : 		{
; 313  : 			if(GET_PLAYER(eCityOwner).isMinorCiv())

	mov	eax, DWORD PTR _eCityOwner$[esp+588]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	add	ecx, eax
	mov	DWORD PTR tv3830[esp+588], eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	$LN68@ProcessSpy@2

; 314  : 			{
; 315  : 				pSpy->m_eSpyState = SPY_STATE_RIG_ELECTION;
; 316  : 				pCityEspionage->ResetProgress(ePlayer);

	or	eax, -1

; 317  : 				int iRate = CalcPerTurn(SPY_STATE_RIG_ELECTION, pCity, uiSpyIndex);

	cmp	DWORD PTR _uiSpyIndex$[esp+584], 0
	mov	DWORD PTR [ebx+16], 4
	mov	DWORD PTR [edi+ebp*4+92], eax
	mov	DWORD PTR [edi+ebp*4+268], eax
	mov	DWORD PTR [edi+ebp*4+180], eax
	lea	ebx, DWORD PTR [eax+2]
	jl	SHORT $LN385@ProcessSpy@2
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR tv3648[esp+588]
	mov	ecx, DWORD PTR _pCity$[esp+588]
	mov	ebx, DWORD PTR [eax+edx+12]
	mov	eax, DWORD PTR [ecx+84]
	mov	ecx, DWORD PTR [esi+1296]
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceCityStateSpyRankBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceCityStateSpyRankBonus
	add	ebx, eax
	inc	ebx
	imul	ebx, ebx
$LN385@ProcessSpy@2:

; 318  : 				int iGoal = CalcRequired(SPY_STATE_RIG_ELECTION, pCity, uiSpyIndex);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTurnsUntilMinorCivElection@CvGame@@QAEHXZ ; CvGame::GetTurnsUntilMinorCivElection

; 319  : 				pCityEspionage->SetActivity(ePlayer, 0, iRate, iGoal);

	mov	DWORD PTR [edi+ebp*4+92], 0
	mov	DWORD PTR [edi+ebp*4+180], ebx
	mov	DWORD PTR [edi+ebp*4+268], eax

; 320  : 				pCityEspionage->SetLastProgress(ePlayer, iRate);

	mov	DWORD PTR [edi+ebp*4+356], ebx

; 321  : 			}
; 322  : 			else

	jmp	$LN2@ProcessSpy@2
$LN68@ProcessSpy@2:

; 323  : 			{
; 324  : 				BuildStealableTechList(eCityOwner);

	mov	edx, DWORD PTR _eCityOwner$[esp+588]
	push	edx
	mov	ecx, esi
	call	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ; CvPlayerEspionage::BuildStealableTechList

; 325  : 				// moved rate out here to set the potential
; 326  : 				int iBasePotentialRate = CalcPerTurn(SPY_STATE_GATHERING_INTEL, pCity, -1);

	mov	eax, DWORD PTR _pCity$[esp+588]
	push	-1
	push	eax
	push	3
	mov	ecx, esi
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn

; 327  : 				pCityEspionage->SetLastBasePotential(ePlayer, iBasePotentialRate);

	mov	DWORD PTR [edi+ebp*4+532], eax

; 328  : 
; 329  : 				if(m_aaPlayerStealableTechList[eCityOwner].size() > 0)

	mov	eax, DWORD PTR _eCityOwner$[esp+588]
	mov	edx, DWORD PTR [esi+264]
	lea	ecx, DWORD PTR [eax+eax*4]
	cmp	DWORD PTR [edx+ecx*4+4], 0
	jbe	$LN66@ProcessSpy@2

; 330  : 				{
; 331  : 					// TODO: need to proclaim surveillance somehow
; 332  : 					pSpy->m_eSpyState = SPY_STATE_GATHERING_INTEL;
; 333  : 					pCityEspionage->ResetProgress(ePlayer);
; 334  : 					int iPotentialRate = CalcPerTurn(SPY_STATE_GATHERING_INTEL, pCity, uiSpyIndex);

	mov	ecx, DWORD PTR _pCity$[esp+588]
	or	eax, -1
	mov	DWORD PTR [ebx+16], 3
	mov	DWORD PTR [edi+ebp*4+92], eax
	mov	DWORD PTR [edi+ebp*4+268], eax
	mov	DWORD PTR [edi+ebp*4+180], eax
	mov	eax, DWORD PTR _uiSpyIndex$[esp+584]
	push	eax
	push	ecx
	push	3
	mov	ecx, esi
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn

; 335  : 					int iGoal = CalcRequired(SPY_STATE_GATHERING_INTEL, pCity, uiSpyIndex);

	mov	edx, DWORD PTR _uiSpyIndex$[esp+584]
	mov	ebx, eax
	mov	eax, DWORD PTR _pCity$[esp+588]
	push	edx
	push	eax
	push	3
	mov	ecx, esi
	call	?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcRequired

; 368  : 
; 369  : 				}
; 370  : 				UncoverIntrigue(uiSpyIndex);

	mov	edx, DWORD PTR _uiSpyIndex$[esp+584]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR [edi+ebp*4+92], 0
	mov	DWORD PTR [edi+ebp*4+180], ebx
	mov	DWORD PTR [edi+ebp*4+268], eax
	mov	DWORD PTR [edi+ebp*4+356], ebx
	mov	DWORD PTR [edi+ebp*4+444], ebx
	call	?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z ; CvPlayerEspionage::UncoverIntrigue

; 371  : 			}
; 372  : 		}
; 373  : 		break;

	jmp	$LN2@ProcessSpy@2
$LN66@ProcessSpy@2:

; 336  : 					pCityEspionage->SetActivity(ePlayer, 0, iPotentialRate, iGoal);
; 337  : 					pCityEspionage->SetLastProgress(ePlayer, iPotentialRate);
; 338  : 					pCityEspionage->SetLastPotential(ePlayer, iPotentialRate);
; 339  : 				}
; 340  : 				else
; 341  : 				{
; 342  : 					// if this is the first time they crossed the threshold
; 343  : 					if(!bLastQualified)

	cmp	BYTE PTR _bLastQualified$[esp+588], 0
	jne	$LN63@ProcessSpy@2

; 344  : 					{
; 345  : 						CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$222892[esp+588], eax

; 346  : 						if(pNotifications)

	test	eax, eax
	je	$LN63@ProcessSpy@2

; 347  : 						{
; 348  : 							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH_S");

	lea	ecx, DWORD PTR _strSummary$222894[esp+588]
	push	OFFSET $SG222896
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 349  : 							strSummary << GET_PLAYER(eCityOwner).getCivilizationInfo().getShortDescriptionKey();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv3830[esp+588]
	lea	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR __$EHRec$[esp+596], 0
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strSummary$222894[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 350  : 							Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH");

	lea	ecx, DWORD PTR _strNotification$222903[esp+588]
	push	OFFSET $SG222905
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 351  : 							strNotification << GetSpyRankName(pSpy->m_eRank);;

	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+600], 1
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$222903[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 352  : 							strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$222903[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 353  : 							strNotification << GET_PLAYER(eCityOwner).getCivilizationInfo().getShortDescriptionKey();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv3830[esp+588]
	add	ecx, edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$222903[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 354  : 							pNotifications->Add(NOTIFICATION_SPY_CANT_STEAL_TECH, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$222894[esp+604]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$222903[esp+608]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotifications$222892[esp+608]
	push	eax
	push	240697813				; 0e58c1d5H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 355  : 						}

	lea	ecx, DWORD PTR _strNotification$222903[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$222894[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN63@ProcessSpy@2:

; 356  : 					}
; 357  : 					int iRate = CalcPerTurn(SPY_STATE_SURVEILLANCE, pCity, uiSpyIndex);
; 358  : 					pCityEspionage->SetLastProgress(ePlayer, iRate);

	mov	DWORD PTR [edi+ebp*4+356], 1

; 359  : 					pCityEspionage->SetLastPotential(ePlayer, -1); // set the last potential back to zero so that 

	mov	DWORD PTR [edi+ebp*4+444], -1

; 360  : 					pSpy->m_bEvaluateReassignment = true; // flag to re-evaluate because we can't steal
; 361  : 					if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [ebx+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1026@ProcessSpy@2

; 362  : 					{
; 363  : 						CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222911[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 364  : 						strMsg.Format("Re-eval: can't steal research, %d,", uiSpyIndex);

	mov	eax, DWORD PTR _uiSpyIndex$[esp+584]
	push	eax
	lea	ecx, DWORD PTR _strMsg$222911[esp+592]
	push	OFFSET $SG222912
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+608], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 365  : 						strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	eax, DWORD PTR $T267109[esp+592]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$222911[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 3
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267109[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 366  : 						LogEspionageMsg(strMsg);

	lea	ecx, DWORD PTR _strMsg$222911[esp+588]
	push	ecx
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 367  : 					}

	lea	ecx, DWORD PTR _strMsg$222911[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1026@ProcessSpy@2:

; 368  : 
; 369  : 				}
; 370  : 				UncoverIntrigue(uiSpyIndex);

	mov	edx, DWORD PTR _uiSpyIndex$[esp+584]
	push	edx
	mov	ecx, esi
	call	?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z ; CvPlayerEspionage::UncoverIntrigue

; 371  : 			}
; 372  : 		}
; 373  : 		break;

	jmp	$LN2@ProcessSpy@2
$LN61@ProcessSpy@2:

; 374  : 	case SPY_STATE_GATHERING_INTEL:
; 375  : 		CvAssertMsg(pCity, "pCity not defined. What?");
; 376  : 		if(!pCity)

	cmp	DWORD PTR _pCity$[esp+588], 0
	je	$LN1@ProcessSpy@2

; 377  : 		{
; 378  : 			return;
; 379  : 		}
; 380  : 		BuildStealableTechList(eCityOwner);

	mov	eax, DWORD PTR _eCityOwner$[esp+588]
	push	eax
	mov	ecx, esi
	call	?BuildStealableTechList@CvPlayerEspionage@@QAEXW4PlayerTypes@@@Z ; CvPlayerEspionage::BuildStealableTechList

; 381  : 		pCityEspionage->Process(ePlayer);

	mov	ecx, DWORD PTR [edi+ebp*4+180]
	add	DWORD PTR [edi+ebp*4+92], ecx

; 382  : 		// if the rate is too low, reassign the spy
; 383  : 		if (pCityEspionage->m_aiRate[m_pPlayer->GetID()] < 100)

	mov	edx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edx+44]
	cmp	DWORD PTR [edi+eax*4+180], 100		; 00000064H
	jge	$LN58@ProcessSpy@2

; 384  : 		{
; 385  : 			pSpy->m_bEvaluateReassignment = true;
; 386  : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [ebx+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN58@ProcessSpy@2

; 387  : 			{
; 388  : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222918[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 389  : 				strMsg.Format("Re-eval: potential too low, %d,", uiSpyIndex);

	mov	eax, DWORD PTR _uiSpyIndex$[esp+584]
	push	eax
	lea	ecx, DWORD PTR _strMsg$222918[esp+592]
	push	OFFSET $SG222919
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+608], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 390  : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	eax, DWORD PTR $T267110[esp+592]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$222918[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267110[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 391  : 				LogEspionageMsg(strMsg);

	lea	ecx, DWORD PTR _strMsg$222918[esp+588]
	push	ecx
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 392  : 			}

	lea	ecx, DWORD PTR _strMsg$222918[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN58@ProcessSpy@2:

; 393  : 		}
; 394  : 
; 395  : 		if(m_aaPlayerStealableTechList[eCityOwner].size() == 0)

	mov	eax, DWORD PTR _eCityOwner$[esp+588]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+264]
	cmp	DWORD PTR [eax+edx*4+4], 0
	jne	$LN57@ProcessSpy@2

; 396  : 		{
; 397  : 			// set the spy back to surveillance mode
; 398  : 			pCityEspionage->ResetProgress(ePlayer);

	or	eax, -1
	mov	DWORD PTR [edi+ebp*4+92], eax
	mov	DWORD PTR [edi+ebp*4+268], eax
	mov	DWORD PTR [edi+ebp*4+180], eax

; 399  : 			pSpy->m_eSpyState = SPY_STATE_SURVEILLANCE;
; 400  : 			pSpy->m_bEvaluateReassignment = true; // flag for reassignment
; 401  : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [ebx+16], 2
	mov	BYTE PTR [ebx+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN56@ProcessSpy@2

; 402  : 			{
; 403  : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222923[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 404  : 				strMsg.Format("Re-eval: m_aaPlayerStealableTechList[eCityOwner].size() == 0, %d,", uiSpyIndex);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+584]
	push	ecx
	lea	edx, DWORD PTR _strMsg$222923[esp+592]
	push	OFFSET $SG222924
	push	edx
	mov	DWORD PTR __$EHRec$[esp+608], 6
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 405  : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR $T267111[esp+592]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$222923[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 7
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267111[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 406  : 				LogEspionageMsg(strMsg);

	lea	edx, DWORD PTR _strMsg$222923[esp+588]
	push	edx
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 407  : 			}

	lea	ecx, DWORD PTR _strMsg$222923[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN56@ProcessSpy@2:

; 408  : 
; 409  : 			int iRate = CalcPerTurn(SPY_STATE_SURVEILLANCE, pCity, uiSpyIndex);
; 410  : 			int iGoal = CalcRequired(SPY_STATE_SURVEILLANCE, pCity, uiSpyIndex);

	mov	eax, DWORD PTR _pCity$[esp+588]
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [esi+1296]
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceSurveillanceTime@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceSurveillanceTime

; 411  : 			int iAmount = iGoal; // put the player back at surveillance levels
; 412  : 			pCityEspionage->SetActivity(ePlayer, iAmount, iRate, iGoal);

	push	eax
	push	1
	push	eax
	push	ebp
	mov	ecx, edi
	call	?SetActivity@CvCityEspionage@@QAEXW4PlayerTypes@@HHH@Z ; CvCityEspionage::SetActivity

; 413  : 
; 414  : 			// set last progress rate
; 415  : 			iRate = CalcPerTurn(SPY_STATE_GATHERING_INTEL, pCity, uiSpyIndex);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+584]
	mov	edx, DWORD PTR _pCity$[esp+588]
	push	ecx
	push	edx
	push	3
	mov	ecx, esi
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn

; 416  : 			pCityEspionage->SetLastProgress(ePlayer, iRate);
; 417  : 
; 418  : 			// can't steal any techs from this civ
; 419  : 			m_aiNumTechsToStealList[eCityOwner] = 0;

	mov	ecx, DWORD PTR _eCityOwner$[esp+588]
	mov	DWORD PTR [edi+ebp*4+356], eax
	mov	eax, DWORD PTR [esi+720]
	mov	DWORD PTR [eax+ecx*4], 0

; 420  : 
; 421  : 			CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$222929[esp+588], eax

; 422  : 			if(pNotifications)

	test	eax, eax
	je	$LN2@ProcessSpy@2

; 423  : 			{
; 424  : 				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH_S");

	lea	edx, DWORD PTR _strSummary$222931[esp+588]
	push	OFFSET $SG222933
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 425  : 				strSummary << GET_PLAYER(eCityOwner).getCivilizationInfo().getShortDescriptionKey();

	mov	edi, DWORD PTR _eCityOwner$[esp+588]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR __$EHRec$[esp+596], 8
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strSummary$222931[esp+592]
	call	ebp

; 426  : 				Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_CANT_STEAL_TECH");

	lea	ecx, DWORD PTR _strNotification$222935[esp+588]
	push	OFFSET $SG222937
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 427  : 				strNotification << GetSpyRankName(pSpy->m_eRank);;

	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+600], 9
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$222935[esp+592]
	call	ebp

; 428  : 				strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$222935[esp+592]
	call	ebp

; 429  : 				strNotification << GET_PLAYER(eCityOwner).getCivilizationInfo().getShortDescriptionKey();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$222935[esp+592]
	call	ebp

; 430  : 				pNotifications->Add(NOTIFICATION_SPY_CANT_STEAL_TECH, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$222931[esp+604]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _strNotification$222935[esp+608]
	call	edi
	mov	ecx, DWORD PTR _pNotifications$222929[esp+608]
	push	eax
	push	240697813				; 0e58c1d5H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 431  : 			}

	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$222935[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 8
	call	edi
	lea	ecx, DWORD PTR _strSummary$222931[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	edi

; 432  : 		}

	jmp	$LN2@ProcessSpy@2
$LN57@ProcessSpy@2:

; 433  : 		else if(pCityEspionage->HasReachedGoal(ePlayer))

	mov	edx, DWORD PTR [edi+ebp*4+92]
	cmp	edx, DWORD PTR [edi+ebp*4+268]
	jl	$LN2@ProcessSpy@2

; 434  : 		{
; 435  : 			HeistLocation kHeistLocation;
; 436  : 			kHeistLocation.m_iX = pCity->getX();

	mov	eax, DWORD PTR _pCity$[esp+588]
	mov	ecx, DWORD PTR [eax+96]

; 437  : 			kHeistLocation.m_iY = pCity->getY();

	mov	edx, DWORD PTR [eax+108]
	mov	DWORD PTR _kHeistLocation$222943[esp+588], ecx

; 438  : 			m_aHeistLocations[eCityOwner].push_back(kHeistLocation);

	mov	ecx, DWORD PTR _eCityOwner$[esp+588]
	add	ecx, 57					; 00000039H
	lea	eax, DWORD PTR _kHeistLocation$222943[esp+588]
	shl	ecx, 4
	push	eax
	add	ecx, esi
	mov	DWORD PTR _kHeistLocation$222943[esp+596], edx
	call	?push_back@?$vector@UHeistLocation@@V?$allocator@UHeistLocation@@@std@@@std@@QAEXABUHeistLocation@@@Z ; std::vector<HeistLocation,std::allocator<HeistLocation> >::push_back

; 439  : 
; 440  : 			int iSpyResult;
; 441  : 			if(pCityEspionage->HasCounterSpy())

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+84]
	cmp	DWORD PTR [edi+eax*4+4], -1

; 442  : 			{
; 443  : 				iSpyResult = GC.getGame().getJonRandNum(300, "Random roll for the result of a spy mission with a counterspy in the city");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	je	$LN52@ProcessSpy@2
	push	OFFSET $SG222946
	push	300					; 0000012cH
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 444  : 				int iCounterspyIndex = GET_PLAYER(eCityOwner).GetEspionage()->GetSpyIndexInCity(pCity);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _iSpyResult$222944[esp+588], eax
	mov	eax, DWORD PTR _eCityOwner$[esp+588]
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv3830[esp+588], eax
	lea	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR _pCity$[esp+588]
	push	eax
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?GetSpyIndexInCity@CvPlayerEspionage@@QAEHPAVCvCity@@@Z ; CvPlayerEspionage::GetSpyIndexInCity

; 445  : 				iSpyResult += GET_PLAYER(eCityOwner).GetEspionage()->m_aSpyList[iCounterspyIndex].m_eRank * 30;

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv3830[esp+588]
	add	ecx, edx
	mov	DWORD PTR _iCounterspyIndex$222947[esp+588], eax
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, DWORD PTR _iCounterspyIndex$222947[esp+588]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	mov	eax, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR _iSpyResult$222944[esp+588]
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*2]

; 446  : 				iSpyResult *= (100 + GET_PLAYER(pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CATCH_SPIES_MODIFIER));

	mov	ecx, DWORD PTR _pCity$[esp+588]
	mov	DWORD PTR _iSpyResult$222944[esp+588], eax
	mov	eax, DWORD PTR [ecx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	21					; 00000015H
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, DWORD PTR _iSpyResult$222944[esp+588]

; 447  : 				iSpyResult /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 448  : 				if(iSpyResult < 100)

	cmp	eax, 100				; 00000064H
	jge	SHORT $LN51@ProcessSpy@2

; 449  : 				{
; 450  : 					pCityEspionage->SetSpyResult(ePlayer, SPY_RESULT_DETECTED);

	mov	DWORD PTR [edi+ebp*4+620], 1
	jmp	$LN780@ProcessSpy@2
$LN51@ProcessSpy@2:

; 451  : 				}
; 452  : 				else if(iSpyResult < 200)

	cmp	eax, 200				; 000000c8H

; 453  : 				{
; 454  : 					pCityEspionage->SetSpyResult(ePlayer, SPY_RESULT_IDENTIFIED);
; 455  : 				}
; 456  : 				else

	jl	$LN41@ProcessSpy@2

; 457  : 				{
; 458  : 					pCityEspionage->SetSpyResult(ePlayer, SPY_RESULT_KILLED);
; 459  : 
; 460  : 					CvPlayerAI& kCityOwner = GET_PLAYER(eCityOwner);

	mov	eax, DWORD PTR tv3830[esp+588]
	mov	DWORD PTR [edi+ebp*4+620], 3
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx]

; 461  : 					CvPlayerAI& kSpyOwner = GET_PLAYER(ePlayer);

	mov	eax, ebp
	imul	eax, 63236				; 0000f704H
	add	eax, edx
	mov	DWORD PTR _kSpyOwner$222953[esp+588], eax

; 462  : 
; 463  : 					if(	strcmp(kCityOwner.getCivilizationTypeKey(), "CIVILIZATION_RUSSIA") == 0 &&
; 464  : 						strcmp(kSpyOwner.getCivilizationTypeKey(), "CIVILIZATION_ENGLAND") == 0)

	mov	DWORD PTR tv4587[esp+588], OFFSET $SG222955
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	edx, DWORD PTR tv4587[esp+588]
$LL1018@ProcessSpy@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN1019@ProcessSpy@2
	test	cl, cl
	je	SHORT $LN1020@ProcessSpy@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN1019@ProcessSpy@2
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL1018@ProcessSpy@2
$LN1020@ProcessSpy@2:
	xor	eax, eax
	jmp	SHORT $LN1021@ProcessSpy@2
$LN1019@ProcessSpy@2:
	sbb	eax, eax
	sbb	eax, -1
$LN1021@ProcessSpy@2:
	test	eax, eax
	jne	$LN780@ProcessSpy@2
	mov	ecx, DWORD PTR _kSpyOwner$222953[esp+588]
	mov	DWORD PTR tv4568[esp+588], OFFSET $SG222956
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	edx, DWORD PTR tv4568[esp+588]
$LL1022@ProcessSpy@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN1023@ProcessSpy@2
	test	cl, cl
	je	SHORT $LN1024@ProcessSpy@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN1023@ProcessSpy@2
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL1022@ProcessSpy@2
$LN1024@ProcessSpy@2:
	xor	eax, eax
	jmp	SHORT $LN1025@ProcessSpy@2
$LN1023@ProcessSpy@2:
	sbb	eax, eax
	sbb	eax, -1
$LN1025@ProcessSpy@2:
	test	eax, eax
	jne	$LN780@ProcessSpy@2

; 465  : 					{
; 466  : 						//Do not trigger achievement if we're in the Smokey Skies scenario.
; 467  : 						bool bUsingXP1Scenario3 = gDLL->IsModActivated(CIV5_XP1_SCENARIO3_MODID);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	push	OFFSET $SG92492
	call	eax

; 468  : 						if(!bUsingXP1Scenario3)

	test	al, al
	jne	$LN780@ProcessSpy@2

; 469  : 						{
; 470  : 							if(eCityOwner == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _eCityOwner$[esp+588], eax
	jne	$LN780@ProcessSpy@2

; 471  : 								gDLL->UnlockAchievement(ACHIEVEMENT_XP1_25);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	215					; 000000d7H
	call	eax

; 472  : 						}
; 473  : 					}
; 474  : 				}
; 475  : 			}
; 476  : 			else

	jmp	$LN780@ProcessSpy@2
$LN52@ProcessSpy@2:

; 477  : 			{
; 478  : 				iSpyResult = GC.getGame().getJonRandNum(300, "Random roll for the result of a spying mission without a counterspy in the city");

	push	OFFSET $SG222961
	push	300					; 0000012cH
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 479  : 				iSpyResult *= (100 + GET_PLAYER(pCity->getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CATCH_SPIES_MODIFIER));

	mov	ecx, DWORD PTR _pCity$[esp+588]
	mov	DWORD PTR _iSpyResult$222944[esp+588], eax
	mov	eax, DWORD PTR [ecx+84]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	21					; 00000015H
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, DWORD PTR _iSpyResult$222944[esp+588]

; 480  : 				iSpyResult /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 481  : 				if(iSpyResult < 100)

	cmp	eax, 100				; 00000064H
	jge	SHORT $LN43@ProcessSpy@2

; 482  : 				{
; 483  : 					pCityEspionage->SetSpyResult(ePlayer, SPY_RESULT_UNDETECTED);

	mov	DWORD PTR [edi+ebp*4+620], 0
	jmp	SHORT $LN780@ProcessSpy@2
$LN43@ProcessSpy@2:

; 484  : 				}
; 485  : 				else if(iSpyResult < 200)

	cmp	eax, 200				; 000000c8H
	jge	SHORT $LN41@ProcessSpy@2

; 486  : 				{
; 487  : 					pCityEspionage->SetSpyResult(ePlayer, SPY_RESULT_DETECTED);

	mov	DWORD PTR [edi+ebp*4+620], 1

; 488  : 				}
; 489  : 				else

	jmp	SHORT $LN780@ProcessSpy@2
$LN41@ProcessSpy@2:

; 490  : 				{
; 491  : 					pCityEspionage->SetSpyResult(ePlayer, SPY_RESULT_IDENTIFIED);

	mov	DWORD PTR [edi+ebp*4+620], 2
$LN780@ProcessSpy@2:

; 492  : 				}
; 493  : 			}
; 494  : 
; 495  : 			CvPlayerEspionage* pDefendingPlayerEspionage = GET_PLAYER(eCityOwner).GetEspionage();

	mov	eax, DWORD PTR _eCityOwner$[esp+588]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	lea	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv3830[esp+588], eax
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	DWORD PTR _pDefendingPlayerEspionage$222966[esp+588], eax

; 496  : 			CvAssertMsg(pDefendingPlayerEspionage, "Defending player espionage is null");
; 497  : 			if(pDefendingPlayerEspionage)

	test	eax, eax
	je	SHORT $LN39@ProcessSpy@2

; 498  : 			{
; 499  : 				pDefendingPlayerEspionage->AddSpyMessage(pCity->getX(), pCity->getY(), m_pPlayer->GetID(), pCityEspionage->m_aiResult[ePlayer], NO_TECH);

	mov	edx, DWORD PTR _pCity$[esp+588]
	mov	ecx, DWORD PTR [edx+108]
	mov	edx, DWORD PTR [edx+96]
	mov	eax, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [eax+44]
	push	-1
	mov	DWORD PTR $T268739[esp+592], edx
	mov	edx, DWORD PTR [edi+ebp*4+620]
	push	edx
	push	eax
	mov	eax, DWORD PTR $T268739[esp+600]
	push	ecx
	mov	ecx, DWORD PTR _pDefendingPlayerEspionage$222966[esp+604]
	push	eax
	call	?AddSpyMessage@CvPlayerEspionage@@QAEXHHW4PlayerTypes@@HW4TechTypes@@@Z ; CvPlayerEspionage::AddSpyMessage
$LN39@ProcessSpy@2:

; 500  : 			}
; 501  : 
; 502  : 			CvDiplomacyAI* pDefendingPlayerDiploAI = GET_PLAYER(eCityOwner).GetDiplomacyAI();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv3830[esp+588]
	add	ecx, edx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI

; 503  : 			CvAssertMsg(pDefendingPlayerDiploAI, "Defending player diplo AI is null");
; 504  : 			if(pDefendingPlayerDiploAI)

	test	eax, eax
	je	SHORT $LN1027@ProcessSpy@2

; 505  : 			{
; 506  : 				if(pCityEspionage->m_aiResult[ePlayer] == SPY_RESULT_IDENTIFIED || pCityEspionage->m_aiResult[ePlayer] == SPY_RESULT_KILLED)

	mov	edx, DWORD PTR [edi+ebp*4+620]
	cmp	edx, 2
	je	SHORT $LN36@ProcessSpy@2
	cmp	edx, 3
	jne	SHORT $LN1027@ProcessSpy@2
$LN36@ProcessSpy@2:

; 507  : 				{
; 508  : 					pDefendingPlayerDiploAI->ChangeNumTimesRobbedBy(ePlayer, 1);

	push	1
	push	ebp
	mov	ecx, eax
	call	?ChangeNumTimesRobbedBy@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeNumTimesRobbedBy
$LN1027@ProcessSpy@2:

; 509  : 				}
; 510  : 			}
; 511  : 
; 512  : 			// spy killed in action
; 513  : 			if(pCityEspionage->m_aiResult[ePlayer] == SPY_RESULT_KILLED)

	cmp	DWORD PTR [edi+ebp*4+620], 3
	jne	$LN35@ProcessSpy@2

; 514  : 			{
; 515  : 				CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$222973[esp+588], eax

; 516  : 				if(pNotifications)

	test	eax, eax
	je	$LN1028@ProcessSpy@2

; 517  : 				{
; 518  : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_WAS_KILLED_S");

	lea	eax, DWORD PTR _strSummary$222975[esp+588]
	push	OFFSET $SG222977
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 519  : 					strSummary << m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName);

	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, DWORD PTR [esi+1296]
	mov	DWORD PTR __$EHRec$[esp+600], 10	; 0000000aH
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	mov	ebp, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strSummary$222975[esp+592]
	call	ebp

; 520  : 					Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_WAS_KILLED");

	lea	edx, DWORD PTR _strNotification$222979[esp+588]
	push	OFFSET $SG222981
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 521  : 					strNotification << GetSpyRankName(pSpy->m_eRank);

	mov	eax, DWORD PTR [ebx+12]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+600], 11		; 0000000bH
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$222979[esp+592]
	call	ebp

; 522  : 					strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName);

	mov	ecx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, DWORD PTR [esi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$222979[esp+592]
	call	ebp

; 523  : 					strNotification << GET_PLAYER(eCityOwner).getCivilizationInfo().getShortDescriptionKey();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv3830[esp+588]
	lea	ecx, DWORD PTR [eax+edx]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$222979[esp+592]
	call	ebp

; 524  : 					strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+588]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$222979[esp+592]
	call	ebp

; 525  : 					pNotifications->Add(NOTIFICATION_SPY_WAS_KILLED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	ebp, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$222975[esp+604]
	call	ebp
	push	eax
	lea	ecx, DWORD PTR _strNotification$222979[esp+608]
	call	ebp
	mov	ecx, DWORD PTR _pNotifications$222973[esp+608]
	push	eax
	push	345927241				; 149e6e49H
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 526  : 
; 527  : 				}

	mov	ebp, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$222979[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 10		; 0000000aH
	call	ebp
	lea	ecx, DWORD PTR _strSummary$222975[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	ebp
$LN1028@ProcessSpy@2:

; 528  : 
; 529  : 				CvEspionageAI* pEspionageAI = m_pPlayer->GetEspionageAI();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	mov	DWORD PTR _pEspionageAI$222986[esp+588], eax

; 530  : 				CvAssertMsg(pEspionageAI, "pEspionageAI is null");
; 531  : 				if(pEspionageAI)

	test	eax, eax
	je	SHORT $LN1029@ProcessSpy@2

; 532  : 				{
; 533  : 					pEspionageAI->m_aiTurnLastSpyDied[eCityOwner] = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR _eCityOwner$[esp+588]
	mov	ebp, DWORD PTR [eax+628]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv3982[esp+588], ecx
	add	ebp, ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 534  : 					pEspionageAI->m_aiNumSpiesDied[eCityOwner]++;

	mov	ecx, DWORD PTR _pEspionageAI$222986[esp+588]
	mov	DWORD PTR [ebp], eax
	mov	edx, DWORD PTR [ecx+316]
	mov	eax, DWORD PTR tv3982[esp+588]
	add	eax, edx
	inc	DWORD PTR [eax]
$LN1029@ProcessSpy@2:

; 535  : 				}
; 536  : 				CvEspionageAI* pDefenderEspionageAI = GET_PLAYER(eCityOwner).GetEspionageAI();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv3830[esp+588]
	add	ecx, edx
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	mov	ebp, eax

; 537  : 				CvAssertMsg(pDefenderEspionageAI, "pDefenderEspionageAI is null");
; 538  : 				if(pDefenderEspionageAI)

	test	ebp, ebp
	je	SHORT $LN32@ProcessSpy@2

; 539  : 				{
; 540  : 					pDefenderEspionageAI->m_aiTurnLastSpyKilled[m_pPlayer->GetID()] = GC.getGame().getGameTurn();

	mov	eax, DWORD PTR [esi+1296]
	mov	ecx, DWORD PTR [ebp+524]
	mov	eax, DWORD PTR [eax+44]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T268803[esp+588], edx
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T268803[esp+588]
	mov	DWORD PTR [ecx], eax

; 541  : 					pDefenderEspionageAI->m_aiNumSpiesKilled[m_pPlayer->GetID()]++;

	mov	edx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ebp+212]
	inc	DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
$LN32@ProcessSpy@2:

; 542  : 				}
; 543  : 
; 544  : 				// level up the defending spy
; 545  : 				int iDefendingSpy = pCityEspionage->m_aiSpyAssignment[eCityOwner];
; 546  : 				if(pDefendingPlayerEspionage)

	mov	ecx, DWORD PTR _pDefendingPlayerEspionage$222966[esp+588]
	mov	edx, DWORD PTR _eCityOwner$[esp+588]
	mov	edi, DWORD PTR [edi+edx*4+4]
	test	ecx, ecx
	je	SHORT $LN30@ProcessSpy@2

; 547  : 				{
; 548  : 					CvAssertMsg(iDefendingSpy >= 0, "No defending spy. This is ok if debugging and killing a spy without having a defending spy present, but should not occur when playing the game normally.");
; 549  : 					if(iDefendingSpy >= 0)

	test	edi, edi
	jl	SHORT $LN30@ProcessSpy@2

; 550  : 					{
; 551  : 						pDefendingPlayerEspionage->LevelUpSpy(iDefendingSpy);

	push	edi
	call	?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z	; CvPlayerEspionage::LevelUpSpy
$LN30@ProcessSpy@2:

; 552  : 					}
; 553  : 				}
; 554  : 
; 555  : 				// kill spy off
; 556  : 				ExtractSpyFromCity(uiSpyIndex); // move the dead body out so that someone else can move in

	mov	edi, DWORD PTR _uiSpyIndex$[esp+584]
	push	edi
	mov	ecx, esi
	call	?ExtractSpyFromCity@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::ExtractSpyFromCity

; 557  : 				pSpy->m_eSpyState = SPY_STATE_DEAD; // have to official kill him after the extraction
; 558  : 
; 559  : 				if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [ebx+16], 8
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1030@ProcessSpy@2

; 560  : 				{
; 561  : 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$222994[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 562  : 					strMsg.Format("Killed, %d,", uiSpyIndex);

	push	edi
	lea	eax, DWORD PTR _strMsg$222994[esp+592]
	push	OFFSET $SG222995
	push	eax
	mov	DWORD PTR __$EHRec$[esp+608], 12	; 0000000cH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 563  : 					strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName));

	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR tv3648[esp+600]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR [esi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	edx, DWORD PTR $T267121[esp+592]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 13		; 0000000dH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267121[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 12		; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 564  : 					strMsg += ",";

	push	OFFSET $SG222997
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 565  : 					strMsg += ",";

	push	OFFSET $SG222998
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 566  : 					strMsg += ",";

	push	OFFSET $SG222999
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 567  : 					strMsg += GET_PLAYER(eCityOwner).getCivilizationShortDescription();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv3830[esp+588]
	add	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 568  : 					strMsg += ",";

	push	OFFSET $SG223000
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 569  : 					strMsg += pCity->getName();

	mov	ecx, DWORD PTR _pCity$[esp+588]
	lea	edx, DWORD PTR $T267122[esp+588]
	push	edx
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 14		; 0000000eH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267122[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 12		; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 570  : 					strMsg += ",";

	push	OFFSET $SG223002
	lea	ecx, DWORD PTR _strMsg$222994[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 571  : 					strMsg += "Killed";

	push	OFFSET $SG223003

; 572  : 					LogEspionageMsg(strMsg);
; 573  : 				}
; 574  : 			}
; 575  : 			else // spy successfully completed mission

	jmp	$LN1034@ProcessSpy@2
$LN35@ProcessSpy@2:

; 576  : 			{
; 577  : 				pSpy->m_bEvaluateReassignment = true; // flag spy for reassignment
; 578  : 				if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [ebx+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN27@ProcessSpy@2

; 579  : 				{
; 580  : 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223006[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 581  : 					strMsg.Format("Re-eval: spy completed mission, %d,", uiSpyIndex);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+584]
	push	ecx
	lea	edx, DWORD PTR _strMsg$223006[esp+592]
	push	OFFSET $SG223007
	push	edx
	mov	DWORD PTR __$EHRec$[esp+608], 15	; 0000000fH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 582  : 					strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR $T267123[esp+592]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$223006[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 16		; 00000010H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267123[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 583  : 					LogEspionageMsg(strMsg);

	lea	edx, DWORD PTR _strMsg$223006[esp+588]
	push	edx
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 584  : 				}

	lea	ecx, DWORD PTR _strMsg$223006[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN27@ProcessSpy@2:

; 585  : 				int iCityOwner = (int)eCityOwner;
; 586  : 				m_aiNumTechsToStealList[iCityOwner] = m_aiNumTechsToStealList[iCityOwner] + 1;

	mov	eax, DWORD PTR [esi+720]
	mov	ecx, DWORD PTR _eCityOwner$[esp+588]
	inc	DWORD PTR [eax+ecx*4]

; 587  : 				pCityEspionage->ResetProgress(ePlayer);
; 588  : 				int iRate = CalcPerTurn(SPY_STATE_GATHERING_INTEL, pCity, uiSpyIndex);

	mov	edx, DWORD PTR _uiSpyIndex$[esp+584]
	lea	eax, DWORD PTR [eax+ecx*4]
	or	eax, -1
	mov	DWORD PTR [edi+ebp*4+92], eax
	mov	DWORD PTR [edi+ebp*4+268], eax
	mov	DWORD PTR [edi+ebp*4+180], eax
	mov	eax, DWORD PTR _pCity$[esp+588]
	push	edx
	push	eax
	push	3
	mov	ecx, esi
	call	?CalcPerTurn@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcPerTurn

; 589  : 				int iGoal = CalcRequired(SPY_STATE_GATHERING_INTEL, pCity, uiSpyIndex);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+584]
	mov	edx, DWORD PTR _pCity$[esp+588]
	push	ecx
	push	edx
	push	3
	mov	ecx, esi
	mov	DWORD PTR _iRate$223011[esp+600], eax
	call	?CalcRequired@CvPlayerEspionage@@QAEHHPAVCvCity@@H@Z ; CvPlayerEspionage::CalcRequired

; 590  : 				pCityEspionage->SetActivity(ePlayer, 0, iRate, iGoal);

	mov	ecx, DWORD PTR _iRate$223011[esp+588]
	mov	DWORD PTR [edi+ebp*4+268], eax

; 591  : 				pCityEspionage->SetLastProgress(ePlayer, iRate);
; 592  : 				pCityEspionage->m_aiNumTimesCityRobbed[eCityOwner]++;

	mov	eax, DWORD PTR _eCityOwner$[esp+588]
	mov	DWORD PTR [edi+ebp*4+92], 0
	mov	DWORD PTR [edi+ebp*4+180], ecx
	mov	DWORD PTR [edi+ebp*4+356], ecx
	inc	DWORD PTR [edi+eax*4+708]

; 593  : 
; 594  : 				if(pCityEspionage->m_aiResult[ePlayer] == SPY_RESULT_IDENTIFIED)

	cmp	DWORD PTR [edi+ebp*4+620], 2
	jne	SHORT $LN25@ProcessSpy@2

; 595  : 				{
; 596  : 					CvEspionageAI* pDefenderEspionageAI = GET_PLAYER(eCityOwner).GetEspionageAI();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv3830[esp+588]
	add	ecx, eax
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	mov	DWORD PTR _pDefenderEspionageAI$223014[esp+588], eax

; 597  : 					CvAssertMsg(pDefenderEspionageAI, "pDefenderEspionageAI is null");
; 598  : 					if(pDefenderEspionageAI)

	test	eax, eax
	je	SHORT $LN25@ProcessSpy@2

; 599  : 					{
; 600  : 						pDefenderEspionageAI->m_aiTurnLastSpyCaught[m_pPlayer->GetID()] = GC.getGame().getGameTurn();

	mov	edx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _pDefenderEspionageAI$223014[esp+588]
	mov	edx, DWORD PTR [ecx+420]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T268931[esp+588], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T268931[esp+588]
	mov	DWORD PTR [ecx], eax

; 601  : 						pDefenderEspionageAI->m_aiNumSpiesCaught[m_pPlayer->GetID()]++;

	mov	edx, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _pDefenderEspionageAI$223014[esp+588]
	mov	edx, DWORD PTR [ecx+108]
	inc	DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]
$LN25@ProcessSpy@2:

; 602  : 					}
; 603  : 				}
; 604  : 
; 605  : 				// this check was added because m_aiNumTechsToStealList was getting out of whack somehow and this is a check to prevent the UI from going haywire
; 606  : 				CvAssertMsg(m_aiNumTechsToStealList[iCityOwner] > 0, "m_aiNumTechsToStealList[iCityOwner] <= 0, which shouldn't happen after you succeed at stealing");
; 607  : 				if (m_aiNumTechsToStealList[iCityOwner] > 0)

	mov	eax, DWORD PTR [esi+720]
	mov	ecx, DWORD PTR _eCityOwner$[esp+588]
	cmp	DWORD PTR [eax+ecx*4], 0
	lea	eax, DWORD PTR [eax+ecx*4]
	jle	$LN24@ProcessSpy@2

; 608  : 				{
; 609  : 					CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$223017[esp+588], eax

; 610  : 					if(pNotifications)

	test	eax, eax
	je	$LN22@ProcessSpy@2

; 611  : 					{
; 612  : 						Localization::String strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_STEAL_TECH_S");

	lea	edx, DWORD PTR $T267124[esp+588]
	push	OFFSET $SG223021
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+596], 17	; 00000011H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strSummary$223019[esp+592]
	call	DWORD PTR __imp_??0String@Localization@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T267124[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 19		; 00000013H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 613  : 						Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_STEAL_TECH");

	lea	eax, DWORD PTR _strNotification$223022[esp+588]
	push	OFFSET $SG223024
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 614  : 						strNotification << GetSpyRankName(pSpy->m_eRank);

	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+600], 20		; 00000014H
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	push	eax
	lea	ecx, DWORD PTR _strNotification$223022[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 615  : 						strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223022[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 616  : 						strNotification << pCity->getNameKey();

	mov	ecx, DWORD PTR _pCity$[esp+588]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223022[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 617  : 						strNotification << GET_PLAYER(eCityOwner).getCivilizationInfo().getShortDescriptionKey();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv3830[esp+588]
	add	ecx, eax
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
	push	eax
	lea	ecx, DWORD PTR _strNotification$223022[esp+592]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 618  : 						pNotifications->Add(NOTIFICATION_SPY_STOLE_TECH, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, eCityOwner);

	mov	edx, DWORD PTR _eCityOwner$[esp+588]
	push	-1
	push	edx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223019[esp+604]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strNotification$223022[esp+608]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	ecx, DWORD PTR _pNotifications$223017[esp+608]
	push	eax
	push	-1774532806				; 963ac73aH
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 619  : 					}

	lea	ecx, DWORD PTR _strNotification$223022[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 19		; 00000013H
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$223019[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 620  : 				}
; 621  : 				else

	jmp	SHORT $LN22@ProcessSpy@2
$LN24@ProcessSpy@2:

; 622  : 				{
; 623  : 					m_aiNumTechsToStealList[iCityOwner] = 0;

	mov	DWORD PTR [eax], 0
$LN22@ProcessSpy@2:

; 624  : 				}
; 625  : 
; 626  : 				//Achievements!
; 627  : 				if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR [esi+1296]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T268983[esp+588], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T268983[esp+588], eax
	jne	SHORT $LN21@ProcessSpy@2

; 628  : 				{
; 629  : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_12);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	202					; 000000caH
	call	eax
$LN21@ProcessSpy@2:

; 630  : 				}
; 631  : 
; 632  : 				LevelUpSpy(uiSpyIndex);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+584]
	push	ecx
	mov	ecx, esi
	call	?LevelUpSpy@CvPlayerEspionage@@QAEXI@Z	; CvPlayerEspionage::LevelUpSpy

; 633  : 
; 634  : 				if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1030@ProcessSpy@2

; 635  : 				{
; 636  : 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223032[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 637  : 					strMsg.Format("Stealing tech, %d,", uiSpyIndex);

	mov	edx, DWORD PTR _uiSpyIndex$[esp+584]
	push	edx
	lea	eax, DWORD PTR _strMsg$223032[esp+592]
	push	OFFSET $SG223033
	push	eax
	mov	DWORD PTR __$EHRec$[esp+608], 21	; 00000015H
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 638  : 					strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(m_aSpyList[uiSpyIndex].m_iName));

	mov	eax, DWORD PTR [esi+4]
	add	eax, DWORD PTR tv3648[esp+600]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR [esi+1296]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	edx, DWORD PTR $T267129[esp+592]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 22		; 00000016H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267129[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 21		; 00000015H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 639  : 					strMsg += ",";

	push	OFFSET $SG223035
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 640  : 					strMsg += ",";

	push	OFFSET $SG223036
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 641  : 					strMsg += ",";

	push	OFFSET $SG223037
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 642  : 					strMsg += GET_PLAYER(eCityOwner).getCivilizationShortDescription();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv3830[esp+588]
	add	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 643  : 					strMsg += ",";

	push	OFFSET $SG223038
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 644  : 					strMsg += pCity->getName();

	mov	ecx, DWORD PTR _pCity$[esp+588]
	lea	edx, DWORD PTR $T267130[esp+588]
	push	edx
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 23		; 00000017H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267130[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 21		; 00000015H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 645  : 					strMsg += ",";

	push	OFFSET $SG223040
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 646  : 					switch(pCityEspionage->m_aiResult[ePlayer])

	mov	edi, DWORD PTR [edi+ebp*4+620]
	sub	edi, 0
	je	SHORT $LN17@ProcessSpy@2
	sub	edi, 1
	je	SHORT $LN16@ProcessSpy@2
	sub	edi, 1
	jne	SHORT $LN18@ProcessSpy@2

; 654  : 					case SPY_RESULT_IDENTIFIED:
; 655  : 						strMsg += "Identified";

	push	OFFSET $SG223050

; 656  : 						break;

	jmp	SHORT $LN1034@ProcessSpy@2
$LN16@ProcessSpy@2:

; 650  : 						break;
; 651  : 					case SPY_RESULT_DETECTED:
; 652  : 						strMsg += "Detected";

	push	OFFSET $SG223048

; 653  : 						break;

	jmp	SHORT $LN1034@ProcessSpy@2
$LN17@ProcessSpy@2:

; 647  : 					{
; 648  : 					case SPY_RESULT_UNDETECTED:
; 649  : 						strMsg += "Undetected";

	push	OFFSET $SG223046
$LN1034@ProcessSpy@2:
	lea	ecx, DWORD PTR _strMsg$223032[esp+592]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN18@ProcessSpy@2:

; 657  : 					}
; 658  : 					LogEspionageMsg(strMsg);

	lea	eax, DWORD PTR _strMsg$223032[esp+588]
	push	eax
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 659  : 				}

	lea	ecx, DWORD PTR _strMsg$223032[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1030@ProcessSpy@2:

; 660  : 			}
; 661  : 			if(pSpy->m_eSpyState != SPY_STATE_DEAD)

	cmp	DWORD PTR [ebx+16], 8
	je	$LN2@ProcessSpy@2

; 662  : 			{
; 663  : 				UncoverIntrigue(uiSpyIndex);

	mov	ecx, DWORD PTR _uiSpyIndex$[esp+584]
	push	ecx
	mov	ecx, esi
	call	?UncoverIntrigue@CvPlayerEspionage@@QAEXI@Z ; CvPlayerEspionage::UncoverIntrigue

; 664  : 			}
; 665  : 		}
; 666  : 		break;

	jmp	$LN2@ProcessSpy@2
$LN13@ProcessSpy@2:

; 667  : 	case SPY_STATE_RIG_ELECTION:
; 668  : 		// resetting the value is done in MinorCivAI
; 669  : 		pCityEspionage->Process(ePlayer);

	mov	edx, DWORD PTR [edi+ebp*4+180]
	add	DWORD PTR [edi+ebp*4+92], edx

; 670  : 		break;

	jmp	$LN2@ProcessSpy@2
$LN11@ProcessSpy@2:

; 671  : 	case SPY_STATE_COUNTER_INTEL:
; 672  : 		break;
; 673  : 	case SPY_STATE_MAKING_INTRODUCTIONS:
; 674  : 		// spy is traveling to location
; 675  : 		CvAssertMsg(pCity, "pCity not defined. What?");
; 676  : 		if(!pCity)

	cmp	DWORD PTR _pCity$[esp+588], 0
	je	$LN1@ProcessSpy@2

; 677  : 		{
; 678  : 			return;
; 679  : 		}
; 680  : 		// if the spy has completed travelling, move to location
; 681  : 		pCityEspionage->Process(ePlayer);

	mov	eax, DWORD PTR [edi+ebp*4+180]
	add	DWORD PTR [edi+ebp*4+92], eax

; 682  : 		if(pCityEspionage->HasReachedGoal(ePlayer))

	mov	ecx, DWORD PTR [edi+ebp*4+92]
	cmp	ecx, DWORD PTR [edi+ebp*4+268]
	jl	$LN2@ProcessSpy@2

; 683  : 		{
; 684  : 			pCityEspionage->ResetProgress(ePlayer);

	or	eax, -1
	mov	DWORD PTR [edi+ebp*4+92], eax
	mov	DWORD PTR [edi+ebp*4+268], eax
	mov	DWORD PTR [edi+ebp*4+180], eax

; 685  : 			pSpy->m_eSpyState = SPY_STATE_SCHMOOZE;

	mov	DWORD PTR [ebx+16], 7

; 686  : 		}
; 687  : 		break;

	jmp	$LN2@ProcessSpy@2
$LN6@ProcessSpy@2:

; 688  : 	case SPY_STATE_SCHMOOZE:
; 689  : 		if(pSpy->m_eSpyState != SPY_STATE_DEAD)
; 690  : 		{
; 691  : 			UncoverIntrigue(uiSpyIndex);
; 692  : 		}
; 693  : 		break;
; 694  : 	case SPY_STATE_DEAD:
; 695  : 		pSpy->m_iReviveCounter++;

	inc	DWORD PTR [ebx+20]

; 696  : 		if(pSpy->m_iReviveCounter >= iSpyTurnsToRevive)

	cmp	DWORD PTR [ebx+20], 5
	jl	$LN2@ProcessSpy@2

; 697  : 		{
; 698  : 			pSpy->m_iName = GetNextSpyName();

	mov	ecx, esi
	call	?GetNextSpyName@CvPlayerEspionage@@QAEHXZ ; CvPlayerEspionage::GetNextSpyName
	mov	DWORD PTR [ebx], eax

; 699  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 700  : 			pSpy->m_eRank = (CvSpyRank)m_pPlayer->getCachedSpyStartingRank();
; 701  : #else
; 702  : 			pSpy->m_eRank = (CvSpyRank)m_pPlayer->GetStartingSpyRank();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetStartingSpyRank@CvPlayer@@QBEHXZ	; CvPlayer::GetStartingSpyRank
	mov	DWORD PTR [ebx+12], eax

; 703  : #endif
; 704  : 			pSpy->m_eSpyState = SPY_STATE_UNASSIGNED;

	xor	eax, eax

; 705  : 			pSpy->m_iCityX = -1;

	or	edi, -1

; 706  : 			pSpy->m_iCityY = -1;
; 707  : 			pSpy->m_iReviveCounter = 0;
; 708  : 			pSpy->m_bEvaluateReassignment = true;
; 709  : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR [ebx+4], edi
	mov	DWORD PTR [ebx+8], edi
	mov	DWORD PTR [ebx+20], eax
	mov	BYTE PTR [ebx+25], 1
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1031@ProcessSpy@2

; 710  : 			{
; 711  : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223063[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 712  : 				strMsg.Format("Re-eval: spy killed, %d,", uiSpyIndex);

	mov	eax, DWORD PTR _uiSpyIndex$[esp+584]
	push	eax
	lea	ecx, DWORD PTR _strMsg$223063[esp+592]
	push	OFFSET $SG223064
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+608], 24	; 00000018H
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 713  : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	eax, DWORD PTR $T267131[esp+592]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$223063[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 25		; 00000019H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267131[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 24		; 00000018H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 714  : 				LogEspionageMsg(strMsg);

	lea	ecx, DWORD PTR _strMsg$223063[esp+588]
	push	ecx
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 715  : 			}

	lea	ecx, DWORD PTR _strMsg$223063[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1031@ProcessSpy@2:

; 716  : 
; 717  : 			CvNotifications* pNotifications = m_pPlayer->GetNotifications();

	mov	ecx, DWORD PTR [esi+1296]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 718  : 			if(pNotifications)

	test	ebp, ebp
	je	$LN3@ProcessSpy@2

; 719  : 			{
; 720  : 				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_REVIVED_S");

	mov	edi, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	edx, DWORD PTR _strSummary$223068[esp+588]
	push	OFFSET $SG223070
	push	edx
	call	edi

; 721  : 				Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_REVIVED");

	lea	eax, DWORD PTR _strNotification$223071[esp+596]
	push	OFFSET $SG223073
	push	eax
	mov	DWORD PTR __$EHRec$[esp+612], 26	; 0000001aH
	call	edi
	add	esp, 16					; 00000010H

; 722  : 				strNotification << GetSpyRankName(pSpy->m_eRank);

	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+600], 27		; 0000001bH
	call	?GetSpyRankName@CvPlayerEspionage@@QBEPBDH@Z ; CvPlayerEspionage::GetSpyRankName
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strNotification$223071[esp+592]
	call	edi

; 723  : 				strNotification << m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	ecx, DWORD PTR _strNotification$223071[esp+592]
	call	edi

; 724  : 				pNotifications->Add(NOTIFICATION_SPY_REPLACEMENT, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	mov	edi, DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$223068[esp+604]
	call	edi
	push	eax
	lea	ecx, DWORD PTR _strNotification$223071[esp+608]
	call	edi
	push	eax
	push	-1698732748				; 9abf6534H
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 725  : 			}

	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strNotification$223071[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 26		; 0000001aH
	call	edi
	lea	ecx, DWORD PTR _strSummary$223068[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], -1
	call	edi
	or	edi, -1
$LN3@ProcessSpy@2:

; 726  : 
; 727  : 			if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@ProcessSpy@2

; 728  : 			{
; 729  : 				CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$223077[esp+588]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 730  : 				strMsg.Format("Respawned spy, %d,", uiSpyIndex);

	mov	eax, DWORD PTR _uiSpyIndex$[esp+584]
	push	eax
	lea	ecx, DWORD PTR _strMsg$223077[esp+592]
	push	OFFSET $SG223078
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+608], 28	; 0000001cH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 731  : 				strMsg += GetLocalizedText(m_pPlayer->getCivilizationInfo().getSpyNames(pSpy->m_iName));

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi+1296]
	add	esp, 12					; 0000000cH
	push	edx
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ; CvCivilizationInfo::getSpyNames
	push	eax
	lea	eax, DWORD PTR $T267134[esp+592]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strMsg$223077[esp+592]
	mov	BYTE PTR __$EHRec$[esp+600], 29		; 0000001dH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T267134[esp+588]
	mov	BYTE PTR __$EHRec$[esp+596], 28		; 0000001cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 732  : 				LogEspionageMsg(strMsg);

	lea	ecx, DWORD PTR _strMsg$223077[esp+588]
	push	ecx
	mov	ecx, esi
	call	?LogEspionageMsg@CvPlayerEspionage@@QAEXAAVCvString@@@Z ; CvPlayerEspionage::LogEspionageMsg

; 733  : 			}

	lea	ecx, DWORD PTR _strMsg$223077[esp+588]
	mov	DWORD PTR __$EHRec$[esp+596], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ProcessSpy@2:

; 734  : 		}
; 735  : 		break;
; 736  : 	}
; 737  : 
; 738  : 	// if we just established surveillance in the city, turn the lights on
; 739  : #ifdef AUI_WARNING_FIXES
; 740  : 	if (HasEstablishedSurveillance(uiSpyIndex) && !bHadSurveillance && pCity)
; 741  : #else
; 742  : 	if(HasEstablishedSurveillance(uiSpyIndex) && !bHadSurveillance)

	mov	edx, DWORD PTR _uiSpyIndex$[esp+584]
	push	edx
	mov	ecx, esi
	call	?HasEstablishedSurveillance@CvPlayerEspionage@@QAE_NI@Z ; CvPlayerEspionage::HasEstablishedSurveillance
	test	al, al
	je	SHORT $LN1@ProcessSpy@2
	cmp	BYTE PTR _bHadSurveillance$[esp+588], 0
	jne	SHORT $LN1@ProcessSpy@2

; 743  : #endif
; 744  : 	{
; 745  : 		pCity->plot()->changeAdjacentSight(m_pPlayer->getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), true, NO_INVISIBLE, NO_DIRECTION, false);

	mov	eax, DWORD PTR [esi+1296]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1012@ProcessSpy@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN1013@ProcessSpy@2
$LN1012@ProcessSpy@2:
	or	eax, -1
$LN1013@ProcessSpy@2:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	push	0
	push	-1
	push	-1
	push	1
	push	ecx
	mov	ecx, DWORD PTR _pCity$[esp+608]
	push	eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN1@ProcessSpy@2:

; 746  : 	}
; 747  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+588]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 572				; 0000023cH
	ret	4
$LN1036@ProcessSpy@2:
	DD	$LN1@ProcessSpy@2
	DD	$LN78@ProcessSpy@2
	DD	$LN71@ProcessSpy@2
	DD	$LN61@ProcessSpy@2
	DD	$LN13@ProcessSpy@2
	DD	$LN2@ProcessSpy@2
	DD	$LN11@ProcessSpy@2
	DD	$LN1026@ProcessSpy@2
	DD	$LN6@ProcessSpy@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$0:
	lea	ecx, DWORD PTR _strSummary$222894[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$1:
	lea	ecx, DWORD PTR _strNotification$222903[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$2:
	lea	ecx, DWORD PTR _strMsg$222911[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$3:
	lea	ecx, DWORD PTR $T267109[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$4:
	lea	ecx, DWORD PTR _strMsg$222918[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$5:
	lea	ecx, DWORD PTR $T267110[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$6:
	lea	ecx, DWORD PTR _strMsg$222923[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$7:
	lea	ecx, DWORD PTR $T267111[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$8:
	lea	ecx, DWORD PTR _strSummary$222931[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$9:
	lea	ecx, DWORD PTR _strNotification$222935[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$10:
	lea	ecx, DWORD PTR _strSummary$222975[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$11:
	lea	ecx, DWORD PTR _strNotification$222979[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$12:
	lea	ecx, DWORD PTR _strMsg$222994[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$13:
	lea	ecx, DWORD PTR $T267121[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$14:
	lea	ecx, DWORD PTR $T267122[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$15:
	lea	ecx, DWORD PTR _strMsg$223006[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$16:
	lea	ecx, DWORD PTR $T267123[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$17:
	lea	ecx, DWORD PTR $T267124[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$18:
	lea	ecx, DWORD PTR _strSummary$223019[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$19:
	lea	ecx, DWORD PTR _strNotification$223022[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$20:
	lea	ecx, DWORD PTR _strMsg$223032[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$21:
	lea	ecx, DWORD PTR $T267129[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$22:
	lea	ecx, DWORD PTR $T267130[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$23:
	lea	ecx, DWORD PTR _strMsg$223063[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$24:
	lea	ecx, DWORD PTR $T267131[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$25:
	lea	ecx, DWORD PTR _strSummary$223068[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$26:
	lea	ecx, DWORD PTR _strNotification$223071[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$27:
	lea	ecx, DWORD PTR _strMsg$223077[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z$28:
	lea	ecx, DWORD PTR $T267134[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?ProcessSpy@CvPlayerEspionage@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessSpy@CvPlayerEspionage@@QAEXI@Z ENDP		; CvPlayerEspionage::ProcessSpy
PUBLIC	?DoTurn@CvPlayerEspionage@@QAEXXZ		; CvPlayerEspionage::DoTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvPlayerEspionage@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvPlayerEspionage@@QAEXXZ PROC			; CvPlayerEspionage::DoTurn, COMDAT
; _this$ = ecx

; 186  : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 187  : 	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayerEspionage::DoTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 188  : 	ProcessSpyMessages();

	call	?ProcessSpyMessages@CvPlayerEspionage@@QAEXXZ ; CvPlayerEspionage::ProcessSpyMessages
	lea	esi, DWORD PTR [edi+920]
	mov	ebx, 22					; 00000016H
$LL6@DoTurn@2:

; 191  : 	{
; 192  : 		m_aHeistLocations[ui].clear();

	mov	ecx, DWORD PTR [esi-4]
	mov	edx, DWORD PTR [esi]
	cmp	ecx, edx
	je	SHORT $LN5@DoTurn@2
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN50@DoTurn@2
$LL52@DoTurn@2:
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	add	eax, 8
	add	ecx, 8
	cmp	eax, edx
	jne	SHORT $LL52@DoTurn@2
$LN50@DoTurn@2:
	mov	DWORD PTR [esi], ecx
$LN5@DoTurn@2:

; 189  : 
; 190  : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	add	esi, 16					; 00000010H
	sub	ebx, 1
	jne	SHORT $LL6@DoTurn@2

; 193  : 	}
; 194  : 
; 195  : 	for(uint uiSpy = 0; uiSpy < m_aSpyList.size(); uiSpy++)

	xor	esi, esi
	cmp	DWORD PTR [edi+8], esi
	jbe	SHORT $LN1@DoTurn@2
	npad	6
$LL3@DoTurn@2:

; 196  : 	{
; 197  : 		ProcessSpy(uiSpy);

	push	esi
	mov	ecx, edi
	call	?ProcessSpy@CvPlayerEspionage@@QAEXI@Z	; CvPlayerEspionage::ProcessSpy
	inc	esi
	cmp	esi, DWORD PTR [edi+8]
	jb	SHORT $LL3@DoTurn@2
$LN1@DoTurn@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 198  : 	}
; 199  : }

	ret	0
?DoTurn@CvPlayerEspionage@@QAEXXZ ENDP			; CvPlayerEspionage::DoTurn
_TEXT	ENDS
END
