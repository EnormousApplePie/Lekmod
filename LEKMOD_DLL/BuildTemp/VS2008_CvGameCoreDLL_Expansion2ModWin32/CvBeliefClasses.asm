; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\Github\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvBeliefClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218431 DB	'ShortDescription', 00H
	ORG $+3
$SG218432 DB	'MinPopulation', 00H
	ORG $+2
$SG218433 DB	'MinFollowers', 00H
	ORG $+3
$SG218434 DB	'MaxDistance', 00H
$SG218435 DB	'CityGrowthModifier', 00H
	ORG $+1
$SG218436 DB	'FaithFromKills', 00H
	ORG $+1
$SG218437 DB	'FaithFromDyingUnits', 00H
$SG218438 DB	'RiverHappiness', 00H
	ORG $+1
$SG218439 DB	'HappinessPerCity', 00H
	ORG $+3
$SG218440 DB	'HappinessPerXPeacefulForeignFollowers', 00H
	ORG $+2
$SG218441 DB	'PlotCultureCostModifier', 00H
$SG218442 DB	'CityRangeStrikeModifier', 00H
$SG218443 DB	'CombatModifierEnemyCities', 00H
	ORG $+2
$SG218444 DB	'CombatModifierFriendlyCities', 00H
	ORG $+3
$SG218445 DB	'FriendlyHealChange', 00H
	ORG $+1
$SG218446 DB	'CityStateFriendshipModifier', 00H
$SG218447 DB	'LandBarbarianConversionPercent', 00H
	ORG $+1
$SG218448 DB	'WonderProductionModifier', 00H
	ORG $+3
$SG218449 DB	'PlayerHappiness', 00H
$SG218450 DB	'PlayerCultureModifier', 00H
	ORG $+2
$SG218451 DB	'HappinessPerFollowingCity', 00H
	ORG $+2
$SG218452 DB	'GoldPerFollowingCity', 00H
	ORG $+3
$SG218453 DB	'GoldPerXFollowers', 00H
	ORG $+2
$SG218454 DB	'GoldPerFirstCityConversion', 00H
	ORG $+1
$SG218455 DB	'SciencePerOtherReligionFollower', 00H
$SG218456 DB	'SpreadDistanceModifier', 00H
	ORG $+1
$SG218457 DB	'SpreadStrengthModifier', 00H
	ORG $+1
$SG218458 DB	'ProphetStrengthModifier', 00H
$SG218459 DB	'ProphetCostModifier', 00H
$SG218460 DB	'MissionaryStrengthModifier', 00H
	ORG $+1
$SG218461 DB	'FlatFaithPerCitizenBorn', 00H
$SG218462 DB	'MissionaryExtraSpreads', 00H
	ORG $+1
$SG218463 DB	'SpreadModifierOwnedCities', 00H
	ORG $+2
$SG218464 DB	'SpreadModifierUnownedCities', 00H
$SG218465 DB	'ExtraTradeRoutes', 00H
	ORG $+3
$SG218466 DB	'FaithPerCityStateThisReligion', 00H
	ORG $+2
$SG218467 DB	'FaithPerForeignTradeRoute', 00H
	ORG $+2
$SG218468 DB	'GoldenAgeTurns', 00H
	ORG $+1
$SG218469 DB	'MissionaryCostModifier', 00H
	ORG $+1
$SG218470 DB	'FriendlyCityStateSpreadModifier', 00H
$SG218471 DB	'GreatPersonExpendedFaith', 00H
	ORG $+3
$SG218472 DB	'CityStateMinimumInfluence', 00H
	ORG $+2
$SG218473 DB	'CityStateInfluenceModifier', 00H
	ORG $+1
$SG218474 DB	'OtherReligionPressureErosion', 00H
	ORG $+3
$SG218475 DB	'SpyPressure', 00H
$SG218476 DB	'InquisitorPressureRetention', 00H
$SG218477 DB	'FaithBuildingTourism', 00H
	ORG $+3
$SG218478 DB	'NumFreeSettlers', 00H
$SG218479 DB	'Pantheon', 00H
	ORG $+3
$SG218480 DB	'Founder', 00H
$SG218481 DB	'Follower', 00H
	ORG $+3
$SG218482 DB	'Enhancer', 00H
	ORG $+3
$SG218483 DB	'Reformation', 00H
$SG218484 DB	'RequiresPeace', 00H
	ORG $+2
$SG218485 DB	'ConvertsBarbarians', 00H
	ORG $+1
$SG218486 DB	'DeusVult', 00H
	ORG $+3
$SG218487 DB	'FaithPurchaseAllGreatPeople', 00H
$SG218488 DB	'AllowsFaithGiftsToMinors', 00H
	ORG $+3
$SG218490 DB	'ObsoleteEra', 00H
$SG218492 DB	'ResourceRevealed', 00H
	ORG $+3
$SG218494 DB	'SpreadModifierDoublingTech', 00H
	ORG $+1
$SG218497 DB	'BeliefType', 00H
	ORG $+1
$SG218498 DB	'Belief_CityYieldChanges', 00H
$SG218499 DB	'BeliefType', 00H
	ORG $+1
$SG218500 DB	'Belief_HolyCityYieldChanges', 00H
$SG218501 DB	'BeliefType', 00H
	ORG $+1
$SG218502 DB	'Belief_YieldChangeAnySpecialist', 00H
$SG218503 DB	'BeliefType', 00H
	ORG $+1
$SG218504 DB	'Belief_YieldChangeTradeRoute', 00H
	ORG $+3
$SG218505 DB	'BeliefType', 00H
	ORG $+1
$SG218506 DB	'Belief_YieldChangeNaturalWonder', 00H
$SG218507 DB	'BeliefType', 00H
	ORG $+1
$SG218508 DB	'Belief_YieldChangeWorldWonder', 00H
	ORG $+2
$SG218509 DB	'BeliefType', 00H
	ORG $+1
$SG218510 DB	'Belief_YieldModifierNaturalWonder', 00H
	ORG $+2
$SG218511 DB	'Max', 00H
$SG218512 DB	'BeliefType', 00H
	ORG $+1
$SG218513 DB	'YieldType', 00H
	ORG $+2
$SG218514 DB	'Belief_MaxYieldModifierPerFollower', 00H
	ORG $+1
$SG218515 DB	'Yields', 00H
	ORG $+1
$SG218516 DB	'HappinessChange', 00H
$SG218517 DB	'BeliefType', 00H
	ORG $+1
$SG218518 DB	'ResourceType', 00H
	ORG $+3
$SG218519 DB	'Belief_ResourceHappiness', 00H
	ORG $+3
$SG218520 DB	'Resources', 00H
	ORG $+2
$SG218521 DB	'ResourceQuantityModifier', 00H
	ORG $+3
$SG218522 DB	'BeliefType', 00H
	ORG $+1
$SG218523 DB	'ResourceType', 00H
	ORG $+3
$SG218524 DB	'Belief_ResourceQuantityModifiers', 00H
	ORG $+3
$SG218525 DB	'Resources', 00H
	ORG $+2
$SG218526 DB	'Happiness', 00H
	ORG $+2
$SG218527 DB	'BeliefType', 00H
	ORG $+1
$SG218528 DB	'BuildingClassType', 00H
	ORG $+2
$SG218529 DB	'Belief_BuildingClassHappiness', 00H
	ORG $+2
$SG218530 DB	'BuildingClasses', 00H
$SG218531 DB	'Tourism', 00H
$SG218532 DB	'BeliefType', 00H
	ORG $+1
$SG218533 DB	'BuildingClassType', 00H
	ORG $+2
$SG218534 DB	'Belief_BuildingClassTourism', 00H
$SG218535 DB	'BuildingClasses', 00H
$SG218536 DB	'Yield', 00H
	ORG $+2
$SG218537 DB	'BeliefType', 00H
	ORG $+1
$SG218538 DB	'YieldType', 00H
	ORG $+2
$SG218539 DB	'Belief_YieldChangePerForeignCity', 00H
	ORG $+3
$SG218540 DB	'Yields', 00H
	ORG $+1
$SG218541 DB	'ForeignFollowers', 00H
	ORG $+3
$SG218542 DB	'BeliefType', 00H
	ORG $+1
$SG218543 DB	'YieldType', 00H
	ORG $+2
$SG218544 DB	'Belief_YieldChangePerXForeignFollowers', 00H
	ORG $+1
$SG218545 DB	'Yields', 00H
	ORG $+1
$SG218546 DB	'BeliefType', 00H
	ORG $+1
$SG218547 DB	'EraType', 00H
$SG218548 DB	'Belief_EraFaithUnitPurchase', 00H
$SG218549 DB	'Eras', 00H
	ORG $+3
$SG218550 DB	'BeliefType', 00H
	ORG $+1
$SG218551 DB	'BuildingClassType', 00H
	ORG $+2
$SG218552 DB	'Belief_BuildingClassFaithPurchase', 00H
	ORG $+2
$SG218553 DB	'BuildingClasses', 00H
$SG218554 DB	'Yields', 00H
	ORG $+1
$SG218555 DB	'Improvements', 00H
	ORG $+3
$SG218557 DB	'Belief_ImprovementYieldChanges', 00H
	ORG $+5
$SG218560 DB	'select Improvements.ID as ImprovementID, Yields.ID as Yi'
	DB	'eldID, Yield from Belief_ImprovementYieldChanges inner join I'
	DB	'mprovements on Improvements.Type = ImprovementType inner join'
	DB	' Yields on Yields.Type = YieldType where BeliefType = ?', 00H
	ORG $+2
$SG218567 DB	'Yields', 00H
	ORG $+1
$SG218568 DB	'BuildingClasses', 00H
$SG218570 DB	'Belief_BuildingClassYieldChanges', 00H
	ORG $+3
$SG218573 DB	'select BuildingClasses.ID as BuildingClassID, Yields.ID '
	DB	'as YieldID, YieldChange from Belief_BuildingClassYieldChanges'
	DB	' inner join BuildingClasses on BuildingClasses.Type = Buildin'
	DB	'gClassType inner join Yields on Yields.Type = YieldType where'
	DB	' BeliefType = ?', 00H
	ORG $+1
$SG218580 DB	'Yields', 00H
	ORG $+1
$SG218581 DB	'Features', 00H
	ORG $+3
$SG218583 DB	'Belief_FeatureYieldChanges', 00H
	ORG $+1
$SG218586 DB	'select Features.ID as FeatureID, Yields.ID as YieldID, Y'
	DB	'ield from Belief_FeatureYieldChanges inner join Features on F'
	DB	'eatures.Type = FeatureType inner join Yields on Yields.Type ='
	DB	' YieldType where BeliefType = ?', 00H
	ORG $+2
$SG218593 DB	'Yields', 00H
	ORG $+1
$SG218594 DB	'Resources', 00H
	ORG $+2
$SG218596 DB	'Belief_ResourceYieldChanges', 00H
	ORG $+4
$SG218599 DB	'select Resources.ID as ResourceID, Yields.ID as YieldID,'
	DB	' Yield from Belief_ResourceYieldChanges inner join Resources '
	DB	'on Resources.Type = ResourceType inner join Yields on Yields.'
	DB	'Type = YieldType where BeliefType = ?', 00H
$SG218606 DB	'Yields', 00H
	ORG $+1
$SG218607 DB	'Terrains', 00H
	ORG $+3
$SG218609 DB	'Belief_TerrainYieldChanges', 00H
	ORG $+1
$SG218612 DB	'select Terrains.ID as TerrainID, Yields.ID as YieldID, Y'
	DB	'ield from Belief_TerrainYieldChanges inner join Terrains on T'
	DB	'errains.Type = TerrainType inner join Yields on Yields.Type ='
	DB	' YieldType where BeliefType = ?', 00H
	ORG $+2
$SG219406 DB	'Converted barbarian (with belief), X: %d, Y: %d', 00H
$SG219409 DB	'TXT_KEY_NOTIFICATION_HEATHEN_CONVERTS', 00H
	ORG $+2
$SG219412 DB	'TXT_KEY_NOTIFICATION_SUMMARY_HEATHEN_CONVERTS', 00H
CONST	ENDS
PUBLIC	?GetMinPopulation@CvBeliefEntry@@QBEHXZ		; CvBeliefEntry::GetMinPopulation
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
;	COMDAT ?GetMinPopulation@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinPopulation@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetMinPopulation, COMDAT
; _this$ = ecx

; 173  : 	return m_iMinPopulation;

	mov	eax, DWORD PTR [ecx+260]

; 174  : }

	ret	0
?GetMinPopulation@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetMinPopulation
_TEXT	ENDS
PUBLIC	?GetMinFollowers@CvBeliefEntry@@QBEHXZ		; CvBeliefEntry::GetMinFollowers
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinFollowers@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinFollowers@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetMinFollowers, COMDAT
; _this$ = ecx

; 179  : 	return m_iMinFollowers;

	mov	eax, DWORD PTR [ecx+264]

; 180  : }

	ret	0
?GetMinFollowers@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetMinFollowers
_TEXT	ENDS
PUBLIC	?GetMaxDistance@CvBeliefEntry@@QBEHXZ		; CvBeliefEntry::GetMaxDistance
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxDistance@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMaxDistance@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetMaxDistance, COMDAT
; _this$ = ecx

; 185  : 	return m_iMaxDistance;

	mov	eax, DWORD PTR [ecx+268]

; 186  : }

	ret	0
?GetMaxDistance@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetMaxDistance
_TEXT	ENDS
PUBLIC	?GetCityGrowthModifier@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetCityGrowthModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityGrowthModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityGrowthModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetCityGrowthModifier, COMDAT
; _this$ = ecx

; 191  : 	return m_iCityGrowthModifier;

	mov	eax, DWORD PTR [ecx+272]

; 192  : }

	ret	0
?GetCityGrowthModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetCityGrowthModifier
_TEXT	ENDS
PUBLIC	?GetFaithFromKills@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetFaithFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithFromKills@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithFromKills@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetFaithFromKills, COMDAT
; _this$ = ecx

; 197  : 	return m_iFaithFromKills;

	mov	eax, DWORD PTR [ecx+276]

; 198  : }

	ret	0
?GetFaithFromKills@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetFaithFromKills
_TEXT	ENDS
PUBLIC	?GetFaithFromDyingUnits@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetFaithFromDyingUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithFromDyingUnits@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithFromDyingUnits@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetFaithFromDyingUnits, COMDAT
; _this$ = ecx

; 203  : 	return m_iFaithFromDyingUnits;

	mov	eax, DWORD PTR [ecx+280]

; 204  : }

	ret	0
?GetFaithFromDyingUnits@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetFaithFromDyingUnits
_TEXT	ENDS
PUBLIC	?GetRiverHappiness@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetRiverHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetRiverHappiness@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRiverHappiness@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetRiverHappiness, COMDAT
; _this$ = ecx

; 209  : 	return m_iRiverHappiness;

	mov	eax, DWORD PTR [ecx+284]

; 210  : }

	ret	0
?GetRiverHappiness@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetRiverHappiness
_TEXT	ENDS
PUBLIC	?GetHappinessPerCity@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetHappinessPerCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerCity@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerCity@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetHappinessPerCity, COMDAT
; _this$ = ecx

; 215  : 	return m_iHappinessPerCity;

	mov	eax, DWORD PTR [ecx+288]

; 216  : }

	ret	0
?GetHappinessPerCity@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetHappinessPerCity
_TEXT	ENDS
PUBLIC	?GetHappinessPerXPeacefulForeignFollowers@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetHappinessPerXPeacefulForeignFollowers
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerXPeacefulForeignFollowers@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHappinessPerXPeacefulForeignFollowers@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetHappinessPerXPeacefulForeignFollowers, COMDAT
; _this$ = ecx

; 221  : 	return m_iHappinessPerXPeacefulForeignFollowers;

	mov	eax, DWORD PTR [ecx+292]

; 222  : }

	ret	0
?GetHappinessPerXPeacefulForeignFollowers@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetHappinessPerXPeacefulForeignFollowers
_TEXT	ENDS
PUBLIC	?GetPlotCultureCostModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetPlotCultureCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotCultureCostModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlotCultureCostModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 227  : 	return m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR [ecx+296]

; 228  : }

	ret	0
?GetPlotCultureCostModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetCityRangeStrikeModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetCityRangeStrikeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityRangeStrikeModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityRangeStrikeModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetCityRangeStrikeModifier, COMDAT
; _this$ = ecx

; 233  : 	return m_iCityRangeStrikeModifier;

	mov	eax, DWORD PTR [ecx+300]

; 234  : }

	ret	0
?GetCityRangeStrikeModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetCityRangeStrikeModifier
_TEXT	ENDS
PUBLIC	?GetCombatModifierEnemyCities@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetCombatModifierEnemyCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatModifierEnemyCities@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatModifierEnemyCities@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetCombatModifierEnemyCities, COMDAT
; _this$ = ecx

; 239  : 	return m_iCombatModifierEnemyCities;

	mov	eax, DWORD PTR [ecx+304]

; 240  : }

	ret	0
?GetCombatModifierEnemyCities@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetCombatModifierEnemyCities
_TEXT	ENDS
PUBLIC	?GetCombatModifierFriendlyCities@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetCombatModifierFriendlyCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatModifierFriendlyCities@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatModifierFriendlyCities@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetCombatModifierFriendlyCities, COMDAT
; _this$ = ecx

; 245  : 	return m_iCombatModifierFriendlyCities;

	mov	eax, DWORD PTR [ecx+308]

; 246  : }

	ret	0
?GetCombatModifierFriendlyCities@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetCombatModifierFriendlyCities
_TEXT	ENDS
PUBLIC	?GetFriendlyHealChange@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetFriendlyHealChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyHealChange@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyHealChange@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetFriendlyHealChange, COMDAT
; _this$ = ecx

; 251  : 	return m_iFriendlyHealChange;

	mov	eax, DWORD PTR [ecx+312]

; 252  : }

	ret	0
?GetFriendlyHealChange@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetFriendlyHealChange
_TEXT	ENDS
PUBLIC	?GetCityStateFriendshipModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetCityStateFriendshipModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateFriendshipModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateFriendshipModifier@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetCityStateFriendshipModifier, COMDAT
; _this$ = ecx

; 257  : 	return m_iCityStateFriendshipModifier;

	mov	eax, DWORD PTR [ecx+316]

; 258  : }

	ret	0
?GetCityStateFriendshipModifier@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetCityStateFriendshipModifier
_TEXT	ENDS
PUBLIC	?GetLandBarbarianConversionPercent@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetLandBarbarianConversionPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetLandBarbarianConversionPercent@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLandBarbarianConversionPercent@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetLandBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 263  : 	return m_iLandBarbarianConversionPercent;

	mov	eax, DWORD PTR [ecx+320]

; 264  : }

	ret	0
?GetLandBarbarianConversionPercent@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetLandBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetWonderProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWonderProductionModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWonderProductionModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 269  : 	return m_iWonderProductionModifier;

	mov	eax, DWORD PTR [ecx+324]

; 270  : }

	ret	0
?GetWonderProductionModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetPlayerHappiness@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetPlayerHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerHappiness@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlayerHappiness@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetPlayerHappiness, COMDAT
; _this$ = ecx

; 275  : 	return m_iPlayerHappiness;

	mov	eax, DWORD PTR [ecx+328]

; 276  : }

	ret	0
?GetPlayerHappiness@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetPlayerHappiness
_TEXT	ENDS
PUBLIC	?GetPlayerCultureModifier@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetPlayerCultureModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerCultureModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPlayerCultureModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetPlayerCultureModifier, COMDAT
; _this$ = ecx

; 281  : 	return m_iPlayerCultureModifier;

	mov	eax, DWORD PTR [ecx+332]

; 282  : }

	ret	0
?GetPlayerCultureModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetPlayerCultureModifier
_TEXT	ENDS
PUBLIC	?GetHappinessPerFollowingCity@CvBeliefEntry@@QBEMXZ ; CvBeliefEntry::GetHappinessPerFollowingCity
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerFollowingCity@CvBeliefEntry@@QBEMXZ
_TEXT	SEGMENT
?GetHappinessPerFollowingCity@CvBeliefEntry@@QBEMXZ PROC ; CvBeliefEntry::GetHappinessPerFollowingCity, COMDAT
; _this$ = ecx

; 287  : 	return m_fHappinessPerFollowingCity;

	fld	DWORD PTR [ecx+336]

; 288  : }

	ret	0
?GetHappinessPerFollowingCity@CvBeliefEntry@@QBEMXZ ENDP ; CvBeliefEntry::GetHappinessPerFollowingCity
_TEXT	ENDS
PUBLIC	?GetGoldPerFollowingCity@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetGoldPerFollowingCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerFollowingCity@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerFollowingCity@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetGoldPerFollowingCity, COMDAT
; _this$ = ecx

; 293  : 	return m_iGoldPerFollowingCity;

	mov	eax, DWORD PTR [ecx+340]

; 294  : }

	ret	0
?GetGoldPerFollowingCity@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetGoldPerFollowingCity
_TEXT	ENDS
PUBLIC	?GetGoldPerXFollowers@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetGoldPerXFollowers
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerXFollowers@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerXFollowers@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetGoldPerXFollowers, COMDAT
; _this$ = ecx

; 299  : 	return m_iGoldPerXFollowers;

	mov	eax, DWORD PTR [ecx+344]

; 300  : }

	ret	0
?GetGoldPerXFollowers@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetGoldPerXFollowers
_TEXT	ENDS
PUBLIC	?GetGoldWhenCityAdopts@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetGoldWhenCityAdopts
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldWhenCityAdopts@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldWhenCityAdopts@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetGoldWhenCityAdopts, COMDAT
; _this$ = ecx

; 305  : 	return m_iGoldWhenCityAdopts;

	mov	eax, DWORD PTR [ecx+348]

; 306  : }

	ret	0
?GetGoldWhenCityAdopts@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetGoldWhenCityAdopts
_TEXT	ENDS
PUBLIC	?GetSciencePerOtherReligionFollower@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetSciencePerOtherReligionFollower
; Function compile flags: /Ogtpy
;	COMDAT ?GetSciencePerOtherReligionFollower@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSciencePerOtherReligionFollower@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetSciencePerOtherReligionFollower, COMDAT
; _this$ = ecx

; 311  : 	return m_iSciencePerOtherReligionFollower;

	mov	eax, DWORD PTR [ecx+352]

; 312  : }

	ret	0
?GetSciencePerOtherReligionFollower@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetSciencePerOtherReligionFollower
_TEXT	ENDS
PUBLIC	?GetSpreadDistanceModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetSpreadDistanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpreadDistanceModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpreadDistanceModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetSpreadDistanceModifier, COMDAT
; _this$ = ecx

; 317  : 	return m_iSpreadDistanceModifier;

	mov	eax, DWORD PTR [ecx+356]

; 318  : }

	ret	0
?GetSpreadDistanceModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetSpreadDistanceModifier
_TEXT	ENDS
PUBLIC	?GetSpreadStrengthModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetSpreadStrengthModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpreadStrengthModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpreadStrengthModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetSpreadStrengthModifier, COMDAT
; _this$ = ecx

; 323  : 	return m_iSpreadStrengthModifier;

	mov	eax, DWORD PTR [ecx+360]

; 324  : }

	ret	0
?GetSpreadStrengthModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetSpreadStrengthModifier
_TEXT	ENDS
PUBLIC	?GetProphetStrengthModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetProphetStrengthModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetProphetStrengthModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProphetStrengthModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetProphetStrengthModifier, COMDAT
; _this$ = ecx

; 329  : 	return m_iProphetStrengthModifier;

	mov	eax, DWORD PTR [ecx+364]

; 330  : }

	ret	0
?GetProphetStrengthModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetProphetStrengthModifier
_TEXT	ENDS
PUBLIC	?GetProphetCostModifier@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetProphetCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetProphetCostModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProphetCostModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetProphetCostModifier, COMDAT
; _this$ = ecx

; 335  : 	return m_iProphetCostModifier;

	mov	eax, DWORD PTR [ecx+368]

; 336  : }

	ret	0
?GetProphetCostModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetProphetCostModifier
_TEXT	ENDS
PUBLIC	?GetMissionaryStrengthModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetMissionaryStrengthModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMissionaryStrengthModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMissionaryStrengthModifier@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetMissionaryStrengthModifier, COMDAT
; _this$ = ecx

; 341  : 	return m_iMissionaryStrengthModifier;

	mov	eax, DWORD PTR [ecx+372]

; 342  : }

	ret	0
?GetMissionaryStrengthModifier@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetMissionaryStrengthModifier
_TEXT	ENDS
PUBLIC	?GetFlatFaithPerCitizenBorn@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetFlatFaithPerCitizenBorn
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlatFaithPerCitizenBorn@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFlatFaithPerCitizenBorn@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetFlatFaithPerCitizenBorn, COMDAT
; _this$ = ecx

; 348  : 	return m_iFlatFaithPerCitizenBorn;

	mov	eax, DWORD PTR [ecx+376]

; 349  : }

	ret	0
?GetFlatFaithPerCitizenBorn@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetFlatFaithPerCitizenBorn
_TEXT	ENDS
PUBLIC	?GetMissionaryExtraSpreads@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetMissionaryExtraSpreads
; Function compile flags: /Ogtpy
;	COMDAT ?GetMissionaryExtraSpreads@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMissionaryExtraSpreads@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetMissionaryExtraSpreads, COMDAT
; _this$ = ecx

; 356  : 	return m_iMissionaryExtraSpreads;

	mov	eax, DWORD PTR [ecx+380]

; 357  : }

	ret	0
?GetMissionaryExtraSpreads@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetMissionaryExtraSpreads
_TEXT	ENDS
PUBLIC	?GetSpreadModifierOwnedCities@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetSpreadModifierOwnedCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpreadModifierOwnedCities@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpreadModifierOwnedCities@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetSpreadModifierOwnedCities, COMDAT
; _this$ = ecx

; 364  : 	return m_iSpreadModifierOwnedCities;

	mov	eax, DWORD PTR [ecx+384]

; 365  : }

	ret	0
?GetSpreadModifierOwnedCities@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetSpreadModifierOwnedCities
_TEXT	ENDS
PUBLIC	?GetSpreadModifierUnownedCities@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetSpreadModifierUnownedCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpreadModifierUnownedCities@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpreadModifierUnownedCities@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetSpreadModifierUnownedCities, COMDAT
; _this$ = ecx

; 370  : 	return m_iSpreadModifierUnownedCities;

	mov	eax, DWORD PTR [ecx+388]

; 371  : }

	ret	0
?GetSpreadModifierUnownedCities@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetSpreadModifierUnownedCities
_TEXT	ENDS
PUBLIC	?GetExtraTradeRoutes@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetExtraTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraTradeRoutes@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraTradeRoutes@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetExtraTradeRoutes, COMDAT
; _this$ = ecx

; 378  : 	return m_iExtraTradeRoutes;

	mov	eax, DWORD PTR [ecx+392]

; 379  : }

	ret	0
?GetExtraTradeRoutes@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetExtraTradeRoutes
_TEXT	ENDS
PUBLIC	?GetFaithPerCityStateThisReligion@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetFaithPerCityStateThisReligion
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithPerCityStateThisReligion@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithPerCityStateThisReligion@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetFaithPerCityStateThisReligion, COMDAT
; _this$ = ecx

; 386  : 	return m_iFaithPerCityStateThisReligion;

	mov	eax, DWORD PTR [ecx+396]

; 387  : }

	ret	0
?GetFaithPerCityStateThisReligion@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetFaithPerCityStateThisReligion
_TEXT	ENDS
PUBLIC	?GetFaithPerForeignTradeRoute@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetFaithPerForeignTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithPerForeignTradeRoute@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithPerForeignTradeRoute@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetFaithPerForeignTradeRoute, COMDAT
; _this$ = ecx

; 394  : 	return m_iFaithPerForeignTradeRoute;

	mov	eax, DWORD PTR [ecx+400]

; 395  : }

	ret	0
?GetFaithPerForeignTradeRoute@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetFaithPerForeignTradeRoute
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTurns@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetGoldenAgeTurns
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeTurns@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTurns@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetGoldenAgeTurns, COMDAT
; _this$ = ecx

; 402  : 	return m_iGoldenAgeTurns;

	mov	eax, DWORD PTR [ecx+404]

; 403  : }

	ret	0
?GetGoldenAgeTurns@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetGoldenAgeTurns
_TEXT	ENDS
PUBLIC	?GetMissionaryCostModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetMissionaryCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetMissionaryCostModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMissionaryCostModifier@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetMissionaryCostModifier, COMDAT
; _this$ = ecx

; 409  : 	return m_iMissionaryCostModifier;

	mov	eax, DWORD PTR [ecx+408]

; 410  : }

	ret	0
?GetMissionaryCostModifier@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetMissionaryCostModifier
_TEXT	ENDS
PUBLIC	?GetFriendlyCityStateSpreadModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetFriendlyCityStateSpreadModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyCityStateSpreadModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyCityStateSpreadModifier@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetFriendlyCityStateSpreadModifier, COMDAT
; _this$ = ecx

; 415  : 	return m_iFriendlyCityStateSpreadModifier;

	mov	eax, DWORD PTR [ecx+412]

; 416  : }

	ret	0
?GetFriendlyCityStateSpreadModifier@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetFriendlyCityStateSpreadModifier
_TEXT	ENDS
PUBLIC	?GetGreatPersonExpendedFaith@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetGreatPersonExpendedFaith
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPersonExpendedFaith@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatPersonExpendedFaith@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetGreatPersonExpendedFaith, COMDAT
; _this$ = ecx

; 421  : 	return m_iGreatPersonExpendedFaith;

	mov	eax, DWORD PTR [ecx+416]

; 422  : }

	ret	0
?GetGreatPersonExpendedFaith@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetGreatPersonExpendedFaith
_TEXT	ENDS
PUBLIC	?GetCityStateMinimumInfluence@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetCityStateMinimumInfluence
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateMinimumInfluence@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateMinimumInfluence@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetCityStateMinimumInfluence, COMDAT
; _this$ = ecx

; 427  : 	return m_iCityStateMinimumInfluence;

	mov	eax, DWORD PTR [ecx+420]

; 428  : }

	ret	0
?GetCityStateMinimumInfluence@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetCityStateMinimumInfluence
_TEXT	ENDS
PUBLIC	?GetCityStateInfluenceModifier@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetCityStateInfluenceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityStateInfluenceModifier@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityStateInfluenceModifier@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetCityStateInfluenceModifier, COMDAT
; _this$ = ecx

; 433  : 	return m_iCityStateInfluenceModifier;

	mov	eax, DWORD PTR [ecx+424]

; 434  : }

	ret	0
?GetCityStateInfluenceModifier@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetCityStateInfluenceModifier
_TEXT	ENDS
PUBLIC	?GetOtherReligionPressureErosion@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetOtherReligionPressureErosion
; Function compile flags: /Ogtpy
;	COMDAT ?GetOtherReligionPressureErosion@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOtherReligionPressureErosion@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetOtherReligionPressureErosion, COMDAT
; _this$ = ecx

; 439  : 	return m_iOtherReligionPressureErosion;

	mov	eax, DWORD PTR [ecx+428]

; 440  : }

	ret	0
?GetOtherReligionPressureErosion@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetOtherReligionPressureErosion
_TEXT	ENDS
PUBLIC	?GetSpyPressure@CvBeliefEntry@@QBEHXZ		; CvBeliefEntry::GetSpyPressure
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpyPressure@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpyPressure@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetSpyPressure, COMDAT
; _this$ = ecx

; 445  : 	return m_iSpyPressure;

	mov	eax, DWORD PTR [ecx+432]

; 446  : }

	ret	0
?GetSpyPressure@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetSpyPressure
_TEXT	ENDS
PUBLIC	?GetInquisitorPressureRetention@CvBeliefEntry@@QBEHXZ ; CvBeliefEntry::GetInquisitorPressureRetention
; Function compile flags: /Ogtpy
;	COMDAT ?GetInquisitorPressureRetention@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInquisitorPressureRetention@CvBeliefEntry@@QBEHXZ PROC ; CvBeliefEntry::GetInquisitorPressureRetention, COMDAT
; _this$ = ecx

; 451  : 	return m_iInquisitorPressureRetention;

	mov	eax, DWORD PTR [ecx+436]

; 452  : }

	ret	0
?GetInquisitorPressureRetention@CvBeliefEntry@@QBEHXZ ENDP ; CvBeliefEntry::GetInquisitorPressureRetention
_TEXT	ENDS
PUBLIC	?GetFaithBuildingTourism@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetFaithBuildingTourism
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithBuildingTourism@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithBuildingTourism@CvBeliefEntry@@QBEHXZ PROC	; CvBeliefEntry::GetFaithBuildingTourism, COMDAT
; _this$ = ecx

; 457  : 	return m_iFaithBuildingTourism;

	mov	eax, DWORD PTR [ecx+440]

; 458  : }

	ret	0
?GetFaithBuildingTourism@CvBeliefEntry@@QBEHXZ ENDP	; CvBeliefEntry::GetFaithBuildingTourism
_TEXT	ENDS
PUBLIC	?GetNumFreeSettlers@CvBeliefEntry@@QBEHXZ	; CvBeliefEntry::GetNumFreeSettlers
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeSettlers@CvBeliefEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumFreeSettlers@CvBeliefEntry@@QBEHXZ PROC		; CvBeliefEntry::GetNumFreeSettlers, COMDAT
; _this$ = ecx

; 464  : 	return m_iNumFreeSettlers;

	mov	eax, DWORD PTR [ecx+444]

; 465  : }

	ret	0
?GetNumFreeSettlers@CvBeliefEntry@@QBEHXZ ENDP		; CvBeliefEntry::GetNumFreeSettlers
_TEXT	ENDS
PUBLIC	?IsPantheonBelief@CvBeliefEntry@@QBE_NXZ	; CvBeliefEntry::IsPantheonBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsPantheonBelief@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPantheonBelief@CvBeliefEntry@@QBE_NXZ PROC		; CvBeliefEntry::IsPantheonBelief, COMDAT
; _this$ = ecx

; 471  : 	return m_bPantheon;

	mov	al, BYTE PTR [ecx+448]

; 472  : }

	ret	0
?IsPantheonBelief@CvBeliefEntry@@QBE_NXZ ENDP		; CvBeliefEntry::IsPantheonBelief
_TEXT	ENDS
PUBLIC	?IsFounderBelief@CvBeliefEntry@@QBE_NXZ		; CvBeliefEntry::IsFounderBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsFounderBelief@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFounderBelief@CvBeliefEntry@@QBE_NXZ PROC		; CvBeliefEntry::IsFounderBelief, COMDAT
; _this$ = ecx

; 477  : 	return m_bFounder;

	mov	al, BYTE PTR [ecx+449]

; 478  : }

	ret	0
?IsFounderBelief@CvBeliefEntry@@QBE_NXZ ENDP		; CvBeliefEntry::IsFounderBelief
_TEXT	ENDS
PUBLIC	?IsFollowerBelief@CvBeliefEntry@@QBE_NXZ	; CvBeliefEntry::IsFollowerBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsFollowerBelief@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFollowerBelief@CvBeliefEntry@@QBE_NXZ PROC		; CvBeliefEntry::IsFollowerBelief, COMDAT
; _this$ = ecx

; 483  : 	return m_bFollower;

	mov	al, BYTE PTR [ecx+450]

; 484  : }

	ret	0
?IsFollowerBelief@CvBeliefEntry@@QBE_NXZ ENDP		; CvBeliefEntry::IsFollowerBelief
_TEXT	ENDS
PUBLIC	?IsEnhancerBelief@CvBeliefEntry@@QBE_NXZ	; CvBeliefEntry::IsEnhancerBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnhancerBelief@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEnhancerBelief@CvBeliefEntry@@QBE_NXZ PROC		; CvBeliefEntry::IsEnhancerBelief, COMDAT
; _this$ = ecx

; 489  : 	return m_bEnhancer;

	mov	al, BYTE PTR [ecx+451]

; 490  : }

	ret	0
?IsEnhancerBelief@CvBeliefEntry@@QBE_NXZ ENDP		; CvBeliefEntry::IsEnhancerBelief
_TEXT	ENDS
PUBLIC	?IsReformationBelief@CvBeliefEntry@@QBE_NXZ	; CvBeliefEntry::IsReformationBelief
; Function compile flags: /Ogtpy
;	COMDAT ?IsReformationBelief@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsReformationBelief@CvBeliefEntry@@QBE_NXZ PROC	; CvBeliefEntry::IsReformationBelief, COMDAT
; _this$ = ecx

; 495  : 	return m_bReformer;

	mov	al, BYTE PTR [ecx+452]

; 496  : }

	ret	0
?IsReformationBelief@CvBeliefEntry@@QBE_NXZ ENDP	; CvBeliefEntry::IsReformationBelief
_TEXT	ENDS
PUBLIC	?RequiresPeace@CvBeliefEntry@@QBE_NXZ		; CvBeliefEntry::RequiresPeace
; Function compile flags: /Ogtpy
;	COMDAT ?RequiresPeace@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?RequiresPeace@CvBeliefEntry@@QBE_NXZ PROC		; CvBeliefEntry::RequiresPeace, COMDAT
; _this$ = ecx

; 501  : 	return m_bRequiresPeace;

	mov	al, BYTE PTR [ecx+453]

; 502  : }

	ret	0
?RequiresPeace@CvBeliefEntry@@QBE_NXZ ENDP		; CvBeliefEntry::RequiresPeace
_TEXT	ENDS
PUBLIC	?ConvertsBarbarians@CvBeliefEntry@@QBE_NXZ	; CvBeliefEntry::ConvertsBarbarians
; Function compile flags: /Ogtpy
;	COMDAT ?ConvertsBarbarians@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?ConvertsBarbarians@CvBeliefEntry@@QBE_NXZ PROC		; CvBeliefEntry::ConvertsBarbarians, COMDAT
; _this$ = ecx

; 507  : 	return m_bConvertsBarbarians;

	mov	al, BYTE PTR [ecx+454]

; 508  : }

	ret	0
?ConvertsBarbarians@CvBeliefEntry@@QBE_NXZ ENDP		; CvBeliefEntry::ConvertsBarbarians
_TEXT	ENDS
PUBLIC	?DeusVult@CvBeliefEntry@@QBE_NXZ		; CvBeliefEntry::DeusVult
; Function compile flags: /Ogtpy
;	COMDAT ?DeusVult@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?DeusVult@CvBeliefEntry@@QBE_NXZ PROC			; CvBeliefEntry::DeusVult, COMDAT
; _this$ = ecx

; 514  : 	return m_bDeusVult;

	mov	al, BYTE PTR [ecx+455]

; 515  : }

	ret	0
?DeusVult@CvBeliefEntry@@QBE_NXZ ENDP			; CvBeliefEntry::DeusVult
_TEXT	ENDS
PUBLIC	?FaithPurchaseAllGreatPeople@CvBeliefEntry@@QBE_NXZ ; CvBeliefEntry::FaithPurchaseAllGreatPeople
; Function compile flags: /Ogtpy
;	COMDAT ?FaithPurchaseAllGreatPeople@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?FaithPurchaseAllGreatPeople@CvBeliefEntry@@QBE_NXZ PROC ; CvBeliefEntry::FaithPurchaseAllGreatPeople, COMDAT
; _this$ = ecx

; 521  : 	return m_bFaithPurchaseAllGreatPeople;

	mov	al, BYTE PTR [ecx+456]

; 522  : }

	ret	0
?FaithPurchaseAllGreatPeople@CvBeliefEntry@@QBE_NXZ ENDP ; CvBeliefEntry::FaithPurchaseAllGreatPeople
_TEXT	ENDS
PUBLIC	?AllowsFaithGiftsToMinors@CvBeliefEntry@@QBE_NXZ ; CvBeliefEntry::AllowsFaithGiftsToMinors
; Function compile flags: /Ogtpy
;	COMDAT ?AllowsFaithGiftsToMinors@CvBeliefEntry@@QBE_NXZ
_TEXT	SEGMENT
?AllowsFaithGiftsToMinors@CvBeliefEntry@@QBE_NXZ PROC	; CvBeliefEntry::AllowsFaithGiftsToMinors, COMDAT
; _this$ = ecx

; 528  : 	return m_bAllowsFaithGiftsToMinors;

	mov	al, BYTE PTR [ecx+457]

; 529  : }

	ret	0
?AllowsFaithGiftsToMinors@CvBeliefEntry@@QBE_NXZ ENDP	; CvBeliefEntry::AllowsFaithGiftsToMinors
_TEXT	ENDS
PUBLIC	?GetObsoleteEra@CvBeliefEntry@@QBE?AW4EraTypes@@XZ ; CvBeliefEntry::GetObsoleteEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetObsoleteEra@CvBeliefEntry@@QBE?AW4EraTypes@@XZ
_TEXT	SEGMENT
?GetObsoleteEra@CvBeliefEntry@@QBE?AW4EraTypes@@XZ PROC	; CvBeliefEntry::GetObsoleteEra, COMDAT
; _this$ = ecx

; 535  : 	return m_eObsoleteEra;

	mov	eax, DWORD PTR [ecx+460]

; 536  : }

	ret	0
?GetObsoleteEra@CvBeliefEntry@@QBE?AW4EraTypes@@XZ ENDP	; CvBeliefEntry::GetObsoleteEra
_TEXT	ENDS
PUBLIC	?GetResourceRevealed@CvBeliefEntry@@QBE?AW4ResourceTypes@@XZ ; CvBeliefEntry::GetResourceRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceRevealed@CvBeliefEntry@@QBE?AW4ResourceTypes@@XZ
_TEXT	SEGMENT
?GetResourceRevealed@CvBeliefEntry@@QBE?AW4ResourceTypes@@XZ PROC ; CvBeliefEntry::GetResourceRevealed, COMDAT
; _this$ = ecx

; 541  : 	return m_eResourceRevealed;

	mov	eax, DWORD PTR [ecx+464]

; 542  : }

	ret	0
?GetResourceRevealed@CvBeliefEntry@@QBE?AW4ResourceTypes@@XZ ENDP ; CvBeliefEntry::GetResourceRevealed
_TEXT	ENDS
PUBLIC	?GetSpreadModifierDoublingTech@CvBeliefEntry@@QBE?AW4TechTypes@@XZ ; CvBeliefEntry::GetSpreadModifierDoublingTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpreadModifierDoublingTech@CvBeliefEntry@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetSpreadModifierDoublingTech@CvBeliefEntry@@QBE?AW4TechTypes@@XZ PROC ; CvBeliefEntry::GetSpreadModifierDoublingTech, COMDAT
; _this$ = ecx

; 547  : 	return m_eSpreadModifierDoublingTech;

	mov	eax, DWORD PTR [ecx+468]

; 548  : }

	ret	0
?GetSpreadModifierDoublingTech@CvBeliefEntry@@QBE?AW4TechTypes@@XZ ENDP ; CvBeliefEntry::GetSpreadModifierDoublingTech
_TEXT	ENDS
PUBLIC	?GetCityYieldChange@CvBeliefEntry@@QBEHH@Z	; CvBeliefEntry::GetCityYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityYieldChange@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCityYieldChange@CvBeliefEntry@@QBEHH@Z PROC		; CvBeliefEntry::GetCityYieldChange, COMDAT
; _this$ = ecx

; 565  : 	return m_paiCityYieldChange ? m_paiCityYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+500]
	test	eax, eax
	je	SHORT $LN3@GetCityYie
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 566  : }

	ret	4
$LN3@GetCityYie:

; 565  : 	return m_paiCityYieldChange ? m_paiCityYieldChange[i] : -1;

	or	eax, -1

; 566  : }

	ret	4
?GetCityYieldChange@CvBeliefEntry@@QBEHH@Z ENDP		; CvBeliefEntry::GetCityYieldChange
_TEXT	ENDS
PUBLIC	?GetHolyCityYieldChange@CvBeliefEntry@@QBEHH@Z	; CvBeliefEntry::GetHolyCityYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetHolyCityYieldChange@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetHolyCityYieldChange@CvBeliefEntry@@QBEHH@Z PROC	; CvBeliefEntry::GetHolyCityYieldChange, COMDAT
; _this$ = ecx

; 571  : 	return m_paiHolyCityYieldChange ? m_paiHolyCityYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+504]
	test	eax, eax
	je	SHORT $LN3@GetHolyCit
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 572  : }

	ret	4
$LN3@GetHolyCit:

; 571  : 	return m_paiHolyCityYieldChange ? m_paiHolyCityYieldChange[i] : -1;

	or	eax, -1

; 572  : }

	ret	4
?GetHolyCityYieldChange@CvBeliefEntry@@QBEHH@Z ENDP	; CvBeliefEntry::GetHolyCityYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangePerForeignCity@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangePerForeignCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerForeignCity@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangePerForeignCity@CvBeliefEntry@@QBEHH@Z PROC ; CvBeliefEntry::GetYieldChangePerForeignCity, COMDAT
; _this$ = ecx

; 577  : 	return m_paiYieldChangePerForeignCity ? m_paiYieldChangePerForeignCity[i] : -1;

	mov	eax, DWORD PTR [ecx+508]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 578  : }

	ret	4
$LN3@GetYieldCh:

; 577  : 	return m_paiYieldChangePerForeignCity ? m_paiYieldChangePerForeignCity[i] : -1;

	or	eax, -1

; 578  : }

	ret	4
?GetYieldChangePerForeignCity@CvBeliefEntry@@QBEHH@Z ENDP ; CvBeliefEntry::GetYieldChangePerForeignCity
_TEXT	ENDS
PUBLIC	?GetYieldChangePerXForeignFollowers@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangePerXForeignFollowers
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerXForeignFollowers@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangePerXForeignFollowers@CvBeliefEntry@@QBEHH@Z PROC ; CvBeliefEntry::GetYieldChangePerXForeignFollowers, COMDAT
; _this$ = ecx

; 583  : 	return m_paiYieldChangePerXForeignFollowers ? m_paiYieldChangePerXForeignFollowers[i] : -1;

	mov	eax, DWORD PTR [ecx+512]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 584  : }

	ret	4
$LN3@GetYieldCh@2:

; 583  : 	return m_paiYieldChangePerXForeignFollowers ? m_paiYieldChangePerXForeignFollowers[i] : -1;

	or	eax, -1

; 584  : }

	ret	4
?GetYieldChangePerXForeignFollowers@CvBeliefEntry@@QBEHH@Z ENDP ; CvBeliefEntry::GetYieldChangePerXForeignFollowers
_TEXT	ENDS
PUBLIC	?GetResourceQuantityModifier@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetResourceQuantityModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceQuantityModifier@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceQuantityModifier@CvBeliefEntry@@QBEHH@Z PROC ; CvBeliefEntry::GetResourceQuantityModifier, COMDAT
; _this$ = ecx

; 589  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 590  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 591  : 	return m_piResourceQuantityModifiers ? m_piResourceQuantityModifiers[i] : -1;

	mov	eax, DWORD PTR [ecx+516]
	test	eax, eax
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 592  : }

	ret	4
$LN3@GetResourc:

; 589  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 590  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 591  : 	return m_piResourceQuantityModifiers ? m_piResourceQuantityModifiers[i] : -1;

	or	eax, -1

; 592  : }

	ret	4
?GetResourceQuantityModifier@CvBeliefEntry@@QBEHH@Z ENDP ; CvBeliefEntry::GetResourceQuantityModifier
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvBeliefEntry::GetImprovementYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvBeliefEntry::GetImprovementYieldChange, COMDAT
; _this$ = ecx

; 597  : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "Index out of bounds");
; 598  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 599  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 600  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 601  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 602  : 	return m_ppiImprovementYieldChanges.first ? m_ppiImprovementYieldChanges.first[eIndex1][eIndex2] : 0;
; 603  : #else
; 604  : 	return m_ppiImprovementYieldChanges ? m_ppiImprovementYieldChanges[eIndex1][eIndex2] : 0;

	mov	eax, DWORD PTR [ecx+520]
	test	eax, eax
	je	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _eIndex1$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eIndex2$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 605  : #endif
; 606  : }

	ret	8
$LN3@GetImprove:

; 597  : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "Index out of bounds");
; 598  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 599  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 600  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 601  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 602  : 	return m_ppiImprovementYieldChanges.first ? m_ppiImprovementYieldChanges.first[eIndex1][eIndex2] : 0;
; 603  : #else
; 604  : 	return m_ppiImprovementYieldChanges ? m_ppiImprovementYieldChanges[eIndex1][eIndex2] : 0;

	xor	eax, eax

; 605  : #endif
; 606  : }

	ret	8
?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvBeliefEntry::GetImprovementYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetBuildingClassYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassYieldChange@CvBeliefEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetBuildingClassYieldChange@CvBeliefEntry@@QBEHHH@Z PROC ; CvBeliefEntry::GetBuildingClassYieldChange, COMDAT
; _this$ = ecx

; 611  : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 612  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 613  : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 614  : 	CvAssertMsg(j > -1, "Index out of bounds");
; 615  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 616  : 	return m_ppiBuildingClassYieldChanges.first ? m_ppiBuildingClassYieldChanges.first[i][j] : 0;
; 617  : #else
; 618  : 	return m_ppiBuildingClassYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+524]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 619  : #endif
; 620  : }

	ret	8
?GetBuildingClassYieldChange@CvBeliefEntry@@QBEHHH@Z ENDP ; CvBeliefEntry::GetBuildingClassYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassHappiness@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetBuildingClassHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassHappiness@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassHappiness@CvBeliefEntry@@QBEHH@Z PROC	; CvBeliefEntry::GetBuildingClassHappiness, COMDAT
; _this$ = ecx

; 642  : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 643  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 644  : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	mov	eax, DWORD PTR [ecx+528]
	test	eax, eax
	je	SHORT $LN3@GetBuildin
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 645  : }

	ret	4
$LN3@GetBuildin:

; 642  : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 643  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 644  : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	or	eax, -1

; 645  : }

	ret	4
?GetBuildingClassHappiness@CvBeliefEntry@@QBEHH@Z ENDP	; CvBeliefEntry::GetBuildingClassHappiness
_TEXT	ENDS
PUBLIC	?GetBuildingClassTourism@CvBeliefEntry@@QBEHH@Z	; CvBeliefEntry::GetBuildingClassTourism
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassTourism@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassTourism@CvBeliefEntry@@QBEHH@Z PROC	; CvBeliefEntry::GetBuildingClassTourism, COMDAT
; _this$ = ecx

; 650  : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 651  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 652  : 	return m_paiBuildingClassTourism ? m_paiBuildingClassTourism[i] : -1;

	mov	eax, DWORD PTR [ecx+532]
	test	eax, eax
	je	SHORT $LN3@GetBuildin@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 653  : }

	ret	4
$LN3@GetBuildin@2:

; 650  : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 651  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 652  : 	return m_paiBuildingClassTourism ? m_paiBuildingClassTourism[i] : -1;

	or	eax, -1

; 653  : }

	ret	4
?GetBuildingClassTourism@CvBeliefEntry@@QBEHH@Z ENDP	; CvBeliefEntry::GetBuildingClassTourism
_TEXT	ENDS
PUBLIC	?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z	; CvBeliefEntry::GetFeatureYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z PROC	; CvBeliefEntry::GetFeatureYieldChange, COMDAT
; _this$ = ecx

; 658  : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 659  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 660  : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 661  : 	CvAssertMsg(j > -1, "Index out of bounds");
; 662  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 663  : 	return m_ppaiFeatureYieldChange.first ? m_ppaiFeatureYieldChange.first[i][j] : -1;
; 664  : #else
; 665  : 	return m_ppaiFeatureYieldChange ? m_ppaiFeatureYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+536]
	test	eax, eax
	je	SHORT $LN3@GetFeature
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 666  : #endif
; 667  : }

	ret	8
$LN3@GetFeature:

; 658  : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 659  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 660  : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 661  : 	CvAssertMsg(j > -1, "Index out of bounds");
; 662  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 663  : 	return m_ppaiFeatureYieldChange.first ? m_ppaiFeatureYieldChange.first[i][j] : -1;
; 664  : #else
; 665  : 	return m_ppaiFeatureYieldChange ? m_ppaiFeatureYieldChange[i][j] : -1;

	or	eax, -1

; 666  : #endif
; 667  : }

	ret	8
?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z ENDP	; CvBeliefEntry::GetFeatureYieldChange
_TEXT	ENDS
PUBLIC	?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z	; CvBeliefEntry::GetResourceYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z PROC	; CvBeliefEntry::GetResourceYieldChange, COMDAT
; _this$ = ecx

; 672  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 673  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 674  : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 675  : 	CvAssertMsg(j > -1, "Index out of bounds");
; 676  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 677  : 	return m_ppaiResourceYieldChange.first ? m_ppaiResourceYieldChange.first[i][j] : -1;
; 678  : #else
; 679  : 	return m_ppaiResourceYieldChange ? m_ppaiResourceYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+540]
	test	eax, eax
	je	SHORT $LN3@GetResourc@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 680  : #endif
; 681  : }

	ret	8
$LN3@GetResourc@2:

; 672  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 673  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 674  : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 675  : 	CvAssertMsg(j > -1, "Index out of bounds");
; 676  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 677  : 	return m_ppaiResourceYieldChange.first ? m_ppaiResourceYieldChange.first[i][j] : -1;
; 678  : #else
; 679  : 	return m_ppaiResourceYieldChange ? m_ppaiResourceYieldChange[i][j] : -1;

	or	eax, -1

; 680  : #endif
; 681  : }

	ret	8
?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z ENDP	; CvBeliefEntry::GetResourceYieldChange
_TEXT	ENDS
PUBLIC	?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z	; CvBeliefEntry::GetTerrainYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z PROC	; CvBeliefEntry::GetTerrainYieldChange, COMDAT
; _this$ = ecx

; 686  : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 687  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 688  : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 689  : 	CvAssertMsg(j > -1, "Index out of bounds");
; 690  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 691  : 	return m_ppaiTerrainYieldChange.first ? m_ppaiTerrainYieldChange.first[i][j] : -1;
; 692  : #else
; 693  : 	return m_ppaiTerrainYieldChange ? m_ppaiTerrainYieldChange[i][j] : -1;

	mov	eax, DWORD PTR [ecx+544]
	test	eax, eax
	je	SHORT $LN3@GetTerrain
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 694  : #endif
; 695  : }

	ret	8
$LN3@GetTerrain:

; 686  : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 687  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 688  : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 689  : 	CvAssertMsg(j > -1, "Index out of bounds");
; 690  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 691  : 	return m_ppaiTerrainYieldChange.first ? m_ppaiTerrainYieldChange.first[i][j] : -1;
; 692  : #else
; 693  : 	return m_ppaiTerrainYieldChange ? m_ppaiTerrainYieldChange[i][j] : -1;

	or	eax, -1

; 694  : #endif
; 695  : }

	ret	8
?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z ENDP	; CvBeliefEntry::GetTerrainYieldChange
_TEXT	ENDS
PUBLIC	?GetResourceHappiness@CvBeliefEntry@@QBEHH@Z	; CvBeliefEntry::GetResourceHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceHappiness@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceHappiness@CvBeliefEntry@@QBEHH@Z PROC	; CvBeliefEntry::GetResourceHappiness, COMDAT
; _this$ = ecx

; 700  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 701  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 702  : 	return m_piResourceHappiness ? m_piResourceHappiness[i] : -1;

	mov	eax, DWORD PTR [ecx+548]
	test	eax, eax
	je	SHORT $LN3@GetResourc@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 703  : }

	ret	4
$LN3@GetResourc@3:

; 700  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 701  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 702  : 	return m_piResourceHappiness ? m_piResourceHappiness[i] : -1;

	or	eax, -1

; 703  : }

	ret	4
?GetResourceHappiness@CvBeliefEntry@@QBEHH@Z ENDP	; CvBeliefEntry::GetResourceHappiness
_TEXT	ENDS
PUBLIC	?GetYieldChangeAnySpecialist@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangeAnySpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeAnySpecialist@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeAnySpecialist@CvBeliefEntry@@QBEHH@Z PROC ; CvBeliefEntry::GetYieldChangeAnySpecialist, COMDAT
; _this$ = ecx

; 708  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 709  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 710  : 	return m_piYieldChangeAnySpecialist ? m_piYieldChangeAnySpecialist[i] : -1;

	mov	eax, DWORD PTR [ecx+552]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 711  : }

	ret	4
$LN3@GetYieldCh@3:

; 708  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 709  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 710  : 	return m_piYieldChangeAnySpecialist ? m_piYieldChangeAnySpecialist[i] : -1;

	or	eax, -1

; 711  : }

	ret	4
?GetYieldChangeAnySpecialist@CvBeliefEntry@@QBEHH@Z ENDP ; CvBeliefEntry::GetYieldChangeAnySpecialist
_TEXT	ENDS
PUBLIC	?GetYieldChangeTradeRoute@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangeTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeTradeRoute@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeTradeRoute@CvBeliefEntry@@QBEHH@Z PROC	; CvBeliefEntry::GetYieldChangeTradeRoute, COMDAT
; _this$ = ecx

; 716  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 717  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 718  : 	return m_piYieldChangeTradeRoute ? m_piYieldChangeTradeRoute[i] : -1;

	mov	eax, DWORD PTR [ecx+556]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@4
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 719  : }

	ret	4
$LN3@GetYieldCh@4:

; 716  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 717  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 718  : 	return m_piYieldChangeTradeRoute ? m_piYieldChangeTradeRoute[i] : -1;

	or	eax, -1

; 719  : }

	ret	4
?GetYieldChangeTradeRoute@CvBeliefEntry@@QBEHH@Z ENDP	; CvBeliefEntry::GetYieldChangeTradeRoute
_TEXT	ENDS
PUBLIC	?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangeNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z PROC ; CvBeliefEntry::GetYieldChangeNaturalWonder, COMDAT
; _this$ = ecx

; 724  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 725  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 726  : 	return m_piYieldChangeNaturalWonder ? m_piYieldChangeNaturalWonder[i] : -1;

	mov	eax, DWORD PTR [ecx+560]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@5
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 727  : }

	ret	4
$LN3@GetYieldCh@5:

; 724  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 725  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 726  : 	return m_piYieldChangeNaturalWonder ? m_piYieldChangeNaturalWonder[i] : -1;

	or	eax, -1

; 727  : }

	ret	4
?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z ENDP ; CvBeliefEntry::GetYieldChangeNaturalWonder
_TEXT	ENDS
PUBLIC	?GetYieldChangeWorldWonder@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangeWorldWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeWorldWonder@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangeWorldWonder@CvBeliefEntry@@QBEHH@Z PROC	; CvBeliefEntry::GetYieldChangeWorldWonder, COMDAT
; _this$ = ecx

; 732  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 733  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 734  : 	return m_piYieldChangeWorldWonder ? m_piYieldChangeWorldWonder[i] : -1;

	mov	eax, DWORD PTR [ecx+564]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@6
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 735  : }

	ret	4
$LN3@GetYieldCh@6:

; 732  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 733  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 734  : 	return m_piYieldChangeWorldWonder ? m_piYieldChangeWorldWonder[i] : -1;

	or	eax, -1

; 735  : }

	ret	4
?GetYieldChangeWorldWonder@CvBeliefEntry@@QBEHH@Z ENDP	; CvBeliefEntry::GetYieldChangeWorldWonder
_TEXT	ENDS
PUBLIC	?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldModifierNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z PROC ; CvBeliefEntry::GetYieldModifierNaturalWonder, COMDAT
; _this$ = ecx

; 740  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 741  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 742  : 	return m_piYieldModifierNaturalWonder ? m_piYieldModifierNaturalWonder[i] : -1;

	mov	eax, DWORD PTR [ecx+568]
	test	eax, eax
	je	SHORT $LN3@GetYieldMo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 743  : }

	ret	4
$LN3@GetYieldMo:

; 740  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 741  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 742  : 	return m_piYieldModifierNaturalWonder ? m_piYieldModifierNaturalWonder[i] : -1;

	or	eax, -1

; 743  : }

	ret	4
?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z ENDP ; CvBeliefEntry::GetYieldModifierNaturalWonder
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File s:\msvs2008\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?GetMaxYieldModifierPerFollower@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetMaxYieldModifierPerFollower
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
;	COMDAT ?GetMaxYieldModifierPerFollower@CvBeliefEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetMaxYieldModifierPerFollower@CvBeliefEntry@@QBEHH@Z PROC ; CvBeliefEntry::GetMaxYieldModifierPerFollower, COMDAT
; _this$ = ecx

; 748  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 749  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 750  : 	return m_piMaxYieldModifierPerFollower ? m_piMaxYieldModifierPerFollower[i] : -1;

	mov	eax, DWORD PTR [ecx+572]
	test	eax, eax
	je	SHORT $LN3@GetMaxYiel
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 751  : }

	ret	4
$LN3@GetMaxYiel:

; 748  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 749  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 750  : 	return m_piMaxYieldModifierPerFollower ? m_piMaxYieldModifierPerFollower[i] : -1;

	or	eax, -1

; 751  : }

	ret	4
?GetMaxYieldModifierPerFollower@CvBeliefEntry@@QBEHH@Z ENDP ; CvBeliefEntry::GetMaxYieldModifierPerFollower
_TEXT	ENDS
PUBLIC	?IsFaithUnitPurchaseEra@CvBeliefEntry@@QBE_NH@Z	; CvBeliefEntry::IsFaithUnitPurchaseEra
; Function compile flags: /Ogtpy
;	COMDAT ?IsFaithUnitPurchaseEra@CvBeliefEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsFaithUnitPurchaseEra@CvBeliefEntry@@QBE_NH@Z PROC	; CvBeliefEntry::IsFaithUnitPurchaseEra, COMDAT
; _this$ = ecx

; 756  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 757  : 	CvAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
; 758  : 	return m_pbFaithPurchaseUnitEraEnabled ? m_pbFaithPurchaseUnitEraEnabled[i] : false;

	mov	eax, DWORD PTR [ecx+576]
	test	eax, eax
	je	SHORT $LN3@IsFaithUni
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 759  : }

	ret	4
$LN3@IsFaithUni:

; 756  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 757  : 	CvAssertMsg(i < GC.getNumEraInfos(), "Index out of bounds");
; 758  : 	return m_pbFaithPurchaseUnitEraEnabled ? m_pbFaithPurchaseUnitEraEnabled[i] : false;

	xor	al, al

; 759  : }

	ret	4
?IsFaithUnitPurchaseEra@CvBeliefEntry@@QBE_NH@Z ENDP	; CvBeliefEntry::IsFaithUnitPurchaseEra
_TEXT	ENDS
PUBLIC	?IsBuildingClassEnabled@CvBeliefEntry@@QBE_NH@Z	; CvBeliefEntry::IsBuildingClassEnabled
; Function compile flags: /Ogtpy
;	COMDAT ?IsBuildingClassEnabled@CvBeliefEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsBuildingClassEnabled@CvBeliefEntry@@QBE_NH@Z PROC	; CvBeliefEntry::IsBuildingClassEnabled, COMDAT
; _this$ = ecx

; 764  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 765  : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 766  : 	return m_pbBuildingClassEnabled ? m_pbBuildingClassEnabled[i] : false;

	mov	eax, DWORD PTR [ecx+580]
	test	eax, eax
	je	SHORT $LN3@IsBuilding
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 767  : }

	ret	4
$LN3@IsBuilding:

; 764  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 765  : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 766  : 	return m_pbBuildingClassEnabled ? m_pbBuildingClassEnabled[i] : false;

	xor	al, al

; 767  : }

	ret	4
?IsBuildingClassEnabled@CvBeliefEntry@@QBE_NH@Z ENDP	; CvBeliefEntry::IsBuildingClassEnabled
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ ; CvBeliefXMLEntries::GetBeliefEntries
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
;	COMDAT ?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ PROC ; CvBeliefXMLEntries::GetBeliefEntries, COMDAT
; _this$ = ecx

; 1099 : {

	mov	eax, ecx

; 1100 : 	return m_paBeliefEntries;
; 1101 : }

	ret	0
?GetBeliefEntries@CvBeliefXMLEntries@@QAEAAV?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@XZ ENDP ; CvBeliefXMLEntries::GetBeliefEntries
_TEXT	ENDS
PUBLIC	?IsBuildingClassEnabled@CvReligionBeliefs@@QBE_NW4BuildingClassTypes@@@Z ; CvReligionBeliefs::IsBuildingClassEnabled
; Function compile flags: /Ogtpy
;	COMDAT ?IsBuildingClassEnabled@CvReligionBeliefs@@QBE_NW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?IsBuildingClassEnabled@CvReligionBeliefs@@QBE_NW4BuildingClassTypes@@@Z PROC ; CvReligionBeliefs::IsBuildingClassEnabled, COMDAT
; _this$ = ecx

; 1991 : 	return m_paiBuildingClassEnabled[(int)eType];

	mov	eax, DWORD PTR [ecx+172]
	mov	ecx, DWORD PTR _eType$[esp-4]
	cmp	DWORD PTR [eax+ecx*4], 0
	setne	al

; 1992 : }

	ret	4
?IsBuildingClassEnabled@CvReligionBeliefs@@QBE_NW4BuildingClassTypes@@@Z ENDP ; CvReligionBeliefs::IsBuildingClassEnabled
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAPAVCvBeliefEntry@@I@Z ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$0A@@@QBEABHI@Z		; BaseVector<int,0>::operator[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$0A@@@QBEABHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$0A@@@QBEABHI@Z PROC			; BaseVector<int,0>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@H$0A@@@QBEABHI@Z ENDP			; BaseVector<int,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$0A@@@QBEIXZ		; BaseVector<int,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$0A@@@QBEIXZ PROC			; BaseVector<int,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$0A@@@QBEIXZ ENDP			; BaseVector<int,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@H$0A@@@QBEPBHXZ		; BaseVector<int,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@H$0A@@@QBEPBHXZ
_TEXT	SEGMENT
?begin@?$BaseVector@H$0A@@@QBEPBHXZ PROC		; BaseVector<int,0>::begin, COMDAT
; _this$ = ecx

; 201  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 202  :     };

	ret	0
?begin@?$BaseVector@H$0A@@@QBEPBHXZ ENDP		; BaseVector<int,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@H$0A@@@QBEPBHXZ		; BaseVector<int,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@H$0A@@@QBEPBHXZ
_TEXT	SEGMENT
?end@?$BaseVector@H$0A@@@QBEPBHXZ PROC			; BaseVector<int,0>::end, COMDAT
; _this$ = ecx

; 204  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*4]

; 205  :     };

	ret	0
?end@?$BaseVector@H$0A@@@QBEPBHXZ ENDP			; BaseVector<int,0>::end
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@XZ	; std::allocator<CvBeliefEntry *>::allocator<CvBeliefEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@XZ PROC	; std::allocator<CvBeliefEntry *>::allocator<CvBeliefEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvBeliefEntry *>::allocator<CvBeliefEntry *>
_TEXT	ENDS
PUBLIC	??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEPAHI@Z ; FStaticVector<int,5,0,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ DB 's:\github\l'
	DB	'ekmod\lekmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEPAHI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEPAHI@Z PROC ; FStaticVector<int,5,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 5
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 5
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEPAHI@Z ENDP ; FStaticVector<int,5,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$0A@@@QAE@XZ			; BaseVector<int,0>::~BaseVector<int,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@H$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@H$0A@@@QAE@XZ PROC			; BaseVector<int,0>::~BaseVector<int,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@H$0A@@@QAE@XZ ENDP			; BaseVector<int,0>::~BaseVector<int,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@H$0A@@@IAE@XZ			; BaseVector<int,0>::BaseVector<int,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@H$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@H$0A@@@IAE@XZ PROC			; BaseVector<int,0>::BaseVector<int,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@H$0A@@@IAE@XZ ENDP			; BaseVector<int,0>::BaseVector<int,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z		; BaseVector<int,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z PROC		; BaseVector<int,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z ENDP		; BaseVector<int,0>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@H$0A@@@IAEXABV1@@Z		; BaseVector<int,0>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@H$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@H$0A@@@IAEXABV1@@Z PROC		; BaseVector<int,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	esi
	push	edi

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	edi, DWORD PTR _RHS$[esp+4]
	mov	eax, DWORD PTR [edi+4]

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);
; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	xor	esi, esi
	mov	DWORD PTR [ecx+4], eax
	test	eax, eax
	jbe	SHORT $LN1@Copy
	push	ebx
$LL3@Copy:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi*4]
	add	eax, edx

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	je	SHORT $LN2@Copy
	mov	ebx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+ebx]
	mov	DWORD PTR [eax], edx
$LN2@Copy:
	inc	esi
	cmp	esi, DWORD PTR [ecx+4]
	jb	SHORT $LL3@Copy
	pop	ebx
$LN1@Copy:
	pop	edi
	pop	esi

; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@H$0A@@@IAEXABV1@@Z ENDP		; BaseVector<int,0>::Copy
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEABQAVCvBeliefEntry@@XZ ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEABQAVCvBeliefEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEABQAVCvBeliefEntry@@XZ PROC ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEABQAVCvBeliefEntry@@XZ ENDP ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220635 = -80						; size = 28
$T220634 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220635[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T220634[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T220635[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T220634[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T220634[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220634[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T220634[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220635[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220634[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvBeliefEntry *>::allocator<CvBeliefEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvBeliefEntry *>::allocator<CvBeliefEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvBeliefEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvBeliefEntry *>::allocator<CvBeliefEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEXPAPAVCvBeliefEntry@@I@Z ; std::allocator<CvBeliefEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEXPAPAVCvBeliefEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEXPAPAVCvBeliefEntry@@I@Z PROC ; std::allocator<CvBeliefEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEXPAPAVCvBeliefEntry@@I@Z ENDP ; std::allocator<CvBeliefEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z PROC ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z ENDP ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvBeliefEntry@@@std@@QBEIXZ ; std::allocator<CvBeliefEntry *>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvBeliefEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvBeliefEntry@@@std@@QBEIXZ PROC ; std::allocator<CvBeliefEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvBeliefEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvBeliefEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvBeliefEntry@@@std@@YAPAPAVCvBeliefEntry@@IPAPAV1@@Z ; std::_Allocate<CvBeliefEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvBeliefEntry@@@std@@YAPAPAVCvBeliefEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T220681 = -12						; size = 12
$T220685 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvBeliefEntry@@@std@@YAPAPAVCvBeliefEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvBeliefEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T220685[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T220681[esp+16]
	mov	DWORD PTR $T220685[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220681[esp+16]
	push	ecx
	mov	DWORD PTR $T220681[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvBeliefEntry@@@std@@YAPAPAVCvBeliefEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvBeliefEntry *>
_TEXT	ENDS
PUBLIC	??$_Find@PBHH@std@@YAPBHPBH0ABH@Z		; std::_Find<int const *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Find@PBHH@std@@YAPBHPBH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find@PBHH@std@@YAPBHPBH0ABH@Z PROC			; std::_Find<int const *,int>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN8@Find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Find:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN8@Find
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL4@Find
$LN8@Find:

; 41   : 			break;
; 42   : 	return (_First);
; 43   : 	}

	ret	0
??$_Find@PBHH@std@@YAPBHPBH0ABH@Z ENDP			; std::_Find<int const *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBeliefEntry@@0@Z ; std::_Iter_random<CvBeliefEntry * *,CvBeliefEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBeliefEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBeliefEntry@@0@Z PROC ; std::_Iter_random<CvBeliefEntry * *,CvBeliefEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvBeliefEntry@@0@Z ENDP ; std::_Iter_random<CvBeliefEntry * *,CvBeliefEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBeliefEntry@@0@Z ; std::_Ptr_cat<CvBeliefEntry * *,CvBeliefEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBeliefEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBeliefEntry@@0@Z PROC ; std::_Ptr_cat<CvBeliefEntry * *,CvBeliefEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvBeliefEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvBeliefEntry@@0@Z ENDP ; std::_Ptr_cat<CvBeliefEntry * *,CvBeliefEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvBeliefEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBeliefEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvBeliefEntry * *,CvBeliefEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvBeliefEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBeliefEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvBeliefEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBeliefEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvBeliefEntry * *,CvBeliefEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvBeliefEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvBeliefEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvBeliefEntry * *,CvBeliefEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBeliefEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT, COMDAT
; _this$ = ecx

; 7355 : 		return m_iBARBARIAN_CAMP_IMPROVEMENT;

	mov	eax, DWORD PTR [ecx+8548]

; 7356 : 	}

	ret	0
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T220809 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T220809[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T220809[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T220809[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T220809[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvBeliefEntry@@6B@				; CvBeliefEntry::`vftable'
PUBLIC	??1CvBeliefEntry@@QAE@XZ			; CvBeliefEntry::~CvBeliefEntry
PUBLIC	??_R4CvBeliefEntry@@6B@				; CvBeliefEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvBeliefEntry@@@8			; CvBeliefEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvBeliefEntry@@8				; CvBeliefEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBeliefEntry@@8				; CvBeliefEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvBeliefEntry@@8			; CvBeliefEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBeliefEntry::CacheResults
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBeliefEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBeliefEntry@@8 DD FLAT:??_R0?AVCvBeliefEntry@@@8 ; CvBeliefEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBeliefEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvBeliefEntry@@8
rdata$r	SEGMENT
??_R2CvBeliefEntry@@8 DD FLAT:??_R1A@?0A@EA@CvBeliefEntry@@8 ; CvBeliefEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvBeliefEntry@@8
rdata$r	SEGMENT
??_R3CvBeliefEntry@@8 DD 00H				; CvBeliefEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvBeliefEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBeliefEntry@@@8
_DATA	SEGMENT
??_R0?AVCvBeliefEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvBeliefEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBeliefEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvBeliefEntry@@6B@
rdata$r	SEGMENT
??_R4CvBeliefEntry@@6B@ DD 00H				; CvBeliefEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvBeliefEntry@@@8
	DD	FLAT:??_R3CvBeliefEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvBeliefEntry@@6B@
CONST	SEGMENT
??_7CvBeliefEntry@@6B@ DD FLAT:??_R4CvBeliefEntry@@6B@	; CvBeliefEntry::`vftable'
	DD	FLAT:?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvBeliefEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBeliefEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBeliefEntry@@QAE@XZ$1
__ehfuncinfo$??1CvBeliefEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvBeliefEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvBeliefEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBeliefEntry@@QAE@XZ PROC				; CvBeliefEntry::~CvBeliefEntry, COMDAT
; _this$ = ecx

; 148  : {

	push	-1
	push	__ehhandler$??1CvBeliefEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvBeliefEntry@@6B@

; 149  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 150  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges.first, m_ppiImprovementYieldChanges.second);
; 151  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges.first, m_ppiBuildingClassYieldChanges.second);
; 152  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 153  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassFlavorChanges.first, m_ppiBuildingClassFlavorChanges.second);
; 154  : #endif
; 155  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiFeatureYieldChange.first, m_ppaiFeatureYieldChange.second);
; 156  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldChange.first, m_ppaiResourceYieldChange.second);
; 157  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiTerrainYieldChange.first, m_ppaiTerrainYieldChange.second);
; 158  : #else
; 159  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges);

	lea	eax, DWORD PTR [esi+520]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 1
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 160  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges);

	lea	ecx, DWORD PTR [esi+524]
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 161  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 162  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassFlavorChanges);
; 163  : #endif
; 164  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiFeatureYieldChange);

	lea	edx, DWORD PTR [esi+536]
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 165  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldChange);

	lea	eax, DWORD PTR [esi+540]
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray

; 166  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiTerrainYieldChange);

	lea	ecx, DWORD PTR [esi+544]
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 20					; 00000014H

; 167  : #endif
; 168  : }

	lea	ecx, DWORD PTR [esi+472]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBeliefEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvBeliefEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 472				; 000001d8H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBeliefEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBeliefEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBeliefEntry@@QAE@XZ ENDP				; CvBeliefEntry::~CvBeliefEntry
PUBLIC	?getShortDescription@CvBeliefEntry@@QBEPBDXZ	; CvBeliefEntry::getShortDescription
; Function compile flags: /Ogtpy
;	COMDAT ?getShortDescription@CvBeliefEntry@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDescription@CvBeliefEntry@@QBEPBDXZ PROC	; CvBeliefEntry::getShortDescription, COMDAT
; _this$ = ecx

; 553  : 	return m_strShortDescription;

	add	ecx, 472				; 000001d8H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDescription@CvBeliefEntry@@QBEPBDXZ ENDP	; CvBeliefEntry::getShortDescription
_TEXT	ENDS
PUBLIC	?setShortDescription@CvBeliefEntry@@QAEXPBD@Z	; CvBeliefEntry::setShortDescription
; Function compile flags: /Ogtpy
;	COMDAT ?setShortDescription@CvBeliefEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setShortDescription@CvBeliefEntry@@QAEXPBD@Z PROC	; CvBeliefEntry::setShortDescription, COMDAT
; _this$ = ecx

; 559  : 	m_strShortDescription = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 472				; 000001d8H
	test	eax, eax
	je	SHORT $LN4@setShortDe
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setShortDe:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 560  : }

	ret	4
?setShortDescription@CvBeliefEntry@@QAEXPBD@Z ENDP	; CvBeliefEntry::setShortDescription
_TEXT	ENDS
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetFloat@Results@Database@@QAEMPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_YieldID$218604 = -72					; size = 4
_YieldID$218591 = -72					; size = 4
_iYieldID$218578 = -72					; size = 4
_YieldID$218565 = -72					; size = 4
_strKey$218595 = -68					; size = 28
_strKey$218582 = -68					; size = 28
_strKey$218569 = -68					; size = 28
_strKey$218556 = -68					; size = 28
_strKey$218608 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_ResourceID$218603 = 8					; size = 4
_FeatureID$218590 = 8					; size = 4
_BuildingClassID$218577 = 8				; size = 4
_ImprovementID$218564 = 8				; size = 4
_kResults$ = 8						; size = 4
tv1120 = 12						; size = 4
_pResults$218597 = 12					; size = 4
_pResults$218584 = 12					; size = 4
_pResults$218571 = 12					; size = 4
_pResults$218558 = 12					; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvBeliefEntry::CacheResults, COMDAT
; _this$ = ecx

; 771  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebp

; 772  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp+72]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+80]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN16@CacheResul
	pop	edi
	pop	esi
	pop	ebp

; 1078 : 
; 1079 : 	return true;
; 1080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
$LN16@CacheResul:

; 773  : 		return false;
; 774  : 
; 775  : 	//Basic Properties
; 776  : 	setShortDescription(kResults.GetText("ShortDescription"));

	push	OFFSET $SG218431
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	lea	ecx, DWORD PTR [esi+472]
	test	eax, eax
	je	SHORT $LN27@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN26@CacheResul
$LN27@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN26@CacheResul:
	push	ebx

; 777  : 
; 778  : 	m_iMinPopulation                  = kResults.GetInt("MinPopulation");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG218432
	mov	ecx, edi
	call	ebx

; 779  : 	m_iMinFollowers                   = kResults.GetInt("MinFollowers");

	push	OFFSET $SG218433
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 780  : 	m_iMaxDistance					  = kResults.GetInt("MaxDistance");

	push	OFFSET $SG218434
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 781  : 	m_iCityGrowthModifier		      = kResults.GetInt("CityGrowthModifier");

	push	OFFSET $SG218435
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 782  : 	m_iFaithFromKills				  = kResults.GetInt("FaithFromKills");

	push	OFFSET $SG218436
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 783  : 	m_iFaithFromDyingUnits			  = kResults.GetInt("FaithFromDyingUnits");

	push	OFFSET $SG218437
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 784  : 	m_iRiverHappiness				  = kResults.GetInt("RiverHappiness");

	push	OFFSET $SG218438
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 785  : 	m_iHappinessPerCity				  = kResults.GetInt("HappinessPerCity");

	push	OFFSET $SG218439
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 786  : 	m_iHappinessPerXPeacefulForeignFollowers  = kResults.GetInt("HappinessPerXPeacefulForeignFollowers");

	push	OFFSET $SG218440
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 787  : 	m_iPlotCultureCostModifier	      = kResults.GetInt("PlotCultureCostModifier");

	push	OFFSET $SG218441
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 788  : 	m_iCityRangeStrikeModifier	      = kResults.GetInt("CityRangeStrikeModifier");

	push	OFFSET $SG218442
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 789  : 	m_iCombatModifierEnemyCities      = kResults.GetInt("CombatModifierEnemyCities");

	push	OFFSET $SG218443
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 790  : 	m_iCombatModifierFriendlyCities   = kResults.GetInt("CombatModifierFriendlyCities");

	push	OFFSET $SG218444
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 791  : 	m_iFriendlyHealChange	          = kResults.GetInt("FriendlyHealChange");

	push	OFFSET $SG218445
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebx

; 792  : 	m_iCityStateFriendshipModifier    = kResults.GetInt("CityStateFriendshipModifier");

	push	OFFSET $SG218446
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebx

; 793  : 	m_iLandBarbarianConversionPercent = kResults.GetInt("LandBarbarianConversionPercent");

	push	OFFSET $SG218447
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebx

; 794  : 	m_iWonderProductionModifier       = kResults.GetInt("WonderProductionModifier");

	push	OFFSET $SG218448
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebx

; 795  : 	m_iPlayerHappiness			      = kResults.GetInt("PlayerHappiness");

	push	OFFSET $SG218449
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebx

; 796  : 	m_iPlayerCultureModifier          = kResults.GetInt("PlayerCultureModifier");

	push	OFFSET $SG218450
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebx

; 797  : 	m_fHappinessPerFollowingCity      = kResults.GetFloat("HappinessPerFollowingCity");

	push	OFFSET $SG218451
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z

; 798  : 	m_iGoldPerFollowingCity           = kResults.GetInt("GoldPerFollowingCity");

	push	OFFSET $SG218452
	fstp	DWORD PTR [esi+336]
	mov	ecx, edi
	call	ebx

; 799  : 	m_iGoldPerXFollowers              = kResults.GetInt("GoldPerXFollowers");

	push	OFFSET $SG218453
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	ebx

; 800  : 	m_iGoldWhenCityAdopts             = kResults.GetInt("GoldPerFirstCityConversion");

	push	OFFSET $SG218454
	mov	ecx, edi
	mov	DWORD PTR [esi+344], eax
	call	ebx

; 801  : 	m_iSciencePerOtherReligionFollower= kResults.GetInt("SciencePerOtherReligionFollower");

	push	OFFSET $SG218455
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	ebx

; 802  : 	m_iSpreadDistanceModifier         = kResults.GetInt("SpreadDistanceModifier");

	push	OFFSET $SG218456
	mov	ecx, edi
	mov	DWORD PTR [esi+352], eax
	call	ebx

; 803  : 	m_iSpreadStrengthModifier		  = kResults.GetInt("SpreadStrengthModifier");

	push	OFFSET $SG218457
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	ebx

; 804  : 	m_iProphetStrengthModifier        = kResults.GetInt("ProphetStrengthModifier");

	push	OFFSET $SG218458
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	ebx

; 805  : 	m_iProphetCostModifier            = kResults.GetInt("ProphetCostModifier");

	push	OFFSET $SG218459
	mov	ecx, edi
	mov	DWORD PTR [esi+364], eax
	call	ebx

; 806  : 	m_iMissionaryStrengthModifier     = kResults.GetInt("MissionaryStrengthModifier");

	push	OFFSET $SG218460
	mov	ecx, edi
	mov	DWORD PTR [esi+368], eax
	call	ebx

; 807  : #ifdef NQ_FLAT_FAITH_PER_CITIZEN_BORN_FROM_BELIEFS
; 808  : 	m_iFlatFaithPerCitizenBorn        = kResults.GetInt("FlatFaithPerCitizenBorn");

	push	OFFSET $SG218461
	mov	ecx, edi
	mov	DWORD PTR [esi+372], eax
	call	ebx

; 809  : #endif
; 810  : #ifdef NQ_BELIEF_EXTRA_MISSIONARY_SPREADS
; 811  : 	m_iMissionaryExtraSpreads		  = kResults.GetInt("MissionaryExtraSpreads");

	push	OFFSET $SG218462
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	ebx

; 812  : #endif
; 813  : #ifdef NQ_SPREAD_MODIFIER_OWNED_CITIES
; 814  : 	m_iSpreadModifierOwnedCities	  = kResults.GetInt("SpreadModifierOwnedCities");

	push	OFFSET $SG218463
	mov	ecx, edi
	mov	DWORD PTR [esi+380], eax
	call	ebx

; 815  : 	m_iSpreadModifierUnownedCities	  = kResults.GetInt("SpreadModifierUnownedCities");

	push	OFFSET $SG218464
	mov	ecx, edi
	mov	DWORD PTR [esi+384], eax
	call	ebx

; 816  : #endif
; 817  : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 818  : 	m_iExtraTradeRoutes				  = kResults.GetInt("ExtraTradeRoutes");

	push	OFFSET $SG218465
	mov	ecx, edi
	mov	DWORD PTR [esi+388], eax
	call	ebx

; 819  : #endif
; 820  : #ifdef NQ_FAITH_PER_CITY_STATE_THIS_RELIGION
; 821  : 	m_iFaithPerCityStateThisReligion  = kResults.GetInt("FaithPerCityStateThisReligion");

	push	OFFSET $SG218466
	mov	ecx, edi
	mov	DWORD PTR [esi+392], eax
	call	ebx

; 822  : #endif
; 823  : #ifdef NQ_FAITH_PER_FOREIGN_TRADE_ROUTE
; 824  : 	m_iFaithPerForeignTradeRoute	  = kResults.GetInt("FaithPerForeignTradeRoute");

	push	OFFSET $SG218467
	mov	ecx, edi
	mov	DWORD PTR [esi+396], eax
	call	ebx

; 825  : #endif
; 826  : #ifdef NQ_GOLDEN_AGE_TURNS_FROM_BELIEF
; 827  : 	m_iGoldenAgeTurns				  = kResults.GetInt("GoldenAgeTurns");

	push	OFFSET $SG218468
	mov	ecx, edi
	mov	DWORD PTR [esi+400], eax
	call	ebx

; 828  : #endif
; 829  : 	m_iMissionaryCostModifier         = kResults.GetInt("MissionaryCostModifier");

	push	OFFSET $SG218469
	mov	ecx, edi
	mov	DWORD PTR [esi+404], eax
	call	ebx

; 830  : 	m_iFriendlyCityStateSpreadModifier= kResults.GetInt("FriendlyCityStateSpreadModifier");

	push	OFFSET $SG218470
	mov	ecx, edi
	mov	DWORD PTR [esi+408], eax
	call	ebx

; 831  : 	m_iGreatPersonExpendedFaith       = kResults.GetInt("GreatPersonExpendedFaith");

	push	OFFSET $SG218471
	mov	ecx, edi
	mov	DWORD PTR [esi+412], eax
	call	ebx
	mov	DWORD PTR [esi+416], eax

; 832  : 	m_iCityStateMinimumInfluence      = kResults.GetInt("CityStateMinimumInfluence");

	push	OFFSET $SG218472
	mov	ecx, edi
	call	ebx

; 833  : 	m_iCityStateInfluenceModifier     = kResults.GetInt("CityStateInfluenceModifier");

	push	OFFSET $SG218473
	mov	ecx, edi
	mov	DWORD PTR [esi+420], eax
	call	ebx

; 834  : 	m_iOtherReligionPressureErosion   = kResults.GetInt("OtherReligionPressureErosion");

	push	OFFSET $SG218474
	mov	ecx, edi
	mov	DWORD PTR [esi+424], eax
	call	ebx

; 835  : 	m_iSpyPressure					  = kResults.GetInt("SpyPressure");

	push	OFFSET $SG218475
	mov	ecx, edi
	mov	DWORD PTR [esi+428], eax
	call	ebx

; 836  : 	m_iInquisitorPressureRetention    = kResults.GetInt("InquisitorPressureRetention");

	push	OFFSET $SG218476
	mov	ecx, edi
	mov	DWORD PTR [esi+432], eax
	call	ebx

; 837  : 	m_iFaithBuildingTourism           = kResults.GetInt("FaithBuildingTourism");

	push	OFFSET $SG218477
	mov	ecx, edi
	mov	DWORD PTR [esi+436], eax
	call	ebx

; 838  : #ifdef NQ_FREE_SETTLERS_FROM_BELIEF
; 839  : 	m_iNumFreeSettlers				  = kResults.GetInt("NumFreeSettlers");

	push	OFFSET $SG218478
	mov	ecx, edi
	mov	DWORD PTR [esi+440], eax
	call	ebx

; 840  : #endif
; 841  : 
; 842  : 	m_bPantheon						  = kResults.GetBool("Pantheon");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG218479
	mov	ecx, edi
	mov	DWORD PTR [esi+444], eax
	call	ebx

; 843  : 	m_bFounder						  = kResults.GetBool("Founder");

	push	OFFSET $SG218480
	mov	ecx, edi
	mov	BYTE PTR [esi+448], al
	call	ebx

; 844  : 	m_bFollower						  = kResults.GetBool("Follower");

	push	OFFSET $SG218481
	mov	ecx, edi
	mov	BYTE PTR [esi+449], al
	call	ebx

; 845  : 	m_bEnhancer						  = kResults.GetBool("Enhancer");

	push	OFFSET $SG218482
	mov	ecx, edi
	mov	BYTE PTR [esi+450], al
	call	ebx

; 846  : 	m_bReformer						  = kResults.GetBool("Reformation");

	push	OFFSET $SG218483
	mov	ecx, edi
	mov	BYTE PTR [esi+451], al
	call	ebx

; 847  : 	m_bRequiresPeace				  = kResults.GetBool("RequiresPeace");

	push	OFFSET $SG218484
	mov	ecx, edi
	mov	BYTE PTR [esi+452], al
	call	ebx

; 848  : 	m_bConvertsBarbarians			  = kResults.GetBool("ConvertsBarbarians");

	push	OFFSET $SG218485
	mov	ecx, edi
	mov	BYTE PTR [esi+453], al
	call	ebx

; 849  : #ifdef NQ_DEUS_VULT
; 850  : 	m_bDeusVult						  = kResults.GetBool("DeusVult");

	push	OFFSET $SG218486
	mov	ecx, edi
	mov	BYTE PTR [esi+454], al
	call	ebx

; 851  : #endif
; 852  : 	m_bFaithPurchaseAllGreatPeople	  = kResults.GetBool("FaithPurchaseAllGreatPeople");

	push	OFFSET $SG218487
	mov	ecx, edi
	mov	BYTE PTR [esi+455], al
	call	ebx

; 853  : #ifdef NQ_BELIEF_TOGGLE_ALLOW_FAITH_GIFTS_TO_MINORS
; 854  : 	m_bAllowsFaithGiftsToMinors       = kResults.GetBool("AllowsFaithGiftsToMinors");

	push	OFFSET $SG218488
	mov	ecx, edi
	mov	BYTE PTR [esi+456], al
	call	ebx

; 855  : #endif
; 856  : 
; 857  : 	//References
; 858  : 	const char* szTextVal;
; 859  : 	szTextVal						  = kResults.GetText("ObsoleteEra");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG218490
	mov	ecx, edi
	mov	BYTE PTR [esi+457], al
	call	ebx

; 860  : 	m_eObsoleteEra					  = (EraTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 861  : 	szTextVal						  = kResults.GetText("ResourceRevealed");

	push	OFFSET $SG218492
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebx

; 862  : 	m_eResourceRevealed				  = (ResourceTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 863  : 	szTextVal						  = kResults.GetText("SpreadModifierDoublingTech");

	push	OFFSET $SG218494
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebx

; 864  : 	m_eSpreadModifierDoublingTech     = (TechTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 865  : 
; 866  : 	//Arrays
; 867  : 	const char* szBeliefType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+468], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebx, eax

; 868  : 	kUtility.SetYields(m_paiCityYieldChange, "Belief_CityYieldChanges", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218497
	push	OFFSET $SG218498
	lea	eax, DWORD PTR [esi+500]
	push	eax
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 869  : 	kUtility.SetYields(m_paiHolyCityYieldChange, "Belief_HolyCityYieldChanges", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218499
	push	OFFSET $SG218500
	lea	ecx, DWORD PTR [esi+504]
	push	ecx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 870  : 	kUtility.SetYields(m_piYieldChangeAnySpecialist, "Belief_YieldChangeAnySpecialist", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218501
	push	OFFSET $SG218502
	lea	edx, DWORD PTR [esi+552]
	push	edx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 871  : 	kUtility.SetYields(m_piYieldChangeTradeRoute, "Belief_YieldChangeTradeRoute", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218503
	push	OFFSET $SG218504
	lea	eax, DWORD PTR [esi+556]
	push	eax
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 872  : 	kUtility.SetYields(m_piYieldChangeNaturalWonder, "Belief_YieldChangeNaturalWonder", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218505
	push	OFFSET $SG218506
	lea	ecx, DWORD PTR [esi+560]
	push	ecx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 873  : 	kUtility.SetYields(m_piYieldChangeWorldWonder, "Belief_YieldChangeWorldWonder", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218507
	push	OFFSET $SG218508
	lea	edx, DWORD PTR [esi+564]
	push	edx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 874  : 	kUtility.SetYields(m_piYieldModifierNaturalWonder, "Belief_YieldModifierNaturalWonder", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218509
	push	OFFSET $SG218510
	lea	eax, DWORD PTR [esi+568]
	push	eax
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 875  : 	kUtility.PopulateArrayByValue(m_piMaxYieldModifierPerFollower, "Yields", "Belief_MaxYieldModifierPerFollower", "YieldType", "BeliefType", szBeliefType, "Max");

	push	0
	push	0
	push	OFFSET $SG218511
	push	ebx
	push	OFFSET $SG218512
	push	OFFSET $SG218513
	push	OFFSET $SG218514
	push	OFFSET $SG218515
	lea	ecx, DWORD PTR [esi+572]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 876  : 	kUtility.PopulateArrayByValue(m_piResourceHappiness, "Resources", "Belief_ResourceHappiness", "ResourceType", "BeliefType", szBeliefType, "HappinessChange");

	push	0
	push	0
	push	OFFSET $SG218516
	push	ebx
	push	OFFSET $SG218517
	push	OFFSET $SG218518
	push	OFFSET $SG218519
	push	OFFSET $SG218520
	lea	edx, DWORD PTR [esi+548]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 877  : 	kUtility.PopulateArrayByValue(m_piResourceQuantityModifiers, "Resources", "Belief_ResourceQuantityModifiers", "ResourceType", "BeliefType", szBeliefType, "ResourceQuantityModifier");

	push	0
	push	0
	push	OFFSET $SG218521
	push	ebx
	push	OFFSET $SG218522
	push	OFFSET $SG218523
	push	OFFSET $SG218524
	push	OFFSET $SG218525
	lea	eax, DWORD PTR [esi+516]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 878  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassHappiness, "BuildingClasses", "Belief_BuildingClassHappiness", "BuildingClassType", "BeliefType", szBeliefType, "Happiness");

	push	0
	push	0
	push	OFFSET $SG218526
	push	ebx
	push	OFFSET $SG218527
	push	OFFSET $SG218528
	push	OFFSET $SG218529
	push	OFFSET $SG218530
	lea	ecx, DWORD PTR [esi+528]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 879  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassTourism, "BuildingClasses", "Belief_BuildingClassTourism", "BuildingClassType", "BeliefType", szBeliefType, "Tourism");

	push	0
	push	0
	push	OFFSET $SG218531
	push	ebx
	push	OFFSET $SG218532
	push	OFFSET $SG218533
	push	OFFSET $SG218534
	push	OFFSET $SG218535
	lea	edx, DWORD PTR [esi+532]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 880  : 	kUtility.PopulateArrayByValue(m_paiYieldChangePerForeignCity, "Yields", "Belief_YieldChangePerForeignCity", "YieldType", "BeliefType", szBeliefType, "Yield");

	push	0
	push	0
	push	OFFSET $SG218536
	push	ebx
	push	OFFSET $SG218537
	push	OFFSET $SG218538
	push	OFFSET $SG218539
	push	OFFSET $SG218540
	lea	eax, DWORD PTR [esi+508]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 881  : 	kUtility.PopulateArrayByValue(m_paiYieldChangePerXForeignFollowers, "Yields", "Belief_YieldChangePerXForeignFollowers", "YieldType", "BeliefType", szBeliefType, "ForeignFollowers");

	push	0
	push	0
	push	OFFSET $SG218541
	push	ebx
	push	OFFSET $SG218542
	push	OFFSET $SG218543
	push	OFFSET $SG218544
	push	OFFSET $SG218545
	lea	ecx, DWORD PTR [esi+512]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 882  : 	kUtility.PopulateArrayByExistence(m_pbFaithPurchaseUnitEraEnabled, "Eras", "Belief_EraFaithUnitPurchase", "EraType", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218546
	push	OFFSET $SG218547
	push	OFFSET $SG218548
	push	OFFSET $SG218549
	lea	edx, DWORD PTR [esi+576]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 883  : 	kUtility.PopulateArrayByExistence(m_pbBuildingClassEnabled, "BuildingClasses", "Belief_BuildingClassFaithPurchase", "BuildingClassType", "BeliefType", szBeliefType);

	push	ebx
	push	OFFSET $SG218550
	push	OFFSET $SG218551
	push	OFFSET $SG218552
	push	OFFSET $SG218553
	lea	eax, DWORD PTR [esi+580]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 884  : 
; 885  : 	//ImprovementYieldChanges
; 886  : 	{
; 887  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 888  : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges.first, "Improvements", "Yields");
; 889  : 		m_ppiImprovementYieldChanges.second = kUtility.MaxRows("Improvements");
; 890  : #else
; 891  : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges, "Improvements", "Yields");

	push	0
	push	OFFSET $SG218554
	lea	eax, DWORD PTR [esi+520]
	push	OFFSET $SG218555
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 892  : #endif
; 893  : 
; 894  : 		std::string strKey("Belief_ImprovementYieldChanges");

	push	OFFSET $SG218557
	lea	ecx, DWORD PTR _strKey$218556[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 895  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$218556[esp+88]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+100], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax
	mov	DWORD PTR _pResults$218558[esp+84], edi

; 896  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN15@CacheResul

; 897  : 		{
; 898  : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Belief_ImprovementYieldChanges inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where BeliefType = ?");

	push	OFFSET $SG218560
	lea	edx, DWORD PTR _strKey$218556[esp+92]
	push	edx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218558[esp+84], eax
	mov	edi, eax
$LN15@CacheResul:

; 899  : 		}
; 900  : 
; 901  : 		pResults->Bind(1, szBeliefType);

	push	1
	push	ebx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 902  : 
; 903  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	edi, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	test	al, al
	je	SHORT $LN13@CacheResul
$LL14@CacheResul:

; 904  : 		{
; 905  : 			const int ImprovementID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218558[esp+84]
	push	0
	call	edi

; 906  : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218558[esp+84]
	push	1
	mov	DWORD PTR _ImprovementID$218564[esp+88], eax
	call	edi

; 907  : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218558[esp+84]
	push	2
	mov	DWORD PTR _YieldID$218565[esp+92], eax
	call	edi

; 908  : 
; 909  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 910  : 			m_ppiImprovementYieldChanges.first[ImprovementID][YieldID] = yield;
; 911  : #else
; 912  : 			m_ppiImprovementYieldChanges[ImprovementID][YieldID] = yield;

	mov	ecx, DWORD PTR [esi+520]
	mov	edx, DWORD PTR _ImprovementID$218564[esp+84]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _YieldID$218565[esp+88]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pResults$218558[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL14@CacheResul
$LN13@CacheResul:

; 913  : #endif
; 914  : 		}
; 915  : 	}

	lea	ecx, DWORD PTR _strKey$218556[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 916  : 
; 917  : 	//BuildingClassYieldChanges
; 918  : 	{
; 919  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 920  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges.first, "BuildingClasses", "Yields");
; 921  : 		m_ppiBuildingClassYieldChanges.second = kUtility.MaxRows("BuildingClasses");
; 922  : #else
; 923  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges, "BuildingClasses", "Yields");

	push	0
	push	OFFSET $SG218567
	lea	eax, DWORD PTR [esi+524]
	push	OFFSET $SG218568
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 924  : #endif
; 925  : 
; 926  : 		std::string strKey("Belief_BuildingClassYieldChanges");

	push	OFFSET $SG218570
	lea	ecx, DWORD PTR _strKey$218569[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 927  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218569[esp+88]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+100], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218571[esp+84], eax

; 928  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN12@CacheResul

; 929  : 		{
; 930  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldChange from Belief_BuildingClassYieldChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Yields on Yields.Type = YieldType where BeliefType = ?");

	push	OFFSET $SG218573
	lea	ecx, DWORD PTR _strKey$218569[esp+92]
	push	ecx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218571[esp+84], eax
$LN12@CacheResul:

; 931  : 		}
; 932  : 
; 933  : 		pResults->Bind(1, szBeliefType);

	push	1
	push	ebx
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 934  : 
; 935  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218571[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN10@CacheResul
	npad	7
$LL11@CacheResul:

; 936  : 		{
; 937  : 			const int BuildingClassID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218571[esp+84]
	push	0
	call	edi

; 938  : 			const int iYieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218571[esp+84]
	push	1
	mov	DWORD PTR _BuildingClassID$218577[esp+88], eax
	call	edi

; 939  : 			const int iYieldChange = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218571[esp+84]
	push	2
	mov	DWORD PTR _iYieldID$218578[esp+92], eax
	call	edi

; 940  : 
; 941  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 942  : 			m_ppiBuildingClassYieldChanges.first[BuildingClassID][iYieldID] = iYieldChange;
; 943  : #else
; 944  : 			m_ppiBuildingClassYieldChanges[BuildingClassID][iYieldID] = iYieldChange;

	mov	edx, DWORD PTR [esi+524]
	mov	ecx, DWORD PTR _BuildingClassID$218577[esp+84]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _iYieldID$218578[esp+88]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _pResults$218571[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL11@CacheResul
$LN10@CacheResul:

; 945  : #endif
; 946  : 		}
; 947  : 	}

	lea	ecx, DWORD PTR _strKey$218569[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 948  : 
; 949  : #ifdef AUI_BELIEF_BUILDING_CLASS_FLAVOR_MODIFIERS
; 950  : 	//BuildingClassFlavorChanges
; 951  : 	{
; 952  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 953  : 		kUtility.Initialize2DArray(m_ppiBuildingClassFlavorChanges.first, "BuildingClasses", "Flavors");
; 954  : 		m_ppiBuildingClassFlavorChanges.second = kUtility.MaxRows("BuildingClasses");
; 955  : #else
; 956  : 		kUtility.Initialize2DArray(m_ppiBuildingClassFlavorChanges, "BuildingClasses", "Flavors");
; 957  : #endif
; 958  : 
; 959  : 		std::string strKey("Belief_BuildingClassFlavorChanges");
; 960  : 		Database::Results* pResults = kUtility.GetResults(strKey);
; 961  : 		if (pResults == NULL)
; 962  : 		{
; 963  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Flavors.ID as FlavorID, FlavorChange from Belief_BuildingClassFlavorChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Flavors on Flavors.Type = FlavorType where BeliefType = ?");
; 964  : 		}
; 965  : 
; 966  : 		pResults->Bind(1, szBeliefType);
; 967  : 
; 968  : 		while (pResults->Step())
; 969  : 		{
; 970  : 			const int BuildingClassID = pResults->GetInt(0);
; 971  : 			const int iFlavorID = pResults->GetInt(1);
; 972  : 			const int iFlavorChange = pResults->GetInt(2);
; 973  : 
; 974  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 975  : 			m_ppiBuildingClassFlavorChanges.first[BuildingClassID][iFlavorID] = iFlavorChange;
; 976  : #else
; 977  : 			m_ppiBuildingClassFlavorChanges[BuildingClassID][iFlavorID] = iFlavorChange;
; 978  : #endif
; 979  : 		}
; 980  : 	}
; 981  : #endif
; 982  : 
; 983  : 	//FeatureYieldChanges
; 984  : 	{
; 985  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 986  : 		kUtility.Initialize2DArray(m_ppaiFeatureYieldChange.first, "Features", "Yields");
; 987  : 		m_ppaiFeatureYieldChange.second = kUtility.MaxRows("Features");
; 988  : #else
; 989  : 		kUtility.Initialize2DArray(m_ppaiFeatureYieldChange, "Features", "Yields");

	push	0
	push	OFFSET $SG218580
	lea	eax, DWORD PTR [esi+536]
	push	OFFSET $SG218581
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 990  : #endif
; 991  : 
; 992  : 		std::string strKey("Belief_FeatureYieldChanges");

	push	OFFSET $SG218583
	lea	ecx, DWORD PTR _strKey$218582[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 993  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218582[esp+88]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+100], 2
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218584[esp+84], eax

; 994  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN9@CacheResul

; 995  : 		{
; 996  : 			pResults = kUtility.PrepareResults(strKey, "select Features.ID as FeatureID, Yields.ID as YieldID, Yield from Belief_FeatureYieldChanges inner join Features on Features.Type = FeatureType inner join Yields on Yields.Type = YieldType where BeliefType = ?");

	push	OFFSET $SG218586
	lea	eax, DWORD PTR _strKey$218582[esp+92]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218584[esp+84], eax
$LN9@CacheResul:

; 997  : 		}
; 998  : 
; 999  : 		pResults->Bind(1, szBeliefType);

	push	1
	push	ebx
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1000 : 
; 1001 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218584[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN7@CacheResul
	npad	7
$LL8@CacheResul:

; 1002 : 		{
; 1003 : 			const int FeatureID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218584[esp+84]
	push	0
	call	edi

; 1004 : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218584[esp+84]
	push	1
	mov	DWORD PTR _FeatureID$218590[esp+88], eax
	call	edi

; 1005 : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218584[esp+84]
	push	2
	mov	DWORD PTR _YieldID$218591[esp+92], eax
	call	edi

; 1006 : 
; 1007 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1008 : 			m_ppaiFeatureYieldChange.first[FeatureID][YieldID] = yield;
; 1009 : #else
; 1010 : 			m_ppaiFeatureYieldChange[FeatureID][YieldID] = yield;

	mov	ecx, DWORD PTR [esi+536]
	mov	edx, DWORD PTR _FeatureID$218590[esp+84]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _YieldID$218591[esp+88]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pResults$218584[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL8@CacheResul
$LN7@CacheResul:

; 1011 : #endif
; 1012 : 		}
; 1013 : 	}

	lea	ecx, DWORD PTR _strKey$218582[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1014 : 
; 1015 : 	//ResourceYieldChanges
; 1016 : 	{
; 1017 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1018 : 		kUtility.Initialize2DArray(m_ppaiResourceYieldChange.first, "Resources", "Yields");
; 1019 : 		m_ppaiResourceYieldChange.second = kUtility.MaxRows("Resources");
; 1020 : #else
; 1021 : 		kUtility.Initialize2DArray(m_ppaiResourceYieldChange, "Resources", "Yields");

	push	0
	push	OFFSET $SG218593
	lea	eax, DWORD PTR [esi+540]
	push	OFFSET $SG218594
	push	eax
	mov	ecx, ebp
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1022 : #endif
; 1023 : 
; 1024 : 		std::string strKey("Belief_ResourceYieldChanges");

	push	OFFSET $SG218596
	lea	ecx, DWORD PTR _strKey$218595[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1025 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218595[esp+88]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+100], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218597[esp+84], eax

; 1026 : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN6@CacheResul

; 1027 : 		{
; 1028 : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, Yields.ID as YieldID, Yield from Belief_ResourceYieldChanges inner join Resources on Resources.Type = ResourceType inner join Yields on Yields.Type = YieldType where BeliefType = ?");

	push	OFFSET $SG218599
	lea	ecx, DWORD PTR _strKey$218595[esp+92]
	push	ecx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218597[esp+84], eax
$LN6@CacheResul:

; 1029 : 		}
; 1030 : 
; 1031 : 		pResults->Bind(1, szBeliefType);

	push	1
	push	ebx
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1032 : 
; 1033 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218597[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN4@CacheResul
	npad	7
$LL5@CacheResul:

; 1034 : 		{
; 1035 : 			const int ResourceID = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218597[esp+84]
	push	0
	call	edi

; 1036 : 			const int YieldID = pResults->GetInt(1);

	mov	ecx, DWORD PTR _pResults$218597[esp+84]
	push	1
	mov	DWORD PTR _ResourceID$218603[esp+88], eax
	call	edi

; 1037 : 			const int yield = pResults->GetInt(2);

	mov	ecx, DWORD PTR _pResults$218597[esp+84]
	push	2
	mov	DWORD PTR _YieldID$218604[esp+92], eax
	call	edi

; 1038 : 
; 1039 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1040 : 			m_ppaiResourceYieldChange.first[ResourceID][YieldID] = yield;
; 1041 : #else
; 1042 : 			m_ppaiResourceYieldChange[ResourceID][YieldID] = yield;

	mov	edx, DWORD PTR [esi+540]
	mov	ecx, DWORD PTR _ResourceID$218603[esp+84]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _YieldID$218604[esp+88]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _pResults$218597[esp+84]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL5@CacheResul
$LN4@CacheResul:

; 1043 : #endif
; 1044 : 		}
; 1045 : 	}

	lea	ecx, DWORD PTR _strKey$218595[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1046 : 
; 1047 : 	//TerrainYieldChanges
; 1048 : 	{
; 1049 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1050 : 		kUtility.Initialize2DArray(m_ppaiTerrainYieldChange.first, "Terrains", "Yields");
; 1051 : 		m_ppaiTerrainYieldChange.second = kUtility.MaxRows("Terrains");
; 1052 : #else
; 1053 : 		kUtility.Initialize2DArray(m_ppaiTerrainYieldChange, "Terrains", "Yields");

	push	0
	push	OFFSET $SG218606
	add	esi, 544				; 00000220H
	push	OFFSET $SG218607
	push	esi
	mov	ecx, ebp
	mov	DWORD PTR tv1120[esp+100], esi
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1054 : #endif
; 1055 : 
; 1056 : 		std::string strKey("Belief_TerrainYieldChanges");

	push	OFFSET $SG218609
	lea	ecx, DWORD PTR _strKey$218608[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1057 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218608[esp+88]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+100], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	esi, eax

; 1058 : 		if(pResults == NULL)

	test	esi, esi
	jne	SHORT $LN3@CacheResul

; 1059 : 		{
; 1060 : 			pResults = kUtility.PrepareResults(strKey, "select Terrains.ID as TerrainID, Yields.ID as YieldID, Yield from Belief_TerrainYieldChanges inner join Terrains on Terrains.Type = TerrainType inner join Yields on Yields.Type = YieldType where BeliefType = ?");

	push	OFFSET $SG218612
	lea	eax, DWORD PTR _strKey$218608[esp+92]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	esi, eax
$LN3@CacheResul:

; 1061 : 		}
; 1062 : 
; 1063 : 		pResults->Bind(1, szBeliefType);

	push	1
	push	ebx
	push	1
	mov	ecx, esi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 1064 : 
; 1065 : 		while(pResults->Step())

	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@CacheResul
$LL2@CacheResul:

; 1066 : 		{
; 1067 : 			const int TerrainID = pResults->GetInt(0);

	push	0
	mov	ecx, esi
	call	edi

; 1068 : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	edi

; 1069 : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, esi
	mov	ebp, eax
	call	edi

; 1070 : 
; 1071 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1072 : 			m_ppaiTerrainYieldChange.first[TerrainID][YieldID] = yield;
; 1073 : #else
; 1074 : 			m_ppaiTerrainYieldChange[TerrainID][YieldID] = yield;

	mov	ecx, DWORD PTR tv1120[esp+84]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	DWORD PTR [ecx+ebp*4], eax
	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@CacheResul
$LN1@CacheResul:

; 1075 : #endif
; 1076 : 		}
; 1077 : 	}

	lea	ecx, DWORD PTR _strKey$218608[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1078 : 
; 1079 : 	return true;
; 1080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebx
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$218556[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$218569[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR _strKey$218582[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$218595[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _strKey$218608[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvBeliefEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvBeliefEntry::CacheResults
PUBLIC	?GetNumBeliefs@CvBeliefXMLEntries@@QAEHXZ	; CvBeliefXMLEntries::GetNumBeliefs
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumBeliefs@CvBeliefXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumBeliefs@CvBeliefXMLEntries@@QAEHXZ PROC		; CvBeliefXMLEntries::GetNumBeliefs, COMDAT
; _this$ = ecx

; 1106 : 	return m_paBeliefEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1107 : }

	ret	0
?GetNumBeliefs@CvBeliefXMLEntries@@QAEHXZ ENDP		; CvBeliefXMLEntries::GetNumBeliefs
_TEXT	ENDS
PUBLIC	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z PROC ; CvBeliefXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 1123 : 	return m_paBeliefEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1124 : }

	ret	4
?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ENDP ; CvBeliefXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Uninit@CvReligionBeliefs@@QAEXXZ		; CvReligionBeliefs::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvReligionBeliefs@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvReligionBeliefs@@QAEXXZ PROC			; CvReligionBeliefs::Uninit, COMDAT
; _this$ = ecx

; 1217 : {

	push	esi
	mov	esi, ecx

; 1218 : 	SAFE_DELETE_ARRAY(m_paiBuildingClassEnabled);

	mov	eax, DWORD PTR [esi+172]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+172], 0
	pop	esi

; 1219 : }

	ret	0
?Uninit@CvReligionBeliefs@@QAEXXZ ENDP			; CvReligionBeliefs::Uninit
_TEXT	ENDS
PUBLIC	?GetBelief@CvReligionBeliefs@@QBE?AW4BeliefTypes@@H@Z ; CvReligionBeliefs::GetBelief
; Function compile flags: /Ogtpy
;	COMDAT ?GetBelief@CvReligionBeliefs@@QBE?AW4BeliefTypes@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetBelief@CvReligionBeliefs@@QBE?AW4BeliefTypes@@H@Z PROC ; CvReligionBeliefs::GetBelief, COMDAT
; _this$ = ecx

; 1387 : 	return (BeliefTypes)m_ReligionBeliefs[iIndex];

	mov	eax, DWORD PTR [ecx+136]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1388 : }

	ret	4
?GetBelief@CvReligionBeliefs@@QBE?AW4BeliefTypes@@H@Z ENDP ; CvReligionBeliefs::GetBelief
_TEXT	ENDS
PUBLIC	?GetNumBeliefs@CvReligionBeliefs@@QBEHXZ	; CvReligionBeliefs::GetNumBeliefs
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumBeliefs@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
?GetNumBeliefs@CvReligionBeliefs@@QBEHXZ PROC		; CvReligionBeliefs::GetNumBeliefs, COMDAT
; _this$ = ecx

; 1393 : 	return m_ReligionBeliefs.size();

	mov	eax, DWORD PTR [ecx+140]

; 1394 : }

	ret	0
?GetNumBeliefs@CvReligionBeliefs@@QBEHXZ ENDP		; CvReligionBeliefs::GetNumBeliefs
_TEXT	ENDS
PUBLIC	?Write@CvReligionBeliefs@@QBEXAAVFDataStream@@@Z ; CvReligionBeliefs::Write
EXTRN	?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; BuildingClassArrayHelpers::Write
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4BeliefTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ResourceTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvReligionBeliefs@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T220995 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvReligionBeliefs@@QBEXAAVFDataStream@@@Z PROC	; CvReligionBeliefs::Write, COMDAT
; _this$ = ecx

; 2171 : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 2172 : 	// Current version number
; 2173 : 	uint uiVersion = 2;
; 2174 : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2175 : 
; 2176 : 	kStream << m_iFaithFromDyingUnits;

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2177 : 	kStream << m_iRiverHappiness;

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2178 : 	kStream << m_iPlotCultureCostModifier;

	lea	edx, DWORD PTR [esi+8]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2179 : 	kStream << m_iCityRangeStrikeModifier;

	lea	eax, DWORD PTR [esi+12]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2180 : 	kStream << m_iCombatModifierEnemyCities;

	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2181 : 	kStream << m_iCombatModifierFriendlyCities;

	lea	edx, DWORD PTR [esi+20]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2182 : 	kStream << m_iFriendlyHealChange;

	lea	eax, DWORD PTR [esi+24]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2183 : 	kStream << m_iCityStateFriendshipModifier;

	lea	ecx, DWORD PTR [esi+28]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2184 : 	kStream << m_iLandBarbarianConversionPercent;

	lea	edx, DWORD PTR [esi+32]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2185 : 	kStream << m_iSpreadStrengthModifier;

	lea	eax, DWORD PTR [esi+40]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2186 : 	kStream << m_iSpreadDistanceModifier;

	lea	ecx, DWORD PTR [esi+36]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2187 : 	kStream << m_iProphetStrengthModifier;

	lea	edx, DWORD PTR [esi+44]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2188 : 	kStream << m_iProphetCostModifier;

	lea	eax, DWORD PTR [esi+48]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2189 : 	kStream << m_iMissionaryStrengthModifier;

	lea	ecx, DWORD PTR [esi+52]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2190 : #ifdef NQ_FLAT_FAITH_PER_CITIZEN_BORN_FROM_BELIEFS
; 2191 : 	kStream << m_iFlatFaithPerCitizenBorn;

	lea	edx, DWORD PTR [esi+56]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2192 : #endif
; 2193 : #ifdef NQ_BELIEF_EXTRA_MISSIONARY_SPREADS
; 2194 : 	kStream << m_iMissionaryExtraSpreads;

	lea	eax, DWORD PTR [esi+60]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2195 : #endif
; 2196 : #ifdef NQ_SPREAD_MODIFIER_OWNED_CITIES
; 2197 : 	kStream << m_iSpreadModifierOwnedCities;

	lea	ecx, DWORD PTR [esi+64]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2198 : 	kStream << m_iSpreadModifierUnownedCities;

	lea	edx, DWORD PTR [esi+68]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2199 : #endif
; 2200 : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 2201 : 	kStream << m_iExtraTradeRoutes;

	lea	eax, DWORD PTR [esi+72]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2202 : #endif
; 2203 : #ifdef NQ_FAITH_PER_CITY_STATE_THIS_RELIGION
; 2204 : 	kStream << m_iFaithPerCityStateThisReligion;

	lea	ecx, DWORD PTR [esi+76]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2205 : #endif
; 2206 : #ifdef NQ_FAITH_PER_FOREIGN_TRADE_ROUTE
; 2207 : 	kStream << m_iFaithPerForeignTradeRoute;

	lea	edx, DWORD PTR [esi+80]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2208 : #endif
; 2209 : #ifdef NQ_GOLDEN_AGE_TURNS_FROM_BELIEF
; 2210 : 	kStream << m_iGoldenAgeTurns;

	lea	eax, DWORD PTR [esi+84]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2211 : #endif
; 2212 : 	kStream << m_iMissionaryCostModifier;

	lea	ecx, DWORD PTR [esi+88]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2213 : 	kStream << m_iFriendlyCityStateSpreadModifier;

	lea	edx, DWORD PTR [esi+92]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2214 : 	kStream << m_iGreatPersonExpendedFaith;

	lea	eax, DWORD PTR [esi+96]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2215 : 	kStream << m_iCityStateMinimumInfluence;

	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2216 : 	kStream << m_iCityStateInfluenceModifier;

	lea	edx, DWORD PTR [esi+104]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2217 : 	kStream << m_iOtherReligionPressureErosion;

	lea	eax, DWORD PTR [esi+108]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2218 : 	kStream << m_iSpyPressure;

	lea	ecx, DWORD PTR [esi+112]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2219 : 	kStream << m_iInquisitorPressureRetention;

	lea	edx, DWORD PTR [esi+116]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2220 : 	kStream << m_iFaithBuildingTourism;

	lea	eax, DWORD PTR [esi+120]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2221 : 
; 2222 : 	kStream << m_eObsoleteEra;

	lea	ecx, DWORD PTR [esi+124]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<

; 2223 : 	kStream << m_eResourceRevealed;

	lea	edx, DWORD PTR [esi+128]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4ResourceTypes@@@Z ; operator<<

; 2224 : 	kStream << m_eSpreadModifierDoublingTech;

	lea	eax, DWORD PTR [esi+132]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z ; operator<<

; 2225 : 
; 2226 : 	// m_ReligionBeliefs contains the BeliefTypes, which are indices into the religion info table (GC.getBeliefInfo).  Write out the info hashes
; 2227 : 	kStream << m_ReligionBeliefs.size();

	mov	ecx, DWORD PTR [esi+140]
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR $T220995[esp+12]
	mov	DWORD PTR $T220995[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2228 : 	for (uint i = 0; i < m_ReligionBeliefs.size(); ++i)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+140], ebx
	jbe	SHORT $LN1@Write
	npad	9
$LL3@Write:

; 2229 : 	{
; 2230 : 		CvInfosSerializationHelper::WriteHashed(kStream, (BeliefTypes)m_ReligionBeliefs[i]);

	mov	eax, DWORD PTR [esi+136]
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	ecx
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4BeliefTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	inc	ebx
	add	esp, 8
	cmp	ebx, DWORD PTR [esi+140]
	jb	SHORT $LL3@Write
$LN1@Write:

; 2231 : 	}
; 2232 : 
; 2233 : 	BuildingClassArrayHelpers::Write(kStream, m_paiBuildingClassEnabled, GC.getNumBuildingClassInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	mov	edx, DWORD PTR [esi+172]
	push	eax
	push	edx
	push	edi
	call	?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingClassArrayHelpers::Write
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2234 : }

	pop	ecx
	ret	4
?Write@CvReligionBeliefs@@QBEXAAVFDataStream@@@Z ENDP	; CvReligionBeliefs::Write
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@2

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@2:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@2

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@2:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,5,0,297,0>::FStaticVector<int,5,0,297,0>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,5,0,297,0>::FStaticVector<int,5,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 5
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,5,0,297,0>::FStaticVector<int,5,0,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@H$0A@@@QAEXXZ		; BaseVector<int,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@H$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@H$0A@@@QAEXXZ PROC			; BaseVector<int,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@H$0A@@@QAEXXZ ENDP			; BaseVector<int,0>::clear
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEAAPAVCvBeliefEntry@@XZ ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEAAPAVCvBeliefEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEAAPAVCvBeliefEntry@@XZ PROC ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEAAPAVCvBeliefEntry@@XZ ENDP ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::~_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::~_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::~_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z ; std::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z PROC ; std::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE@V?$allocator@PAVCvBeliefEntry@@@1@@Z ENDP ; std::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_val<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXPAHI@Z ; FStaticVector<int,5,0,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXPAHI@Z PROC ; FStaticVector<int,5,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXPAHI@Z ENDP ; FStaticVector<int,5,0,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z PROC ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@PAPAVCvBeliefEntry@@@Z ENDP ; std::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Vector_iterator<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@@Z ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@@Z PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@@Z ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEPAPAVCvBeliefEntry@@I@Z ; std::allocator<CvBeliefEntry *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEPAPAVCvBeliefEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEPAPAVCvBeliefEntry@@I@Z PROC ; std::allocator<CvBeliefEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvBeliefEntry@@@std@@YAPAPAVCvBeliefEntry@@IPAPAV1@@Z ; std::_Allocate<CvBeliefEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvBeliefEntry@@@std@@QAEPAPAVCvBeliefEntry@@I@Z ENDP ; std::allocator<CvBeliefEntry *>::allocate
_TEXT	ENDS
PUBLIC	??$find@PBHH@std@@YAPBHPBH0ABH@Z		; std::find<int const *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$find@PBHH@std@@YAPBHPBH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$find@PBHH@std@@YAPBHPBH0ABH@Z PROC			; std::find<int const *,int>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN10@find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@find:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN10@find
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL6@find
$LN10@find:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);
; 77   : 	}

	ret	0
??$find@PBHH@std@@YAPBHPBH0ABH@Z ENDP			; std::find<int const *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvBeliefEntry@@PAPAV1@@stdext@@YAPAPAVCvBeliefEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvBeliefEntry * *,CvBeliefEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvBeliefEntry@@PAPAV1@@stdext@@YAPAPAVCvBeliefEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvBeliefEntry@@PAPAV1@@stdext@@YAPAPAVCvBeliefEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvBeliefEntry * *,CvBeliefEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvBeliefEntry@@PAPAV1@@stdext@@YAPAPAVCvBeliefEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvBeliefEntry * *,CvBeliefEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvBeliefEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@YAXPAPAVCvBeliefEntry@@0AAV?$allocator@PAVCvBeliefEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	??_GCvBeliefEntry@@QAEPAXI@Z			; CvBeliefEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvBeliefEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBeliefEntry@@QAEPAXI@Z PROC			; CvBeliefEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBeliefEntry@@QAE@XZ		; CvBeliefEntry::~CvBeliefEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBeliefEntry@@QAEPAXI@Z ENDP			; CvBeliefEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	??0CvBeliefEntry@@QAE@XZ			; CvBeliefEntry::CvBeliefEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvBeliefEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBeliefEntry@@QAE@XZ$0
__ehfuncinfo$??0CvBeliefEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvBeliefEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvBeliefEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvBeliefEntry@@QAE@XZ PROC				; CvBeliefEntry::CvBeliefEntry, COMDAT
; _this$ = ecx

; 143  : {

	push	-1
	push	__ehhandler$??0CvBeliefEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	eax, -1
	lea	ecx, DWORD PTR [esi+472]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvBeliefEntry@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], ebx
	mov	DWORD PTR [esi+340], ebx
	mov	DWORD PTR [esi+344], ebx
	mov	DWORD PTR [esi+348], ebx
	mov	DWORD PTR [esi+352], ebx
	mov	DWORD PTR [esi+356], ebx
	mov	DWORD PTR [esi+360], ebx
	mov	DWORD PTR [esi+364], ebx
	mov	DWORD PTR [esi+368], ebx
	mov	DWORD PTR [esi+372], ebx
	mov	DWORD PTR [esi+376], ebx
	mov	DWORD PTR [esi+380], ebx
	mov	DWORD PTR [esi+384], ebx
	mov	DWORD PTR [esi+388], ebx
	mov	DWORD PTR [esi+392], ebx
	mov	DWORD PTR [esi+396], ebx
	mov	DWORD PTR [esi+400], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+420], ebx
	mov	DWORD PTR [esi+424], ebx
	mov	DWORD PTR [esi+428], ebx
	mov	DWORD PTR [esi+432], ebx
	mov	DWORD PTR [esi+436], ebx
	mov	DWORD PTR [esi+440], ebx
	mov	DWORD PTR [esi+444], ebx
	mov	BYTE PTR [esi+448], bl
	mov	BYTE PTR [esi+449], bl
	mov	BYTE PTR [esi+450], bl
	mov	BYTE PTR [esi+451], bl
	mov	BYTE PTR [esi+452], bl
	mov	BYTE PTR [esi+453], bl
	mov	BYTE PTR [esi+454], bl
	mov	BYTE PTR [esi+455], bl
	mov	BYTE PTR [esi+456], bl
	mov	BYTE PTR [esi+457], bl
	mov	DWORD PTR [esi+460], eax
	mov	DWORD PTR [esi+464], eax
	mov	DWORD PTR [esi+468], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+500], ebx
	mov	DWORD PTR [esi+504], ebx
	mov	DWORD PTR [esi+508], ebx
	mov	DWORD PTR [esi+512], ebx
	mov	DWORD PTR [esi+516], ebx
	mov	DWORD PTR [esi+520], ebx
	mov	DWORD PTR [esi+524], ebx
	mov	DWORD PTR [esi+528], ebx
	mov	DWORD PTR [esi+532], ebx

; 144  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+536], ebx
	mov	DWORD PTR [esi+540], ebx
	mov	DWORD PTR [esi+544], ebx
	mov	DWORD PTR [esi+548], ebx
	mov	DWORD PTR [esi+552], ebx
	mov	DWORD PTR [esi+556], ebx
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	mov	DWORD PTR [esi+568], ebx
	mov	DWORD PTR [esi+572], ebx
	mov	DWORD PTR [esi+576], ebx
	mov	DWORD PTR [esi+580], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBeliefEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvBeliefEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvBeliefEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBeliefEntry@@QAE@XZ ENDP				; CvBeliefEntry::CvBeliefEntry
PUBLIC	?Reset@CvReligionBeliefs@@QAEXXZ		; CvReligionBeliefs::Reset
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvReligionBeliefs@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvReligionBeliefs@@QAEXXZ PROC			; CvReligionBeliefs::Reset, COMDAT
; _this$ = ecx

; 1223 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 1224 : 	m_iFaithFromDyingUnits = 0;
; 1225 : 	m_iRiverHappiness = 0;
; 1226 : 	m_iPlotCultureCostModifier = 0;
; 1227 : 	m_iCityRangeStrikeModifier = 0;
; 1228 : 	m_iCombatModifierEnemyCities = 0;
; 1229 : 	m_iCombatModifierFriendlyCities = 0;
; 1230 : 	m_iFriendlyHealChange = 0;
; 1231 : 	m_iCityStateFriendshipModifier = 0;
; 1232 : 	m_iLandBarbarianConversionPercent = 0;
; 1233 : 	m_iSpreadDistanceModifier = 0;
; 1234 : 	m_iSpreadStrengthModifier = 0;
; 1235 : 	m_iProphetStrengthModifier = 0;
; 1236 : 	m_iProphetCostModifier = 0;
; 1237 : 	m_iMissionaryStrengthModifier = 0;
; 1238 : #ifdef NQ_FLAT_FAITH_PER_CITIZEN_BORN_FROM_BELIEFS
; 1239 : 	m_iFlatFaithPerCitizenBorn = 0;
; 1240 : #endif
; 1241 : #ifdef NQ_BELIEF_EXTRA_MISSIONARY_SPREADS
; 1242 : 	m_iMissionaryExtraSpreads = 0;
; 1243 : #endif
; 1244 : #ifdef NQ_SPREAD_MODIFIER_OWNED_CITIES
; 1245 : 	m_iSpreadModifierOwnedCities = 0;
; 1246 : 	m_iSpreadModifierUnownedCities = 0;
; 1247 : #endif
; 1248 : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 1249 : 	m_iExtraTradeRoutes	= 0;
; 1250 : #endif
; 1251 : #ifdef NQ_FAITH_PER_CITY_STATE_THIS_RELIGION
; 1252 : 	m_iFaithPerCityStateThisReligion = 0;
; 1253 : #endif
; 1254 : #ifdef NQ_FAITH_PER_FOREIGN_TRADE_ROUTE
; 1255 : 	m_iFaithPerForeignTradeRoute = 0;
; 1256 : #endif
; 1257 : #ifdef NQ_GOLDEN_AGE_TURNS_FROM_BELIEF
; 1258 : 	m_iGoldenAgeTurns = 0;
; 1259 : #endif
; 1260 : 	m_iMissionaryCostModifier = 0;
; 1261 : 	m_iFriendlyCityStateSpreadModifier = 0;
; 1262 : 	m_iGreatPersonExpendedFaith = 0;
; 1263 : 	m_iCityStateMinimumInfluence = 0;
; 1264 : 	m_iCityStateInfluenceModifier = 0;
; 1265 : 	m_iOtherReligionPressureErosion = 0;
; 1266 : 	m_iSpyPressure = 0;
; 1267 : 	m_iInquisitorPressureRetention = 0;
; 1268 : 	m_iFaithBuildingTourism = 0;
; 1269 : 
; 1270 : 	m_eObsoleteEra = NO_ERA;

	or	eax, -1
	push	edi
	xor	edi, edi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+68], edi
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	mov	DWORD PTR [esi+80], edi
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	mov	DWORD PTR [esi+92], edi
	mov	DWORD PTR [esi+96], edi
	mov	DWORD PTR [esi+100], edi
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], edi
	mov	DWORD PTR [esi+120], edi
	mov	DWORD PTR [esi+124], eax

; 1271 : 	m_eResourceRevealed = NO_RESOURCE;

	mov	DWORD PTR [esi+128], eax

; 1272 : 	m_eSpreadModifierDoublingTech = NO_TECH;

	mov	DWORD PTR [esi+132], eax

; 1273 : 
; 1274 : 	m_ReligionBeliefs.clear();
; 1275 : 
; 1276 : #ifdef AUI_WARNING_FIXES
; 1277 : 	SAFE_DELETE_ARRAY(m_paiBuildingClassEnabled);
; 1278 : #endif
; 1279 : 	m_paiBuildingClassEnabled = FNEW(int[GC.getNumBuildingClassInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+140], edi
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 1280 : #ifdef AUI_WARNING_FIXES
; 1281 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 1282 : 	{
; 1283 : #else
; 1284 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+172], eax
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN2@Reset
$LL4@Reset:

; 1285 : 	{
; 1286 : 		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 1287 : 		if(!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN3@Reset

; 1288 : 		{
; 1289 : 			continue;
; 1290 : 		}
; 1291 : #endif
; 1292 : 
; 1293 : 		m_paiBuildingClassEnabled[iI] = 0;

	mov	eax, DWORD PTR [esi+172]
	mov	DWORD PTR [eax+ebx*4], edi
$LN3@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	SHORT $LL4@Reset
$LN2@Reset:
	pop	edi
	pop	esi
	pop	ebx

; 1294 : 	}
; 1295 : }

	ret	0
?Reset@CvReligionBeliefs@@QAEXXZ ENDP			; CvReligionBeliefs::Reset
_TEXT	ENDS
PUBLIC	?HasBelief@CvReligionBeliefs@@QBE_NW4BeliefTypes@@@Z ; CvReligionBeliefs::HasBelief
; Function compile flags: /Ogtpy
;	COMDAT ?HasBelief@CvReligionBeliefs@@QBE_NW4BeliefTypes@@@Z
_TEXT	SEGMENT
_eBelief$ = 8						; size = 4
?HasBelief@CvReligionBeliefs@@QBE_NW4BeliefTypes@@@Z PROC ; CvReligionBeliefs::HasBelief, COMDAT
; _this$ = ecx

; 1381 : 	return (find(m_ReligionBeliefs.begin(), m_ReligionBeliefs.end(), (int)eBelief) != m_ReligionBeliefs.end());

	mov	eax, DWORD PTR [ecx+136]
	mov	edx, DWORD PTR [ecx+140]
	push	esi
	mov	esi, eax
	lea	edx, DWORD PTR [esi+edx*4]
	cmp	eax, edx
	je	SHORT $LN18@HasBelief
	mov	esi, DWORD PTR _eBelief$[esp]
	npad	6
$LL12@HasBelief:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN18@HasBelief
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL12@HasBelief
$LN18@HasBelief:
	mov	edx, DWORD PTR [ecx+140]
	mov	ecx, DWORD PTR [ecx+136]
	lea	edx, DWORD PTR [ecx+edx*4]
	xor	ecx, ecx
	cmp	eax, edx
	setne	cl
	mov	al, cl
	pop	esi

; 1382 : }

	ret	4
?HasBelief@CvReligionBeliefs@@QBE_NW4BeliefTypes@@@Z ENDP ; CvReligionBeliefs::HasBelief
_TEXT	ENDS
PUBLIC	?GetFaithFromKills@CvReligionBeliefs@@QBEHH@Z	; CvReligionBeliefs::GetFaithFromKills
EXTRN	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ:PROC ; CvGlobals::GetGameBeliefs
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithFromKills@CvReligionBeliefs@@QBEHH@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_iDistance$ = 8						; size = 4
?GetFaithFromKills@CvReligionBeliefs@@QBEHH@Z PROC	; CvReligionBeliefs::GetFaithFromKills, COMDAT
; _this$ = ecx

; 1398 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1399 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1400 : 	int rtnValue = 0;
; 1401 : 	int iRequiredDistance;
; 1402 : 
; 1403 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN4@GetFaithFr
	push	ebp
	mov	ebp, edx
	npad	4
$LL6@GetFaithFr:

; 1404 : 	{
; 1405 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN43@GetFaithFr
$LL24@GetFaithFr:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN43@GetFaithFr
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL24@GetFaithFr
$LN43@GetFaithFr:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN5@GetFaithFr

; 1406 : 		{
; 1407 : 			iRequiredDistance = pBeliefs->GetEntry(i)->GetMaxDistance();

	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edx+268]

; 1408 : 			if(iRequiredDistance == 0 || iDistance <= iRequiredDistance)

	test	ecx, ecx
	je	SHORT $LN1@GetFaithFr
	cmp	DWORD PTR _iDistance$[esp+16], ecx
	jg	SHORT $LN5@GetFaithFr
$LN1@GetFaithFr:

; 1409 : 			{
; 1410 : 				rtnValue += pBeliefs->GetEntry(i)->GetFaithFromKills();

	mov	ecx, DWORD PTR [edx+276]
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN5@GetFaithFr:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL6@GetFaithFr

; 1411 : 			}
; 1412 : 		}
; 1413 : 	}
; 1414 : 
; 1415 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN4@GetFaithFr:
	pop	edi
	pop	esi
	pop	ebx

; 1416 : }

	pop	ecx
	ret	4
?GetFaithFromKills@CvReligionBeliefs@@QBEHH@Z ENDP	; CvReligionBeliefs::GetFaithFromKills
_TEXT	ENDS
PUBLIC	?GetHappinessPerCity@CvReligionBeliefs@@QBEHH@Z	; CvReligionBeliefs::GetHappinessPerCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerCity@CvReligionBeliefs@@QBEHH@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_iPopulation$ = 8					; size = 4
?GetHappinessPerCity@CvReligionBeliefs@@QBEHH@Z PROC	; CvReligionBeliefs::GetHappinessPerCity, COMDAT
; _this$ = ecx

; 1420 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1421 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1422 : 	int rtnValue = 0;
; 1423 : 
; 1424 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN3@GetHappine
	push	ebp
	mov	ebp, edx
	npad	4
$LL5@GetHappine:

; 1425 : 	{
; 1426 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN42@GetHappine
$LL23@GetHappine:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN42@GetHappine
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL23@GetHappine
$LN42@GetHappine:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN4@GetHappine

; 1427 : 		{
; 1428 : 			if(iPopulation >= pBeliefs->GetEntry(i)->GetMinPopulation())

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR _iPopulation$[esp+16]
	cmp	edx, DWORD PTR [ecx+260]
	jl	SHORT $LN4@GetHappine

; 1429 : 			{
; 1430 : 				rtnValue += pBeliefs->GetEntry(i)->GetHappinessPerCity();

	mov	eax, DWORD PTR [ecx+288]
	add	DWORD PTR _rtnValue$[esp+20], eax
$LN4@GetHappine:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL5@GetHappine

; 1431 : 			}
; 1432 : 		}
; 1433 : 	}
; 1434 : 
; 1435 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN3@GetHappine:
	pop	edi
	pop	esi
	pop	ebx

; 1436 : }

	pop	ecx
	ret	4
?GetHappinessPerCity@CvReligionBeliefs@@QBEHH@Z ENDP	; CvReligionBeliefs::GetHappinessPerCity
_TEXT	ENDS
PUBLIC	?GetHappinessPerXPeacefulForeignFollowers@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetHappinessPerXPeacefulForeignFollowers
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerXPeacefulForeignFollowers@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
tv229 = -4						; size = 4
?GetHappinessPerXPeacefulForeignFollowers@CvReligionBeliefs@@QBEHXZ PROC ; CvReligionBeliefs::GetHappinessPerXPeacefulForeignFollowers, COMDAT
; _this$ = ecx

; 1440 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1441 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs

; 1442 : 
; 1443 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	ebx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+8]
	sub	esi, ebx
	sar	esi, 2
	xor	edx, edx
	mov	DWORD PTR tv229[esp+20], ebx
	test	esi, esi
	jle	SHORT $LN2@GetHappine@2
	npad	10
$LL4@GetHappine@2:

; 1444 : 	{
; 1445 : 		if(HasBelief((BeliefTypes)i) && pBeliefs->GetEntry(i)->GetHappinessPerXPeacefulForeignFollowers() > 0)

	mov	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR [edi+140]
	mov	ebp, eax
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN41@GetHappine@2
$LL22@GetHappine@2:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN41@GetHappine@2
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL22@GetHappine@2
$LN41@GetHappine@2:
	mov	ecx, DWORD PTR [edi+140]
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN3@GetHappine@2
	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+292], 0
	jg	SHORT $LN42@GetHappine@2
$LN3@GetHappine@2:

; 1442 : 
; 1443 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edx
	add	ebx, 4
	cmp	edx, esi
	jl	SHORT $LL4@GetHappine@2
$LN2@GetHappine@2:
	pop	edi
	pop	esi
	pop	ebp

; 1448 : 		}
; 1449 : 	}
; 1450 : 
; 1451 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1452 : }

	pop	ecx
	ret	0
$LN42@GetHappine@2:

; 1446 : 		{
; 1447 : 			return pBeliefs->GetEntry(i)->GetHappinessPerXPeacefulForeignFollowers();

	mov	ecx, DWORD PTR tv229[esp+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [edx+292]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1452 : }

	pop	ecx
	ret	0
?GetHappinessPerXPeacefulForeignFollowers@CvReligionBeliefs@@QBEHXZ ENDP ; CvReligionBeliefs::GetHappinessPerXPeacefulForeignFollowers
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvReligionBeliefs@@QBEHW4EraTypes@@@Z ; CvReligionBeliefs::GetWonderProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWonderProductionModifier@CvReligionBeliefs@@QBEHW4EraTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eWonderEra$ = 8					; size = 4
?GetWonderProductionModifier@CvReligionBeliefs@@QBEHW4EraTypes@@@Z PROC ; CvReligionBeliefs::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 1456 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1457 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1458 : 	int rtnValue = 0;
; 1459 : 
; 1460 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN3@GetWonderP
	push	ebp
	mov	ebp, edx
	npad	4
$LL5@GetWonderP:

; 1461 : 	{
; 1462 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN42@GetWonderP
$LL23@GetWonderP:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN42@GetWonderP
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL23@GetWonderP
$LN42@GetWonderP:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN4@GetWonderP

; 1463 : 		{
; 1464 : 			if((int)eWonderEra < (int)pBeliefs->GetEntry(i)->GetObsoleteEra())

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR _eWonderEra$[esp+16]
	cmp	edx, DWORD PTR [ecx+460]
	jge	SHORT $LN4@GetWonderP

; 1465 : 			{
; 1466 : 				rtnValue += pBeliefs->GetEntry(i)->GetWonderProductionModifier();

	mov	eax, DWORD PTR [ecx+324]
	add	DWORD PTR _rtnValue$[esp+20], eax
$LN4@GetWonderP:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL5@GetWonderP

; 1467 : 			}
; 1468 : 		}
; 1469 : 	}
; 1470 : 
; 1471 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN3@GetWonderP:
	pop	edi
	pop	esi
	pop	ebx

; 1472 : }

	pop	ecx
	ret	4
?GetWonderProductionModifier@CvReligionBeliefs@@QBEHW4EraTypes@@@Z ENDP ; CvReligionBeliefs::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetPlayerHappiness@CvReligionBeliefs@@QBEH_N@Z	; CvReligionBeliefs::GetPlayerHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerHappiness@CvReligionBeliefs@@QBEH_N@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_bAtPeace$ = 8						; size = 1
?GetPlayerHappiness@CvReligionBeliefs@@QBEH_N@Z PROC	; CvReligionBeliefs::GetPlayerHappiness, COMDAT
; _this$ = ecx

; 1476 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1477 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1478 : 	int rtnValue = 0;
; 1479 : 
; 1480 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN4@GetPlayerH
	push	ebp
	mov	ebp, edx
	npad	4
$LL6@GetPlayerH:

; 1481 : 	{
; 1482 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN43@GetPlayerH
$LL24@GetPlayerH:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN43@GetPlayerH
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL24@GetPlayerH
$LN43@GetPlayerH:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN5@GetPlayerH

; 1483 : 		{
; 1484 : 			if(bAtPeace || !pBeliefs->GetEntry(i)->RequiresPeace())

	cmp	BYTE PTR _bAtPeace$[esp+16], 0
	jne	SHORT $LN1@GetPlayerH
	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+453], 0
	jne	SHORT $LN5@GetPlayerH
$LN1@GetPlayerH:

; 1485 : 			{
; 1486 : 				rtnValue += pBeliefs->GetEntry(i)->GetPlayerHappiness();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+328]
	add	DWORD PTR _rtnValue$[esp+20], eax
$LN5@GetPlayerH:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL6@GetPlayerH

; 1487 : 			}
; 1488 : 		}
; 1489 : 	}
; 1490 : 
; 1491 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN4@GetPlayerH:
	pop	edi
	pop	esi
	pop	ebx

; 1492 : }

	pop	ecx
	ret	4
?GetPlayerHappiness@CvReligionBeliefs@@QBEH_N@Z ENDP	; CvReligionBeliefs::GetPlayerHappiness
_TEXT	ENDS
PUBLIC	?GetPlayerCultureModifier@CvReligionBeliefs@@QBEH_N@Z ; CvReligionBeliefs::GetPlayerCultureModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerCultureModifier@CvReligionBeliefs@@QBEH_N@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_bAtPeace$ = 8						; size = 1
?GetPlayerCultureModifier@CvReligionBeliefs@@QBEH_N@Z PROC ; CvReligionBeliefs::GetPlayerCultureModifier, COMDAT
; _this$ = ecx

; 1496 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1497 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1498 : 	int rtnValue = 0;
; 1499 : 
; 1500 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN4@GetPlayerC
	push	ebp
	mov	ebp, edx
	npad	4
$LL6@GetPlayerC:

; 1501 : 	{
; 1502 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN43@GetPlayerC
$LL24@GetPlayerC:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN43@GetPlayerC
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL24@GetPlayerC
$LN43@GetPlayerC:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN5@GetPlayerC

; 1503 : 		{
; 1504 : 			if(bAtPeace || !pBeliefs->GetEntry(i)->RequiresPeace())

	cmp	BYTE PTR _bAtPeace$[esp+16], 0
	jne	SHORT $LN1@GetPlayerC
	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+453], 0
	jne	SHORT $LN5@GetPlayerC
$LN1@GetPlayerC:

; 1505 : 			{
; 1506 : 				rtnValue += pBeliefs->GetEntry(i)->GetPlayerCultureModifier();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+332]
	add	DWORD PTR _rtnValue$[esp+20], eax
$LN5@GetPlayerC:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL6@GetPlayerC

; 1507 : 			}
; 1508 : 		}
; 1509 : 	}
; 1510 : 
; 1511 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN4@GetPlayerC:
	pop	edi
	pop	esi
	pop	ebx

; 1512 : }

	pop	ecx
	ret	4
?GetPlayerCultureModifier@CvReligionBeliefs@@QBEH_N@Z ENDP ; CvReligionBeliefs::GetPlayerCultureModifier
_TEXT	ENDS
PUBLIC	?GetHappinessPerFollowingCity@CvReligionBeliefs@@QBEMXZ ; CvReligionBeliefs::GetHappinessPerFollowingCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetHappinessPerFollowingCity@CvReligionBeliefs@@QBEMXZ
_TEXT	SEGMENT
_rtnValue$ = -8						; size = 4
$T222030 = -4						; size = 4
?GetHappinessPerFollowingCity@CvReligionBeliefs@@QBEMXZ PROC ; CvReligionBeliefs::GetHappinessPerFollowingCity, COMDAT
; _this$ = ecx

; 1516 : {

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 1517 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs

; 1518 : 	float rtnValue = 0.0;
; 1519 : 
; 1520 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, ecx
	xor	esi, esi
	sar	edx, 2
	cmp	edx, esi
	mov	DWORD PTR _rtnValue$[esp+16], esi
	jle	SHORT $LN38@GetHappine@3
	push	ebx
	push	ebp
	mov	ebx, ecx
	npad	6
$LL4@GetHappine@3:

; 1521 : 	{
; 1522 : 		if(HasBelief((BeliefTypes)i))

	mov	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR [edi+140]
	mov	ebp, eax
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN35@GetHappine@3
$LL22@GetHappine@3:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN35@GetHappine@3
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL22@GetHappine@3
$LN35@GetHappine@3:
	mov	ecx, DWORD PTR [edi+140]
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN3@GetHappine@3

; 1523 : 		{
; 1524 : 			rtnValue += pBeliefs->GetEntry(i)->GetHappinessPerFollowingCity();

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+336]
	mov	DWORD PTR $T222030[esp+24], ecx
	fld	DWORD PTR $T222030[esp+24]
	fadd	DWORD PTR _rtnValue$[esp+24]
	fstp	DWORD PTR _rtnValue$[esp+24]
$LN3@GetHappine@3:
	inc	esi
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL4@GetHappine@3
	pop	ebp
	pop	ebx
$LN38@GetHappine@3:

; 1525 : 		}
; 1526 : 	}
; 1527 : 
; 1528 : 	return rtnValue;

	fld	DWORD PTR _rtnValue$[esp+16]
	pop	edi
	pop	esi

; 1529 : }

	add	esp, 8
	ret	0
?GetHappinessPerFollowingCity@CvReligionBeliefs@@QBEMXZ ENDP ; CvReligionBeliefs::GetHappinessPerFollowingCity
_TEXT	ENDS
PUBLIC	?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetGoldPerFollowingCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ PROC	; CvReligionBeliefs::GetGoldPerFollowingCity, COMDAT
; _this$ = ecx

; 1533 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1534 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1535 : 	int rtnValue = 0;
; 1536 : 
; 1537 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetGoldPer
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetGoldPer:

; 1538 : 	{
; 1539 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN35@GetGoldPer
$LL22@GetGoldPer:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN35@GetGoldPer
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetGoldPer
$LN35@GetGoldPer:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetGoldPer

; 1540 : 		{
; 1541 : 			rtnValue += pBeliefs->GetEntry(i)->GetGoldPerFollowingCity();

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+340]
	add	DWORD PTR _rtnValue$[esp+20], edx
$LN3@GetGoldPer:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetGoldPer

; 1542 : 		}
; 1543 : 	}
; 1544 : 
; 1545 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetGoldPer:
	pop	edi
	pop	esi
	pop	ebx

; 1546 : }

	pop	ecx
	ret	0
?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ ENDP	; CvReligionBeliefs::GetGoldPerFollowingCity
_TEXT	ENDS
PUBLIC	?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ	; CvReligionBeliefs::GetGoldPerXFollowers
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ PROC	; CvReligionBeliefs::GetGoldPerXFollowers, COMDAT
; _this$ = ecx

; 1550 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1551 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1552 : 	int rtnValue = 0;
; 1553 : 
; 1554 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetGoldPer@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetGoldPer@2:

; 1555 : 	{
; 1556 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN35@GetGoldPer@2
$LL22@GetGoldPer@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN35@GetGoldPer@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetGoldPer@2
$LN35@GetGoldPer@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetGoldPer@2

; 1557 : 		{
; 1558 : 			rtnValue += pBeliefs->GetEntry(i)->GetGoldPerXFollowers();

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+344]
	add	DWORD PTR _rtnValue$[esp+20], edx
$LN3@GetGoldPer@2:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetGoldPer@2

; 1559 : 		}
; 1560 : 	}
; 1561 : 
; 1562 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetGoldPer@2:
	pop	edi
	pop	esi
	pop	ebx

; 1563 : }

	pop	ecx
	ret	0
?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ ENDP	; CvReligionBeliefs::GetGoldPerXFollowers
_TEXT	ENDS
PUBLIC	?GetGoldWhenCityAdopts@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetGoldWhenCityAdopts
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldWhenCityAdopts@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetGoldWhenCityAdopts@CvReligionBeliefs@@QBEHXZ PROC	; CvReligionBeliefs::GetGoldWhenCityAdopts, COMDAT
; _this$ = ecx

; 1567 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1568 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1569 : 	int rtnValue = 0;
; 1570 : 
; 1571 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetGoldWhe
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetGoldWhe:

; 1572 : 	{
; 1573 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN35@GetGoldWhe
$LL22@GetGoldWhe:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN35@GetGoldWhe
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetGoldWhe
$LN35@GetGoldWhe:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetGoldWhe

; 1574 : 		{
; 1575 : 			rtnValue += pBeliefs->GetEntry(i)->GetGoldWhenCityAdopts();

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+348]
	add	DWORD PTR _rtnValue$[esp+20], edx
$LN3@GetGoldWhe:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetGoldWhe

; 1576 : 		}
; 1577 : 	}
; 1578 : 
; 1579 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetGoldWhe:
	pop	edi
	pop	esi
	pop	ebx

; 1580 : }

	pop	ecx
	ret	0
?GetGoldWhenCityAdopts@CvReligionBeliefs@@QBEHXZ ENDP	; CvReligionBeliefs::GetGoldWhenCityAdopts
_TEXT	ENDS
PUBLIC	?GetSciencePerOtherReligionFollower@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetSciencePerOtherReligionFollower
; Function compile flags: /Ogtpy
;	COMDAT ?GetSciencePerOtherReligionFollower@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetSciencePerOtherReligionFollower@CvReligionBeliefs@@QBEHXZ PROC ; CvReligionBeliefs::GetSciencePerOtherReligionFollower, COMDAT
; _this$ = ecx

; 1584 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1585 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1586 : 	int rtnValue = 0;
; 1587 : 
; 1588 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetScience
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetScience:

; 1589 : 	{
; 1590 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN35@GetScience
$LL22@GetScience:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN35@GetScience
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetScience
$LN35@GetScience:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetScience

; 1591 : 		{
; 1592 : 			rtnValue += pBeliefs->GetEntry(i)->GetSciencePerOtherReligionFollower();

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+352]
	add	DWORD PTR _rtnValue$[esp+20], edx
$LN3@GetScience:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetScience

; 1593 : 		}
; 1594 : 	}
; 1595 : 
; 1596 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetScience:
	pop	edi
	pop	esi
	pop	ebx

; 1597 : }

	pop	ecx
	ret	0
?GetSciencePerOtherReligionFollower@CvReligionBeliefs@@QBEHXZ ENDP ; CvReligionBeliefs::GetSciencePerOtherReligionFollower
_TEXT	ENDS
PUBLIC	?GetCityGrowthModifier@CvReligionBeliefs@@QBEH_N@Z ; CvReligionBeliefs::GetCityGrowthModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityGrowthModifier@CvReligionBeliefs@@QBEH_N@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_bAtPeace$ = 8						; size = 1
?GetCityGrowthModifier@CvReligionBeliefs@@QBEH_N@Z PROC	; CvReligionBeliefs::GetCityGrowthModifier, COMDAT
; _this$ = ecx

; 1601 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1602 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1603 : 	int rtnValue = 0;
; 1604 : 
; 1605 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN4@GetCityGro
	push	ebp
	mov	ebp, edx
	npad	4
$LL6@GetCityGro:

; 1606 : 	{
; 1607 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN43@GetCityGro
$LL24@GetCityGro:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN43@GetCityGro
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL24@GetCityGro
$LN43@GetCityGro:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN5@GetCityGro

; 1608 : 		{
; 1609 : 			if(bAtPeace || !pBeliefs->GetEntry(i)->RequiresPeace())

	cmp	BYTE PTR _bAtPeace$[esp+16], 0
	jne	SHORT $LN1@GetCityGro
	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+453], 0
	jne	SHORT $LN5@GetCityGro
$LN1@GetCityGro:

; 1610 : 			{
; 1611 : 				rtnValue += pBeliefs->GetEntry(i)->GetCityGrowthModifier();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+272]
	add	DWORD PTR _rtnValue$[esp+20], eax
$LN5@GetCityGro:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL6@GetCityGro

; 1612 : 			}
; 1613 : 		}
; 1614 : 	}
; 1615 : 
; 1616 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN4@GetCityGro:
	pop	edi
	pop	esi
	pop	ebx

; 1617 : }

	pop	ecx
	ret	4
?GetCityGrowthModifier@CvReligionBeliefs@@QBEH_N@Z ENDP	; CvReligionBeliefs::GetCityGrowthModifier
_TEXT	ENDS
PUBLIC	?GetCityYieldChange@CvReligionBeliefs@@QBEHHW4YieldTypes@@@Z ; CvReligionBeliefs::GetCityYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityYieldChange@CvReligionBeliefs@@QBEHHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_iPopulation$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetCityYieldChange@CvReligionBeliefs@@QBEHHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetCityYieldChange, COMDAT
; _this$ = ecx

; 1621 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1622 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1623 : 	int rtnValue = 0;
; 1624 : 
; 1625 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN3@GetCityYie@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL5@GetCityYie@2:

; 1626 : 	{
; 1627 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN44@GetCityYie@2
$LL23@GetCityYie@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN44@GetCityYie@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL23@GetCityYie@2
$LN44@GetCityYie@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN4@GetCityYie@2

; 1628 : 		{
; 1629 : 			if(iPopulation >= pBeliefs->GetEntry(i)->GetMinPopulation())

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR _iPopulation$[esp+16]
	cmp	edx, DWORD PTR [ecx+260]
	jl	SHORT $LN4@GetCityYie@2

; 1630 : 			{
; 1631 : 				rtnValue += pBeliefs->GetEntry(i)->GetCityYieldChange(eYield);

	mov	ecx, DWORD PTR [ecx+500]
	test	ecx, ecx
	je	SHORT $LN40@GetCityYie@2
	mov	eax, DWORD PTR _eYield$[esp+16]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN41@GetCityYie@2
$LN40@GetCityYie@2:
	or	ecx, -1
$LN41@GetCityYie@2:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN4@GetCityYie@2:

; 1623 : 	int rtnValue = 0;
; 1624 : 
; 1625 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL5@GetCityYie@2

; 1632 : 			}
; 1633 : 		}
; 1634 : 	}
; 1635 : 
; 1636 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN3@GetCityYie@2:
	pop	edi
	pop	esi
	pop	ebx

; 1637 : }

	pop	ecx
	ret	8
?GetCityYieldChange@CvReligionBeliefs@@QBEHHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetCityYieldChange
_TEXT	ENDS
PUBLIC	?GetHolyCityYieldChange@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetHolyCityYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetHolyCityYieldChange@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYield$ = 8						; size = 4
?GetHolyCityYieldChange@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetHolyCityYieldChange, COMDAT
; _this$ = ecx

; 1641 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1642 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1643 : 	int rtnValue = 0;
; 1644 : 
; 1645 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetHolyCit@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetHolyCit@2:

; 1646 : 	{
; 1647 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetHolyCit@2
$LL22@GetHolyCit@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetHolyCit@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetHolyCit@2
$LN37@GetHolyCit@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetHolyCit@2

; 1648 : 		{
; 1649 : 				rtnValue += pBeliefs->GetEntry(i)->GetHolyCityYieldChange(eYield);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+504]
	test	ecx, ecx
	je	SHORT $LN33@GetHolyCit@2
	mov	edx, DWORD PTR _eYield$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetHolyCit@2
$LN33@GetHolyCit@2:
	or	ecx, -1
$LN34@GetHolyCit@2:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetHolyCit@2:

; 1643 : 	int rtnValue = 0;
; 1644 : 
; 1645 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetHolyCit@2

; 1650 : 		}
; 1651 : 	}
; 1652 : 
; 1653 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetHolyCit@2:
	pop	edi
	pop	esi
	pop	ebx

; 1654 : }

	pop	ecx
	ret	4
?GetHolyCityYieldChange@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetHolyCityYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangePerForeignCity@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangePerForeignCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerForeignCity@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYield$ = 8						; size = 4
?GetYieldChangePerForeignCity@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetYieldChangePerForeignCity, COMDAT
; _this$ = ecx

; 1658 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1659 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1660 : 	int rtnValue = 0;
; 1661 : 
; 1662 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetYieldCh@7
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetYieldCh@7:

; 1663 : 	{
; 1664 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetYieldCh@7
$LL22@GetYieldCh@7:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetYieldCh@7
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetYieldCh@7
$LN37@GetYieldCh@7:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetYieldCh@7

; 1665 : 		{
; 1666 : 			rtnValue += pBeliefs->GetEntry(i)->GetYieldChangePerForeignCity(eYield);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+508]
	test	ecx, ecx
	je	SHORT $LN33@GetYieldCh@7
	mov	edx, DWORD PTR _eYield$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetYieldCh@7
$LN33@GetYieldCh@7:
	or	ecx, -1
$LN34@GetYieldCh@7:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetYieldCh@7:

; 1660 : 	int rtnValue = 0;
; 1661 : 
; 1662 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetYieldCh@7

; 1667 : 		}
; 1668 : 	}
; 1669 : 
; 1670 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetYieldCh@7:
	pop	edi
	pop	esi
	pop	ebx

; 1671 : }

	pop	ecx
	ret	4
?GetYieldChangePerForeignCity@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetYieldChangePerForeignCity
_TEXT	ENDS
PUBLIC	?GetYieldChangePerXForeignFollowers@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangePerXForeignFollowers
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerXForeignFollowers@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYield$ = 8						; size = 4
?GetYieldChangePerXForeignFollowers@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetYieldChangePerXForeignFollowers, COMDAT
; _this$ = ecx

; 1675 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1676 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1677 : 	int rtnValue = 0;
; 1678 : 
; 1679 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetYieldCh@8
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetYieldCh@8:

; 1680 : 	{
; 1681 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetYieldCh@8
$LL22@GetYieldCh@8:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetYieldCh@8
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetYieldCh@8
$LN37@GetYieldCh@8:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetYieldCh@8

; 1682 : 		{
; 1683 : 			rtnValue += pBeliefs->GetEntry(i)->GetYieldChangePerXForeignFollowers(eYield);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+512]
	test	ecx, ecx
	je	SHORT $LN33@GetYieldCh@8
	mov	edx, DWORD PTR _eYield$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetYieldCh@8
$LN33@GetYieldCh@8:
	or	ecx, -1
$LN34@GetYieldCh@8:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetYieldCh@8:

; 1677 : 	int rtnValue = 0;
; 1678 : 
; 1679 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetYieldCh@8

; 1684 : 		}
; 1685 : 	}
; 1686 : 
; 1687 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetYieldCh@8:
	pop	edi
	pop	esi
	pop	ebx

; 1688 : }

	pop	ecx
	ret	4
?GetYieldChangePerXForeignFollowers@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetYieldChangePerXForeignFollowers
_TEXT	ENDS
PUBLIC	?GetResourceQuantityModifier@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z ; CvReligionBeliefs::GetResourceQuantityModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceQuantityModifier@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eResource$ = 8						; size = 4
?GetResourceQuantityModifier@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z PROC ; CvReligionBeliefs::GetResourceQuantityModifier, COMDAT
; _this$ = ecx

; 1692 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1693 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1694 : 	int rtnValue = 0;
; 1695 : 
; 1696 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetResourc@4
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetResourc@4:

; 1697 : 	{
; 1698 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetResourc@4
$LL22@GetResourc@4:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetResourc@4
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetResourc@4
$LN37@GetResourc@4:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetResourc@4

; 1699 : 		{
; 1700 : 			rtnValue += pBeliefs->GetEntry(i)->GetResourceQuantityModifier(eResource);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+516]
	test	ecx, ecx
	je	SHORT $LN33@GetResourc@4
	mov	edx, DWORD PTR _eResource$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetResourc@4
$LN33@GetResourc@4:
	or	ecx, -1
$LN34@GetResourc@4:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetResourc@4:

; 1694 : 	int rtnValue = 0;
; 1695 : 
; 1696 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetResourc@4

; 1701 : 		}
; 1702 : 	}
; 1703 : 
; 1704 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetResourc@4:
	pop	edi
	pop	esi
	pop	ebx

; 1705 : }

	pop	ecx
	ret	4
?GetResourceQuantityModifier@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z ENDP ; CvReligionBeliefs::GetResourceQuantityModifier
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetImprovementYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eImprovement$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetImprovementYieldChange, COMDAT
; _this$ = ecx

; 1709 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1710 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1711 : 	int rtnValue = 0;
; 1712 : 
; 1713 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetImprove@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetImprove@2:

; 1714 : 	{
; 1715 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetImprove@2
$LL22@GetImprove@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetImprove@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetImprove@2
$LN37@GetImprove@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetImprove@2

; 1716 : 		{
; 1717 : 			rtnValue += pBeliefs->GetEntry(i)->GetImprovementYieldChange(eImprovement, eYield);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+520]
	test	ecx, ecx
	je	SHORT $LN33@GetImprove@2
	mov	edx, DWORD PTR _eImprovement$[esp+16]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eYield$[esp+16]
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN34@GetImprove@2
$LN33@GetImprove@2:
	xor	ecx, ecx
$LN34@GetImprove@2:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetImprove@2:

; 1711 : 	int rtnValue = 0;
; 1712 : 
; 1713 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetImprove@2

; 1718 : 		}
; 1719 : 	}
; 1720 : 
; 1721 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetImprove@2:
	pop	edi
	pop	esi
	pop	ebx

; 1722 : }

	pop	ecx
	ret	8
?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetImprovementYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChange@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvReligionBeliefs::GetBuildingClassYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassYieldChange@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_eYieldType$ = 12					; size = 4
_iFollowers$ = 16					; size = 4
?GetBuildingClassYieldChange@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@W4YieldTypes@@H@Z PROC ; CvReligionBeliefs::GetBuildingClassYieldChange, COMDAT
; _this$ = ecx

; 1726 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1727 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1728 : 	int rtnValue = 0;
; 1729 : 
; 1730 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN3@GetBuildin@3
	push	ebp
	mov	ebp, edx
	npad	4
$LL5@GetBuildin@3:

; 1731 : 	{
; 1732 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN42@GetBuildin@3
$LL23@GetBuildin@3:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN42@GetBuildin@3
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL23@GetBuildin@3
$LN42@GetBuildin@3:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN4@GetBuildin@3

; 1733 : 		{
; 1734 : 			if(iFollowers >= pBeliefs->GetEntry(i)->GetMinFollowers())

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR _iFollowers$[esp+16]
	cmp	edx, DWORD PTR [ecx+264]
	jl	SHORT $LN4@GetBuildin@3

; 1735 : 			{
; 1736 : 				rtnValue += pBeliefs->GetEntry(i)->GetBuildingClassYieldChange(eBuildingClass, eYieldType);

	mov	eax, DWORD PTR [ecx+524]
	mov	ecx, DWORD PTR _eBuildingClass$[esp+16]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN4@GetBuildin@3:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL5@GetBuildin@3

; 1737 : 			}
; 1738 : 		}
; 1739 : 	}
; 1740 : 
; 1741 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN3@GetBuildin@3:
	pop	edi
	pop	esi
	pop	ebx

; 1742 : }

	pop	ecx
	ret	12					; 0000000cH
?GetBuildingClassYieldChange@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@W4YieldTypes@@H@Z ENDP ; CvReligionBeliefs::GetBuildingClassYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassHappiness@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@H@Z ; CvReligionBeliefs::GetBuildingClassHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassHappiness@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@H@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_iFollowers$ = 12					; size = 4
?GetBuildingClassHappiness@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@H@Z PROC ; CvReligionBeliefs::GetBuildingClassHappiness, COMDAT
; _this$ = ecx

; 1764 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1765 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1766 : 	int rtnValue = 0;
; 1767 : 
; 1768 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN3@GetBuildin@4
	push	ebp
	mov	ebp, edx
	npad	4
$LL5@GetBuildin@4:

; 1769 : 	{
; 1770 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN44@GetBuildin@4
$LL23@GetBuildin@4:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN44@GetBuildin@4
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL23@GetBuildin@4
$LN44@GetBuildin@4:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN4@GetBuildin@4

; 1771 : 		{
; 1772 : 			if(iFollowers >= pBeliefs->GetEntry(i)->GetMinFollowers())

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR _iFollowers$[esp+16]
	cmp	edx, DWORD PTR [ecx+264]
	jl	SHORT $LN4@GetBuildin@4

; 1773 : 			{
; 1774 : 				rtnValue += pBeliefs->GetEntry(i)->GetBuildingClassHappiness(eBuildingClass);

	mov	ecx, DWORD PTR [ecx+528]
	test	ecx, ecx
	je	SHORT $LN40@GetBuildin@4
	mov	eax, DWORD PTR _eBuildingClass$[esp+16]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN41@GetBuildin@4
$LN40@GetBuildin@4:
	or	ecx, -1
$LN41@GetBuildin@4:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN4@GetBuildin@4:

; 1766 : 	int rtnValue = 0;
; 1767 : 
; 1768 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL5@GetBuildin@4

; 1775 : 			}
; 1776 : 		}
; 1777 : 	}
; 1778 : 
; 1779 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN3@GetBuildin@4:
	pop	edi
	pop	esi
	pop	ebx

; 1780 : }

	pop	ecx
	ret	8
?GetBuildingClassHappiness@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@H@Z ENDP ; CvReligionBeliefs::GetBuildingClassHappiness
_TEXT	ENDS
PUBLIC	?GetBuildingClassTourism@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@@Z ; CvReligionBeliefs::GetBuildingClassTourism
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassTourism@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
?GetBuildingClassTourism@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@@Z PROC ; CvReligionBeliefs::GetBuildingClassTourism, COMDAT
; _this$ = ecx

; 1784 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1785 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1786 : 	int rtnValue = 0;
; 1787 : 
; 1788 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetBuildin@5
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetBuildin@5:

; 1789 : 	{
; 1790 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetBuildin@5
$LL22@GetBuildin@5:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetBuildin@5
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetBuildin@5
$LN37@GetBuildin@5:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetBuildin@5

; 1791 : 		{
; 1792 : 			rtnValue += pBeliefs->GetEntry(i)->GetBuildingClassTourism(eBuildingClass);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+532]
	test	ecx, ecx
	je	SHORT $LN33@GetBuildin@5
	mov	edx, DWORD PTR _eBuildingClass$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetBuildin@5
$LN33@GetBuildin@5:
	or	ecx, -1
$LN34@GetBuildin@5:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetBuildin@5:

; 1786 : 	int rtnValue = 0;
; 1787 : 
; 1788 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetBuildin@5

; 1793 : 		}
; 1794 : 	}
; 1795 : 
; 1796 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetBuildin@5:
	pop	edi
	pop	esi
	pop	ebx

; 1797 : }

	pop	ecx
	ret	4
?GetBuildingClassTourism@CvReligionBeliefs@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvReligionBeliefs::GetBuildingClassTourism
_TEXT	ENDS
PUBLIC	?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetFeatureYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eFeature$ = 8						; size = 4
_eYieldType$ = 12					; size = 4
?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetFeatureYieldChange, COMDAT
; _this$ = ecx

; 1801 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1802 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1803 : 	int rtnValue = 0;
; 1804 : 
; 1805 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetFeature@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetFeature@2:

; 1806 : 	{
; 1807 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetFeature@2
$LL22@GetFeature@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetFeature@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetFeature@2
$LN37@GetFeature@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetFeature@2

; 1808 : 		{
; 1809 : 			rtnValue += pBeliefs->GetEntry(i)->GetFeatureYieldChange(eFeature, eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+536]
	test	ecx, ecx
	je	SHORT $LN33@GetFeature@2
	mov	edx, DWORD PTR _eFeature$[esp+16]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN34@GetFeature@2
$LN33@GetFeature@2:
	or	ecx, -1
$LN34@GetFeature@2:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetFeature@2:

; 1803 : 	int rtnValue = 0;
; 1804 : 
; 1805 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetFeature@2

; 1810 : 		}
; 1811 : 	}
; 1812 : 
; 1813 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetFeature@2:
	pop	edi
	pop	esi
	pop	ebx

; 1814 : }

	pop	ecx
	ret	8
?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetFeatureYieldChange
_TEXT	ENDS
PUBLIC	?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetResourceYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eResource$ = 8						; size = 4
_eYieldType$ = 12					; size = 4
?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetResourceYieldChange, COMDAT
; _this$ = ecx

; 1818 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1819 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1820 : 	int rtnValue = 0;
; 1821 : 
; 1822 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetResourc@5
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetResourc@5:

; 1823 : 	{
; 1824 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetResourc@5
$LL22@GetResourc@5:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetResourc@5
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetResourc@5
$LN37@GetResourc@5:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetResourc@5

; 1825 : 		{
; 1826 : 			rtnValue += pBeliefs->GetEntry(i)->GetResourceYieldChange(eResource, eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+540]
	test	ecx, ecx
	je	SHORT $LN33@GetResourc@5
	mov	edx, DWORD PTR _eResource$[esp+16]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN34@GetResourc@5
$LN33@GetResourc@5:
	or	ecx, -1
$LN34@GetResourc@5:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetResourc@5:

; 1820 : 	int rtnValue = 0;
; 1821 : 
; 1822 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetResourc@5

; 1827 : 		}
; 1828 : 	}
; 1829 : 
; 1830 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetResourc@5:
	pop	edi
	pop	esi
	pop	ebx

; 1831 : }

	pop	ecx
	ret	8
?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetResourceYieldChange
_TEXT	ENDS
PUBLIC	?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetTerrainYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eTerrain$ = 8						; size = 4
_eYieldType$ = 12					; size = 4
?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetTerrainYieldChange, COMDAT
; _this$ = ecx

; 1835 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1836 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1837 : 	int rtnValue = 0;
; 1838 : 
; 1839 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetTerrain@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetTerrain@2:

; 1840 : 	{
; 1841 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetTerrain@2
$LL22@GetTerrain@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetTerrain@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetTerrain@2
$LN37@GetTerrain@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetTerrain@2

; 1842 : 		{
; 1843 : 			rtnValue += pBeliefs->GetEntry(i)->GetTerrainYieldChange(eTerrain, eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+544]
	test	ecx, ecx
	je	SHORT $LN33@GetTerrain@2
	mov	edx, DWORD PTR _eTerrain$[esp+16]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN34@GetTerrain@2
$LN33@GetTerrain@2:
	or	ecx, -1
$LN34@GetTerrain@2:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetTerrain@2:

; 1837 : 	int rtnValue = 0;
; 1838 : 
; 1839 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetTerrain@2

; 1844 : 		}
; 1845 : 	}
; 1846 : 
; 1847 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetTerrain@2:
	pop	edi
	pop	esi
	pop	ebx

; 1848 : }

	pop	ecx
	ret	8
?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetTerrainYieldChange
_TEXT	ENDS
PUBLIC	?GetResourceHappiness@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z ; CvReligionBeliefs::GetResourceHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceHappiness@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eResource$ = 8						; size = 4
?GetResourceHappiness@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z PROC ; CvReligionBeliefs::GetResourceHappiness, COMDAT
; _this$ = ecx

; 1852 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1853 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1854 : 	int rtnValue = 0;
; 1855 : 
; 1856 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetResourc@6
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetResourc@6:

; 1857 : 	{
; 1858 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetResourc@6
$LL22@GetResourc@6:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetResourc@6
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetResourc@6
$LN37@GetResourc@6:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetResourc@6

; 1859 : 		{
; 1860 : 			rtnValue += pBeliefs->GetEntry(i)->GetResourceHappiness(eResource);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+548]
	test	ecx, ecx
	je	SHORT $LN33@GetResourc@6
	mov	edx, DWORD PTR _eResource$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetResourc@6
$LN33@GetResourc@6:
	or	ecx, -1
$LN34@GetResourc@6:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetResourc@6:

; 1854 : 	int rtnValue = 0;
; 1855 : 
; 1856 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetResourc@6

; 1861 : 		}
; 1862 : 	}
; 1863 : 
; 1864 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetResourc@6:
	pop	edi
	pop	esi
	pop	ebx

; 1865 : }

	pop	ecx
	ret	4
?GetResourceHappiness@CvReligionBeliefs@@QBEHW4ResourceTypes@@@Z ENDP ; CvReligionBeliefs::GetResourceHappiness
_TEXT	ENDS
PUBLIC	?GetYieldChangeAnySpecialist@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangeAnySpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeAnySpecialist@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYieldType$ = 8					; size = 4
?GetYieldChangeAnySpecialist@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetYieldChangeAnySpecialist, COMDAT
; _this$ = ecx

; 1869 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1870 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1871 : 	int rtnValue = 0;
; 1872 : 
; 1873 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetYieldCh@9
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetYieldCh@9:

; 1874 : 	{
; 1875 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetYieldCh@9
$LL22@GetYieldCh@9:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetYieldCh@9
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetYieldCh@9
$LN37@GetYieldCh@9:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetYieldCh@9

; 1876 : 		{
; 1877 : 			rtnValue += pBeliefs->GetEntry(i)->GetYieldChangeAnySpecialist(eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+552]
	test	ecx, ecx
	je	SHORT $LN33@GetYieldCh@9
	mov	edx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetYieldCh@9
$LN33@GetYieldCh@9:
	or	ecx, -1
$LN34@GetYieldCh@9:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetYieldCh@9:

; 1871 : 	int rtnValue = 0;
; 1872 : 
; 1873 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetYieldCh@9

; 1878 : 		}
; 1879 : 	}
; 1880 : 
; 1881 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetYieldCh@9:
	pop	edi
	pop	esi
	pop	ebx

; 1882 : }

	pop	ecx
	ret	4
?GetYieldChangeAnySpecialist@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetYieldChangeAnySpecialist
_TEXT	ENDS
PUBLIC	?GetYieldChangeTradeRoute@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangeTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeTradeRoute@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYieldType$ = 8					; size = 4
?GetYieldChangeTradeRoute@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetYieldChangeTradeRoute, COMDAT
; _this$ = ecx

; 1886 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1887 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1888 : 	int rtnValue = 0;
; 1889 : 
; 1890 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetYieldCh@10
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetYieldCh@10:

; 1891 : 	{
; 1892 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetYieldCh@10
$LL22@GetYieldCh@10:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetYieldCh@10
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetYieldCh@10
$LN37@GetYieldCh@10:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetYieldCh@10

; 1893 : 		{
; 1894 : 			rtnValue += pBeliefs->GetEntry(i)->GetYieldChangeTradeRoute(eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+556]
	test	ecx, ecx
	je	SHORT $LN33@GetYieldCh@10
	mov	edx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetYieldCh@10
$LN33@GetYieldCh@10:
	or	ecx, -1
$LN34@GetYieldCh@10:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetYieldCh@10:

; 1888 : 	int rtnValue = 0;
; 1889 : 
; 1890 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetYieldCh@10

; 1895 : 		}
; 1896 : 	}
; 1897 : 
; 1898 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetYieldCh@10:
	pop	edi
	pop	esi
	pop	ebx

; 1899 : }

	pop	ecx
	ret	4
?GetYieldChangeTradeRoute@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetYieldChangeTradeRoute
_TEXT	ENDS
PUBLIC	?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangeNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYieldType$ = 8					; size = 4
?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetYieldChangeNaturalWonder, COMDAT
; _this$ = ecx

; 1903 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1904 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1905 : 	int rtnValue = 0;
; 1906 : 
; 1907 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetYieldCh@11
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetYieldCh@11:

; 1908 : 	{
; 1909 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetYieldCh@11
$LL22@GetYieldCh@11:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetYieldCh@11
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetYieldCh@11
$LN37@GetYieldCh@11:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetYieldCh@11

; 1910 : 		{
; 1911 : 			rtnValue += pBeliefs->GetEntry(i)->GetYieldChangeNaturalWonder(eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+560]
	test	ecx, ecx
	je	SHORT $LN33@GetYieldCh@11
	mov	edx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetYieldCh@11
$LN33@GetYieldCh@11:
	or	ecx, -1
$LN34@GetYieldCh@11:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetYieldCh@11:

; 1905 : 	int rtnValue = 0;
; 1906 : 
; 1907 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetYieldCh@11

; 1912 : 		}
; 1913 : 	}
; 1914 : 
; 1915 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetYieldCh@11:
	pop	edi
	pop	esi
	pop	ebx

; 1916 : }

	pop	ecx
	ret	4
?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetYieldChangeNaturalWonder
_TEXT	ENDS
PUBLIC	?GetYieldChangeWorldWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangeWorldWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeWorldWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYieldType$ = 8					; size = 4
?GetYieldChangeWorldWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetYieldChangeWorldWonder, COMDAT
; _this$ = ecx

; 1920 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1921 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1922 : 	int rtnValue = 0;
; 1923 : 
; 1924 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetYieldCh@12
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetYieldCh@12:

; 1925 : 	{
; 1926 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetYieldCh@12
$LL22@GetYieldCh@12:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetYieldCh@12
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetYieldCh@12
$LN37@GetYieldCh@12:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetYieldCh@12

; 1927 : 		{
; 1928 : 			rtnValue += pBeliefs->GetEntry(i)->GetYieldChangeWorldWonder(eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+564]
	test	ecx, ecx
	je	SHORT $LN33@GetYieldCh@12
	mov	edx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetYieldCh@12
$LN33@GetYieldCh@12:
	or	ecx, -1
$LN34@GetYieldCh@12:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetYieldCh@12:

; 1922 : 	int rtnValue = 0;
; 1923 : 
; 1924 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetYieldCh@12

; 1929 : 		}
; 1930 : 	}
; 1931 : 
; 1932 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetYieldCh@12:
	pop	edi
	pop	esi
	pop	ebx

; 1933 : }

	pop	ecx
	ret	4
?GetYieldChangeWorldWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetYieldChangeWorldWonder
_TEXT	ENDS
PUBLIC	?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldModifierNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYieldType$ = 8					; size = 4
?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetYieldModifierNaturalWonder, COMDAT
; _this$ = ecx

; 1937 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1938 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1939 : 	int rtnValue = 0;
; 1940 : 
; 1941 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetYieldMo@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetYieldMo@2:

; 1942 : 	{
; 1943 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetYieldMo@2
$LL22@GetYieldMo@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetYieldMo@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetYieldMo@2
$LN37@GetYieldMo@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetYieldMo@2

; 1944 : 		{
; 1945 : 			rtnValue += pBeliefs->GetEntry(i)->GetYieldModifierNaturalWonder(eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+568]
	test	ecx, ecx
	je	SHORT $LN33@GetYieldMo@2
	mov	edx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetYieldMo@2
$LN33@GetYieldMo@2:
	or	ecx, -1
$LN34@GetYieldMo@2:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetYieldMo@2:

; 1939 : 	int rtnValue = 0;
; 1940 : 
; 1941 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetYieldMo@2

; 1946 : 		}
; 1947 : 	}
; 1948 : 
; 1949 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetYieldMo@2:
	pop	edi
	pop	esi
	pop	ebx

; 1950 : }

	pop	ecx
	ret	4
?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetYieldModifierNaturalWonder
_TEXT	ENDS
PUBLIC	?GetMaxYieldModifierPerFollower@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetMaxYieldModifierPerFollower
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxYieldModifierPerFollower@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
_eYieldType$ = 8					; size = 4
?GetMaxYieldModifierPerFollower@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z PROC ; CvReligionBeliefs::GetMaxYieldModifierPerFollower, COMDAT
; _this$ = ecx

; 1954 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1955 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1956 : 	int rtnValue = 0;
; 1957 : 
; 1958 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetMaxYiel@2
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetMaxYiel@2:

; 1959 : 	{
; 1960 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN37@GetMaxYiel@2
$LL22@GetMaxYiel@2:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN37@GetMaxYiel@2
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetMaxYiel@2
$LN37@GetMaxYiel@2:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetMaxYiel@2

; 1961 : 		{
; 1962 : 			rtnValue += pBeliefs->GetEntry(i)->GetMaxYieldModifierPerFollower(eYieldType);

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+572]
	test	ecx, ecx
	je	SHORT $LN33@GetMaxYiel@2
	mov	edx, DWORD PTR _eYieldType$[esp+16]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN34@GetMaxYiel@2
$LN33@GetMaxYiel@2:
	or	ecx, -1
$LN34@GetMaxYiel@2:
	add	DWORD PTR _rtnValue$[esp+20], ecx
$LN3@GetMaxYiel@2:

; 1956 : 	int rtnValue = 0;
; 1957 : 
; 1958 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetMaxYiel@2

; 1963 : 		}
; 1964 : 	}
; 1965 : 
; 1966 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetMaxYiel@2:
	pop	edi
	pop	esi
	pop	ebx

; 1967 : }

	pop	ecx
	ret	4
?GetMaxYieldModifierPerFollower@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ENDP ; CvReligionBeliefs::GetMaxYieldModifierPerFollower
_TEXT	ENDS
PUBLIC	?GetNumFreeSettlers@CvReligionBeliefs@@QBEHXZ	; CvReligionBeliefs::GetNumFreeSettlers
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeSettlers@CvReligionBeliefs@@QBEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetNumFreeSettlers@CvReligionBeliefs@@QBEHXZ PROC	; CvReligionBeliefs::GetNumFreeSettlers, COMDAT
; _this$ = ecx

; 1972 : {

	push	ecx
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1973 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax

; 1974 : 	int rtnValue = 0;
; 1975 : 
; 1976 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edx
	xor	eax, eax
	sar	esi, 2
	xor	edi, edi
	mov	DWORD PTR _rtnValue$[esp+16], eax
	test	esi, esi
	jle	SHORT $LN2@GetNumFree
	push	ebp
	mov	ebp, edx
	npad	4
$LL4@GetNumFree:

; 1977 : 	{
; 1978 : 		if(HasBelief((BeliefTypes)i))

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+140]
	mov	edx, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	cmp	ecx, edx
	je	SHORT $LN35@GetNumFree
$LL22@GetNumFree:
	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN35@GetNumFree
	add	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL22@GetNumFree
$LN35@GetNumFree:
	mov	edx, DWORD PTR [ebx+136]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	ecx, eax
	je	SHORT $LN3@GetNumFree

; 1979 : 		{
; 1980 : 			rtnValue += pBeliefs->GetEntry(i)->GetNumFreeSettlers();

	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx+444]
	add	DWORD PTR _rtnValue$[esp+20], edx
$LN3@GetNumFree:
	inc	edi
	add	ebp, 4
	cmp	edi, esi
	jl	SHORT $LL4@GetNumFree

; 1981 : 		}
; 1982 : 	}
; 1983 : 
; 1984 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[esp+20]
	pop	ebp
$LN2@GetNumFree:
	pop	edi
	pop	esi
	pop	ebx

; 1985 : }

	pop	ecx
	ret	0
?GetNumFreeSettlers@CvReligionBeliefs@@QBEHXZ ENDP	; CvReligionBeliefs::GetNumFreeSettlers
_TEXT	ENDS
PUBLIC	?IsFaithBuyingEnabled@CvReligionBeliefs@@QBE_NW4EraTypes@@@Z ; CvReligionBeliefs::IsFaithBuyingEnabled
; Function compile flags: /Ogtpy
;	COMDAT ?IsFaithBuyingEnabled@CvReligionBeliefs@@QBE_NW4EraTypes@@@Z
_TEXT	SEGMENT
_eEra$ = 8						; size = 4
?IsFaithBuyingEnabled@CvReligionBeliefs@@QBE_NW4EraTypes@@@Z PROC ; CvReligionBeliefs::IsFaithBuyingEnabled, COMDAT
; _this$ = ecx

; 1996 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1997 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs

; 1998 : 
; 1999 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, ecx
	sar	edx, 2
	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN3@IsFaithBuy

; 1997 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ebx, ecx
	npad	13
$LL5@IsFaithBuy:

; 2000 : 	{
; 2001 : 		if(HasBelief((BeliefTypes)i))

	mov	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR [edi+140]
	mov	ebp, eax
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN38@IsFaithBuy
$LL23@IsFaithBuy:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN38@IsFaithBuy
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL23@IsFaithBuy
$LN38@IsFaithBuy:
	mov	ecx, DWORD PTR [edi+140]
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN4@IsFaithBuy

; 2002 : 		{
; 2003 : 			if (pBeliefs->GetEntry(i)->IsFaithUnitPurchaseEra((int)eEra))

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+576]
	test	eax, eax
	je	SHORT $LN4@IsFaithBuy
	mov	ecx, DWORD PTR _eEra$[esp+12]
	cmp	BYTE PTR [eax+ecx], 0
	jne	SHORT $LN39@IsFaithBuy
$LN4@IsFaithBuy:

; 1998 : 
; 1999 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	esi
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL5@IsFaithBuy
$LN3@IsFaithBuy:
	pop	edi
	pop	esi
	pop	ebp

; 2006 : 			}
; 2007 : 		}
; 2008 : 	}
; 2009 : 
; 2010 : 	return false;

	xor	al, al
	pop	ebx

; 2011 : }

	ret	4
$LN39@IsFaithBuy:
	pop	edi
	pop	esi
	pop	ebp

; 2004 : 			{
; 2005 : 				return true;

	mov	al, 1
	pop	ebx

; 2011 : }

	ret	4
?IsFaithBuyingEnabled@CvReligionBeliefs@@QBE_NW4EraTypes@@@Z ENDP ; CvReligionBeliefs::IsFaithBuyingEnabled
_TEXT	ENDS
PUBLIC	?IsConvertsBarbarians@CvReligionBeliefs@@QBE_NXZ ; CvReligionBeliefs::IsConvertsBarbarians
; Function compile flags: /Ogtpy
;	COMDAT ?IsConvertsBarbarians@CvReligionBeliefs@@QBE_NXZ
_TEXT	SEGMENT
?IsConvertsBarbarians@CvReligionBeliefs@@QBE_NXZ PROC	; CvReligionBeliefs::IsConvertsBarbarians, COMDAT
; _this$ = ecx

; 2015 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2016 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs

; 2017 : 
; 2018 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, ecx
	sar	edx, 2
	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN3@IsConverts

; 2016 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ebx, ecx
	npad	13
$LL5@IsConverts:

; 2019 : 	{
; 2020 : 		if(HasBelief((BeliefTypes)i))

	mov	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR [edi+140]
	mov	ebp, eax
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN36@IsConverts
$LL23@IsConverts:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN36@IsConverts
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL23@IsConverts
$LN36@IsConverts:
	mov	ecx, DWORD PTR [edi+140]
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN4@IsConverts

; 2021 : 		{
; 2022 : 			if (pBeliefs->GetEntry(i)->ConvertsBarbarians())

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+454], 0
	jne	SHORT $LN37@IsConverts
$LN4@IsConverts:

; 2017 : 
; 2018 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	esi
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL5@IsConverts
$LN3@IsConverts:
	pop	edi
	pop	esi
	pop	ebp

; 2025 : 			}
; 2026 : 		}
; 2027 : 	}
; 2028 : 
; 2029 : 	return false;

	xor	al, al
	pop	ebx

; 2030 : }

	ret	0
$LN37@IsConverts:
	pop	edi
	pop	esi
	pop	ebp

; 2023 : 			{
; 2024 : 				return true;

	mov	al, 1
	pop	ebx

; 2030 : }

	ret	0
?IsConvertsBarbarians@CvReligionBeliefs@@QBE_NXZ ENDP	; CvReligionBeliefs::IsConvertsBarbarians
_TEXT	ENDS
PUBLIC	?IsDeusVult@CvReligionBeliefs@@QBE_NXZ		; CvReligionBeliefs::IsDeusVult
; Function compile flags: /Ogtpy
;	COMDAT ?IsDeusVult@CvReligionBeliefs@@QBE_NXZ
_TEXT	SEGMENT
?IsDeusVult@CvReligionBeliefs@@QBE_NXZ PROC		; CvReligionBeliefs::IsDeusVult, COMDAT
; _this$ = ecx

; 2035 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2036 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs

; 2037 : 
; 2038 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, ecx
	sar	edx, 2
	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN3@IsDeusVult

; 2036 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ebx, ecx
	npad	13
$LL5@IsDeusVult:

; 2039 : 	{
; 2040 : 		if(HasBelief((BeliefTypes)i))

	mov	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR [edi+140]
	mov	ebp, eax
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN36@IsDeusVult
$LL23@IsDeusVult:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN36@IsDeusVult
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL23@IsDeusVult
$LN36@IsDeusVult:
	mov	ecx, DWORD PTR [edi+140]
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN4@IsDeusVult

; 2041 : 		{
; 2042 : 			if (pBeliefs->GetEntry(i)->DeusVult())

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+455], 0
	jne	SHORT $LN37@IsDeusVult
$LN4@IsDeusVult:

; 2037 : 
; 2038 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	esi
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL5@IsDeusVult
$LN3@IsDeusVult:
	pop	edi
	pop	esi
	pop	ebp

; 2045 : 			}
; 2046 : 		}
; 2047 : 	}
; 2048 : 
; 2049 : 	return false;

	xor	al, al
	pop	ebx

; 2050 : }

	ret	0
$LN37@IsDeusVult:
	pop	edi
	pop	esi
	pop	ebp

; 2043 : 			{
; 2044 : 				return true;

	mov	al, 1
	pop	ebx

; 2050 : }

	ret	0
?IsDeusVult@CvReligionBeliefs@@QBE_NXZ ENDP		; CvReligionBeliefs::IsDeusVult
_TEXT	ENDS
PUBLIC	?IsFaithPurchaseAllGreatPeople@CvReligionBeliefs@@QBE_NXZ ; CvReligionBeliefs::IsFaithPurchaseAllGreatPeople
; Function compile flags: /Ogtpy
;	COMDAT ?IsFaithPurchaseAllGreatPeople@CvReligionBeliefs@@QBE_NXZ
_TEXT	SEGMENT
?IsFaithPurchaseAllGreatPeople@CvReligionBeliefs@@QBE_NXZ PROC ; CvReligionBeliefs::IsFaithPurchaseAllGreatPeople, COMDAT
; _this$ = ecx

; 2055 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2056 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs

; 2057 : 
; 2058 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, ecx
	sar	edx, 2
	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN3@IsFaithPur

; 2056 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ebx, ecx
	npad	13
$LL5@IsFaithPur:

; 2059 : 	{
; 2060 : 		if(HasBelief((BeliefTypes)i))

	mov	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR [edi+140]
	mov	ebp, eax
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN36@IsFaithPur
$LL23@IsFaithPur:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN36@IsFaithPur
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL23@IsFaithPur
$LN36@IsFaithPur:
	mov	ecx, DWORD PTR [edi+140]
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN4@IsFaithPur

; 2061 : 		{
; 2062 : 			if (pBeliefs->GetEntry(i)->FaithPurchaseAllGreatPeople())

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+456], 0
	jne	SHORT $LN37@IsFaithPur
$LN4@IsFaithPur:

; 2057 : 
; 2058 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	esi
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL5@IsFaithPur
$LN3@IsFaithPur:
	pop	edi
	pop	esi
	pop	ebp

; 2065 : 			}
; 2066 : 		}
; 2067 : 	}
; 2068 : 
; 2069 : 	return false;

	xor	al, al
	pop	ebx

; 2070 : }

	ret	0
$LN37@IsFaithPur:
	pop	edi
	pop	esi
	pop	ebp

; 2063 : 			{
; 2064 : 				return true;

	mov	al, 1
	pop	ebx

; 2070 : }

	ret	0
?IsFaithPurchaseAllGreatPeople@CvReligionBeliefs@@QBE_NXZ ENDP ; CvReligionBeliefs::IsFaithPurchaseAllGreatPeople
_TEXT	ENDS
PUBLIC	?IsAllowsFaithGiftsToMinors@CvReligionBeliefs@@QBE_NXZ ; CvReligionBeliefs::IsAllowsFaithGiftsToMinors
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsFaithGiftsToMinors@CvReligionBeliefs@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsFaithGiftsToMinors@CvReligionBeliefs@@QBE_NXZ PROC ; CvReligionBeliefs::IsAllowsFaithGiftsToMinors, COMDAT
; _this$ = ecx

; 2075 : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2076 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs

; 2077 : 
; 2078 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, ecx
	sar	edx, 2
	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN3@IsAllowsFa

; 2076 : 	CvBeliefXMLEntries* pBeliefs = GC.GetGameBeliefs();

	mov	ebx, ecx
	npad	13
$LL5@IsAllowsFa:

; 2079 : 	{
; 2080 : 		if(HasBelief((BeliefTypes)i))

	mov	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR [edi+140]
	mov	ebp, eax
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN36@IsAllowsFa
$LL23@IsAllowsFa:
	cmp	DWORD PTR [eax], esi
	je	SHORT $LN36@IsAllowsFa
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL23@IsAllowsFa
$LN36@IsAllowsFa:
	mov	ecx, DWORD PTR [edi+140]
	lea	ecx, DWORD PTR [ebp+ecx*4]
	cmp	eax, ecx
	je	SHORT $LN4@IsAllowsFa

; 2081 : 		{
; 2082 : 			if (pBeliefs->GetEntry(i)->AllowsFaithGiftsToMinors())

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+457], 0
	jne	SHORT $LN37@IsAllowsFa
$LN4@IsAllowsFa:

; 2077 : 
; 2078 : 	for(int i = 0; i < pBeliefs->GetNumBeliefs(); i++)

	inc	esi
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL5@IsAllowsFa
$LN3@IsAllowsFa:
	pop	edi
	pop	esi
	pop	ebp

; 2085 : 			}
; 2086 : 		}
; 2087 : 	}
; 2088 : 
; 2089 : 	return false;

	xor	al, al
	pop	ebx

; 2090 : }

	ret	0
$LN37@IsAllowsFa:
	pop	edi
	pop	esi
	pop	ebp

; 2083 : 			{
; 2084 : 				return true;

	mov	al, 1
	pop	ebx

; 2090 : }

	ret	0
?IsAllowsFaithGiftsToMinors@CvReligionBeliefs@@QBE_NXZ ENDP ; CvReligionBeliefs::IsAllowsFaithGiftsToMinors
_TEXT	ENDS
PUBLIC	?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvBeliefHelpers::ConvertBarbarianUnit
EXTRN	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlot::SetPlayerThatClearedBarbCampHere
EXTRN	?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z:PROC ; CvBarbarians::DoBarbCampCleared
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z:PROC ; CvHomelandAI::LogHomelandMessage
EXTRN	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ:PROC ; CvPlayer::GetHomelandAI
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?setupGraphical@CvUnit@@QAEXXZ:PROC		; CvUnit::setupGraphical
EXTRN	?convert@CvUnit@@QAEXPAV1@_N@Z:PROC		; CvUnit::convert
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$4
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
xdata$x	ENDS
;	COMDAT ?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T224738 = -112						; size = 4
$T224742 = -108						; size = 4
_pNewUnit$ = -104					; size = 8
_logMsg$219405 = -96					; size = 28
_strSummary$ = -68					; size = 28
_strBuffer$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
_pUnit$ = 12						; size = 8
?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvBeliefHelpers::ConvertBarbarianUnit, COMDAT

; 2240 : {

	push	-1
	push	__ehhandler$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+136], eax

; 2241 : 	UnitHandle pNewUnit;

	mov	DWORD PTR _pNewUnit$[esp+128], eax
	mov	BYTE PTR _pNewUnit$[esp+132], al

; 2242 : 	CvPlot *pPlot = pUnit->plot();

	mov	ecx, DWORD PTR _pUnit$[esp+124]
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 2243 : 
; 2244 : 	// Convert the barbarian into our unit
; 2245 : #ifdef AUI_UNIT_FIX_GIFTED_UNITS_ARE_GIFTED_NOT_CLONED
; 2246 : 	pNewUnit = pPlayer->initUnit(pUnit->getUnitType(), pUnit->getX(), pUnit->getY(), pUnit->AI_getUnitAIType(), NO_DIRECTION, true /*bNoMove*/, false, DEFAULT_UNIT_MAP_LAYER, 0, true);
; 2247 : #else
; 2248 : 	pNewUnit = pPlayer->initUnit(pUnit->getUnitType(), pUnit->getX(), pUnit->getY(), pUnit->AI_getUnitAIType(), NO_DIRECTION, true /*bNoMove*/, false);

	mov	ecx, DWORD PTR _pUnit$[esp+124]
	mov	esi, DWORD PTR [ecx+88]
	mov	edi, DWORD PTR [ecx+76]
	push	0
	push	0
	push	0
	push	1
	push	-1
	mov	ebp, eax
	mov	ebx, ecx
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	push	eax
	push	esi
	push	edi
	mov	ecx, ebx
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	edi, DWORD PTR _pPlayer$[esp+156]
	push	eax
	mov	ecx, edi
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	esi, eax
	mov	DWORD PTR _pNewUnit$[esp+128], esi
	test	esi, esi
	je	SHORT $LN36@ConvertBar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN36@ConvertBar:

; 2249 : #endif
; 2250 : 	CvAssertMsg(pNewUnit, "pNewUnit is not assigned a valid value");
; 2251 : 	pNewUnit->convert(pUnit.pointer(), false);

	mov	eax, DWORD PTR _pUnit$[esp+124]
	push	0
	push	eax
	mov	ecx, esi
	call	?convert@CvUnit@@QAEXPAV1@_N@Z		; CvUnit::convert

; 2252 : 	pNewUnit->setupGraphical();

	mov	ecx, esi
	call	?setupGraphical@CvUnit@@QAEXXZ		; CvUnit::setupGraphical

; 2253 : 	pNewUnit->finishMoves(); // No move first turn

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2254 : 
; 2255 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN2@ConvertBar
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN2@ConvertBar

; 2256 : 	{
; 2257 : 		CvString logMsg;

	lea	ecx, DWORD PTR _logMsg$219405[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2258 : 		logMsg.Format("Converted barbarian (with belief), X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$[esp+124]
	mov	ecx, DWORD PTR [eax+88]
	mov	eax, DWORD PTR [eax+76]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _logMsg$219405[esp+136]
	push	OFFSET $SG219406
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+152], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2259 : 		pPlayer->GetHomelandAI()->LogHomelandMessage(logMsg);

	lea	edx, DWORD PTR _logMsg$219405[esp+128]
	push	edx
	mov	ecx, edi
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2260 : 	}

	lea	ecx, DWORD PTR _logMsg$219405[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ConvertBar:

; 2261 : 
; 2262 : 	CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_HEATHEN_CONVERTS");

	lea	eax, DWORD PTR _strBuffer$[esp+128]
	push	OFFSET $SG219409
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 2263 : 	CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_HEATHEN_CONVERTS");

	lea	ecx, DWORD PTR _strSummary$[esp+136]
	push	OFFSET $SG219412
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+152], 3
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 16					; 00000010H

; 2264 : 	pPlayer->GetNotifications()->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pUnit->getX(), pUnit->getY(), -1);

	mov	eax, DWORD PTR _pUnit$[esp+124]
	mov	edx, DWORD PTR [eax+76]
	mov	ebx, DWORD PTR [eax+88]
	lea	ecx, DWORD PTR _strSummary$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 4
	mov	DWORD PTR $T224738[esp+128], edx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strBuffer$[esp+128]
	mov	DWORD PTR $T224742[esp+128], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR $T224738[esp+128]
	mov	edx, DWORD PTR $T224742[esp+128]
	push	-1
	push	-1
	push	ebx
	push	ecx
	push	edx
	push	eax
	push	-1097390650				; be9725c6H
	mov	ecx, edi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2265 : 
; 2266 : 	if (pPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, ebp
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, ebx
	jne	SHORT $LN107@ConvertBar

; 2267 : 	{
; 2268 : 		pPlot->setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, ebp
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 2269 : 
; 2270 : 		CvBarbarians::DoBarbCampCleared(pPlot, pPlayer->GetID());

	mov	eax, DWORD PTR [edi+44]
	push	eax
	push	ebp
	call	?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z ; CvBarbarians::DoBarbCampCleared

; 2271 : 		pPlot->SetPlayerThatClearedBarbCampHere(pPlayer->GetID());

	mov	edi, DWORD PTR [edi+44]
	add	esp, 8
	push	edi
	mov	ecx, ebp
	call	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatClearedBarbCampHere
$LN107@ConvertBar:

; 2272 : 
; 2273 : 		// Don't give gold for Camps cleared by heathen conversion
; 2274 : 	}
; 2275 : 
; 2276 : 	return true;

	lea	ecx, DWORD PTR _strSummary$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$[esp+128]
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+136], 0
	test	esi, esi
	je	SHORT $LN99@ConvertBar
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN99@ConvertBar:
	mov	ecx, DWORD PTR _pUnit$[esp+124]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+124], -1
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN106@ConvertBar
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN106@ConvertBar:

; 2277 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	mov	al, 1
	mov	DWORD PTR fs:0, ecx
	add	esp, 112				; 00000070H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _pNewUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR _logMsg$219405[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z$4:
	lea	ecx, DWORD PTR _strSummary$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConvertBarbarianUnit@CvBeliefHelpers@@YA_NPAVCvPlayer@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvBeliefHelpers::ConvertBarbarianUnit
PUBLIC	?begin@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@XZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::end
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,5,0,297,0>::~FStaticVector<int,5,0,297,0>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,5,0,297,0>::~FStaticVector<int,5,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,5,0,297,0>::~FStaticVector<int,5,0,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<int,5,0,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEXABV0@@Z PROC	; FStaticVector<int,5,0,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@3

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@3:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 5
	jbe	SHORT $LN16@operator@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	ecx, DWORD PTR [edi*4]
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	ebx

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	push	ebp
	mov	ecx, esi
	mov	DWORD PTR [esi], eax
	call	?Copy@?$BaseVector@H$0A@@@IAEXABV1@@Z	; BaseVector<int,0>::Copy
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

$LN16@operator@3:
	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [esi+8], 5
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@3:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	push	ebp
	mov	ecx, esi
	call	?Copy@?$BaseVector@H$0A@@@IAEXABV1@@Z	; BaseVector<int,0>::Copy
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEXABV0@@Z ENDP	; FStaticVector<int,5,0,297,0>::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@KAXXZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvBeliefEntry@@@std@@YAPAPAVCvBeliefEntry@@IPAPAV1@@Z ; std::_Allocate<CvBeliefEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,0,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,5,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	5
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN33@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN33@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, 5
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 5
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN1@GrowSize
	mov	ecx, ebp
$LL3@GrowSize:

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN2@GrowSize
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN2@GrowSize:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL3@GrowSize
$LN1@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN37@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN37@GrowSize:
	pop	edi

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+32], 1
	pop	esi
	pop	ebp

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,5,0,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXPAPAVCvBeliefEntry@@0@Z ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXPAPAVCvBeliefEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXPAPAVCvBeliefEntry@@0@Z PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXPAPAVCvBeliefEntry@@0@Z ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvBeliefEntry@@@@YAXAAPAVCvBeliefEntry@@@Z ; SAFE_DELETE<CvBeliefEntry>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvBeliefEntry@@@@YAXAAPAVCvBeliefEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvBeliefEntry@@@@YAXAAPAVCvBeliefEntry@@@Z PROC ; SAFE_DELETE<CvBeliefEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET
	mov	ecx, esi
	call	??1CvBeliefEntry@@QAE@XZ		; CvBeliefEntry::~CvBeliefEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvBeliefEntry@@@@YAXAAPAVCvBeliefEntry@@@Z ENDP ; SAFE_DELETE<CvBeliefEntry>
_TEXT	ENDS
PUBLIC	??0CvReligionBeliefs@@QAE@XZ			; CvReligionBeliefs::CvReligionBeliefs
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvReligionBeliefs@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReligionBeliefs@@QAE@XZ$0
__ehfuncinfo$??0CvReligionBeliefs@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvReligionBeliefs@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvReligionBeliefs@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvReligionBeliefs@@QAE@XZ PROC			; CvReligionBeliefs::CvReligionBeliefs, COMDAT
; _this$ = ecx

; 1132 : {

	push	-1
	push	__ehhandler$??0CvReligionBeliefs@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+148]
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi+140], ecx
	mov	DWORD PTR [esi+144], 5
	mov	DWORD PTR [esi+136], eax
	mov	DWORD PTR __$EHRec$[esp+28], ecx
	mov	DWORD PTR [esi+172], ecx

; 1133 : 	Reset();

	mov	ecx, esi
	call	?Reset@CvReligionBeliefs@@QAEXXZ	; CvReligionBeliefs::Reset

; 1134 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReligionBeliefs@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	jmp	??1?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,5,0,297,0>::~FStaticVector<int,5,0,297,0>
__ehhandler$??0CvReligionBeliefs@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvReligionBeliefs@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReligionBeliefs@@QAE@XZ ENDP			; CvReligionBeliefs::CvReligionBeliefs
PUBLIC	??1CvReligionBeliefs@@QAE@XZ			; CvReligionBeliefs::~CvReligionBeliefs
; Function compile flags: /Ogtpy
;	COMDAT ??1CvReligionBeliefs@@QAE@XZ
_TEXT	SEGMENT
??1CvReligionBeliefs@@QAE@XZ PROC			; CvReligionBeliefs::~CvReligionBeliefs, COMDAT
; _this$ = ecx

; 1138 : {

	push	esi
	mov	esi, ecx

; 1139 : 	Uninit();

	mov	eax, DWORD PTR [esi+172]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+172], 0

; 1140 : }

	mov	eax, DWORD PTR [esi+136]
	add	esi, 148				; 00000094H
	add	esp, 4
	cmp	eax, esi
	pop	esi
	je	SHORT $LN10@CvReligion
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN10@CvReligion:
	ret	0
??1CvReligionBeliefs@@QAE@XZ ENDP			; CvReligionBeliefs::~CvReligionBeliefs
_TEXT	ENDS
PUBLIC	??0CvReligionBeliefs@@QAE@ABV0@@Z		; CvReligionBeliefs::CvReligionBeliefs
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvReligionBeliefs@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReligionBeliefs@@QAE@ABV0@@Z$0
__ehfuncinfo$??0CvReligionBeliefs@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvReligionBeliefs@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvReligionBeliefs@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
??0CvReligionBeliefs@@QAE@ABV0@@Z PROC			; CvReligionBeliefs::CvReligionBeliefs, COMDAT
; _this$ = ecx

; 1144 : {

	push	-1
	push	__ehhandler$??0CvReligionBeliefs@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+136]
	lea	eax, DWORD PTR [ecx+12]
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 5
	mov	DWORD PTR [ecx], eax

; 1145 : 	m_iFaithFromDyingUnits = source.m_iFaithFromDyingUnits;

	mov	edi, DWORD PTR _source$[esp+24]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 1146 : 	m_iRiverHappiness = source.m_iRiverHappiness;

	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], edx

; 1147 : 	m_iPlotCultureCostModifier = source.m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax

; 1148 : 	m_iCityRangeStrikeModifier = source.m_iCityRangeStrikeModifier;

	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], edx

; 1149 : 	m_iCombatModifierEnemyCities = source.m_iCombatModifierEnemyCities;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax

; 1150 : 	m_iCombatModifierFriendlyCities = source.m_iCombatModifierFriendlyCities;

	mov	edx, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], edx

; 1151 : 	m_iFriendlyHealChange = source.m_iFriendlyHealChange;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi+24], eax

; 1152 : 	m_iCityStateFriendshipModifier = source.m_iCityStateFriendshipModifier;

	mov	edx, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], edx

; 1153 : 	m_iLandBarbarianConversionPercent = source.m_iLandBarbarianConversionPercent;

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], eax

; 1154 : 	m_iSpreadDistanceModifier = source.m_iSpreadDistanceModifier;

	mov	edx, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], edx

; 1155 : 	m_iSpreadStrengthModifier = source.m_iSpreadStrengthModifier;

	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax

; 1156 : 	m_iProphetStrengthModifier = source.m_iProphetStrengthModifier;

	mov	edx, DWORD PTR [edi+44]
	mov	DWORD PTR [esi+44], edx

; 1157 : 	m_iProphetCostModifier = source.m_iProphetCostModifier;

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [esi+48], eax

; 1158 : 	m_iMissionaryStrengthModifier = source.m_iMissionaryStrengthModifier;

	mov	edx, DWORD PTR [edi+52]
	mov	DWORD PTR [esi+52], edx

; 1159 : #ifdef NQ_FLAT_FAITH_PER_CITIZEN_BORN_FROM_BELIEFS
; 1160 : 	m_iFlatFaithPerCitizenBorn = source.m_iFlatFaithPerCitizenBorn;

	mov	eax, DWORD PTR [edi+56]
	mov	DWORD PTR [esi+56], eax

; 1161 : #endif
; 1162 : #ifdef NQ_BELIEF_EXTRA_MISSIONARY_SPREADS
; 1163 : 	m_iMissionaryExtraSpreads = source.m_iMissionaryExtraSpreads;

	mov	edx, DWORD PTR [edi+60]
	mov	DWORD PTR [esi+60], edx

; 1164 : #endif
; 1165 : #ifdef NQ_SPREAD_MODIFIER_OWNED_CITIES
; 1166 : 	m_iSpreadModifierOwnedCities = source.m_iSpreadModifierOwnedCities;

	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], eax

; 1167 : 	m_iSpreadModifierUnownedCities = source.m_iSpreadModifierUnownedCities;

	mov	edx, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], edx

; 1168 : #endif
; 1169 : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 1170 : 	m_iExtraTradeRoutes	= source.m_iExtraTradeRoutes;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], eax

; 1171 : #endif
; 1172 : #ifdef NQ_FAITH_PER_CITY_STATE_THIS_RELIGION
; 1173 : 	m_iFaithPerCityStateThisReligion = source.m_iFaithPerCityStateThisReligion;

	mov	edx, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], edx

; 1174 : #endif
; 1175 : #ifdef NQ_FAITH_PER_FOREIGN_TRADE_ROUTE
; 1176 : 	m_iFaithPerForeignTradeRoute = source.m_iFaithPerForeignTradeRoute;

	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax

; 1177 : #endif
; 1178 : #ifdef NQ_GOLDEN_AGE_TURNS_FROM_BELIEF
; 1179 : 	m_iGoldenAgeTurns = source.m_iGoldenAgeTurns;

	mov	edx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+84], edx

; 1180 : #endif
; 1181 : 	m_iMissionaryCostModifier = source.m_iMissionaryCostModifier;

	mov	eax, DWORD PTR [edi+88]
	mov	DWORD PTR [esi+88], eax

; 1182 : 	m_iFriendlyCityStateSpreadModifier = source.m_iFriendlyCityStateSpreadModifier;

	mov	edx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+92], edx

; 1183 : 	m_iGreatPersonExpendedFaith = source.m_iGreatPersonExpendedFaith;

	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [esi+96], eax

; 1184 : 	m_iCityStateMinimumInfluence = source.m_iCityStateMinimumInfluence;

	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR [esi+100], edx

; 1185 : 	m_iCityStateInfluenceModifier = source.m_iCityStateInfluenceModifier;

	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR [esi+104], eax

; 1186 : 	m_iOtherReligionPressureErosion = source.m_iOtherReligionPressureErosion;

	mov	edx, DWORD PTR [edi+108]
	mov	DWORD PTR [esi+108], edx

; 1187 : 	m_iSpyPressure = source.m_iSpyPressure;

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [esi+112], eax

; 1188 : 	m_iInquisitorPressureRetention = source.m_iInquisitorPressureRetention;

	mov	edx, DWORD PTR [edi+116]
	mov	DWORD PTR [esi+116], edx

; 1189 : 	m_iFaithBuildingTourism = source.m_iFaithBuildingTourism;

	mov	eax, DWORD PTR [edi+120]
	mov	DWORD PTR [esi+120], eax

; 1190 : 
; 1191 : 	m_eObsoleteEra = source.m_eObsoleteEra;

	mov	edx, DWORD PTR [edi+124]
	mov	DWORD PTR [esi+124], edx

; 1192 : 	m_eResourceRevealed = source.m_eResourceRevealed;

	mov	eax, DWORD PTR [edi+128]
	mov	DWORD PTR [esi+128], eax

; 1193 : 	m_eSpreadModifierDoublingTech = source.m_eSpreadModifierDoublingTech;

	mov	edx, DWORD PTR [edi+132]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi+132], edx

; 1194 : 
; 1195 : 	m_ReligionBeliefs = source.m_ReligionBeliefs;

	lea	eax, DWORD PTR [edi+136]
	push	eax
	call	??4?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<int,5,0,297,0>::operator=

; 1196 : 
; 1197 : 	m_paiBuildingClassEnabled = FNEW(int[GC.getNumBuildingClassInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 1198 : #ifdef AUI_WARNING_FIXES
; 1199 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 1200 : 	{
; 1201 : #else
; 1202 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+172], eax
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN18@CvReligion@2
	npad	1
$LL4@CvReligion@2:

; 1203 : 	{
; 1204 : 		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 1205 : 		if(!pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN3@CvReligion@2

; 1206 : 		{
; 1207 : 			continue;
; 1208 : 		}
; 1209 : #endif
; 1210 : 
; 1211 : 		m_paiBuildingClassEnabled[iI] = source.m_paiBuildingClassEnabled[iI];

	mov	eax, DWORD PTR [edi+172]
	mov	ecx, DWORD PTR [esi+172]
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR [ecx+ebx*4], edx
$LN3@CvReligion@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	SHORT $LL4@CvReligion@2
$LN18@CvReligion@2:

; 1212 : 	}
; 1213 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReligionBeliefs@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	jmp	??1?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,5,0,297,0>::~FStaticVector<int,5,0,297,0>
__ehhandler$??0CvReligionBeliefs@@QAE@ABV0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvReligionBeliefs@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReligionBeliefs@@QAE@ABV0@@Z ENDP			; CvReligionBeliefs::CvReligionBeliefs
PUBLIC	??0?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,5,0,297,0>::push_back
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,5,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+32], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,0,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,5,0,297,0>::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@0@Z ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::erase
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@0@Z PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@2@0@Z ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXXZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?AddBelief@CvReligionBeliefs@@QAEXW4BeliefTypes@@@Z ; CvReligionBeliefs::AddBelief
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
;	COMDAT ?AddBelief@CvReligionBeliefs@@QAEXW4BeliefTypes@@@Z
_TEXT	SEGMENT
_eBelief$ = 8						; size = 4
?AddBelief@CvReligionBeliefs@@QAEXW4BeliefTypes@@@Z PROC ; CvReligionBeliefs::AddBelief, COMDAT
; _this$ = ecx

; 1299 : {

	push	ebp

; 1300 : 	CvAssert(eBelief != NO_BELIEF);
; 1301 : 	if(eBelief == NO_BELIEF)

	mov	ebp, DWORD PTR _eBelief$[esp]
	push	esi
	mov	esi, ecx
	cmp	ebp, -1
	je	$LN89@AddBelief
	push	edi

; 1302 : 		return;
; 1303 : 
; 1304 : 	CvBeliefEntry* belief = GC.GetGameBeliefs()->GetEntry(eBelief);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+ebp*4]

; 1305 : 	CvAssert(belief != NULL);
; 1306 : 	if(belief == NULL)

	test	edi, edi
	je	$LN98@AddBelief

; 1307 : 		return;
; 1308 : 
; 1309 : 	m_iFaithFromDyingUnits += belief->GetFaithFromDyingUnits();

	mov	ecx, DWORD PTR [edi+280]
	add	DWORD PTR [esi], ecx

; 1310 : 	m_iRiverHappiness += belief->GetRiverHappiness();

	mov	edx, DWORD PTR [edi+284]
	add	DWORD PTR [esi+4], edx

; 1311 : 	m_iPlotCultureCostModifier += belief->GetPlotCultureCostModifier();

	mov	eax, DWORD PTR [edi+296]
	add	DWORD PTR [esi+8], eax

; 1312 : 	m_iCityRangeStrikeModifier += belief->GetCityRangeStrikeModifier();

	mov	ecx, DWORD PTR [edi+300]
	add	DWORD PTR [esi+12], ecx

; 1313 : 	m_iCombatModifierEnemyCities += belief->GetCombatModifierEnemyCities();

	mov	edx, DWORD PTR [edi+304]
	add	DWORD PTR [esi+16], edx

; 1314 : 	m_iCombatModifierFriendlyCities += belief->GetCombatModifierFriendlyCities();

	mov	eax, DWORD PTR [edi+308]
	add	DWORD PTR [esi+20], eax

; 1315 : 	m_iFriendlyHealChange += belief->GetFriendlyHealChange();

	mov	ecx, DWORD PTR [edi+312]
	add	DWORD PTR [esi+24], ecx

; 1316 : 	m_iCityStateFriendshipModifier += belief->GetCityStateFriendshipModifier();

	mov	edx, DWORD PTR [edi+316]
	add	DWORD PTR [esi+28], edx

; 1317 : 	m_iLandBarbarianConversionPercent += belief->GetLandBarbarianConversionPercent();

	mov	eax, DWORD PTR [edi+320]
	add	DWORD PTR [esi+32], eax

; 1318 : 	m_iSpreadDistanceModifier += belief->GetSpreadDistanceModifier();

	mov	ecx, DWORD PTR [edi+356]
	add	DWORD PTR [esi+36], ecx

; 1319 : 	m_iSpreadStrengthModifier += belief->GetSpreadStrengthModifier();

	mov	edx, DWORD PTR [edi+360]
	add	DWORD PTR [esi+40], edx

; 1320 : 	m_iProphetStrengthModifier += belief->GetProphetStrengthModifier();

	mov	eax, DWORD PTR [edi+364]
	add	DWORD PTR [esi+44], eax

; 1321 : 	m_iProphetCostModifier += belief->GetProphetCostModifier();

	mov	ecx, DWORD PTR [edi+368]
	add	DWORD PTR [esi+48], ecx

; 1322 : 	m_iMissionaryStrengthModifier += belief->GetMissionaryStrengthModifier();

	mov	edx, DWORD PTR [edi+372]
	add	DWORD PTR [esi+52], edx

; 1323 : #ifdef NQ_FLAT_FAITH_PER_CITIZEN_BORN_FROM_BELIEFS
; 1324 : 	m_iFlatFaithPerCitizenBorn += belief->GetFlatFaithPerCitizenBorn();

	mov	eax, DWORD PTR [edi+376]
	add	DWORD PTR [esi+56], eax

; 1325 : #endif
; 1326 : #ifdef NQ_BELIEF_EXTRA_MISSIONARY_SPREADS
; 1327 : 	m_iMissionaryExtraSpreads += belief->GetMissionaryExtraSpreads();

	mov	ecx, DWORD PTR [edi+380]
	add	DWORD PTR [esi+60], ecx

; 1328 : #endif
; 1329 : #ifdef NQ_SPREAD_MODIFIER_OWNED_CITIES
; 1330 : 	m_iSpreadModifierOwnedCities += belief->GetSpreadModifierOwnedCities();

	mov	edx, DWORD PTR [edi+384]
	add	DWORD PTR [esi+64], edx

; 1331 : 	m_iSpreadModifierUnownedCities += belief->GetSpreadModifierUnownedCities();

	mov	eax, DWORD PTR [edi+388]
	add	DWORD PTR [esi+68], eax

; 1332 : #endif
; 1333 : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 1334 : 	m_iExtraTradeRoutes	+= belief->GetExtraTradeRoutes();

	mov	ecx, DWORD PTR [edi+392]
	add	DWORD PTR [esi+72], ecx

; 1335 : #endif
; 1336 : #ifdef NQ_FAITH_PER_CITY_STATE_THIS_RELIGION
; 1337 : 	m_iFaithPerCityStateThisReligion += belief->GetFaithPerCityStateThisReligion();

	mov	edx, DWORD PTR [edi+396]
	add	DWORD PTR [esi+76], edx

; 1338 : #endif
; 1339 : #ifdef NQ_FAITH_PER_FOREIGN_TRADE_ROUTE
; 1340 : 	m_iFaithPerForeignTradeRoute += belief->GetFaithPerForeignTradeRoute();

	mov	eax, DWORD PTR [edi+400]
	add	DWORD PTR [esi+80], eax

; 1341 : #endif
; 1342 : #ifdef NQ_GOLDEN_AGE_TURNS_FROM_BELIEF
; 1343 : 	m_iGoldenAgeTurns += belief->GetGoldenAgeTurns();

	mov	ecx, DWORD PTR [edi+404]
	add	DWORD PTR [esi+84], ecx

; 1344 : #endif
; 1345 : 	m_iMissionaryCostModifier += belief->GetMissionaryCostModifier();

	mov	edx, DWORD PTR [edi+408]
	add	DWORD PTR [esi+88], edx

; 1346 : 	m_iFriendlyCityStateSpreadModifier += belief->GetFriendlyCityStateSpreadModifier();

	mov	eax, DWORD PTR [edi+412]
	add	DWORD PTR [esi+92], eax

; 1347 : 	m_iGreatPersonExpendedFaith += belief->GetGreatPersonExpendedFaith();

	mov	ecx, DWORD PTR [edi+416]
	add	DWORD PTR [esi+96], ecx

; 1348 : 	m_iCityStateMinimumInfluence += belief->GetCityStateMinimumInfluence();

	mov	edx, DWORD PTR [edi+420]
	add	DWORD PTR [esi+100], edx

; 1349 : 	m_iCityStateInfluenceModifier += belief->GetCityStateInfluenceModifier();

	mov	eax, DWORD PTR [edi+424]
	add	DWORD PTR [esi+104], eax

; 1350 : 	m_iOtherReligionPressureErosion += belief->GetOtherReligionPressureErosion();

	mov	ecx, DWORD PTR [edi+428]
	add	DWORD PTR [esi+108], ecx

; 1351 : 	m_iSpyPressure += belief->GetSpyPressure();

	mov	edx, DWORD PTR [edi+432]
	add	DWORD PTR [esi+112], edx

; 1352 : 	m_iInquisitorPressureRetention += belief->GetInquisitorPressureRetention();

	mov	eax, DWORD PTR [edi+436]
	add	DWORD PTR [esi+116], eax

; 1353 : 	m_iFaithBuildingTourism += belief->GetFaithBuildingTourism();

	mov	ecx, DWORD PTR [edi+440]
	add	DWORD PTR [esi+120], ecx

; 1354 : 
; 1355 : 	m_eObsoleteEra = belief->GetObsoleteEra();

	mov	edx, DWORD PTR [edi+460]
	mov	DWORD PTR [esi+124], edx

; 1356 : 	m_eResourceRevealed = belief->GetResourceRevealed();

	mov	eax, DWORD PTR [edi+464]
	push	ebx

; 1357 : 
; 1358 : #ifdef AUI_WARNING_FIXES
; 1359 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 1360 : #else
; 1361 : 	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [esi+128], eax
	xor	ebx, ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN3@AddBelief
$LL5@AddBelief:

; 1362 : #endif
; 1363 : 	{
; 1364 : 		if (belief->IsBuildingClassEnabled(iI))

	mov	eax, DWORD PTR [edi+580]
	test	eax, eax
	je	SHORT $LN4@AddBelief
	cmp	BYTE PTR [eax+ebx], 0
	je	SHORT $LN4@AddBelief
	mov	ecx, DWORD PTR [esi+172]

; 1365 : 		{
; 1366 : 			m_paiBuildingClassEnabled[iI]++;

	inc	DWORD PTR [ecx+ebx*4]
	lea	eax, DWORD PTR [ecx+ebx*4]
$LN4@AddBelief:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebx, eax
	jl	SHORT $LL5@AddBelief
$LN3@AddBelief:

; 1367 : 		}
; 1368 : 	}
; 1369 : 
; 1370 : 	if(belief->GetSpreadModifierDoublingTech() != NO_TECH)

	mov	edi, DWORD PTR [edi+468]
	pop	ebx
	cmp	edi, -1
	je	SHORT $LN1@AddBelief

; 1371 : 	{
; 1372 : 		m_eSpreadModifierDoublingTech = belief->GetSpreadModifierDoublingTech();

	mov	DWORD PTR [esi+132], edi
$LN1@AddBelief:

; 1373 : 	}
; 1374 : 
; 1375 : 	m_ReligionBeliefs.push_back((int)eBelief);

	mov	eax, DWORD PTR [esi+144]
	add	esi, 136				; 00000088H
	mov	BYTE PTR [esi+32], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN88@AddBelief
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,0,297,0>::GrowSize
$LN88@AddBelief:
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN91@AddBelief
	mov	DWORD PTR [eax], ebp
$LN91@AddBelief:
	inc	DWORD PTR [esi+4]
$LN98@AddBelief:
	pop	edi
$LN89@AddBelief:
	pop	esi
	pop	ebp

; 1376 : }

	ret	4
?AddBelief@CvReligionBeliefs@@QAEXW4BeliefTypes@@@Z ENDP ; CvReligionBeliefs::AddBelief
_TEXT	ENDS
PUBLIC	?Read@CvReligionBeliefs@@QAEXAAVFDataStream@@@Z	; CvReligionBeliefs::Read
EXTRN	?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; BuildingClassArrayHelpers::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvReligionBeliefs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiBeliefCount$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvReligionBeliefs@@QAEXAAVFDataStream@@@Z PROC	; CvReligionBeliefs::Read, COMDAT
; _this$ = ecx

; 2095 : {

	push	ecx
	push	ebp
	push	esi

; 2096 : 	// Version number to maintain backwards compatibility
; 2097 : 	uint uiVersion;
; 2098 : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2099 : 
; 2100 : 	kStream >> m_iFaithFromDyingUnits;

	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2101 : 	kStream >> m_iRiverHappiness;

	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2102 : 	kStream >> m_iPlotCultureCostModifier;

	lea	edx, DWORD PTR [edi+8]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2103 : 	kStream >> m_iCityRangeStrikeModifier;

	lea	eax, DWORD PTR [edi+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2104 : 	kStream >> m_iCombatModifierEnemyCities;

	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2105 : 	kStream >> m_iCombatModifierFriendlyCities;

	lea	edx, DWORD PTR [edi+20]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2106 : 	kStream >> m_iFriendlyHealChange;

	lea	eax, DWORD PTR [edi+24]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2107 : 	kStream >> m_iCityStateFriendshipModifier;

	lea	ecx, DWORD PTR [edi+28]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2108 : 	kStream >> m_iLandBarbarianConversionPercent;

	lea	edx, DWORD PTR [edi+32]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2109 : 	kStream >> m_iSpreadStrengthModifier;

	lea	eax, DWORD PTR [edi+40]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2110 : 	kStream >> m_iSpreadDistanceModifier;

	lea	ecx, DWORD PTR [edi+36]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2111 : 	kStream >> m_iProphetStrengthModifier;

	lea	edx, DWORD PTR [edi+44]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2112 : 	kStream >> m_iProphetCostModifier;

	lea	eax, DWORD PTR [edi+48]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2113 : 	kStream >> m_iMissionaryStrengthModifier;

	lea	ecx, DWORD PTR [edi+52]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2114 : #ifdef NQ_FLAT_FAITH_PER_CITIZEN_BORN_FROM_BELIEFS
; 2115 : 	kStream >> m_iFlatFaithPerCitizenBorn;

	lea	edx, DWORD PTR [edi+56]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2116 : #endif
; 2117 : #ifdef NQ_BELIEF_EXTRA_MISSIONARY_SPREADS
; 2118 : 	kStream >> m_iMissionaryExtraSpreads;

	lea	eax, DWORD PTR [edi+60]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2119 : #endif
; 2120 : #ifdef NQ_SPREAD_MODIFIER_OWNED_CITIES
; 2121 : 	kStream >> m_iSpreadModifierOwnedCities;

	lea	ecx, DWORD PTR [edi+64]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2122 : 	kStream >> m_iSpreadModifierUnownedCities;

	lea	edx, DWORD PTR [edi+68]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2123 : #endif
; 2124 : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 2125 : 	kStream >> m_iExtraTradeRoutes;

	lea	eax, DWORD PTR [edi+72]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2126 : #endif
; 2127 : #ifdef NQ_FAITH_PER_CITY_STATE_THIS_RELIGION
; 2128 : 	kStream >> m_iFaithPerCityStateThisReligion;

	lea	ecx, DWORD PTR [edi+76]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2129 : #endif
; 2130 : #ifdef NQ_FAITH_PER_FOREIGN_TRADE_ROUTE
; 2131 : 	kStream >> m_iFaithPerForeignTradeRoute;

	lea	edx, DWORD PTR [edi+80]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2132 : #endif
; 2133 : #ifdef NQ_GOLDEN_AGE_TURNS_FROM_BELIEF
; 2134 : 	kStream >> m_iGoldenAgeTurns;

	lea	eax, DWORD PTR [edi+84]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2135 : #endif
; 2136 : 	kStream >> m_iMissionaryCostModifier;

	lea	ecx, DWORD PTR [edi+88]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2137 : 	kStream >> m_iFriendlyCityStateSpreadModifier;

	lea	edx, DWORD PTR [edi+92]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2138 : 	kStream >> m_iGreatPersonExpendedFaith;

	lea	eax, DWORD PTR [edi+96]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2139 : 	kStream >> m_iCityStateMinimumInfluence;

	lea	ecx, DWORD PTR [edi+100]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2140 : 	kStream >> m_iCityStateInfluenceModifier;

	lea	edx, DWORD PTR [edi+104]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2141 : 	kStream >> m_iOtherReligionPressureErosion;

	lea	eax, DWORD PTR [edi+108]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2142 : 	kStream >> m_iSpyPressure;

	lea	ecx, DWORD PTR [edi+112]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2143 : 	kStream >> m_iInquisitorPressureRetention;

	lea	edx, DWORD PTR [edi+116]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2144 : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+16], 2
	jb	SHORT $LN4@Read

; 2145 : 	{
; 2146 : 		kStream >> m_iFaithBuildingTourism;

	lea	eax, DWORD PTR [edi+120]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2147 : 	}
; 2148 : 	else

	jmp	SHORT $LN3@Read
$LN4@Read:

; 2149 : 	{
; 2150 : 		m_iFaithBuildingTourism = 0;

	mov	DWORD PTR [edi+120], 0
$LN3@Read:

; 2151 : 	}
; 2152 : 
; 2153 : 	kStream >> m_eObsoleteEra;

	lea	ecx, DWORD PTR [edi+124]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>

; 2154 : 	kStream >> m_eResourceRevealed;

	lea	edx, DWORD PTR [edi+128]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z ; operator>>

; 2155 : 	kStream >> m_eSpreadModifierDoublingTech;

	lea	eax, DWORD PTR [edi+132]
	push	eax
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z ; operator>>
	add	esp, 24					; 00000018H

; 2156 : 
; 2157 : 	m_ReligionBeliefs.clear();
; 2158 : 	uint uiBeliefCount;
; 2159 : 	kStream >> uiBeliefCount;

	lea	ecx, DWORD PTR _uiBeliefCount$[esp+12]
	push	ecx
	lea	ebp, DWORD PTR [edi+136]
	mov	ecx, esi
	mov	DWORD PTR [ebp+4], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2160 : 	while(uiBeliefCount--)

	cmp	DWORD PTR _uiBeliefCount$[esp+12], 0
	je	SHORT $LN91@Read
	push	ebx
$LL2@Read:
	dec	DWORD PTR _uiBeliefCount$[esp+16]

; 2161 : 	{
; 2162 : 		int iBeliefIndex = CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	esi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	ebx, eax

; 2163 : 		m_ReligionBeliefs.push_back(iBeliefIndex);

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 8
	mov	BYTE PTR [ebp+32], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN81@Read
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@H$04$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,5,0,297,0>::GrowSize
$LN81@Read:
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN84@Read
	mov	DWORD PTR [eax], ebx
$LN84@Read:
	inc	DWORD PTR [ebp+4]
	cmp	DWORD PTR _uiBeliefCount$[esp+16], 0
	jne	SHORT $LL2@Read
	pop	ebx
$LN91@Read:

; 2164 : 	}
; 2165 : 
; 2166 : 	BuildingClassArrayHelpers::Read(kStream, m_paiBuildingClassEnabled);

	mov	ecx, DWORD PTR [edi+172]
	dec	DWORD PTR _uiBeliefCount$[esp+12]
	push	ecx
	push	esi
	call	?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingClassArrayHelpers::Read
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 2167 : }

	pop	ecx
	ret	4
?Read@CvReligionBeliefs@@QAEXAAVFDataStream@@@Z ENDP	; CvReligionBeliefs::Read
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::~vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::~vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::~vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEXXZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::clear
_TEXT	ENDS
PUBLIC	??0CvBeliefXMLEntries@@QAE@XZ			; CvBeliefXMLEntries::CvBeliefXMLEntries
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
;	COMDAT ??0CvBeliefXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvBeliefXMLEntries@@QAE@XZ PROC			; CvBeliefXMLEntries::CvBeliefXMLEntries, COMDAT
; _this$ = ecx

; 1087 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 1088 : 
; 1089 : }

	ret	0
??0CvBeliefXMLEntries@@QAE@XZ ENDP			; CvBeliefXMLEntries::CvBeliefXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvBeliefXMLEntries@@QAEXXZ		; CvBeliefXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvBeliefXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvBeliefXMLEntries@@QAEXXZ PROC		; CvBeliefXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 1111 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 1112 : 	for(std::vector<CvBeliefEntry*>::iterator it = m_paBeliefEntries.begin(); it != m_paBeliefEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 1113 : 	{
; 1114 : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvBeliefEntry@@QAE@XZ		; CvBeliefEntry::~CvBeliefEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 1115 : 	}
; 1116 : 
; 1117 : 	m_paBeliefEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 1118 : }

	ret	0
?DeleteArray@CvBeliefXMLEntries@@QAEXXZ ENDP		; CvBeliefXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??1CvBeliefXMLEntries@@QAE@XZ			; CvBeliefXMLEntries::~CvBeliefXMLEntries
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvBeliefXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBeliefXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvBeliefXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvBeliefXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbeliefclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvBeliefXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBeliefXMLEntries@@QAE@XZ PROC			; CvBeliefXMLEntries::~CvBeliefXMLEntries, COMDAT
; _this$ = ecx

; 1093 : {

	push	-1
	push	__ehhandler$??1CvBeliefXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 1094 : 	DeleteArray();

	call	?DeleteArray@CvBeliefXMLEntries@@QAEXXZ	; CvBeliefXMLEntries::DeleteArray

; 1095 : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvBeliefXM
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvBeliefXM:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBeliefXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvBeliefEntry@@V?$allocator@PAVCvBeliefEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >::~vector<CvBeliefEntry *,std::allocator<CvBeliefEntry *> >
__ehhandler$??1CvBeliefXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBeliefXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBeliefXMLEntries@@QAE@XZ ENDP			; CvBeliefXMLEntries::~CvBeliefXMLEntries
END
