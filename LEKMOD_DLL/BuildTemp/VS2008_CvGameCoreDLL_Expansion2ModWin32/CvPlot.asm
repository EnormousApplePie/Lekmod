; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPlot.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG222132 DB	'CvPlot::m_eFeatureType', 00H
$SG224681 DB	00H
$SG222413 DB	'Resource Discovery', 00H
$SG226739 DB	00H
$SG222419 DB	'RESOURCE_ARTIFACTS', 00H
	ORG $+1
$SG222426 DB	'TXT_KEY_MISC_DISCOVERED_ARTIFACTS_NEAR', 00H
	ORG $+1
$SG222429 DB	'RESOURCE_HIDDEN_ARTIFACTS', 00H
	ORG $+2
$SG222431 DB	'TXT_KEY_MISC_DISCOVERED_HIDDEN_ARTIFACTS_NEAR', 00H
	ORG $+2
$SG222443 DB	'TXT_KEY_MISC_DISCOVERED_NEW_RESOURCE', 00H
	ORG $+3
$SG223668 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG223669 DB	'FLAVOR_DEFENSE', 00H
	ORG $+1
$SG225234 DB	'IMPROVEMENT_MOTTE_BAILEY', 00H
	ORG $+3
$SG225238 DB	'IMPROVEMENT_FEITORIA', 00H
	ORG $+3
$SG226095 DB	'NaturalWonderDiscovered', 00H
$SG226098 DB	'TXT_KEY_NOTIFICATION_FOUND_NATURAL_WONDER', 00H
	ORG $+2
$SG226107 DB	'TXT_KEY_NOTIFICATION_SUMMARY_FOUND_NATURAL_WONDER', 00H
	ORG $+2
$SG226143 DB	'HANDICAP_PRINCE', 00H
$SG226166 DB	'[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]', 00H
	ORG $+1
$SG226178 DB	'FEATURE_FOUNTAIN_YOUTH', 00H
	ORG $+1
$SG226181 DB	'FEATURE_EL_DORADO', 00H
	ORG $+2
$SG226196 DB	'TXT_KEY_NOTIFICATION_FOUND_GOODY_HUT', 00H
	ORG $+3
$SG226199 DB	'TXT_KEY_NOTIFICATION_SUMMARY_FOUND_GOODY_HUT', 00H
	ORG $+3
$SG226293 DB	'TXT_KEY_NOTIFICATION_FOUND_BARB_CAMP', 00H
	ORG $+3
$SG226296 DB	'TXT_KEY_NOTIFICATION_SUMMARY_FOUND_BARB_CAMP', 00H
	ORG $+3
$SG226378 DB	'TXT_KEY_NOTIFICATION_CHOOSE_ARCHAEOLOGY', 00H
$SG226381 DB	'TXT_KEY_NOTIFICATION_SUMMARY_CHOOSE_ARCHAEOLOGY', 00H
$SG226384 DB	'CIVILIZATION_AMERICA', 00H
	ORG $+3
$SG226387 DB	'CIVILIZATION_EGYPT', 00H
	ORG $+1
$SG226396 DB	'CIVILIZATION_GERMANY', 00H
	ORG $+3
$SG226403 DB	'UNIT_ARCHAEOLOGIST', 00H
	ORG $+1
$SG226430 DB	'TXT_KEY_MISC_CLEARING_FEATURE_RESOURCE', 00H
	ORG $+1
$SG226438 DB	'TXT_KEY_MISC_CLEARING_FEATURE_FOOD', 00H
	ORG $+1
$SG226449 DB	'BuildFinished', 00H
	ORG $+2
$SG227365 DB	'Game Turn : ', 00H
	ORG $+3
$SG227373 DB	'%d', 00H, 00H
$SG92482 DB	'daf6f887-3614-4169-a0e5-3ac9bd4ef82b', 00H
	ORG $+3
_CIV5_DLC_04_SCENARIO_MODID DD FLAT:$SG92482
$SG207740 DB	0aH, 00H
	ORG $+2
$SG207741 DB	0aH, 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
; Function compile flags: /Ogtpy
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	eax, DWORD PTR _iDX$[esp-4]
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	xor	edx, edx
	test	esi, esi
	setge	dl
	cmp	ecx, edx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN6@hexDistanc
	neg	eax
$LN6@hexDistanc:

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN8@hexDistanc
	neg	esi
$LN8@hexDistanc:

; 112  : 		return iAbsDX + iAbsDY;

	add	eax, esi
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
$LN2@hexDistanc:

; 113  : 	}
; 114  : 	else
; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN10@hexDistanc
	neg	eax
$LN10@hexDistanc:

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN12@hexDistanc
	neg	esi
$LN12@hexDistanc:

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	eax, esi
	jge	SHORT $LN1@hexDistanc
	mov	eax, esi
$LN1@hexDistanc:
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ ; FAutoArchiveClassContainer<CvPlot>::~FAutoArchiveClassContainer<CvPlot>
EXTRN	??1FAutoArchive@@UAE@XZ:PROC			; FAutoArchive::~FAutoArchive
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ
_TEXT	SEGMENT
??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ PROC	; FAutoArchiveClassContainer<CvPlot>::~FAutoArchiveClassContainer<CvPlot>, COMDAT
; _this$ = ecx
	jmp	??1FAutoArchive@@UAE@XZ			; FAutoArchive::~FAutoArchive
??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ ENDP	; FAutoArchiveClassContainer<CvPlot>::~FAutoArchiveClassContainer<CvPlot>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z	; CvPlot::nukeExplosion
EXTRN	?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z:PROC ; CvUnitCombat::ApplyNuclearExplosionDamage
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z
_TEXT	SEGMENT
_iDamageLevel$ = 8					; size = 4
___formal$ = 12						; size = 4
?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z PROC		; CvPlot::nukeExplosion, COMDAT
; _this$ = ecx

; 822  : 	CvUnitCombat::ApplyNuclearExplosionDamage(this, iDamageLevel);

	mov	eax, DWORD PTR _iDamageLevel$[esp-4]
	push	0
	push	eax
	push	ecx
	call	?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z ; CvUnitCombat::ApplyNuclearExplosionDamage
	add	esp, 12					; 0000000cH

; 823  : }

	ret	8
?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z ENDP		; CvPlot::nukeExplosion
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__real@c000000000000000
PUBLIC	__real@4056800000000000
PUBLIC	__real@4066800000000000
PUBLIC	__real@4052c00000000000
PUBLIC	__real@400921fb54442d18
PUBLIC	?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ; CvPlot::shouldProcessDisplacementPlot
EXTRN	_atan2:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@4056800000000000
CONST	SEGMENT
__real@4056800000000000 DQ 04056800000000000r	; 90
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@4052c00000000000
CONST	SEGMENT
__real@4052c00000000000 DQ 04052c00000000000r	; 75
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_theta$223221 = -112					; size = 8
_crossProduct$223219 = -112				; size = 8
_directionX$223217 = -112				; size = 8
_spread$223222 = -104					; size = 8
_dotProduct$223220 = -104				; size = 8
_directionY$223218 = -104				; size = 8
_displacements$223216 = -96				; size = 96
_dx$ = 8						; size = 4
_dy$ = 12						; size = 4
___formal$ = 16						; size = 4
_eFacingDirection$ = 20					; size = 4
?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z PROC ; CvPlot::shouldProcessDisplacementPlot, COMDAT
; _this$ = ecx

; 1761 : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H

; 1762 : 	if(eFacingDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eFacingDirection$[ebp]
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	cmp	ecx, -1

; 1763 : 	{
; 1764 : 		return true;

	je	$LN19@shouldProc

; 1765 : 	}
; 1766 : 	else if((dx == 0) && (dy == 0)) //always process this plot

	mov	esi, DWORD PTR _dx$[ebp]
	mov	ebx, DWORD PTR _dy$[ebp]
	xor	eax, eax
	cmp	esi, eax
	jne	SHORT $LN5@shouldProc
	cmp	ebx, eax

; 1767 : 	{
; 1768 : 		return true;

	je	$LN19@shouldProc
$LN5@shouldProc:

; 1769 : 	}
; 1770 : 	else
; 1771 : 	{
; 1772 : 		//							NE					E		SE					SW					W		NW
; 1773 : 		double displacements[6][2] = { {0.5f, 0.866025f}, {1, 0}, {0.5f, -0.866025f}, {-0.5f, -0.866025f}, {-1, 0}, {-0.5f, -0.866025f}};
; 1774 : 
; 1775 : 		double directionX = displacements[eFacingDirection][0];
; 1776 : 		double directionY = displacements[eFacingDirection][1];
; 1777 : 
; 1778 : 		//compute angle off of direction
; 1779 : 		double crossProduct = directionX * dy - directionY * dx; //cross product

	fild	DWORD PTR _dy$[ebp]
	mov	DWORD PTR _displacements$223216[esp+128], eax
	mov	DWORD PTR _displacements$223216[esp+136], eax
	mov	DWORD PTR _displacements$223216[esp+144], eax
	mov	DWORD PTR _displacements$223216[esp+152], eax
	mov	DWORD PTR _displacements$223216[esp+156], eax
	mov	DWORD PTR _displacements$223216[esp+160], eax
	mov	DWORD PTR _displacements$223216[esp+168], eax
	mov	DWORD PTR _displacements$223216[esp+176], eax
	mov	DWORD PTR _displacements$223216[esp+184], eax
	mov	DWORD PTR _displacements$223216[esp+192], eax
	mov	DWORD PTR _displacements$223216[esp+200], eax
	mov	DWORD PTR _displacements$223216[esp+204], eax
	mov	DWORD PTR _displacements$223216[esp+208], eax
	mov	DWORD PTR _displacements$223216[esp+216], eax
	shl	ecx, 4
	mov	eax, ecx
	mov	edx, 1071644672				; 3fe00000H
	mov	DWORD PTR _displacements$223216[esp+132], edx
	mov	DWORD PTR _displacements$223216[esp+164], edx
	mov	edx, -1075071366			; bfebb67aH
	mov	DWORD PTR _displacements$223216[esp+172], edx
	mov	DWORD PTR _displacements$223216[esp+188], edx
	mov	DWORD PTR _displacements$223216[esp+220], edx
	mov	DWORD PTR _displacements$223216[esp+140], 1072412282 ; 3febb67aH
	mov	DWORD PTR _displacements$223216[esp+148], 1072693248 ; 3ff00000H
	mov	DWORD PTR _displacements$223216[esp+180], -1075838976 ; bfe00000H
	mov	DWORD PTR _displacements$223216[esp+196], -1074790400 ; bff00000H
	mov	DWORD PTR _displacements$223216[esp+212], -1075838976 ; bfe00000H
	mov	ecx, DWORD PTR _displacements$223216[esp+eax+128]
	mov	edx, DWORD PTR _displacements$223216[esp+eax+132]
	mov	DWORD PTR _directionX$223217[esp+128], ecx
	mov	ecx, DWORD PTR _displacements$223216[esp+eax+136]
	mov	DWORD PTR _directionX$223217[esp+132], edx
	mov	edx, DWORD PTR _displacements$223216[esp+eax+140]
	fld	QWORD PTR _directionX$223217[esp+128]
	fmul	ST(1), ST(0)
	mov	DWORD PTR _directionY$223218[esp+128], ecx
	fild	DWORD PTR _dx$[ebp]
	mov	DWORD PTR _directionY$223218[esp+132], edx
	fld	QWORD PTR _directionY$223218[esp+128]

; 1780 : 		double dotProduct = directionX * dx + directionY * dy; //dot product
; 1781 : 
; 1782 : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1783 : 		double theta = abs(atan2(crossProduct, dotProduct));
; 1784 : 		double spread = 37.5 * M_PI / 180.0;
; 1785 : #if 0 // Enable if 8 or more directions
; 1786 : 		if ((abs(dx) <= 1) && (abs(dy) <= 1)) //close plots use wider spread
; 1787 : 		{
; 1788 : 			spread = 90 * (double)M_PI / 180;
; 1789 : 		}
; 1790 : #endif
; 1791 : 
; 1792 : 		if (theta <= spread)
; 1793 : 			return true;
; 1794 : 		else
; 1795 : 			return false;
; 1796 : #else
; 1797 : 		double theta = atan2(crossProduct, dotProduct);

	sub	esp, 8
	mov	eax, esp
	fmul	ST(1), ST(0)
	sub	esp, 8
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _crossProduct$223219[esp+144]
	fild	DWORD PTR _dy$[ebp]
	fmulp	ST(2), ST(0)
	fimul	DWORD PTR _dx$[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _dotProduct$223220[esp+144]
	mov	ecx, DWORD PTR _dotProduct$223220[esp+144]
	mov	edx, DWORD PTR _dotProduct$223220[esp+148]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _crossProduct$223219[esp+144]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _crossProduct$223219[esp+148]
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	call	_atan2
	fstp	QWORD PTR _theta$223221[esp+144]

; 1798 : 		double spread = 75 * (double) M_PI / 180;

	fld	QWORD PTR __real@400921fb54442d18

; 1799 : 		if((abs(dx) <= 1) && (abs(dy) <= 1)) //close plots use wider spread

	mov	eax, esi
	fld	QWORD PTR __real@4052c00000000000
	cdq
	fmul	ST(0), ST(1)
	xor	eax, edx
	fld	QWORD PTR __real@4066800000000000
	sub	eax, edx
	add	esp, 16					; 00000010H
	cmp	eax, 1
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _spread$223222[esp+128]
	jg	SHORT $LN14@shouldProc
	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 1
	jg	SHORT $LN14@shouldProc

; 1800 : 		{
; 1801 : 			spread = 90 * (double) M_PI / 180;

	fxch	ST(1)
	fmul	QWORD PTR __real@4056800000000000
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _spread$223222[esp+128]
	jmp	SHORT $LN3@shouldProc
$LN14@shouldProc:

; 1799 : 		if((abs(dx) <= 1) && (abs(dy) <= 1)) //close plots use wider spread

	fstp	ST(1)
	fstp	ST(0)
$LN3@shouldProc:

; 1802 : 		}
; 1803 : 
; 1804 : 		if((theta >= -spread / 2) && (theta <= spread / 2))

	fld	QWORD PTR _spread$223222[esp+128]
	fld	QWORD PTR __real@c000000000000000
	fdivr	ST(0), ST(1)
	fld	QWORD PTR _theta$223221[esp+128]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 1
	jne	SHORT $LN17@shouldProc
	fxch	ST(1)
	fdiv	QWORD PTR __real@4000000000000000
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN2@shouldProc
$LN19@shouldProc:

; 1805 : 		{
; 1806 : 			return true;

	mov	al, 1

; 1807 : 		}
; 1808 : 		else
; 1809 : 		{
; 1810 : 			return false;
; 1811 : 		}
; 1812 : #endif
; 1813 : 	}
; 1814 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN17@shouldProc:

; 1802 : 		}
; 1803 : 
; 1804 : 		if((theta >= -spread / 2) && (theta <= spread / 2))

	fstp	ST(1)
	fstp	ST(0)
$LN2@shouldProc:

; 1807 : 		}
; 1808 : 		else
; 1809 : 		{
; 1810 : 			return false;
; 1811 : 		}
; 1812 : #endif
; 1813 : 	}
; 1814 : }

	pop	esi
	xor	al, al
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ENDP ; CvPlot::shouldProcessDisplacementPlot
_TEXT	ENDS
PUBLIC	?abs@@YANN@Z					; abs
EXTRN	_fabs:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?abs@@YANN@Z
_TEXT	SEGMENT
$T229983 = -8						; size = 8
__X$ = 8						; size = 8
?abs@@YANN@Z PROC					; abs, COMDAT

; 488  :         {return (fabs(_X)); }

	sub	esp, 8
	mov	ecx, DWORD PTR __X$[esp+4]
	mov	edx, DWORD PTR __X$[esp+8]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	call	_fabs
	fstp	QWORD PTR $T229983[esp+16]
	fld	QWORD PTR $T229983[esp+16]
	add	esp, 16					; 00000010H
	ret	0
?abs@@YANN@Z ENDP					; abs
_TEXT	ENDS
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z:PROC ; CvUnit::canCoexistWithEnemyUnit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?isOtherTeam@@YA_NPBVCvUnit@@W4TeamTypes@@@Z
_TEXT	SEGMENT
?isOtherTeam@@YA_NPBVCvUnit@@W4TeamTypes@@@Z PROC	; isOtherTeam, COMDAT
; _pUnit$ = edi
; _eOtherTeam$ = esi

; 3833 : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	push	esi
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	je	SHORT $LN1@isOtherTea

; 3834 : 	{
; 3835 : 		return false;

	xor	al, al

; 3839 : }

	ret	0
$LN1@isOtherTea:

; 3836 : 	}
; 3837 : 
; 3838 : 	return (pUnit->getTeam() != eOtherTeam);

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	xor	ecx, ecx
	cmp	eax, esi
	setne	cl
	mov	al, cl

; 3839 : }

	ret	0
?isOtherTeam@@YA_NPBVCvUnit@@W4TeamTypes@@@Z ENDP	; isOtherTeam
_TEXT	ENDS
PUBLIC	?isRoute@CvPlot@@QBE_NXZ			; CvPlot::isRoute
; Function compile flags: /Ogtpy
;	COMDAT ?isRoute@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRoute@CvPlot@@QBE_NXZ PROC				; CvPlot::isRoute, COMDAT
; _this$ = ecx

; 4379 : 	return ((RouteTypes)m_eRouteType != NO_ROUTE);

	xor	eax, eax
	cmp	BYTE PTR [ecx+447], -1
	setne	al

; 4380 : }

	ret	0
?isRoute@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRoute
_TEXT	ENDS
PUBLIC	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z	; CvPlot::IsTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::IsTradeRoute, COMDAT
; _this$ = ecx

; 4443 : {

	mov	eax, ecx

; 4444 : 	if(ePlayer == NO_PLAYER)

	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	cmp	ecx, -1
	jne	SHORT $LN5@IsTradeRou

; 4445 : 	{
; 4446 : 		if(m_uiTradeRouteBitFlags > 0)

	cmp	DWORD PTR [eax+388], 0
	seta	al

; 4455 : 		{
; 4456 : 			return true;
; 4457 : 		}
; 4458 : 		else
; 4459 : 		{
; 4460 : 			return false;
; 4461 : 		}
; 4462 : 	}
; 4463 : 
; 4464 : 	return false;
; 4465 : }

	ret	4
$LN5@IsTradeRou:

; 4447 : 		{
; 4448 : 			return true;
; 4449 : 		}
; 4450 : 	}
; 4451 : 	else
; 4452 : 	{
; 4453 : 		uint uiNewBitValue = (1 << ePlayer);

	mov	edx, 1
	shl	edx, cl

; 4454 : 		if(m_uiTradeRouteBitFlags & uiNewBitValue)

	test	edx, DWORD PTR [eax+388]
	setne	al

; 4455 : 		{
; 4456 : 			return true;
; 4457 : 		}
; 4458 : 		else
; 4459 : 		{
; 4460 : 			return false;
; 4461 : 		}
; 4462 : 	}
; 4463 : 
; 4464 : 	return false;
; 4465 : }

	ret	4
?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::IsTradeRoute
_TEXT	ENDS
PUBLIC	?getFeatureVariety@CvPlot@@QBEHXZ		; CvPlot::getFeatureVariety
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureVariety@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getFeatureVariety@CvPlot@@QBEHXZ PROC			; CvPlot::getFeatureVariety, COMDAT
; _this$ = ecx

; 4678 : 	return m_iFeatureVariety;

	movsx	eax, BYTE PTR [ecx+453]

; 4679 : }

	ret	0
?getFeatureVariety@CvPlot@@QBEHXZ ENDP			; CvPlot::getFeatureVariety
_TEXT	ENDS
PUBLIC	?getOwnershipDuration@CvPlot@@QBEHXZ		; CvPlot::getOwnershipDuration
; Function compile flags: /Ogtpy
;	COMDAT ?getOwnershipDuration@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getOwnershipDuration@CvPlot@@QBEHXZ PROC		; CvPlot::getOwnershipDuration, COMDAT
; _this$ = ecx

; 4685 : 	return m_iOwnershipDuration;

	movsx	eax, WORD PTR [ecx+380]

; 4686 : }

	ret	0
?getOwnershipDuration@CvPlot@@QBEHXZ ENDP		; CvPlot::getOwnershipDuration
_TEXT	ENDS
PUBLIC	?getImprovementDuration@CvPlot@@QBEHXZ		; CvPlot::getImprovementDuration
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementDuration@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getImprovementDuration@CvPlot@@QBEHXZ PROC		; CvPlot::getImprovementDuration, COMDAT
; _this$ = ecx

; 4732 : 	return m_iImprovementDuration;

	movsx	eax, WORD PTR [ecx+382]

; 4733 : }

	ret	0
?getImprovementDuration@CvPlot@@QBEHXZ ENDP		; CvPlot::getImprovementDuration
_TEXT	ENDS
PUBLIC	?setImprovementDuration@CvPlot@@QAEXH@Z		; CvPlot::setImprovementDuration
; Function compile flags: /Ogtpy
;	COMDAT ?setImprovementDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setImprovementDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::setImprovementDuration, COMDAT
; _this$ = ecx

; 4739 : 	m_iImprovementDuration = iNewValue;

	mov	ax, WORD PTR _iNewValue$[esp-4]
	mov	WORD PTR [ecx+382], ax

; 4740 : 	CvAssert(getImprovementDuration() >= 0);
; 4741 : }

	ret	4
?setImprovementDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::setImprovementDuration
_TEXT	ENDS
PUBLIC	?changeImprovementDuration@CvPlot@@QAEXH@Z	; CvPlot::changeImprovementDuration
; Function compile flags: /Ogtpy
;	COMDAT ?changeImprovementDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeImprovementDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::changeImprovementDuration, COMDAT
; _this$ = ecx

; 4747 : 	setImprovementDuration(getImprovementDuration() + iChange);

	mov	ax, WORD PTR _iChange$[esp-4]
	add	WORD PTR [ecx+382], ax

; 4748 : }

	ret	4
?changeImprovementDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeImprovementDuration
_TEXT	ENDS
PUBLIC	?getUpgradeProgress@CvPlot@@QBEHXZ		; CvPlot::getUpgradeProgress
; Function compile flags: /Ogtpy
;	COMDAT ?getUpgradeProgress@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getUpgradeProgress@CvPlot@@QBEHXZ PROC			; CvPlot::getUpgradeProgress, COMDAT
; _this$ = ecx

; 4754 : 	return m_iUpgradeProgress;

	movsx	eax, WORD PTR [ecx+384]

; 4755 : }

	ret	0
?getUpgradeProgress@CvPlot@@QBEHXZ ENDP			; CvPlot::getUpgradeProgress
_TEXT	ENDS
PUBLIC	?setUpgradeProgress@CvPlot@@QAEXH@Z		; CvPlot::setUpgradeProgress
; Function compile flags: /Ogtpy
;	COMDAT ?setUpgradeProgress@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setUpgradeProgress@CvPlot@@QAEXH@Z PROC		; CvPlot::setUpgradeProgress, COMDAT
; _this$ = ecx

; 4795 : 	m_iUpgradeProgress = iNewValue;

	mov	ax, WORD PTR _iNewValue$[esp-4]
	mov	WORD PTR [ecx+384], ax

; 4796 : 	CvAssert(getUpgradeProgress() >= 0);
; 4797 : }

	ret	4
?setUpgradeProgress@CvPlot@@QAEXH@Z ENDP		; CvPlot::setUpgradeProgress
_TEXT	ENDS
PUBLIC	?changeUpgradeProgress@CvPlot@@QAEXH@Z		; CvPlot::changeUpgradeProgress
; Function compile flags: /Ogtpy
;	COMDAT ?changeUpgradeProgress@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeUpgradeProgress@CvPlot@@QAEXH@Z PROC		; CvPlot::changeUpgradeProgress, COMDAT
; _this$ = ecx

; 4803 : 	setUpgradeProgress(getUpgradeProgress() + iChange);

	mov	ax, WORD PTR _iChange$[esp-4]
	add	WORD PTR [ecx+384], ax

; 4804 : }

	ret	4
?changeUpgradeProgress@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeUpgradeProgress
_TEXT	ENDS
PUBLIC	?getNumMajorCivsRevealed@CvPlot@@QBEHXZ		; CvPlot::getNumMajorCivsRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?getNumMajorCivsRevealed@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getNumMajorCivsRevealed@CvPlot@@QBEHXZ PROC		; CvPlot::getNumMajorCivsRevealed, COMDAT
; _this$ = ecx

; 4830 : 	return m_iNumMajorCivsRevealed;

	movsx	eax, BYTE PTR [ecx+454]

; 4831 : }

	ret	0
?getNumMajorCivsRevealed@CvPlot@@QBEHXZ ENDP		; CvPlot::getNumMajorCivsRevealed
_TEXT	ENDS
PUBLIC	?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z	; CvPlot::setNumMajorCivsRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z PROC		; CvPlot::setNumMajorCivsRevealed, COMDAT
; _this$ = ecx

; 4836 : 	m_iNumMajorCivsRevealed = iNewValue;

	mov	al, BYTE PTR _iNewValue$[esp-4]
	mov	BYTE PTR [ecx+454], al

; 4837 : 	CvAssert(getNumMajorCivsRevealed() >= 0);
; 4838 : }

	ret	4
?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z ENDP		; CvPlot::setNumMajorCivsRevealed
_TEXT	ENDS
PUBLIC	?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z	; CvPlot::changeNumMajorCivsRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z PROC	; CvPlot::changeNumMajorCivsRevealed, COMDAT
; _this$ = ecx

; 4844 : 	setNumMajorCivsRevealed(getNumMajorCivsRevealed() + iChange);

	mov	al, BYTE PTR _iChange$[esp-4]
	add	BYTE PTR [ecx+454], al

; 4845 : }

	ret	4
?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z ENDP	; CvPlot::changeNumMajorCivsRevealed
_TEXT	ENDS
PUBLIC	?getCityRadiusCount@CvPlot@@QBEHXZ		; CvPlot::getCityRadiusCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCityRadiusCount@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getCityRadiusCount@CvPlot@@QBEHXZ PROC			; CvPlot::getCityRadiusCount, COMDAT
; _this$ = ecx

; 4851 : 	return m_iCityRadiusCount;

	movsx	eax, BYTE PTR [ecx+455]

; 4852 : }

	ret	0
?getCityRadiusCount@CvPlot@@QBEHXZ ENDP			; CvPlot::getCityRadiusCount
_TEXT	ENDS
PUBLIC	?isCityRadius@CvPlot@@QBEHXZ			; CvPlot::isCityRadius
; Function compile flags: /Ogtpy
;	COMDAT ?isCityRadius@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?isCityRadius@CvPlot@@QBEHXZ PROC			; CvPlot::isCityRadius, COMDAT
; _this$ = ecx

; 4858 : 	return (getCityRadiusCount() > 0);

	xor	eax, eax
	cmp	BYTE PTR [ecx+455], al
	setg	al

; 4859 : }

	ret	0
?isCityRadius@CvPlot@@QBEHXZ ENDP			; CvPlot::isCityRadius
_TEXT	ENDS
PUBLIC	?changeCityRadiusCount@CvPlot@@QAEXH@Z		; CvPlot::changeCityRadiusCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeCityRadiusCount@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeCityRadiusCount@CvPlot@@QAEXH@Z PROC		; CvPlot::changeCityRadiusCount, COMDAT
; _this$ = ecx

; 4865 : 	m_iCityRadiusCount = (m_iCityRadiusCount + iChange);

	mov	al, BYTE PTR _iChange$[esp-4]
	add	BYTE PTR [ecx+455], al

; 4866 : 	CvAssert(getCityRadiusCount() >= 0);
; 4867 : }

	ret	4
?changeCityRadiusCount@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeCityRadiusCount
_TEXT	ENDS
PUBLIC	?isStartingPlot@CvPlot@@QBE_NXZ			; CvPlot::isStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?isStartingPlot@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isStartingPlot@CvPlot@@QBE_NXZ PROC			; CvPlot::isStartingPlot, COMDAT
; _this$ = ecx

; 4873 : 	return m_bStartingPlot;

	mov	al, BYTE PTR [ecx+461]
	shr	al, 2
	and	al, 1

; 4874 : }

	ret	0
?isStartingPlot@CvPlot@@QBE_NXZ ENDP			; CvPlot::isStartingPlot
_TEXT	ENDS
PUBLIC	?setStartingPlot@CvPlot@@QAEX_N@Z		; CvPlot::setStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?setStartingPlot@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?setStartingPlot@CvPlot@@QAEX_N@Z PROC			; CvPlot::setStartingPlot, COMDAT
; _this$ = ecx

; 4880 : 	m_bStartingPlot = bNewValue;

	mov	al, BYTE PTR _bNewValue$[esp-4]
	add	al, al
	add	al, al
	xor	al, BYTE PTR [ecx+461]
	and	al, 4
	xor	BYTE PTR [ecx+461], al

; 4881 : }

	ret	4
?setStartingPlot@CvPlot@@QAEX_N@Z ENDP			; CvPlot::setStartingPlot
_TEXT	ENDS
PUBLIC	?isNEOfRiver@CvPlot@@QBE_NXZ			; CvPlot::isNEOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isNEOfRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isNEOfRiver@CvPlot@@QBE_NXZ PROC			; CvPlot::isNEOfRiver, COMDAT
; _this$ = ecx

; 4887 : 	return m_bNEOfRiver;

	mov	al, BYTE PTR [ecx+461]
	shr	al, 4
	and	al, 1

; 4888 : }

	ret	0
?isNEOfRiver@CvPlot@@QBE_NXZ ENDP			; CvPlot::isNEOfRiver
_TEXT	ENDS
PUBLIC	?isWOfRiver@CvPlot@@QBE_NXZ			; CvPlot::isWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isWOfRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWOfRiver@CvPlot@@QBE_NXZ PROC			; CvPlot::isWOfRiver, COMDAT
; _this$ = ecx

; 4933 : 	return m_bWOfRiver;

	mov	al, BYTE PTR [ecx+461]
	shr	al, 5
	and	al, 1

; 4934 : }

	ret	0
?isWOfRiver@CvPlot@@QBE_NXZ ENDP			; CvPlot::isWOfRiver
_TEXT	ENDS
PUBLIC	?isNWOfRiver@CvPlot@@QBE_NXZ			; CvPlot::isNWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isNWOfRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isNWOfRiver@CvPlot@@QBE_NXZ PROC			; CvPlot::isNWOfRiver, COMDAT
; _this$ = ecx

; 4979 : 	return m_bNWOfRiver;

	mov	al, BYTE PTR [ecx+461]
	shr	al, 6
	and	al, 1

; 4980 : }

	ret	0
?isNWOfRiver@CvPlot@@QBE_NXZ ENDP			; CvPlot::isNWOfRiver
_TEXT	ENDS
PUBLIC	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
; Function compile flags: /Ogtpy
;	COMDAT ?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ
_TEXT	SEGMENT
?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ PROC ; CvPlot::getRiverEFlowDirection, COMDAT
; _this$ = ecx

; 5025 : 	return (FlowDirectionTypes)m_eRiverEFlowDirection;

	movsx	eax, BYTE PTR [ecx+450]

; 5026 : }

	ret	0
?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ENDP ; CvPlot::getRiverEFlowDirection
_TEXT	ENDS
PUBLIC	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
; Function compile flags: /Ogtpy
;	COMDAT ?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ
_TEXT	SEGMENT
?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ PROC ; CvPlot::getRiverSEFlowDirection, COMDAT
; _this$ = ecx

; 5032 : 	return (FlowDirectionTypes)m_eRiverSEFlowDirection;

	movsx	eax, BYTE PTR [ecx+451]

; 5033 : }

	ret	0
?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ENDP ; CvPlot::getRiverSEFlowDirection
_TEXT	ENDS
PUBLIC	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
; Function compile flags: /Ogtpy
;	COMDAT ?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ
_TEXT	SEGMENT
?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ PROC ; CvPlot::getRiverSWFlowDirection, COMDAT
; _this$ = ecx

; 5038 : 	return (FlowDirectionTypes)m_eRiverSWFlowDirection;

	movsx	eax, BYTE PTR [ecx+452]

; 5039 : }

	ret	0
?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ENDP ; CvPlot::getRiverSWFlowDirection
_TEXT	ENDS
PUBLIC	?isPotentialCityWork@CvPlot@@QBE_NXZ		; CvPlot::isPotentialCityWork
; Function compile flags: /Ogtpy
;	COMDAT ?isPotentialCityWork@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isPotentialCityWork@CvPlot@@QBE_NXZ PROC		; CvPlot::isPotentialCityWork, COMDAT
; _this$ = ecx

; 5113 : 	return m_bPotentialCityWork;

	mov	al, BYTE PTR [ecx+461]
	shr	al, 7

; 5114 : }

	ret	0
?isPotentialCityWork@CvPlot@@QBE_NXZ ENDP		; CvPlot::isPotentialCityWork
_TEXT	ENDS
PUBLIC	?ClearCityPurchaseInfo@CvPlot@@QAEXXZ		; CvPlot::ClearCityPurchaseInfo
; Function compile flags: /Ogtpy
;	COMDAT ?ClearCityPurchaseInfo@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?ClearCityPurchaseInfo@CvPlot@@QAEXXZ PROC		; CvPlot::ClearCityPurchaseInfo, COMDAT
; _this$ = ecx

; 5612 : 	m_purchaseCity.eOwner = NO_PLAYER;

	or	eax, -1
	mov	DWORD PTR [ecx+136], eax

; 5613 : 	m_purchaseCity.iID = -1;

	mov	DWORD PTR [ecx+140], eax

; 5614 : }

	ret	0
?ClearCityPurchaseInfo@CvPlot@@QAEXXZ ENDP		; CvPlot::ClearCityPurchaseInfo
_TEXT	ENDS
PUBLIC	?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ ; CvPlot::GetCityPurchaseOwner
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetCityPurchaseOwner, COMDAT
; _this$ = ecx

; 5623 : 	return m_purchaseCity.eOwner;

	mov	eax, DWORD PTR [ecx+136]

; 5624 : }

	ret	0
?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetCityPurchaseOwner
_TEXT	ENDS
PUBLIC	?GetCityPurchaseID@CvPlot@@QAEHXZ		; CvPlot::GetCityPurchaseID
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityPurchaseID@CvPlot@@QAEHXZ
_TEXT	SEGMENT
?GetCityPurchaseID@CvPlot@@QAEHXZ PROC			; CvPlot::GetCityPurchaseID, COMDAT
; _this$ = ecx

; 5633 : 	return m_purchaseCity.iID;

	mov	eax, DWORD PTR [ecx+140]

; 5634 : }

	ret	0
?GetCityPurchaseID@CvPlot@@QAEHXZ ENDP			; CvPlot::GetCityPurchaseID
_TEXT	ENDS
PUBLIC	?SetCityPurchaseID@CvPlot@@QAEXH@Z		; CvPlot::SetCityPurchaseID
; Function compile flags: /Ogtpy
;	COMDAT ?SetCityPurchaseID@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iAcquiringCityID$ = 8					; size = 4
?SetCityPurchaseID@CvPlot@@QAEXH@Z PROC			; CvPlot::SetCityPurchaseID, COMDAT
; _this$ = ecx

; 5639 : 	m_purchaseCity.iID = iAcquiringCityID;

	mov	eax, DWORD PTR _iAcquiringCityID$[esp-4]
	mov	DWORD PTR [ecx+140], eax

; 5640 : }

	ret	4
?SetCityPurchaseID@CvPlot@@QAEXH@Z ENDP			; CvPlot::SetCityPurchaseID
_TEXT	ENDS
PUBLIC	?IsRoughFeature@CvPlot@@QBE_NXZ			; CvPlot::IsRoughFeature
; Function compile flags: /Ogtpy
;	COMDAT ?IsRoughFeature@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsRoughFeature@CvPlot@@QBE_NXZ PROC			; CvPlot::IsRoughFeature, COMDAT
; _this$ = ecx

; 5682 : 	return m_bRoughFeature;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 3
	and	al, 1

; 5683 : }

	ret	0
?IsRoughFeature@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsRoughFeature
_TEXT	ENDS
PUBLIC	?SetRoughFeature@CvPlot@@QAEX_N@Z		; CvPlot::SetRoughFeature
; Function compile flags: /Ogtpy
;	COMDAT ?SetRoughFeature@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetRoughFeature@CvPlot@@QAEX_N@Z PROC			; CvPlot::SetRoughFeature, COMDAT
; _this$ = ecx

; 5688 : 	if(IsRoughFeature() != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	push	esi
	mov	esi, ecx
	mov	dl, BYTE PTR [esi+462]
	mov	cl, dl
	shr	cl, 3
	and	cl, 1
	cmp	cl, al
	je	SHORT $LN1@SetRoughFe

; 5689 : 	{
; 5690 : 		m_bRoughFeature = bValue;

	add	al, al
	add	al, al
	add	al, al
	xor	al, dl
	and	al, 8
	xor	al, dl
	mov	BYTE PTR [esi+462], al
$LN1@SetRoughFe:
	pop	esi

; 5691 : 	}
; 5692 : }

	ret	4
?SetRoughFeature@CvPlot@@QAEX_N@Z ENDP			; CvPlot::SetRoughFeature
_TEXT	ENDS
PUBLIC	?getNumResource@CvPlot@@QBEHXZ			; CvPlot::getNumResource
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResource@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getNumResource@CvPlot@@QBEHXZ PROC			; CvPlot::getNumResource, COMDAT
; _this$ = ecx

; 6193 : 	return m_iResourceNum;

	movsx	eax, BYTE PTR [ecx+458]

; 6194 : }

	ret	0
?getNumResource@CvPlot@@QBEHXZ ENDP			; CvPlot::getNumResource
_TEXT	ENDS
PUBLIC	?setNumResource@CvPlot@@QAEXH@Z			; CvPlot::setNumResource
; Function compile flags: /Ogtpy
;	COMDAT ?setNumResource@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNum$ = 8						; size = 4
?setNumResource@CvPlot@@QAEXH@Z PROC			; CvPlot::setNumResource, COMDAT
; _this$ = ecx

; 6199 : 	m_iResourceNum = iNum;

	mov	al, BYTE PTR _iNum$[esp-4]
	mov	BYTE PTR [ecx+458], al

; 6200 : 	CvAssert(getNumResource() >= 0);
; 6201 : 	FAssertMsg(getResourceType() == NO_RESOURCE || m_iResourceNum > 0, "If a plot contains a Resource it should always have a quantity of at least 1.");
; 6202 : }

	ret	4
?setNumResource@CvPlot@@QAEXH@Z ENDP			; CvPlot::setNumResource
_TEXT	ENDS
PUBLIC	?changeNumResource@CvPlot@@QAEXH@Z		; CvPlot::changeNumResource
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumResource@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumResource@CvPlot@@QAEXH@Z PROC			; CvPlot::changeNumResource, COMDAT
; _this$ = ecx

; 6207 : 	setNumResource(getNumResource() + iChange);

	mov	al, BYTE PTR _iChange$[esp-4]
	add	BYTE PTR [ecx+458], al

; 6208 : 	CvAssert(getNumResource() >= 0);
; 6209 : }

	ret	4
?changeNumResource@CvPlot@@QAEXH@Z ENDP			; CvPlot::changeNumResource
_TEXT	ENDS
PUBLIC	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ
_TEXT	SEGMENT
?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ PROC ; CvPlot::getImprovementType, COMDAT
; _this$ = ecx

; 6260 : 	return (ImprovementTypes)m_eImprovementType;

	movsx	eax, BYTE PTR [ecx+441]

; 6261 : }

	ret	0
?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ENDP ; CvPlot::getImprovementType
_TEXT	ENDS
PUBLIC	?IsImprovementPillaged@CvPlot@@QBE_NXZ		; CvPlot::IsImprovementPillaged
; Function compile flags: /Ogtpy
;	COMDAT ?IsImprovementPillaged@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsImprovementPillaged@CvPlot@@QBE_NXZ PROC		; CvPlot::IsImprovementPillaged, COMDAT
; _this$ = ecx

; 6644 : 	return m_bImprovementPillaged;

	mov	al, BYTE PTR [ecx+461]
	and	al, 1

; 6645 : }

	ret	0
?IsImprovementPillaged@CvPlot@@QBE_NXZ ENDP		; CvPlot::IsImprovementPillaged
_TEXT	ENDS
PUBLIC	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ	; CvPlot::IsImprovedByGiftFromMajor
; Function compile flags: /Ogtpy
;	COMDAT ?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ PROC		; CvPlot::IsImprovedByGiftFromMajor, COMDAT
; _this$ = ecx

; 6697 : 	return m_bImprovedByGiftFromMajor;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 5
	and	al, 1

; 6698 : }

	ret	0
?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ ENDP		; CvPlot::IsImprovedByGiftFromMajor
_TEXT	ENDS
PUBLIC	?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z	; CvPlot::SetImprovedByGiftFromMajor
; Function compile flags: /Ogtpy
;	COMDAT ?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z PROC	; CvPlot::SetImprovedByGiftFromMajor, COMDAT
; _this$ = ecx

; 6703 : 	m_bImprovedByGiftFromMajor = bValue;

	mov	al, BYTE PTR _bValue$[esp-4]
	shl	al, 5
	xor	al, BYTE PTR [ecx+462]
	and	al, 32					; 00000020H
	xor	BYTE PTR [ecx+462], al

; 6704 : }

	ret	4
?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z ENDP	; CvPlot::SetImprovedByGiftFromMajor
_TEXT	ENDS
PUBLIC	?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ	; CvPlot::IsBarbarianCampNotConverting
; Function compile flags: /Ogtpy
;	COMDAT ?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ PROC	; CvPlot::IsBarbarianCampNotConverting, COMDAT
; _this$ = ecx

; 6740 : 	return m_bBarbCampNotConverting;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 2
	and	al, 1

; 6741 : }

	ret	0
?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ ENDP	; CvPlot::IsBarbarianCampNotConverting
_TEXT	ENDS
PUBLIC	?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z	; CvPlot::SetBarbarianCampNotConverting
; Function compile flags: /Ogtpy
;	COMDAT ?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bNotConverting$ = 8					; size = 1
?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z PROC	; CvPlot::SetBarbarianCampNotConverting, COMDAT
; _this$ = ecx

; 6746 : 	m_bBarbCampNotConverting = bNotConverting;

	mov	al, BYTE PTR _bNotConverting$[esp-4]
	add	al, al
	add	al, al
	xor	al, BYTE PTR [ecx+462]
	and	al, 4
	xor	BYTE PTR [ecx+462], al

; 6747 : }

	ret	4
?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z ENDP	; CvPlot::SetBarbarianCampNotConverting
_TEXT	ENDS
PUBLIC	?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ ; CvPlot::GetWorldAnchor
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ
_TEXT	SEGMENT
?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ PROC ; CvPlot::GetWorldAnchor, COMDAT
; _this$ = ecx

; 6752 : 	return (GenericWorldAnchorTypes) m_eWorldAnchor;

	movsx	eax, BYTE PTR [ecx+448]

; 6753 : }

	ret	0
?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ ENDP ; CvPlot::GetWorldAnchor
_TEXT	ENDS
PUBLIC	?GetWorldAnchorData@CvPlot@@QBEHXZ		; CvPlot::GetWorldAnchorData
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorldAnchorData@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?GetWorldAnchorData@CvPlot@@QBEHXZ PROC			; CvPlot::GetWorldAnchorData, COMDAT
; _this$ = ecx

; 6758 : 	return (int) m_cWorldAnchorData;

	movsx	eax, BYTE PTR [ecx+449]

; 6759 : }

	ret	0
?GetWorldAnchorData@CvPlot@@QBEHXZ ENDP			; CvPlot::GetWorldAnchorData
_TEXT	ENDS
PUBLIC	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ	; CvPlot::getRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ
_TEXT	SEGMENT
?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ PROC	; CvPlot::getRouteType, COMDAT
; _this$ = ecx

; 6783 : 	return (RouteTypes)m_eRouteType;

	movsx	eax, BYTE PTR [ecx+447]

; 6784 : }

	ret	0
?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ENDP	; CvPlot::getRouteType
_TEXT	ENDS
PUBLIC	?IsRoutePillaged@CvPlot@@QBE_NXZ		; CvPlot::IsRoutePillaged
; Function compile flags: /Ogtpy
;	COMDAT ?IsRoutePillaged@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsRoutePillaged@CvPlot@@QBE_NXZ PROC			; CvPlot::IsRoutePillaged, COMDAT
; _this$ = ecx

; 6901 : 	return m_bRoutePillaged;

	mov	al, BYTE PTR [ecx+461]
	shr	al, 1
	and	al, 1

; 6902 : }

	ret	0
?IsRoutePillaged@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsRoutePillaged
_TEXT	ENDS
PUBLIC	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerThatBuiltImprovement, COMDAT
; _this$ = ecx

; 6967 : 	return (PlayerTypes) m_ePlayerBuiltImprovement;

	movsx	eax, BYTE PTR [ecx+443]

; 6968 : }

	ret	0
?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerThatBuiltImprovement
_TEXT	ENDS
PUBLIC	?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatBuiltImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eBuilder$ = 8						; size = 4
?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerThatBuiltImprovement, COMDAT
; _this$ = ecx

; 6974 : 	m_ePlayerBuiltImprovement = eBuilder;

	mov	al, BYTE PTR _eBuilder$[esp-4]
	mov	BYTE PTR [ecx+443], al

; 6975 : }

	ret	4
?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerThatBuiltImprovement
_TEXT	ENDS
PUBLIC	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerResponsibleForImprovement, COMDAT
; _this$ = ecx

; 6981 : 	return (PlayerTypes) m_ePlayerResponsibleForImprovement;

	movsx	eax, BYTE PTR [ecx+444]

; 6982 : }

	ret	0
?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerResponsibleForImprovement
_TEXT	ENDS
PUBLIC	?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eNewValue$ = 8						; size = 4
?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerResponsibleForImprovement, COMDAT
; _this$ = ecx

; 6988 : 	if(GetPlayerResponsibleForImprovement() != eNewValue)

	movsx	edx, BYTE PTR [ecx+444]
	mov	eax, DWORD PTR _eNewValue$[esp-4]
	cmp	edx, eax
	je	SHORT $LN1@SetPlayerR

; 6989 : 	{
; 6990 : 		m_ePlayerResponsibleForImprovement = eNewValue;

	mov	BYTE PTR [ecx+444], al
$LN1@SetPlayerR:

; 6991 : 	}
; 6992 : }

	ret	4
?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerResponsibleForImprovement
_TEXT	ENDS
PUBLIC	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerResponsibleForRoute, COMDAT
; _this$ = ecx

; 6998 : 	return (PlayerTypes) m_ePlayerResponsibleForRoute;

	movsx	eax, BYTE PTR [ecx+445]

; 6999 : }

	ret	0
?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerResponsibleForRoute
_TEXT	ENDS
PUBLIC	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForRoute
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eNewValue$ = 8						; size = 4
?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerResponsibleForRoute, COMDAT
; _this$ = ecx

; 7005 : 	if(GetPlayerResponsibleForRoute() != eNewValue)

	movsx	edx, BYTE PTR [ecx+445]
	mov	eax, DWORD PTR _eNewValue$[esp-4]
	cmp	edx, eax
	je	SHORT $LN1@SetPlayerR@2

; 7006 : 	{
; 7007 : 		m_ePlayerResponsibleForRoute = eNewValue;

	mov	BYTE PTR [ecx+445], al
$LN1@SetPlayerR@2:

; 7008 : 	}
; 7009 : }

	ret	4
?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerResponsibleForRoute
_TEXT	ENDS
PUBLIC	?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatClearedBarbCampHere
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerThatClearedBarbCampHere, COMDAT
; _this$ = ecx

; 7014 : 	return (PlayerTypes) m_ePlayerThatClearedBarbCampHere;

	movsx	eax, BYTE PTR [ecx+446]

; 7015 : }

	ret	0
?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerThatClearedBarbCampHere
_TEXT	ENDS
PUBLIC	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatClearedBarbCampHere
; Function compile flags: /Ogtpy
;	COMDAT ?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eNewValue$ = 8						; size = 4
?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerThatClearedBarbCampHere, COMDAT
; _this$ = ecx

; 7020 : 	m_ePlayerThatClearedBarbCampHere = eNewValue;

	mov	al, BYTE PTR _eNewValue$[esp-4]
	mov	BYTE PTR [ecx+446], al

; 7021 : }

	ret	4
?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerThatClearedBarbCampHere
_TEXT	ENDS
PUBLIC	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::GetResourceLinkedCity
EXTRN	?getCity@@YAPAVCvCity@@UIDInfo@@@Z:PROC		; getCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ PROC	; CvPlot::GetResourceLinkedCity, COMDAT
; _this$ = ecx

; 7027 : 	return getCity(m_ResourceLinkedCity);

	mov	eax, DWORD PTR [ecx+132]
	mov	ecx, DWORD PTR [ecx+128]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 7028 : }

	ret	0
?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ENDP	; CvPlot::GetResourceLinkedCity
_TEXT	ENDS
PUBLIC	?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ	; CvPlot::IsResourceLinkedCityActive
; Function compile flags: /Ogtpy
;	COMDAT ?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ PROC	; CvPlot::IsResourceLinkedCityActive, COMDAT
; _this$ = ecx

; 7055 : 	return m_bResourceLinkedCityActive;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 4
	and	al, 1

; 7056 : }

	ret	0
?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ ENDP	; CvPlot::IsResourceLinkedCityActive
_TEXT	ENDS
PUBLIC	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getWorkingCity
; Function compile flags: /Ogtpy
;	COMDAT ?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getWorkingCity, COMDAT
; _this$ = ecx

; 7222 : 	return getCity(m_workingCity);

	mov	eax, DWORD PTR [ecx+116]
	mov	ecx, DWORD PTR [ecx+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 7223 : }

	ret	0
?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getWorkingCity
_TEXT	ENDS
PUBLIC	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride
; Function compile flags: /Ogtpy
;	COMDAT ?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ PROC	; CvPlot::getWorkingCityOverride, COMDAT
; _this$ = ecx

; 7320 : 	return getCity(m_workingCityOverride);

	mov	eax, DWORD PTR [ecx+124]
	mov	ecx, DWORD PTR [ecx+120]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 7321 : }

	ret	0
?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ENDP	; CvPlot::getWorkingCityOverride
_TEXT	ENDS
PUBLIC	?getReconCount@CvPlot@@QBEHXZ			; CvPlot::getReconCount
; Function compile flags: /Ogtpy
;	COMDAT ?getReconCount@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getReconCount@CvPlot@@QBEHXZ PROC			; CvPlot::getReconCount, COMDAT
; _this$ = ecx

; 7346 : 	return m_iReconCount;

	movsx	eax, BYTE PTR [ecx+456]

; 7347 : }

	ret	0
?getReconCount@CvPlot@@QBEHXZ ENDP			; CvPlot::getReconCount
_TEXT	ENDS
PUBLIC	?changeReconCount@CvPlot@@QAEXH@Z		; CvPlot::changeReconCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeReconCount@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeReconCount@CvPlot@@QAEXH@Z PROC			; CvPlot::changeReconCount, COMDAT
; _this$ = ecx

; 7353 : 	m_iReconCount = (m_iReconCount + iChange);

	mov	al, BYTE PTR _iChange$[esp-4]
	add	BYTE PTR [ecx+456], al

; 7354 : 	CvAssert(getReconCount() >= 0);
; 7355 : }

	ret	4
?changeReconCount@CvPlot@@QAEXH@Z ENDP			; CvPlot::changeReconCount
_TEXT	ENDS
PUBLIC	?getRiverCrossingCount@CvPlot@@QBEHXZ		; CvPlot::getRiverCrossingCount
; Function compile flags: /Ogtpy
;	COMDAT ?getRiverCrossingCount@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getRiverCrossingCount@CvPlot@@QBEHXZ PROC		; CvPlot::getRiverCrossingCount, COMDAT
; _this$ = ecx

; 7361 : 	return m_iRiverCrossingCount;

	movsx	eax, BYTE PTR [ecx+457]

; 7362 : }

	ret	0
?getRiverCrossingCount@CvPlot@@QBEHXZ ENDP		; CvPlot::getRiverCrossingCount
_TEXT	ENDS
PUBLIC	?changeRiverCrossingCount@CvPlot@@QAEXH@Z	; CvPlot::changeRiverCrossingCount
; Function compile flags: /Ogtpy
;	COMDAT ?changeRiverCrossingCount@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeRiverCrossingCount@CvPlot@@QAEXH@Z PROC		; CvPlot::changeRiverCrossingCount, COMDAT
; _this$ = ecx

; 7368 : 	m_iRiverCrossingCount = (m_iRiverCrossingCount + iChange);

	mov	al, BYTE PTR _iChange$[esp-4]
	add	BYTE PTR [ecx+457], al

; 7369 : 	CvAssert(getRiverCrossingCount() >= 0);
; 7370 : }

	ret	4
?changeRiverCrossingCount@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeRiverCrossingCount
_TEXT	ENDS
PUBLIC	?getYield@CvPlot@@QAEPAFXZ			; CvPlot::getYield
; Function compile flags: /Ogtpy
;	COMDAT ?getYield@CvPlot@@QAEPAFXZ
_TEXT	SEGMENT
?getYield@CvPlot@@QAEPAFXZ PROC				; CvPlot::getYield, COMDAT
; _this$ = ecx

; 7380 : 	return m_aiYield;

	mov	eax, DWORD PTR [ecx+144]

; 7381 : }

	ret	0
?getYield@CvPlot@@QAEPAFXZ ENDP				; CvPlot::getYield
_TEXT	ENDS
PUBLIC	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z		; CvPlot::getYield
; Function compile flags: /Ogtpy
;	COMDAT ?getYield@CvPlot@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getYield@CvPlot@@QBEHW4YieldTypes@@@Z PROC		; CvPlot::getYield, COMDAT
; _this$ = ecx

; 7387 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7388 : 	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 7389 : 	return (int)(m_aiYield[eIndex]);

	mov	eax, DWORD PTR [ecx+144]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 7390 : }

	ret	4
?getYield@CvPlot@@QBEHW4YieldTypes@@@Z ENDP		; CvPlot::getYield
_TEXT	ENDS
PUBLIC	?hasYield@CvPlot@@QBE_NXZ			; CvPlot::hasYield
; Function compile flags: /Ogtpy
;	COMDAT ?hasYield@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?hasYield@CvPlot@@QBE_NXZ PROC				; CvPlot::hasYield, COMDAT
; _this$ = ecx

; 8117 : 	int iI;
; 8118 : 
; 8119 : 	for(iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	mov	ecx, DWORD PTR [ecx+144]
	xor	eax, eax
$LL4@hasYield:

; 8120 : 	{
; 8121 : 		if(getYield((YieldTypes)iI) > 0)

	cmp	WORD PTR [ecx], 0
	jg	SHORT $LN10@hasYield
	inc	eax
	add	ecx, 2
	cmp	eax, 6
	jl	SHORT $LL4@hasYield

; 8124 : 		}
; 8125 : 	}
; 8126 : 
; 8127 : 	return false;

	xor	al, al

; 8128 : }

	ret	0
$LN10@hasYield:

; 8122 : 		{
; 8123 : 			return true;

	mov	al, 1

; 8128 : }

	ret	0
?hasYield@CvPlot@@QBE_NXZ ENDP				; CvPlot::hasYield
_TEXT	ENDS
PUBLIC	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z	; CvPlot::setFoundValue
; Function compile flags: /Ogtpy
;	COMDAT ?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z PROC	; CvPlot::setFoundValue, COMDAT
; _this$ = ecx

; 8232 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8233 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8234 : 
; 8235 : 	m_aiFoundValue[eIndex] = iNewValue;

	mov	eax, DWORD PTR [ecx+148]
	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 8236 : }

	ret	8
?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ENDP	; CvPlot::setFoundValue
_TEXT	ENDS
PUBLIC	?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getPlayerCityRadiusCount
; Function compile flags: /Ogtpy
;	COMDAT ?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z PROC ; CvPlot::getPlayerCityRadiusCount, COMDAT
; _this$ = ecx

; 8242 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8243 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8244 : 
; 8245 : 	return m_aiPlayerCityRadiusCount[eIndex];

	mov	eax, DWORD PTR [ecx+152]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	movsx	eax, BYTE PTR [eax+ecx]

; 8246 : }

	ret	4
?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlot::getPlayerCityRadiusCount
_TEXT	ENDS
PUBLIC	?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isPlayerCityRadius
; Function compile flags: /Ogtpy
;	COMDAT ?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::isPlayerCityRadius, COMDAT
; _this$ = ecx

; 8252 : 	return (getPlayerCityRadiusCount(eIndex) > 0);

	mov	eax, DWORD PTR [ecx+152]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	xor	ecx, ecx
	cmp	BYTE PTR [edx+eax], cl
	setg	cl
	mov	al, cl

; 8253 : }

	ret	4
?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::isPlayerCityRadius
_TEXT	ENDS
PUBLIC	?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::changePlayerCityRadiusCount
; Function compile flags: /Ogtpy
;	COMDAT ?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z PROC ; CvPlot::changePlayerCityRadiusCount, COMDAT
; _this$ = ecx

; 8259 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8260 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8261 : 
; 8262 : 	if(0 != iChange)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN1@changePlay

; 8263 : 	{
; 8264 : 		m_aiPlayerCityRadiusCount[eIndex] += iChange;

	mov	eax, DWORD PTR [ecx+152]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	add	eax, ecx
	add	BYTE PTR [eax], dl
$LN1@changePlay:

; 8265 : 		CvAssert(getPlayerCityRadiusCount(eIndex) >= 0);
; 8266 : 	}
; 8267 : }

	ret	8
?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z ENDP ; CvPlot::changePlayerCityRadiusCount
_TEXT	ENDS
PUBLIC	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getRevealedOwner, COMDAT
; _this$ = ecx

; 8440 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8441 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8442 : 
; 8443 : 	return (PlayerTypes)m_aiRevealedOwner[eTeam];

	mov	eax, DWORD PTR [ecx+160]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, BYTE PTR [eax+ecx]

; 8444 : }

	ret	4
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getRevealedOwner
_TEXT	ENDS
PUBLIC	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
; Function compile flags: /Ogtpy
;	COMDAT ?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z PROC	; CvPlot::isRiverCrossing, COMDAT
; _this$ = ecx

; 8532 : {

	mov	eax, ecx

; 8533 : 	CvAssertMsg(eIndex < NUM_DIRECTION_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8534 : 
; 8535 : 	if(eIndex == NO_DIRECTION)

	mov	ecx, DWORD PTR _eIndex$[esp-4]
	cmp	ecx, -1
	jne	SHORT $LN1@isRiverCro

; 8536 : 	{
; 8537 : 		return false;

	xor	al, al

; 8543 : }

	ret	4
$LN1@isRiverCro:

; 8538 : 	}
; 8539 : 
; 8540 : 	int iFlowMask = 1 << eIndex;
; 8541 : 
; 8542 : 	return ((m_cRiverCrossing & iFlowMask) != 0);

	movsx	eax, BYTE PTR [eax+460]
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	neg	eax
	sbb	eax, eax
	neg	eax

; 8543 : }

	ret	4
?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ENDP	; CvPlot::isRiverCrossing
_TEXT	ENDS
PUBLIC	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsResourceForceReveal
; Function compile flags: /Ogtpy
;	COMDAT ?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z PROC ; CvPlot::IsResourceForceReveal, COMDAT
; _this$ = ecx

; 8635 : 	return m_abResourceForceReveal[eTeam];

	mov	eax, DWORD PTR [ecx+176]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 8636 : }

	ret	4
?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP ; CvPlot::IsResourceForceReveal
_TEXT	ENDS
PUBLIC	?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z ; CvPlot::SetResourceForceReveal
; Function compile flags: /Ogtpy
;	COMDAT ?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z PROC ; CvPlot::SetResourceForceReveal, COMDAT
; _this$ = ecx

; 8642 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8643 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8644 : 	m_abResourceForceReveal[eTeam] = bValue;

	mov	eax, DWORD PTR [ecx+176]
	mov	cl, BYTE PTR _bValue$[esp-4]
	mov	edx, DWORD PTR _eTeam$[esp-4]
	mov	BYTE PTR [edx+eax], cl

; 8645 : }

	ret	8
?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z ENDP ; CvPlot::SetResourceForceReveal
_TEXT	ENDS
PUBLIC	?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z	; CvPlot::IsNoSettling
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::IsNoSettling, COMDAT
; _this$ = ecx

; 8650 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 8651 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 8652 : 
; 8653 : 	return m_abNoSettling[eMajor];

	mov	eax, DWORD PTR [ecx+172]
	mov	ecx, DWORD PTR _eMajor$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 8654 : }

	ret	4
?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::IsNoSettling
_TEXT	ENDS
PUBLIC	?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z	; CvPlot::SetNoSettling
; Function compile flags: /Ogtpy
;	COMDAT ?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_eMajor$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z PROC	; CvPlot::SetNoSettling, COMDAT
; _this$ = ecx

; 8659 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 8660 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 8661 : 
; 8662 : 	if(bValue != IsNoSettling(eMajor))

	mov	eax, DWORD PTR [ecx+172]
	mov	ecx, DWORD PTR _eMajor$[esp-4]
	add	eax, ecx
	mov	cl, BYTE PTR _bValue$[esp-4]
	cmp	cl, BYTE PTR [eax]
	je	SHORT $LN1@SetNoSettl

; 8663 : 		m_abNoSettling[eMajor] = bValue;

	mov	BYTE PTR [eax], cl
$LN1@SetNoSettl:

; 8664 : }

	ret	8
?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z ENDP	; CvPlot::SetNoSettling
_TEXT	ENDS
PUBLIC	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getRevealedImprovementType, COMDAT
; _this$ = ecx

; 9148 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9149 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9150 : 
; 9151 : 	return (ImprovementTypes)m_aeRevealedImprovementType[eTeam];

	mov	eax, DWORD PTR [ecx+164]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 9152 : }

	ret	4
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getRevealedImprovementType
_TEXT	ENDS
PUBLIC	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getRevealedRouteType, COMDAT
; _this$ = ecx

; 9203 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9204 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9205 : 
; 9206 : 	return (RouteTypes)m_aeRevealedRouteType[eTeam];

	mov	eax, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 9207 : }

	ret	4
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getRevealedRouteType
_TEXT	ENDS
PUBLIC	?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ	; CvPlot::SilentlyResetAllBuildProgress
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ PROC	; CvPlot::SilentlyResetAllBuildProgress, COMDAT
; _this$ = ecx

; 9230 : {

	push	ebx
	mov	ebx, ecx

; 9231 : 	if(NULL != m_paiBuildProgress)  // if it doesn't exist no point in clearing it out

	cmp	DWORD PTR [ebx+184], 0
	je	SHORT $LN3@SilentlyRe
	push	esi
	push	edi

; 9232 : 	{
; 9233 : 		int iNumBuildInfos = GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	edi, eax

; 9234 : 		for(int iThisBuild = 0 ; iThisBuild < iNumBuildInfos; iThisBuild++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN11@SilentlyRe
$LL5@SilentlyRe:

; 9235 : 		{
; 9236 : 			CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iThisBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 9237 : 			if(!pkBuildInfo)

	test	eax, eax
	je	SHORT $LN4@SilentlyRe

; 9238 : 			{
; 9239 : 				continue;
; 9240 : 			}
; 9241 : 
; 9242 : 			// Is this an Improvement?
; 9243 : 			if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT)

	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, -1
	je	SHORT $LN4@SilentlyRe

; 9244 : 			{
; 9245 : 				m_paiBuildProgress[iThisBuild] = 0;

	mov	eax, DWORD PTR [ebx+184]
	xor	ecx, ecx
	mov	WORD PTR [eax+esi*2], cx
$LN4@SilentlyRe:
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL5@SilentlyRe
$LN11@SilentlyRe:
	pop	edi
	pop	esi
$LN3@SilentlyRe:
	pop	ebx

; 9246 : 			}
; 9247 : 		}
; 9248 : 	}
; 9249 : }

	ret	0
?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ ENDP	; CvPlot::SilentlyResetAllBuildProgress
_TEXT	ENDS
PUBLIC	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z	; CvPlot::getBuildProgress
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z
_TEXT	SEGMENT
_eBuild$ = 8						; size = 4
?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z PROC	; CvPlot::getBuildProgress, COMDAT
; _this$ = ecx

; 9255 : 	if(NULL == m_paiBuildProgress)

	mov	eax, DWORD PTR [ecx+184]
	test	eax, eax
	jne	SHORT $LN1@getBuildPr

; 9261 : }

	ret	4
$LN1@getBuildPr:

; 9256 : 	{
; 9257 : 		return 0;
; 9258 : 	}
; 9259 : 
; 9260 : 	return m_paiBuildProgress[eBuild];

	mov	ecx, DWORD PTR _eBuild$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 9261 : }

	ret	4
?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ENDP	; CvPlot::getBuildProgress
_TEXT	ENDS
PUBLIC	?getAnyBuildProgress@CvPlot@@QBE_NXZ		; CvPlot::getAnyBuildProgress
; Function compile flags: /Ogtpy
;	COMDAT ?getAnyBuildProgress@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?getAnyBuildProgress@CvPlot@@QBE_NXZ PROC		; CvPlot::getAnyBuildProgress, COMDAT
; _this$ = ecx

; 9266 : 	return (NULL != m_paiBuildProgress);

	xor	eax, eax
	cmp	DWORD PTR [ecx+184], eax
	setne	al

; 9267 : }

	ret	0
?getAnyBuildProgress@CvPlot@@QBE_NXZ ENDP		; CvPlot::getAnyBuildProgress
_TEXT	ENDS
PUBLIC	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::getInvisibleVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_eInvisible$ = 12					; size = 4
?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z PROC ; CvPlot::getInvisibleVisibilityCount, COMDAT
; _this$ = ecx

; 9563 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9564 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9565 : 	CvAssertMsg(eInvisible >= 0, "eInvisible is expected to be non-negative (invalid Index)");
; 9566 : 	CvAssertMsg(eInvisible < NUM_INVISIBLE_TYPES, "eInvisible is expected to be within maximum bounds (invalid Index)");
; 9567 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return 0;

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getInvisib

; 9568 : 	if(eInvisible < 0 || eInvisible >= NUM_INVISIBLE_TYPES) return 0;

	mov	edx, DWORD PTR _eInvisible$[esp-4]
	test	edx, edx
	ja	SHORT $LN3@getInvisib

; 9569 : 	return m_apaiInvisibleVisibilityCount[eTeam][eInvisible];

	add	eax, edx
	movsx	eax, WORD PTR [ecx+eax*2+196]

; 9570 : }

	ret	8
$LN3@getInvisib:

; 9563 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9564 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9565 : 	CvAssertMsg(eInvisible >= 0, "eInvisible is expected to be non-negative (invalid Index)");
; 9566 : 	CvAssertMsg(eInvisible < NUM_INVISIBLE_TYPES, "eInvisible is expected to be within maximum bounds (invalid Index)");
; 9567 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return 0;

	xor	eax, eax

; 9570 : }

	ret	8
?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ENDP ; CvPlot::getInvisibleVisibilityCount
_TEXT	ENDS
PUBLIC	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_eInvisible$ = 12					; size = 4
?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z PROC ; CvPlot::isInvisibleVisible, COMDAT
; _this$ = ecx

; 9576 : 	return (getInvisibleVisibilityCount(eTeam, eInvisible) > 0);

	mov	edx, DWORD PTR _eTeam$[esp-4]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN5@isInvisibl
	mov	eax, DWORD PTR _eInvisible$[esp-4]
	test	eax, eax
	ja	SHORT $LN5@isInvisibl
	add	edx, eax
	movsx	eax, WORD PTR [ecx+edx*2+196]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 9577 : }

	ret	8

; 9576 : 	return (getInvisibleVisibilityCount(eTeam, eInvisible) > 0);

$LN5@isInvisibl:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 9577 : }

	ret	8
?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ENDP ; CvPlot::isInvisibleVisible
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ; CvPopupInfo::CvPopupInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z
_TEXT	SEGMENT
_buttonPopupType$ = 8					; size = 4
_data1$ = 12						; size = 4
_data2$ = 16						; size = 4
_data3$ = 20						; size = 4
_flags$ = 24						; size = 4
_option1$ = 28						; size = 1
_option2$ = 32						; size = 1
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z PROC	; CvPopupInfo::CvPopupInfo, COMDAT
; _this$ = ecx

; 119  : 	{

	mov	edx, DWORD PTR _data2$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _data1$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _data3$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _flags$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	cl, BYTE PTR _option1$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR _option2$[esp-4]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _buttonPopupType$[esp-4]
	mov	BYTE PTR [eax+17], dl
	mov	DWORD PTR [eax+20], ecx

; 120  : 		//Nothing
; 121  : 		szText[0] = 0;

	mov	BYTE PTR [eax+24], 0

; 122  : 	}

	ret	28					; 0000001cH
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ENDP	; CvPopupInfo::CvPopupInfo
_TEXT	ENDS
PUBLIC	??0IDInfo@@QAE@W4PlayerTypes@@H@Z		; IDInfo::IDInfo
; Function compile flags: /Ogtpy
;	COMDAT ??0IDInfo@@QAE@W4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eOwner$ = 8						; size = 4
_iID$ = 12						; size = 4
??0IDInfo@@QAE@W4PlayerTypes@@H@Z PROC			; IDInfo::IDInfo, COMDAT
; _this$ = ecx

; 177  : 	IDInfo(PlayerTypes eOwner=NO_PLAYER, int iID=FFreeList::INVALID_INDEX) : eOwner(eOwner), iID(iID) {}

	mov	edx, DWORD PTR _iID$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _eOwner$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0IDInfo@@QAE@W4PlayerTypes@@H@Z ENDP			; IDInfo::IDInfo
_TEXT	ENDS
PUBLIC	??8IDInfo@@QBE_NABU0@@Z				; IDInfo::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8IDInfo@@QBE_NABU0@@Z
_TEXT	SEGMENT
_info$ = 8						; size = 4
??8IDInfo@@QBE_NABU0@@Z PROC				; IDInfo::operator==, COMDAT
; _this$ = ecx

; 183  : 		return (eOwner == info.eOwner && iID == info.iID);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _info$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator
	mov	eax, 1

; 184  : 	}

	ret	4
$LN3@operator:

; 183  : 		return (eOwner == info.eOwner && iID == info.iID);

	xor	eax, eax

; 184  : 	}

	ret	4
??8IDInfo@@QBE_NABU0@@Z ENDP				; IDInfo::operator==
_TEXT	ENDS
PUBLIC	?reset@IDInfo@@QAEXXZ				; IDInfo::reset
; Function compile flags: /Ogtpy
;	COMDAT ?reset@IDInfo@@QAEXXZ
_TEXT	SEGMENT
?reset@IDInfo@@QAEXXZ PROC				; IDInfo::reset, COMDAT
; _this$ = ecx

; 193  : 		eOwner = NO_PLAYER;

	mov	DWORD PTR [ecx], -1

; 194  : 		iID = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [ecx+4], -1

; 195  : 	}

	ret	0
?reset@IDInfo@@QAEXXZ ENDP				; IDInfo::reset
_TEXT	ENDS
PUBLIC	?isLayoutDirty@CvPlot@@QBE_NXZ			; CvPlot::isLayoutDirty
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?isLayoutDirty@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isLayoutDirty@CvPlot@@QBE_NXZ PROC			; CvPlot::isLayoutDirty, COMDAT
; _this$ = ecx

; 10441: 	return m_bPlotLayoutDirty;

	mov	al, BYTE PTR [ecx+462]
	and	al, 1

; 10442: }

	ret	0
?isLayoutDirty@CvPlot@@QBE_NXZ ENDP			; CvPlot::isLayoutDirty
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator@2

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator@2:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetBuilderAIScratchPadPlayer, COMDAT
; _this$ = ecx

; 11134: 	return (PlayerTypes)m_cBuilderAIScratchPadPlayer;

	movsx	eax, BYTE PTR [ecx+368]

; 11135: }

	ret	0
?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetBuilderAIScratchPadPlayer
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetBuilderAIScratchPadPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetBuilderAIScratchPadPlayer, COMDAT
; _this$ = ecx

; 11140: 	m_cBuilderAIScratchPadPlayer = ePlayer;

	mov	al, BYTE PTR _ePlayer$[esp-4]
	mov	BYTE PTR [ecx+368], al

; 11141: }

	ret	4
?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetBuilderAIScratchPadPlayer
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ	; CvPlot::GetBuilderAIScratchPadTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ
_TEXT	SEGMENT
?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ PROC		; CvPlot::GetBuilderAIScratchPadTurn, COMDAT
; _this$ = ecx

; 11150: 	return m_sBuilderAIScratchPadTurn;

	mov	ax, WORD PTR [ecx+370]

; 11151: }

	ret	0
?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ENDP		; CvPlot::GetBuilderAIScratchPadTurn
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z	; CvPlot::SetBuilderAIScratchPadTurn
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z
_TEXT	SEGMENT
_sNewTurnValue$ = 8					; size = 2
?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z PROC	; CvPlot::SetBuilderAIScratchPadTurn, COMDAT
; _this$ = ecx

; 11160: 	m_sBuilderAIScratchPadTurn = sNewTurnValue;

	mov	ax, WORD PTR _sNewTurnValue$[esp-4]
	mov	WORD PTR [ecx+370], ax

; 11161: }

	ret	4
?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z ENDP	; CvPlot::SetBuilderAIScratchPadTurn
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::GetBuilderAIScratchPadRoute
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ
_TEXT	SEGMENT
?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ PROC ; CvPlot::GetBuilderAIScratchPadRoute, COMDAT
; _this$ = ecx

; 11166: 	return m_eBuilderAIScratchPadRoute;

	mov	eax, DWORD PTR [ecx+376]

; 11167: }

	ret	0
?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ ENDP ; CvPlot::GetBuilderAIScratchPadRoute
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z
_TEXT	SEGMENT
_eRoute$ = 8						; size = 4
?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z PROC ; CvPlot::SetBuilderAIScratchPadRoute, COMDAT
; _this$ = ecx

; 11172: 	m_eBuilderAIScratchPadRoute = eRoute;

	mov	eax, DWORD PTR _eRoute$[esp-4]
	mov	DWORD PTR [ecx+376], eax

; 11173: }

	ret	4
?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ENDP ; CvPlot::SetBuilderAIScratchPadRoute
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ	; CvPlot::GetBuilderAIScratchPadValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ
_TEXT	SEGMENT
?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ PROC	; CvPlot::GetBuilderAIScratchPadValue, COMDAT
; _this$ = ecx

; 11182: 	return m_sBuilderAIScratchPadValue;

	mov	ax, WORD PTR [ecx+372]

; 11183: }

	ret	0
?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ ENDP	; CvPlot::GetBuilderAIScratchPadValue
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z	; CvPlot::SetBuilderAIScratchPadValue
; Function compile flags: /Ogtpy
;	COMDAT ?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z
_TEXT	SEGMENT
_sNewValue$ = 8						; size = 2
?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z PROC	; CvPlot::SetBuilderAIScratchPadValue, COMDAT
; _this$ = ecx

; 11192: 	m_sBuilderAIScratchPadValue = sNewValue;

	mov	ax, WORD PTR _sNewValue$[esp-4]
	mov	WORD PTR [ecx+372], ax

; 11193: }

	ret	4
?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ENDP	; CvPlot::SetBuilderAIScratchPadValue
_TEXT	ENDS
PUBLIC	?GetContinentType@CvPlot@@QBEDXZ		; CvPlot::GetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?GetContinentType@CvPlot@@QBEDXZ
_TEXT	SEGMENT
?GetContinentType@CvPlot@@QBEDXZ PROC			; CvPlot::GetContinentType, COMDAT
; _this$ = ecx

; 11212: 	return m_cContinentType;

	mov	al, BYTE PTR [ecx+459]

; 11213: }

	ret	0
?GetContinentType@CvPlot@@QBEDXZ ENDP			; CvPlot::GetContinentType
_TEXT	ENDS
PUBLIC	?SetContinentType@CvPlot@@QAEXD@Z		; CvPlot::SetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?SetContinentType@CvPlot@@QAEXD@Z
_TEXT	SEGMENT
_cContinent$ = 8					; size = 1
?SetContinentType@CvPlot@@QAEXD@Z PROC			; CvPlot::SetContinentType, COMDAT
; _this$ = ecx

; 11222: 	m_cContinentType = cContinent;

	mov	al, BYTE PTR _cContinent$[esp-4]
	mov	BYTE PTR [ecx+459], al

; 11223: }

	ret	4
?SetContinentType@CvPlot@@QAEXD@Z ENDP			; CvPlot::SetContinentType
_TEXT	ENDS
PUBLIC	?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ	; CvPlot::getSyncArchive
; Function compile flags: /Ogtpy
;	COMDAT ?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ
_TEXT	SEGMENT
?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ PROC	; CvPlot::getSyncArchive, COMDAT
; _this$ = ecx

; 11228: 	return m_syncArchive;

	lea	eax, DWORD PTR [ecx+392]

; 11229: }

	ret	0
?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ ENDP	; CvPlot::getSyncArchive
_TEXT	ENDS
PUBLIC	?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ	; CvPlot::getSyncArchive
; Function compile flags: /Ogtpy
;	COMDAT ?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ
_TEXT	SEGMENT
?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ PROC	; CvPlot::getSyncArchive, COMDAT
; _this$ = ecx

; 11234: 	return m_syncArchive;

	lea	eax, DWORD PTR [ecx+392]

; 11235: }

	ret	0
?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ ENDP	; CvPlot::getSyncArchive
_TEXT	ENDS
PUBLIC	?ClearArchaeologicalRecord@CvPlot@@QAEXXZ	; CvPlot::ClearArchaeologicalRecord
; Function compile flags: /Ogtpy
;	COMDAT ?ClearArchaeologicalRecord@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?ClearArchaeologicalRecord@CvPlot@@QAEXXZ PROC		; CvPlot::ClearArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11350: 	m_kArchaeologyData.m_eArtifactType = NO_GREAT_WORK_ARTIFACT_CLASS;
; 11351: 	m_kArchaeologyData.m_ePlayer1 = NO_PLAYER;

	or	eax, -1
	mov	DWORD PTR [ecx+464], 0
	mov	DWORD PTR [ecx+472], eax

; 11352: 	m_kArchaeologyData.m_ePlayer2 = NO_PLAYER;

	mov	DWORD PTR [ecx+476], eax

; 11353: 	m_kArchaeologyData.m_eEra = NO_ERA;

	mov	DWORD PTR [ecx+468], eax

; 11354: }

	ret	0
?ClearArchaeologicalRecord@CvPlot@@QAEXXZ ENDP		; CvPlot::ClearArchaeologicalRecord
_TEXT	ENDS
PUBLIC	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
; Function compile flags: /Ogtpy
;	COMDAT ?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ PROC ; CvPlot::GetArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11359: 	return m_kArchaeologyData; // return a copy of the record

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx+464]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+468]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+472]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+476]
	mov	ecx, DWORD PTR [ecx+480]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx

; 11360: }

	ret	4
?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ENDP ; CvPlot::GetArchaeologicalRecord
_TEXT	ENDS
PUBLIC	?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z ; CvPlot::SetArtifactType
; Function compile flags: /Ogtpy
;	COMDAT ?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z PROC ; CvPlot::SetArtifactType, COMDAT
; _this$ = ecx

; 11365: 	m_kArchaeologyData.m_eArtifactType = eType;

	mov	eax, DWORD PTR _eType$[esp-4]
	mov	DWORD PTR [ecx+464], eax

; 11366: }

	ret	4
?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z ENDP ; CvPlot::SetArtifactType
_TEXT	ENDS
PUBLIC	?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z ; CvPlot::SetArtifactGreatWork
; Function compile flags: /Ogtpy
;	COMDAT ?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z
_TEXT	SEGMENT
_eWork$ = 8						; size = 4
?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z PROC ; CvPlot::SetArtifactGreatWork, COMDAT
; _this$ = ecx

; 11371: 	m_kArchaeologyData.m_eWork = eWork;

	mov	eax, DWORD PTR _eWork$[esp-4]
	mov	DWORD PTR [ecx+480], eax

; 11372: }

	ret	4
?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z ENDP ; CvPlot::SetArtifactGreatWork
_TEXT	ENDS
PUBLIC	?HasWrittenArtifact@CvPlot@@QBE_NXZ		; CvPlot::HasWrittenArtifact
EXTRN	?getARTIFACT_WRITING@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ:PROC ; CvTypes::getARTIFACT_WRITING
; Function compile flags: /Ogtpy
;	COMDAT ?HasWrittenArtifact@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?HasWrittenArtifact@CvPlot@@QBE_NXZ PROC		; CvPlot::HasWrittenArtifact, COMDAT
; _this$ = ecx

; 11376: {

	push	ebx
	push	esi

; 11377: 	bool bRtnValue = false;
; 11378: 	GreatWorkArtifactClass eArtifactClass = m_kArchaeologyData.m_eArtifactType;

	mov	esi, DWORD PTR [ecx+464]
	xor	bl, bl

; 11379: 	if (eArtifactClass == CvTypes::getARTIFACT_WRITING())

	call	?getARTIFACT_WRITING@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ ; CvTypes::getARTIFACT_WRITING
	cmp	esi, eax

; 11380: 	{
; 11381: 		bRtnValue = true;

	mov	al, 1
	je	SHORT $LN1@HasWritten

; 11382: 	}
; 11383: 	return bRtnValue;

	mov	al, bl
$LN1@HasWritten:
	pop	esi
	pop	ebx

; 11384: }

	ret	0
?HasWrittenArtifact@CvPlot@@QBE_NXZ ENDP		; CvPlot::HasWrittenArtifact
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QBEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QBEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QBEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 83   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 84   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QBEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QBEPBVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QBEPBVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QBEPBVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 93   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 94   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QBEPBVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator!
; Function compile flags: /Ogtpy
;	COMDAT ??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator!, COMDAT
; _this$ = ecx

; 113  : 		return m_target == 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 114  : 	}

	ret	0
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator!
_TEXT	ENDS
PUBLIC	??9?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::operator!=, COMDAT
; _this$ = ecx

; 118  : 		return m_target != rhs;

	mov	ecx, DWORD PTR [ecx]
	xor	eax, eax
	cmp	ecx, DWORD PTR _rhs$[esp-4]
	setne	al

; 119  : 	}

	ret	4
??9?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::operator!=
_TEXT	ENDS
PUBLIC	?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z ; FObjectHandle<CvUnit>::ignoreDestruction
; Function compile flags: /Ogtpy
;	COMDAT ?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z
_TEXT	SEGMENT
_ignore$ = 8						; size = 1
?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z PROC ; FObjectHandle<CvUnit>::ignoreDestruction, COMDAT
; _this$ = ecx

; 128  : 		m_ignoreDestruction = ignore;

	mov	al, BYTE PTR _ignore$[esp-4]
	mov	BYTE PTR [ecx+4], al

; 129  : 	}

	ret	4
?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z ENDP ; FObjectHandle<CvUnit>::ignoreDestruction
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ ; BaseVector<CvPlot *,1>::begin
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?begin@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ PROC ; BaseVector<CvPlot *,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ ENDP ; BaseVector<CvPlot *,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ ; BaseVector<CvPlot *,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ PROC ; BaseVector<CvPlot *,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*4]

; 198  :     };

	ret	0
?end@?$BaseVector@PAVCvPlot@@$00@@QAEPAPAVCvPlot@@XZ ENDP ; BaseVector<CvPlot *,1>::end
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z	; BaseVector<IDInfo,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z PROC	; BaseVector<IDInfo,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UIDInfo@@$00@@QAEAAUIDInfo@@I@Z ENDP	; BaseVector<IDInfo,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UIDInfo@@$00@@QBEABUIDInfo@@I@Z	; BaseVector<IDInfo,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UIDInfo@@$00@@QBEABUIDInfo@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UIDInfo@@$00@@QBEABUIDInfo@@I@Z PROC	; BaseVector<IDInfo,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UIDInfo@@$00@@QBEABUIDInfo@@I@Z ENDP	; BaseVector<IDInfo,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ		; BaseVector<IDInfo,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ PROC		; BaseVector<IDInfo,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ ENDP		; BaseVector<IDInfo,1>::size
_TEXT	ENDS
PUBLIC	?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::getAt
; Function compile flags: /Ogtpy
;	COMDAT ?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::getAt, COMDAT
; _this$ = ecx

; 900  :         if ( (UINT)iIndex < mVec.size() )

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@getAt

; 901  : #endif
; 902  : 	    {
; 903  : 		    return &mVec[ iIndex ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 908  : 	    }
; 909  :     };

	ret	4
$LN2@getAt:

; 904  : 	    }
; 905  : 	    else
; 906  : 	    {
; 907  : 		    return NULL;

	xor	eax, eax

; 908  : 	    }
; 909  :     };

	ret	4
?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::getAt
_TEXT	ENDS
PUBLIC	?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::next
; Function compile flags: /Ogtpy
;	COMDAT ?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::next, COMDAT
; _this$ = ecx

; 936  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 937  : 		unsigned int iIndex = (pNode + 1) - &mVec[0];
; 938  : #else
; 939  :         INT iIndex = ( pNode + 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	add	eax, 8
	sar	eax, 3

; 940  : #endif
; 941  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@next
	lea	eax, DWORD PTR [edx+eax*8]

; 942  :     }

	ret	4

; 940  : #endif
; 941  :         return getAt( iIndex );

$LN6@next:
	xor	eax, eax

; 942  :     }

	ret	4
?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::next
_TEXT	ENDS
PUBLIC	?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::prev
; Function compile flags: /Ogtpy
;	COMDAT ?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::prev, COMDAT
; _this$ = ecx

; 947  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 948  : 		unsigned int iIndex = (pNode - 1) - &mVec[0];
; 949  : #else
; 950  :         INT iIndex = ( pNode - 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	sub	eax, 8
	sar	eax, 3

; 951  : #endif
; 952  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@prev
	lea	eax, DWORD PTR [edx+eax*8]

; 953  :     }

	ret	4

; 951  : #endif
; 952  :         return getAt( iIndex );

$LN6@prev:
	xor	eax, eax

; 953  :     }

	ret	4
?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@PBU2@@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::prev
_TEXT	ENDS
PUBLIC	?getLength@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEHXZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::getLength
; Function compile flags: /Ogtpy
;	COMDAT ?getLength@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEHXZ
_TEXT	SEGMENT
?getLength@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEHXZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::getLength, COMDAT
; _this$ = ecx

; 962  :         return mVec.size();

	mov	eax, DWORD PTR [ecx+4]

; 963  :     }

	ret	0
?getLength@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEHXZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::getLength
_TEXT	ENDS
PUBLIC	?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::head
; Function compile flags: /Ogtpy
;	COMDAT ?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::head, COMDAT
; _this$ = ecx

; 968  :         UINT uSize = mVec.size();
; 969  : 
; 970  :         if( uSize > 0 )

	cmp	DWORD PTR [ecx+4], 0
	jbe	SHORT $LN2@head

; 971  :         {
; 972  :             return &mVec[ 0 ];

	mov	eax, DWORD PTR [ecx]

; 977  :         }
; 978  :     };

	ret	0
$LN2@head:

; 973  :         }
; 974  :         else
; 975  :         {
; 976  :             return NULL;

	xor	eax, eax

; 977  :         }
; 978  :     };

	ret	0
?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::head
_TEXT	ENDS
PUBLIC	?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::tail
; Function compile flags: /Ogtpy
;	COMDAT ?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::tail, COMDAT
; _this$ = ecx

; 983  :         UINT uSize = mVec.size();

	mov	eax, DWORD PTR [ecx+4]

; 984  : 
; 985  :         if( uSize > 0 )

	test	eax, eax
	jbe	SHORT $LN2@tail

; 986  :         {
; 987  :             return &mVec[ uSize - 1 ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8-8]

; 992  :         }
; 993  :     };

	ret	0
$LN2@tail:

; 988  :         }
; 989  :         else
; 990  :         {
; 991  :             return NULL;

	xor	eax, eax

; 992  :         }
; 993  :     };

	ret	0
?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::tail
_TEXT	ENDS
PUBLIC	?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::head
; Function compile flags: /Ogtpy
;	COMDAT ?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::head, COMDAT
; _this$ = ecx

; 997  :         UINT uSize = mVec.size();
; 998  : 
; 999  :         if( uSize > 0 )

	cmp	DWORD PTR [ecx+4], 0
	jbe	SHORT $LN2@head@2

; 1000 :         {
; 1001 :             return &mVec[ 0];

	mov	eax, DWORD PTR [ecx]

; 1006 :         }
; 1007 :     };

	ret	0
$LN2@head@2:

; 1002 :         }
; 1003 :         else
; 1004 :         {
; 1005 :             return NULL;

	xor	eax, eax

; 1006 :         }
; 1007 :     };

	ret	0
?head@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::head
_TEXT	ENDS
PUBLIC	?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::tail
; Function compile flags: /Ogtpy
;	COMDAT ?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::tail, COMDAT
; _this$ = ecx

; 1012 :         UINT uSize = mVec.size();

	mov	eax, DWORD PTR [ecx+4]

; 1013 : 
; 1014 :         if( uSize > 0 )

	test	eax, eax
	jbe	SHORT $LN2@tail@2

; 1015 :         {
; 1016 :             return &mVec[ uSize - 1 ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8-8]

; 1021 :         }
; 1022 :     };

	ret	0
$LN2@tail@2:

; 1017 :         }
; 1018 :         else
; 1019 :         {
; 1020 :             return NULL;

	xor	eax, eax

; 1021 :         }
; 1022 :     };

	ret	0
?tail@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@XZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::tail
_TEXT	ENDS
PUBLIC	??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@	; FAutoArchiveClassContainer<CvPlot>::`vftable'
PUBLIC	??0?$FAutoArchiveClassContainer@VCvPlot@@@@QAE@AAVCvPlot@@@Z ; FAutoArchiveClassContainer<CvPlot>::FAutoArchiveClassContainer<CvPlot>
PUBLIC	??_R4?$FAutoArchiveClassContainer@VCvPlot@@@@6B@ ; FAutoArchiveClassContainer<CvPlot>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$FAutoArchiveClassContainer@VCvPlot@@@@@8 ; FAutoArchiveClassContainer<CvPlot> `RTTI Type Descriptor'
PUBLIC	??_R3?$FAutoArchiveClassContainer@VCvPlot@@@@8	; FAutoArchiveClassContainer<CvPlot>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FAutoArchiveClassContainer@VCvPlot@@@@8	; FAutoArchiveClassContainer<CvPlot>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$FAutoArchiveClassContainer@VCvPlot@@@@8 ; FAutoArchiveClassContainer<CvPlot>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@FAutoArchive@@8			; FAutoArchive::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFAutoArchive@@@8			; FAutoArchive `RTTI Type Descriptor'
PUBLIC	??_R3FAutoArchive@@8				; FAutoArchive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FAutoArchive@@8				; FAutoArchive::`RTTI Base Class Array'
PUBLIC	?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; FAutoArchiveClassContainer<CvPlot>::getVariableName
PUBLIC	?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FAutoArchiveClassContainer<CvPlot>::setVariableName
PUBLIC	?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; FAutoArchiveClassContainer<CvPlot>::debugDump
PUBLIC	?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; FAutoArchiveClassContainer<CvPlot>::stackTraceRemark
EXTRN	??0FAutoArchive@@QAE@XZ:PROC			; FAutoArchive::FAutoArchive
EXTRN	??_E?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z:PROC ; FAutoArchiveClassContainer<CvPlot>::`vector deleting destructor'
;	COMDAT ??_R2FAutoArchive@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchiveclasscontainer.h
rdata$r	SEGMENT
??_R2FAutoArchive@@8 DD FLAT:??_R1A@?0A@EA@FAutoArchive@@8 ; FAutoArchive::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3FAutoArchive@@8
rdata$r	SEGMENT
??_R3FAutoArchive@@8 DD 00H				; FAutoArchive::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2FAutoArchive@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFAutoArchive@@@8
_DATA	SEGMENT
??_R0?AVFAutoArchive@@@8 DD FLAT:??_7type_info@@6B@	; FAutoArchive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFAutoArchive@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FAutoArchive@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FAutoArchive@@8 DD FLAT:??_R0?AVFAutoArchive@@@8 ; FAutoArchive::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FAutoArchive@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$FAutoArchiveClassContainer@VCvPlot@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FAutoArchiveClassContainer@VCvPlot@@@@8 DD FLAT:??_R0?AV?$FAutoArchiveClassContainer@VCvPlot@@@@@8 ; FAutoArchiveClassContainer<CvPlot>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FAutoArchiveClassContainer@VCvPlot@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FAutoArchiveClassContainer@VCvPlot@@@@8
rdata$r	SEGMENT
??_R2?$FAutoArchiveClassContainer@VCvPlot@@@@8 DD FLAT:??_R1A@?0A@EA@?$FAutoArchiveClassContainer@VCvPlot@@@@8 ; FAutoArchiveClassContainer<CvPlot>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FAutoArchive@@8
rdata$r	ENDS
;	COMDAT ??_R3?$FAutoArchiveClassContainer@VCvPlot@@@@8
rdata$r	SEGMENT
??_R3?$FAutoArchiveClassContainer@VCvPlot@@@@8 DD 00H	; FAutoArchiveClassContainer<CvPlot>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$FAutoArchiveClassContainer@VCvPlot@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FAutoArchiveClassContainer@VCvPlot@@@@@8
_DATA	SEGMENT
??_R0?AV?$FAutoArchiveClassContainer@VCvPlot@@@@@8 DD FLAT:??_7type_info@@6B@ ; FAutoArchiveClassContainer<CvPlot> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FAutoArchiveClassContainer@VCvPlot@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$FAutoArchiveClassContainer@VCvPlot@@@@6B@
rdata$r	SEGMENT
??_R4?$FAutoArchiveClassContainer@VCvPlot@@@@6B@ DD 00H	; FAutoArchiveClassContainer<CvPlot>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$FAutoArchiveClassContainer@VCvPlot@@@@@8
	DD	FLAT:??_R3?$FAutoArchiveClassContainer@VCvPlot@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@
CONST	SEGMENT
??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@ DD FLAT:??_R4?$FAutoArchiveClassContainer@VCvPlot@@@@6B@ ; FAutoArchiveClassContainer<CvPlot>::`vftable'
	DD	FLAT:??_E?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z
	DD	FLAT:?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	FLAT:?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	FLAT:?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0?$FAutoArchiveClassContainer@VCvPlot@@@@QAE@AAVCvPlot@@@Z
_TEXT	SEGMENT
_owner$ = 8						; size = 4
??0?$FAutoArchiveClassContainer@VCvPlot@@@@QAE@AAVCvPlot@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::FAutoArchiveClassContainer<CvPlot>, COMDAT
; _this$ = ecx

; 34   : 	{

	push	esi
	mov	esi, ecx
	call	??0FAutoArchive@@QAE@XZ			; FAutoArchive::FAutoArchive
	mov	eax, DWORD PTR _owner$[esp]
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi], OFFSET ??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@

; 35   : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FAutoArchiveClassContainer@VCvPlot@@@@QAE@AAVCvPlot@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::FAutoArchiveClassContainer<CvPlot>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 434  : 		iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 435  : 			{	// construct with null node pointer
; 436  : 			}

	ret	0
??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::head
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::head, COMDAT
; _this$ = ecx

; 968  :         UINT uSize = mVec.size();
; 969  : 
; 970  :         if( uSize > 0 )

	cmp	DWORD PTR [ecx+4], 0
	jbe	SHORT $LN2@head@3

; 971  :         {
; 972  :             return &mVec[ 0 ];

	mov	eax, DWORD PTR [ecx]

; 977  :         }
; 978  :     };

	ret	0
$LN2@head@3:

; 973  :         }
; 974  :         else
; 975  :         {
; 976  :             return NULL;

	xor	eax, eax

; 977  :         }
; 978  :     };

	ret	0
?head@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@XZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::head
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ; std::auto_ptr<ICvUnit1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ PROC ; std::auto_ptr<ICvUnit1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ENDP ; std::auto_ptr<ICvUnit1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP	; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z PROC ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ENDP ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@2:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ; std::auto_ptr<ICvPlot1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ PROC ; std::auto_ptr<ICvPlot1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ENDP ; std::auto_ptr<ICvPlot1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z PROC	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvCity1@@@std@@QAE@PAVICvCity1@@@Z ENDP	; std::auto_ptr<ICvCity1>::auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@3
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@3:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ; std::auto_ptr<ICvCity1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ PROC ; std::auto_ptr<ICvCity1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvCity1@@@std@@QBEPAVICvCity1@@XZ ENDP ; std::auto_ptr<ICvCity1>::get
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z PROC ; FAutoArchiveClassContainer<CvPlot>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1FAutoArchive@@UAE@XZ			; FAutoArchive::~FAutoArchive
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UIDInfo@@$00@@IAE@XZ		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$BaseVector@UIDInfo@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UIDInfo@@$00@@IAE@XZ PROC		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UIDInfo@@$00@@IAE@XZ ENDP		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>
_TEXT	ENDS
PUBLIC	?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::getAt
; Function compile flags: /Ogtpy
;	COMDAT ?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::getAt, COMDAT
; _this$ = ecx

; 881  :         if ( (UINT)iIndex < mVec.size() )

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@getAt@2

; 882  : #endif
; 883  : 	    {
; 884  : 		    return &mVec[ iIndex ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 889  : 	    }
; 890  :     };

	ret	4
$LN2@getAt@2:

; 885  : 	    }
; 886  : 	    else
; 887  : 	    {
; 888  : 		    return NULL;

	xor	eax, eax

; 889  : 	    }
; 890  :     };

	ret	4
?getAt@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::getAt
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@XZ		; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ PROC		; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ ENDP		; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 17					; 00000011H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@SAABQAVCvPlot@@ABQAV3@@Z ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@SAABQAVCvPlot@@ABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@SAABQAVCvPlot@@ABQAV3@@Z PROC ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Kfn, COMDAT

; 45   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 46   : 		}

	ret	0
?_Kfn@?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@SAABQAVCvPlot@@ABQAV3@@Z ENDP ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Kfn
_TEXT	ENDS
PUBLIC	??R?$less@PAVCvPlot@@@std@@QBE_NABQAVCvPlot@@0@Z ; std::less<CvPlot *>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@PAVCvPlot@@@std@@QBE_NABQAVCvPlot@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVCvPlot@@@std@@QBE_NABQAVCvPlot@@0@Z PROC	; std::less<CvPlot *>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@PAVCvPlot@@@std@@QBE_NABQAVCvPlot@@0@Z ENDP	; std::less<CvPlot *>::operator()
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@XZ ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ; CvGlobals::getFlavorTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z PROC ; CvGlobals::getFlavorTypes, COMDAT
; _this$ = ecx

; 812  : 		CvAssert(e > -1); /*CvAssert(e < GC.getNumFlavorTypes())*/;
; 813  : 		return m_paszFlavorTypes[e];

	mov	eax, DWORD PTR _e$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1760]
	lea	eax, DWORD PTR [eax+edx*4]

; 814  : 	}

	ret	4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ENDP ; CvGlobals::getFlavorTypes
_TEXT	ENDS
PUBLIC	?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z ; FFastSmallFixedList<IDInfo,25,1,297,0>::getAt
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::getAt, COMDAT
; _this$ = ecx

; 881  :         if ( (UINT)iIndex < mVec.size() )

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@getAt@3

; 882  : #endif
; 883  : 	    {
; 884  : 		    return &mVec[ iIndex ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 889  : 	    }
; 890  :     };

	ret	4
$LN2@getAt@3:

; 885  : 	    }
; 886  : 	    else
; 887  : 	    {
; 888  : 		    return NULL;

	xor	eax, eax

; 889  : 	    }
; 890  :     };

	ret	4
?getAt@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@H@Z ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::getAt
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ; FStaticVector<IDInfo,50,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,50,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 50					; 00000032H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 50			; 00000032H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,50,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z ; FStaticVector<CvPlot *,1000,1,297,1>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 1000				; 000003e8H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 1000			; 000003e8H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEPAPAVCvPlot@@I@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::Alloc
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z	; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T230750 = -80						; size = 28
$T230749 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T230750[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T230749[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T230750[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T230749[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T230749[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T230749[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T230749[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T230750[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T230749[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ; FStaticVector<IDInfo,25,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 25			; 00000019H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z ; BaseVector<CvPlot *,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z PROC ; BaseVector<CvPlot *,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvPlot@@$00@@IAEXPAPAVCvPlot@@I@Z ENDP ; BaseVector<CvPlot *,1>::Destroy
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ	; std::allocator<CvPlot *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ PROC	; std::allocator<CvPlot *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ ENDP	; std::allocator<CvPlot *>::max_size
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Max
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QBEIXZ ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 76695844				; 04924924H

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@0@Z PROC ; std::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>::pair<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVCvPlot@@D@Z ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVCvPlot@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVCvPlot@@D@Z PROC ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVCvPlot@@D@Z ENDP ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAPAXIIII@Z ; BaseVector<IDInfo,1>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAPAXIIII@Z PROC ; BaseVector<IDInfo,1>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAPAXIIII@Z ENDP ; BaseVector<IDInfo,1>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAXPAX@Z ; BaseVector<IDInfo,1>::FDefaultFastVectorAllocator::FreeAligned
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAXPAX@Z PROC ; BaseVector<IDInfo,1>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@SAXPAX@Z ENDP ; BaseVector<IDInfo,1>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT, COMDAT
; _this$ = ecx

; 1769 : 		return m_iAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT;

	mov	eax, DWORD PTR [ecx+2704]

; 1770 : 	}

	ret	0
?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??_7?$FAutoVariable@DVCvPlot@@@@6B@		; FAutoVariable<char,CvPlot>::`vftable'
PUBLIC	??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z ; FAutoVariable<char,CvPlot>::FAutoVariable<char,CvPlot>
PUBLIC	??_R4?$FAutoVariable@DVCvPlot@@@@6B@		; FAutoVariable<char,CvPlot>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$FAutoVariable@DVCvPlot@@@@@8		; FAutoVariable<char,CvPlot> `RTTI Type Descriptor'
PUBLIC	??_R3?$FAutoVariable@DVCvPlot@@@@8		; FAutoVariable<char,CvPlot>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FAutoVariable@DVCvPlot@@@@8		; FAutoVariable<char,CvPlot>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$FAutoVariable@DVCvPlot@@@@8	; FAutoVariable<char,CvPlot>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@FAutoVariableBase@@8		; FAutoVariableBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFAutoVariableBase@@@8			; FAutoVariableBase `RTTI Type Descriptor'
PUBLIC	??_R3FAutoVariableBase@@8			; FAutoVariableBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FAutoVariableBase@@8			; FAutoVariableBase::`RTTI Base Class Array'
PUBLIC	?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::load
PUBLIC	?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::loadDelta
PUBLIC	?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::save
PUBLIC	?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::saveDelta
PUBLIC	?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ	; FAutoVariable<char,CvPlot>::clearDelta
PUBLIC	?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::compare
PUBLIC	?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ	; FAutoVariable<char,CvPlot>::reset
PUBLIC	?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; FAutoVariable<char,CvPlot>::name
PUBLIC	?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ; FAutoVariable<char,CvPlot>::setStackTraceRemark
PUBLIC	?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z ; FAutoVariable<char,CvPlot>::debugDump
PUBLIC	?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; FAutoVariable<char,CvPlot>::toString
EXTRN	??0FAutoVariableBase@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVFAutoArchive@@_N@Z:PROC ; FAutoVariableBase::FAutoVariableBase
EXTRN	??_E?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z:PROC	; FAutoVariable<char,CvPlot>::`vector deleting destructor'
;	COMDAT ??_R2FAutoVariableBase@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
rdata$r	SEGMENT
??_R2FAutoVariableBase@@8 DD FLAT:??_R1A@?0A@EA@FAutoVariableBase@@8 ; FAutoVariableBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3FAutoVariableBase@@8
rdata$r	SEGMENT
??_R3FAutoVariableBase@@8 DD 00H			; FAutoVariableBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2FAutoVariableBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFAutoVariableBase@@@8
_DATA	SEGMENT
??_R0?AVFAutoVariableBase@@@8 DD FLAT:??_7type_info@@6B@ ; FAutoVariableBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFAutoVariableBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FAutoVariableBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FAutoVariableBase@@8 DD FLAT:??_R0?AVFAutoVariableBase@@@8 ; FAutoVariableBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FAutoVariableBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$FAutoVariable@DVCvPlot@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FAutoVariable@DVCvPlot@@@@8 DD FLAT:??_R0?AV?$FAutoVariable@DVCvPlot@@@@@8 ; FAutoVariable<char,CvPlot>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FAutoVariable@DVCvPlot@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FAutoVariable@DVCvPlot@@@@8
rdata$r	SEGMENT
??_R2?$FAutoVariable@DVCvPlot@@@@8 DD FLAT:??_R1A@?0A@EA@?$FAutoVariable@DVCvPlot@@@@8 ; FAutoVariable<char,CvPlot>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FAutoVariableBase@@8
rdata$r	ENDS
;	COMDAT ??_R3?$FAutoVariable@DVCvPlot@@@@8
rdata$r	SEGMENT
??_R3?$FAutoVariable@DVCvPlot@@@@8 DD 00H		; FAutoVariable<char,CvPlot>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$FAutoVariable@DVCvPlot@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FAutoVariable@DVCvPlot@@@@@8
_DATA	SEGMENT
??_R0?AV?$FAutoVariable@DVCvPlot@@@@@8 DD FLAT:??_7type_info@@6B@ ; FAutoVariable<char,CvPlot> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FAutoVariable@DVCvPlot@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$FAutoVariable@DVCvPlot@@@@6B@
rdata$r	SEGMENT
??_R4?$FAutoVariable@DVCvPlot@@@@6B@ DD 00H		; FAutoVariable<char,CvPlot>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$FAutoVariable@DVCvPlot@@@@@8
	DD	FLAT:??_R3?$FAutoVariable@DVCvPlot@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$FAutoVariable@DVCvPlot@@@@6B@
CONST	SEGMENT
??_7?$FAutoVariable@DVCvPlot@@@@6B@ DD FLAT:??_R4?$FAutoVariable@DVCvPlot@@@@6B@ ; FAutoVariable<char,CvPlot>::`vftable'
	DD	FLAT:??_E?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z
	DD	FLAT:?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
	DD	FLAT:?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z
	DD	FLAT:?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
	DD	FLAT:?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
	DD	FLAT:?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	DD	FLAT:?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
_owner$ = 12						; size = 4
_callStackTracking$ = 16				; size = 1
??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z PROC ; FAutoVariable<char,CvPlot>::FAutoVariable<char,CvPlot>, COMDAT
; _this$ = ecx

; 147  : {

	mov	eax, DWORD PTR _callStackTracking$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _owner$[esp+4]
	push	eax
	mov	esi, ecx
	mov	ecx, DWORD PTR _name$[esp+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	??0FAutoVariableBase@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVFAutoArchive@@_N@Z ; FAutoVariableBase::FAutoVariableBase
	mov	DWORD PTR [esi+8], edi
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7?$FAutoVariable@DVCvPlot@@@@6B@
	mov	BYTE PTR [esi+4], 0

; 148  : }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z ENDP ; FAutoVariable<char,CvPlot>::FAutoVariable<char,CvPlot>
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@DVCvPlot@@@@QBEABDXZ	; FAutoVariable<char,CvPlot>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::get
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$?6W4GreatWorkArtifactClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkArtifactClass@@@Z ; FDataStream::operator<<<enum GreatWorkArtifactClass>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6W4GreatWorkArtifactClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkArtifactClass@@@Z
_TEXT	SEGMENT
$T230921 = 8						; size = 4
_kData$ = 8						; size = 4
??$?6W4GreatWorkArtifactClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkArtifactClass@@@Z PROC ; FDataStream::operator<<<enum GreatWorkArtifactClass>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T230921[esp]
	mov	DWORD PTR $T230921[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6W4GreatWorkArtifactClass@@@FDataStream@@QAEAAV0@ABW4GreatWorkArtifactClass@@@Z ENDP ; FDataStream::operator<<<enum GreatWorkArtifactClass>
_TEXT	ENDS
PUBLIC	??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z ; FDataStream::operator<<<enum GreatWorkType>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z
_TEXT	SEGMENT
$T230925 = 8						; size = 4
_kData$ = 8						; size = 4
??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z PROC ; FDataStream::operator<<<enum GreatWorkType>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T230925[esp]
	mov	DWORD PTR $T230925[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6W4GreatWorkType@@@FDataStream@@QAEAAV0@ABW4GreatWorkType@@@Z ENDP ; FDataStream::operator<<<enum GreatWorkType>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z		; SAFE_DELETE_ARRAY<char>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z PROC			; SAFE_DELETE_ARRAY<char>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@D@@YAXAAPAD@Z ENDP			; SAFE_DELETE_ARRAY<char>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z		; SAFE_DELETE_ARRAY<short>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z PROC			; SAFE_DELETE_ARRAY<short>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@F@@YAXAAPAF@Z ENDP			; SAFE_DELETE_ARRAY<short>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	256					; 00000100H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
PUBLIC	??$?5F@FDataStream@@QAEAAV0@AAF@Z		; FDataStream::operator>><short>
EXTRN	?Read@FDataStream@@IAEXAAF@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5F@FDataStream@@QAEAAV0@AAF@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5F@FDataStream@@QAEAAV0@AAF@Z PROC			; FDataStream::operator>><short>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5F@FDataStream@@QAEAAV0@AAF@Z ENDP			; FDataStream::operator>><short>
_TEXT	ENDS
PUBLIC	??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z ; operator>><char,CvPlot>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z
_TEXT	SEGMENT
_archive$ = 8						; size = 4
_object$ = 12						; size = 4
??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z PROC ; operator>><char,CvPlot>, COMDAT

; 106  : 	object.load(archive);

	mov	ecx, DWORD PTR _object$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	esi, DWORD PTR _archive$[esp]
	push	esi
	call	edx

; 107  : 	return archive;

	mov	eax, esi
	pop	esi

; 108  : }

	ret	0
??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z ENDP ; operator>><char,CvPlot>
_TEXT	ENDS
PUBLIC	??$?5K@FDataStream@@QAEAAV0@AAK@Z		; FDataStream::operator>><unsigned long>
EXTRN	?Read@FDataStream@@IAEXAAK@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5K@FDataStream@@QAEAAV0@AAK@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5K@FDataStream@@QAEAAV0@AAK@Z PROC			; FDataStream::operator>><unsigned long>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5K@FDataStream@@QAEAAV0@AAK@Z ENDP			; FDataStream::operator>><unsigned long>
_TEXT	ENDS
PUBLIC	??$?6F@FDataStream@@QAEAAV0@ABF@Z		; FDataStream::operator<<<short>
EXTRN	?Write@FDataStream@@IAEXABF@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6F@FDataStream@@QAEAAV0@ABF@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6F@FDataStream@@QAEAAV0@ABF@Z PROC			; FDataStream::operator<<<short>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6F@FDataStream@@QAEAAV0@ABF@Z ENDP			; FDataStream::operator<<<short>
_TEXT	ENDS
PUBLIC	??$?6K@FDataStream@@QAEAAV0@ABK@Z		; FDataStream::operator<<<unsigned long>
EXTRN	?Write@FDataStream@@IAEXABK@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6K@FDataStream@@QAEAAV0@ABK@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6K@FDataStream@@QAEAAV0@ABK@Z PROC			; FDataStream::operator<<<unsigned long>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6K@FDataStream@@QAEAAV0@ABK@Z ENDP			; FDataStream::operator<<<unsigned long>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$07@@YAHAAY07DPBDZZ		; sprintf_s<8>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$07@@YAHAAY07DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$07@@YAHAAY07DPBDZZ PROC			; sprintf_s<8>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	8
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$07@@YAHAAY07DPBDZZ ENDP			; sprintf_s<8>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z
_TEXT	SEGMENT
$T230973 = -12						; size = 12
$T230977 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 56					; 00000038H
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T230977[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T230973[esp+16]
	mov	DWORD PTR $T230977[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T230973[esp+16]
	push	ecx
	mov	DWORD PTR $T230973[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$?0PAVCvPlot@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *><CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0PAVCvPlot@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVCvPlot@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *><CvPlot *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0PAVCvPlot@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *><CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T230986 = -12						; size = 12
$T230990 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T230990[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T230986[esp+16]
	mov	DWORD PTR $T230990[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T230986[esp+16]
	push	ecx
	mov	DWORD PTR $T230986[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0PAVCvPlot@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node><CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0PAVCvPlot@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0PAVCvPlot@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node><CvPlot *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0PAVCvPlot@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node><CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *,std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *,std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *,std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z	; operator>><short,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z PROC		; operator>><short,1>, COMDAT

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)
; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 241  : }

	ret	0
??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z ENDP		; operator>><short,1>
_TEXT	ENDS
PUBLIC	??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z	; operator<<<short,1>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z PROC	; operator<<<short,1>, COMDAT

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)
; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	mov	eax, DWORD PTR _readFrom$[esp-4]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 230  : }

	ret	0
??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z ENDP	; operator<<<short,1>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0@Z ; std::_Ptr_cat<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0@Z PROC ; std::_Ptr_cat<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0@Z ENDP ; std::_Ptr_cat<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *>
_TEXT	ENDS
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ$0
__ehfuncinfo$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ	; CvGlobals::getEVENT_MESSAGE_TIME
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ PROC		; CvGlobals::getEVENT_MESSAGE_TIME, COMDAT
; _this$ = ecx

; 5252 : 		return m_iEVENT_MESSAGE_TIME;

	mov	eax, DWORD PTR [ecx+6176]

; 5253 : 	}

	ret	0
?getEVENT_MESSAGE_TIME@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getEVENT_MESSAGE_TIME
_TEXT	ENDS
PUBLIC	?getRECON_VISIBILITY_RANGE@CvGlobals@@QAEHXZ	; CvGlobals::getRECON_VISIBILITY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getRECON_VISIBILITY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getRECON_VISIBILITY_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getRECON_VISIBILITY_RANGE, COMDAT
; _this$ = ecx

; 5268 : 		return m_iRECON_VISIBILITY_RANGE;

	mov	eax, DWORD PTR [ecx+6192]

; 5269 : 	}

	ret	0
?getRECON_VISIBILITY_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getRECON_VISIBILITY_RANGE
_TEXT	ENDS
PUBLIC	?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ	; CvGlobals::getPLOT_VISIBILITY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getPLOT_VISIBILITY_RANGE, COMDAT
; _this$ = ecx

; 5272 : 		return m_iPLOT_VISIBILITY_RANGE;

	mov	eax, DWORD PTR [ecx+6196]

; 5273 : 	}

	ret	0
?getPLOT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getPLOT_VISIBILITY_RANGE
_TEXT	ENDS
PUBLIC	?getUNIT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ	; CvGlobals::getUNIT_VISIBILITY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getUNIT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getUNIT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getUNIT_VISIBILITY_RANGE, COMDAT
; _this$ = ecx

; 5276 : 		return m_iUNIT_VISIBILITY_RANGE;

	mov	eax, DWORD PTR [ecx+6200]

; 5277 : 	}

	ret	0
?getUNIT_VISIBILITY_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getUNIT_VISIBILITY_RANGE
_TEXT	ENDS
PUBLIC	?getMOUNTAIN_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ	; CvGlobals::getMOUNTAIN_SEE_FROM_CHANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getMOUNTAIN_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOUNTAIN_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMOUNTAIN_SEE_FROM_CHANGE, COMDAT
; _this$ = ecx

; 5284 : 		return m_iMOUNTAIN_SEE_FROM_CHANGE;

	mov	eax, DWORD PTR [ecx+6208]

; 5285 : 	}

	ret	0
?getMOUNTAIN_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMOUNTAIN_SEE_FROM_CHANGE
_TEXT	ENDS
PUBLIC	?getMOUNTAIN_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ ; CvGlobals::getMOUNTAIN_SEE_THROUGH_CHANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getMOUNTAIN_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOUNTAIN_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMOUNTAIN_SEE_THROUGH_CHANGE, COMDAT
; _this$ = ecx

; 5288 : 		return m_iMOUNTAIN_SEE_THROUGH_CHANGE;

	mov	eax, DWORD PTR [ecx+6212]

; 5289 : 	}

	ret	0
?getMOUNTAIN_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMOUNTAIN_SEE_THROUGH_CHANGE
_TEXT	ENDS
PUBLIC	?getHILLS_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ	; CvGlobals::getHILLS_SEE_FROM_CHANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getHILLS_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getHILLS_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getHILLS_SEE_FROM_CHANGE, COMDAT
; _this$ = ecx

; 5292 : 		return m_iHILLS_SEE_FROM_CHANGE;

	mov	eax, DWORD PTR [ecx+6216]

; 5293 : 	}

	ret	0
?getHILLS_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getHILLS_SEE_FROM_CHANGE
_TEXT	ENDS
PUBLIC	?getHILLS_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ	; CvGlobals::getHILLS_SEE_THROUGH_CHANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getHILLS_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getHILLS_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getHILLS_SEE_THROUGH_CHANGE, COMDAT
; _this$ = ecx

; 5296 : 		return m_iHILLS_SEE_THROUGH_CHANGE;

	mov	eax, DWORD PTR [ecx+6220]

; 5297 : 	}

	ret	0
?getHILLS_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getHILLS_SEE_THROUGH_CHANGE
_TEXT	ENDS
PUBLIC	?getSEAWATER_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ	; CvGlobals::getSEAWATER_SEE_FROM_CHANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getSEAWATER_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSEAWATER_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSEAWATER_SEE_FROM_CHANGE, COMDAT
; _this$ = ecx

; 5300 : 		return m_iSEAWATER_SEE_FROM_CHANGE;

	mov	eax, DWORD PTR [ecx+6224]

; 5301 : 	}

	ret	0
?getSEAWATER_SEE_FROM_CHANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSEAWATER_SEE_FROM_CHANGE
_TEXT	ENDS
PUBLIC	?getSEAWATER_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ ; CvGlobals::getSEAWATER_SEE_THROUGH_CHANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getSEAWATER_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSEAWATER_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSEAWATER_SEE_THROUGH_CHANGE, COMDAT
; _this$ = ecx

; 5304 : 		return m_iSEAWATER_SEE_THROUGH_CHANGE;

	mov	eax, DWORD PTR [ecx+6228]

; 5305 : 	}

	ret	0
?getSEAWATER_SEE_THROUGH_CHANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSEAWATER_SEE_THROUGH_CHANGE
_TEXT	ENDS
PUBLIC	?getOWNERSHIP_SCORE_DURATION_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getOWNERSHIP_SCORE_DURATION_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getOWNERSHIP_SCORE_DURATION_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getOWNERSHIP_SCORE_DURATION_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getOWNERSHIP_SCORE_DURATION_THRESHOLD, COMDAT
; _this$ = ecx

; 5328 : 		return m_iOWNERSHIP_SCORE_DURATION_THRESHOLD;

	mov	eax, DWORD PTR [ecx+6252]

; 5329 : 	}

	ret	0
?getOWNERSHIP_SCORE_DURATION_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getOWNERSHIP_SCORE_DURATION_THRESHOLD
_TEXT	ENDS
PUBLIC	?getFOOD_CONSUMPTION_PER_POPULATION@CvGlobals@@QAEHXZ ; CvGlobals::getFOOD_CONSUMPTION_PER_POPULATION
; Function compile flags: /Ogtpy
;	COMDAT ?getFOOD_CONSUMPTION_PER_POPULATION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFOOD_CONSUMPTION_PER_POPULATION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getFOOD_CONSUMPTION_PER_POPULATION, COMDAT
; _this$ = ecx

; 5404 : 		return m_iFOOD_CONSUMPTION_PER_POPULATION;

	mov	eax, DWORD PTR [ecx+6328]

; 5405 : 	}

	ret	0
?getFOOD_CONSUMPTION_PER_POPULATION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getFOOD_CONSUMPTION_PER_POPULATION
_TEXT	ENDS
PUBLIC	?getEXTRA_YIELD@CvGlobals@@QAEHXZ		; CvGlobals::getEXTRA_YIELD
; Function compile flags: /Ogtpy
;	COMDAT ?getEXTRA_YIELD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getEXTRA_YIELD@CvGlobals@@QAEHXZ PROC			; CvGlobals::getEXTRA_YIELD, COMDAT
; _this$ = ecx

; 5684 : 		return m_iEXTRA_YIELD;

	mov	eax, DWORD PTR [ecx+6608]

; 5685 : 	}

	ret	0
?getEXTRA_YIELD@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getEXTRA_YIELD
_TEXT	ENDS
PUBLIC	?getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT, COMDAT
; _this$ = ecx

; 5780 : 		return m_iDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT;

	mov	eax, DWORD PTR [ecx+6704]

; 5781 : 	}

	ret	0
?getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT
_TEXT	ENDS
PUBLIC	?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ	; CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN
; Function compile flags: /Ogtpy
;	COMDAT ?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN, COMDAT
; _this$ = ecx

; 5952 : 		return m_iMIN_WATER_SIZE_FOR_OCEAN;

	mov	eax, DWORD PTR [ecx+6876]

; 5953 : 	}

	ret	0
?getMIN_WATER_SIZE_FOR_OCEAN@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN
_TEXT	ENDS
PUBLIC	?getWATER_POTENTIAL_CITY_WORK_FOR_AREA@CvGlobals@@QAEHXZ ; CvGlobals::getWATER_POTENTIAL_CITY_WORK_FOR_AREA
; Function compile flags: /Ogtpy
;	COMDAT ?getWATER_POTENTIAL_CITY_WORK_FOR_AREA@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getWATER_POTENTIAL_CITY_WORK_FOR_AREA@CvGlobals@@QAEHXZ PROC ; CvGlobals::getWATER_POTENTIAL_CITY_WORK_FOR_AREA, COMDAT
; _this$ = ecx

; 5960 : 		return m_iWATER_POTENTIAL_CITY_WORK_FOR_AREA;

	mov	eax, DWORD PTR [ecx+6884]

; 5961 : 	}

	ret	0
?getWATER_POTENTIAL_CITY_WORK_FOR_AREA@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getWATER_POTENTIAL_CITY_WORK_FOR_AREA
_TEXT	ENDS
PUBLIC	?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ		; CvGlobals::getPLOT_UNIT_LIMIT
; Function compile flags: /Ogtpy
;	COMDAT ?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPLOT_UNIT_LIMIT, COMDAT
; _this$ = ecx

; 6485 : 		return m_iPLOT_UNIT_LIMIT;

	mov	eax, DWORD PTR [ecx+7356]

; 6486 : 	}

	ret	0
?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPLOT_UNIT_LIMIT
_TEXT	ENDS
PUBLIC	?getFLAT_LAND_EXTRA_DEFENSE@CvGlobals@@QAEHXZ	; CvGlobals::getFLAT_LAND_EXTRA_DEFENSE
; Function compile flags: /Ogtpy
;	COMDAT ?getFLAT_LAND_EXTRA_DEFENSE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getFLAT_LAND_EXTRA_DEFENSE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getFLAT_LAND_EXTRA_DEFENSE, COMDAT
; _this$ = ecx

; 6509 : 		return m_iFLAT_LAND_EXTRA_DEFENSE;

	mov	eax, DWORD PTR [ecx+7380]

; 6510 : 	}

	ret	0
?getFLAT_LAND_EXTRA_DEFENSE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getFLAT_LAND_EXTRA_DEFENSE
_TEXT	ENDS
PUBLIC	?getHILLS_EXTRA_DEFENSE@CvGlobals@@QAEHXZ	; CvGlobals::getHILLS_EXTRA_DEFENSE
; Function compile flags: /Ogtpy
;	COMDAT ?getHILLS_EXTRA_DEFENSE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getHILLS_EXTRA_DEFENSE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getHILLS_EXTRA_DEFENSE, COMDAT
; _this$ = ecx

; 6513 : 		return m_iHILLS_EXTRA_DEFENSE;

	mov	eax, DWORD PTR [ecx+7384]

; 6514 : 	}

	ret	0
?getHILLS_EXTRA_DEFENSE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getHILLS_EXTRA_DEFENSE
_TEXT	ENDS
PUBLIC	?getMAX_CITY_DIST_HIGHWATER_MARK@CvGlobals@@QAEHXZ ; CvGlobals::getMAX_CITY_DIST_HIGHWATER_MARK
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_CITY_DIST_HIGHWATER_MARK@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_CITY_DIST_HIGHWATER_MARK@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMAX_CITY_DIST_HIGHWATER_MARK, COMDAT
; _this$ = ecx

; 6933 : 		return m_iMAX_CITY_DIST_HIGHWATER_MARK;

	mov	eax, DWORD PTR [ecx+7804]

; 6934 : 	}

	ret	0
?getMAX_CITY_DIST_HIGHWATER_MARK@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMAX_CITY_DIST_HIGHWATER_MARK
_TEXT	ENDS
PUBLIC	?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ	; CvGlobals::getPOST_COMBAT_TEXT_DELAY
; Function compile flags: /Ogtpy
;	COMDAT ?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ PROC	; CvGlobals::getPOST_COMBAT_TEXT_DELAY, COMDAT
; _this$ = ecx

; 7052 : 		return m_fPOST_COMBAT_TEXT_DELAY;

	fld	DWORD PTR [ecx+8040]

; 7053 : 	}

	ret	0
?getPOST_COMBAT_TEXT_DELAY@CvGlobals@@QAEMXZ ENDP	; CvGlobals::getPOST_COMBAT_TEXT_DELAY
_TEXT	ENDS
PUBLIC	?getLAND_TERRAIN@CvGlobals@@QAEHXZ		; CvGlobals::getLAND_TERRAIN
; Function compile flags: /Ogtpy
;	COMDAT ?getLAND_TERRAIN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getLAND_TERRAIN@CvGlobals@@QAEHXZ PROC			; CvGlobals::getLAND_TERRAIN, COMDAT
; _this$ = ecx

; 7171 : 		return m_iLAND_TERRAIN;

	mov	eax, DWORD PTR [ecx+8388]

; 7172 : 	}

	ret	0
?getLAND_TERRAIN@CvGlobals@@QAEHXZ ENDP			; CvGlobals::getLAND_TERRAIN
_TEXT	ENDS
PUBLIC	?getDEEP_WATER_TERRAIN@CvGlobals@@QAEHXZ	; CvGlobals::getDEEP_WATER_TERRAIN
; Function compile flags: /Ogtpy
;	COMDAT ?getDEEP_WATER_TERRAIN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getDEEP_WATER_TERRAIN@CvGlobals@@QAEHXZ PROC		; CvGlobals::getDEEP_WATER_TERRAIN, COMDAT
; _this$ = ecx

; 7175 : 		return m_iDEEP_WATER_TERRAIN;

	mov	eax, DWORD PTR [ecx+8392]

; 7176 : 	}

	ret	0
?getDEEP_WATER_TERRAIN@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getDEEP_WATER_TERRAIN
_TEXT	ENDS
PUBLIC	?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ	; CvGlobals::getSHALLOW_WATER_TERRAIN
; Function compile flags: /Ogtpy
;	COMDAT ?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSHALLOW_WATER_TERRAIN, COMDAT
; _this$ = ecx

; 7179 : 		return m_iSHALLOW_WATER_TERRAIN;

	mov	eax, DWORD PTR [ecx+8396]

; 7180 : 	}

	ret	0
?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSHALLOW_WATER_TERRAIN
_TEXT	ENDS
PUBLIC	?getINITIAL_CITY_ROUTE_TYPE@CvGlobals@@QAEHXZ	; CvGlobals::getINITIAL_CITY_ROUTE_TYPE
; Function compile flags: /Ogtpy
;	COMDAT ?getINITIAL_CITY_ROUTE_TYPE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINITIAL_CITY_ROUTE_TYPE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getINITIAL_CITY_ROUTE_TYPE, COMDAT
; _this$ = ecx

; 7231 : 		return m_iINITIAL_CITY_ROUTE_TYPE;

	mov	eax, DWORD PTR [ecx+8448]

; 7232 : 	}

	ret	0
?getINITIAL_CITY_ROUTE_TYPE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getINITIAL_CITY_ROUTE_TYPE
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT, COMDAT
; _this$ = ecx

; 7355 : 		return m_iBARBARIAN_CAMP_IMPROVEMENT;

	mov	eax, DWORD PTR [ecx+8548]

; 7356 : 	}

	ret	0
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
_TEXT	ENDS
PUBLIC	?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getESPIONAGE_SURVEILLANCE_SIGHT_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getESPIONAGE_SURVEILLANCE_SIGHT_RANGE, COMDAT
; _this$ = ecx

; 7447 : 		return m_iESPIONAGE_SURVEILLANCE_SIGHT_RANGE;

	mov	eax, DWORD PTR [ecx+7948]

; 7448 : 	}

	ret	0
?getESPIONAGE_SURVEILLANCE_SIGHT_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getESPIONAGE_SURVEILLANCE_SIGHT_RANGE
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?GetID@CvArea@@QBEHXZ				; CvArea::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
;	COMDAT ?GetID@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvArea@@QBEHXZ PROC				; CvArea::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvArea@@QBEHXZ ENDP				; CvArea::GetID
_TEXT	ENDS
PUBLIC	??0CvArchaeologyData@@QAE@XZ			; CvArchaeologyData::CvArchaeologyData
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ??0CvArchaeologyData@@QAE@XZ
_TEXT	SEGMENT
??0CvArchaeologyData@@QAE@XZ PROC			; CvArchaeologyData::CvArchaeologyData, COMDAT
; _this$ = ecx

; 70   : 	{}

	mov	eax, ecx
	or	ecx, -1
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	ret	0
??0CvArchaeologyData@@QAE@XZ ENDP			; CvArchaeologyData::CvArchaeologyData
_TEXT	ENDS
PUBLIC	?Reset@CvArchaeologyData@@QAEXXZ		; CvArchaeologyData::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvArchaeologyData@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvArchaeologyData@@QAEXXZ PROC			; CvArchaeologyData::Reset, COMDAT
; _this$ = ecx

; 74   : 		m_eArtifactType = NO_GREAT_WORK_ARTIFACT_CLASS;
; 75   : 		m_eEra = NO_ERA;

	or	eax, -1
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], eax

; 76   : 		m_ePlayer1 = NO_PLAYER;

	mov	DWORD PTR [ecx+8], eax

; 77   : 		m_ePlayer2 = NO_PLAYER;

	mov	DWORD PTR [ecx+12], eax

; 78   : 		m_eWork = NO_GREAT_WORK;

	mov	DWORD PTR [ecx+16], eax

; 79   : 	}

	ret	0
?Reset@CvArchaeologyData@@QAEXXZ ENDP			; CvArchaeologyData::Reset
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getLandmass@CvPlot@@QBEHXZ			; CvPlot::getLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?getLandmass@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getLandmass@CvPlot@@QBEHXZ PROC			; CvPlot::getLandmass, COMDAT
; _this$ = ecx

; 331  : 		return m_iLandmass;

	mov	eax, DWORD PTR [ecx+360]

; 332  : 	}

	ret	0
?getLandmass@CvPlot@@QBEHXZ ENDP			; CvPlot::getLandmass
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ	; CvPlot::getPlotType
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ
_TEXT	SEGMENT
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ PROC		; CvPlot::getPlotType, COMDAT
; _this$ = ecx

; 405  : 		return (PlotTypes)m_ePlotType;

	movsx	eax, BYTE PTR [ecx+5]

; 406  : 	}

	ret	0
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ENDP		; CvPlot::getPlotType
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isRiver@CvPlot@@QBE_NXZ			; CvPlot::isRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRiver@CvPlot@@QBE_NXZ PROC				; CvPlot::isRiver, COMDAT
; _this$ = ecx

; 426  : 		return m_iRiverCrossingCount > 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+457], al
	setg	al

; 427  : 	}

	ret	0
?isRiver@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRiver
_TEXT	ENDS
PUBLIC	?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ	; CvPlot::getTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ
_TEXT	SEGMENT
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ PROC	; CvPlot::getTerrainType, COMDAT
; _this$ = ecx

; 431  : 		return (TerrainTypes)m_eTerrainType;

	movsx	eax, BYTE PTR [ecx+6]

; 432  : 	}

	ret	0
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ ENDP	; CvPlot::getTerrainType
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?getScratchPad@CvPlot@@QBEHXZ			; CvPlot::getScratchPad
; Function compile flags: /Ogtpy
;	COMDAT ?getScratchPad@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getScratchPad@CvPlot@@QBEHXZ PROC			; CvPlot::getScratchPad, COMDAT
; _this$ = ecx

; 703  : 		return m_iScratchPad;

	mov	eax, DWORD PTR [ecx+364]

; 704  : 	}

	ret	0
?getScratchPad@CvPlot@@QBEHXZ ENDP			; CvPlot::getScratchPad
_TEXT	ENDS
PUBLIC	?setScratchPad@CvPlot@@QAEXH@Z			; CvPlot::setScratchPad
; Function compile flags: /Ogtpy
;	COMDAT ?setScratchPad@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setScratchPad@CvPlot@@QAEXH@Z PROC			; CvPlot::setScratchPad, COMDAT
; _this$ = ecx

; 707  : 		m_iScratchPad = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+364], eax

; 708  : 	}

	ret	4
?setScratchPad@CvPlot@@QAEXH@Z ENDP			; CvPlot::setScratchPad
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?ToggleBit@PlotBoolField@CvPlot@@QAEXI@Z	; CvPlot::PlotBoolField::ToggleBit
; Function compile flags: /Ogtpy
;	COMDAT ?ToggleBit@PlotBoolField@CvPlot@@QAEXI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?ToggleBit@PlotBoolField@CvPlot@@QAEXI@Z PROC		; CvPlot::PlotBoolField::ToggleBit, COMDAT
; _this$ = ecx

; 782  : 		{

	mov	edx, ecx

; 783  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 784  : 			m_dwBits[uiOffset] ^= 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	xor	DWORD PTR [edx+eax*4], esi
	pop	esi

; 785  : 		}

	ret	4
?ToggleBit@PlotBoolField@CvPlot@@QAEXI@Z ENDP		; CvPlot::PlotBoolField::ToggleBit
_TEXT	ENDS
PUBLIC	?ClearAll@PlotBoolField@CvPlot@@QAEXXZ		; CvPlot::PlotBoolField::ClearAll
; Function compile flags: /Ogtpy
;	COMDAT ?ClearAll@PlotBoolField@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?ClearAll@PlotBoolField@CvPlot@@QAEXXZ PROC		; CvPlot::PlotBoolField::ClearAll, COMDAT
; _this$ = ecx

; 788  : 			for(uint i = 0; i <eCount; ++i)
; 789  : 			{
; 790  : 				m_dwBits[i] = 0;

	xor	eax, eax
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax

; 791  : 			}
; 792  : 		}

	ret	0
?ClearAll@PlotBoolField@CvPlot@@QAEXXZ ENDP		; CvPlot::PlotBoolField::ClearAll
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotManager@CvMap@@QAEAAVCvPlotManager@@XZ	; CvMap::plotManager
; Function compile flags: /Ogtpy
;	COMDAT ?plotManager@CvMap@@QAEAAVCvPlotManager@@XZ
_TEXT	SEGMENT
?plotManager@CvMap@@QAEAAVCvPlotManager@@XZ PROC	; CvMap::plotManager, COMDAT
; _this$ = ecx

; 295  : 	CvPlotManager& plotManager() { return m_kPlotManager; }

	lea	eax, DWORD PTR [ecx+4184]
	ret	0
?plotManager@CvMap@@QAEAAVCvPlotManager@@XZ ENDP	; CvMap::plotManager
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?isAlive@CvTeam@@QBE_NXZ			; CvTeam::isAlive
; Function compile flags: /Ogtpy
;	COMDAT ?isAlive@CvTeam@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvTeam@@QBE_NXZ PROC				; CvTeam::isAlive, COMDAT
; _this$ = ecx

; 131  : 		return m_iAliveCount > 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	setg	al

; 132  : 	}

	ret	0
?isAlive@CvTeam@@QBE_NXZ ENDP				; CvTeam::isAlive
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTileBonusFaith@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetGoldenAgeTileBonusFaith
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetGoldenAgeTileBonusFaith@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTileBonusFaith@CvPlayerTraits@@QBEHXZ PROC	; CvPlayerTraits::GetGoldenAgeTileBonusFaith, COMDAT
; _this$ = ecx

; 516  : 		return m_iGoldenAgeTileBonusFaith;

	mov	eax, DWORD PTR [ecx+132]

; 517  : 	}

	ret	0
?GetGoldenAgeTileBonusFaith@CvPlayerTraits@@QBEHXZ ENDP	; CvPlayerTraits::GetGoldenAgeTileBonusFaith
_TEXT	ENDS
PUBLIC	?GetNaturalWonderFirstFinderGold@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetNaturalWonderFirstFinderGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderFirstFinderGold@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetNaturalWonderFirstFinderGold@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetNaturalWonderFirstFinderGold, COMDAT
; _this$ = ecx

; 591  : 		return m_iNaturalWonderFirstFinderGold;

	mov	eax, DWORD PTR [ecx+204]

; 592  : 	};

	ret	0
?GetNaturalWonderFirstFinderGold@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetNaturalWonderFirstFinderGold
_TEXT	ENDS
PUBLIC	?GetNaturalWonderSubsequentFinderGold@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetNaturalWonderSubsequentFinderGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderSubsequentFinderGold@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetNaturalWonderSubsequentFinderGold@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetNaturalWonderSubsequentFinderGold, COMDAT
; _this$ = ecx

; 595  : 		return m_iNaturalWonderSubsequentFinderGold;

	mov	eax, DWORD PTR [ecx+208]

; 596  : 	};

	ret	0
?GetNaturalWonderSubsequentFinderGold@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetNaturalWonderSubsequentFinderGold
_TEXT	ENDS
PUBLIC	?GetNaturalWonderYieldModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetNaturalWonderYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNaturalWonderYieldModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetNaturalWonderYieldModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetNaturalWonderYieldModifier, COMDAT
; _this$ = ecx

; 599  : 		return m_iNaturalWonderYieldModifier;

	mov	eax, DWORD PTR [ecx+212]

; 600  : 	};

	ret	0
?GetNaturalWonderYieldModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetNaturalWonderYieldModifier
_TEXT	ENDS
PUBLIC	?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
; Function compile flags: /Ogtpy
;	COMDAT ?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad, COMDAT
; _this$ = ecx

; 716  : 		return m_bMoveFriendlyWoodsAsRoad;

	mov	al, BYTE PTR [ecx+325]

; 717  : 	};

	ret	0
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
_TEXT	ENDS
PUBLIC	?IsNoHillsImprovementMaintenance@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsNoHillsImprovementMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoHillsImprovementMaintenance@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsNoHillsImprovementMaintenance@CvPlayerTraits@@QBE_NXZ PROC ; CvPlayerTraits::IsNoHillsImprovementMaintenance, COMDAT
; _this$ = ecx

; 736  : 		return m_bNoHillsImprovementMaintenance;

	mov	al, BYTE PTR [ecx+330]

; 737  : 	};

	ret	0
?IsNoHillsImprovementMaintenance@CvPlayerTraits@@QBE_NXZ ENDP ; CvPlayerTraits::IsNoHillsImprovementMaintenance
_TEXT	ENDS
PUBLIC	?GetYieldChangeStrategicResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ; CvPlayerTraits::GetYieldChangeStrategicResources
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeStrategicResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetYieldChangeStrategicResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z PROC ; CvPlayerTraits::GetYieldChangeStrategicResources, COMDAT
; _this$ = ecx

; 833  : 		return m_iYieldChangeStrategicResources[(int)eYield];

	mov	eax, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+424]

; 834  : 	};

	ret	4
?GetYieldChangeStrategicResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetYieldChangeStrategicResources
_TEXT	ENDS
PUBLIC	?GetYieldChangeLuxuryResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ; CvPlayerTraits::GetYieldChangeLuxuryResources
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeLuxuryResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetYieldChangeLuxuryResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z PROC ; CvPlayerTraits::GetYieldChangeLuxuryResources, COMDAT
; _this$ = ecx

; 838  : 		return m_iYieldChangeLuxuryResources[(int)eYield];

	mov	eax, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+448]

; 839  : 	};

	ret	4
?GetYieldChangeLuxuryResources@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetYieldChangeLuxuryResources
_TEXT	ENDS
PUBLIC	?GetYieldChangeNaturalWonder@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ; CvPlayerTraits::GetYieldChangeNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeNaturalWonder@CvPlayerTraits@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetYieldChangeNaturalWonder@CvPlayerTraits@@QBEHW4YieldTypes@@@Z PROC ; CvPlayerTraits::GetYieldChangeNaturalWonder, COMDAT
; _this$ = ecx

; 843  : 		return m_iYieldChangeNaturalWonder[(int)eYield];

	mov	eax, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+472]

; 844  : 	};

	ret	4
?GetYieldChangeNaturalWonder@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetYieldChangeNaturalWonder
_TEXT	ENDS
PUBLIC	?GetStrategicResourceQuantityModifier@CvPlayerTraits@@QBEHW4TerrainTypes@@@Z ; CvPlayerTraits::GetStrategicResourceQuantityModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetStrategicResourceQuantityModifier@CvPlayerTraits@@QBEHW4TerrainTypes@@@Z
_TEXT	SEGMENT
_eTerrain$ = 8						; size = 4
?GetStrategicResourceQuantityModifier@CvPlayerTraits@@QBEHW4TerrainTypes@@@Z PROC ; CvPlayerTraits::GetStrategicResourceQuantityModifier, COMDAT
; _this$ = ecx

; 865  : 		return m_iStrategicResourceQuantityModifier[(int)eTerrain];

	mov	eax, DWORD PTR _eTerrain$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+568]

; 866  : 	};

	ret	4
?GetStrategicResourceQuantityModifier@CvPlayerTraits@@QBEHW4TerrainTypes@@@Z ENDP ; CvPlayerTraits::GetStrategicResourceQuantityModifier
_TEXT	ENDS
PUBLIC	?ForceReset@CvAStar@@QAEXXZ			; CvAStar::ForceReset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?ForceReset@CvAStar@@QAEXXZ
_TEXT	SEGMENT
?ForceReset@CvAStar@@QAEXXZ PROC			; CvAStar::ForceReset, COMDAT
; _this$ = ecx

; 178  : 		m_bForceReset = true;

	mov	BYTE PTR [ecx+78], 1

; 179  : 	}

	ret	0
?ForceReset@CvAStar@@QAEXXZ ENDP			; CvAStar::ForceReset
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ ; BaseVector<IDInfo,1>::begin
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?begin@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ PROC	; BaseVector<IDInfo,1>::begin, COMDAT
; _this$ = ecx

; 201  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 202  :     };

	ret	0
?begin@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ ENDP	; BaseVector<IDInfo,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ ; BaseVector<IDInfo,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ PROC	; BaseVector<IDInfo,1>::end, COMDAT
; _this$ = ecx

; 204  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 205  :     };

	ret	0
?end@?$BaseVector@UIDInfo@@$00@@QBEPBUIDInfo@@XZ ENDP	; BaseVector<IDInfo,1>::end
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 17					; 00000011H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z PROC ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn, COMDAT

; 45   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 46   : 		}

	ret	0
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ENDP ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
_TEXT	ENDS
PUBLIC	??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ; std::less<FAutoVariableBase *>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z PROC ; std::less<FAutoVariableBase *>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ENDP ; std::less<FAutoVariableBase *>::operator()
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??R?$less@I@std@@QBE_NABI0@Z			; std::less<unsigned int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@I@std@@QBE_NABI0@Z PROC			; std::less<unsigned int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@I@std@@QBE_NABI0@Z ENDP			; std::less<unsigned int>::operator()
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ; FStaticVector<IDInfo,8,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 8
	jbe	SHORT $LN2@Alloc@4

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@4:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 8
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAE@PAPAVFAutoVariableBase@@@Z ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAE@PAPAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAE@PAPAVFAutoVariableBase@@@Z PROC ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAE@PAPAVFAutoVariableBase@@@Z ENDP ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 51   : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ; std::allocator<FAutoVariableBase *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ PROC ; std::allocator<FAutoVariableBase *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ENDP ; std::allocator<FAutoVariableBase *>::max_size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z ; BaseVector<IDInfo,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z PROC ; BaseVector<IDInfo,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z ENDP ; BaseVector<IDInfo,1>::Destroy
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 45					; 0000002dH

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::size
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
; Function compile flags: /Ogtpy
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Max@2
	npad	3
$LL2@Max@2:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Max@2
$LN1@Max@2:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color
; Function compile flags: /Ogtpy
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 44					; 0000002cH

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+45], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+45], 0
	jne	SHORT $LN1@Max@3
	npad	3
$LL2@Max@3:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+45], 0
	je	SHORT $LL2@Max@3
$LN1@Max@3:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+45], 0
	jne	SHORT $LN1@Min@2
	npad	4
$LL2@Min@2:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+45], 0
	je	SHORT $LL2@Min@2
$LN1@Min@2:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 134217727				; 07ffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ		; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
EXTRN	??1FAutoVariableBase@@UAE@XZ:PROC		; FAutoVariableBase::~FAutoVariableBase
EXTRN	?remove@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z:PROC ; FAutoArchive::remove
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ$0
__ehfuncinfo$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ PROC		; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>, COMDAT
; _this$ = ecx

; 168  : {

	push	-1
	push	__ehhandler$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7?$FAutoVariable@DVCvPlot@@@@6B@

; 169  : 	m_owner.remove(*this);

	mov	ecx, DWORD PTR [esi+8]
	push	esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	?remove@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ; FAutoArchive::remove

; 170  : }

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1FAutoVariableBase@@UAE@XZ		; FAutoVariableBase::~FAutoVariableBase
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FAutoVariableBase@@UAE@XZ		; FAutoVariableBase::~FAutoVariableBase
__ehhandler$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ ENDP		; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::loadDelta, COMDAT
; _this$ = ecx

; 296  : 	load(loadFrom);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	jmp	eax
?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::loadDelta
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::saveDelta, COMDAT
; _this$ = ecx

; 320  : 	save(saveTo);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	jmp	eax
?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::saveDelta
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
_TEXT	SEGMENT
?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ PROC	; FAutoVariable<char,CvPlot>::clearDelta, COMDAT
; _this$ = ecx

; 304  : 	// nothing to do for this type
; 305  : }

	ret	0
?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ENDP	; FAutoVariable<char,CvPlot>::clearDelta
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
_TEXT	SEGMENT
?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ PROC		; FAutoVariable<char,CvPlot>::reset, COMDAT
; _this$ = ecx

; 312  : 	m_value = ObjectType();

	mov	BYTE PTR [ecx+4], 0

; 313  : }

	ret	0
?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ENDP		; FAutoVariable<char,CvPlot>::reset
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; FAutoVariable<char,CvPlot>::name, COMDAT
; _this$ = ecx

; 349  : {

	mov	eax, ecx

; 350  : 	// dereferenced because if this variable exists, it MUST be in the map
; 351  : 	// (or it could never have been constructed in the first place)
; 352  : 	return *(m_owner.getVariableName(*this));

	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 353  : }

	ret	0
?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; FAutoVariable<char,CvPlot>::name
_TEXT	ENDS
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?debugDump@FAutoVariableBase@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z:PROC ; FAutoVariableBase::debugDump
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$5
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
_TEXT	SEGMENT
$T231643 = -156						; size = 4
$T231640 = -152						; size = 28
$T231639 = -124						; size = 28
$T231638 = -96						; size = 28
$T231641 = -68						; size = 28
$T231637 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_callStacks$ = 12					; size = 4
?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z PROC ; FAutoVariable<char,CvPlot>::debugDump, COMDAT
; _this$ = ecx

; 358  : {

	push	-1
	push	__ehhandler$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 144				; 00000090H

; 359  : 	std::string result = FAutoVariableBase::debugDump(callStacks);

	mov	eax, DWORD PTR _callStacks$[esp+152]
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	ebx, ebx
	mov	DWORD PTR $T231643[esp+172], ebx
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+168]
	push	eax
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[esp+188], ebx
	call	?debugDump@FAutoVariableBase@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z ; FAutoVariableBase::debugDump

; 360  : 	result += std::string("\n") + m_owner.debugDump(*this) + std::string("\n");
; 361  : #if !defined(FINAL_RELEASE)
; 362  : 	result += std::string("local value=") + FSerialization::toString(m_value) + "\n";
; 363  : 	result += std::string("remote value=") + FSerialization::toString(m_remoteValue) + "\n";
; 364  : #endif
; 365  : 	return result;

	push	OFFSET $SG207740
	lea	ecx, DWORD PTR $T231637[esp+176]
	mov	DWORD PTR __$EHRec$[esp+184], ebx
	mov	DWORD PTR $T231643[esp+176], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ebp, eax
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+12]
	push	esi
	lea	eax, DWORD PTR $T231638[esp+176]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+188], 1
	call	edx
	mov	esi, eax
	push	OFFSET $SG207741
	lea	ecx, DWORD PTR $T231639[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	esi
	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	eax
	lea	eax, DWORD PTR $T231640[esp+180]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+192], 3
	call	esi
	push	ebp
	push	eax
	lea	ecx, DWORD PTR $T231641[esp+192]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+204], 4
	call	esi
	add	esp, 24					; 00000018H
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+184], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T231641[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T231640[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T231639[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T231638[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T231637[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 366  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+172]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 156				; 0000009cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$0:
	mov	eax, DWORD PTR $T231643[ebp]
	and	eax, 1
	je	$LN4@debugDump
	and	DWORD PTR $T231643[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@debugDump:
	ret	0
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$1:
	lea	ecx, DWORD PTR $T231637[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$2:
	lea	ecx, DWORD PTR $T231638[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$3:
	lea	ecx, DWORD PTR $T231639[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$4:
	lea	ecx, DWORD PTR $T231640[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$5:
	lea	ecx, DWORD PTR $T231641[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z:
	mov	eax, OFFSET __ehfuncinfo$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z ENDP ; FAutoVariable<char,CvPlot>::debugDump
EXTRN	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABD@Z:PROC ; FSerialization::toString
; Function compile flags: /Ogtpy
;	COMDAT ?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T231660 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; FAutoVariable<char,CvPlot>::toString, COMDAT
; _this$ = ecx

; 327  : {

	push	ecx
	push	esi

; 328  : 	return FSerialization::toString(m_value);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 4
	push	ecx
	push	esi
	mov	DWORD PTR $T231660[esp+16], 0
	call	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABD@Z ; FSerialization::toString
	add	esp, 8
	mov	eax, esi
	pop	esi

; 329  : }

	pop	ecx
	ret	4
?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; FAutoVariable<char,CvPlot>::toString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
_TEXT	SEGMENT
?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ PROC ; FAutoVariable<char,CvPlot>::setStackTraceRemark, COMDAT
; _this$ = ecx

; 373  : #ifndef FINAL_RELEASE
; 374  : 	m_callStackRemark = m_owner.stackTraceRemark(*this);
; 375  : #endif
; 376  : }

	ret	0
?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ENDP ; FAutoVariable<char,CvPlot>::setStackTraceRemark
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T231668 = -12						; size = 12
$T231672 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231672[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231668[esp+16]
	mov	DWORD PTR $T231672[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231668[esp+16]
	push	ecx
	mov	DWORD PTR $T231668[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T231678 = -12						; size = 12
$T231682 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	shl	edx, 4
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231682[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231678[esp+16]
	mov	DWORD PTR $T231682[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231678[esp+16]
	push	ecx
	mov	DWORD PTR $T231678[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z PROC		; FAutoVariable<char,CvPlot>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z ENDP		; FAutoVariable<char,CvPlot>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@UIDInfo@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ PROC		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ ENDP		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$?5D@FDataStream@@QAEAAV0@AAD@Z		; FDataStream::operator>><char>
EXTRN	?Read@FDataStream@@IAEXAAD@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5D@FDataStream@@QAEAAV0@AAD@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5D@FDataStream@@QAEAAV0@AAD@Z PROC			; FDataStream::operator>><char>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5D@FDataStream@@QAEAAV0@AAD@Z ENDP			; FDataStream::operator>><char>
_TEXT	ENDS
PUBLIC	??$?6D@FDataStream@@QAEAAV0@ABD@Z		; FDataStream::operator<<<char>
EXTRN	?Write@FDataStream@@IAEXABD@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6D@FDataStream@@QAEAAV0@ABD@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6D@FDataStream@@QAEAAV0@ABD@Z PROC			; FDataStream::operator<<<char>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6D@FDataStream@@QAEAAV0@ABD@Z ENDP			; FDataStream::operator<<<char>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> > >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::~_Node
; Function compile flags: /Ogtpy
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
	add	ecx, 16					; 00000010H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::~_Node
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEABQAVFAutoVariableBase@@XZ ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEABQAVFAutoVariableBase@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEABQAVFAutoVariableBase@@XZ PROC ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEABQAVFAutoVariableBase@@XZ ENDP ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator++
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator-
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator==
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebx

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	mov	ebx, DWORD PTR _iSourceY$[esp]
	push	esi
	push	edi
	test	ebx, ebx
	jl	SHORT $LN17@directionX
	mov	eax, ebx
	jmp	SHORT $LN51@directionX
$LN17@directionX:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN51@directionX:
	mov	esi, DWORD PTR _iSourceX$[esp+8]

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	mov	edi, DWORD PTR _iDestY$[esp+8]
	sar	eax, 1
	sub	esi, eax
	test	edi, edi
	jl	SHORT $LN21@directionX
	mov	eax, edi
	jmp	SHORT $LN52@directionX
$LN21@directionX:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN52@directionX:

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestX$[esp+8]
	sar	eax, 1
	sub	ecx, eax
	sub	ecx, esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [esi+4056], 0
	mov	edx, DWORD PTR [esi+4020]
	je	SHORT $LN31@directionX
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN33@directionX
	sub	ecx, edx
	jmp	SHORT $LN31@directionX
$LN33@directionX:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN35@directionX
$LN31@directionX:
	mov	eax, ecx
$LN35@directionX:

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	sub	edi, ebx
	cmp	BYTE PTR [esi+4057], 0
	mov	edx, edi
	mov	edi, DWORD PTR [esi+4024]
	je	SHORT $LN45@directionX
	mov	esi, edi
	shr	esi, 1
	cmp	edx, esi
	jle	SHORT $LN47@directionX
	sub	edx, edi
	jmp	SHORT $LN45@directionX
$LN47@directionX:
	neg	esi
	cmp	edx, esi
	jge	SHORT $LN45@directionX
	add	edx, edi
$LN45@directionX:
	pop	edi
	pop	esi
	pop	ebx

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	test	edx, edx
	jle	SHORT $LN53@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	xor	ecx, ecx
	test	eax, eax
	setge	cl
	dec	ecx
	and	ecx, 5
	mov	eax, ecx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN53@directionX:

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;
; 276  : 		}
; 277  : 		else
; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;
; 280  : 		}
; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	test	eax, eax
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	neg	eax
	sbb	eax, eax
	and	eax, 5
	dec	eax

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN8@directionX:

; 289  : 		{
; 290  : 			return NO_DIRECTION;
; 291  : 		}
; 292  : 		else
; 293  : 		{
; 294  : 			return DIRECTION_WEST;
; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)
; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	xor	edx, edx
	test	eax, eax
	setle	dl
	add	edx, 2
	mov	eax, edx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[esp-4]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	mov	eax, DWORD PTR _pFromPlot$[esp-4]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z	; GetPlayerUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z PROC		; GetPlayerUnit, COMDAT

; 382  : 	if((unit.eOwner >= 0) && unit.eOwner < MAX_PLAYERS)

	mov	edx, DWORD PTR _unit$[esp-4]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jl	SHORT $LN1@GetPlayerU@3
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@GetPlayerU@3

; 383  : 	{
; 384  : 		return (GET_PLAYER((PlayerTypes)unit.eOwner).m_units.GetAt(unit.iID));

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax

; 388  : }

	ret	0
$LN1@GetPlayerU@3:

; 385  : 	}
; 386  : 
; 387  : 	return NULL;

	xor	eax, eax

; 388  : }

	ret	0
?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z ENDP		; GetPlayerUnit
_TEXT	ENDS
PUBLIC	?GetPlayerUnit@@YAPBVCvUnit@@ABUIDInfo@@@Z	; GetPlayerUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlayerUnit@@YAPBVCvUnit@@ABUIDInfo@@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
?GetPlayerUnit@@YAPBVCvUnit@@ABUIDInfo@@@Z PROC		; GetPlayerUnit, COMDAT

; 392  : 	if((unit.eOwner >= 0) && unit.eOwner < MAX_PLAYERS)

	mov	edx, DWORD PTR _unit$[esp-4]
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jl	SHORT $LN1@GetPlayerU@4
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@GetPlayerU@4

; 393  : 	{
; 394  : 		return (GET_PLAYER((PlayerTypes)unit.eOwner).m_units.GetAt(unit.iID));

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax

; 398  : }

	ret	0
$LN1@GetPlayerU@4:

; 395  : 	}
; 396  : 
; 397  : 	return NULL;

	xor	eax, eax

; 398  : }

	ret	0
?GetPlayerUnit@@YAPBVCvUnit@@ABUIDInfo@@@Z ENDP		; GetPlayerUnit
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T232073 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T232073[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 491  : 
; 492  : 	size_t bytes = 0;
; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 494  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 495  : 	str.assign(szComposedString, bytes);
; 496  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T232073[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T232073[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T232073[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_iTemp$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z PROC ; operator>>, COMDAT

; 109  : {

	push	ecx
	push	esi

; 110  : 	uint uiVersion;
; 111  : 	loadFrom >> uiVersion;

	mov	esi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 112  : 
; 113  : 	int iTemp;
; 114  : 	loadFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 115  : 	writeTo.m_eArtifactType = (GreatWorkArtifactClass)iTemp;

	mov	edi, DWORD PTR _writeTo$[esp+8]
	mov	edx, DWORD PTR _iTemp$[esp+8]

; 116  : 	loadFrom >> writeTo.m_eEra;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	mov	DWORD PTR [edi], edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>

; 117  : 	loadFrom >> writeTo.m_ePlayer1;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 118  : 	loadFrom >> writeTo.m_ePlayer2;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 24					; 00000018H

; 119  : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+12], 2
	jb	SHORT $LN2@operator@3

; 120  : 	{
; 121  : 		loadFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+8]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 122  : 		writeTo.m_eWork = (GreatWorkType)iTemp;

	mov	ecx, DWORD PTR _iTemp$[esp+8]
	mov	DWORD PTR [edi+16], ecx
	pop	edi

; 127  : 	}
; 128  : 
; 129  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 130  : }

	pop	ecx
	ret	0
$LN2@operator@3:

; 123  : 	}
; 124  : 	else
; 125  : 	{
; 126  : 		writeTo.m_eWork = NO_GREAT_WORK;

	mov	DWORD PTR [edi+16], -1
	pop	edi

; 127  : 	}
; 128  : 
; 129  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 130  : }

	pop	ecx
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T232113 = 8						; size = 4
$T232108 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z PROC ; operator<<, COMDAT

; 134  : {

	push	ecx
	push	esi

; 135  : 	uint uiVersion = 2;
; 136  : 	saveTo << uiVersion;

	mov	esi, DWORD PTR _saveTo$[esp+4]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 137  : 
; 138  : 	saveTo << readFrom.m_eArtifactType;

	mov	edi, DWORD PTR _readFrom$[esp+8]
	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR $T232108[esp+8]
	mov	DWORD PTR $T232108[esp+8], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 139  : 	saveTo << readFrom.m_eEra;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<

; 140  : 	saveTo << readFrom.m_ePlayer1;

	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 141  : 	saveTo << readFrom.m_ePlayer2;

	lea	edx, DWORD PTR [edi+12]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 142  : 	saveTo << readFrom.m_eWork;

	mov	eax, DWORD PTR [edi+16]
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR $T232113[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T232113[esp+12], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 143  : 
; 144  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 145  : }

	pop	ecx
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	?updateSymbols@CvPlot@@QAEXXZ			; CvPlot::updateSymbols
EXTRN	??3CvDllPlot@@SAXPAX@Z:PROC			; CvDllPlot::operator delete
EXTRN	??0CvDllPlot@@QAE@PAVCvPlot@@@Z:PROC		; CvDllPlot::CvDllPlot
EXTRN	??2CvDllPlot@@SAPAXI@Z:PROC			; CvDllPlot::operator new
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?updateSymbols@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$1
__ehfuncinfo$?updateSymbols@CvPlot@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?updateSymbols@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateSymbols@CvPlot@@QAEXXZ
_TEXT	SEGMENT
$T232118 = -16						; size = 4
_pDllPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?updateSymbols@CvPlot@@QAEXXZ PROC			; CvPlot::updateSymbols, COMDAT
; _this$ = ecx

; 636  : {

	push	-1
	push	__ehhandler$?updateSymbols@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi

; 637  : 	auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	mov	esi, ecx
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T232118[esp+20], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	eax, eax
	je	SHORT $LN3@updateSymb
	push	esi
	mov	ecx, eax
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	esi, eax
	jmp	SHORT $LN4@updateSymb
$LN3@updateSymb:
	xor	esi, esi
$LN4@updateSymb:
	mov	DWORD PTR _pDllPlot$[esp+20], esi

; 638  : 	gDLL->GameplayYieldMightHaveChanged(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+716]
	push	esi
	mov	DWORD PTR __$EHRec$[esp+32], 1
	call	edx

; 639  : }

	mov	DWORD PTR __$EHRec$[esp+28], -1
	test	esi, esi
	je	SHORT $LN15@updateSymb
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN15@updateSymb:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$0:
	mov	eax, DWORD PTR $T232118[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$1:
	lea	ecx, DWORD PTR _pDllPlot$[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?updateSymbols@CvPlot@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?updateSymbols@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateSymbols@CvPlot@@QAEXXZ ENDP			; CvPlot::updateSymbols
PUBLIC	?isShallowWater@CvPlot@@QBE_NXZ			; CvPlot::isShallowWater
; Function compile flags: /Ogtpy
;	COMDAT ?isShallowWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isShallowWater@CvPlot@@QBE_NXZ PROC			; CvPlot::isShallowWater, COMDAT
; _this$ = ecx

; 937  : 	if(isWater())

	cmp	BYTE PTR [ecx+5], 3
	jne	SHORT $LN1@isShallowW

; 938  : 	{
; 939  : 		TerrainTypes eShallowWater = (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN();
; 940  : 		if(getTerrainType() == eShallowWater)

	movsx	eax, BYTE PTR [ecx+6]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	jne	SHORT $LN1@isShallowW

; 941  : 		{
; 942  : 			return true;

	mov	al, 1

; 946  : }

	ret	0
$LN1@isShallowW:

; 943  : 		}
; 944  : 	}
; 945  : 	return false;

	xor	al, al

; 946  : }

	ret	0
?isShallowWater@CvPlot@@QBE_NXZ ENDP			; CvPlot::isShallowWater
_TEXT	ENDS
PUBLIC	?isLake@CvPlot@@QBE_NXZ				; CvPlot::isLake
EXTRN	?isLake@CvLandmass@@QBE_NXZ:PROC		; CvLandmass::isLake
EXTRN	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z:PROC	; CvMap::getLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?isLake@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isLake@CvPlot@@QBE_NXZ PROC				; CvPlot::isLake, COMDAT
; _this$ = ecx

; 1090 : 	CvLandmass* pLandmass = GC.getMap().getLandmass(m_iLandmass);

	mov	eax, DWORD PTR [ecx+360]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass

; 1091 : 
; 1092 : 	if(pLandmass != NULL)

	test	eax, eax
	je	SHORT $LN1@isLake

; 1093 : 	{
; 1094 : 		return pLandmass->isLake();

	mov	ecx, eax
	jmp	?isLake@CvLandmass@@QBE_NXZ		; CvLandmass::isLake
$LN1@isLake:

; 1095 : 	}
; 1096 : 
; 1097 : 	return false;

	xor	al, al

; 1098 : }

	ret	0
?isLake@CvPlot@@QBE_NXZ ENDP				; CvPlot::isLake
_TEXT	ENDS
PUBLIC	?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverConnection
; Function compile flags: /Ogtpy
;	COMDAT ?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z
_TEXT	SEGMENT
_eDirection$ = 8					; size = 4
?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z PROC ; CvPlot::isRiverConnection, COMDAT
; _this$ = ecx

; 1228 : 	if(eDirection == NO_DIRECTION)

	mov	eax, DWORD PTR _eDirection$[esp-4]
	cmp	eax, -1

; 1229 : 	{
; 1230 : 		return false;

	je	$LN1@isRiverCon

; 1231 : 	}
; 1232 : 
; 1233 : 	switch(eDirection)

	cmp	eax, 5
	ja	$LN1@isRiverCon
	jmp	DWORD PTR $LN61@isRiverCon[eax*4]
$LN7@isRiverCon:

; 1234 : 	{
; 1235 : 
; 1236 : 	case DIRECTION_NORTHEAST:
; 1237 : 		return (isRiverCrossing(DIRECTION_NORTHWEST) || isRiverCrossing(DIRECTION_EAST));

	movsx	eax, BYTE PTR [ecx+460]
	mov	ecx, eax
	shr	ecx, 5
	test	cl, 1
	jne	SHORT $LN13@isRiverCon
	shr	eax, 1
	test	al, 1
	jne	SHORT $LN13@isRiverCon
	xor	eax, eax

; 1266 : }

	ret	4
$LN13@isRiverCon:

; 1234 : 	{
; 1235 : 
; 1236 : 	case DIRECTION_NORTHEAST:
; 1237 : 		return (isRiverCrossing(DIRECTION_NORTHWEST) || isRiverCrossing(DIRECTION_EAST));

	mov	eax, 1

; 1266 : }

	ret	4
$LN6@isRiverCon:

; 1238 : 		break;
; 1239 : 
; 1240 : 	case DIRECTION_EAST:
; 1241 : 		return (isRiverCrossing(DIRECTION_NORTHEAST) || isRiverCrossing(DIRECTION_SOUTHEAST));

	mov	cl, BYTE PTR [ecx+460]
	test	cl, 1
	jne	SHORT $LN13@isRiverCon
	movsx	edx, cl
	shr	edx, 2
	test	dl, 1
	jne	SHORT $LN13@isRiverCon
	xor	eax, eax

; 1266 : }

	ret	4
$LN5@isRiverCon:

; 1242 : 		break;
; 1243 : 
; 1244 : 	case DIRECTION_SOUTHEAST:
; 1245 : 		return (isRiverCrossing(DIRECTION_EAST) || isRiverCrossing(DIRECTION_SOUTHWEST));

	movsx	eax, BYTE PTR [ecx+460]
	mov	ecx, eax
	shr	ecx, 1
	test	cl, 1
	jne	SHORT $LN13@isRiverCon
	shr	eax, 3
	test	al, 1
	jne	SHORT $LN13@isRiverCon
	xor	eax, eax

; 1266 : }

	ret	4
$LN4@isRiverCon:

; 1246 : 		break;
; 1247 : 
; 1248 : 	case DIRECTION_SOUTHWEST:
; 1249 : 		return (isRiverCrossing(DIRECTION_SOUTHEAST) || isRiverCrossing(DIRECTION_WEST));

	movsx	eax, BYTE PTR [ecx+460]
	mov	edx, eax
	shr	edx, 2
	test	dl, 1
	jne	SHORT $LN13@isRiverCon
	shr	eax, 4
	test	al, 1
	jne	SHORT $LN13@isRiverCon
	xor	eax, eax

; 1266 : }

	ret	4
$LN3@isRiverCon:

; 1250 : 		break;
; 1251 : 
; 1252 : 	case DIRECTION_WEST:
; 1253 : 		return (isRiverCrossing(DIRECTION_NORTHWEST) || isRiverCrossing(DIRECTION_SOUTHWEST));

	movsx	eax, BYTE PTR [ecx+460]
	mov	ecx, eax
	shr	ecx, 5
	test	cl, 1
	jne	SHORT $LN13@isRiverCon
	shr	eax, 3
	test	al, 1
	jne	SHORT $LN13@isRiverCon
	xor	eax, eax

; 1266 : }

	ret	4
$LN2@isRiverCon:

; 1254 : 		break;
; 1255 : 
; 1256 : 	case DIRECTION_NORTHWEST:
; 1257 : 		return (isRiverCrossing(DIRECTION_NORTHEAST) || isRiverCrossing(DIRECTION_WEST));

	mov	cl, BYTE PTR [ecx+460]
	test	cl, 1
	jne	$LN13@isRiverCon
	movsx	edx, cl
	shr	edx, 4
	test	dl, 1
	jne	$LN13@isRiverCon
	xor	eax, eax

; 1266 : }

	ret	4
$LN1@isRiverCon:

; 1258 : 		break;
; 1259 : 
; 1260 : 	default:
; 1261 : 		CvAssert(false);
; 1262 : 		break;
; 1263 : 	}
; 1264 : 
; 1265 : 	return false;

	xor	al, al

; 1266 : }

	ret	4
	npad	2
$LN61@isRiverCon:
	DD	$LN7@isRiverCon
	DD	$LN6@isRiverCon
	DD	$LN5@isRiverCon
	DD	$LN4@isRiverCon
	DD	$LN3@isRiverCon
	DD	$LN2@isRiverCon
?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z ENDP ; CvPlot::isRiverConnection
_TEXT	ENDS
PUBLIC	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::seeFromLevel
EXTRN	?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ:PROC	; CvTeam::isExtraWaterSeeFrom
EXTRN	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getSeeFromLevel
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
; Function compile flags: /Ogtpy
;	COMDAT ?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z PROC		; CvPlot::seeFromLevel, COMDAT
; _this$ = ecx

; 1331 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1332 : 	int iLevel;
; 1333 : 
; 1334 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 1335 : 
; 1336 : 	// Plot recon-ed?
; 1337 : 	if(getReconCount() > 0)

	cmp	BYTE PTR [edi+456], 0
	jle	SHORT $LN6@seeFromLev

; 1338 : 	{
; 1339 : 		iLevel = GC.getRECON_VISIBILITY_RANGE() * 2;

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6192
	add	esi, esi

; 1340 : 	}
; 1341 : 	// Normal visibility
; 1342 : 	else

	jmp	SHORT $LN5@seeFromLev
$LN6@seeFromLev:

; 1343 : 	{
; 1344 : 		iLevel = GC.getTerrainInfo(getTerrainType())->getSeeFromLevel();

	movsx	eax, BYTE PTR [edi+6]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getSeeFromLevel
	mov	esi, eax
$LN5@seeFromLev:

; 1345 : 	}
; 1346 : 
; 1347 : 	if(isMountain())

	mov	al, BYTE PTR [edi+5]
	test	al, al
	jne	SHORT $LN4@seeFromLev

; 1348 : 	{
; 1349 : 		iLevel += GC.getMOUNTAIN_SEE_FROM_CHANGE();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6208
$LN4@seeFromLev:

; 1350 : 	}
; 1351 : 
; 1352 : 	if(isHills())

	cmp	al, 1
	jne	SHORT $LN3@seeFromLev

; 1353 : 	{
; 1354 : 		iLevel += GC.getHILLS_SEE_FROM_CHANGE();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6216
$LN3@seeFromLev:

; 1355 : 	}
; 1356 : 
; 1357 : 	if(isWater())

	cmp	al, 3
	jne	SHORT $LN30@seeFromLev

; 1358 : 	{
; 1359 : 		iLevel += GC.getSEAWATER_SEE_FROM_CHANGE();
; 1360 : 
; 1361 : 		if(GET_TEAM(eTeam).isExtraWaterSeeFrom())

	mov	ecx, DWORD PTR _eTeam$[esp+4]
	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6224
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ	; CvTeam::isExtraWaterSeeFrom
	test	al, al
	je	SHORT $LN30@seeFromLev

; 1362 : 		{
; 1363 : 			iLevel++;

	inc	esi
$LN30@seeFromLev:
	pop	edi

; 1364 : 		}
; 1365 : 	}
; 1366 : 
; 1367 : 	return iLevel;

	mov	eax, esi
	pop	esi

; 1368 : }

	ret	4
?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ENDP		; CvPlot::seeFromLevel
_TEXT	ENDS
PUBLIC	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
EXTRN	?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z:PROC ; CvTargeting::CanSeeDisplacementPlot
; Function compile flags: /Ogtpy
;	COMDAT ?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z
_TEXT	SEGMENT
_dy$223198 = -8						; size = 4
_iDistance$ = -4					; size = 4
_startX$ = 8						; size = 4
_pPlot$ = 8						; size = 4
_eTeam$ = 12						; size = 4
_iRange$ = 16						; size = 4
_eFacingDirection$ = 20					; size = 4
?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z PROC ; CvPlot::canSeePlot, COMDAT
; _this$ = ecx

; 1698 : #ifndef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1699 : 	iRange++;
; 1700 : #endif
; 1701 : 
; 1702 : 	if(pPlot == NULL)

	mov	eax, DWORD PTR _pPlot$[esp-4]
	inc	DWORD PTR _iRange$[esp-4]
	sub	esp, 8
	push	ebp
	mov	ebp, ecx
	test	eax, eax
	jne	SHORT $LN6@canSeePlot

; 1703 : 	{
; 1704 : 		return false;

	xor	al, al
	pop	ebp

; 1757 : }

	add	esp, 8
	ret	16					; 00000010H
$LN6@canSeePlot:

; 1705 : 	}
; 1706 : 
; 1707 : 	if(pPlot == this)

	cmp	eax, ebp
	jne	SHORT $LN5@canSeePlot

; 1708 : 	{
; 1709 : 		return true;

	mov	al, 1
	pop	ebp

; 1757 : }

	add	esp, 8
	ret	16					; 00000010H
$LN5@canSeePlot:

; 1710 : 	}
; 1711 : 
; 1712 : 	int startX = getX();

	movsx	ecx, WORD PTR [ebp]
	push	ebx

; 1713 : 	int startY = getY();
; 1714 : 	int destX = pPlot->getX();

	movsx	ebx, WORD PTR [eax]
	push	esi

; 1715 : 	int destY = pPlot->getY();

	movsx	esi, WORD PTR [eax+2]
	push	edi
	movsx	edi, WORD PTR [ebp+2]

; 1716 : 
; 1717 : 	int iDistance = plotDistance(startX, startY, destX,  destY);

	push	esi
	push	ebx
	push	edi
	push	ecx
	mov	DWORD PTR _startX$[esp+36], ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1718 : 
; 1719 : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1720 : 	if (iDistance <= iRange + 1)
; 1721 : #else
; 1722 : 	if(iDistance <= iRange)

	cmp	eax, DWORD PTR _iRange$[esp+20]
	mov	DWORD PTR _iDistance$[esp+24], eax
	jg	$LN1@canSeePlot

; 1723 : #endif
; 1724 : 	{
; 1725 : 		//find displacement
; 1726 : 		int dy = destY - startY;

	mov	eax, esi
	sub	eax, edi
	mov	DWORD PTR _dy$223198[esp+24], eax

; 1727 : 
; 1728 : 		int iX1 = xToHexspaceX(destX,  destY);

	test	esi, esi
	jl	SHORT $LN19@canSeePlot
	sar	esi, 1
	mov	eax, esi
	jmp	SHORT $LN20@canSeePlot
$LN19@canSeePlot:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
	sar	eax, 1
$LN20@canSeePlot:
	sub	ebx, eax

; 1729 : 		int iX2 = xToHexspaceX(startX, startY);

	test	edi, edi
	jl	SHORT $LN23@canSeePlot
	mov	eax, edi
	jmp	SHORT $LN28@canSeePlot
$LN23@canSeePlot:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN28@canSeePlot:
	sar	eax, 1

; 1730 : 		 
; 1731 : 		int dx = iX1 - iX2;
; 1732 : 
; 1733 : 		dx = dxWrap(dx); //world wrap

	sub	eax, DWORD PTR _startX$[esp+20]
	add	eax, ebx
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	mov	esi, eax

; 1734 : 		dy = dyWrap(dy);

	mov	eax, DWORD PTR _dy$223198[esp+28]
	push	eax
	call	?dyWrap@@YAHH@Z				; dyWrap

; 1735 : 
; 1736 : 		//check if in facing direction
; 1737 : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1738 : 		if (shouldProcessDisplacementPlot(dx, dy, iRange, eFacingDirection))
; 1739 : #else
; 1740 : 		if(shouldProcessDisplacementPlot(dx, dy, iRange - 1, eFacingDirection))

	mov	ecx, DWORD PTR _eFacingDirection$[esp+28]
	mov	edx, DWORD PTR _iRange$[esp+28]
	add	esp, 8
	push	ecx
	dec	edx
	push	edx
	mov	ebx, eax
	push	ebx
	push	esi
	mov	ecx, ebp
	call	?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ; CvPlot::shouldProcessDisplacementPlot
	test	al, al
	je	SHORT $LN1@canSeePlot

; 1741 : #endif
; 1742 : 		{
; 1743 : 			if(iDistance == 1)

	cmp	DWORD PTR _iDistance$[esp+24], 1

; 1744 : 			{
; 1745 : 				return true;

	je	SHORT $LN29@canSeePlot

; 1746 : 			}
; 1747 : 
; 1748 : 			//check if anything blocking the plot
; 1749 : 			if (CvTargeting::CanSeeDisplacementPlot(startX, startY, dx, dy, seeFromLevel(eTeam)))

	mov	eax, DWORD PTR _eTeam$[esp+20]
	push	eax
	mov	ecx, ebp
	call	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel
	mov	ecx, DWORD PTR _startX$[esp+20]
	push	eax
	push	ebx
	push	esi
	push	edi
	push	ecx
	call	?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z ; CvTargeting::CanSeeDisplacementPlot
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN1@canSeePlot
$LN29@canSeePlot:
	pop	edi
	pop	esi
	pop	ebx

; 1750 : 			{
; 1751 : 				return true;

	mov	al, 1
	pop	ebp

; 1757 : }

	add	esp, 8
	ret	16					; 00000010H
$LN1@canSeePlot:
	pop	edi
	pop	esi
	pop	ebx

; 1752 : 			}
; 1753 : 		}
; 1754 : 	}
; 1755 : 
; 1756 : 	return false;

	xor	al, al
	pop	ebp

; 1757 : }

	add	esp, 8
	ret	16					; 00000010H
?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ENDP ; CvPlot::canSeePlot
_TEXT	ENDS
PUBLIC	?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z	; CvPlot::movementCost
EXTRN	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCost
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
; Function compile flags: /Ogtpy
;	COMDAT ?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_iMovesRemaining$ = 16					; size = 4
?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z PROC	; CvPlot::movementCost, COMDAT
; _this$ = ecx

; 3109 : 	return CvUnitMovement::MovementCost(pUnit, pFromPlot, this, pUnit->baseMoves(isWater()?DOMAIN_SEA:NO_DOMAIN), pUnit->maxMoves(), iMovesRemaining);

	mov	eax, DWORD PTR _iMovesRemaining$[esp-4]
	push	ebx
	push	esi
	mov	esi, ecx
	cmp	BYTE PTR [esi+5], 3
	push	edi
	mov	edi, DWORD PTR _pUnit$[esp+8]
	push	eax
	mov	ecx, edi
	sete	bl
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	xor	ecx, ecx
	test	bl, bl
	setne	cl
	push	eax
	dec	ecx
	push	ecx
	mov	ecx, edi
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	mov	edx, DWORD PTR _pFromPlot$[esp+16]
	push	eax
	push	esi
	push	edx
	push	edi
	call	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 3110 : }

	ret	12					; 0000000cH
?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ENDP	; CvPlot::movementCost
_TEXT	ENDS
PUBLIC	?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ; CvPlot::MovementCostNoZOC
EXTRN	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCostNoZOC
; Function compile flags: /Ogtpy
;	COMDAT ?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_iMovesRemaining$ = 16					; size = 4
?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z PROC	; CvPlot::MovementCostNoZOC, COMDAT
; _this$ = ecx

; 3115 : 	return CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, this, pUnit->baseMoves(isWater()?DOMAIN_SEA:NO_DOMAIN), pUnit->maxMoves(), iMovesRemaining);

	mov	eax, DWORD PTR _iMovesRemaining$[esp-4]
	push	ebx
	push	esi
	mov	esi, ecx
	cmp	BYTE PTR [esi+5], 3
	push	edi
	mov	edi, DWORD PTR _pUnit$[esp+8]
	push	eax
	mov	ecx, edi
	sete	bl
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	xor	ecx, ecx
	test	bl, bl
	setne	cl
	push	eax
	dec	ecx
	push	ecx
	mov	ecx, edi
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	mov	edx, DWORD PTR _pFromPlot$[esp+16]
	push	eax
	push	esi
	push	edx
	push	edi
	call	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 3116 : }

	ret	12					; 0000000cH
?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ENDP	; CvPlot::MovementCostNoZOC
_TEXT	ENDS
PUBLIC	?IsAllowsWalkWater@CvPlot@@QBE_NXZ		; CvPlot::IsAllowsWalkWater
EXTRN	?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsAllowsWalkWater
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsWalkWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsWalkWater@CvPlot@@QBE_NXZ PROC			; CvPlot::IsAllowsWalkWater, COMDAT
; _this$ = ecx

; 3121 : 	ImprovementTypes eImprovement = getImprovementType();

	movsx	eax, BYTE PTR [ecx+441]

; 3122 : 	if (eImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN1@IsAllowsWa

; 3123 : 	{
; 3124 : 		CvImprovementEntry *pkEntry = GC.getImprovementInfo(eImprovement);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 3125 : 		if (pkEntry)

	test	eax, eax
	je	SHORT $LN1@IsAllowsWa

; 3126 : 			return pkEntry->IsAllowsWalkWater();

	mov	ecx, eax
	jmp	?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsAllowsWalkWater
$LN1@IsAllowsWa:

; 3127 : 	}
; 3128 : 	return false;

	xor	al, al

; 3129 : }

	ret	0
?IsAllowsWalkWater@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsAllowsWalkWater
_TEXT	ENDS
PUBLIC	?IsAllowsSailLand@CvPlot@@QBE_NXZ		; CvPlot::IsAllowsSailLand
EXTRN	?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsAllowsSailLand
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsSailLand@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsSailLand@CvPlot@@QBE_NXZ PROC			; CvPlot::IsAllowsSailLand, COMDAT
; _this$ = ecx

; 3133 :     ImprovementTypes eImprovement = getImprovementType();

	movsx	eax, BYTE PTR [ecx+441]

; 3134 :     if (eImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN1@IsAllowsSa

; 3135 :     {
; 3136 :         CvImprovementEntry *pkEntry = GC.getImprovementInfo(eImprovement);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 3137 :         if (pkEntry)

	test	eax, eax
	je	SHORT $LN1@IsAllowsSa

; 3138 :             return pkEntry->IsAllowsSailLand();

	mov	ecx, eax
	jmp	?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsAllowsSailLand
$LN1@IsAllowsSa:

; 3139 :     }
; 3140 :     return false;

	xor	al, al

; 3141 : }

	ret	0
?IsAllowsSailLand@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsAllowsSailLand
_TEXT	ENDS
PUBLIC	?getExtraMovePathCost@CvPlot@@QBEHXZ		; CvPlot::getExtraMovePathCost
EXTRN	?getPlotExtraCost@CvGame@@QBEHHH@Z:PROC		; CvGame::getPlotExtraCost
; Function compile flags: /Ogtpy
;	COMDAT ?getExtraMovePathCost@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getExtraMovePathCost@CvPlot@@QBEHXZ PROC		; CvPlot::getExtraMovePathCost, COMDAT
; _this$ = ecx

; 3145 : 	return GC.getGame().getPlotExtraCost(getX(), getY());

	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getPlotExtraCost@CvGame@@QBEHHH@Z	; CvGame::getPlotExtraCost

; 3146 : }

	ret	0
?getExtraMovePathCost@CvPlot@@QBEHXZ ENDP		; CvPlot::getExtraMovePathCost
_TEXT	ENDS
PUBLIC	?changeExtraMovePathCost@CvPlot@@QAEXH@Z	; CvPlot::changeExtraMovePathCost
EXTRN	?changePlotExtraCost@CvGame@@QAEXHHH@Z:PROC	; CvGame::changePlotExtraCost
; Function compile flags: /Ogtpy
;	COMDAT ?changeExtraMovePathCost@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeExtraMovePathCost@CvPlot@@QAEXH@Z PROC		; CvPlot::changeExtraMovePathCost, COMDAT
; _this$ = ecx

; 3152 : 	GC.getGame().changePlotExtraCost(getX(), getY(), iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	movsx	edx, WORD PTR [ecx+2]
	push	eax
	movsx	eax, WORD PTR [ecx]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edx
	push	eax
	call	?changePlotExtraCost@CvGame@@QAEXHHH@Z	; CvGame::changePlotExtraCost

; 3153 : }

	ret	4
?changeExtraMovePathCost@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeExtraMovePathCost
_TEXT	ENDS
PUBLIC	?isOwned@CvPlot@@QBE_NXZ			; CvPlot::isOwned
; Function compile flags: /Ogtpy
;	COMDAT ?isOwned@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isOwned@CvPlot@@QBE_NXZ PROC				; CvPlot::isOwned, COMDAT
; _this$ = ecx

; 3471 : 	return (getOwner() != NO_PLAYER);

	xor	eax, eax
	cmp	BYTE PTR [ecx+4], -1
	setne	al

; 3472 : }

	ret	0
?isOwned@CvPlot@@QBE_NXZ ENDP				; CvPlot::isOwned
_TEXT	ENDS
PUBLIC	?isBarbarian@CvPlot@@QBE_NXZ			; CvPlot::isBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?isBarbarian@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isBarbarian@CvPlot@@QBE_NXZ PROC			; CvPlot::isBarbarian, COMDAT
; _this$ = ecx

; 3478 : 	return (getOwner() == BARBARIAN_PLAYER);

	xor	eax, eax
	cmp	BYTE PTR [ecx+4], 63			; 0000003fH
	sete	al

; 3479 : }

	ret	0
?isBarbarian@CvPlot@@QBE_NXZ ENDP			; CvPlot::isBarbarian
_TEXT	ENDS
PUBLIC	?HasBarbarianCamp@CvPlot@@QAE_NXZ		; CvPlot::HasBarbarianCamp
; Function compile flags: /Ogtpy
;	COMDAT ?HasBarbarianCamp@CvPlot@@QAE_NXZ
_TEXT	SEGMENT
?HasBarbarianCamp@CvPlot@@QAE_NXZ PROC			; CvPlot::HasBarbarianCamp, COMDAT
; _this$ = ecx

; 3491 : 	return (getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT());

	movsx	eax, BYTE PTR [ecx+441]
	xor	ecx, ecx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	sete	cl
	mov	al, cl

; 3492 : }

	ret	0
?HasBarbarianCamp@CvPlot@@QAE_NXZ ENDP			; CvPlot::HasBarbarianCamp
_TEXT	ENDS
PUBLIC	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isGoody
EXTRN	?IsGoody@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsGoody
EXTRN	?isMinorCiv@CvTeam@@QBE_NXZ:PROC		; CvTeam::isMinorCiv
EXTRN	?isBarbarian@CvTeam@@QBE_NXZ:PROC		; CvTeam::isBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isGoody, COMDAT
; _this$ = ecx

; 3662 : {

	push	esi

; 3663 : 	if((eTeam != NO_TEAM) && (GET_TEAM(eTeam).isBarbarian() || GET_TEAM(eTeam).isMinorCiv()))

	mov	esi, DWORD PTR _eTeam$[esp]
	push	edi
	mov	edi, ecx
	cmp	esi, -1
	je	SHORT $LN2@isGoody
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	esi, 2980				; 00000ba4H
	lea	ecx, DWORD PTR [esi+eax]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	test	al, al
	jne	SHORT $LN1@isGoody
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	SHORT $LN2@isGoody
$LN1@isGoody:
	pop	edi

; 3664 : 	{
; 3665 : 		return false;

	xor	al, al
	pop	esi

; 3669 : }

	ret	4
$LN2@isGoody:

; 3666 : 	}
; 3667 : 
; 3668 : 	return ((getImprovementType() == NO_IMPROVEMENT) ? false : GC.getImprovementInfo(getImprovementType())->IsGoody());

	mov	al, BYTE PTR [edi+441]
	cmp	al, -1
	je	SHORT $LN1@isGoody
	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	pop	edi
	pop	esi

; 3669 : }

	ret	4
?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isGoody
_TEXT	ENDS
PUBLIC	?isBeingWorked@CvPlot@@QBE_NXZ			; CvPlot::isBeingWorked
EXTRN	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z:PROC ; CvCityCitizens::IsWorkingPlot
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
; Function compile flags: /Ogtpy
;	COMDAT ?isBeingWorked@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isBeingWorked@CvPlot@@QBE_NXZ PROC			; CvPlot::isBeingWorked, COMDAT
; _this$ = ecx

; 3786 : {

	push	esi
	mov	esi, ecx

; 3787 : 	CvCity* pWorkingCity;
; 3788 : 
; 3789 : 	pWorkingCity = getWorkingCity();

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 3790 : 
; 3791 : 	if(pWorkingCity != NULL)

	test	eax, eax
	je	SHORT $LN1@isBeingWor

; 3792 : 	{
; 3793 : 		return pWorkingCity->GetCityCitizens()->IsWorkingPlot(this);

	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	pop	esi

; 3797 : }

	ret	0
$LN1@isBeingWor:

; 3794 : 	}
; 3795 : 
; 3796 : 	return false;

	xor	al, al
	pop	esi

; 3797 : }

	ret	0
?isBeingWorked@CvPlot@@QBE_NXZ ENDP			; CvPlot::isBeingWorked
_TEXT	ENDS
PUBLIC	?isUnitFighting@CvPlot@@QBE_NXZ			; CvPlot::isUnitFighting
EXTRN	?isFighting@CvUnit@@QBE_NXZ:PROC		; CvUnit::isFighting
; Function compile flags: /Ogtpy
;	COMDAT ?isUnitFighting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isUnitFighting@CvPlot@@QBE_NXZ PROC			; CvPlot::isUnitFighting, COMDAT
; _this$ = ecx

; 4269 : {

	push	esi
	push	edi
	mov	edi, ecx

; 4270 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [edi+28], 0
	jbe	SHORT $LN2@isUnitFigh
	mov	esi, DWORD PTR [edi+24]

; 4271 : 	if(pUnitNode)

	test	esi, esi
	je	SHORT $LN2@isUnitFigh
$LL4@isUnitFigh:

; 4272 : 	{
; 4273 : 		do
; 4274 : 		{
; 4275 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN16@isUnitFigh
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN16@isUnitFigh
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	jmp	SHORT $LN17@isUnitFigh
$LN16@isUnitFigh:
	xor	eax, eax
$LN17@isUnitFigh:

; 4276 : 			pUnitNode = m_units.next(pUnitNode);

	mov	edx, DWORD PTR [edi+24]
	sub	esi, edx
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+28]
	jae	SHORT $LN26@isUnitFigh
	lea	esi, DWORD PTR [edx+esi*8]
	jmp	SHORT $LN25@isUnitFigh
$LN26@isUnitFigh:
	xor	esi, esi
$LN25@isUnitFigh:

; 4277 : 
; 4278 : 			if(pLoopUnit && pLoopUnit->isFighting())

	test	eax, eax
	je	SHORT $LN3@isUnitFigh
	mov	ecx, eax
	call	?isFighting@CvUnit@@QBE_NXZ		; CvUnit::isFighting
	test	al, al
	jne	SHORT $LN34@isUnitFigh
$LN3@isUnitFigh:

; 4281 : 			}
; 4282 : 		}
; 4283 : 		while(pUnitNode != NULL);

	test	esi, esi
	jne	SHORT $LL4@isUnitFigh
$LN2@isUnitFigh:
	pop	edi

; 4284 : 	}
; 4285 : 
; 4286 : 	return false;

	xor	al, al
	pop	esi

; 4287 : }

	ret	0
$LN34@isUnitFigh:
	pop	edi

; 4279 : 			{
; 4280 : 				return true;

	mov	al, 1
	pop	esi

; 4287 : }

	ret	0
?isUnitFighting@CvPlot@@QBE_NXZ ENDP			; CvPlot::isUnitFighting
_TEXT	ENDS
PUBLIC	?isCityFighting@CvPlot@@QBE_NXZ			; CvPlot::isCityFighting
EXTRN	?isFighting@CvCity@@QBE_NXZ:PROC		; CvCity::isFighting
; Function compile flags: /Ogtpy
;	COMDAT ?isCityFighting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCityFighting@CvPlot@@QBE_NXZ PROC			; CvPlot::isCityFighting, COMDAT
; _this$ = ecx

; 4293 : 	CvCity* pkCity = getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCityFigh
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCityFigh
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 4294 : 	if(pkCity)

	test	eax, eax
	je	SHORT $LN1@isCityFigh

; 4295 : 		return pkCity->isFighting();

	mov	ecx, eax
	jmp	?isFighting@CvCity@@QBE_NXZ		; CvCity::isFighting
$LN1@isCityFigh:

; 4296 : 
; 4297 : 	return false;

	xor	al, al

; 4298 : }

	ret	0
?isCityFighting@CvPlot@@QBE_NXZ ENDP			; CvPlot::isCityFighting
_TEXT	ENDS
PUBLIC	?at@CvPlot@@QBE_NHH@Z				; CvPlot::at
; Function compile flags: /Ogtpy
;	COMDAT ?at@CvPlot@@QBE_NHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?at@CvPlot@@QBE_NHH@Z PROC				; CvPlot::at, COMDAT
; _this$ = ecx

; 4514 : 	return ((getX() == iX) && (getY() == iY));

	movsx	eax, WORD PTR [ecx]
	cmp	eax, DWORD PTR _iX$[esp-4]
	jne	SHORT $LN3@at
	movsx	ecx, WORD PTR [ecx+2]
	cmp	ecx, DWORD PTR _iY$[esp-4]
	jne	SHORT $LN3@at
	mov	eax, 1

; 4515 : }

	ret	8
$LN3@at:

; 4514 : 	return ((getX() == iX) && (getY() == iY));

	xor	eax, eax

; 4515 : }

	ret	8
?at@CvPlot@@QBE_NHH@Z ENDP				; CvPlot::at
_TEXT	ENDS
PUBLIC	?getLatitude@CvPlot@@QBEHXZ			; CvPlot::getLatitude
EXTRN	?getTopLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getTopLatitude
EXTRN	?getBottomLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getBottomLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?getLatitude@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getLatitude@CvPlot@@QBEHXZ PROC			; CvPlot::getLatitude, COMDAT
; _this$ = ecx

; 4520 : {

	push	ebx
	mov	eax, ecx

; 4521 : 	int iLatitude;
; 4522 : 
; 4523 : 	if(GC.getMap().isWrapX() || !(GC.getMap().isWrapY()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ecx+4056], 0
	push	esi
	push	edi
	jne	SHORT $LN2@getLatitud
	cmp	BYTE PTR [ecx+4057], 0
	je	SHORT $LN2@getLatitud

; 4526 : 	}
; 4527 : 	else
; 4528 : 	{
; 4529 : 		iLatitude = ((getX() * 100) / GC.getMap().getGridWidth());

	movsx	eax, WORD PTR [eax]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR [ecx+4020]
	jmp	SHORT $LN32@getLatitud
$LN2@getLatitud:

; 4524 : 	{
; 4525 : 		iLatitude = ((getY() * 100) / GC.getMap().getGridHeight());

	movsx	eax, WORD PTR [eax+2]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR [ecx+4024]
$LN32@getLatitud:
	mov	edi, eax

; 4530 : 	}
; 4531 : 
; 4532 : 	iLatitude = ((iLatitude * (GC.getMap().getTopLatitude() - GC.getMap().getBottomLatitude())) / 100);

	mov	esi, ecx
	call	?getBottomLatitude@CvMap@@QAEHXZ	; CvMap::getBottomLatitude
	mov	ecx, esi
	mov	ebx, eax
	call	?getTopLatitude@CvMap@@QAEHXZ		; CvMap::getTopLatitude
	mov	ecx, eax
	sub	ecx, ebx
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 4533 : 
; 4534 : 	return abs(iLatitude + GC.getMap().getBottomLatitude());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getBottomLatitude@CvMap@@QAEHXZ	; CvMap::getBottomLatitude
	add	eax, esi
	cdq
	pop	edi
	xor	eax, edx
	pop	esi
	sub	eax, edx
	pop	ebx

; 4535 : }

	ret	0
?getLatitude@CvPlot@@QBEHXZ ENDP			; CvPlot::getLatitude
_TEXT	ENDS
PUBLIC	?area@CvPlot@@QBEPAVCvArea@@XZ			; CvPlot::area
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?area@CvPlot@@QBEPAVCvArea@@XZ
_TEXT	SEGMENT
?area@CvPlot@@QBEPAVCvArea@@XZ PROC			; CvPlot::area, COMDAT
; _this$ = ecx

; 4541 : 	return GC.getMap().getArea(getArea());

	mov	ecx, DWORD PTR [ecx+356]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea

; 4542 : }

	ret	0
?area@CvPlot@@QBEPAVCvArea@@XZ ENDP			; CvPlot::area
_TEXT	ENDS
PUBLIC	?setLandmass@CvPlot@@QAEXH@Z			; CvPlot::setLandmass
EXTRN	?ChangeCentroidY@CvLandmass@@QAEXH@Z:PROC	; CvLandmass::ChangeCentroidY
EXTRN	?ChangeCentroidX@CvLandmass@@QAEXH@Z:PROC	; CvLandmass::ChangeCentroidX
EXTRN	?changeNumTiles@CvLandmass@@QAEXH@Z:PROC	; CvLandmass::changeNumTiles
; Function compile flags: /Ogtpy
;	COMDAT ?setLandmass@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setLandmass@CvPlot@@QAEXH@Z PROC			; CvPlot::setLandmass, COMDAT
; _this$ = ecx

; 4650 : {

	push	ebx

; 4651 : 	if(m_iLandmass != iNewValue)

	mov	ebx, DWORD PTR _iNewValue$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+360]
	cmp	eax, ebx
	je	SHORT $LN1@setLandmas

; 4652 : 	{
; 4653 : 		// cleanup old one
; 4654 : 		CvLandmass* pLandmass = GC.getMap().getLandmass(m_iLandmass);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	push	eax
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	edi, eax

; 4655 : 		if(pLandmass != NULL)

	test	edi, edi
	je	SHORT $LN2@setLandmas

; 4656 : 		{
; 4657 : 			pLandmass->changeNumTiles(-1);

	push	-1
	mov	ecx, edi
	call	?changeNumTiles@CvLandmass@@QAEXH@Z	; CvLandmass::changeNumTiles

; 4658 : 			pLandmass->ChangeCentroidX(-m_iX);

	movsx	eax, WORD PTR [esi]
	neg	eax
	push	eax
	mov	ecx, edi
	call	?ChangeCentroidX@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidX

; 4659 : 			pLandmass->ChangeCentroidY(-m_iY);

	movsx	ecx, WORD PTR [esi+2]
	neg	ecx
	push	ecx
	mov	ecx, edi
	call	?ChangeCentroidY@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidY
$LN2@setLandmas:

; 4660 : 		}
; 4661 : 
; 4662 : 		m_iLandmass = iNewValue;

	mov	DWORD PTR [esi+360], ebx

; 4663 : 
; 4664 : 		pLandmass = GC.getMap().getLandmass(m_iLandmass);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	edi, eax

; 4665 : 		if(pLandmass != NULL)

	test	edi, edi
	je	SHORT $LN10@setLandmas

; 4666 : 		{
; 4667 : 			pLandmass->changeNumTiles(1);

	push	1
	mov	ecx, edi
	call	?changeNumTiles@CvLandmass@@QAEXH@Z	; CvLandmass::changeNumTiles

; 4668 : 			pLandmass->ChangeCentroidX(m_iX);

	movsx	edx, WORD PTR [esi]
	push	edx
	mov	ecx, edi
	call	?ChangeCentroidX@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidX

; 4669 : 			pLandmass->ChangeCentroidY(m_iY);

	movsx	eax, WORD PTR [esi+2]
	push	eax
	mov	ecx, edi
	call	?ChangeCentroidY@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidY
$LN10@setLandmas:
	pop	edi
$LN1@setLandmas:
	pop	esi
	pop	ebx

; 4670 : 		}
; 4671 : 	}
; 4672 : }

	ret	4
?setLandmass@CvPlot@@QAEXH@Z ENDP			; CvPlot::setLandmass
_TEXT	ENDS
PUBLIC	?isOwnershipScore@CvPlot@@QBE_NXZ		; CvPlot::isOwnershipScore
; Function compile flags: /Ogtpy
;	COMDAT ?isOwnershipScore@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isOwnershipScore@CvPlot@@QBE_NXZ PROC			; CvPlot::isOwnershipScore, COMDAT
; _this$ = ecx

; 4692 : 	return (getOwnershipDuration() >= GC.getOWNERSHIP_SCORE_DURATION_THRESHOLD());

	movsx	eax, WORD PTR [ecx+380]
	xor	ecx, ecx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6252
	setge	cl
	mov	al, cl

; 4693 : }

	ret	0
?isOwnershipScore@CvPlot@@QBE_NXZ ENDP			; CvPlot::isOwnershipScore
_TEXT	ENDS
PUBLIC	?setOwnershipDuration@CvPlot@@QAEXH@Z		; CvPlot::setOwnershipDuration
EXTRN	?changeTotalLandScored@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeTotalLandScored
; Function compile flags: /Ogtpy
;	COMDAT ?setOwnershipDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setOwnershipDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::setOwnershipDuration, COMDAT
; _this$ = ecx

; 4699 : 	bool bOldOwnershipScore;
; 4700 : 
; 4701 : 	if(getOwnershipDuration() != iNewValue)

	movsx	edx, WORD PTR [ecx+380]
	mov	eax, DWORD PTR _iNewValue$[esp-4]
	cmp	edx, eax
	je	SHORT $LN1@setOwnersh

; 4702 : 	{
; 4703 : 		bOldOwnershipScore = isOwnershipScore();

	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6252
	push	esi

; 4704 : 
; 4705 : 		m_iOwnershipDuration = iNewValue;

	movsx	esi, ax
	mov	WORD PTR [ecx+380], ax
	push	edi

; 4706 : 		CvAssert(getOwnershipDuration() >= 0);
; 4707 : 
; 4708 : 		if(bOldOwnershipScore != isOwnershipScore())

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6252
	setge	dl
	cmp	esi, edi
	setge	al
	cmp	dl, al
	je	SHORT $LN37@setOwnersh

; 4709 : 		{
; 4710 : 			if(isOwned())

	mov	al, BYTE PTR [ecx+4]
	cmp	al, -1
	je	SHORT $LN37@setOwnersh

; 4711 : 			{
; 4712 : 				if(!isWater())

	cmp	BYTE PTR [ecx+5], 3
	je	SHORT $LN37@setOwnersh

; 4713 : 				{
; 4714 : 					GET_PLAYER(getOwner()).changeTotalLandScored((isOwnershipScore()) ? 1 : -1);

	xor	ecx, ecx
	cmp	esi, edi
	setge	cl
	pop	edi
	pop	esi
	lea	ecx, DWORD PTR [ecx+ecx-1]
	mov	DWORD PTR _iNewValue$[esp-4], ecx
	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	jmp	?changeTotalLandScored@CvPlayer@@QAEXH@Z ; CvPlayer::changeTotalLandScored
$LN37@setOwnersh:
	pop	edi
	pop	esi
$LN1@setOwnersh:

; 4715 : 				}
; 4716 : 			}
; 4717 : 		}
; 4718 : 	}
; 4719 : }

	ret	4
?setOwnershipDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::setOwnershipDuration
_TEXT	ENDS
PUBLIC	?changeOwnershipDuration@CvPlot@@QAEXH@Z	; CvPlot::changeOwnershipDuration
; Function compile flags: /Ogtpy
;	COMDAT ?changeOwnershipDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeOwnershipDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::changeOwnershipDuration, COMDAT
; _this$ = ecx

; 4725 : 	setOwnershipDuration(getOwnershipDuration() + iChange);

	movsx	eax, WORD PTR [ecx+380]
	add	eax, DWORD PTR _iChange$[esp-4]
	mov	DWORD PTR _iChange$[esp-4], eax
	jmp	?setOwnershipDuration@CvPlot@@QAEXH@Z	; CvPlot::setOwnershipDuration
?changeOwnershipDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeOwnershipDuration
_TEXT	ENDS
PUBLIC	?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::getUpgradeTimeLeft
EXTRN	?getImprovementUpgradeRate@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getImprovementUpgradeRate
EXTRN	?getImprovementUpgradeTime@CvGame@@QBEHW4ImprovementTypes@@PBVCvPlot@@@Z:PROC ; CvGame::getImprovementUpgradeTime
; Function compile flags: /Ogtpy
;	COMDAT ?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iTurnsLeft$ = 8					; size = 4
_eImprovement$ = 8					; size = 4
$T232698 = 12						; size = 4
_ePlayer$ = 12						; size = 4
?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::getUpgradeTimeLeft, COMDAT
; _this$ = ecx

; 4761 : 	int iUpgradeLeft;
; 4762 : 	int iUpgradeRate;
; 4763 : 	int iTurnsLeft;
; 4764 : 
; 4765 : 	iUpgradeLeft = ((100 * GC.getGame().getImprovementUpgradeTime(eImprovement, const_cast<CvPlot*>(this))) - ((getImprovementType() == eImprovement) ? getUpgradeProgress() : 0));

	movsx	edx, BYTE PTR [ecx+441]
	mov	eax, DWORD PTR _eImprovement$[esp-4]
	push	esi
	cmp	edx, eax
	jne	SHORT $LN6@getUpgrade
	movsx	esi, WORD PTR [ecx+384]
	jmp	SHORT $LN7@getUpgrade
$LN6@getUpgrade:
	xor	esi, esi
$LN7@getUpgrade:
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?getImprovementUpgradeTime@CvGame@@QBEHW4ImprovementTypes@@PBVCvPlot@@@Z ; CvGame::getImprovementUpgradeTime
	mov	ecx, eax
	imul	ecx, 100				; 00000064H
	sub	ecx, esi

; 4766 : 	iUpgradeLeft /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 4767 : 
; 4768 : 	if(ePlayer == NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer$[esp]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	cmp	eax, -1
	jne	SHORT $LN3@getUpgrade

; 4769 : 	{
; 4770 : 		return iUpgradeLeft;

	mov	eax, esi
	pop	esi

; 4789 : }

	ret	8
$LN3@getUpgrade:

; 4771 : 	}
; 4772 : 
; 4773 : 	iUpgradeRate = GET_PLAYER(ePlayer).getImprovementUpgradeRate();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getImprovementUpgradeRate@CvPlayer@@QBEHXZ ; CvPlayer::getImprovementUpgradeRate
	mov	ecx, eax

; 4774 : 
; 4775 : 	if(iUpgradeRate == 0)
; 4776 : 	{
; 4777 : 		return iUpgradeLeft;

	mov	eax, esi
	test	ecx, ecx
	je	SHORT $LN4@getUpgrade

; 4778 : 	}
; 4779 : 
; 4780 : 	// Upgrade rate is stored at 100x
; 4781 : 	iTurnsLeft = (100 * iUpgradeLeft / iUpgradeRate);

	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx

; 4782 : 
; 4783 : 	if((iTurnsLeft * iUpgradeRate) < iUpgradeLeft)

	mov	edx, eax
	imul	edx, ecx
	cmp	edx, esi
	mov	DWORD PTR _iTurnsLeft$[esp], eax
	jge	SHORT $LN1@getUpgrade

; 4784 : 	{
; 4785 : 		iTurnsLeft++;

	inc	eax
	mov	DWORD PTR _iTurnsLeft$[esp], eax
$LN1@getUpgrade:

; 4786 : 	}
; 4787 : 
; 4788 : 	return std::max(1, iTurnsLeft);

	cmp	eax, 1
	mov	DWORD PTR $T232698[esp], 1
	lea	eax, DWORD PTR _iTurnsLeft$[esp]
	jg	SHORT $LN19@getUpgrade
	lea	eax, DWORD PTR $T232698[esp]
$LN19@getUpgrade:
	mov	eax, DWORD PTR [eax]
$LN4@getUpgrade:
	pop	esi

; 4789 : }

	ret	8
?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::getUpgradeTimeLeft
_TEXT	ENDS
PUBLIC	?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z ; CvPlot::isPotentialCityWorkForArea
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
; Function compile flags: /Ogtpy
;	COMDAT ?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z
_TEXT	SEGMENT
_pArea$ = 8						; size = 4
?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z PROC ; CvPlot::isPotentialCityWorkForArea, COMDAT
; _this$ = ecx

; 5119 : {

	push	ebp

; 5120 : 	CvPlot* pLoopPlot;
; 5121 : 	int iI;
; 5122 : 
; 5123 : 	for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	ebp, DWORD PTR _pArea$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	xor	esi, esi
	npad	5
$LL7@isPotentia:

; 5124 : 	{
; 5125 : 		pLoopPlot = plotCity(getX(), getY(), iI);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	esi
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 5126 : 
; 5127 : 		if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN6@isPotentia

; 5128 : 		{
; 5129 : 			if(!(pLoopPlot->isWater()) || GC.getWATER_POTENTIAL_CITY_WORK_FOR_AREA())

	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN2@isPotentia
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6884, 0
	je	SHORT $LN6@isPotentia
$LN2@isPotentia:

; 5130 : 			{
; 5131 : 				if(pLoopPlot->area() == pArea)

	mov	eax, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	cmp	eax, ebp
	je	SHORT $LN25@isPotentia
$LN6@isPotentia:

; 5120 : 	CvPlot* pLoopPlot;
; 5121 : 	int iI;
; 5122 : 
; 5123 : 	for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	inc	esi
	cmp	esi, 37					; 00000025H
	jl	SHORT $LL7@isPotentia
	pop	edi
	pop	esi

; 5134 : 				}
; 5135 : 			}
; 5136 : 		}
; 5137 : 	}
; 5138 : 
; 5139 : 	return false;

	xor	al, al
	pop	ebp

; 5140 : }

	ret	4
$LN25@isPotentia:
	pop	edi
	pop	esi

; 5132 : 				{
; 5133 : 					return true;

	mov	al, 1
	pop	ebp

; 5140 : }

	ret	4
?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z ENDP ; CvPlot::isPotentialCityWorkForArea
_TEXT	ENDS
PUBLIC	?isFlatlands@CvPlot@@QBE_NXZ			; CvPlot::isFlatlands
; Function compile flags: /Ogtpy
;	COMDAT ?isFlatlands@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isFlatlands@CvPlot@@QBE_NXZ PROC			; CvPlot::isFlatlands, COMDAT
; _this$ = ecx

; 5676 : 	return (getPlotType() == PLOT_LAND);

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 2
	sete	al

; 5677 : }

	ret	0
?isFlatlands@CvPlot@@QBE_NXZ ENDP			; CvPlot::isFlatlands
_TEXT	ENDS
PUBLIC	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
EXTRN	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z:PROC ; CvTeam::isForceRevealedResource
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getTechReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechReveal
EXTRN	?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z:PROC ; CvTeam::HavePolicyInTeam
EXTRN	?getPolicyReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getPolicyReveal
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?isDebugMode@CvGame@@QBE_NXZ:PROC		; CvGame::isDebugMode
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getResourceType, COMDAT
; _this$ = ecx

; 6071 : {

	push	ebx
	push	ebp

; 6072 : 	if(eTeam != NO_TEAM)

	mov	ebp, DWORD PTR _eTeam$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	cmp	ebp, -1
	je	$LN1@getResourc

; 6073 : 	{
; 6074 : 		if(m_eResourceType != NO_RESOURCE)

	cmp	BYTE PTR [edi+440], -1
	je	$LN1@getResourc

; 6075 : 		{
; 6076 : 			CvGame& Game = GC.getGame();
; 6077 : 			bool bDebug = Game.isDebugMode();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	mov	bl, al

; 6078 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_RESOURCES
; 6079 : 			if (eTeam == OBSERVER_TEAM)
; 6080 : 				bDebug = true;
; 6081 : #endif
; 6082 : 
; 6083 : 			int iPolicyReveal = GC.getResourceInfo((ResourceTypes)m_eResourceType)->getPolicyReveal();

	movsx	eax, BYTE PTR [edi+440]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal

; 6084 : 			if (!bDebug && iPolicyReveal != NO_POLICY)

	test	bl, bl
	jne	$LN1@getResourc
	cmp	eax, -1
	je	SHORT $LN18@getResourc

; 6085 : 			{
; 6086 : 				if (!GET_TEAM(eTeam).HavePolicyInTeam((PolicyTypes)iPolicyReveal))

	mov	ecx, ebp
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z ; CvTeam::HavePolicyInTeam
	test	al, al
	jne	SHORT $LN18@getResourc
$LN19@getResourc:
	pop	edi
	pop	esi
	pop	ebp

; 6087 : 				{
; 6088 : 					return NO_RESOURCE;

	or	eax, -1
	pop	ebx

; 6102 : }

	ret	4
$LN18@getResourc:

; 6089 : 				}
; 6090 : 			}
; 6091 : 
; 6092 : 			if(!bDebug && !GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)(GC.getResourceInfo((ResourceTypes)m_eResourceType)->getTechReveal())) &&
; 6093 : 			        !GET_TEAM(eTeam).isForceRevealedResource((ResourceTypes)m_eResourceType) &&
; 6094 : 			        !IsResourceForceReveal(eTeam))

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	movsx	edx, BYTE PTR [edi+440]
	mov	esi, ebp
	imul	esi, 2980				; 00000ba4H
	lea	ebx, DWORD PTR [esi+ecx]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	push	eax
	mov	ecx, ebx
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	SHORT $LN1@getResourc
	movsx	edx, BYTE PTR [edi+440]
	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [esi+eax]
	push	edx
	call	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ; CvTeam::isForceRevealedResource
	test	al, al
	jne	SHORT $LN1@getResourc
	mov	eax, DWORD PTR [edi+176]
	cmp	BYTE PTR [eax+ebp], 0

; 6095 : 			{
; 6096 : 				return NO_RESOURCE;

	je	SHORT $LN19@getResourc
$LN1@getResourc:

; 6097 : 			}
; 6098 : 		}
; 6099 : 	}
; 6100 : 
; 6101 : 	return (ResourceTypes)m_eResourceType;

	movsx	eax, BYTE PTR [edi+440]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 6102 : }

	ret	4
?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getResourceType
_TEXT	ENDS
PUBLIC	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
EXTRN	?getTechObsolete@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechObsolete
; Function compile flags: /Ogtpy
;	COMDAT ?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getNonObsoleteResourceType, COMDAT
; _this$ = ecx

; 6107 : {

	push	esi

; 6108 : 	ResourceTypes eResource;
; 6109 : 
; 6110 : 	CvAssert(eTeam != NO_TEAM);
; 6111 : 
; 6112 : 	eResource = getResourceType(eTeam);

	mov	esi, DWORD PTR _eTeam$[esp]
	push	edi
	push	esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	edi, eax

; 6113 : 
; 6114 : 	if(eResource != NO_RESOURCE)

	cmp	edi, -1
	je	SHORT $LN1@getNonObso

; 6115 : 	{
; 6116 : 		if((GC.getResourceInfo(eResource)->getTechObsolete() != NO_TECH) && GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)(GC.getResourceInfo(eResource)->getTechObsolete())))

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechObsolete@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechObsolete
	cmp	eax, -1
	je	SHORT $LN1@getNonObso
	imul	esi, 2980				; 00000ba4H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechObsolete@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechObsolete
	push	eax
	mov	ecx, esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN1@getNonObso
	pop	edi

; 6117 : 		{
; 6118 : 			return NO_RESOURCE;

	or	eax, -1
	pop	esi

; 6123 : }

	ret	4
$LN1@getNonObso:

; 6119 : 		}
; 6120 : 	}
; 6121 : 
; 6122 : 	return eResource;

	mov	eax, edi
	pop	edi
	pop	esi

; 6123 : }

	ret	4
?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getNonObsoleteResourceType
_TEXT	ENDS
PUBLIC	?HasSpecialImprovement@CvPlot@@QBE_NXZ		; CvPlot::HasSpecialImprovement
EXTRN	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsCreatedByGreatPerson
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Ogtpy
;	COMDAT ?HasSpecialImprovement@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?HasSpecialImprovement@CvPlot@@QBE_NXZ PROC		; CvPlot::HasSpecialImprovement, COMDAT
; _this$ = ecx

; 6709 : {

	push	esi
	mov	esi, ecx

; 6710 : 	// Gifted improvements (if we are a minor civ)
; 6711 : 	if (getOwner() != NO_PLAYER)

	mov	al, BYTE PTR [esi+4]
	cmp	al, -1
	je	SHORT $LN3@HasSpecial

; 6712 : 	{
; 6713 : 		CvPlayer* pOwner = &GET_PLAYER(getOwner());

	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 6714 : 		if (pOwner->isMinorCiv())

	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN3@HasSpecial

; 6715 : 		{
; 6716 : 			if (IsImprovedByGiftFromMajor())

	test	BYTE PTR [esi+462], 32			; 00000020H
	je	SHORT $LN3@HasSpecial
$LN18@HasSpecial:

; 6717 : 			{
; 6718 : 				return true;

	mov	al, 1
	pop	esi

; 6735 : }

	ret	0
$LN3@HasSpecial:

; 6719 : 			}
; 6720 : 		}
; 6721 : 	}
; 6722 : 
; 6723 : 	// Great person improvements
; 6724 : 	ImprovementTypes eImprovement = getImprovementType();

	movsx	eax, BYTE PTR [esi+441]

; 6725 : 	if (eImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN1@HasSpecial

; 6726 : 	{
; 6727 : 		CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 6728 : 		if (pImprovementInfo && pImprovementInfo->IsCreatedByGreatPerson())

	test	eax, eax
	je	SHORT $LN1@HasSpecial
	mov	ecx, eax
	call	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsCreatedByGreatPerson
	test	al, al

; 6729 : 		{
; 6730 : 			return true;

	jne	SHORT $LN18@HasSpecial
$LN1@HasSpecial:

; 6731 : 		}
; 6732 : 	}
; 6733 : 
; 6734 : 	return false;

	xor	al, al
	pop	esi

; 6735 : }

	ret	0
?HasSpecialImprovement@CvPlot@@QBE_NXZ ENDP		; CvPlot::HasSpecialImprovement
_TEXT	ENDS
PUBLIC	?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z ; CvPlot::SetWorldAnchor
; Function compile flags: /Ogtpy
;	COMDAT ?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z
_TEXT	SEGMENT
_eAnchor$ = 8						; size = 4
_iData1$ = 12						; size = 4
?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z PROC ; CvPlot::SetWorldAnchor, COMDAT
; _this$ = ecx

; 6763 : {

	push	ebx

; 6764 : 	GenericWorldAnchorTypes eOldAnchor = (GenericWorldAnchorTypes) m_eWorldAnchor;
; 6765 : 
; 6766 : 	// Set the new anchor
; 6767 : 	m_eWorldAnchor = eAnchor;
; 6768 : 	m_cWorldAnchorData = iData1;

	mov	ebx, DWORD PTR _iData1$[esp]
	push	esi
	mov	esi, ecx
	movsx	eax, BYTE PTR [esi+448]
	mov	cl, BYTE PTR _eAnchor$[esp+4]
	mov	BYTE PTR [esi+448], cl
	mov	BYTE PTR [esi+449], bl

; 6769 : 
; 6770 : 	// Remove old
; 6771 : 	if(eOldAnchor != NO_WORLD_ANCHOR)

	cmp	eax, -1
	je	SHORT $LN2@SetWorldAn

; 6772 : 		gDLL->GameplayWorldAnchor(eOldAnchor, /*bAdd*/ false, getX(), getY(), iData1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	push	edi
	movsx	edi, WORD PTR [esi+2]
	push	ebx
	push	edi
	movsx	edi, WORD PTR [esi]
	push	edi
	push	0
	push	eax
	mov	eax, DWORD PTR [edx+792]
	call	eax
	pop	edi
$LN2@SetWorldAn:

; 6773 : 
; 6774 : 	// Add new
; 6775 : 	if(eAnchor == WORLD_ANCHOR_NATURAL_WONDER)

	cmp	DWORD PTR _eAnchor$[esp+4], 0
	jne	SHORT $LN1@SetWorldAn

; 6776 : 		gDLL->GameplayWorldAnchor(eAnchor, /*bAdd*/ true, getX(), getY(), iData1);

	movsx	eax, WORD PTR [esi+2]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+792]
	push	ebx
	push	eax
	movsx	eax, WORD PTR [esi]
	push	eax
	push	1
	push	0
	call	edx
$LN1@SetWorldAn:
	pop	esi
	pop	ebx

; 6777 : }

	ret	8
?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z ENDP ; CvPlot::SetWorldAnchor
_TEXT	ENDS
PUBLIC	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z	; CvPlot::SetResourceLinkedCityActive
EXTRN	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z:PROC ; CvCity::ChangeNumResourceLocal
; Function compile flags: /Ogtpy
;	COMDAT ?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z PROC	; CvPlot::SetResourceLinkedCityActive, COMDAT
; _this$ = ecx

; 7062 : 	if(bValue != IsResourceLinkedCityActive())

	mov	al, BYTE PTR [ecx+462]
	mov	dl, BYTE PTR _bValue$[esp-4]
	push	ebx
	mov	bl, al
	shr	bl, 4
	and	bl, 1
	cmp	dl, bl
	je	SHORT $LN1@SetResourc

; 7063 : 	{
; 7064 : 		m_bResourceLinkedCityActive = bValue;

	mov	bl, dl
	shl	bl, 4
	xor	bl, al
	and	bl, 16					; 00000010H
	xor	bl, al

; 7065 : 
; 7066 : 		// Now change num resource local to linked city (new or former)
; 7067 : 
; 7068 : 		FAssertMsg(GetResourceLinkedCity() != NULL, "Resource linked city is null for some reason. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 7069 : 		FAssertMsg(getOwner() != NO_PLAYER, "Owner of a tile with a resource linkned to a city is not valid. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 7070 : 
; 7071 : 		int iResourceChange = bValue ? getNumResource() : -getNumResource();

	movsx	eax, BYTE PTR [ecx+458]
	mov	BYTE PTR [ecx+462], bl
	test	dl, dl
	jne	SHORT $LN5@SetResourc
	neg	eax
$LN5@SetResourc:

; 7072 : 		GetResourceLinkedCity()->ChangeNumResourceLocal(getResourceType(), iResourceChange);

	movsx	edx, BYTE PTR [ecx+440]
	push	eax
	mov	eax, DWORD PTR [ecx+132]
	mov	ecx, DWORD PTR [ecx+128]
	push	edx
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	mov	ecx, eax
	call	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z ; CvCity::ChangeNumResourceLocal
$LN1@SetResourc:
	pop	ebx

; 7073 : 	}
; 7074 : }

	ret	4
?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ENDP	; CvPlot::SetResourceLinkedCityActive
_TEXT	ENDS
PUBLIC	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z	; CvPlot::getFoundValue
; Function compile flags: /Ogtpy
;	COMDAT ?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z PROC	; CvPlot::getFoundValue, COMDAT
; _this$ = ecx

; 8185 : {

	push	esi
	mov	esi, ecx

; 8186 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8187 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8188 : 
; 8189 : 	if(m_aiFoundValue[eIndex] == -1)

	mov	eax, DWORD PTR [esi+148]
	push	edi
	mov	edi, DWORD PTR _eIndex$[esp+4]
	cmp	DWORD PTR [eax+edi*4], -1
	jne	SHORT $LN10@getFoundVa

; 8190 : 	{
; 8191 : 		m_aiFoundValue[eIndex] = GET_PLAYER(eIndex).AI_foundValue(getX(), getY(), -1, true);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	movsx	eax, WORD PTR [esi+2]
	mov	ecx, edi
	imul	ecx, 63236				; 0000f704H
	push	ebx
	mov	ebx, DWORD PTR [ecx+edx]
	push	1
	add	ecx, edx
	movsx	edx, WORD PTR [esi]
	push	-1
	push	eax
	mov	eax, DWORD PTR [ebx+48]
	push	edx
	call	eax
	mov	ecx, DWORD PTR [esi+148]
	mov	DWORD PTR [ecx+edi*4], eax

; 8192 : 	}
; 8193 : 
; 8194 : 	return m_aiFoundValue[eIndex];

	mov	edx, DWORD PTR [esi+148]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	ebx
	pop	edi
	pop	esi

; 8195 : }

	ret	4
$LN10@getFoundVa:

; 8192 : 	}
; 8193 : 
; 8194 : 	return m_aiFoundValue[eIndex];

	mov	eax, DWORD PTR [eax+edi*4]
	pop	edi
	pop	esi

; 8195 : }

	ret	4
?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ENDP	; CvPlot::getFoundValue
_TEXT	ENDS
PUBLIC	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::getRevealedOwner, COMDAT
; _this$ = ecx

; 8405 : 	if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@getReveale
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN2@getReveale

; 8406 : 	{
; 8407 : 		return getOwner();

	movsx	eax, BYTE PTR [esi+4]
	pop	esi

; 8415 : 	}
; 8416 : }

	ret	8
$LN2@getReveale:

; 8408 : 	}
; 8409 : 	else
; 8410 : 	{
; 8411 : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8412 : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8413 : 
; 8414 : 		return (PlayerTypes)m_aiRevealedOwner[eTeam];

	mov	eax, DWORD PTR [esi+160]
	mov	ecx, DWORD PTR _eTeam$[esp]
	movsx	eax, BYTE PTR [eax+ecx]
	pop	esi

; 8415 : 	}
; 8416 : }

	ret	8
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::getRevealedOwner
_TEXT	ENDS
PUBLIC	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner
EXTRN	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvTeam::SetHasFoundPlayersTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_eNewValue$ = 12					; size = 4
?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::setRevealedOwner, COMDAT
; _this$ = ecx

; 8469 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8470 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8471 : 
; 8472 : 	if(getRevealedOwner(eTeam, false) != eNewValue)

	mov	eax, DWORD PTR [ecx+160]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	lea	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _eNewValue$[esp-4]
	push	esi
	movsx	esi, BYTE PTR [edx]
	cmp	esi, eax
	pop	esi
	je	SHORT $LN2@setReveale

; 8473 : 	{
; 8474 : 		m_aiRevealedOwner[eTeam] = eNewValue;

	mov	BYTE PTR [edx], al

; 8475 : 
; 8476 : 		// Let the team know we've found someone (if eNewValue IS someone)
; 8477 : 		if(eNewValue != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN1@setReveale

; 8478 : 		{
; 8479 : 			GET_TEAM(eTeam).SetHasFoundPlayersTerritory(eNewValue, true);

	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	eax
	call	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ; CvTeam::SetHasFoundPlayersTerritory
$LN1@setReveale:

; 8480 : 		}
; 8481 : 		return true;

	mov	al, 1

; 8486 : }

	ret	8
$LN2@setReveale:

; 8482 : 	}
; 8483 : 
; 8484 : 	CvAssert(m_aiRevealedOwner[eTeam] == eNewValue);
; 8485 : 	return false;

	xor	al, al

; 8486 : }

	ret	8
?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::setRevealedOwner
_TEXT	ENDS
PUBLIC	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::getRevealedImprovementType, COMDAT
; _this$ = ecx

; 9132 : 	if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@getReveale@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN2@getReveale@2

; 9133 : 	{
; 9134 : 		return getImprovementType();

	movsx	eax, BYTE PTR [esi+441]
	pop	esi

; 9142 : 	}
; 9143 : }

	ret	8
$LN2@getReveale@2:

; 9135 : 	}
; 9136 : 	else
; 9137 : 	{
; 9138 : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9139 : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9140 : 
; 9141 : 		return (ImprovementTypes)m_aeRevealedImprovementType[eTeam];

	mov	eax, DWORD PTR [esi+164]
	mov	ecx, DWORD PTR _eTeam$[esp]
	movsx	eax, WORD PTR [eax+ecx*2]
	pop	esi

; 9142 : 	}
; 9143 : }

	ret	8
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::getRevealedImprovementType
_TEXT	ENDS
PUBLIC	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::getRevealedRouteType, COMDAT
; _this$ = ecx

; 9187 : 	if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@getReveale@3
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN2@getReveale@3

; 9188 : 	{
; 9189 : 		return getRouteType();

	movsx	eax, BYTE PTR [esi+447]
	pop	esi

; 9197 : 	}
; 9198 : }

	ret	8
$LN2@getReveale@3:

; 9190 : 	}
; 9191 : 	else
; 9192 : 	{
; 9193 : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9194 : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9195 : 
; 9196 : 		return (RouteTypes)m_aeRevealedRouteType[eTeam];

	mov	eax, DWORD PTR [esi+168]
	mov	ecx, DWORD PTR _eTeam$[esp]
	movsx	eax, WORD PTR [eax+ecx*2]
	pop	esi

; 9197 : 	}
; 9198 : }

	ret	8
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::getRevealedRouteType
_TEXT	ENDS
PUBLIC	?getNumLayerUnits@CvPlot@@QBEHH@Z		; CvPlot::getNumLayerUnits
EXTRN	?GetNumUnits@CvPlotManager@@QBEHHHI@Z:PROC	; CvPlotManager::GetNumUnits
EXTRN	?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z:PROC ; CvPlotManager::GetNumUnitsByIndex
EXTRN	?GetNumLayers@CvPlotManager@@QBEHXZ:PROC	; CvPlotManager::GetNumLayers
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLayerUnits@CvPlot@@QBEHH@Z
_TEXT	SEGMENT
_iCount$226530 = 8					; size = 4
_iLayerID$ = 8						; size = 4
?getNumLayerUnits@CvPlot@@QBEHH@Z PROC			; CvPlot::getNumLayerUnits, COMDAT
; _this$ = ecx

; 9637 : 	if (iLayerID == DEFAULT_UNIT_MAP_LAYER)

	mov	eax, DWORD PTR _iLayerID$[esp-4]
	push	edi
	mov	edi, ecx
	test	eax, eax
	jne	SHORT $LN7@getNumLaye

; 9638 : 		// Base layer
; 9639 : 		return m_units.getLength();

	mov	eax, DWORD PTR [edi+28]
	pop	edi

; 9657 : 		}
; 9658 : }

	ret	4
$LN7@getNumLaye:

; 9640 : 	else
; 9641 : 		if (iLayerID == -1)

	cmp	eax, -1
	jne	SHORT $LN5@getNumLaye

; 9642 : 		{
; 9643 : 			// All layers
; 9644 : 			int iCount = m_units.getLength();

	mov	eax, DWORD PTR [edi+28]
	push	ebx

; 9645 : 			const CvPlotManager& kManager = GC.getMap().plotManager();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebp
	add	ebx, 4184				; 00001058H
	push	esi

; 9646 : 			int iNumLayers = kManager.GetNumLayers();

	mov	ecx, ebx
	mov	DWORD PTR _iCount$226530[esp+12], eax
	call	?GetNumLayers@CvPlotManager@@QBEHXZ	; CvPlotManager::GetNumLayers
	mov	ebp, eax

; 9647 : 			for (int iIndex = 0; iIndex < iNumLayers; ++iIndex)

	xor	esi, esi
	test	ebp, ebp
	jle	SHORT $LN2@getNumLaye
	npad	4
$LL4@getNumLaye:

; 9648 : 			{		
; 9649 : 				iCount += kManager.GetNumUnitsByIndex(m_iX, m_iY, iIndex);

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	push	esi
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z ; CvPlotManager::GetNumUnitsByIndex
	add	DWORD PTR _iCount$226530[esp+12], eax
	inc	esi
	cmp	esi, ebp
	jl	SHORT $LL4@getNumLaye
$LN2@getNumLaye:

; 9650 : 			}
; 9651 : 			return iCount;

	mov	eax, DWORD PTR _iCount$226530[esp+12]
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 9657 : 		}
; 9658 : }

	ret	4
$LN5@getNumLaye:

; 9652 : 		}
; 9653 : 		else
; 9654 : 		{
; 9655 : 			// Specific layer
; 9656 : 			return GC.getMap().plotManager().GetNumUnits(m_iX, m_iY, iLayerID);

	movsx	ecx, WORD PTR [edi]
	push	eax
	movsx	eax, WORD PTR [edi+2]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, 4184				; 00001058H
	call	?GetNumUnits@CvPlotManager@@QBEHHHI@Z	; CvPlotManager::GetNumUnits
	pop	edi

; 9657 : 		}
; 9658 : }

	ret	4
?getNumLayerUnits@CvPlot@@QBEHH@Z ENDP			; CvPlot::getNumLayerUnits
_TEXT	ENDS
PUBLIC	?getNumUnits@CvPlot@@QBEHXZ			; CvPlot::getNumUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnits@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getNumUnits@CvPlot@@QBEHXZ PROC			; CvPlot::getNumUnits, COMDAT
; _this$ = ecx

; 9708 : 	return m_units.getLength();

	mov	eax, DWORD PTR [ecx+28]

; 9709 : }

	ret	0
?getNumUnits@CvPlot@@QBEHXZ ENDP			; CvPlot::getNumUnits
_TEXT	ENDS
PUBLIC	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z	; CvPlot::nextUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z PROC	; CvPlot::nextUnitNode, COMDAT
; _this$ = ecx

; 9874 : 	return m_units.next(pNode);

	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	add	eax, 8
	sar	eax, 3
	cmp	eax, DWORD PTR [ecx+28]
	jae	SHORT $LN8@nextUnitNo
	lea	eax, DWORD PTR [edx+eax*8]

; 9875 : }

	ret	4

; 9874 : 	return m_units.next(pNode);

$LN8@nextUnitNo:
	xor	eax, eax

; 9875 : }

	ret	4
?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ENDP	; CvPlot::nextUnitNode
_TEXT	ENDS
PUBLIC	?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z	; CvPlot::prevUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z PROC	; CvPlot::prevUnitNode, COMDAT
; _this$ = ecx

; 9886 : 	return m_units.prev(pNode);

	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	sub	eax, 8
	sar	eax, 3
	cmp	eax, DWORD PTR [ecx+28]
	jae	SHORT $LN8@prevUnitNo
	lea	eax, DWORD PTR [edx+eax*8]

; 9887 : }

	ret	4

; 9886 : 	return m_units.prev(pNode);

$LN8@prevUnitNo:
	xor	eax, eax

; 9887 : }

	ret	4
?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ENDP	; CvPlot::prevUnitNode
_TEXT	ENDS
PUBLIC	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ		; CvPlot::headUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ PROC		; CvPlot::headUnitNode, COMDAT
; _this$ = ecx

; 9898 : 	return m_units.head();

	cmp	DWORD PTR [ecx+28], 0
	jbe	SHORT $LN4@headUnitNo
	mov	eax, DWORD PTR [ecx+24]

; 9899 : }

	ret	0

; 9898 : 	return m_units.head();

$LN4@headUnitNo:
	xor	eax, eax

; 9899 : }

	ret	0
?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ ENDP		; CvPlot::headUnitNode
_TEXT	ENDS
PUBLIC	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ		; CvPlot::headUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ PROC		; CvPlot::headUnitNode, COMDAT
; _this$ = ecx

; 9904 : 	return m_units.head();

	cmp	DWORD PTR [ecx+28], 0
	jbe	SHORT $LN4@headUnitNo@2
	mov	eax, DWORD PTR [ecx+24]

; 9905 : }

	ret	0

; 9904 : 	return m_units.head();

$LN4@headUnitNo@2:
	xor	eax, eax

; 9905 : }

	ret	0
?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ ENDP		; CvPlot::headUnitNode
_TEXT	ENDS
PUBLIC	?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ		; CvPlot::tailUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ PROC		; CvPlot::tailUnitNode, COMDAT
; _this$ = ecx

; 9910 : 	return m_units.tail();

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	jbe	SHORT $LN4@tailUnitNo
	mov	ecx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [ecx+eax*8-8]

; 9911 : }

	ret	0

; 9910 : 	return m_units.tail();

$LN4@tailUnitNo:
	xor	eax, eax

; 9911 : }

	ret	0
?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ ENDP		; CvPlot::tailUnitNode
_TEXT	ENDS
PUBLIC	?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ		; CvPlot::tailUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ PROC		; CvPlot::tailUnitNode, COMDAT
; _this$ = ecx

; 9916 : 	return m_units.tail();

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	jbe	SHORT $LN4@tailUnitNo@2
	mov	ecx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [ecx+eax*8-8]

; 9917 : }

	ret	0

; 9916 : 	return m_units.tail();

$LN4@tailUnitNo@2:
	xor	eax, eax

; 9917 : }

	ret	0
?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ ENDP		; CvPlot::tailUnitNode
_TEXT	ENDS
PUBLIC	?getScriptData@CvPlot@@QBE?AVCvString@@XZ	; CvPlot::getScriptData
; Function compile flags: /Ogtpy
;	COMDAT ?getScriptData@CvPlot@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T233178 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getScriptData@CvPlot@@QBE?AVCvString@@XZ PROC		; CvPlot::getScriptData, COMDAT
; _this$ = ecx

; 9941 : {

	push	ecx

; 9942 : 	CvString scriptData = (m_szScriptData != NULL)? m_szScriptData : "";

	mov	eax, DWORD PTR [ecx+180]
	mov	DWORD PTR $T233178[esp+4], 0
	test	eax, eax
	jne	SHORT $LN4@getScriptD
	mov	eax, OFFSET $SG226739
$LN4@getScriptD:
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 9943 : 	return scriptData;

	mov	eax, esi
	pop	esi

; 9944 : }

	pop	ecx
	ret	4
?getScriptData@CvPlot@@QBE?AVCvString@@XZ ENDP		; CvPlot::getScriptData
_TEXT	ENDS
PUBLIC	?setScriptData@CvPlot@@QAEXPBD@Z		; CvPlot::setScriptData
EXTRN	__imp___strdup:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?setScriptData@CvPlot@@QAEXPBD@Z
_TEXT	SEGMENT
_szNewValue$ = 8					; size = 4
?setScriptData@CvPlot@@QAEXPBD@Z PROC			; CvPlot::setScriptData, COMDAT
; _this$ = ecx

; 9948 : {

	push	esi
	mov	esi, ecx

; 9949 : 	SAFE_DELETE_ARRAY(m_szScriptData);

	mov	eax, DWORD PTR [esi+180]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 9950 : 	m_szScriptData = _strdup(szNewValue);

	mov	ecx, DWORD PTR _szNewValue$[esp+4]
	push	ecx
	mov	DWORD PTR [esi+180], 0
	call	DWORD PTR __imp___strdup
	add	esp, 8
	mov	DWORD PTR [esi+180], eax
	pop	esi

; 9951 : }

	ret	4
?setScriptData@CvPlot@@QAEXPBD@Z ENDP			; CvPlot::setScriptData
_TEXT	ENDS
PUBLIC	?setLayoutDirty@CvPlot@@QAEX_N@Z		; CvPlot::setLayoutDirty
; Function compile flags: /Ogtpy
;	COMDAT ?setLayoutDirty@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bDirty$ = 8						; size = 1
?setLayoutDirty@CvPlot@@QAEX_N@Z PROC			; CvPlot::setLayoutDirty, COMDAT
; _this$ = ecx

; 10430: {

	push	ebx

; 10431: 	if(bDirty == true)

	mov	bl, BYTE PTR _bDirty$[esp]
	push	esi
	mov	esi, ecx
	cmp	bl, 1
	jne	SHORT $LN1@setLayoutD

; 10432: 	{
; 10433: 		GC.GetEngineUserInterface()->setDirty(PlotData_DIRTY_BIT,true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	33					; 00000021H
	call	edx
$LN1@setLayoutD:

; 10434: 	}
; 10435: 	m_bPlotLayoutDirty = bDirty;

	mov	al, BYTE PTR [esi+462]
	xor	al, bl
	and	al, 1
	xor	BYTE PTR [esi+462], al
	pop	esi
	pop	ebx

; 10436: }

	ret	4
?setLayoutDirty@CvPlot@@QAEX_N@Z ENDP			; CvPlot::setLayoutDirty
_TEXT	ENDS
PUBLIC	?isLayoutStateDifferent@CvPlot@@QBE_NXZ		; CvPlot::isLayoutStateDifferent
; Function compile flags: /Ogtpy
;	COMDAT ?isLayoutStateDifferent@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isLayoutStateDifferent@CvPlot@@QBE_NXZ PROC		; CvPlot::isLayoutStateDifferent, COMDAT
; _this$ = ecx

; 10612: {

	push	esi
	mov	esi, ecx

; 10613: 	return (m_bLayoutStateWorked != isBeingWorked());

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@isLayoutSt
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	jmp	SHORT $LN4@isLayoutSt
$LN3@isLayoutSt:
	xor	al, al
$LN4@isLayoutSt:
	mov	dl, BYTE PTR [esi+462]
	shr	dl, 1
	and	dl, 1
	xor	ecx, ecx
	cmp	dl, al
	setne	cl
	mov	al, cl
	pop	esi

; 10614: }

	ret	0
?isLayoutStateDifferent@CvPlot@@QBE_NXZ ENDP		; CvPlot::isLayoutStateDifferent
_TEXT	ENDS
PUBLIC	?setLayoutStateToCurrent@CvPlot@@QAEXXZ		; CvPlot::setLayoutStateToCurrent
; Function compile flags: /Ogtpy
;	COMDAT ?setLayoutStateToCurrent@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?setLayoutStateToCurrent@CvPlot@@QAEXXZ PROC		; CvPlot::setLayoutStateToCurrent, COMDAT
; _this$ = ecx

; 10618: {

	push	esi
	mov	esi, ecx

; 10619: 	m_bLayoutStateWorked = isBeingWorked();

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@setLayoutS
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	add	al, al
	xor	al, BYTE PTR [esi+462]
	and	al, 2
	xor	BYTE PTR [esi+462], al
	pop	esi

; 10620: }

	ret	0

; 10619: 	m_bLayoutStateWorked = isBeingWorked();

$LN3@setLayoutS:
	xor	al, al
	mov	al, al
	xor	al, BYTE PTR [esi+462]
	and	al, 2
	xor	BYTE PTR [esi+462], al
	pop	esi

; 10620: }

	ret	0
?setLayoutStateToCurrent@CvPlot@@QAEXXZ ENDP		; CvPlot::setLayoutStateToCurrent
_TEXT	ENDS
PUBLIC	?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::countNumAirUnits
EXTRN	?GetAirUnitCap@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetAirUnitCap
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?isCargo@CvUnit@@QBE_NXZ:PROC			; CvUnit::isCargo
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
; Function compile flags: /Ogtpy
;	COMDAT ?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::countNumAirUnits, COMDAT
; _this$ = ecx

; 11113: {

	push	ecx
	push	ebx

; 11114: 	int iCount = 0;

	xor	eax, eax
	mov	ebx, ecx
	push	esi
	mov	DWORD PTR _iCount$[esp+12], eax

; 11115: 
; 11116: 	const IDInfo* pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], eax
	jbe	SHORT $LN9@countNumAi
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN8@countNumAi
$LN9@countNumAi:
	xor	esi, esi
$LN8@countNumAi:

; 11117: 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN2@countNumAi
	push	ebp

; 11120: 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ebp, DWORD PTR _eTeam$[esp+12]
	push	edi
$LL3@countNumAi:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN16@countNumAi

; 11118: 	{
; 11119: 		const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	cmp	eax, 64					; 00000040H
	jge	SHORT $LN16@countNumAi
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN17@countNumAi
$LN16@countNumAi:
	xor	edi, edi
$LN17@countNumAi:

; 11120: 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN28@countNumAi
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN27@countNumAi
$LN28@countNumAi:
	xor	esi, esi
$LN27@countNumAi:

; 11121: 
; 11122: 		if(pLoopUnit && DOMAIN_AIR == pLoopUnit->getDomainType() && !pLoopUnit->isCargo() && pLoopUnit->getTeam() == eTeam)

	test	edi, edi
	je	SHORT $LN37@countNumAi
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN37@countNumAi
	mov	ecx, edi
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	test	al, al
	jne	SHORT $LN37@countNumAi
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, ebp
	jne	SHORT $LN37@countNumAi

; 11123: 		{
; 11124: 			iCount += pLoopUnit->getUnitInfo().GetAirUnitCap();

	mov	ecx, edi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetAirUnitCap@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetAirUnitCap
	add	DWORD PTR _iCount$[esp+20], eax
$LN37@countNumAi:

; 11117: 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL3@countNumAi

; 11125: 		}
; 11126: 	}
; 11127: 
; 11128: 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+20]
	pop	edi
	pop	ebp
$LN2@countNumAi:
	pop	esi
	pop	ebx

; 11129: }

	pop	ecx
	ret	4
?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::countNumAirUnits
_TEXT	ENDS
PUBLIC	?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::debugDump
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0
__ehfuncinfo$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T233334 = -24						; size = 4
_gameTurnBuffer$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; CvPlot::debugDump, COMDAT
; _this$ = ecx

; 11239: {

	push	-1
	push	__ehhandler$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T233334[esp+32], ebx

; 11240: 	std::string result = "Game Turn : ";

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	push	OFFSET $SG227365
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+44], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 11241: 	char gameTurnBuffer[8] = {0};
; 11242: 	int gameTurn = GC.getGame().getGameTurn();
; 11243: 	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);
; 11244: 	result += gameTurnBuffer;
; 11245: 	return result;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	mov	DWORD PTR $T233334[esp+32], 1
	mov	BYTE PTR _gameTurnBuffer$[esp+32], bl
	mov	DWORD PTR _gameTurnBuffer$[esp+33], eax
	mov	WORD PTR _gameTurnBuffer$[esp+37], ax
	mov	BYTE PTR _gameTurnBuffer$[esp+39], al
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	eax, DWORD PTR _gameTurnBuffer$[esp+36]
	push	OFFSET $SG227373
	push	eax
	call	??$sprintf_s@$07@@YAHAAY07DPBDZZ	; sprintf_s<8>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _gameTurnBuffer$[esp+32]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 11246: }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0:
	mov	eax, DWORD PTR $T233334[ebp]
	and	eax, 1
	je	$LN4@debugDump@2
	and	DWORD PTR $T233334[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@debugDump@2:
	ret	0
__ehhandler$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; CvPlot::debugDump
PUBLIC	?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::stackTraceRemark
; Function compile flags: /Ogtpy
;	COMDAT ?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T233350 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_var$ = 12						; size = 4
?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; CvPlot::stackTraceRemark, COMDAT
; _this$ = ecx

; 11250: {

	push	ecx

; 11251: 	return debugDump(var);

	mov	eax, DWORD PTR _var$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	eax
	push	esi
	mov	DWORD PTR $T233350[esp+16], 0
	call	?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::debugDump
	mov	eax, esi
	pop	esi

; 11252: }

	pop	ecx
	ret	8
?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; CvPlot::stackTraceRemark
_TEXT	ENDS
PUBLIC	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Ogtpy
;	COMDAT ?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC ; CvPlot::MustPayMaintenanceHere, COMDAT
; _this$ = ecx

; 11307: 	if(isHills() && GET_PLAYER(ePlayer).GetPlayerTraits()->IsNoHillsImprovementMaintenance())

	cmp	BYTE PTR [ecx+5], 1
	jne	SHORT $LN1@MustPayMai
	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	je	SHORT $LN1@MustPayMai

; 11308: 	{
; 11309: 		return false;

	xor	al, al

; 11313: }

	ret	4
$LN1@MustPayMai:

; 11310: 	}
; 11311: 
; 11312: 	return true;

	mov	al, 1

; 11313: }

	ret	4
?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP ; CvPlot::MustPayMaintenanceHere
_TEXT	ENDS
PUBLIC	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z ; CvPlot::AddArchaeologicalRecord
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?IsArchaeologyTriggered@CvGame@@QBE_NXZ:PROC	; CvGame::IsArchaeologyTriggered
; Function compile flags: /Ogtpy
;	COMDAT ?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
_ePlayer1$ = 12						; size = 4
_ePlayer2$ = 16						; size = 4
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z PROC ; CvPlot::AddArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11317: {

	push	esi
	mov	esi, ecx

; 11318: 	// Make sure the new record is more significant
; 11319: 	if (!GC.getGame().IsArchaeologyTriggered() && eType > m_kArchaeologyData.m_eArtifactType)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?IsArchaeologyTriggered@CvGame@@QBE_NXZ	; CvGame::IsArchaeologyTriggered
	test	al, al
	jne	SHORT $LN1@AddArchaeo
	mov	ecx, DWORD PTR _eType$[esp]
	cmp	ecx, DWORD PTR [esi+464]
	jle	SHORT $LN1@AddArchaeo

; 11320: 	{
; 11321: 		if (ePlayer1 != NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer1$[esp]
	cmp	eax, -1
	je	SHORT $LN1@AddArchaeo

; 11322: 		{
; 11323: 			m_kArchaeologyData.m_eArtifactType = eType;
; 11324: 			m_kArchaeologyData.m_ePlayer1 = ePlayer1;

	mov	DWORD PTR [esi+472], eax

; 11325: 			m_kArchaeologyData.m_ePlayer2 = ePlayer2;
; 11326: 			m_kArchaeologyData.m_eEra = GET_PLAYER(ePlayer1).GetCurrentEra();

	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR [esi+464], ecx
	mov	ecx, DWORD PTR _ePlayer2$[esp]
	mov	DWORD PTR [esi+476], ecx
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	DWORD PTR [esi+468], eax
$LN1@AddArchaeo:
	pop	esi

; 11327: 		}
; 11328: 	}
; 11329: }

	ret	12					; 0000000cH
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z ENDP ; CvPlot::AddArchaeologicalRecord
_TEXT	ENDS
PUBLIC	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z ; CvPlot::AddArchaeologicalRecord
; Function compile flags: /Ogtpy
;	COMDAT ?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
_eEra$ = 12						; size = 4
_ePlayer1$ = 16						; size = 4
_ePlayer2$ = 20						; size = 4
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z PROC ; CvPlot::AddArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11333: {

	push	esi
	mov	esi, ecx

; 11334: 	// Make sure the new record is more significant
; 11335: 	if (!GC.getGame().IsArchaeologyTriggered() && eType > m_kArchaeologyData.m_eArtifactType)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?IsArchaeologyTriggered@CvGame@@QBE_NXZ	; CvGame::IsArchaeologyTriggered
	test	al, al
	jne	SHORT $LN1@AddArchaeo@2
	mov	eax, DWORD PTR _eType$[esp]
	cmp	eax, DWORD PTR [esi+464]
	jle	SHORT $LN1@AddArchaeo@2

; 11336: 	{
; 11337: 		if (ePlayer1 != NO_PLAYER)

	mov	ecx, DWORD PTR _ePlayer1$[esp]
	cmp	ecx, -1
	je	SHORT $LN1@AddArchaeo@2

; 11338: 		{
; 11339: 			m_kArchaeologyData.m_eArtifactType = eType;

	mov	DWORD PTR [esi+464], eax

; 11340: 			m_kArchaeologyData.m_ePlayer1 = ePlayer1;
; 11341: 			m_kArchaeologyData.m_ePlayer2 = ePlayer2;

	mov	eax, DWORD PTR _ePlayer2$[esp]
	mov	DWORD PTR [esi+472], ecx

; 11342: 			m_kArchaeologyData.m_eEra = eEra;

	mov	ecx, DWORD PTR _eEra$[esp]
	mov	DWORD PTR [esi+476], eax
	mov	DWORD PTR [esi+468], ecx
$LN1@AddArchaeo@2:
	pop	esi

; 11343: 		}
; 11344: 	}
; 11345: }

	ret	16					; 00000010H
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z ENDP ; CvPlot::AddArchaeologicalRecord
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@4

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@4:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@4

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@4:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@PBVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QBEABV0@PBVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@PBVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 180  : 	{

	push	esi
	mov	esi, ecx

; 181  : 		OBJECT_HANDLE_STACK;
; 182  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@5

; 183  : 		{
; 184  : 			const_cast<PointingTo *>(m_target)->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@5:

; 185  : 		}
; 186  : 		const_cast<FObjectHandle *>(this)->m_target = const_cast<PointingTo *>(target);

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 187  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@5

; 188  : 		{
; 189  : 			const_cast<PointingTo *>(m_target)->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@5:

; 190  : 		}
; 191  : 		return *this;

	mov	eax, esi
	pop	esi

; 192  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@PBVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z	; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z PROC	; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 195  : 	{

	push	esi
	push	edi

; 196  : 		if(&rhs != this)

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	edi, esi
	je	SHORT $LN11@operator@6

; 197  : 		{
; 198  : 			OBJECT_HANDLE_STACK;
; 199  : 			if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@operator@6

; 200  : 			{
; 201  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@operator@6:

; 202  : 			}
; 203  : 			const_cast<FObjectHandle *>(this)->m_target = rhs.m_target;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 204  : 			if(m_target)

	test	ecx, ecx
	je	SHORT $LN11@operator@6

; 205  : 			{
; 206  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@operator@6:
	pop	edi

; 207  : 			}
; 208  : 		}
; 209  : 		return *this;

	mov	eax, esi
	pop	esi

; 210  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z ENDP	; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@3

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@3:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UIDInfo@@$00@@QAEXXZ	; BaseVector<IDInfo,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@UIDInfo@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UIDInfo@@$00@@QAEXXZ PROC		; BaseVector<IDInfo,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UIDInfo@@$00@@QAEXXZ ENDP		; BaseVector<IDInfo,1>::clear
_TEXT	ENDS
PUBLIC	?nodeNum@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::nodeNum
; Function compile flags: /Ogtpy
;	COMDAT ?nodeNum@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?nodeNum@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::nodeNum, COMDAT
; _this$ = ecx

; 869  : 
; 870  :         return getAt( iIndex );

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN4@nodeNum
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 871  :     };

	ret	4

; 869  : 
; 870  :         return getAt( iIndex );

$LN4@nodeNum:
	xor	eax, eax

; 871  :     };

	ret	4
?nodeNum@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QBEPBUIDInfo@@H@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::nodeNum
_TEXT	ENDS
PUBLIC	?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::next
; Function compile flags: /Ogtpy
;	COMDAT ?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::next, COMDAT
; _this$ = ecx

; 914  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 915  : 		unsigned int iIndex = (pNode + 1) - &mVec[0];
; 916  : #else
; 917  :         INT iIndex = ( pNode + 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	add	eax, 8
	sar	eax, 3

; 918  : #endif
; 919  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@next@2
	lea	eax, DWORD PTR [edx+eax*8]

; 920  :     }

	ret	4

; 918  : #endif
; 919  :         return getAt( iIndex );

$LN6@next@2:
	xor	eax, eax

; 920  :     }

	ret	4
?next@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::next
_TEXT	ENDS
PUBLIC	?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::prev
; Function compile flags: /Ogtpy
;	COMDAT ?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::prev, COMDAT
; _this$ = ecx

; 925  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 926  : 		unsigned int iIndex = (pNode - 1) - &mVec[0];
; 927  : #else
; 928  :         INT iIndex = ( pNode - 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	sub	eax, 8
	sar	eax, 3

; 929  : #endif
; 930  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@prev@2
	lea	eax, DWORD PTR [edx+eax*8]

; 931  :     }

	ret	4

; 929  : #endif
; 930  :         return getAt( iIndex );

$LN6@prev@2:
	xor	eax, eax

; 931  :     }

	ret	4
?prev@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::prev
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEABQAVCvPlot@@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEABQAVCvPlot@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEABQAVCvPlot@@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEABQAVCvPlot@@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEAAPAVCvPlot@@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEAAPAVCvPlot@@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEAAPAVCvPlot@@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEAAPAVCvPlot@@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ; FFastSmallFixedList<IDInfo,25,1,297,0>::next
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::next, COMDAT
; _this$ = ecx

; 914  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 915  : 		unsigned int iIndex = (pNode + 1) - &mVec[0];
; 916  : #else
; 917  :         INT iIndex = ( pNode + 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	add	eax, 8
	sar	eax, 3

; 918  : #endif
; 919  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@next@3
	lea	eax, DWORD PTR [edx+eax*8]

; 920  :     }

	ret	4

; 918  : #endif
; 919  :         return getAt( iIndex );

$LN6@next@3:
	xor	eax, eax

; 920  :     }

	ret	4
?next@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::next
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::FStaticVector<IDInfo,50,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,50,1,297,0>::FStaticVector<IDInfo,50,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 50			; 00000032H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,50,1,297,0>::FStaticVector<IDInfo,50,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@XZ ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::~_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@XZ PROC ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::~_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@XZ ENDP ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::~_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAABQAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAABQAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAABQAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAABQAVCvPlot@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Root
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z PROC ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 25			; 00000019H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ; FStaticVector<IDInfo,25,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ; FStaticVector<IDInfo,50,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,50,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,50,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z ; FStaticVector<CvPlot *,1000,1,297,1>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@3:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXPAPAVCvPlot@@I@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::Free
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange
; Function compile flags: /Ogtpy
;	COMDAT ?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange, COMDAT
; _this$ = ecx

; 1133 : 		_Nodeptr _Pnode = _Root();

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]

; 1134 : 		_Nodeptr _Lonode = _Myhead;	// end() if search fails
; 1135 : 		_Nodeptr _Hinode = _Myhead;	// end() if search fails
; 1136 : 
; 1137 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Keyval$[esp+4]
	mov	ebx, edx
	jne	SHORT $LN8@Eqrange
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebp]
	npad	7
$LL9@Eqrange:

; 1138 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	esi, DWORD PTR [eax+12]
	cmp	esi, edi
	jae	SHORT $LN7@Eqrange

; 1139 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1140 : 			else

	jmp	SHORT $LN6@Eqrange
$LN7@Eqrange:

; 1141 : 				{	// _Pnode not less than _Keyval, remember it
; 1142 : 				if (_Isnil(_Hinode)
; 1143 : 						&& _DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	cmp	BYTE PTR [edx+17], 0
	je	SHORT $LN5@Eqrange
	cmp	edi, esi
	jae	SHORT $LN5@Eqrange

; 1144 : 					_Hinode = _Pnode;	// _Pnode greater, remember it

	mov	edx, eax
$LN5@Eqrange:

; 1145 : 				_Lonode = _Pnode;

	mov	ebx, eax

; 1146 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
$LN6@Eqrange:

; 1134 : 		_Nodeptr _Lonode = _Myhead;	// end() if search fails
; 1135 : 		_Nodeptr _Hinode = _Myhead;	// end() if search fails
; 1136 : 
; 1137 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL9@Eqrange
	pop	edi
	pop	esi
$LN8@Eqrange:

; 1147 : 				}
; 1148 : 
; 1149 : 		_Pnode = _Isnil(_Hinode) ? _Root()
; 1150 : 			: _Left(_Hinode);	// continue scan for upper bound

	cmp	BYTE PTR [edx+17], 0
	je	SHORT $LN12@Eqrange
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN13@Eqrange
$LN12@Eqrange:
	mov	eax, DWORD PTR [edx]
$LN13@Eqrange:

; 1151 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Eqrange
	mov	ecx, DWORD PTR [ebp]
	npad	3
$LL4@Eqrange:

; 1152 : 			if (_DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN2@Eqrange

; 1153 : 				{	// _Pnode greater than _Keyval, remember it
; 1154 : 				_Hinode = _Pnode;

	mov	edx, eax

; 1155 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]

; 1156 : 				}
; 1157 : 			else

	jmp	SHORT $LN1@Eqrange
$LN2@Eqrange:

; 1158 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN1@Eqrange:

; 1151 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL4@Eqrange
$LN3@Eqrange:

; 1159 : 
; 1160 : 		iterator _First = _TREE_ITERATOR(_Lonode);
; 1161 : 		iterator _Last = _TREE_ITERATOR(_Hinode);
; 1162 : 		return (_Pairii(_First, _Last));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edx
	pop	ebx

; 1163 : 		}

	ret	8
?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate@2:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@2:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@2:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 76695844				; 04924924H

; 732  : 		}

	ret	0
?max_size@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@I@Z ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 25					; 00000019H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 25			; 00000019H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+212], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEPAUIDInfo@@I@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEPAUIDInfo@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEPAUIDInfo@@I@Z PROC ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@5

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@5:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEPAUIDInfo@@I@Z ENDP ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXPAUIDInfo@@I@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXPAUIDInfo@@I@Z PROC ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXPAUIDInfo@@I@Z ENDP ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

	mov	eax, ecx

; 39   : 		}

	ret	8
??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T234174 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T234174[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 503  : 	text << arg1;

	mov	edx, DWORD PTR _arg1$[esp+108]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 504  : 
; 505  : 	size_t bytes = 0;
; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 507  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 508  : 	str.assign(szComposedString, bytes);
; 509  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T234174[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	mov	eax, DWORD PTR $T234174[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@2
	and	DWORD PTR $T234174[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T234194 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T234194[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 517  : 
; 518  : 	size_t bytes = 0;
; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[esp+116]
	push	eax
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 520  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 521  : 	str.assign(szComposedString, bytes);
; 522  : 	return str;

	mov	ecx, DWORD PTR _bytes$[esp+112]
	push	ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T234194[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	mov	eax, DWORD PTR $T234194[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@3
	and	DWORD PTR $T234194[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
PUBLIC	??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ PROC ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ENDP ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$0
__ehfuncinfo$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T234223 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z PROC ; GetLocalizedText<char const *,int,char const *>, COMDAT

; 527  : {

	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 528  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T234223[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 529  : 	text << arg1 << arg2 << arg3;

	mov	edx, DWORD PTR _arg1$[esp+108]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], 1
	call	esi
	mov	ecx, DWORD PTR _arg2$[esp+108]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z
	mov	eax, DWORD PTR _arg3$[esp+108]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR _text$[esp+116]
	call	esi

; 530  : 
; 531  : 	size_t bytes = 0;
; 532  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 533  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 534  : 	str.assign(szComposedString, bytes);
; 535  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T234223[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$1:
	mov	eax, DWORD PTR $T234223[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz@4
	and	DWORD PTR $T234223[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz@4:
	ret	0
__ehhandler$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z:
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ENDP ; GetLocalizedText<char const *,int,char const *>
PUBLIC	??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z ; operator>><short [1],80>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z PROC ; operator>><short [1],80>, COMDAT

; 234  : {

	push	ebx
	push	esi

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	mov	ebx, 80					; 00000050H
$LL3@operator@7:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read
	add	esi, 2
	sub	ebx, 1
	jne	SHORT $LL3@operator@7

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z ENDP ; operator>><short [1],80>
_TEXT	ENDS
PUBLIC	??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z ; operator<<<short const [1],80>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z PROC ; operator<<<short const [1],80>, COMDAT

; 223  : {

	push	ebx
	push	esi

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	mov	ebx, 80					; 00000050H
$LL3@operator@8:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	add	esi, 2
	sub	ebx, 1
	jne	SHORT $LL3@operator@8

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z ENDP ; operator<<<short const [1],80>
_TEXT	ENDS
PUBLIC	??_G?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAEPAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1173 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1174 : 	}

	ret	0

; 1173 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1174 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 197  : 		if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN3@isVisible
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN3@isVisible

; 198  : 			return true;

	mov	al, 1
	pop	esi

; 205  : 		}
; 206  : 	}

	ret	8
$LN3@isVisible:

; 199  : 		else
; 200  : 		{
; 201  : 			if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 202  : 				return false;

	xor	al, al
	pop	esi

; 205  : 		}
; 206  : 	}

	ret	8
$LN1@isVisible:

; 203  : 
; 204  : 			return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [esi+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	pop	esi
	setg	dl
	mov	al, dl

; 205  : 		}
; 206  : 	}

	ret	8
?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible@2

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible@2:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 612  : 		if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN1@isRevealed
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN1@isRevealed

; 613  : 			return true;

	mov	al, 1
	pop	esi

; 617  : 	}

	ret	8
$LN1@isRevealed:

; 614  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 615  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 616  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp]
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	pop	esi
	setne	al

; 617  : 	}

	ret	8
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotCheckInvalid
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z PROC	; CvMap::plotCheckInvalid, COMDAT
; _this$ = ecx

; 282  : 	{

	push	esi

; 283  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	esi, DWORD PTR _iX$[esp]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI
	mov	edx, DWORD PTR _iY$[esp]
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI

; 286  : 		}
; 287  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, edx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	esi

; 288  : 	}

	ret	8
$LN1@plotCheckI:

; 284  : 		{
; 285  : 			return NULL;

	xor	eax, eax
	pop	esi

; 288  : 	}

	ret	8
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z ENDP	; CvMap::plotCheckInvalid
_TEXT	ENDS
PUBLIC	?GetResourceQuantityModifier@CvPlayerTraits@@QBEHW4ResourceTypes@@@Z ; CvPlayerTraits::GetResourceQuantityModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetResourceQuantityModifier@CvPlayerTraits@@QBEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
?GetResourceQuantityModifier@CvPlayerTraits@@QBEHW4ResourceTypes@@@Z PROC ; CvPlayerTraits::GetResourceQuantityModifier, COMDAT
; _this$ = ecx

; 869  : 		return ((uint)eResource < m_aiResourceQuantityModifier.size())?m_aiResourceQuantityModifier[(int)eResource]:0;

	mov	edx, DWORD PTR [ecx+612]
	sub	edx, DWORD PTR [ecx+608]
	mov	eax, DWORD PTR _eResource$[esp-4]
	sar	edx, 2
	cmp	eax, edx
	jae	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR [ecx+608]
	mov	eax, DWORD PTR [ecx+eax*4]

; 870  : 	};

	ret	4
$LN3@GetResourc:

; 869  : 		return ((uint)eResource < m_aiResourceQuantityModifier.size())?m_aiResourceQuantityModifier[(int)eResource]:0;

	xor	eax, eax

; 870  : 	};

	ret	4
?GetResourceQuantityModifier@CvPlayerTraits@@QBEHW4ResourceTypes@@@Z ENDP ; CvPlayerTraits::GetResourceQuantityModifier
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchiveclasscontainer.h
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$1
__ehfuncinfo$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T234539 = -72						; size = 4
$T234535 = -68						; size = 28
$T234534 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_var$ = 12						; size = 4
?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::debugDump, COMDAT
; _this$ = ecx

; 75   : 	{

	push	-1
	push	__ehhandler$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH

; 76   : 		return std::string("\n") + m_classInstance.debugDump(var);

	mov	eax, DWORD PTR _var$[esp+68]
	push	esi
	push	eax
	lea	edx, DWORD PTR $T234534[esp+80]
	mov	DWORD PTR $T234539[esp+80], 0
	mov	ecx, DWORD PTR [ecx+32]
	push	edx
	call	?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::debugDump
	mov	esi, eax
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	lea	ecx, DWORD PTR $T234535[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	push	eax
	push	esi
	mov	BYTE PTR __$EHRec$[esp+96], 2
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR $T234535[esp+76]
	mov	DWORD PTR $T234539[esp+76], 1
	mov	BYTE PTR __$EHRec$[esp+84], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T234534[esp+76]
	mov	BYTE PTR __$EHRec$[esp+84], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 77   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T234534[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$1:
	lea	ecx, DWORD PTR $T234535[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$2:
	mov	eax, DWORD PTR $T234539[ebp]
	and	eax, 1
	je	$LN6@debugDump@3
	and	DWORD PTR $T234539[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@debugDump@3:
	ret	0
__ehhandler$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::debugDump
; Function compile flags: /Ogtpy
;	COMDAT ?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T234551 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_var$ = 12						; size = 4
?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::stackTraceRemark, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ecx

; 81   : 		return m_classInstance.stackTraceRemark(var);

	mov	eax, DWORD PTR _var$[esp]
	mov	ecx, DWORD PTR [ecx+32]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	eax
	push	esi
	mov	DWORD PTR $T234551[esp+16], 0
	call	?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::stackTraceRemark
	mov	eax, esi
	pop	esi

; 82   : 	}

	pop	ecx
	ret	8
?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::stackTraceRemark
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ ; std::vector<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ PROC ; std::vector<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ ENDP ; std::vector<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ ; std::vector<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ PROC ; std::vector<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@2@XZ ENDP ; std::vector<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::end
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate@2:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@2:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@2:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Rrotate@3

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate@3:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate@3

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate@3:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate@3

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate@3:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ; FStaticVector<IDInfo,8,1,297,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@4

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@4:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec@2:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN43@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN24@Dec@2
	npad	1
$LL25@Dec@2:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL25@Dec@2
$LN24@Dec@2:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec@2:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Dec@2
$LL4@Dec@2:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL4@Dec@2
$LN3@Dec@2:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN1@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec@2:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+45], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jae	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+45], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 134217727				; 07ffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+45], 0
	jne	SHORT $LN5@Lrotate@3

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate@3:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate@3

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate@3:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate@3

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate@3:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LN9@Dec@3

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec@3:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+45], 0
	jne	SHORT $LN43@Dec@3

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN24@Dec@3
	npad	1
$LL25@Dec@3:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL25@Dec@3
$LN24@Dec@3:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec@3:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN3@Dec@3
$LL4@Dec@3:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec@3

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL4@Dec@3
$LN3@Dec@3:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+45], 0
	jne	SHORT $LN1@Dec@3

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec@3:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN3@Inc@2

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+45], 0
	jne	SHORT $LN34@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN17@Inc@2
	npad	7
$LL18@Inc@2:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL18@Inc@2
$LN17@Inc@2:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc@2:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN1@Inc@2
$LL2@Inc@2:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL2@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc@2:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	eax, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Rarg$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Parg$[esp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	dl, BYTE PTR __Carg$[esp]
	mov	BYTE PTR [esi+44], dl
	mov	BYTE PTR [esi+45], 0

; 39   : 			}

	mov	eax, esi
	pop	esi
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
_TEXT	ENDS
;	COMDAT ?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::load, COMDAT
; _this$ = ecx

; 280  : 	loadFrom >> m_value;

	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[esp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 281  : }

	ret	4
?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::load
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::save, COMDAT
; _this$ = ecx

; 288  : 	saveTo << m_value;

	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 289  : }

	ret	4
?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::save
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_compareWith$ = 8					; size = 1
_otherValue$ = 8					; size = 4
?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::compare, COMDAT
; _this$ = ecx

; 335  : {

	push	esi

; 336  : 	ObjectType compareWith;
; 337  : 	otherValue >> compareWith;

	lea	eax, DWORD PTR _compareWith$[esp]
	mov	esi, ecx
	mov	ecx, DWORD PTR _otherValue$[esp]
	push	eax
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 338  : #if !defined(FINAL_RELEASE)
; 339  : 	m_remoteValue = compareWith;
; 340  : #endif
; 341  : 
; 342  : 	return m_value == compareWith;

	mov	cl, BYTE PTR [esi+4]
	xor	eax, eax
	cmp	cl, BYTE PTR _compareWith$[esp]
	pop	esi
	sete	al

; 343  : }

	ret	4
?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::compare
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::~_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::~_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::~_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@H@std@@YAXV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@H@std@@YAXV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@H@std@@YAXV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 2
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@H@std@@YAXV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,int>
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+16]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >::operator!=
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::~FFastSmallFixedList<IDInfo,8,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::~FFastSmallFixedList<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@FFastSmall
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@FFastSmall:
	ret	0
??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::~FFastSmallFixedList<IDInfo,8,1,297,0>
_TEXT	ENDS
PUBLIC	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ
_TEXT	SEGMENT
_bIsDebug$ = -4						; size = 1
?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ PROC ; CvPlot::GetActiveFogOfWarMode, COMDAT
; _this$ = ecx

; 531  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 532  : 	CvGame& Game = GC.getGame();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, ecx

; 533  : 	const TeamTypes activeTeam = Game.getActiveTeam();

	mov	ecx, edi
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam

; 534  : 	CvAssert(activeTeam != NO_TEAM);
; 535  : 
; 536  : 	FogOfWarModeTypes eFOWMode = FOGOFWARMODE_UNEXPLORED;
; 537  : 
; 538  : 	bool bIsDebug = Game.isDebugMode();

	mov	ecx, edi
	mov	esi, eax
	mov	ebp, 1
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	mov	BYTE PTR _bIsDebug$[esp+20], al

; 539  : 	if(bIsDebug || activeTeam != NO_TEAM)

	test	al, al
	jne	SHORT $LN15@GetActiveF
	cmp	esi, -1
	jne	SHORT $LN8@GetActiveF
$LN18@GetActiveF:
	pop	edi
	pop	esi

; 544  : 		}
; 545  : 	}
; 546  : 
; 547  : 	return eFOWMode;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 548  : }

	pop	ecx
	ret	0
$LN15@GetActiveF:

; 540  : 	{
; 541  : 		if(isRevealed(activeTeam, bIsDebug))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	jne	SHORT $LN16@GetActiveF
$LN8@GetActiveF:
	mov	eax, esi
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, esi
	sub	ecx, edx
	mov	edx, ebp
	shl	edx, cl
	test	edx, DWORD PTR [ebx+eax*4+8]
	setne	al
	test	al, al
	je	SHORT $LN18@GetActiveF
$LN16@GetActiveF:

; 542  : 		{
; 543  : 			eFOWMode = (isVisible(activeTeam, bIsDebug))? FOGOFWARMODE_OFF : FOGOFWARMODE_NOVIS;

	mov	eax, DWORD PTR _bIsDebug$[esp+20]
	push	eax
	push	esi
	mov	ecx, ebx
	call	?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isVisible
	movzx	eax, al
	neg	eax
	pop	edi
	sbb	eax, eax
	pop	esi
	and	eax, -2					; fffffffeH
	pop	ebp
	add	eax, 2
	pop	ebx

; 548  : }

	pop	ecx
	ret	0
?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ENDP ; CvPlot::GetActiveFogOfWarMode
_TEXT	ENDS
PUBLIC	?isAdjacentToArea@CvPlot@@QBE_NH@Z		; CvPlot::isAdjacentToArea
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentToArea@CvPlot@@QBE_NH@Z
_TEXT	SEGMENT
_iAreaID$ = 8						; size = 4
?isAdjacentToArea@CvPlot@@QBE_NH@Z PROC			; CvPlot::isAdjacentToArea, COMDAT
; _this$ = ecx

; 827  : {

	push	ebx

; 828  : 
; 829  : 	CvPlot* pAdjacentPlot;
; 830  : 	int iI;
; 831  : 
; 832  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx]
	push	ebp
	mov	ebp, DWORD PTR _iAreaID$[esp+4]
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
$LL5@isAdjacent:

; 833  : 	{
; 834  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 835  : 
; 836  : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent

; 837  : 		{
; 838  : 			if(pAdjacentPlot->getArea() == iAreaID)

	cmp	DWORD PTR [eax+356], ebp
	je	SHORT $LN15@isAdjacent
$LN4@isAdjacent:

; 828  : 
; 829  : 	CvPlot* pAdjacentPlot;
; 830  : 	int iI;
; 831  : 
; 832  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@isAdjacent
	pop	edi
	pop	esi
	pop	ebp

; 841  : 			}
; 842  : 		}
; 843  : 	}
; 844  : 
; 845  : 	return false;

	xor	al, al
	pop	ebx

; 846  : }

	ret	4
$LN15@isAdjacent:
	pop	edi
	pop	esi
	pop	ebp

; 839  : 			{
; 840  : 				return true;

	mov	al, 1
	pop	ebx

; 846  : }

	ret	4
?isAdjacentToArea@CvPlot@@QBE_NH@Z ENDP			; CvPlot::isAdjacentToArea
_TEXT	ENDS
PUBLIC	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z	; CvPlot::isAdjacentToArea
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z
_TEXT	SEGMENT
_pArea$ = 8						; size = 4
?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z PROC	; CvPlot::isAdjacentToArea, COMDAT
; _this$ = ecx

; 851  : 	return isAdjacentToArea(pArea->GetID());

	mov	eax, DWORD PTR _pArea$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _pArea$[esp-4], edx
	jmp	?isAdjacentToArea@CvPlot@@QBE_NH@Z	; CvPlot::isAdjacentToArea
?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z ENDP	; CvPlot::isAdjacentToArea
_TEXT	ENDS
PUBLIC	?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z		; CvPlot::shareAdjacentArea
; Function compile flags: /Ogtpy
;	COMDAT ?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z
_TEXT	SEGMENT
tv135 = -4						; size = 4
_pPlot$ = 8						; size = 4
?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z PROC		; CvPlot::shareAdjacentArea, COMDAT
; _this$ = ecx

; 857  : {

	push	ecx

; 858  : 	int iCurrArea;
; 859  : 	int iLastArea;
; 860  : 	CvPlot* pAdjacentPlot;
; 861  : 	int iI;
; 862  : 
; 863  : 	iLastArea = FFreeList::INVALID_INDEX;
; 864  : 
; 865  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	eax, WORD PTR [ecx]
	push	ebx
	push	ebp
	movsx	ebp, WORD PTR [ecx+2]
	push	esi
	push	edi
	or	ebx, -1
	xor	edi, edi
	mov	DWORD PTR tv135[esp+20], eax
$LL19@shareAdjac:

; 866  : 	{
; 867  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR tv135[esp+20]
	push	edi
	push	ebp
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 868  : 
; 869  : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN5@shareAdjac

; 870  : 		{
; 871  : 			iCurrArea = pAdjacentPlot->getArea();

	mov	esi, DWORD PTR [eax+356]

; 872  : 
; 873  : 			if(iCurrArea != iLastArea)

	cmp	esi, ebx
	je	SHORT $LN5@shareAdjac

; 874  : 			{
; 875  : 				if(pPlot->isAdjacentToArea(iCurrArea))

	mov	ecx, DWORD PTR _pPlot$[esp+16]
	push	esi
	call	?isAdjacentToArea@CvPlot@@QBE_NH@Z	; CvPlot::isAdjacentToArea
	test	al, al
	jne	SHORT $LN16@shareAdjac

; 878  : 				}
; 879  : 
; 880  : 				iLastArea = iCurrArea;

	mov	ebx, esi
$LN5@shareAdjac:

; 858  : 	int iCurrArea;
; 859  : 	int iLastArea;
; 860  : 	CvPlot* pAdjacentPlot;
; 861  : 	int iI;
; 862  : 
; 863  : 	iLastArea = FFreeList::INVALID_INDEX;
; 864  : 
; 865  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL19@shareAdjac
	pop	edi
	pop	esi
	pop	ebp

; 881  : 			}
; 882  : 		}
; 883  : 	}
; 884  : 
; 885  : 	return false;

	xor	al, al
	pop	ebx

; 886  : }

	pop	ecx
	ret	4
$LN16@shareAdjac:
	pop	edi
	pop	esi
	pop	ebp

; 876  : 				{
; 877  : 					return true;

	mov	al, 1
	pop	ebx

; 886  : }

	pop	ecx
	ret	4
?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z ENDP		; CvPlot::shareAdjacentArea
_TEXT	ENDS
PUBLIC	?isAdjacent@CvPlot@@QBE_NPBV1@@Z		; CvPlot::isAdjacent
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacent@CvPlot@@QBE_NPBV1@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?isAdjacent@CvPlot@@QBE_NPBV1@@Z PROC			; CvPlot::isAdjacent, COMDAT
; _this$ = ecx

; 890  : {

	push	ebp

; 891  : 	if(pPlot == NULL)

	mov	ebp, DWORD PTR _pPlot$[esp]
	test	ebp, ebp
	jne	SHORT $LN5@isAdjacent@2

; 892  : 	{
; 893  : 		return false;

	xor	al, al
	pop	ebp

; 910  : }

	ret	4
$LN5@isAdjacent@2:
	push	ebx

; 894  : 	}
; 895  : 
; 896  : 	CvPlot* pAdjacentPlot;
; 897  : 	int iI;
; 898  : 
; 899  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx]
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
	npad	5
$LL4@isAdjacent@2:

; 900  : 	{
; 901  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 902  : 
; 903  : 		if(pAdjacentPlot == pPlot)

	cmp	eax, ebp
	je	SHORT $LN13@isAdjacent@2
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL4@isAdjacent@2
	pop	edi
	pop	esi
	pop	ebx

; 906  : 		}
; 907  : 	}
; 908  : 
; 909  : 	return false;

	xor	al, al
	pop	ebp

; 910  : }

	ret	4
$LN13@isAdjacent@2:
	pop	edi
	pop	esi
	pop	ebx

; 904  : 		{
; 905  : 			return true;

	mov	al, 1
	pop	ebp

; 910  : }

	ret	4
?isAdjacent@CvPlot@@QBE_NPBV1@@Z ENDP			; CvPlot::isAdjacent
_TEXT	ENDS
PUBLIC	?isAdjacentToLand@CvPlot@@QBE_NXZ		; CvPlot::isAdjacentToLand
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentToLand@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isAdjacentToLand@CvPlot@@QBE_NXZ PROC			; CvPlot::isAdjacentToLand, COMDAT
; _this$ = ecx

; 914  : {

	push	ebp

; 915  : 	CvPlot* pAdjacentPlot;
; 916  : 	int iI;
; 917  : 
; 918  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebp, WORD PTR [ecx]
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
	npad	4
$LL5@isAdjacent@3:

; 919  : 	{
; 920  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 921  : 
; 922  : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent@3

; 923  : 		{
; 924  : 			if(!(pAdjacentPlot->isWater()))

	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN15@isAdjacent@3
$LN4@isAdjacent@3:

; 915  : 	CvPlot* pAdjacentPlot;
; 916  : 	int iI;
; 917  : 
; 918  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@isAdjacent@3
	pop	edi
	pop	esi

; 927  : 			}
; 928  : 		}
; 929  : 	}
; 930  : 
; 931  : 	return false;

	xor	al, al
	pop	ebp

; 932  : }

	ret	0
$LN15@isAdjacent@3:
	pop	edi
	pop	esi

; 925  : 			{
; 926  : 				return true;

	mov	al, 1
	pop	ebp

; 932  : }

	ret	0
?isAdjacentToLand@CvPlot@@QBE_NXZ ENDP			; CvPlot::isAdjacentToLand
_TEXT	ENDS
PUBLIC	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToShallowWater
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentToShallowWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isAdjacentToShallowWater@CvPlot@@QBE_NXZ PROC		; CvPlot::isAdjacentToShallowWater, COMDAT
; _this$ = ecx

; 950  : {

	push	ebx

; 951  : 	CvPlot* pAdjacentPlot;
; 952  : 	int iI;
; 953  : 
; 954  : 	TerrainTypes eShallowWater = (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN();
; 955  : 
; 956  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx]
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
$LL5@isAdjacent@4:

; 957  : 	{
; 958  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 959  : 
; 960  : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent@4

; 961  : 		{
; 962  : 			if(pAdjacentPlot->getTerrainType() == eShallowWater)

	movsx	eax, BYTE PTR [eax+6]
	cmp	eax, ebp
	je	SHORT $LN17@isAdjacent@4
$LN4@isAdjacent@4:

; 951  : 	CvPlot* pAdjacentPlot;
; 952  : 	int iI;
; 953  : 
; 954  : 	TerrainTypes eShallowWater = (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN();
; 955  : 
; 956  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@isAdjacent@4
	pop	edi
	pop	esi
	pop	ebp

; 965  : 			}
; 966  : 		}
; 967  : 	}
; 968  : 
; 969  : 	return false;

	xor	al, al
	pop	ebx

; 970  : }

	ret	0
$LN17@isAdjacent@4:
	pop	edi
	pop	esi
	pop	ebp

; 963  : 			{
; 964  : 				return true;

	mov	al, 1
	pop	ebx

; 970  : }

	ret	0
?isAdjacentToShallowWater@CvPlot@@QBE_NXZ ENDP		; CvPlot::isAdjacentToShallowWater
_TEXT	ENDS
PUBLIC	?isCoastalLand@CvPlot@@QBE_NH@Z			; CvPlot::isCoastalLand
EXTRN	?getNumTiles@CvLandmass@@QBEHXZ:PROC		; CvLandmass::getNumTiles
; Function compile flags: /Ogtpy
;	COMDAT ?isCoastalLand@CvPlot@@QBE_NH@Z
_TEXT	SEGMENT
_iMinWaterSize$ = 8					; size = 4
?isCoastalLand@CvPlot@@QBE_NH@Z PROC			; CvPlot::isCoastalLand, COMDAT
; _this$ = ecx

; 975  : {

	push	edi
	mov	edi, ecx

; 976  : 	CvPlot* pAdjacentPlot;
; 977  : 	int iI;
; 978  : 
; 979  : 	if(isWater())

	cmp	BYTE PTR [edi+5], 3
	jne	SHORT $LN9@isCoastalL

; 980  : 	{
; 981  : 		return false;

	xor	al, al
	pop	edi

; 1012 : }

	ret	4
$LN9@isCoastalL:
	push	ebp

; 982  : 	}
; 983  : 
; 984  : 	// If -1 was passed in (default argument) use min water size for ocean define
; 985  : 	if(iMinWaterSize == -1)

	mov	ebp, DWORD PTR _iMinWaterSize$[esp+4]
	cmp	ebp, -1
	jne	SHORT $LN14@isCoastalL

; 986  : 	{
; 987  : 		iMinWaterSize = GC.getMIN_WATER_SIZE_FOR_OCEAN();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6876
$LN14@isCoastalL:
	push	esi

; 988  : 	}
; 989  : 
; 990  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	esi, esi
$LL7@isCoastalL:

; 991  : 	{
; 992  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	esi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 993  : 
; 994  : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN6@isCoastalL

; 995  : 		{
; 996  : 			if(pAdjacentPlot->isWater())

	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN6@isCoastalL

; 997  : 			{
; 998  : 				if(iMinWaterSize <= 0)

	test	ebp, ebp
	jle	SHORT $LN28@isCoastalL

; 999  : 				{
; 1000 : 					return true;
; 1001 : 				}
; 1002 : 				CvLandmass* pAdjacentBodyOfWater = GC.getMap().getLandmass(pAdjacentPlot->getLandmass());

	mov	eax, DWORD PTR [eax+360]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass

; 1003 : 				if(pAdjacentBodyOfWater && pAdjacentBodyOfWater->getNumTiles() >= iMinWaterSize)

	test	eax, eax
	je	SHORT $LN6@isCoastalL
	mov	ecx, eax
	call	?getNumTiles@CvLandmass@@QBEHXZ		; CvLandmass::getNumTiles
	cmp	eax, ebp
	jge	SHORT $LN28@isCoastalL
$LN6@isCoastalL:

; 988  : 	}
; 989  : 
; 990  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL7@isCoastalL
	pop	esi
	pop	ebp

; 1006 : 				}
; 1007 : 			}
; 1008 : 		}
; 1009 : 	}
; 1010 : 
; 1011 : 	return false;

	xor	al, al
	pop	edi

; 1012 : }

	ret	4
$LN28@isCoastalL:
	pop	esi
	pop	ebp

; 1004 : 				{
; 1005 : 					return true;

	mov	al, 1
	pop	edi

; 1012 : }

	ret	4
?isCoastalLand@CvPlot@@QBE_NH@Z ENDP			; CvPlot::isCoastalLand
_TEXT	ENDS
PUBLIC	?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ	; CvPlot::GetSizeLargestAdjacentWater
; Function compile flags: /Ogtpy
;	COMDAT ?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ PROC	; CvPlot::GetSizeLargestAdjacentWater, COMDAT
; _this$ = ecx

; 1016 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 1017 : 	CvPlot* pAdjacentPlot;
; 1018 : 	int iI;
; 1019 : 	int iRtnValue = 0;

	xor	ebx, ebx

; 1020 : 
; 1021 : 	if(isWater())

	cmp	BYTE PTR [ebp+5], 3
	jne	SHORT $LN7@GetSizeLar
	pop	ebp

; 1022 : 	{
; 1023 : 		return iRtnValue;

	xor	eax, eax
	pop	ebx

; 1044 : }

	ret	0
$LN7@GetSizeLar:
	push	esi
	push	edi

; 1024 : 	}
; 1025 : 
; 1026 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	edi, edi
$LL25@GetSizeLar:

; 1027 : 	{
; 1028 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1029 : 
; 1030 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN5@GetSizeLar

; 1031 : 		{
; 1032 : 			if(pAdjacentPlot->isWater())

	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN5@GetSizeLar

; 1033 : 			{
; 1034 : 				CvLandmass* pAdjacentBodyOfWater = GC.getMap().getLandmass(pAdjacentPlot->getLandmass());

	mov	eax, DWORD PTR [eax+360]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	esi, eax

; 1035 : 				if (pAdjacentBodyOfWater && pAdjacentBodyOfWater->getNumTiles() >= iRtnValue)

	test	esi, esi
	je	SHORT $LN5@GetSizeLar
	mov	ecx, esi
	call	?getNumTiles@CvLandmass@@QBEHXZ		; CvLandmass::getNumTiles
	cmp	eax, ebx
	jl	SHORT $LN5@GetSizeLar

; 1036 : 				{
; 1037 : 					iRtnValue = pAdjacentBodyOfWater->getNumTiles();

	mov	ecx, esi
	call	?getNumTiles@CvLandmass@@QBEHXZ		; CvLandmass::getNumTiles
	mov	ebx, eax
$LN5@GetSizeLar:
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL25@GetSizeLar
	pop	edi
	pop	esi
	pop	ebp

; 1038 : 				}
; 1039 : 			}
; 1040 : 		}
; 1041 : 	}
; 1042 : 
; 1043 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 1044 : }

	ret	0
?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ ENDP	; CvPlot::GetSizeLargestAdjacentWater
_TEXT	ENDS
PUBLIC	?isVisibleWorked@CvPlot@@QBE_NXZ		; CvPlot::isVisibleWorked
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleWorked@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isVisibleWorked@CvPlot@@QBE_NXZ PROC			; CvPlot::isVisibleWorked, COMDAT
; _this$ = ecx

; 1048 : {

	push	esi
	mov	esi, ecx

; 1049 : 	if(isBeingWorked())

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@isVisibleW
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	je	SHORT $LN2@isVisibleW

; 1050 : 	{
; 1051 : 		if((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN12@isVisibleW
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN19@isVisibleW
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	esi, eax
	jmp	SHORT $LN11@isVisibleW
$LN19@isVisibleW:
	or	eax, -1
	mov	esi, eax
	jmp	SHORT $LN11@isVisibleW
$LN12@isVisibleW:
	or	esi, -1
$LN11@isVisibleW:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	esi, eax
	je	SHORT $LN1@isVisibleW
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN2@isVisibleW
$LN1@isVisibleW:

; 1052 : 		{
; 1053 : 			return true;

	mov	al, 1
	pop	esi

; 1058 : }

	ret	0
$LN2@isVisibleW:

; 1054 : 		}
; 1055 : 	}
; 1056 : 
; 1057 : 	return false;

	xor	al, al
	pop	esi

; 1058 : }

	ret	0
?isVisibleWorked@CvPlot@@QBE_NXZ ENDP			; CvPlot::isVisibleWorked
_TEXT	ENDS
PUBLIC	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
; Function compile flags: /Ogtpy
;	COMDAT ?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_eIgnorePlayer$ = 12					; size = 4
?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::isWithinTeamCityRadius, COMDAT
; _this$ = ecx

; 1063 : {

	push	ebx

; 1064 : 	int iI;
; 1065 : 
; 1066 : 	for(iI = 0; iI < MAX_PLAYERS; ++iI)

	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	ebp
	push	esi
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	edi, DWORD PTR _eIgnorePlayer$[esp+12]
	xor	edx, edx
	add	esi, 44					; 0000002cH
	npad	7
$LL36@isWithinTe:

; 1067 : 	{
; 1068 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	cmp	BYTE PTR [esi+2212], 0
	je	SHORT $LN7@isWithinTe

; 1069 : 		{
; 1070 : 			if(GET_PLAYER((PlayerTypes)iI).getTeam() == eTeam)

	mov	eax, DWORD PTR [esi]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@isWithinTe
	mov	ebp, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebp+eax*4]
	jmp	SHORT $LN24@isWithinTe
$LN23@isWithinTe:
	or	eax, -1
$LN24@isWithinTe:
	cmp	eax, DWORD PTR _eTeam$[esp+12]
	jne	SHORT $LN7@isWithinTe

; 1071 : 			{
; 1072 : 				if((eIgnorePlayer == NO_PLAYER) || (((PlayerTypes)iI) != eIgnorePlayer))

	cmp	edi, -1
	je	SHORT $LN2@isWithinTe
	cmp	edx, edi
	je	SHORT $LN7@isWithinTe
$LN2@isWithinTe:

; 1073 : 				{
; 1074 : 					if(isPlayerCityRadius((PlayerTypes)iI))

	mov	eax, DWORD PTR [ecx+152]
	cmp	BYTE PTR [edx+eax], 0
	jg	SHORT $LN33@isWithinTe
$LN7@isWithinTe:

; 1064 : 	int iI;
; 1065 : 
; 1066 : 	for(iI = 0; iI < MAX_PLAYERS; ++iI)

	inc	edx
	add	esi, 63236				; 0000f704H
	cmp	edx, 64					; 00000040H
	jl	SHORT $LL36@isWithinTe
	pop	edi
	pop	esi
	pop	ebp

; 1077 : 					}
; 1078 : 				}
; 1079 : 			}
; 1080 : 		}
; 1081 : 	}
; 1082 : 
; 1083 : 	return false;

	xor	al, al
	pop	ebx

; 1084 : }

	ret	8
$LN33@isWithinTe:
	pop	edi
	pop	esi
	pop	ebp

; 1075 : 					{
; 1076 : 						return true;

	mov	al, 1
	pop	ebx

; 1084 : }

	ret	8
?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::isWithinTeamCityRadius
_TEXT	ENDS
PUBLIC	?isFreshWater@CvPlot@@QBE_NXZ			; CvPlot::isFreshWater
EXTRN	?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isAddsFreshWater
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
; Function compile flags: /Ogtpy
;	COMDAT ?isFreshWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isFreshWater@CvPlot@@QBE_NXZ PROC			; CvPlot::isFreshWater, COMDAT
; _this$ = ecx

; 1104 : {

	push	ebx
	mov	ebx, ecx

; 1105 : 	CvPlot* pLoopPlot;
; 1106 : 	int iDX, iDY;
; 1107 : 
; 1108 : 	if(isWater() || isImpassable() || isMountain())

	mov	al, BYTE PTR [ebx+5]
	cmp	al, 3
	je	$LN12@isFreshWat
	test	BYTE PTR [ebx+462], 128			; 00000080H
	jne	$LN12@isFreshWat
	test	al, al
	je	$LN12@isFreshWat

; 1110 : 
; 1111 : 	if(isRiver())

	cmp	BYTE PTR [ebx+457], 0
	jle	SHORT $LN11@isFreshWat

; 1112 : 	{
; 1113 : 		return true;

	mov	al, 1
	pop	ebx

; 1153 : }

	ret	0
$LN11@isFreshWat:
	push	ebp
	push	esi

; 1114 : 	}
; 1115 : 
; 1116 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1117 : 	int iMaxDX;
; 1118 : 	for (iDY = -1; iDY <= 1; iDY++)
; 1119 : 	{
; 1120 : 		iMaxDX = 1 - MAX(0, iDY);
; 1121 : 		for (iDX = -1 - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1122 : 		{
; 1123 : 			pLoopPlot = plotXY(getX(), getY(), iDX, iDY);
; 1124 : #else
; 1125 : 	for(iDX = -1; iDX <= 1; iDX++)

	or	ebp, -1
	push	edi
$LL44@isFreshWat:

; 1126 : 	{
; 1127 : 		for(iDY = -1; iDY <= 1; iDY++)

	or	edi, -1
	npad	7
$LL7@isFreshWat:

; 1128 : 		{
; 1129 : 			pLoopPlot	= plotXYWithRangeCheck(getX(), getY(), iDX, iDY, 1);

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	1
	push	edi
	push	ebp
	push	eax
	push	ecx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	mov	esi, eax
	add	esp, 20					; 00000014H

; 1130 : #endif
; 1131 : 
; 1132 : 			if(pLoopPlot != NULL)

	test	esi, esi
	je	SHORT $LN6@isFreshWat

; 1133 : 			{
; 1134 : 				if(pLoopPlot->isLake())

	mov	edx, DWORD PTR [esi+360]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	test	eax, eax
	je	SHORT $LN43@isFreshWat
	mov	ecx, eax
	call	?isLake@CvLandmass@@QBE_NXZ		; CvLandmass::isLake
	test	al, al
	jne	SHORT $LN40@isFreshWat
$LN43@isFreshWat:

; 1135 : 				{
; 1136 : 					return true;
; 1137 : 				}
; 1138 : 
; 1139 : 				FeatureTypes feature_type = pLoopPlot->getFeatureType();

	movsx	eax, BYTE PTR [esi+432]

; 1140 : 
; 1141 : 				if(feature_type != NO_FEATURE)

	cmp	eax, -1
	je	SHORT $LN6@isFreshWat

; 1142 : 				{
; 1143 : 					if(GC.getFeatureInfo(feature_type)->isAddsFreshWater())

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ ; CvFeatureInfo::isAddsFreshWater
	test	al, al
	jne	SHORT $LN40@isFreshWat
$LN6@isFreshWat:

; 1126 : 	{
; 1127 : 		for(iDY = -1; iDY <= 1; iDY++)

	inc	edi
	cmp	edi, 1
	jle	SHORT $LL7@isFreshWat
	inc	ebp
	cmp	ebp, 1
	jle	SHORT $LL44@isFreshWat
	pop	edi
	pop	esi
	pop	ebp

; 1146 : 					}
; 1147 : 				}
; 1148 : 			}
; 1149 : 		}
; 1150 : 	}
; 1151 : 
; 1152 : 	return false;

	xor	al, al
	pop	ebx

; 1153 : }

	ret	0
$LN40@isFreshWat:
	pop	edi
	pop	esi
	pop	ebp

; 1144 : 					{
; 1145 : 						return true;

	mov	al, 1
	pop	ebx

; 1153 : }

	ret	0
$LN12@isFreshWat:

; 1109 : 		return false;

	xor	al, al
	pop	ebx

; 1153 : }

	ret	0
?isFreshWater@CvPlot@@QBE_NXZ ENDP			; CvPlot::isFreshWater
_TEXT	ENDS
PUBLIC	?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossingFlowClockwise
; Function compile flags: /Ogtpy
;	COMDAT ?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z
_TEXT	SEGMENT
_eDirection$ = 8					; size = 4
?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z PROC ; CvPlot::isRiverCrossingFlowClockwise, COMDAT
; _this$ = ecx

; 1161 : 	CvPlot* pPlot;
; 1162 : 	switch(eDirection)

	mov	eax, DWORD PTR _eDirection$[esp-4]
	cmp	eax, 5
	ja	$LN2@isRiverCro@2
	jmp	DWORD PTR $LN39@isRiverCro@2[eax*4]
$LN10@isRiverCro@2:

; 1163 : 	{
; 1164 : 	case DIRECTION_NORTHEAST:
; 1165 : 		pPlot = plotDirection(getX(), getY(), DIRECTION_NORTHEAST);

	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	0
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1166 : 		if(pPlot != NULL)

	test	eax, eax
	je	$LN2@isRiverCro@2

; 1167 : 		{
; 1168 : 			return (pPlot->getRiverSWFlowDirection() == FLOWDIRECTION_SOUTHEAST);

	xor	edx, edx
	cmp	BYTE PTR [eax+452], 2
	sete	dl
	mov	al, dl

; 1200 : }

	ret	4
$LN8@isRiverCro@2:

; 1169 : 		}
; 1170 : 		break;
; 1171 : 	case DIRECTION_EAST:
; 1172 : 		return (getRiverEFlowDirection() == FLOWDIRECTION_SOUTH);

	xor	eax, eax
	cmp	BYTE PTR [ecx+450], 3
	sete	al

; 1200 : }

	ret	4
$LN7@isRiverCro@2:

; 1173 : 		break;
; 1174 : 	case DIRECTION_SOUTHEAST:
; 1175 : 		return (getRiverSEFlowDirection() == FLOWDIRECTION_SOUTHWEST);

	xor	eax, eax
	cmp	BYTE PTR [ecx+451], 4
	sete	al

; 1200 : }

	ret	4
$LN6@isRiverCro@2:

; 1176 : 		break;
; 1177 : 	case DIRECTION_SOUTHWEST:
; 1178 : 		return (getRiverSWFlowDirection() == FLOWDIRECTION_NORTHWEST);

	xor	eax, eax
	cmp	BYTE PTR [ecx+452], 5
	sete	al

; 1200 : }

	ret	4
$LN5@isRiverCro@2:

; 1179 : 		break;
; 1180 : 	case DIRECTION_WEST:
; 1181 : 		pPlot = plotDirection(getX(), getY(), DIRECTION_WEST);

	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	4
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1182 : 		if(pPlot != NULL)

	test	eax, eax
	je	SHORT $LN2@isRiverCro@2

; 1183 : 		{
; 1184 : 			return (pPlot->getRiverEFlowDirection() == FLOWDIRECTION_NORTH);

	xor	edx, edx
	cmp	BYTE PTR [eax+450], dl
	sete	dl
	mov	al, dl

; 1200 : }

	ret	4
$LN3@isRiverCro@2:

; 1185 : 		}
; 1186 : 		break;
; 1187 : 	case DIRECTION_NORTHWEST:
; 1188 : 		pPlot = plotDirection(getX(), getY(), DIRECTION_NORTHWEST);

	movsx	eax, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	5
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1189 : 		if(pPlot != NULL)

	test	eax, eax
	je	SHORT $LN2@isRiverCro@2

; 1190 : 		{
; 1191 : 			return (pPlot->getRiverSEFlowDirection() == FLOWDIRECTION_NORTHEAST);

	xor	edx, edx
	cmp	BYTE PTR [eax+451], 1
	sete	dl
	mov	al, dl

; 1200 : }

	ret	4
$LN2@isRiverCro@2:

; 1192 : 		}
; 1193 : 		break;
; 1194 : 	default:
; 1195 : 		CvAssert(false);
; 1196 : 		break;
; 1197 : 	}
; 1198 : 
; 1199 : 	return false;

	xor	al, al

; 1200 : }

	ret	4
	npad	3
$LN39@isRiverCro@2:
	DD	$LN10@isRiverCro@2
	DD	$LN8@isRiverCro@2
	DD	$LN7@isRiverCro@2
	DD	$LN6@isRiverCro@2
	DD	$LN5@isRiverCro@2
	DD	$LN3@isRiverCro@2
?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z ENDP ; CvPlot::isRiverCrossingFlowClockwise
_TEXT	ENDS
PUBLIC	?isRiverSide@CvPlot@@QBE_NXZ			; CvPlot::isRiverSide
; Function compile flags: /Ogtpy
;	COMDAT ?isRiverSide@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
tv184 = -4						; size = 4
?isRiverSide@CvPlot@@QBE_NXZ PROC			; CvPlot::isRiverSide, COMDAT
; _this$ = ecx

; 1205 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 1206 : 	CvPlot* pLoopPlot;
; 1207 : 	int iI;
; 1208 : 
; 1209 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ebp]
	push	edi
	movsx	edi, WORD PTR [ebp+2]
	xor	esi, esi
$LL5@isRiverSid:

; 1210 : 	{
; 1211 : 		pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1212 : 
; 1213 : 		if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isRiverSid

; 1214 : 		{
; 1215 : 			if(isRiverCrossing(directionXY(this, pLoopPlot)))

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	push	edi
	push	ebx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H
	cmp	eax, -1
	je	SHORT $LN4@isRiverSid
	movsx	edx, BYTE PTR [ebp+460]
	mov	ecx, 1
	mov	DWORD PTR tv184[esp+20], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv184[esp+20]
	shl	eax, cl
	test	edx, eax
	setne	al
	test	al, al
	jne	SHORT $LN26@isRiverSid
$LN4@isRiverSid:

; 1206 : 	CvPlot* pLoopPlot;
; 1207 : 	int iI;
; 1208 : 
; 1209 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@isRiverSid
	pop	edi
	pop	esi
	pop	ebp

; 1218 : 			}
; 1219 : 		}
; 1220 : 	}
; 1221 : 
; 1222 : 	return false;

	xor	al, al
	pop	ebx

; 1223 : }

	pop	ecx
	ret	0
$LN26@isRiverSid:
	pop	edi
	pop	esi
	pop	ebp

; 1216 : 			{
; 1217 : 				return true;

	mov	al, 1
	pop	ebx

; 1223 : }

	pop	ecx
	ret	0
?isRiverSide@CvPlot@@QBE_NXZ ENDP			; CvPlot::isRiverSide
_TEXT	ENDS
PUBLIC	?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z ; CvPlot::getNeighboringPlot
; Function compile flags: /Ogtpy
;	COMDAT ?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z
_TEXT	SEGMENT
_eDirection$ = 8					; size = 4
?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z PROC ; CvPlot::getNeighboringPlot, COMDAT
; _this$ = ecx

; 1271 : 	return plotDirection(getX(), getY(), eDirection);

	mov	eax, DWORD PTR _eDirection$[esp-4]
	movsx	edx, WORD PTR [ecx+2]
	push	eax
	movsx	eax, WORD PTR [ecx]
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1272 : }

	ret	4
?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z ENDP ; CvPlot::getNeighboringPlot
_TEXT	ENDS
PUBLIC	?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z	; CvPlot::getNearestLandPlotInternal
; Function compile flags: /Ogtpy
;	COMDAT ?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z
_TEXT	SEGMENT
_iDX$223008 = -16					; size = 4
tv243 = -12						; size = 4
_this$ = -8						; size = 4
tv194 = -4						; size = 4
_iDistance$ = 8						; size = 4
?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z PROC	; CvPlot::getNearestLandPlotInternal, COMDAT
; _this$ = ecx

; 1276 : {

	sub	esp, 16					; 00000010H

; 1307 : 			}
; 1308 : 		}
; 1309 : 	}
; 1310 : 	return getNearestLandPlotInternal(iDistance + 1);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edx, DWORD PTR [eax+4024]
	mov	eax, DWORD PTR _iDistance$[esp+12]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, eax
	mov	DWORD PTR _this$[esp+32], ecx
	mov	DWORD PTR tv194[esp+32], edx
	neg	edi
$LN45@getNearest:
	cmp	eax, DWORD PTR tv194[esp+32]
	mov	DWORD PTR tv243[esp+32], edi
	jle	SHORT $LN8@getNearest
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [edx+4020]
	jg	SHORT $LN39@getNearest
$LN8@getNearest:

; 1284 : 	}
; 1285 : 
; 1286 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1287 : 	int iDX, iMaxDX;
; 1288 : 	for (int iDY = -iDistance; iDY <= iDistance; iDY++)
; 1289 : 	{
; 1290 : 		iMaxDX = iDistance - MAX(0, iDY);
; 1291 : 		for (iDX = -iDistance - MIN(0, iDY); iDX <= iMaxDX; ((iDY == abs(iDistance) || iDX == iMaxDX) ? iDX++ : iDX = iMaxDX)) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1292 : #else
; 1293 : 	for(int iDX = -iDistance; iDX <= iDistance; iDX++)

	cmp	edi, eax
	mov	DWORD PTR _iDX$223008[esp+32], edi
	jg	SHORT $LN5@getNearest
$LL7@getNearest:

; 1294 : 	{
; 1295 : 		for(int iDY = -iDistance; iDY <= iDistance; iDY++)

	movsx	ebp, WORD PTR [ecx+2]
	movsx	ebx, WORD PTR [ecx]
	npad	7
$LL43@getNearest:

; 1296 : #endif
; 1297 : 		{
; 1298 : 			// bkw - revisit this, it works but is inefficient
; 1299 : 			CvPlot* pPlot = plotXY(getX(), getY(), iDX, iDY);

	mov	eax, DWORD PTR _iDX$223008[esp+32]
	push	edi
	push	eax
	push	ebp
	push	ebx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 1300 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1301 : 			if (pPlot != NULL && !pPlot->isWater())
; 1302 : #else
; 1303 : 			if(pPlot != NULL && !pPlot->isWater() && plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) == iDistance)

	test	esi, esi
	je	SHORT $LN3@getNearest
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN3@getNearest
	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	ecx
	push	edx
	push	ebp
	push	ebx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iDistance$[esp+28]
	je	SHORT $LN38@getNearest
$LN3@getNearest:

; 1294 : 	{
; 1295 : 		for(int iDY = -iDistance; iDY <= iDistance; iDY++)

	inc	edi
	cmp	edi, DWORD PTR _iDistance$[esp+28]
	jle	SHORT $LL43@getNearest
	mov	eax, DWORD PTR _iDX$223008[esp+32]
	mov	ecx, DWORD PTR _this$[esp+32]
	mov	edi, DWORD PTR tv243[esp+32]
	inc	eax
	cmp	eax, DWORD PTR _iDistance$[esp+28]
	mov	DWORD PTR _iDX$223008[esp+32], eax
	jle	SHORT $LL7@getNearest

; 1284 : 	}
; 1285 : 
; 1286 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1287 : 	int iDX, iMaxDX;
; 1288 : 	for (int iDY = -iDistance; iDY <= iDistance; iDY++)
; 1289 : 	{
; 1290 : 		iMaxDX = iDistance - MAX(0, iDY);
; 1291 : 		for (iDX = -iDistance - MIN(0, iDY); iDX <= iMaxDX; ((iDY == abs(iDistance) || iDX == iMaxDX) ? iDX++ : iDX = iMaxDX)) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1292 : #else
; 1293 : 	for(int iDX = -iDistance; iDX <= iDistance; iDX++)

	mov	eax, DWORD PTR _iDistance$[esp+28]
$LN5@getNearest:

; 1307 : 			}
; 1308 : 		}
; 1309 : 	}
; 1310 : 	return getNearestLandPlotInternal(iDistance + 1);

	inc	eax
	mov	DWORD PTR _iDistance$[esp+28], eax
	dec	edi
	jmp	$LN45@getNearest
$LN39@getNearest:
	pop	edi
	pop	esi
	pop	ebp

; 1277 : #ifdef AUI_WARNING_FIXES
; 1278 : 	if (uint(iDistance) > GC.getMap().getGridHeight() && uint(iDistance) > GC.getMap().getGridWidth())
; 1279 : #else
; 1280 : 	if(iDistance > GC.getMap().getGridHeight() && iDistance > GC.getMap().getGridWidth())
; 1281 : #endif
; 1282 : 	{
; 1283 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 1311 : }

	add	esp, 16					; 00000010H
	ret	4
$LN38@getNearest:
	pop	edi

; 1304 : #endif
; 1305 : 			{
; 1306 : 				return pPlot;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1311 : }

	add	esp, 16					; 00000010H
	ret	4
?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z ENDP	; CvPlot::getNearestLandPlotInternal
_TEXT	ENDS
PUBLIC	?getNearestLandPlot@CvPlot@@QBEPAV1@XZ		; CvPlot::getNearestLandPlot
; Function compile flags: /Ogtpy
;	COMDAT ?getNearestLandPlot@CvPlot@@QBEPAV1@XZ
_TEXT	SEGMENT
?getNearestLandPlot@CvPlot@@QBEPAV1@XZ PROC		; CvPlot::getNearestLandPlot, COMDAT
; _this$ = ecx

; 1325 : 	return getNearestLandPlotInternal(0);

	push	0
	call	?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z ; CvPlot::getNearestLandPlotInternal

; 1326 : }

	ret	0
?getNearestLandPlot@CvPlot@@QBEPAV1@XZ ENDP		; CvPlot::getNearestLandPlot
_TEXT	ENDS
PUBLIC	?seeThroughLevel@CvPlot@@QBEH_N@Z		; CvPlot::seeThroughLevel
EXTRN	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getSeeThroughChange
EXTRN	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getSeeThroughLevel
; Function compile flags: /Ogtpy
;	COMDAT ?seeThroughLevel@CvPlot@@QBEH_N@Z
_TEXT	SEGMENT
_bIncludeShubbery$ = 8					; size = 1
?seeThroughLevel@CvPlot@@QBEH_N@Z PROC			; CvPlot::seeThroughLevel, COMDAT
; _this$ = ecx

; 1373 : {

	push	esi
	mov	esi, ecx

; 1374 : 	int iLevel;
; 1375 : 
; 1376 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 1377 : 
; 1378 : 	iLevel = GC.getTerrainInfo(getTerrainType())->getSeeThroughLevel();

	movsx	eax, BYTE PTR [esi+6]
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getSeeThroughLevel

; 1379 : 
; 1380 : 	if(bIncludeShubbery && getFeatureType() != NO_FEATURE)

	cmp	BYTE PTR _bIncludeShubbery$[esp+4], 0
	mov	edi, eax
	je	SHORT $LN4@seeThrough
	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN4@seeThrough

; 1381 : 	{
; 1382 : 		iLevel += GC.getFeatureInfo(getFeatureType())->getSeeThroughChange();

	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	add	edi, eax
$LN4@seeThrough:

; 1383 : 	}
; 1384 : 
; 1385 : 	if(isMountain())

	mov	al, BYTE PTR [esi+5]
	test	al, al
	jne	SHORT $LN3@seeThrough

; 1386 : 	{
; 1387 : 		iLevel += GC.getMOUNTAIN_SEE_THROUGH_CHANGE();

	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6212
$LN3@seeThrough:

; 1388 : 	}
; 1389 : 
; 1390 : 	if(isHills())

	cmp	al, 1
	jne	SHORT $LN2@seeThrough

; 1391 : 	{
; 1392 : 		iLevel += GC.getHILLS_SEE_THROUGH_CHANGE();

	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6220
$LN2@seeThrough:

; 1393 : 	}
; 1394 : 
; 1395 : 	if(isWater())

	cmp	al, 3
	jne	SHORT $LN29@seeThrough

; 1396 : 	{
; 1397 : 		iLevel += GC.getSEAWATER_SEE_THROUGH_CHANGE();

	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6228
$LN29@seeThrough:

; 1398 : 	}
; 1399 : 
; 1400 : 	return iLevel;

	mov	eax, edi
	pop	edi
	pop	esi

; 1401 : }

	ret	4
?seeThroughLevel@CvPlot@@QBEH_N@Z ENDP			; CvPlot::seeThroughLevel
_TEXT	ENDS
PUBLIC	?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z ; CvPlot::canHaveResource
EXTRN	?getMinLatitude@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getMinLatitude
EXTRN	?getMaxLatitude@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getMaxLatitude
EXTRN	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvResourceInfo::GetRequiredCivilization
EXTRN	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ:PROC	; CvResourceInfo::isOnlyMinorCivs
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?getMinAreaSize@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getMinAreaSize
EXTRN	?isNoRiverSide@CvResourceInfo@@QBE_NXZ:PROC	; CvResourceInfo::isNoRiverSide
EXTRN	?isFlatlands@CvResourceInfo@@QBE_NXZ:PROC	; CvResourceInfo::isFlatlands
EXTRN	?isHills@CvResourceInfo@@QBE_NXZ:PROC		; CvResourceInfo::isHills
EXTRN	?isTerrain@CvResourceInfo@@QBE_NH@Z:PROC	; CvResourceInfo::isTerrain
EXTRN	?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z:PROC	; CvResourceInfo::isFeatureTerrain
EXTRN	?isFeature@CvResourceInfo@@QBE_NH@Z:PROC	; CvResourceInfo::isFeature
; Function compile flags: /Ogtpy
;	COMDAT ?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
_bIgnoreLatitude$ = 12					; size = 1
?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z PROC ; CvPlot::canHaveResource, COMDAT
; _this$ = ecx

; 1950 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 1951 : 
; 1952 : 	if(eResource == NO_RESOURCE)

	mov	eax, DWORD PTR _eResource$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	eax, -1
	jne	SHORT $LN25@canHaveRes

; 1953 : 	{
; 1954 : 		return true;

	mov	al, 1
	pop	esi

; 2058 : }

	ret	8
$LN25@canHaveRes:

; 1955 : 	}
; 1956 : 
; 1957 : 	if(getResourceType() != NO_RESOURCE)

	cmp	BYTE PTR [esi+440], -1
	je	SHORT $LN24@canHaveRes
$LN75@canHaveRes:

; 1958 : 	{
; 1959 : 		return false;

	xor	al, al
	pop	esi

; 2058 : }

	ret	8
$LN24@canHaveRes:

; 1960 : 	}
; 1961 : 
; 1962 : 	if(isMountain())

	cmp	BYTE PTR [esi+5], 0

; 1963 : 	{
; 1964 : 		return false;

	je	SHORT $LN75@canHaveRes
	push	edi

; 1965 : 	}
; 1966 : 
; 1967 : 	CvResourceInfo& thisResourceInfo = *GC.getResourceInfo(eResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	edi, eax

; 1968 : 	if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [esi+432]

; 1969 : 	{
; 1970 : 		if(!(thisResourceInfo.isFeature(getFeatureType())))

	mov	ecx, edi
	cmp	al, -1
	je	SHORT $LN22@canHaveRes
	movsx	eax, al
	push	eax
	call	?isFeature@CvResourceInfo@@QBE_NH@Z	; CvResourceInfo::isFeature
	test	al, al

; 1971 : 		{
; 1972 : 			return false;

	je	SHORT $LN74@canHaveRes

; 1973 : 		}
; 1974 : 
; 1975 : 		if(!(thisResourceInfo.isFeatureTerrain(getTerrainType())))

	movsx	eax, BYTE PTR [esi+6]
	push	eax
	mov	ecx, edi
	call	?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z ; CvResourceInfo::isFeatureTerrain
	test	al, al
	jne	SHORT $LN18@canHaveRes
	pop	edi
	pop	esi

; 2058 : }

	ret	8
$LN22@canHaveRes:

; 1976 : 		{
; 1977 : 			return false;
; 1978 : 		}
; 1979 : 	}
; 1980 : 	else
; 1981 : 	{
; 1982 : 		if(!(thisResourceInfo.isTerrain(getTerrainType())))

	movsx	eax, BYTE PTR [esi+6]
	push	eax
	call	?isTerrain@CvResourceInfo@@QBE_NH@Z	; CvResourceInfo::isTerrain
	test	al, al

; 1983 : 		{
; 1984 : 			return false;

	je	SHORT $LN74@canHaveRes
$LN18@canHaveRes:

; 1985 : 		}
; 1986 : 	}
; 1987 : 
; 1988 : 	if(isHills())

	mov	al, BYTE PTR [esi+5]
	cmp	al, 1
	jne	SHORT $LN17@canHaveRes

; 1989 : 	{
; 1990 : 		if(!(thisResourceInfo.isHills()))

	mov	ecx, edi
	call	?isHills@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isHills
	test	al, al
	jne	SHORT $LN13@canHaveRes
$LN74@canHaveRes:
	pop	edi

; 1991 : 		{
; 1992 : 			return false;

	xor	al, al
	pop	esi

; 2058 : }

	ret	8
$LN17@canHaveRes:

; 1993 : 		}
; 1994 : 	}
; 1995 : 	else if(isFlatlands())

	cmp	al, 2
	jne	SHORT $LN13@canHaveRes

; 1996 : 	{
; 1997 : 		if(!(thisResourceInfo.isFlatlands()))

	mov	ecx, edi
	call	?isFlatlands@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isFlatlands
	test	al, al

; 1998 : 		{
; 1999 : 			return false;

	je	SHORT $LN74@canHaveRes
$LN13@canHaveRes:

; 2000 : 		}
; 2001 : 	}
; 2002 : 
; 2003 : 	if(thisResourceInfo.isNoRiverSide())

	mov	ecx, edi
	call	?isNoRiverSide@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isNoRiverSide
	test	al, al
	je	SHORT $LN11@canHaveRes

; 2004 : 	{
; 2005 : 		if(isRiverSide())

	mov	ecx, esi
	call	?isRiverSide@CvPlot@@QBE_NXZ		; CvPlot::isRiverSide
	test	al, al

; 2006 : 		{
; 2007 : 			return false;

	jne	SHORT $LN74@canHaveRes
$LN11@canHaveRes:
	push	ebx

; 2008 : 		}
; 2009 : 	}
; 2010 : 
; 2011 : 	if(thisResourceInfo.getMinAreaSize() != -1)

	mov	ecx, edi
	call	?getMinAreaSize@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMinAreaSize
	cmp	eax, -1
	je	SHORT $LN9@canHaveRes

; 2012 : 	{
; 2013 : 		if(area()->getNumTiles() < thisResourceInfo.getMinAreaSize())

	mov	ecx, esi
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	ecx, edi
	mov	ebx, eax
	call	?getMinAreaSize@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMinAreaSize
	cmp	ebx, eax

; 2014 : 		{
; 2015 : 			return false;

	jl	SHORT $LN73@canHaveRes
$LN9@canHaveRes:

; 2016 : 		}
; 2017 : 	}
; 2018 : 
; 2019 : 	if(thisResourceInfo.isOnlyMinorCivs())

	mov	ecx, edi
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	test	al, al

; 2020 : 	{
; 2021 : 		return false;

	jne	SHORT $LN73@canHaveRes

; 2022 : 	}
; 2023 : 
; 2024 : 	if (thisResourceInfo.GetRequiredCivilization() != NO_CIVILIZATION)

	mov	ecx, edi
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	cmp	eax, -1

; 2025 : 	{
; 2026 : 		return false;

	jne	SHORT $LN73@canHaveRes

; 2027 : 	}
; 2028 : 
; 2029 : 	if(!bIgnoreLatitude)

	cmp	BYTE PTR _bIgnoreLatitude$[esp+8], 0
	jne	SHORT $LN4@canHaveRes

; 2030 : 	{
; 2031 : 		if(getLatitude() > thisResourceInfo.getMaxLatitude())

	mov	ecx, edi
	call	?getMaxLatitude@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMaxLatitude
	mov	ecx, esi
	mov	ebx, eax
	call	?getLatitude@CvPlot@@QBEHXZ		; CvPlot::getLatitude
	cmp	eax, ebx

; 2032 : 		{
; 2033 : 			return false;

	jg	SHORT $LN73@canHaveRes

; 2034 : 		}
; 2035 : 
; 2036 : 		if(getLatitude() < thisResourceInfo.getMinLatitude())

	mov	ecx, edi
	call	?getMinLatitude@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMinLatitude
	mov	ecx, esi
	mov	edi, eax
	call	?getLatitude@CvPlot@@QBEHXZ		; CvPlot::getLatitude
	cmp	eax, edi

; 2037 : 		{
; 2038 : 			return false;

	jl	SHORT $LN73@canHaveRes
$LN4@canHaveRes:

; 2039 : 		}
; 2040 : 	}
; 2041 : 
; 2042 : 	if(!isPotentialCityWork())

	test	BYTE PTR [esi+461], 128			; 00000080H

; 2043 : 	{
; 2044 : 		return false;

	je	SHORT $LN73@canHaveRes

; 2045 : 	}
; 2046 : 
; 2047 : 	TerrainTypes eShallowWater = (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN();
; 2048 : 	if(getTerrainType() == eShallowWater)

	movsx	ecx, BYTE PTR [esi+6]
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	jne	SHORT $LN1@canHaveRes

; 2049 : 	{
; 2050 : 		if(!isAdjacentToLand())

	mov	ecx, esi
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	test	al, al
	jne	SHORT $LN1@canHaveRes
$LN73@canHaveRes:
	pop	ebx
	pop	edi

; 2051 : 		{
; 2052 : 			return false;

	xor	al, al
	pop	esi

; 2058 : }

	ret	8
$LN1@canHaveRes:
	pop	ebx
	pop	edi

; 2053 : 		}
; 2054 : 	}
; 2055 : 
; 2056 : 
; 2057 : 	return true;

	mov	al, 1
	pop	esi

; 2058 : }

	ret	8
?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z ENDP ; CvPlot::canHaveResource
_TEXT	ENDS
PUBLIC	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
EXTRN	?getBuildPercent@CvEraInfo@@QBEHXZ:PROC		; CvEraInfo::getBuildPercent
EXTRN	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ:PROC ; CvGame::getStartEraInfo
EXTRN	?getBuildPercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getBuildPercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getBuildModifier@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getBuildModifier
EXTRN	?getFeatureTime@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureTime
EXTRN	?getRoute@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getRoute
EXTRN	?isRepair@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::isRepair
EXTRN	?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z:PROC ; CvTeam::getBuildTimeChange
EXTRN	?getTime@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTime
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
$T236314 = 8						; size = 4
_eBuild$ = 8						; size = 4
$T236315 = 12						; size = 4
_ePlayer$ = 12						; size = 4
?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::getBuildTime, COMDAT
; _this$ = ecx

; 2568 : {

	push	ecx
	push	ebx
	push	esi

; 2569 : 	int iTime;
; 2570 : 
; 2571 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 2572 : 
; 2573 : 	iTime = GC.getBuildInfo(eBuild)->getTime();

	mov	esi, DWORD PTR _eBuild$[esp+8]
	push	edi
	mov	edi, ecx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+20], edi
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTime@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getTime
	mov	ebx, eax

; 2574 : 	if (ePlayer != NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer$[esp+12]
	cmp	eax, -1
	je	SHORT $LN10@getBuildTi

; 2575 : 	{
; 2576 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN10@getBuildTi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2577 : 		if (eTeam != NO_TEAM)

	cmp	eax, -1
	je	SHORT $LN10@getBuildTi

; 2578 : 		{
; 2579 : 			iTime += GET_TEAM(eTeam).getBuildTimeChange(eBuild);

	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z ; CvTeam::getBuildTimeChange
	add	ebx, eax
$LN10@getBuildTi:
	push	ebp

; 2580 : 		}
; 2581 : 	}
; 2582 : 
; 2583 : 	// Repair is either 3 turns or the original build time, whichever is shorter
; 2584 : 	if(GC.getBuildInfo(eBuild)->isRepair())

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	test	al, al
	je	SHORT $LN5@getBuildTi

; 2585 : 	{
; 2586 : 		RouteTypes eRoute = getRouteType();

	movsx	ebp, BYTE PTR [edi+447]

; 2587 : 
; 2588 : 		if(eRoute != NO_ROUTE)

	cmp	ebp, -1
	je	SHORT $LN5@getBuildTi

; 2589 : 		{
; 2590 : #ifdef AUI_WARNING_FIXES
; 2591 : 			for (uint iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
; 2592 : #else
; 2593 : 			for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN51@getBuildTi
	npad	6
$LL49@getBuildTi:

; 2594 : #endif
; 2595 : 			{
; 2596 : 				CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	esi, eax

; 2597 : 				if(!pkBuildInfo)

	test	esi, esi
	je	SHORT $LN6@getBuildTi

; 2598 : 				{
; 2599 : 					continue;
; 2600 : 				}
; 2601 : 
; 2602 : 				if(pkBuildInfo->getRoute() == eRoute)

	mov	ecx, esi
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, ebp
	jne	SHORT $LN6@getBuildTi

; 2603 : 				{
; 2604 : 					if(pkBuildInfo->getTime() < iTime)

	mov	ecx, esi
	call	?getTime@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getTime
	cmp	eax, ebx
	jge	SHORT $LN6@getBuildTi

; 2605 : 					{
; 2606 : 						iTime = pkBuildInfo->getTime();

	mov	ecx, esi
	call	?getTime@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getTime
	mov	ebx, eax
$LN6@getBuildTi:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	SHORT $LL49@getBuildTi

; 2589 : 		{
; 2590 : #ifdef AUI_WARNING_FIXES
; 2591 : 			for (uint iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
; 2592 : #else
; 2593 : 			for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)

	mov	esi, DWORD PTR _eBuild$[esp+16]
$LN51@getBuildTi:
	mov	edi, DWORD PTR _this$[esp+20]
$LN5@getBuildTi:

; 2607 : 					}
; 2608 : 				}
; 2609 : 			}
; 2610 : 		}
; 2611 : 	}
; 2612 : 	// End Repair time mod
; 2613 : 
; 2614 : 	if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [edi+432]
	pop	ebp
	cmp	al, -1
	je	SHORT $LN53@getBuildTi

; 2615 : 	{
; 2616 : 		iTime += GC.getBuildInfo(eBuild)->getFeatureTime(getFeatureType());

	movsx	edx, al
	push	edx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureTime@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureTime
	add	ebx, eax
$LN53@getBuildTi:

; 2617 : 	}
; 2618 : 
; 2619 : 	iTime *= std::max(0, (GC.getTerrainInfo(getTerrainType())->getBuildModifier() + 100));

	movsx	eax, BYTE PTR [edi+6]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getBuildModifier@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getBuildModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T236314[esp+12], eax
	mov	DWORD PTR $T236315[esp+12], 0
	lea	edi, DWORD PTR $T236314[esp+12]
	test	eax, eax
	jg	SHORT $LN42@getBuildTi
	lea	edi, DWORD PTR $T236315[esp+12]
$LN42@getBuildTi:

; 2620 : 	iTime /= 100;
; 2621 : 
; 2622 : 	iTime *= GC.getGame().getGameSpeedInfo().getBuildPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getBuildPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getBuildPercent
	mov	ecx, DWORD PTR [edi]
	imul	ecx, ebx
	mov	esi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	esi, eax

; 2623 : 	iTime /= 100;
; 2624 : 
; 2625 : 	iTime *= GC.getGame().getStartEraInfo().getBuildPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ ; CvGame::getStartEraInfo
	mov	ecx, eax
	call	?getBuildPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getBuildPercent
	mov	ecx, eax
	imul	ecx, esi

; 2626 : 	iTime /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2627 : 
; 2628 : #ifdef NQ_ROUND_BUILD_TIMES_DOWN
; 2629 : 	iTime /= 10; // round to lowest 10 for the sake of quick speed

	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	edi

; 2630 : 	iTime *= 10;

	lea	eax, DWORD PTR [eax+eax*4]
	pop	esi
	add	eax, eax
	pop	ebx

; 2631 : #endif
; 2632 : 
; 2633 : 	return iTime;
; 2634 : }

	pop	ecx
	ret	8
?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::getBuildTime
_TEXT	ENDS
PUBLIC	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ; CvPlot::getBuildTurnsLeft
EXTRN	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z:PROC	; CvUnit::workRate
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ:PROC ; CvUnit::getBuildType
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z
_TEXT	SEGMENT
_iBuildLeft$ = -4					; size = 4
$T236399 = 8						; size = 4
_eBuild$ = 8						; size = 4
_iNowBuildRate$ = 12					; size = 4
_ePlayer$ = 12						; size = 4
_iNowExtra$ = 16					; size = 4
_iThenExtra$ = 20					; size = 4
?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z PROC ; CvPlot::getBuildTurnsLeft, COMDAT
; _this$ = ecx

; 2639 : {

	push	ecx

; 2640 : #ifdef NQ_FIX_BUILD_TIMES_UI
; 2641 : 	// work rate
; 2642 : 	int iTotalWorkRate = iThenExtra;
; 2643 : 	const CvUnit* pLoopUnit;
; 2644 : 	const IDInfo* pUnitNode = headUnitNode();
; 2645 : 	while(pUnitNode != NULL)
; 2646 : 	{
; 2647 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);
; 2648 : 		pUnitNode = nextUnitNode(pUnitNode);
; 2649 : 
; 2650 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)
; 2651 : 		{
; 2652 : 			iTotalWorkRate += pLoopUnit->workRate(true);
; 2653 : 		}
; 2654 : 	}
; 2655 : 	if(iTotalWorkRate <= 0)
; 2656 : 	{
; 2657 : 		//this means it will take forever under current circumstances
; 2658 : 		return INT_MAX;
; 2659 : 	}
; 2660 : 
; 2661 : 	// turns left = roundUp(build left / worker rate)
; 2662 : 	int iBuildLeft = getBuildTime(eBuild, ePlayer) - getBuildProgress(eBuild);
; 2663 : 	int iTurnsLeft = iBuildLeft / iTotalWorkRate;
; 2664 : 
; 2665 : 	// if there's anything leftover, we actually have to bump up by 1 turn
; 2666 : 	if (iBuildLeft % iTotalWorkRate > 0)
; 2667 : 	{
; 2668 : 		iTurnsLeft++;
; 2669 : 	}
; 2670 : 
; 2671 : 	return iTurnsLeft;
; 2672 : #else
; 2673 : 
; 2674 : 	int iBuildLeft = getBuildTime(eBuild, ePlayer);

	mov	eax, DWORD PTR _ePlayer$[esp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, DWORD PTR _eBuild$[esp+4]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	ecx, eax
	mov	DWORD PTR _iBuildLeft$[esp+8], ecx

; 2675 : 
; 2676 : 	if(iBuildLeft == 0)

	test	ecx, ecx
	jne	SHORT $LN7@getBuildTu
	pop	ebx

; 2721 : 	}
; 2722 : 
; 2723 : 	//iTurnsLeft++;
; 2724 : 
; 2725 : 	//return std::max(1, iTurnsLeft);
; 2726 : 	return iTurnsLeft;
; 2727 : #endif
; 2728 : }

	pop	ecx
	ret	16					; 00000010H
$LN7@getBuildTu:

; 2677 : 		return 0;
; 2678 : 
; 2679 : 	const IDInfo* pUnitNode;
; 2680 : 	const CvUnit* pLoopUnit;
; 2681 : 	int iNowBuildRate;
; 2682 : 	int iThenBuildRate;
; 2683 : 	int iTurnsLeft;
; 2684 : 
; 2685 : 	iNowBuildRate = iNowExtra;
; 2686 : 	iThenBuildRate = iThenExtra;
; 2687 : 
; 2688 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], 0
	mov	edx, DWORD PTR _iNowExtra$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _iThenExtra$[esp+8]
	push	esi
	mov	DWORD PTR _iNowBuildRate$[esp+12], edx
	jbe	SHORT $LN13@getBuildTu
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN12@getBuildTu
$LN13@getBuildTu:
	xor	esi, esi
$LN12@getBuildTu:

; 2689 : 
; 2690 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN5@getBuildTu
	push	edi
$LL6@getBuildTu:

; 2691 : 	{
; 2692 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN20@getBuildTu
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN20@getBuildTu
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN21@getBuildTu
$LN20@getBuildTu:
	xor	edi, edi
$LN21@getBuildTu:

; 2693 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN32@getBuildTu
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN31@getBuildTu
$LN32@getBuildTu:
	xor	esi, esi
$LN31@getBuildTu:

; 2694 : 
; 2695 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)

	test	edi, edi
	je	SHORT $LN47@getBuildTu
	mov	ecx, edi
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	cmp	eax, DWORD PTR _eBuild$[esp+16]
	jne	SHORT $LN47@getBuildTu

; 2696 : 		{
; 2697 : 			if(pLoopUnit->canMove())

	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN3@getBuildTu

; 2698 : 			{
; 2699 : 				iNowBuildRate += pLoopUnit->workRate(false);

	push	-1
	push	0
	mov	ecx, edi
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	add	DWORD PTR _iNowBuildRate$[esp+16], eax
$LN3@getBuildTu:

; 2700 : 			}
; 2701 : 			iThenBuildRate += pLoopUnit->workRate(true);

	push	-1
	push	1
	mov	ecx, edi
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	add	ebp, eax
$LN47@getBuildTu:

; 2689 : 
; 2690 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL6@getBuildTu
	mov	ecx, DWORD PTR _iBuildLeft$[esp+20]
	pop	edi
$LN5@getBuildTu:

; 2702 : 		}
; 2703 : 	}
; 2704 : 
; 2705 : 	if(iThenBuildRate == 0)

	test	ebp, ebp
	jne	SHORT $LN2@getBuildTu
	pop	esi
	pop	ebp

; 2706 : 	{
; 2707 : 		//this means it will take forever under current circumstances
; 2708 : 		return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH
	pop	ebx

; 2721 : 	}
; 2722 : 
; 2723 : 	//iTurnsLeft++;
; 2724 : 
; 2725 : 	//return std::max(1, iTurnsLeft);
; 2726 : 	return iTurnsLeft;
; 2727 : #endif
; 2728 : }

	pop	ecx
	ret	16					; 00000010H
$LN2@getBuildTu:

; 2709 : 	}
; 2710 : 
; 2711 : 	iBuildLeft -= getBuildProgress(eBuild);

	mov	eax, DWORD PTR [ebx+184]
	test	eax, eax
	je	SHORT $LN40@getBuildTu
$LN39@getBuildTu:
	mov	edx, DWORD PTR _eBuild$[esp+12]
	movsx	eax, WORD PTR [eax+edx*2]
$LN40@getBuildTu:

; 2712 : 	iBuildLeft -= iNowBuildRate;

	mov	edx, DWORD PTR _iNowBuildRate$[esp+12]
	add	eax, edx
	sub	ecx, eax
	mov	DWORD PTR _iBuildLeft$[esp+16], ecx

; 2713 : 
; 2714 : 	iBuildLeft = std::max(0, iBuildLeft);

	mov	DWORD PTR $T236399[esp+12], 0
	lea	eax, DWORD PTR _iBuildLeft$[esp+16]
	test	ecx, ecx
	jg	SHORT $LN45@getBuildTu
	lea	eax, DWORD PTR $T236399[esp+12]
$LN45@getBuildTu:
	mov	ecx, DWORD PTR [eax]

; 2715 : 
; 2716 : 	iTurnsLeft = (iBuildLeft / iThenBuildRate);

	mov	eax, ecx
	cdq
	idiv	ebp

; 2717 : 
; 2718 : 	if((iTurnsLeft * iThenBuildRate) < iBuildLeft)

	mov	edx, eax
	imul	edx, ebp
	cmp	edx, ecx
	jge	SHORT $LN48@getBuildTu

; 2719 : 	{
; 2720 : 		iTurnsLeft++;

	inc	eax
$LN48@getBuildTu:
	pop	esi
	pop	ebp
	pop	ebx

; 2721 : 	}
; 2722 : 
; 2723 : 	//iTurnsLeft++;
; 2724 : 
; 2725 : 	//return std::max(1, iTurnsLeft);
; 2726 : 	return iTurnsLeft;
; 2727 : #endif
; 2728 : }

	pop	ecx
	ret	16					; 00000010H
?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ENDP ; CvPlot::getBuildTurnsLeft
_TEXT	ENDS
PUBLIC	?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTurnsTotal
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iTurnsLeft$ = 8					; size = 4
_iBuildLeft$ = 8					; size = 4
_eBuild$ = 8						; size = 4
$T236511 = 12						; size = 4
$T236510 = 12						; size = 4
_ePlayer$ = 12						; size = 4
?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::getBuildTurnsTotal, COMDAT
; _this$ = ecx

; 2733 : {

	push	ebx
	push	ebp
	mov	ebx, ecx

; 2734 : #ifdef NQ_FIX_BUILD_TIMES_UI
; 2735 : 	// work rate
; 2736 : 	int iTotalWorkRate = 0;
; 2737 : 	const CvUnit* pLoopUnit;
; 2738 : 	const IDInfo* pUnitNode = headUnitNode();
; 2739 : 	while(pUnitNode != NULL)
; 2740 : 	{
; 2741 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);
; 2742 : 		pUnitNode = nextUnitNode(pUnitNode);
; 2743 : 
; 2744 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)
; 2745 : 		{
; 2746 : 			iTotalWorkRate += pLoopUnit->workRate(true);
; 2747 : 		}
; 2748 : 	}
; 2749 : 	if(iTotalWorkRate <= 0)
; 2750 : 	{
; 2751 : 		//this means it will take forever under current circumstances
; 2752 : 		return INT_MAX;
; 2753 : 	}
; 2754 : 
; 2755 : 	// turns left = roundUp(build left / worker rate)
; 2756 : 	int iBuildTime = getBuildTime(eBuild, ePlayer);
; 2757 : 	int iTurnsTotal = iBuildTime / iTotalWorkRate;
; 2758 : 
; 2759 : 	// if there's anything leftover, we actually have to bump up by 1 turn
; 2760 : 	if (iBuildTime % iTotalWorkRate > 0)
; 2761 : 	{
; 2762 : 		iTurnsTotal++;
; 2763 : 	}
; 2764 : 
; 2765 : 	return iTurnsTotal;
; 2766 : #else
; 2767 : 	const IDInfo* pUnitNode;
; 2768 : 	const CvUnit* pLoopUnit;
; 2769 : 	int iNowBuildRate = 0;
; 2770 : 	int iThenBuildRate = 0;

	xor	ebp, ebp
	push	esi

; 2771 : 	int iBuildLeft = 0;
; 2772 : 	int iTurnsLeft = 0;
; 2773 : 
; 2774 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], ebp
	jbe	SHORT $LN11@getBuildTu@2
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN10@getBuildTu@2
$LN11@getBuildTu@2:
	xor	esi, esi
$LN10@getBuildTu@2:

; 2775 : 
; 2776 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN46@getBuildTu@2
	push	edi
	npad	4
$LL5@getBuildTu@2:

; 2777 : 	{
; 2778 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN18@getBuildTu@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN18@getBuildTu@2
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN19@getBuildTu@2
$LN18@getBuildTu@2:
	xor	edi, edi
$LN19@getBuildTu@2:

; 2779 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN30@getBuildTu@2
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN29@getBuildTu@2
$LN30@getBuildTu@2:
	xor	esi, esi
$LN29@getBuildTu@2:

; 2780 : 
; 2781 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)

	test	edi, edi
	je	SHORT $LN47@getBuildTu@2
	mov	ecx, edi
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	cmp	eax, DWORD PTR _eBuild$[esp+12]
	jne	SHORT $LN47@getBuildTu@2

; 2782 : 		{
; 2783 : 			if(pLoopUnit->canMove())

	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN2@getBuildTu@2

; 2784 : 			{
; 2785 : 				iNowBuildRate += pLoopUnit->workRate(false);

	push	-1
	push	0
	mov	ecx, edi
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
$LN2@getBuildTu@2:

; 2786 : 			}
; 2787 : 			iThenBuildRate += pLoopUnit->workRate(true);

	push	-1
	push	1
	mov	ecx, edi
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	add	ebp, eax
$LN47@getBuildTu@2:

; 2775 : 
; 2776 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL5@getBuildTu@2
	pop	edi

; 2788 : 		}
; 2789 : 	}
; 2790 : 
; 2791 : 	if(iThenBuildRate == 0)

	test	ebp, ebp
	jne	SHORT $LN1@getBuildTu@2
$LN46@getBuildTu@2:
	pop	esi
	pop	ebp

; 2792 : 	{
; 2793 : 		//this means it will take forever under current circumstances
; 2794 : 		return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH
	pop	ebx

; 2806 : #endif
; 2807 : }

	ret	8
$LN1@getBuildTu@2:

; 2795 : 	}
; 2796 : 
; 2797 : 	iBuildLeft = getBuildTime(eBuild, ePlayer);

	mov	eax, DWORD PTR _ePlayer$[esp+8]
	mov	ecx, DWORD PTR _eBuild$[esp+8]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	DWORD PTR _iBuildLeft$[esp+8], eax

; 2798 : 
; 2799 : 	iBuildLeft = std::max(0, iBuildLeft);

	test	eax, eax
	mov	DWORD PTR $T236510[esp+8], 0
	lea	eax, DWORD PTR _iBuildLeft$[esp+8]
	jg	SHORT $LN40@getBuildTu@2
	lea	eax, DWORD PTR $T236510[esp+8]
$LN40@getBuildTu@2:

; 2800 : 
; 2801 : 	iTurnsLeft = (iBuildLeft / iThenBuildRate);

	mov	eax, DWORD PTR [eax]
	cdq
	idiv	ebp

; 2802 : 
; 2803 : 	iTurnsLeft--;
; 2804 : 
; 2805 : 	return std::max(1, iTurnsLeft);

	mov	DWORD PTR $T236511[esp+8], 1
	dec	eax
	mov	DWORD PTR _iTurnsLeft$[esp+8], eax
	cmp	eax, 1
	lea	eax, DWORD PTR _iTurnsLeft$[esp+8]
	jg	SHORT $LN44@getBuildTu@2
	lea	eax, DWORD PTR $T236511[esp+8]
$LN44@getBuildTu@2:
	mov	eax, DWORD PTR [eax]
	pop	esi
	pop	ebp
	pop	ebx

; 2806 : #endif
; 2807 : }

	ret	8
?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::getBuildTurnsTotal
_TEXT	ENDS
PUBLIC	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
EXTRN	?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getFeatureProductionPercent
EXTRN	?getFeatureProductionModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getFeatureProductionModifier
EXTRN	?getFeatureProduction@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureProduction
EXTRN	?GetAllFeatureProduction@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetAllFeatureProduction
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z
_TEXT	SEGMENT
$T236629 = 8						; size = 4
$T236627 = 8						; size = 4
_eBuild$ = 8						; size = 4
$T236648 = 12						; size = 4
$T236630 = 12						; size = 4
_ePlayer$ = 12						; size = 4
$T236628 = 16						; size = 4
$T236626 = 16						; size = 4
_iProduction$ = 16					; size = 4
_ppCity$ = 16						; size = 4
?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z PROC ; CvPlot::getFeatureProduction, COMDAT
; _this$ = ecx

; 2813 : 	int iProduction;
; 2814 : 
; 2815 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp]
	imul	esi, 63236				; 0000f704H
	mov	eax, DWORD PTR [esi+eax+44]
	push	edi
	mov	edi, ecx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN15@getFeature
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T236648[esp+4], eax
	jmp	SHORT $LN16@getFeature
$LN15@getFeature:
	mov	DWORD PTR $T236648[esp+4], -1
$LN16@getFeature:

; 2816 : 
; 2817 : 	if(getFeatureType() == NO_FEATURE)

	cmp	BYTE PTR [edi+432], -1
	jne	SHORT $LN6@getFeature
	pop	edi

; 2818 : 	{
; 2819 : 		return 0;

	xor	eax, eax
	pop	esi

; 2860 : }

	ret	12					; 0000000cH
$LN6@getFeature:

; 2820 : 	}
; 2821 : 
; 2822 : 	*ppCity = getWorkingCity();

	mov	ecx, DWORD PTR [edi+116]
	mov	edx, DWORD PTR [edi+112]
	push	ebp
	push	ecx
	push	edx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	ebp, DWORD PTR _ppCity$[esp+16]
	add	esp, 8
	mov	DWORD PTR [ebp], eax

; 2823 : 
; 2824 : 	if(*ppCity == NULL)

	test	eax, eax
	jne	SHORT $LN4@getFeature

; 2825 : 	{
; 2826 : 		*ppCity = GC.getMap().findCity(getX(), getY(), NO_PLAYER, eTeam, false);

	mov	edx, DWORD PTR $T236648[esp+8]
	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	-1
	push	-1
	push	0
	push	0
	push	edx
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR [ebp], eax

; 2827 : 	}
; 2828 : 
; 2829 : 	if(*ppCity == NULL)

	test	eax, eax
	jne	SHORT $LN4@getFeature
	pop	ebp
	pop	edi
	pop	esi

; 2860 : }

	ret	12					; 0000000cH
$LN4@getFeature:

; 2830 : 	{
; 2831 : 		return 0;
; 2832 : 	}
; 2833 : 
; 2834 : 	// Base value
; 2835 : 	if(GET_PLAYER(ePlayer).GetAllFeatureProduction() > 0)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	lea	ecx, DWORD PTR [esi+eax]
	call	?GetAllFeatureProduction@CvPlayer@@QBEHXZ ; CvPlayer::GetAllFeatureProduction
	test	eax, eax
	jle	SHORT $LN3@getFeature

; 2836 : 	{
; 2837 : 		iProduction = GET_PLAYER(ePlayer).GetAllFeatureProduction();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?GetAllFeatureProduction@CvPlayer@@QBEHXZ ; CvPlayer::GetAllFeatureProduction

; 2838 : 	}
; 2839 : 	else

	jmp	SHORT $LN88@getFeature
$LN3@getFeature:

; 2840 : 	{
; 2841 : 		iProduction = GC.getBuildInfo(eBuild)->getFeatureProduction(getFeatureType());

	movsx	edx, BYTE PTR [edi+432]
	mov	eax, DWORD PTR _eBuild$[esp+12]
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureProduction@CvBuildInfo@@QBEHH@Z ; CvBuildInfo::getFeatureProduction
$LN88@getFeature:

; 2842 : 	}
; 2843 : 
; 2844 : 	// Distance mod
; 2845 : 	iProduction -= (std::max(0, (plotDistance(getX(), getY(), (*ppCity)->getX(), (*ppCity)->getY()) - 2)) * 5);

	mov	esi, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+96]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	mov	ebx, eax
	movsx	eax, WORD PTR [edi+2]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	sub	eax, 2
	xor	ebp, ebp
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T236626[esp+12], eax
	cmp	eax, ebp
	mov	DWORD PTR $T236627[esp+12], ebp
	lea	eax, DWORD PTR $T236626[esp+12]
	jg	SHORT $LN55@getFeature
	lea	eax, DWORD PTR $T236627[esp+12]
$LN55@getFeature:

; 2846 : 
; 2847 : 	iProduction *= std::max(0, (GET_PLAYER((*ppCity)->getOwner()).getFeatureProductionModifier() + 100));

	mov	ecx, DWORD PTR [esi+84]
	mov	eax, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, eax
	neg	edx
	add	edx, edx
	add	edx, edx
	sub	edx, eax
	add	ebx, edx
	call	?getFeatureProductionModifier@CvPlayer@@QBEHXZ ; CvPlayer::getFeatureProductionModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T236629[esp+12], ebp
	cmp	eax, ebp
	mov	DWORD PTR $T236628[esp+12], eax
	lea	ebp, DWORD PTR $T236628[esp+12]
	jg	SHORT $LN65@getFeature
	lea	ebp, DWORD PTR $T236629[esp+12]
$LN65@getFeature:

; 2848 : 	iProduction /= 100;
; 2849 : 
; 2850 : 	iProduction *= GC.getGame().getGameSpeedInfo().getFeatureProductionPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getFeatureProductionPercent
	mov	ecx, DWORD PTR [ebp]
	imul	ecx, ebx
	mov	esi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 2851 : 	iProduction /= 100;
; 2852 : 
; 2853 : 	if(getTeam() != eTeam)

	movsx	ecx, BYTE PTR [edi+4]
	imul	esi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iProduction$[esp+12], eax
	pop	ebx
	cmp	ecx, -1
	je	SHORT $LN69@getFeature
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN69@getFeature
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN68@getFeature
$LN69@getFeature:
	or	ecx, -1
$LN68@getFeature:
	cmp	ecx, DWORD PTR $T236648[esp+8]
	je	SHORT $LN1@getFeature

; 2854 : 	{
; 2855 : 		iProduction *= GC.getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6704
	imul	ecx, eax

; 2856 : 		iProduction /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iProduction$[esp+8], eax
$LN1@getFeature:

; 2857 : 	}
; 2858 : 
; 2859 : 	return std::max(0, iProduction);

	test	eax, eax
	mov	DWORD PTR $T236630[esp+8], 0
	lea	eax, DWORD PTR _iProduction$[esp+8]
	jg	SHORT $LN86@getFeature
	lea	eax, DWORD PTR $T236630[esp+8]
$LN86@getFeature:
	mov	eax, DWORD PTR [eax]
	pop	ebp
	pop	edi
	pop	esi

; 2860 : }

	ret	12					; 0000000cH
?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ENDP ; CvPlot::getFeatureProduction
_TEXT	ENDS
PUBLIC	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureFood
EXTRN	?getFeatureFood@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureFood
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z
_TEXT	SEGMENT
$T236816 = 8						; size = 4
$T236814 = 8						; size = 4
_eBuild$ = 8						; size = 4
$T236835 = 12						; size = 4
$T236817 = 12						; size = 4
_ePlayer$ = 12						; size = 4
$T236815 = 16						; size = 4
$T236813 = 16						; size = 4
_iFood$ = 16						; size = 4
_ppCity$ = 16						; size = 4
?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z PROC ; CvPlot::getFeatureFood, COMDAT
; _this$ = ecx

; 2866 : 	int iFood;
; 2867 : 
; 2868 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@getFeature@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T236835[esp], edx
	jmp	SHORT $LN14@getFeature@2
$LN13@getFeature@2:
	mov	DWORD PTR $T236835[esp], -1
$LN14@getFeature@2:

; 2869 : 
; 2870 : 	if(getFeatureType() == NO_FEATURE)

	cmp	BYTE PTR [esi+432], -1
	jne	SHORT $LN4@getFeature@2

; 2871 : 	{
; 2872 : 		return 0;

	xor	eax, eax
	pop	esi

; 2913 : }

	ret	12					; 0000000cH
$LN4@getFeature@2:

; 2873 : 	}
; 2874 : 
; 2875 : 	*ppCity = getWorkingCity();

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	ebp
	push	edi
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	edi, DWORD PTR _ppCity$[esp+16]

; 2876 : 
; 2877 : 	if(*ppCity == NULL)

	xor	ebp, ebp
	add	esp, 8
	mov	DWORD PTR [edi], eax
	cmp	eax, ebp
	jne	SHORT $LN2@getFeature@2

; 2878 : 	{
; 2879 : 		*ppCity = GC.getMap().findCity(getX(), getY(), NO_PLAYER, eTeam, false);

	mov	edx, DWORD PTR $T236835[esp+8]
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	-1
	push	-1
	push	ebp
	push	ebp
	push	edx
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR [edi], eax

; 2880 : 	}
; 2881 : 
; 2882 : 	if(*ppCity == NULL)

	cmp	eax, ebp
	jne	SHORT $LN2@getFeature@2
	pop	edi
	pop	ebp

; 2883 : 	{
; 2884 : 		return 0;

	xor	eax, eax
	pop	esi

; 2913 : }

	ret	12					; 0000000cH
$LN2@getFeature@2:

; 2885 : 	}
; 2886 : 
; 2887 : 	// Base value
; 2888 : 	//if(GET_PLAYER(ePlayer).GetAllFeatureProduction() > 0)
; 2889 : 	//{
; 2890 : 	//	iProduction = GET_PLAYER(ePlayer).GetAllFeatureProduction();
; 2891 : 	//}
; 2892 : 	//else
; 2893 : 	//{
; 2894 : 	iFood = GC.getBuildInfo(eBuild)->getFeatureFood(getFeatureType());

	movsx	eax, BYTE PTR [esi+432]
	mov	ecx, DWORD PTR _eBuild$[esp+8]
	push	ebx
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureFood@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureFood

; 2895 : 	//}
; 2896 : 
; 2897 : 	// Distance mod
; 2898 : 	iFood -= (std::max(0, (plotDistance(getX(), getY(), (*ppCity)->getX(), (*ppCity)->getY()) - 2)) * 5);

	mov	edi, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+108]
	movsx	ecx, WORD PTR [esi+2]
	push	edx
	movsx	edx, WORD PTR [esi]
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+96]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	sub	eax, 2
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T236813[esp+12], eax
	cmp	eax, ebp
	mov	DWORD PTR $T236814[esp+12], ebp
	lea	eax, DWORD PTR $T236813[esp+12]
	jg	SHORT $LN49@getFeature@2
	lea	eax, DWORD PTR $T236814[esp+12]
$LN49@getFeature@2:
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	sub	ecx, eax
	add	ebx, ecx

; 2899 : 
; 2900 : 	iFood *= std::max(0, (GET_PLAYER((*ppCity)->getOwner()).getFeatureProductionModifier() + 100));

	mov	ecx, DWORD PTR [edi+84]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getFeatureProductionModifier@CvPlayer@@QBEHXZ ; CvPlayer::getFeatureProductionModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T236816[esp+12], ebp
	cmp	eax, ebp
	mov	DWORD PTR $T236815[esp+12], eax
	lea	ebp, DWORD PTR $T236815[esp+12]
	jg	SHORT $LN59@getFeature@2
	lea	ebp, DWORD PTR $T236816[esp+12]
$LN59@getFeature@2:

; 2901 : 	iFood /= 100;
; 2902 : 
; 2903 : 	iFood *= GC.getGame().getGameSpeedInfo().getFeatureProductionPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getFeatureProductionPercent
	mov	ecx, DWORD PTR [ebp]
	imul	ecx, ebx
	mov	edi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 2904 : 	iFood /= 100;
; 2905 : 
; 2906 : 	if(getTeam() != eTeam)

	movsx	ecx, BYTE PTR [esi+4]
	imul	edi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iFood$[esp+12], eax
	pop	ebx
	cmp	ecx, -1
	je	SHORT $LN63@getFeature@2
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN63@getFeature@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN62@getFeature@2
$LN63@getFeature@2:
	or	ecx, -1
$LN62@getFeature@2:
	cmp	ecx, DWORD PTR $T236835[esp+8]
	je	SHORT $LN1@getFeature@2

; 2907 : 	{
; 2908 : 		iFood *= GC.getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6704
	imul	ecx, eax

; 2909 : 		iFood /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iFood$[esp+8], eax
$LN1@getFeature@2:

; 2910 : 	}
; 2911 : 
; 2912 : 	return std::max(0, iFood);

	test	eax, eax
	mov	DWORD PTR $T236817[esp+8], 0
	lea	eax, DWORD PTR _iFood$[esp+8]
	jg	SHORT $LN80@getFeature@2
	lea	eax, DWORD PTR $T236817[esp+8]
$LN80@getFeature@2:
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	ebp
	pop	esi

; 2913 : }

	ret	12					; 0000000cH
?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ENDP ; CvPlot::getFeatureFood
_TEXT	ENDS
PUBLIC	?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
EXTRN	?isBetterDefenderThan@CvUnit@@QBE_NPBV1@0@Z:PROC ; CvUnit::isBetterDefenderThan
EXTRN	?GetRangedCombatLimit@CvUnit@@QBEHXZ:PROC	; CvUnit::GetRangedCombatLimit
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
EXTRN	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isPotentialEnemy
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$1
__ehfuncinfo$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
_TEXT	SEGMENT
$T237143 = -40						; size = 4
tv713 = -36						; size = 4
$T236995 = -32						; size = 4
_pBestUnit$ = -28					; size = 8
_pLoopUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eOwner$ = 12						; size = 4
_eAttackingPlayer$ = 16					; size = 4
_pAttacker$ = 20					; size = 4
_bTestAtWar$ = 24					; size = 1
_bTestPotentialEnemy$ = 28				; size = 1
_bTestCanMove$ = 32					; size = 1
_bNoncombatAllowed$ = 36				; size = 1
?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z PROC ; CvPlot::getBestDefender, COMDAT
; _this$ = ecx

; 2926 : {

	push	-1
	push	__ehhandler$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T236995[esp+44], ebx
	push	ebp
	mov	ebp, ecx

; 2927 : 	const IDInfo* pUnitNode;
; 2928 : 	const UnitHandle pLoopUnit;

	mov	DWORD PTR _pLoopUnit$[esp+48], ebx
	mov	BYTE PTR _pLoopUnit$[esp+52], bl
	mov	DWORD PTR __$EHRec$[esp+56], 1

; 2929 : 	const UnitHandle pBestUnit;

	mov	DWORD PTR _pBestUnit$[esp+48], ebx
	mov	BYTE PTR _pBestUnit$[esp+52], bl

; 2930 : 
; 2931 : 	//NQMP GJS - fix radaring begin
; 2932 : 	if (eAttackingPlayer != NO_PLAYER && !isVisible(GET_PLAYER(eAttackingPlayer).getTeam()))

	mov	eax, DWORD PTR _eAttackingPlayer$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+56], 2
	cmp	eax, -1
	je	SHORT $LN204@getBestDef
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN200@getBestDef
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, -1
	je	SHORT $LN200@getBestDef
	mov	edx, DWORD PTR [ebp+156]
	cmp	WORD PTR [edx+eax*2], bx
	setg	al
	test	al, al
	jne	SHORT $LN204@getBestDef
$LN200@getBestDef:

; 2933 : 		return pBestUnit;	

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+44]
	mov	DWORD PTR [eax], ebx
	mov	BYTE PTR [eax+4], 0
	pop	ebp
	pop	ebx

; 2971 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	32					; 00000020H
$LN204@getBestDef:

; 2934 : 	//NQMP GJS - fix radaring end
; 2935 : 
; 2936 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebp+28], ebx
	jbe	SHORT $LN63@getBestDef
	mov	eax, DWORD PTR [ebp+24]
	jmp	SHORT $LN62@getBestDef
$LN63@getBestDef:
	xor	eax, eax
$LN62@getBestDef:
	push	esi
	push	edi
	mov	edi, eax

; 2937 : 
; 2938 : 	while(pUnitNode != NULL)

	cmp	eax, ebx
	je	$LN16@getBestDef

; 2941 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ebx, DWORD PTR _pAttacker$[esp+52]
$LL17@getBestDef:

; 2939 : 	{
; 2940 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jl	SHORT $LN70@getBestDef
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN70@getBestDef
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	edx
	mov	esi, eax
	jmp	SHORT $LN71@getBestDef
$LN70@getBestDef:
	xor	esi, esi
$LN71@getBestDef:
	mov	ecx, DWORD PTR _pLoopUnit$[esp+56]
	test	ecx, ecx
	je	SHORT $LN79@getBestDef
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN79@getBestDef:
	mov	DWORD PTR _pLoopUnit$[esp+56], esi
	test	esi, esi
	je	SHORT $LN81@getBestDef
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN81@getBestDef:

; 2941 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	edi, eax
	add	edi, 8
	sar	edi, 3
	mov	ecx, edi
	cmp	ecx, DWORD PTR [ebp+28]
	jae	SHORT $LN90@getBestDef
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T237143[esp+56], eax
	jmp	SHORT $LN89@getBestDef
$LN90@getBestDef:
	mov	DWORD PTR $T237143[esp+56], 0
$LN89@getBestDef:
	mov	edi, DWORD PTR $T237143[esp+56]

; 2942 : 
; 2943 : 		if(pLoopUnit && (bNoncombatAllowed || pLoopUnit->IsCanDefend()) && pLoopUnit != pAttacker)	// Does the unit exist, and can it fight, or do we care if it can't fight?

	test	esi, esi
	je	$LN202@getBestDef
	cmp	BYTE PTR _bNoncombatAllowed$[esp+52], 0
	jne	SHORT $LN14@getBestDef
	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	$LN202@getBestDef
$LN14@getBestDef:
	cmp	esi, ebx
	je	$LN202@getBestDef

; 2944 : 		{
; 2945 : 			if((eOwner ==  NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	mov	eax, DWORD PTR _eOwner$[esp+52]
	cmp	eax, -1
	je	SHORT $LN12@getBestDef
	cmp	DWORD PTR [esi+40], eax
	jne	$LN202@getBestDef
$LN12@getBestDef:

; 2946 : 			{
; 2947 : 				if((eAttackingPlayer == NO_PLAYER) || !(pLoopUnit->isInvisible(GET_PLAYER(eAttackingPlayer).getTeam(), false)))

	mov	eax, DWORD PTR _eAttackingPlayer$[esp+52]
	cmp	eax, -1
	je	SHORT $LN10@getBestDef
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN115@getBestDef
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN116@getBestDef
$LN115@getBestDef:
	or	eax, -1
$LN116@getBestDef:
	push	1
	push	0
	push	eax
	mov	ecx, esi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	$LN202@getBestDef
$LN10@getBestDef:

; 2948 : 				{
; 2949 : 					if(!bTestAtWar || eAttackingPlayer == NO_PLAYER || pLoopUnit->isEnemy(GET_PLAYER(eAttackingPlayer).getTeam(), this) || (NULL != pAttacker && pAttacker->isEnemy(GET_PLAYER(pLoopUnit->getOwner()).getTeam(), this)))

	cmp	BYTE PTR _bTestAtWar$[esp+52], 0
	je	SHORT $LN201@getBestDef
	mov	eax, DWORD PTR _eAttackingPlayer$[esp+52]
	cmp	eax, -1
	je	SHORT $LN201@getBestDef
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN128@getBestDef
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN129@getBestDef
$LN128@getBestDef:
	or	eax, -1
$LN129@getBestDef:
	push	ebp
	push	eax
	mov	ecx, esi
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	test	al, al
	jne	SHORT $LN201@getBestDef
	test	ebx, ebx
	je	$LN202@getBestDef
	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ecx, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, ebx
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	test	al, al
	je	$LN202@getBestDef
$LN201@getBestDef:

; 2950 : 					{
; 2951 : 						if(!bTestPotentialEnemy || (eAttackingPlayer == NO_PLAYER) ||  pLoopUnit->isPotentialEnemy(GET_PLAYER(eAttackingPlayer).getTeam(), this) || (NULL != pAttacker && pAttacker->isPotentialEnemy(GET_PLAYER(pLoopUnit->getOwner()).getTeam(), this)))

	cmp	BYTE PTR _bTestPotentialEnemy$[esp+52], 0
	je	SHORT $LN205@getBestDef
	mov	eax, DWORD PTR _eAttackingPlayer$[esp+52]
	cmp	eax, -1
	je	SHORT $LN205@getBestDef
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN149@getBestDef
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN150@getBestDef
$LN149@getBestDef:
	or	eax, -1
$LN150@getBestDef:
	push	ebp
	push	eax
	mov	ecx, esi
	call	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isPotentialEnemy
	test	al, al
	jne	SHORT $LN205@getBestDef
	test	ebx, ebx
	je	$LN202@getBestDef
	mov	eax, DWORD PTR [esi+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ecx, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, ebx
	call	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isPotentialEnemy
	test	al, al
	je	SHORT $LN202@getBestDef
$LN205@getBestDef:

; 2952 : 						{
; 2953 : 							if(!bTestCanMove || (pLoopUnit->canMove() && !(pLoopUnit->isCargo())))

	cmp	BYTE PTR _bTestCanMove$[esp+52], 0
	je	SHORT $LN4@getBestDef
	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN202@getBestDef
	mov	ecx, esi
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	test	al, al
	jne	SHORT $LN202@getBestDef
$LN4@getBestDef:

; 2954 : 							{
; 2955 : 								if((pAttacker == NULL) || (pAttacker->getDomainType() != DOMAIN_AIR) || (pLoopUnit->getDamage() < pAttacker->GetRangedCombatLimit()))

	test	ebx, ebx
	je	SHORT $LN2@getBestDef
	mov	ecx, ebx
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN2@getBestDef
	mov	ecx, esi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, ebx
	mov	DWORD PTR tv713[esp+56], eax
	call	?GetRangedCombatLimit@CvUnit@@QBEHXZ	; CvUnit::GetRangedCombatLimit
	mov	ecx, DWORD PTR tv713[esp+56]
	cmp	ecx, eax
	mov	ebx, DWORD PTR _pAttacker$[esp+52]
	jge	SHORT $LN202@getBestDef
$LN2@getBestDef:

; 2956 : 								{
; 2957 : 									if(pLoopUnit->isBetterDefenderThan(pBestUnit.pointer(), pAttacker))

	mov	eax, DWORD PTR _pBestUnit$[esp+56]
	push	ebx
	push	eax
	mov	ecx, esi
	call	?isBetterDefenderThan@CvUnit@@QBE_NPBV1@0@Z ; CvUnit::isBetterDefenderThan
	test	al, al
	je	SHORT $LN202@getBestDef

; 2958 : 									{
; 2959 : 										pBestUnit = pLoopUnit;

	mov	ecx, DWORD PTR _pBestUnit$[esp+56]
	test	ecx, ecx
	je	SHORT $LN179@getBestDef
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN179@getBestDef:
	mov	ecx, esi
	mov	DWORD PTR _pBestUnit$[esp+56], esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN202@getBestDef:

; 2937 : 
; 2938 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR $T237143[esp+56], 0
	jne	$LL17@getBestDef
	mov	ebx, DWORD PTR _pBestUnit$[esp+56]
$LN16@getBestDef:

; 2960 : 									}
; 2961 : 								}
; 2962 : 							}
; 2963 : 						}
; 2964 : 					}
; 2965 : 				}
; 2966 : 			}
; 2967 : 		}
; 2968 : 	}
; 2969 : 
; 2970 : 	return pBestUnit;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+52]
	mov	DWORD PTR [esi], ebx
	mov	BYTE PTR [esi+4], 0
	test	ebx, ebx
	je	SHORT $LN186@getBestDef
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN186@getBestDef:
	mov	DWORD PTR $T236995[esp+56], 1
	mov	BYTE PTR __$EHRec$[esp+64], 1
	test	ebx, ebx
	je	SHORT $LN191@getBestDef
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN191@getBestDef:
	mov	ecx, DWORD PTR _pLoopUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], 0
	test	ecx, ecx
	je	SHORT $LN196@getBestDef
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN196@getBestDef:

; 2971 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$1:
	lea	ecx, DWORD PTR _pBestUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$2:
	mov	eax, DWORD PTR $T236995[ebp]
	and	eax, 1
	je	$LN24@getBestDef
	and	DWORD PTR $T236995[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
$LN24@getBestDef:
	ret	0
__ehhandler$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:
	mov	eax, OFFSET __ehfuncinfo$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ENDP ; CvPlot::getBestDefender
PUBLIC	?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ	; CvPlot::getSelectedUnit
EXTRN	?IsSelected@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsSelected
; Function compile flags: /Ogtpy
;	COMDAT ?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ
_TEXT	SEGMENT
?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ PROC		; CvPlot::getSelectedUnit, COMDAT
; _this$ = ecx

; 2981 : {

	push	ebx
	mov	ebx, ecx

; 2982 : 	const IDInfo* pUnitNode;
; 2983 : 	const CvUnit* pLoopUnit;
; 2984 : 
; 2985 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], 0
	push	esi
	push	edi
	jbe	SHORT $LN9@getSelecte
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN8@getSelecte
$LN9@getSelecte:
	xor	esi, esi
$LN8@getSelecte:

; 2986 : 
; 2987 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	SHORT $LN2@getSelecte
$LL3@getSelecte:

; 2988 : 	{
; 2989 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN16@getSelecte
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN16@getSelecte
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN17@getSelecte
$LN16@getSelecte:
	xor	edi, edi
$LN17@getSelecte:

; 2990 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN28@getSelecte
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN27@getSelecte
$LN28@getSelecte:
	xor	esi, esi
$LN27@getSelecte:

; 2991 : 
; 2992 : 		if(pLoopUnit && pLoopUnit->IsSelected())

	test	edi, edi
	je	SHORT $LN1@getSelecte
	mov	ecx, edi
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	jne	SHORT $LN36@getSelecte
$LN1@getSelecte:

; 2986 : 
; 2987 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	SHORT $LL3@getSelecte
$LN2@getSelecte:
	pop	edi
	pop	esi

; 2995 : 		}
; 2996 : 	}
; 2997 : 
; 2998 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 2999 : }

	ret	0
$LN36@getSelecte:

; 2993 : 		{
; 2994 : 			return pLoopUnit;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2999 : }

	ret	0
?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ ENDP		; CvPlot::getSelectedUnit
_TEXT	ENDS
PUBLIC	?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z	; CvPlot::getUnitPower
EXTRN	?GetFlavorValue@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetFlavorValue
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iCount$ = -12						; size = 4
$T237561 = -8						; size = 4
_this$ = -4						; size = 4
_eOwner$ = 8						; size = 4
?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z PROC	; CvPlot::getUnitPower, COMDAT
; _this$ = ecx

; 3004 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 3005 : 	const IDInfo* pUnitNode;
; 3006 : 	const CvUnit* pLoopUnit;
; 3007 : 	int iCount;
; 3008 : 
; 3009 : 	iCount = 0;

	xor	eax, eax
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR _iCount$[esp+20], eax

; 3010 : 
; 3011 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [esi+28], eax
	jbe	SHORT $LN16@getUnitPow
	mov	ebx, DWORD PTR [esi+24]
	jmp	SHORT $LN15@getUnitPow
$LN16@getUnitPow:
	xor	ebx, ebx
$LN15@getUnitPow:

; 3012 : 
; 3013 : 	while(pUnitNode != NULL)

	test	ebx, ebx
	je	$LN9@getUnitPow
	push	ebp
	push	edi
$LL10@getUnitPow:

; 3014 : 	{
; 3015 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jl	SHORT $LN23@getUnitPow
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN23@getUnitPow
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	edx
	mov	ebp, eax
	jmp	SHORT $LN24@getUnitPow
$LN23@getUnitPow:
	xor	ebp, ebp
$LN24@getUnitPow:

; 3016 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [esi+24]
	sub	ebx, eax
	add	ebx, 8
	sar	ebx, 3
	mov	ecx, ebx
	cmp	ecx, DWORD PTR [esi+28]
	jae	SHORT $LN35@getUnitPow
	lea	eax, DWORD PTR [eax+ecx*8]
	jmp	SHORT $LN58@getUnitPow
$LN35@getUnitPow:
	xor	eax, eax
$LN58@getUnitPow:
	mov	DWORD PTR $T237561[esp+28], eax
	mov	ebx, eax

; 3017 : 
; 3018 : 		if(!pLoopUnit) continue;

	test	ebp, ebp
	je	SHORT $LN57@getUnitPow

; 3019 : 
; 3020 : 		if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	mov	ecx, DWORD PTR _eOwner$[esp+24]
	cmp	ecx, -1
	je	SHORT $LN6@getUnitPow
	cmp	DWORD PTR [ebp+40], ecx
	jne	SHORT $LN57@getUnitPow
$LN6@getUnitPow:

; 3021 : 		{
; 3022 : 			for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, edi
	jle	SHORT $LN57@getUnitPow
	xor	esi, esi
	npad	8
$LL5@getUnitPow:

; 3023 : 			{
; 3024 : 				if(GC.getFlavorTypes((FlavorTypes)iI) == "FLAVOR_OFFENSE" ||
; 3025 : 				        GC.getFlavorTypes((FlavorTypes)iI) == "FLAVOR_DEFENSE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, esi
	push	OFFSET $SG223668
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	jne	SHORT $LN1@getUnitPow
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+ecx]
	push	OFFSET $SG223669
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN4@getUnitPow
$LN1@getUnitPow:

; 3026 : 				{
; 3027 : 					iCount += pLoopUnit->getUnitInfo().GetFlavorValue(iI);

	push	edi
	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetFlavorValue@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetFlavorValue
	add	DWORD PTR _iCount$[esp+28], eax
$LN4@getUnitPow:
	inc	edi
	add	esi, 28					; 0000001cH
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL5@getUnitPow
	mov	eax, DWORD PTR $T237561[esp+28]
	mov	esi, DWORD PTR _this$[esp+28]
$LN57@getUnitPow:

; 3012 : 
; 3013 : 	while(pUnitNode != NULL)

	test	eax, eax
	jne	$LL10@getUnitPow

; 3028 : 				}
; 3029 : 			}
; 3030 : 		}
; 3031 : 	}
; 3032 : 
; 3033 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+28]
	pop	edi
	pop	ebp
$LN9@getUnitPow:
	pop	esi
	pop	ebx

; 3034 : }

	add	esp, 12					; 0000000cH
	ret	4
?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP	; CvPlot::getUnitPower
_TEXT	ENDS
PUBLIC	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z	; CvPlot::defenseModifier
EXTRN	?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetDefenseModifierGlobal
EXTRN	?GetDefenseModifier@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetDefenseModifier
EXTRN	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::isFriendlyTerritory
EXTRN	?getDefenseModifier@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getDefenseModifier
EXTRN	?getDefenseModifier@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
_eDefender$ = 8						; size = 4
___formal$ = 12						; size = 1
_bHelp$ = 16						; size = 1
?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z PROC	; CvPlot::defenseModifier, COMDAT
; _this$ = ecx

; 3039 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 3040 : 	CvCity* pCity;
; 3041 : 	ImprovementTypes eImprovement;
; 3042 : 	int iModifier;
; 3043 : 
; 3044 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 3045 : 
; 3046 : 	// Can only get Defensive Bonus from ONE thing - they don't stack
; 3047 : 
; 3048 : 	// Hill (and mountain)
; 3049 : 	if(isHills() || isMountain())

	mov	al, BYTE PTR [esi+5]
	cmp	al, 1
	je	SHORT $LN14@defenseMod
	test	al, al
	je	SHORT $LN14@defenseMod

; 3052 : 	}
; 3053 : 	// Feature
; 3054 : 	else if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [esi+432]

; 3055 : 	{
; 3056 : 		iModifier = GC.getFeatureInfo(getFeatureType())->getDefenseModifier();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	al, -1
	je	SHORT $LN12@defenseMod
	movsx	eax, al
	push	eax
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getDefenseModifier@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getDefenseModifier
	mov	ebx, eax

; 3057 : 	}
; 3058 : 	// Terrain
; 3059 : 	else

	jmp	SHORT $LN69@defenseMod
$LN12@defenseMod:

; 3060 : 	{
; 3061 : 		iModifier = GC.getTerrainInfo(getTerrainType())->getDefenseModifier();

	movsx	eax, BYTE PTR [esi+6]
	push	eax
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getDefenseModifier@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getDefenseModifier

; 3062 : 
; 3063 : 		// Flat land gives defensive PENALTY
; 3064 : 		if(!isWater())

	cmp	BYTE PTR [esi+5], 3
	mov	ebx, eax
	je	SHORT $LN69@defenseMod

; 3065 : 		{
; 3066 : 			iModifier += /*-25*/ GC.getFLAT_LAND_EXTRA_DEFENSE();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7380
	jmp	SHORT $LN69@defenseMod
$LN14@defenseMod:

; 3050 : 	{
; 3051 : 		iModifier = /*25*/ GC.getHILLS_EXTRA_DEFENSE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7384
$LN69@defenseMod:

; 3067 : 		}
; 3068 : 	}
; 3069 : 
; 3070 : 	if(bHelp)

	cmp	BYTE PTR _bHelp$[esp+4], 0
	push	edi
	je	SHORT $LN9@defenseMod

; 3071 : 	{
; 3072 : 		eImprovement = getRevealedImprovementType(GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR [esi+164]
	movsx	edi, WORD PTR [ecx+eax*2]

; 3073 : 	}
; 3074 : 	else

	jmp	SHORT $LN8@defenseMod
$LN9@defenseMod:

; 3075 : 	{
; 3076 : 		eImprovement = getImprovementType();

	movsx	edi, BYTE PTR [esi+441]
$LN8@defenseMod:

; 3077 : 	}
; 3078 : 
; 3079 : 	if(eImprovement != NO_IMPROVEMENT && !IsImprovementPillaged())

	cmp	edi, -1
	je	$LN72@defenseMod
	test	BYTE PTR [esi+461], 1
	jne	SHORT $LN72@defenseMod

; 3080 : 	{
; 3081 : 		if(eDefender != NO_TEAM && (getTeam() == NO_TEAM || GET_TEAM(eDefender).isFriendlyTerritory(getTeam())))

	mov	eax, DWORD PTR _eDefender$[esp+8]
	cmp	eax, -1
	je	SHORT $LN70@defenseMod
	movsx	ecx, BYTE PTR [esi+4]
	cmp	ecx, -1
	je	SHORT $LN5@defenseMod
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN5@defenseMod
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	cmp	DWORD PTR [edx+ecx*4], -1
	je	SHORT $LN5@defenseMod
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	mov	ecx, esi
	mov	ebp, eax
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	push	eax
	mov	ecx, ebp
	call	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isFriendlyTerritory
	pop	ebp
	test	al, al
	je	SHORT $LN70@defenseMod
$LN5@defenseMod:

; 3082 : 		{
; 3083 : 			CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 3084 : 			if (pkImprovement)

	test	eax, eax
	je	SHORT $LN70@defenseMod

; 3085 : 				iModifier += pkImprovement->GetDefenseModifier();

	mov	ecx, eax
	call	?GetDefenseModifier@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetDefenseModifier
	add	ebx, eax
$LN70@defenseMod:

; 3086 : 		}
; 3087 : 		CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 3088 : 		if (pkImprovement)

	test	eax, eax
	je	SHORT $LN72@defenseMod

; 3089 : 		{
; 3090 : 			iModifier += pkImprovement->GetDefenseModifierGlobal();

	mov	ecx, eax
	call	?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetDefenseModifierGlobal
	add	ebx, eax
$LN72@defenseMod:

; 3091 : 		}
; 3092 : 	}
; 3093 : 
; 3094 : 	if(!bHelp)

	cmp	BYTE PTR _bHelp$[esp+8], 0
	pop	edi
	jne	SHORT $LN68@defenseMod

; 3095 : 	{
; 3096 : 		pCity = getPlotCity();

	mov	ecx, DWORD PTR [esi+104]
	test	ecx, ecx
	jl	SHORT $LN68@defenseMod
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN68@defenseMod
	mov	eax, DWORD PTR [esi+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
$LN68@defenseMod:
	pop	esi

; 3097 : 
; 3098 : 		if(pCity != NULL)
; 3099 : 		{
; 3100 : 		}
; 3101 : 	}
; 3102 : 
; 3103 : 	return iModifier;

	mov	eax, ebx
	pop	ebx

; 3104 : }

	ret	12					; 0000000cH
?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ENDP	; CvPlot::defenseModifier
_TEXT	ENDS
PUBLIC	?isAdjacentOwned@CvPlot@@QBE_NXZ		; CvPlot::isAdjacentOwned
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentOwned@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isAdjacentOwned@CvPlot@@QBE_NXZ PROC			; CvPlot::isAdjacentOwned, COMDAT
; _this$ = ecx

; 3157 : {

	push	ebp

; 3158 : 	CvPlot* pAdjacentPlot;
; 3159 : 	int iI;
; 3160 : 
; 3161 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebp, WORD PTR [ecx]
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
	npad	4
$LL5@isAdjacent@5:

; 3162 : 	{
; 3163 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3164 : 
; 3165 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent@5

; 3166 : 		{
; 3167 : 			if(pAdjacentPlot->getOwner() != NO_PLAYER)

	cmp	BYTE PTR [eax+4], -1
	jne	SHORT $LN15@isAdjacent@5
$LN4@isAdjacent@5:

; 3158 : 	CvPlot* pAdjacentPlot;
; 3159 : 	int iI;
; 3160 : 
; 3161 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@isAdjacent@5
	pop	edi
	pop	esi

; 3170 : 			}
; 3171 : 		}
; 3172 : 	}
; 3173 : 
; 3174 : 	return false;

	xor	al, al
	pop	ebp

; 3175 : }

	ret	0
$LN15@isAdjacent@5:
	pop	edi
	pop	esi

; 3168 : 			{
; 3169 : 				return true;

	mov	al, 1
	pop	ebp

; 3175 : }

	ret	0
?isAdjacentOwned@CvPlot@@QBE_NXZ ENDP			; CvPlot::isAdjacentOwned
_TEXT	ENDS
PUBLIC	?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::isAdjacentPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bLandOnly$ = 12					; size = 1
?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z PROC	; CvPlot::isAdjacentPlayer, COMDAT
; _this$ = ecx

; 3180 : {

	push	ebx

; 3181 : 	CvPlot* pAdjacentPlot;
; 3182 : 	int iI;
; 3183 : 
; 3184 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	bl, BYTE PTR _bLandOnly$[esp]
	push	ebp
	movsx	ebp, WORD PTR [ecx]
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
$LL7@isAdjacent@6:

; 3185 : 	{
; 3186 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3187 : 
; 3188 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN6@isAdjacent@6

; 3189 : 		{
; 3190 : 			if(pAdjacentPlot->getOwner() == ePlayer)

	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR _ePlayer$[esp+12]
	jne	SHORT $LN6@isAdjacent@6

; 3191 : 			{
; 3192 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	test	bl, bl
	je	SHORT $LN1@isAdjacent@6
	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN1@isAdjacent@6
$LN6@isAdjacent@6:

; 3181 : 	CvPlot* pAdjacentPlot;
; 3182 : 	int iI;
; 3183 : 
; 3184 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL7@isAdjacent@6
	pop	edi
	pop	esi
	pop	ebp

; 3195 : 				}
; 3196 : 			}
; 3197 : 		}
; 3198 : 	}
; 3199 : 
; 3200 : 	return false;

	xor	al, al
	pop	ebx

; 3201 : }

	ret	8
$LN1@isAdjacent@6:
	pop	edi
	pop	esi
	pop	ebp

; 3193 : 				{
; 3194 : 					return true;

	mov	al, 1
	pop	ebx

; 3201 : }

	ret	8
?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ENDP	; CvPlot::isAdjacentPlayer
_TEXT	ENDS
PUBLIC	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
; Function compile flags: /Ogtpy
;	COMDAT ?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z PROC ; CvPlot::IsAdjacentOwnedByOtherTeam, COMDAT
; _this$ = ecx

; 3205 : {

	push	ebx

; 3206 : 	CvPlot* pAdjacentPlot;
; 3207 : 	int iI;
; 3208 : 
; 3209 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx]
	push	ebp
	mov	ebp, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
$LL5@IsAdjacent:

; 3210 : 	{
; 3211 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3212 : 
; 3213 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@IsAdjacent

; 3214 : 		{
; 3215 : 			if(pAdjacentPlot->getTeam() != NO_TEAM && pAdjacentPlot->getTeam() != eTeam)

	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, -1
	je	SHORT $LN4@IsAdjacent
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN4@IsAdjacent
	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+eax*4], -1
	je	SHORT $LN4@IsAdjacent
	cmp	eax, -1
	je	SHORT $LN26@IsAdjacent
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN26@IsAdjacent
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN25@IsAdjacent
$LN26@IsAdjacent:
	or	eax, -1
$LN25@IsAdjacent:
	cmp	eax, DWORD PTR _eTeam$[esp+12]
	jne	SHORT $LN39@IsAdjacent
$LN4@IsAdjacent:

; 3206 : 	CvPlot* pAdjacentPlot;
; 3207 : 	int iI;
; 3208 : 
; 3209 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@IsAdjacent
	pop	edi
	pop	esi
	pop	ebp

; 3218 : 			}
; 3219 : 		}
; 3220 : 	}
; 3221 : 
; 3222 : 	return false;

	xor	al, al
	pop	ebx

; 3223 : 
; 3224 : }

	ret	4
$LN39@IsAdjacent:
	pop	edi
	pop	esi
	pop	ebp

; 3216 : 			{
; 3217 : 				return true;

	mov	al, 1
	pop	ebx

; 3223 : 
; 3224 : }

	ret	4
?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP ; CvPlot::IsAdjacentOwnedByOtherTeam
_TEXT	ENDS
PUBLIC	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isAdjacentTeam
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bLandOnly$ = 12					; size = 1
?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC	; CvPlot::isAdjacentTeam, COMDAT
; _this$ = ecx

; 3229 : {

	push	ebx

; 3230 : 	CvPlot* pAdjacentPlot;
; 3231 : 	int iI;
; 3232 : 
; 3233 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	ebp
	movsx	ebp, WORD PTR [ecx]
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	esi, esi
$LL7@isAdjacent@7:

; 3234 : 	{
; 3235 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3236 : 
; 3237 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN6@isAdjacent@7

; 3238 : 		{
; 3239 : 			if(pAdjacentPlot->getTeam() == eTeam)

	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -1
	je	SHORT $LN15@isAdjacent@7
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN15@isAdjacent@7
	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN14@isAdjacent@7
$LN15@isAdjacent@7:
	or	ecx, -1
$LN14@isAdjacent@7:
	cmp	ecx, DWORD PTR _eTeam$[esp+12]
	jne	SHORT $LN6@isAdjacent@7

; 3240 : 			{
; 3241 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	cmp	BYTE PTR _bLandOnly$[esp+12], 0
	je	SHORT $LN1@isAdjacent@7
	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN1@isAdjacent@7
$LN6@isAdjacent@7:

; 3230 : 	CvPlot* pAdjacentPlot;
; 3231 : 	int iI;
; 3232 : 
; 3233 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL7@isAdjacent@7
	pop	edi
	pop	esi
	pop	ebp

; 3244 : 				}
; 3245 : 			}
; 3246 : 		}
; 3247 : 	}
; 3248 : 
; 3249 : 	return false;

	xor	al, al
	pop	ebx

; 3250 : }

	ret	8
$LN1@isAdjacent@7:
	pop	edi
	pop	esi
	pop	ebp

; 3242 : 				{
; 3243 : 					return true;

	mov	al, 1
	pop	ebx

; 3250 : }

	ret	8
?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP	; CvPlot::isAdjacentTeam
_TEXT	ENDS
PUBLIC	?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z ; CvPlot::GetAdjacentFriendlyCity
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bLandOnly$ = 12					; size = 1
?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z PROC ; CvPlot::GetAdjacentFriendlyCity, COMDAT
; _this$ = ecx

; 3254 : {

	push	ebx

; 3255 : 	CvPlot* pAdjacentPlot;
; 3256 : 	int iI;
; 3257 : 
; 3258 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	ebx, DWORD PTR _eTeam$[esp]
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	xor	edi, edi
	npad	4
$LL9@GetAdjacen:

; 3259 : 	{
; 3260 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 3261 : 
; 3262 : 		if(pAdjacentPlot != NULL)

	test	esi, esi
	je	$LN8@GetAdjacen

; 3263 : 		{
; 3264 : 			if(pAdjacentPlot->getTeam() == eTeam && pAdjacentPlot->isCity())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN17@GetAdjacen
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN17@GetAdjacen
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN16@GetAdjacen
$LN17@GetAdjacen:
	or	eax, -1
$LN16@GetAdjacen:
	cmp	eax, ebx
	jne	SHORT $LN8@GetAdjacen
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN8@GetAdjacen
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN8@GetAdjacen
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN8@GetAdjacen

; 3265 : 			{
; 3266 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	cmp	BYTE PTR _bLandOnly$[esp+12], 0
	je	SHORT $LN3@GetAdjacen
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN8@GetAdjacen
$LN3@GetAdjacen:

; 3267 : 				{
; 3268 : 					CvCity* pCity = pAdjacentPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN8@GetAdjacen
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN8@GetAdjacen
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 3269 : 					if(pCity)

	test	esi, esi
	je	SHORT $LN8@GetAdjacen

; 3270 : 					{
; 3271 : 						if(pCity->getTeam() == eTeam)

	mov	ecx, esi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, ebx
	je	SHORT $LN42@GetAdjacen
$LN8@GetAdjacen:

; 3255 : 	CvPlot* pAdjacentPlot;
; 3256 : 	int iI;
; 3257 : 
; 3258 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	$LL9@GetAdjacen
	pop	edi
	pop	esi
	pop	ebp

; 3274 : 						}
; 3275 : 					}
; 3276 : 				}
; 3277 : 			}
; 3278 : 		}
; 3279 : 	}
; 3280 : 
; 3281 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 3282 : }

	ret	8
$LN42@GetAdjacen:
	pop	edi

; 3272 : 						{
; 3273 : 							return pCity;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 3282 : }

	ret	8
?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z ENDP ; CvPlot::GetAdjacentFriendlyCity
_TEXT	ENDS
PUBLIC	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z	; CvPlot::GetAdjacentCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z
_TEXT	SEGMENT
_bLandOnly$ = 8						; size = 1
?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z PROC	; CvPlot::GetAdjacentCity, COMDAT
; _this$ = ecx

; 3286 : {

	push	ebx

; 3287 : 	CvPlot* pAdjacentPlot;
; 3288 : 	int iI;
; 3289 : 
; 3290 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	bl, BYTE PTR _bLandOnly$[esp]
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	xor	edi, edi
	npad	4
$LL8@GetAdjacen@2:

; 3291 : 	{
; 3292 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 3293 : 
; 3294 : 		if(pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN7@GetAdjacen@2

; 3295 : 		{
; 3296 : 			if(pAdjacentPlot->isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN7@GetAdjacen@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN7@GetAdjacen@2
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN7@GetAdjacen@2

; 3297 : 			{
; 3298 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	test	bl, bl
	je	SHORT $LN2@GetAdjacen@2
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN7@GetAdjacen@2
$LN2@GetAdjacen@2:

; 3299 : 				{
; 3300 : 					CvCity* pCity = pAdjacentPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN7@GetAdjacen@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN7@GetAdjacen@2
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 3301 : 					if(pCity)

	test	eax, eax
	jne	SHORT $LN9@GetAdjacen@2
$LN7@GetAdjacen@2:

; 3287 : 	CvPlot* pAdjacentPlot;
; 3288 : 	int iI;
; 3289 : 
; 3290 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL8@GetAdjacen@2

; 3302 : 					{
; 3303 : 						return pCity;
; 3304 : 					}
; 3305 : 				}
; 3306 : 			}
; 3307 : 		}
; 3308 : 	}
; 3309 : 
; 3310 : 	return NULL;

	xor	eax, eax
$LN9@GetAdjacen@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3311 : }

	ret	4
?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z ENDP	; CvPlot::GetAdjacentCity
_TEXT	ENDS
PUBLIC	?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z ; CvPlot::GetNumAdjacentDifferentTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bIgnoreWater$ = 12					; size = 1
?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z PROC ; CvPlot::GetNumAdjacentDifferentTeam, COMDAT
; _this$ = ecx

; 3316 : {

	push	ebx
	push	ebp

; 3317 : 	CvPlot* pAdjacentPlot;
; 3318 : 	int iI;
; 3319 : 	int iRtnValue = 0;
; 3320 : 
; 3321 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebp, WORD PTR [ecx]
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	ebx, ebx
	xor	esi, esi
	npad	1
$LL6@GetNumAdja:

; 3322 : 	{
; 3323 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3324 : 
; 3325 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN5@GetNumAdja

; 3326 : 		{
; 3327 : 			if(bIgnoreWater && pAdjacentPlot->isWater())

	cmp	BYTE PTR _bIgnoreWater$[esp+12], 0
	je	SHORT $LN2@GetNumAdja
	cmp	BYTE PTR [eax+5], 3
	je	SHORT $LN5@GetNumAdja
$LN2@GetNumAdja:

; 3328 : 			{
; 3329 : 				continue;
; 3330 : 			}
; 3331 : 
; 3332 : 			if(pAdjacentPlot->getTeam() != eTeam)

	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, -1
	je	SHORT $LN16@GetNumAdja
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN16@GetNumAdja
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN15@GetNumAdja
$LN16@GetNumAdja:
	or	eax, -1
$LN15@GetNumAdja:
	cmp	eax, DWORD PTR _eTeam$[esp+12]
	je	SHORT $LN5@GetNumAdja

; 3333 : 			{
; 3334 : 				iRtnValue++;

	inc	ebx
$LN5@GetNumAdja:

; 3317 : 	CvPlot* pAdjacentPlot;
; 3318 : 	int iI;
; 3319 : 	int iRtnValue = 0;
; 3320 : 
; 3321 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL6@GetNumAdja
	pop	edi
	pop	esi
	pop	ebp

; 3335 : 			}
; 3336 : 		}
; 3337 : 	}
; 3338 : 
; 3339 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 3340 : }

	ret	8
?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z ENDP ; CvPlot::GetNumAdjacentDifferentTeam
_TEXT	ENDS
PUBLIC	?GetNumAdjacentMountains@CvPlot@@QBEHXZ		; CvPlot::GetNumAdjacentMountains
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumAdjacentMountains@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?GetNumAdjacentMountains@CvPlot@@QBEHXZ PROC		; CvPlot::GetNumAdjacentMountains, COMDAT
; _this$ = ecx

; 3343 : {

	push	ebx

; 3344 : 	CvPlot* pAdjacentPlot;
; 3345 : 	int iI;
; 3346 : 	int iNumMountains = 0;
; 3347 : 
; 3348 : 	for (iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx]
	push	ebp
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	xor	ebp, ebp
	xor	esi, esi
	npad	1
$LL5@GetNumAdja@2:

; 3349 : 	{
; 3350 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3351 : 
; 3352 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@GetNumAdja@2

; 3353 : 		{
; 3354 : 			if (pAdjacentPlot->isMountain())

	cmp	BYTE PTR [eax+5], 0
	jne	SHORT $LN4@GetNumAdja@2

; 3355 : 			{
; 3356 : 				iNumMountains++;

	inc	ebp
$LN4@GetNumAdja@2:

; 3344 : 	CvPlot* pAdjacentPlot;
; 3345 : 	int iI;
; 3346 : 	int iNumMountains = 0;
; 3347 : 
; 3348 : 	for (iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@GetNumAdja@2
	pop	edi
	pop	esi

; 3357 : 			}
; 3358 : 		}
; 3359 : 	}
; 3360 : 	return iNumMountains;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 3361 : }

	ret	0
?GetNumAdjacentMountains@CvPlot@@QBEHXZ ENDP		; CvPlot::GetNumAdjacentMountains
_TEXT	ENDS
PUBLIC	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
; Function compile flags: /Ogtpy
;	COMDAT ?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
_funcA$ = 8						; size = 4
_iData1A$ = 12						; size = 4
_iData2A$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
_funcB$ = 28						; size = 4
_iData1B$ = 32						; size = 4
_iData2B$ = 36						; size = 4
?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z PROC ; CvPlot::plotCount, COMDAT
; _this$ = ecx

; 3392 : {

	push	ecx
	push	ebx

; 3393 : 	const IDInfo* pUnitNode;
; 3394 : 	const CvUnit* pLoopUnit;
; 3395 : 	int iCount;
; 3396 : 
; 3397 : 	iCount = 0;

	xor	eax, eax
	mov	ebx, ecx
	push	esi
	mov	DWORD PTR _iCount$[esp+12], eax

; 3398 : 
; 3399 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], eax
	jbe	SHORT $LN17@plotCount
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN16@plotCount
$LN17@plotCount:
	xor	esi, esi
$LN16@plotCount:

; 3400 : 
; 3401 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN10@plotCount
	push	ebp

; 3404 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ebp, DWORD PTR _funcB$[esp+12]
	push	edi
$LL11@plotCount:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN24@plotCount

; 3402 : 	{
; 3403 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	cmp	eax, 64					; 00000040H
	jge	SHORT $LN24@plotCount
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN25@plotCount
$LN24@plotCount:
	xor	edi, edi
$LN25@plotCount:

; 3404 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN36@plotCount
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN35@plotCount
$LN36@plotCount:
	xor	esi, esi
$LN35@plotCount:

; 3405 : 
; 3406 : 		if(pLoopUnit)

	test	edi, edi
	je	SHORT $LN49@plotCount

; 3407 : 		{
; 3408 : 			if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	mov	eax, DWORD PTR _eOwner$[esp+16]
	cmp	eax, -1
	je	SHORT $LN7@plotCount
	cmp	DWORD PTR [edi+40], eax
	jne	SHORT $LN49@plotCount
$LN7@plotCount:

; 3409 : 			{
; 3410 : 				if((eTeam == NO_TEAM) || (pLoopUnit->getTeam() == eTeam))

	cmp	DWORD PTR _eTeam$[esp+16], -1
	je	SHORT $LN5@plotCount
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eTeam$[esp+16]
	jne	SHORT $LN49@plotCount
$LN5@plotCount:

; 3411 : 				{
; 3412 : 					if((funcA == NULL) || funcA(pLoopUnit, iData1A, iData2A))

	mov	eax, DWORD PTR _funcA$[esp+16]
	test	eax, eax
	je	SHORT $LN3@plotCount
	mov	ecx, DWORD PTR _iData2A$[esp+16]
	mov	edx, DWORD PTR _iData1A$[esp+16]
	push	ecx
	push	edx
	push	edi
	call	eax
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN49@plotCount
$LN3@plotCount:

; 3413 : 					{
; 3414 : 						if((funcB == NULL) || funcB(pLoopUnit, iData1B, iData2B))

	test	ebp, ebp
	je	SHORT $LN1@plotCount
	mov	eax, DWORD PTR _iData2B$[esp+16]
	mov	ecx, DWORD PTR _iData1B$[esp+16]
	push	eax
	push	ecx
	push	edi
	call	ebp
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN49@plotCount
$LN1@plotCount:

; 3415 : 						{
; 3416 : 							iCount++;

	inc	DWORD PTR _iCount$[esp+20]
$LN49@plotCount:

; 3400 : 
; 3401 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL11@plotCount

; 3417 : 						}
; 3418 : 					}
; 3419 : 				}
; 3420 : 			}
; 3421 : 		}
; 3422 : 	}
; 3423 : 
; 3424 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+20]
	pop	edi
	pop	ebp
$LN10@plotCount:
	pop	esi
	pop	ebx

; 3425 : }

	pop	ecx
	ret	32					; 00000020H
?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ENDP ; CvPlot::plotCount
_TEXT	ENDS
PUBLIC	?isRevealedBarbarian@CvPlot@@QBE_NXZ		; CvPlot::isRevealedBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealedBarbarian@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRevealedBarbarian@CvPlot@@QBE_NXZ PROC		; CvPlot::isRevealedBarbarian, COMDAT
; _this$ = ecx

; 3484 : {

	push	esi
	mov	esi, ecx

; 3485 : 	return (getRevealedOwner(GC.getGame().getActiveTeam(), true) == BARBARIAN_PLAYER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN6@isRevealed@2
	movsx	eax, BYTE PTR [esi+4]
	xor	ecx, ecx
	cmp	eax, 63					; 0000003fH
	sete	cl
	pop	edi
	mov	al, cl
	pop	esi

; 3486 : }

	ret	0

; 3485 : 	return (getRevealedOwner(GC.getGame().getActiveTeam(), true) == BARBARIAN_PLAYER);

$LN6@isRevealed@2:
	mov	eax, DWORD PTR [esi+160]
	movsx	eax, BYTE PTR [eax+edi]
	xor	ecx, ecx
	cmp	eax, 63					; 0000003fH
	sete	cl
	pop	edi
	mov	al, cl
	pop	esi

; 3486 : }

	ret	0
?isRevealedBarbarian@CvPlot@@QBE_NXZ ENDP		; CvPlot::isRevealedBarbarian
_TEXT	ENDS
PUBLIC	?isActiveVisible@CvPlot@@QBE_N_N@Z		; CvPlot::isActiveVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isActiveVisible@CvPlot@@QBE_N_N@Z
_TEXT	SEGMENT
_bDebug$ = 8						; size = 1
?isActiveVisible@CvPlot@@QBE_N_N@Z PROC			; CvPlot::isActiveVisible, COMDAT
; _this$ = ecx

; 3496 : {

	push	esi
	push	edi
	mov	edi, ecx

; 3497 : 	return isVisible(GC.getGame().getActiveTeam(), bDebug);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	BYTE PTR _bDebug$[esp+4], 0
	mov	esi, eax
	je	SHORT $LN7@isActiveVi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN7@isActiveVi
	pop	edi
	mov	al, 1
	pop	esi

; 3498 : }

	ret	4

; 3497 : 	return isVisible(GC.getGame().getActiveTeam(), bDebug);

$LN7@isActiveVi:
	cmp	esi, -1
	jne	SHORT $LN5@isActiveVi
	pop	edi
	xor	al, al
	pop	esi

; 3498 : }

	ret	4

; 3497 : 	return isVisible(GC.getGame().getActiveTeam(), bDebug);

$LN5@isActiveVi:
	mov	eax, DWORD PTR [edi+156]
	cmp	WORD PTR [eax+esi*2], 0
	pop	edi
	setg	al
	pop	esi

; 3498 : }

	ret	4
?isActiveVisible@CvPlot@@QBE_N_N@Z ENDP			; CvPlot::isActiveVisible
_TEXT	ENDS
PUBLIC	?isActiveVisible@CvPlot@@QBE_NXZ		; CvPlot::isActiveVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isActiveVisible@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isActiveVisible@CvPlot@@QBE_NXZ PROC			; CvPlot::isActiveVisible, COMDAT
; _this$ = ecx

; 3502 : {

	push	esi
	mov	esi, ecx

; 3503 : 	return isVisible(GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, -1
	jne	SHORT $LN5@isActiveVi@2
	xor	al, al
	pop	esi

; 3504 : }

	ret	0

; 3503 : 	return isVisible(GC.getGame().getActiveTeam());

$LN5@isActiveVi@2:
	mov	ecx, DWORD PTR [esi+156]
	cmp	WORD PTR [ecx+eax*2], 0
	pop	esi
	setg	al

; 3504 : }

	ret	0
?isActiveVisible@CvPlot@@QBE_NXZ ENDP			; CvPlot::isActiveVisible
_TEXT	ENDS
PUBLIC	?isVisibleToCivTeam@CvPlot@@QBE_NXZ		; CvPlot::isVisibleToCivTeam
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleToCivTeam@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isVisibleToCivTeam@CvPlot@@QBE_NXZ PROC		; CvPlot::isVisibleToCivTeam, COMDAT
; _this$ = ecx

; 3508 : {

	push	esi

; 3509 : 	int iI;
; 3510 : 
; 3511 : 	for(iI = 0; iI < MAX_CIV_TEAMS; ++iI)

	mov	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	xor	eax, eax
	npad	7
$LL5@isVisibleT:

; 3512 : 	{
; 3513 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, eax
	imul	edx, 2980				; 00000ba4H
	cmp	DWORD PTR [edx+esi+12], 0
	jle	SHORT $LN4@isVisibleT

; 3514 : 		{
; 3515 : 			if(isVisible(((TeamTypes)iI)))

	cmp	eax, -1
	je	SHORT $LN4@isVisibleT
	mov	edx, DWORD PTR [ecx+156]
	cmp	WORD PTR [edx+eax*2], 0
	setg	dl
	test	dl, dl
	jne	SHORT $LN18@isVisibleT
$LN4@isVisibleT:

; 3509 : 	int iI;
; 3510 : 
; 3511 : 	for(iI = 0; iI < MAX_CIV_TEAMS; ++iI)

	inc	eax
	cmp	eax, 63					; 0000003fH
	jl	SHORT $LL5@isVisibleT

; 3518 : 			}
; 3519 : 		}
; 3520 : 	}
; 3521 : 
; 3522 : 	return false;

	xor	al, al
	pop	esi

; 3523 : }

	ret	0
$LN18@isVisibleT:

; 3516 : 			{
; 3517 : 				return true;

	mov	al, 1
	pop	esi

; 3523 : }

	ret	0
?isVisibleToCivTeam@CvPlot@@QBE_NXZ ENDP		; CvPlot::isVisibleToCivTeam
_TEXT	ENDS
PUBLIC	?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isVisibleToEnemyTeam
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eFriendlyTeam$ = 8					; size = 4
?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isVisibleToEnemyTeam, COMDAT
; _this$ = ecx

; 3528 : {

	push	ebx

; 3529 : 	int iI;
; 3530 : 
; 3531 : 	for(iI = 0; iI < MAX_CIV_TEAMS; ++iI)

	mov	ebx, DWORD PTR _eFriendlyTeam$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	xor	esi, esi
	npad	5
$LL6@isVisibleT@2:

; 3532 : 	{
; 3533 : 		CvTeam& kTeam = GET_TEAM((TeamTypes)iI);

	mov	ecx, esi
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 3534 : 
; 3535 : 		if(kTeam.isAlive())

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN5@isVisibleT@2

; 3536 : 		{
; 3537 : 			if(kTeam.isAtWar(eFriendlyTeam))

	push	ebx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN5@isVisibleT@2

; 3538 : 			{
; 3539 : 				if(isVisible(((TeamTypes)iI)))

	cmp	esi, -1
	je	SHORT $LN5@isVisibleT@2
	mov	eax, DWORD PTR [edi+156]
	cmp	WORD PTR [eax+esi*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN19@isVisibleT@2
$LN5@isVisibleT@2:

; 3529 : 	int iI;
; 3530 : 
; 3531 : 	for(iI = 0; iI < MAX_CIV_TEAMS; ++iI)

	inc	esi
	cmp	esi, 63					; 0000003fH
	jl	SHORT $LL6@isVisibleT@2
	pop	edi
	pop	esi

; 3542 : 				}
; 3543 : 			}
; 3544 : 		}
; 3545 : 	}
; 3546 : 
; 3547 : 	return false;

	xor	al, al
	pop	ebx

; 3548 : }

	ret	4
$LN19@isVisibleT@2:
	pop	edi
	pop	esi

; 3540 : 				{
; 3541 : 					return true;

	mov	al, 1
	pop	ebx

; 3548 : }

	ret	4
?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isVisibleToEnemyTeam
_TEXT	ENDS
PUBLIC	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ	; CvPlot::isVisibleToWatchingHuman
EXTRN	?slotClaim@CvPreGame@@YA?AW4SlotClaim@@W4PlayerTypes@@@Z:PROC ; CvPreGame::slotClaim
EXTRN	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z:PROC ; CvPreGame::slotStatus
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ PROC		; CvPlot::isVisibleToWatchingHuman, COMDAT
; _this$ = ecx

; 3553 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 3554 : 	int iI;
; 3555 : 
; 3556 : 	for(iI = 0; iI < MAX_CIV_PLAYERS; ++iI)

	xor	ebx, ebx
	mov	ebp, ecx
	xor	edi, edi
	npad	6
$LL7@isVisibleT@3:

; 3557 : 	{
; 3558 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3559 : 		if( (thisPlayer.isAlive() && thisPlayer.isHuman()) || ( CvPreGame::slotStatus((PlayerTypes)iI) == SS_OBSERVER && CvPreGame::slotClaim((PlayerTypes)iI) == SLOTCLAIM_ASSIGNED) )

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	esi, DWORD PTR [edi+eax]
	je	SHORT $LN2@isVisibleT@3
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN3@isVisibleT@3
$LN2@isVisibleT@3:
	push	ebx
	call	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z ; CvPreGame::slotStatus
	add	esp, 4
	cmp	eax, 4
	jne	SHORT $LN6@isVisibleT@3
	push	ebx
	call	?slotClaim@CvPreGame@@YA?AW4SlotClaim@@W4PlayerTypes@@@Z ; CvPreGame::slotClaim
	add	esp, 4
	cmp	eax, 2
	jne	SHORT $LN6@isVisibleT@3
$LN3@isVisibleT@3:

; 3560 : 		{
; 3561 : 			if(isVisible(thisPlayer.getTeam()))

	mov	esi, DWORD PTR [esi+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN6@isVisibleT@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+esi*4]
	cmp	eax, -1
	je	SHORT $LN6@isVisibleT@3
	mov	ecx, DWORD PTR [ebp+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN31@isVisibleT@3
$LN6@isVisibleT@3:

; 3554 : 	int iI;
; 3555 : 
; 3556 : 	for(iI = 0; iI < MAX_CIV_PLAYERS; ++iI)

	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 3983868				; 003cc9fcH
	jl	SHORT $LL7@isVisibleT@3
	pop	edi
	pop	esi
	pop	ebp

; 3564 : 			}
; 3565 : 		}
; 3566 : 	}
; 3567 : 
; 3568 : 	return false;

	xor	al, al
	pop	ebx

; 3569 : }

	ret	0
$LN31@isVisibleT@3:
	pop	edi
	pop	esi
	pop	ebp

; 3562 : 			{
; 3563 : 				return true;

	mov	al, 1
	pop	ebx

; 3569 : }

	ret	0
?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ENDP		; CvPlot::isVisibleToWatchingHuman
_TEXT	ENDS
PUBLIC	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC	; CvPlot::isAdjacentVisible, COMDAT
; _this$ = ecx

; 3574 : {

	push	ebx

; 3575 : 	CvPlot* pAdjacentPlot;
; 3576 : 	int iI;
; 3577 : 
; 3578 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	ebx, DWORD PTR _eTeam$[esp]
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	xor	edi, edi
	npad	4
$LL5@isAdjacent@8:

; 3579 : 	{
; 3580 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 3581 : 
; 3582 : 		if(pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN4@isAdjacent@8

; 3583 : 		{
; 3584 : 			if(pAdjacentPlot->isVisible(eTeam, bDebug))

	cmp	BYTE PTR _bDebug$[esp+12], 0
	je	SHORT $LN14@isAdjacent@8
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	jne	SHORT $LN22@isAdjacent@8
$LN14@isAdjacent@8:
	cmp	ebx, -1
	je	SHORT $LN4@isAdjacent@8
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+ebx*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN22@isAdjacent@8
$LN4@isAdjacent@8:

; 3575 : 	CvPlot* pAdjacentPlot;
; 3576 : 	int iI;
; 3577 : 
; 3578 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL5@isAdjacent@8
	pop	edi
	pop	esi
	pop	ebp

; 3587 : 			}
; 3588 : 		}
; 3589 : 	}
; 3590 : 
; 3591 : 	return false;

	xor	al, al
	pop	ebx

; 3592 : }

	ret	8
$LN22@isAdjacent@8:
	pop	edi
	pop	esi
	pop	ebp

; 3585 : 			{
; 3586 : 				return true;

	mov	al, 1
	pop	ebx

; 3592 : }

	ret	8
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP	; CvPlot::isAdjacentVisible
_TEXT	ENDS
PUBLIC	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isAdjacentVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isAdjacentVisible, COMDAT
; _this$ = ecx

; 3596 : {

	push	ebx

; 3597 : 	CvPlot* pAdjacentPlot;
; 3598 : 	int iI;
; 3599 : 
; 3600 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx+2]
	push	ebp
	movsx	ebp, WORD PTR [ecx]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+12]
	xor	esi, esi
$LL5@isAdjacent@9:

; 3601 : 	{
; 3602 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	ebx
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3603 : 
; 3604 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent@9

; 3605 : 		{
; 3606 : 			if(pAdjacentPlot->isVisible(eTeam))

	cmp	edi, -1
	je	SHORT $LN4@isAdjacent@9
	mov	eax, DWORD PTR [eax+156]
	cmp	WORD PTR [eax+edi*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN18@isAdjacent@9
$LN4@isAdjacent@9:

; 3597 : 	CvPlot* pAdjacentPlot;
; 3598 : 	int iI;
; 3599 : 
; 3600 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@isAdjacent@9
	pop	edi
	pop	esi
	pop	ebp

; 3609 : 			}
; 3610 : 		}
; 3611 : 	}
; 3612 : 
; 3613 : 	return false;

	xor	al, al
	pop	ebx

; 3614 : }

	ret	4
$LN18@isAdjacent@9:
	pop	edi
	pop	esi
	pop	ebp

; 3607 : 			{
; 3608 : 				return true;

	mov	al, 1
	pop	ebx

; 3614 : }

	ret	4
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isAdjacentVisible
_TEXT	ENDS
PUBLIC	?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonvisible
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isAdjacentNonvisible, COMDAT
; _this$ = ecx

; 3618 : {

	push	ebx

; 3619 : 	CvPlot* pAdjacentPlot;
; 3620 : 	int iI;
; 3621 : 
; 3622 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx+2]
	push	ebp
	movsx	ebp, WORD PTR [ecx]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+12]
	xor	esi, esi
$LL5@isAdjacent@10:

; 3623 : 	{
; 3624 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	ebx
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3625 : 
; 3626 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent@10

; 3627 : 		{
; 3628 : 			if(!pAdjacentPlot->isVisible(eTeam))

	cmp	edi, -1
	je	SHORT $LN18@isAdjacent@10
	mov	eax, DWORD PTR [eax+156]
	cmp	WORD PTR [eax+edi*2], 0
	setg	al
	test	al, al
	je	SHORT $LN18@isAdjacent@10
$LN4@isAdjacent@10:

; 3619 : 	CvPlot* pAdjacentPlot;
; 3620 : 	int iI;
; 3621 : 
; 3622 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@isAdjacent@10
	pop	edi
	pop	esi
	pop	ebp

; 3631 : 			}
; 3632 : 		}
; 3633 : 	}
; 3634 : 
; 3635 : 	return false;

	xor	al, al
	pop	ebx

; 3636 : }

	ret	4
$LN18@isAdjacent@10:
	pop	edi
	pop	esi
	pop	ebp

; 3629 : 			{
; 3630 : 				return true;

	mov	al, 1
	pop	ebx

; 3636 : }

	ret	4
?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isAdjacentNonvisible
_TEXT	ENDS
PUBLIC	?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonvisible
; Function compile flags: /Ogtpy
;	COMDAT ?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z PROC ; CvPlot::getNumAdjacentNonvisible, COMDAT
; _this$ = ecx

; 3640 : {

	push	ecx
	push	ebx

; 3641 : 	CvPlot* pAdjacentPlot;
; 3642 : 	int iCount = 0;
; 3643 : 
; 3644 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [ecx]
	push	ebp
	mov	ebp, DWORD PTR _eTeam$[esp+8]
	push	esi
	xor	esi, esi
	push	edi
	movsx	edi, WORD PTR [ecx+2]
	mov	DWORD PTR _iCount$[esp+20], esi
$LL5@getNumAdja:

; 3645 : 	{
; 3646 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	edi
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 3647 : 
; 3648 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@getNumAdja

; 3649 : 		{
; 3650 : 			if(!pAdjacentPlot->isVisible(eTeam))

	cmp	ebp, -1
	je	SHORT $LN19@getNumAdja
	mov	eax, DWORD PTR [eax+156]
	cmp	WORD PTR [eax+ebp*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN4@getNumAdja
$LN19@getNumAdja:

; 3651 : 			{
; 3652 : 				iCount++;

	inc	DWORD PTR _iCount$[esp+20]
$LN4@getNumAdja:

; 3641 : 	CvPlot* pAdjacentPlot;
; 3642 : 	int iCount = 0;
; 3643 : 
; 3644 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@getNumAdja

; 3653 : 			}
; 3654 : 		}
; 3655 : 	}
; 3656 : 
; 3657 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3658 : }

	pop	ecx
	ret	4
?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z ENDP ; CvPlot::getNumAdjacentNonvisible
_TEXT	ENDS
PUBLIC	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealedGoody
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isRevealedGoody, COMDAT
; _this$ = ecx

; 3674 : {

	push	ebx
	push	edi

; 3675 : 	if(eTeam == NO_TEAM)

	mov	edi, DWORD PTR _eTeam$[esp+4]
	mov	ebx, ecx
	cmp	edi, -1
	jne	SHORT $LN4@isRevealed@3

; 3676 : 	{
; 3677 : 		return isGoody();

	mov	bl, BYTE PTR [ebx+441]
	cmp	bl, -1
	jne	SHORT $LN13@isRevealed@3
	pop	edi
	xor	al, al
	pop	ebx

; 3691 : }

	ret	4

; 3676 : 	{
; 3677 : 		return isGoody();

$LN13@isRevealed@3:
	movsx	eax, bl
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	pop	edi
	pop	ebx

; 3691 : }

	ret	4
$LN4@isRevealed@3:

; 3678 : 	}
; 3679 : 
; 3680 : 	if(GET_TEAM(eTeam).isBarbarian() || GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	esi, edi
	imul	esi, 2980				; 00000ba4H
	lea	ecx, DWORD PTR [esi+eax]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	test	al, al
	jne	SHORT $LN2@isRevealed@3
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, esi
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	SHORT $LN2@isRevealed@3

; 3683 : 	}
; 3684 : 
; 3685 : 	if(!isRevealed(eTeam))

	mov	eax, edi
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	mov	ecx, edi
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [ebx+eax*4+8]

; 3686 : 	{
; 3687 : 		return false;

	je	SHORT $LN2@isRevealed@3

; 3688 : 	}
; 3689 : 
; 3690 : 	return ((getRevealedImprovementType(eTeam) == NO_IMPROVEMENT) ? false : GC.getImprovementInfo(getRevealedImprovementType(eTeam))->IsGoody());

	mov	eax, DWORD PTR [ebx+164]
	movzx	eax, WORD PTR [eax+edi*2]
	cmp	ax, -1
	je	SHORT $LN2@isRevealed@3
	cwde
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	pop	esi
	pop	edi
	pop	ebx

; 3691 : }

	ret	4
$LN2@isRevealed@3:
	pop	esi
	pop	edi

; 3681 : 	{
; 3682 : 		return false;

	xor	al, al
	pop	ebx

; 3691 : }

	ret	4
?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isRevealedGoody
_TEXT	ENDS
PUBLIC	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z	; CvPlot::isFriendlyCity
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z:PROC ; CvUnit::getCombatOwner
; Function compile flags: /Ogtpy
;	COMDAT ?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z
_TEXT	SEGMENT
_kUnit$ = 8						; size = 4
___formal$ = 12						; size = 1
?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z PROC	; CvPlot::isFriendlyCity, COMDAT
; _this$ = ecx

; 3710 : {

	push	edi
	mov	edi, ecx

; 3711 : 	if(!getPlotCity())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN38@isFriendly
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN38@isFriendly
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	jne	SHORT $LN4@isFriendly
$LN38@isFriendly:

; 3712 : 	{
; 3713 : 		return false;

	xor	al, al
	pop	edi

; 3734 : }

	ret	8
$LN4@isFriendly:

; 3714 : 	}
; 3715 : 
; 3716 : 	TeamTypes ePlotTeam = getTeam();

	movsx	eax, BYTE PTR [edi+4]
	push	esi
	cmp	eax, -1
	je	SHORT $LN1@isFriendly
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@isFriendly
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]

; 3717 : 
; 3718 : 	if(NO_TEAM != ePlotTeam)

	cmp	esi, -1
	je	SHORT $LN1@isFriendly

; 3719 : 	{
; 3720 : 		TeamTypes eTeam = GET_PLAYER(kUnit.getCombatOwner(ePlotTeam, *this)).getTeam();

	mov	ecx, DWORD PTR _kUnit$[esp+4]
	push	edi
	push	esi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN31@isFriendly
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN32@isFriendly
$LN31@isFriendly:
	or	eax, -1
$LN32@isFriendly:

; 3721 : 
; 3722 : 		if(eTeam == ePlotTeam)

	cmp	eax, esi

; 3723 : 		{
; 3724 : 			return true;

	je	SHORT $LN40@isFriendly

; 3725 : 		}
; 3726 : 
; 3727 : 		if(GET_TEAM(ePlotTeam).IsAllowsOpenBordersToTeam(eTeam))

	imul	esi, 2980				; 00000ba4H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	mov	ecx, esi
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	je	SHORT $LN1@isFriendly
$LN40@isFriendly:
	pop	esi

; 3728 : 		{
; 3729 : 			return true;

	mov	al, 1
	pop	edi

; 3734 : }

	ret	8
$LN1@isFriendly:
	pop	esi

; 3730 : 		}
; 3731 : 	}
; 3732 : 
; 3733 : 	return false;

	xor	al, al
	pop	edi

; 3734 : }

	ret	8
?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ENDP	; CvPlot::isFriendlyCity
_TEXT	ENDS
PUBLIC	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
EXTRN	?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsPlayerHasOpenBorders
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ:PROC ; CvTeam::getLeaderID
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC ; CvPlot::IsFriendlyTerritory, COMDAT
; _this$ = ecx

; 3740 : 	// No friendly territory for barbs!
; 3741 : 	if(GET_PLAYER(ePlayer).isBarbarian())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ebp, DWORD PTR _ePlayer$[esp]
	push	esi
	mov	esi, ebp
	imul	esi, 63236				; 0000f704H
	push	edi
	mov	edi, ecx
	lea	ecx, DWORD PTR [esi+eax]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	je	SHORT $LN7@IsFriendly
	pop	edi
	pop	esi

; 3742 : 	{
; 3743 : 		return false;

	xor	al, al
	pop	ebp

; 3777 : 	{
; 3778 : 		return true;
; 3779 : 	}
; 3780 : 
; 3781 : 	return false;
; 3782 : }

	ret	4
$LN7@IsFriendly:

; 3744 : 	}
; 3745 : 
; 3746 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [ecx+esi+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	add	ecx, esi
	push	ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN18@IsFriendly
	mov	esi, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [esi+eax*4]
	jmp	SHORT $LN19@IsFriendly
$LN18@IsFriendly:
	or	ebx, -1
$LN19@IsFriendly:

; 3747 : 	TeamTypes ePlotOwner = getTeam();

	movsx	eax, BYTE PTR [edi+4]
	cmp	eax, -1
	je	SHORT $LN46@IsFriendly
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN46@IsFriendly
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [edx+eax*4]

; 3748 : 
; 3749 : 	// Nobody owns this plot
; 3750 : 	if(ePlotOwner == NO_TEAM)

	cmp	esi, -1
	jne	SHORT $LN6@IsFriendly
$LN46@IsFriendly:
	pop	ebx
	pop	edi
	pop	esi

; 3751 : 	{
; 3752 : 		return false;

	xor	al, al
	pop	ebp

; 3777 : 	{
; 3778 : 		return true;
; 3779 : 	}
; 3780 : 
; 3781 : 	return false;
; 3782 : }

	ret	4
$LN6@IsFriendly:

; 3753 : 	}
; 3754 : 
; 3755 : 	// Our territory
; 3756 : 	if(ePlotOwner == eTeam)

	cmp	esi, ebx

; 3757 : 	{
; 3758 : 		return true;

	je	SHORT $LN48@IsFriendly

; 3759 : 	}
; 3760 : 
; 3761 : 	// City State's territory we've earned OB with
; 3762 : 	if(!GET_PLAYER(ePlayer).isMinorCiv())

	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN2@IsFriendly

; 3763 : 	{
; 3764 : 		if(GET_TEAM(ePlotOwner).isMinorCiv())

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edi, esi
	imul	edi, 2980				; 00000ba4H
	lea	ecx, DWORD PTR [edi+eax]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	je	SHORT $LN2@IsFriendly

; 3765 : 		{
; 3766 : 			PlayerTypes eCityState = GET_TEAM(ePlotOwner).getLeaderID();

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, edi
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID

; 3767 : 
; 3768 : 			if(GET_PLAYER(eCityState).GetMinorCivAI()->IsPlayerHasOpenBorders(ePlayer))

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ecx, eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsPlayerHasOpenBorders
	test	al, al
	je	SHORT $LN2@IsFriendly
$LN48@IsFriendly:
	pop	ebx
	pop	edi
	pop	esi

; 3769 : 			{
; 3770 : 				return true;

	mov	al, 1
	pop	ebp

; 3777 : 	{
; 3778 : 		return true;
; 3779 : 	}
; 3780 : 
; 3781 : 	return false;
; 3782 : }

	ret	4
$LN2@IsFriendly:

; 3771 : 			}
; 3772 : 		}
; 3773 : 	}
; 3774 : 
; 3775 : 	// Major's territory we have OB with
; 3776 : 	if(GET_TEAM(ePlotOwner).IsAllowsOpenBordersToTeam(eTeam))

	imul	esi, 2980				; 00000ba4H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	mov	ecx, esi
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	pop	ebx
	pop	edi
	test	al, al
	pop	esi
	setne	al
	pop	ebp

; 3777 : 	{
; 3778 : 		return true;
; 3779 : 	}
; 3780 : 
; 3781 : 	return false;
; 3782 : }

	ret	4
?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP ; CvPlot::IsFriendlyTerritory
_TEXT	ENDS
PUBLIC	?isUnit@CvPlot@@QBE_NXZ				; CvPlot::isUnit
; Function compile flags: /Ogtpy
;	COMDAT ?isUnit@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isUnit@CvPlot@@QBE_NXZ PROC				; CvPlot::isUnit, COMDAT
; _this$ = ecx

; 3803 : 	return (getNumUnits() > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+28], eax
	setg	al

; 3804 : }

	ret	0
?isUnit@CvPlot@@QBE_NXZ ENDP				; CvPlot::isUnit
_TEXT	ENDS
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Ogtpy
;	COMDAT ?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_bAlwaysHostile$ = 8					; size = 1
?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z PROC		; isEnemy, COMDAT
; _pUnit$ = edi
; _eOtherTeam$ = esi

; 3809 : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	push	esi
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	je	SHORT $LN1@isEnemy

; 3810 : 	{
; 3811 : 		return false;

	xor	al, al

; 3816 : }

	ret	0
$LN1@isEnemy:

; 3812 : 	}
; 3813 : 
; 3814 : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	esi
	mov	ecx, edi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN12@isEnemy
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN13@isEnemy
$LN12@isEnemy:
	or	ecx, -1
$LN13@isEnemy:

; 3815 : 	return (bAlwaysHostile ? eOtherTeam != eOurTeam : atWar(eOtherTeam, eOurTeam));

	cmp	BYTE PTR _bAlwaysHostile$[esp-4], 0
	je	SHORT $LN4@isEnemy
	xor	eax, eax
	cmp	esi, ecx
	setne	al

; 3816 : }

	ret	0
$LN4@isEnemy:

; 3815 : 	return (bAlwaysHostile ? eOtherTeam != eOurTeam : atWar(eOtherTeam, eOurTeam));

	push	ecx
	push	esi
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	eax, al

; 3816 : }

	ret	0
?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ENDP		; isEnemy
_TEXT	ENDS
EXTRN	?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z:PROC	; isPotentialEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_bAlwaysHostile$ = 8					; size = 1
?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z PROC ; isPotentialEnemy, COMDAT
; _pUnit$ = edi
; _eOtherTeam$ = esi

; 3821 : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	push	esi
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	je	SHORT $LN1@isPotentia@2

; 3822 : 	{
; 3823 : 		return false;

	xor	al, al

; 3828 : }

	ret	0
$LN1@isPotentia@2:

; 3824 : 	}
; 3825 : 
; 3826 : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	esi
	mov	ecx, edi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN12@isPotentia@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN13@isPotentia@2
$LN12@isPotentia@2:
	or	ecx, -1
$LN13@isPotentia@2:

; 3827 : 	return (bAlwaysHostile ? eOtherTeam != eOurTeam : isPotentialEnemy(eOtherTeam, eOurTeam));

	cmp	BYTE PTR _bAlwaysHostile$[esp-4], 0
	je	SHORT $LN4@isPotentia@2
	xor	eax, eax
	cmp	esi, ecx
	setne	al

; 3828 : }

	ret	0
$LN4@isPotentia@2:

; 3827 : 	return (bAlwaysHostile ? eOtherTeam != eOurTeam : isPotentialEnemy(eOtherTeam, eOurTeam));

	push	ecx
	push	esi
	call	?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z	; isPotentialEnemy
	add	esp, 8
	movzx	eax, al

; 3828 : }

	ret	0
?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ENDP ; isPotentialEnemy
_TEXT	ENDS
PUBLIC	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
EXTRN	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z:PROC ; CvUnit::isAlwaysHostile
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_bAlwaysHostile$224118 = 8				; size = 1
_pUnit$ = 8						; size = 4
?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z PROC	; CvPlot::isVisibleEnemyDefender, COMDAT
; _this$ = ecx

; 3843 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 3844 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 3845 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [ebp+28], 0
	push	esi
	push	edi
	jbe	SHORT $LN10@isVisibleE
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN9@isVisibleE
$LN10@isVisibleE:
	xor	ebx, ebx
$LN9@isVisibleE:

; 3846 : 	if(pUnit && pUnitNode)

	mov	ecx, DWORD PTR _pUnit$[esp+12]
	test	ecx, ecx
	je	$LN3@isVisibleE
	test	ebx, ebx
	je	$LN3@isVisibleE

; 3847 : 	{
; 3848 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@isVisibleE
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@isVisibleE
$LN27@isVisibleE:
	or	esi, -1
$LN28@isVisibleE:

; 3849 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	push	ebp
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$224118[esp+12], al
	npad	6
$LL5@isVisibleE:

; 3850 : 
; 3851 : 		do
; 3852 : 		{
; 3853 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jl	SHORT $LN32@isVisibleE
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN32@isVisibleE
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN33@isVisibleE
$LN32@isVisibleE:
	xor	edi, edi
$LN33@isVisibleE:

; 3854 : 			pUnitNode = m_units.next(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	ebx, eax
	add	ebx, 8
	sar	ebx, 3
	cmp	ebx, DWORD PTR [ebp+28]
	jae	SHORT $LN42@isVisibleE
	lea	ebx, DWORD PTR [eax+ebx*8]
	jmp	SHORT $LN41@isVisibleE
$LN42@isVisibleE:
	xor	ebx, ebx
$LN41@isVisibleE:

; 3855 : 
; 3856 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 3857 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 3858 : #else
; 3859 : 			if(pLoopUnit)

	test	edi, edi
	je	SHORT $LN4@isVisibleE

; 3860 : #endif
; 3861 : 			{
; 3862 : 				if(pLoopUnit->IsCanDefend() && isEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	push	0
	mov	ecx, edi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN4@isVisibleE
	mov	eax, DWORD PTR _bAlwaysHostile$224118[esp+12]
	push	eax
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 4
	test	al, al
	jne	SHORT $LN50@isVisibleE
$LN4@isVisibleE:

; 3865 : 				}
; 3866 : 			}
; 3867 : 		}
; 3868 : 		while(pUnitNode != NULL);

	test	ebx, ebx
	jne	SHORT $LL5@isVisibleE
$LN3@isVisibleE:
	pop	edi
	pop	esi
	pop	ebp

; 3869 : 	}
; 3870 : 
; 3871 : 	return false;

	xor	al, al
	pop	ebx

; 3872 : }

	ret	4
$LN50@isVisibleE:
	pop	edi
	pop	esi
	pop	ebp

; 3863 : 				{
; 3864 : 					return true;

	mov	al, 1
	pop	ebx

; 3872 : }

	ret	4
?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ENDP	; CvPlot::isVisibleEnemyDefender
_TEXT	ENDS
PUBLIC	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z PROC ; CvPlot::getVisibleEnemyDefender, COMDAT
; _this$ = ecx

; 3910 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 3911 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [ebp+28], 0
	push	esi
	push	edi
	jbe	$LN3@getVisible
	mov	esi, DWORD PTR [ebp+24]

; 3912 : 	if(pUnitNode)

	test	esi, esi
	je	$LN3@getVisible

; 3913 : 	{
; 3914 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp+12]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@getVisible
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LL5@getVisible
$LN23@getVisible:
	or	ebx, -1
$LL5@getVisible:

; 3915 : 		do
; 3916 : 		{
; 3917 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN28@getVisible
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN28@getVisible
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	edi, eax
	jmp	SHORT $LN29@getVisible
$LN28@getVisible:
	xor	edi, edi
$LN29@getVisible:

; 3918 : 			pUnitNode = m_units.next(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebp+28]
	jae	SHORT $LN38@getVisible
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN37@getVisible
$LN38@getVisible:
	xor	esi, esi
$LN37@getVisible:

; 3919 : 
; 3920 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 3921 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 3922 : #else
; 3923 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	test	edi, edi
	je	SHORT $LN4@getVisible
	push	1
	push	0
	push	ebx
	mov	ecx, edi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN4@getVisible

; 3924 : #endif
; 3925 : 			{
; 3926 : 				if(pLoopUnit->IsCanDefend() && isEnemy(pLoopUnit, eTeam, false))

	push	0
	mov	ecx, edi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN4@getVisible
	push	ebx
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	jne	SHORT $LN4@getVisible
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	ebx
	mov	ecx, edi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN56@getVisible
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN57@getVisible
$LN56@getVisible:
	or	eax, -1
$LN57@getVisible:
	push	eax
	push	ebx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	jne	SHORT $LN62@getVisible
$LN4@getVisible:

; 3929 : 				}
; 3930 : 			}
; 3931 : 		}
; 3932 : 		while(pUnitNode != NULL);

	test	esi, esi
	jne	$LL5@getVisible
$LN3@getVisible:
	pop	edi
	pop	esi
	pop	ebp

; 3933 : 	}
; 3934 : 
; 3935 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 3936 : }

	ret	4
$LN62@getVisible:

; 3927 : 				{
; 3928 : 					return const_cast<CvUnit*>(pLoopUnit);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3936 : }

	ret	4
?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ENDP ; CvPlot::getVisibleEnemyDefender
_TEXT	ENDS
PUBLIC	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z	; CvPlot::getNumDefenders
; Function compile flags: /Ogtpy
;	COMDAT ?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z PROC	; CvPlot::getNumDefenders, COMDAT
; _this$ = ecx

; 3940 : {

	push	esi
	push	edi
	mov	edi, ecx

; 3941 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [edi+28], 0
	jbe	$LN6@getNumDefe
	mov	esi, DWORD PTR [edi+24]

; 3942 : 	if(pUnitNode != NULL)

	test	esi, esi
	je	SHORT $LN6@getNumDefe
	push	ebx
	push	ebp

; 3950 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ebp, DWORD PTR _ePlayer$[esp+12]
	xor	ebx, ebx
	npad	3
$LL5@getNumDefe:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN17@getNumDefe

; 3943 : 	{
; 3944 : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player must be valid");
; 3945 : 		int iCount = 0;
; 3946 : 
; 3947 : 		do
; 3948 : 		{
; 3949 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	cmp	eax, 64					; 00000040H
	jge	SHORT $LN17@getNumDefe
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	jmp	SHORT $LN18@getNumDefe
$LN17@getNumDefe:
	xor	eax, eax
$LN18@getNumDefe:

; 3950 : 			pUnitNode = m_units.next(pUnitNode);

	mov	edx, DWORD PTR [edi+24]
	sub	esi, edx
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+28]
	jae	SHORT $LN27@getNumDefe
	lea	esi, DWORD PTR [edx+esi*8]
	jmp	SHORT $LN26@getNumDefe
$LN27@getNumDefe:
	xor	esi, esi
$LN26@getNumDefe:

; 3951 : 
; 3952 : 			if(pLoopUnit)

	test	eax, eax
	je	SHORT $LN4@getNumDefe

; 3953 : 			{
; 3954 : 				if(pLoopUnit->getOwner() == ePlayer && pLoopUnit->IsCanDefend())

	cmp	DWORD PTR [eax+40], ebp
	jne	SHORT $LN4@getNumDefe
	push	0
	mov	ecx, eax
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN4@getNumDefe

; 3955 : 				{
; 3956 : 					++iCount;

	inc	ebx
$LN4@getNumDefe:

; 3957 : 				}
; 3958 : 			}
; 3959 : 		}
; 3960 : 		while(pUnitNode != NULL);

	test	esi, esi
	jne	SHORT $LL5@getNumDefe
	pop	ebp

; 3961 : 		return iCount;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 3965 : }

	ret	4
$LN6@getNumDefe:
	pop	edi

; 3962 : 	}
; 3963 : 
; 3964 : 	return 0;

	xor	eax, eax
	pop	esi

; 3965 : }

	ret	4
?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP	; CvPlot::getNumDefenders
_TEXT	ENDS
PUBLIC	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
; Function compile flags: /Ogtpy
;	COMDAT ?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z
_TEXT	SEGMENT
_bAlwaysHostile$224159 = -4				; size = 1
_iCount$224160 = 8					; size = 4
_pUnit$ = 8						; size = 4
?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z PROC ; CvPlot::getNumVisibleEnemyDefenders, COMDAT
; _this$ = ecx

; 3969 : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx

; 3970 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 3971 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [ebp+28], 0
	jbe	SHORT $LN10@getNumVisi
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN9@getNumVisi
$LN10@getNumVisi:
	xor	ebx, ebx
$LN9@getNumVisi:

; 3972 : 	if(pUnit && pUnitNode)

	mov	ecx, DWORD PTR _pUnit$[esp+8]
	test	ecx, ecx
	je	$LN6@getNumVisi
	test	ebx, ebx
	je	$LN6@getNumVisi

; 3973 : 	{
; 3974 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@getNumVisi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@getNumVisi
$LN27@getNumVisi:
	or	esi, -1
$LN28@getNumVisi:

; 3975 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	push	ebp
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$224159[esp+20], al

; 3976 : 		int iCount = 0;

	mov	DWORD PTR _iCount$224160[esp+16], 0
$LL5@getNumVisi:

; 3977 : 
; 3978 : 		do
; 3979 : 		{
; 3980 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jl	SHORT $LN32@getNumVisi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN32@getNumVisi
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN33@getNumVisi
$LN32@getNumVisi:
	xor	edi, edi
$LN33@getNumVisi:

; 3981 : 			pUnitNode = m_units.next(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	ebx, eax
	add	ebx, 8
	sar	ebx, 3
	cmp	ebx, DWORD PTR [ebp+28]
	jae	SHORT $LN42@getNumVisi
	lea	ebx, DWORD PTR [eax+ebx*8]
	jmp	SHORT $LN41@getNumVisi
$LN42@getNumVisi:
	xor	ebx, ebx
$LN41@getNumVisi:

; 3982 : 
; 3983 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 3984 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 3985 : #else
; 3986 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	test	edi, edi
	je	SHORT $LN4@getNumVisi
	push	1
	push	0
	push	esi
	mov	ecx, edi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN4@getNumVisi

; 3987 : #endif
; 3988 : 			{
; 3989 : 				if(pLoopUnit->IsCanDefend() && isEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	push	0
	mov	ecx, edi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN4@getNumVisi
	mov	eax, DWORD PTR _bAlwaysHostile$224159[esp+20]
	push	eax
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 4
	test	al, al
	je	SHORT $LN4@getNumVisi

; 3990 : 				{
; 3991 : 					++iCount;

	inc	DWORD PTR _iCount$224160[esp+16]
$LN4@getNumVisi:

; 3992 : 				}
; 3993 : 			}
; 3994 : 		}
; 3995 : 		while(pUnitNode != NULL);

	test	ebx, ebx
	jne	$LL5@getNumVisi

; 3996 : 		return iCount;

	mov	eax, DWORD PTR _iCount$224160[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3999 : }

	pop	ecx
	ret	4
$LN6@getNumVisi:
	pop	ebp

; 3997 : 	}
; 3998 : 	return 0;

	xor	eax, eax
	pop	ebx

; 3999 : }

	pop	ecx
	ret	4
?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ENDP ; CvPlot::getNumVisibleEnemyDefenders
_TEXT	ENDS
PUBLIC	?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisiblePotentialEnemyDefenders
; Function compile flags: /Ogtpy
;	COMDAT ?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z
_TEXT	SEGMENT
_bAlwaysHostile$224175 = -4				; size = 1
_iCount$224173 = 8					; size = 4
_pUnit$ = 8						; size = 4
?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z PROC ; CvPlot::getNumVisiblePotentialEnemyDefenders, COMDAT
; _this$ = ecx

; 4003 : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx

; 4004 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 4005 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [ebp+28], 0
	jbe	SHORT $LN10@getNumVisi@2
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN9@getNumVisi@2
$LN10@getNumVisi@2:
	xor	ebx, ebx
$LN9@getNumVisi@2:

; 4006 : 	if(pUnit && pUnitNode)

	mov	ecx, DWORD PTR _pUnit$[esp+8]
	test	ecx, ecx
	je	$LN6@getNumVisi@2
	test	ebx, ebx
	je	$LN6@getNumVisi@2

; 4007 : 	{
; 4008 : 		int iCount = 0;
; 4009 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	push	esi
	push	edi
	mov	DWORD PTR _iCount$224173[esp+16], 0
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@getNumVisi@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@getNumVisi@2
$LN27@getNumVisi@2:
	or	esi, -1
$LN28@getNumVisi@2:

; 4010 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	push	ebp
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$224175[esp+20], al
$LL5@getNumVisi@2:

; 4011 : 
; 4012 : 		do
; 4013 : 		{
; 4014 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jl	SHORT $LN32@getNumVisi@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN32@getNumVisi@2
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN33@getNumVisi@2
$LN32@getNumVisi@2:
	xor	edi, edi
$LN33@getNumVisi@2:

; 4015 : 			pUnitNode = m_units.next(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	ebx, eax
	add	ebx, 8
	sar	ebx, 3
	cmp	ebx, DWORD PTR [ebp+28]
	jae	SHORT $LN42@getNumVisi@2
	lea	ebx, DWORD PTR [eax+ebx*8]
	jmp	SHORT $LN41@getNumVisi@2
$LN42@getNumVisi@2:
	xor	ebx, ebx
$LN41@getNumVisi@2:

; 4016 : 
; 4017 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4018 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4019 : #else
; 4020 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	test	edi, edi
	je	SHORT $LN4@getNumVisi@2
	push	1
	push	0
	push	esi
	mov	ecx, edi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN4@getNumVisi@2

; 4021 : #endif
; 4022 : 			{
; 4023 : 				if(pLoopUnit->IsCanDefend() && isPotentialEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	push	0
	mov	ecx, edi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN4@getNumVisi@2
	mov	eax, DWORD PTR _bAlwaysHostile$224175[esp+20]
	push	eax
	call	?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isPotentialEnemy
	add	esp, 4
	test	al, al
	je	SHORT $LN4@getNumVisi@2

; 4024 : 				{
; 4025 : 					++iCount;

	inc	DWORD PTR _iCount$224173[esp+16]
$LN4@getNumVisi@2:

; 4026 : 				}
; 4027 : 			}
; 4028 : 		}
; 4029 : 		while(pUnitNode != NULL);

	test	ebx, ebx
	jne	$LL5@getNumVisi@2

; 4030 : 		return iCount;

	mov	eax, DWORD PTR _iCount$224173[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4034 : }

	pop	ecx
	ret	4
$LN6@getNumVisi@2:
	pop	ebp

; 4031 : 	}
; 4032 : 
; 4033 : 	return 0;

	xor	eax, eax
	pop	ebx

; 4034 : }

	pop	ecx
	ret	4
?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ENDP ; CvPlot::getNumVisiblePotentialEnemyDefenders
_TEXT	ENDS
PUBLIC	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::isVisibleEnemyUnit, COMDAT
; _this$ = ecx

; 4038 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 4039 : 	CvAssertMsg(ePlayer != NO_PLAYER, "Source player must be valid");
; 4040 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [ebp+28], 0
	push	esi
	push	edi
	jbe	$LN3@isVisibleE@2
	mov	esi, DWORD PTR [ebp+24]

; 4041 : 	if(pUnitNode)

	test	esi, esi
	je	$LN3@isVisibleE@2

; 4042 : 	{
; 4043 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp+12]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@isVisibleE@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LL5@isVisibleE@2
$LN23@isVisibleE@2:
	or	ebx, -1
$LL5@isVisibleE@2:

; 4044 : 
; 4045 : 		do
; 4046 : 		{
; 4047 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN28@isVisibleE@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN28@isVisibleE@2
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	edi, eax
	jmp	SHORT $LN29@isVisibleE@2
$LN28@isVisibleE@2:
	xor	edi, edi
$LN29@isVisibleE@2:

; 4048 : 			pUnitNode = m_units.next(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebp+28]
	jae	SHORT $LN38@isVisibleE@2
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN37@isVisibleE@2
$LN38@isVisibleE@2:
	xor	esi, esi
$LN37@isVisibleE@2:

; 4049 : 
; 4050 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4051 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4052 : #else
; 4053 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	test	edi, edi
	je	SHORT $LN4@isVisibleE@2
	push	1
	push	0
	push	ebx
	mov	ecx, edi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN4@isVisibleE@2

; 4054 : #endif
; 4055 : 			{
; 4056 : 				if(isEnemy(pLoopUnit, eTeam, false))

	push	ebx
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	jne	SHORT $LN4@isVisibleE@2
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	ebx
	mov	ecx, edi
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN56@isVisibleE@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN57@isVisibleE@2
$LN56@isVisibleE@2:
	or	eax, -1
$LN57@isVisibleE@2:
	push	eax
	push	ebx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	jne	SHORT $LN62@isVisibleE@2
$LN4@isVisibleE@2:

; 4059 : 				}
; 4060 : 			}
; 4061 : 		}
; 4062 : 		while(pUnitNode != NULL);

	test	esi, esi
	jne	$LL5@isVisibleE@2
$LN3@isVisibleE@2:
	pop	edi
	pop	esi
	pop	ebp

; 4063 : 	}
; 4064 : 
; 4065 : 	return false;

	xor	al, al
	pop	ebx

; 4066 : }

	ret	4
$LN62@isVisibleE@2:
	pop	edi
	pop	esi
	pop	ebp

; 4057 : 				{
; 4058 : 					return true;

	mov	al, 1
	pop	ebx

; 4066 : }

	ret	4
?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::isVisibleEnemyUnit
_TEXT	ENDS
PUBLIC	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z	; CvPlot::isVisibleEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_bAlwaysHostile$224202 = 8				; size = 1
_pUnit$ = 8						; size = 4
?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z PROC	; CvPlot::isVisibleEnemyUnit, COMDAT
; _this$ = ecx

; 4070 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 4071 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 4072 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [ebp+28], 0
	push	esi
	push	edi
	jbe	SHORT $LN10@isVisibleE@3
	mov	ebx, DWORD PTR [ebp+24]
	jmp	SHORT $LN9@isVisibleE@3
$LN10@isVisibleE@3:
	xor	ebx, ebx
$LN9@isVisibleE@3:

; 4073 : 	if(pUnit && pUnitNode)

	mov	ecx, DWORD PTR _pUnit$[esp+12]
	test	ecx, ecx
	je	$LN3@isVisibleE@3
	test	ebx, ebx
	je	$LN3@isVisibleE@3

; 4074 : 	{
; 4075 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@isVisibleE@3
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@isVisibleE@3
$LN27@isVisibleE@3:
	or	esi, -1
$LN28@isVisibleE@3:

; 4076 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	push	ebp
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$224202[esp+12], al
	npad	6
$LL5@isVisibleE@3:

; 4077 : 
; 4078 : 		do
; 4079 : 		{
; 4080 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	jl	SHORT $LN32@isVisibleE@3
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN32@isVisibleE@3
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN33@isVisibleE@3
$LN32@isVisibleE@3:
	xor	edi, edi
$LN33@isVisibleE@3:

; 4081 : 			pUnitNode = m_units.next(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	ebx, eax
	add	ebx, 8
	sar	ebx, 3
	cmp	ebx, DWORD PTR [ebp+28]
	jae	SHORT $LN42@isVisibleE@3
	lea	ebx, DWORD PTR [eax+ebx*8]
	jmp	SHORT $LN41@isVisibleE@3
$LN42@isVisibleE@3:
	xor	ebx, ebx
$LN41@isVisibleE@3:

; 4082 : 
; 4083 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4084 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4085 : #else
; 4086 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	test	edi, edi
	je	SHORT $LN4@isVisibleE@3
	push	1
	push	0
	push	esi
	mov	ecx, edi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN4@isVisibleE@3

; 4087 : #endif
; 4088 : 			{
; 4089 : 				if(isEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	mov	eax, DWORD PTR _bAlwaysHostile$224202[esp+12]
	push	eax
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 4
	test	al, al
	jne	SHORT $LN50@isVisibleE@3
$LN4@isVisibleE@3:

; 4092 : 				}
; 4093 : 			}
; 4094 : 		}
; 4095 : 		while(pUnitNode != NULL);

	test	ebx, ebx
	jne	SHORT $LL5@isVisibleE@3
$LN3@isVisibleE@3:
	pop	edi
	pop	esi
	pop	ebp

; 4096 : 	}
; 4097 : 
; 4098 : 	return false;

	xor	al, al
	pop	ebx

; 4099 : }

	ret	4
$LN50@isVisibleE@3:
	pop	edi
	pop	esi
	pop	ebp

; 4090 : 				{
; 4091 : 					return true;

	mov	al, 1
	pop	ebx

; 4099 : }

	ret	4
?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ENDP	; CvPlot::isVisibleEnemyUnit
_TEXT	ENDS
PUBLIC	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::isVisibleOtherUnit, COMDAT
; _this$ = ecx

; 4103 : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 4104 : 	CvAssertMsg(ePlayer != NO_PLAYER, "Source player must be valid");
; 4105 : 	const IDInfo* pUnitNode = m_units.head();

	cmp	DWORD PTR [ebp+28], 0
	push	esi
	push	edi
	jbe	$LN3@isVisibleO
	mov	esi, DWORD PTR [ebp+24]

; 4106 : 	if(pUnitNode)

	test	esi, esi
	je	$LN3@isVisibleO

; 4107 : 	{
; 4108 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp+12]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@isVisibleO
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LL5@isVisibleO
$LN23@isVisibleO:
	or	ebx, -1
$LL5@isVisibleO:

; 4109 : 
; 4110 : 		do
; 4111 : 		{
; 4112 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN28@isVisibleO
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN28@isVisibleO
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	edi, eax
	jmp	SHORT $LN29@isVisibleO
$LN28@isVisibleO:
	xor	edi, edi
$LN29@isVisibleO:

; 4113 : 			pUnitNode = m_units.next(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebp+28]
	jae	SHORT $LN38@isVisibleO
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN37@isVisibleO
$LN38@isVisibleO:
	xor	esi, esi
$LN37@isVisibleO:

; 4114 : 
; 4115 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4116 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4117 : #else
; 4118 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	test	edi, edi
	je	SHORT $LN4@isVisibleO
	push	1
	push	0
	push	ebx
	mov	ecx, edi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN4@isVisibleO

; 4119 : #endif
; 4120 : 			{
; 4121 : 				if(isOtherTeam(pLoopUnit, eTeam))

	push	ebx
	mov	ecx, edi
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	test	al, al
	jne	SHORT $LN4@isVisibleO
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, ebx
	setne	al
	test	al, al
	jne	SHORT $LN49@isVisibleO
$LN4@isVisibleO:

; 4124 : 				}
; 4125 : 			}
; 4126 : 		}
; 4127 : 		while(pUnitNode != NULL);

	test	esi, esi
	jne	SHORT $LL5@isVisibleO
$LN3@isVisibleO:
	pop	edi
	pop	esi
	pop	ebp

; 4128 : 	}
; 4129 : 
; 4130 : 	return false;

	xor	al, al
	pop	ebx

; 4131 : }

	ret	4
$LN49@isVisibleO:
	pop	edi
	pop	esi
	pop	ebp

; 4122 : 				{
; 4123 : 					return true;

	mov	al, 1
	pop	ebx

; 4131 : }

	ret	4
?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::isVisibleOtherUnit
_TEXT	ENDS
PUBLIC	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
EXTRN	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z:PROC	; CvUnit::AreUnitsOfSameType
EXTRN	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z:PROC ; CvUnit::canEmbarkOnto
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z
_TEXT	SEGMENT
_iNumUnitsOfSameType$ = -12				; size = 4
_kUnitTeam$ = -8					; size = 4
_iPlotUnitLimit$ = -4					; size = 4
_bPretendEmbarked$ = 8					; size = 1
_pUnit$ = 8						; size = 4
_bBreakOnUnitLimit$ = 12				; size = 1
?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z PROC ; CvPlot::getNumFriendlyUnitsOfType, COMDAT
; _this$ = ecx

; 4193 : {

	sub	esp, 12					; 0000000cH
	push	ebx

; 4194 : 	int iNumUnitsOfSameType = 0;
; 4195 : 
; 4196 : 	bool bCombat = false;
; 4197 : 
; 4198 : 	// slewis - trying to break the 1upt for trade units
; 4199 : 	if (pUnit->isTrade())

	mov	ebx, DWORD PTR _pUnit$[esp+12]
	push	ebp
	mov	ebp, ecx
	mov	ecx, ebx
	mov	DWORD PTR _iNumUnitsOfSameType$[esp+20], 0
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	test	al, al
	je	SHORT $LN12@getNumFrie
	pop	ebp

; 4200 : 	{
; 4201 : 		return 0;

	xor	eax, eax
	pop	ebx

; 4257 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN12@getNumFrie:

; 4202 : 	}
; 4203 : 
; 4204 : 	if(pUnit->IsCombatUnit())
; 4205 : 	{
; 4206 : 		bCombat = true;
; 4207 : 	}
; 4208 : 
; 4209 : 	bool bPretendEmbarked = false;
; 4210 : 	if(isWater() && pUnit->canEmbarkOnto(*pUnit->plot(), *this))

	cmp	BYTE PTR [ebp+5], 3
	mov	BYTE PTR _bPretendEmbarked$[esp+16], 0
	jne	SHORT $LN10@getNumFrie
	push	0
	push	0
	push	ebp
	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, ebx
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	test	al, al
	je	SHORT $LN10@getNumFrie

; 4211 : 	{
; 4212 : 		bPretendEmbarked = true;

	mov	BYTE PTR _bPretendEmbarked$[esp+16], 1
$LN10@getNumFrie:
	push	esi

; 4213 : 	}
; 4214 : 
; 4215 : 	CvTeam& kUnitTeam = GET_TEAM(pUnit->getTeam());

	mov	ecx, ebx
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 4216 : 
; 4217 : 	const IDInfo* pUnitNode;
; 4218 : 	const CvUnit* pLoopUnit;
; 4219 : 
; 4220 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebp+28], 0
	mov	DWORD PTR _kUnitTeam$[esp+24], eax
	jbe	SHORT $LN26@getNumFrie
	mov	esi, DWORD PTR [ebp+24]
	jmp	SHORT $LN25@getNumFrie
$LN26@getNumFrie:
	xor	esi, esi
$LN25@getNumFrie:

; 4221 : 
; 4222 : 	int iPlotUnitLimit = GC.getPLOT_UNIT_LIMIT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	push	edi
	mov	DWORD PTR _iPlotUnitLimit$[esp+28], eax

; 4223 : 
; 4224 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN8@getNumFrie
$LL9@getNumFrie:

; 4225 : 	{
; 4226 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN35@getNumFrie
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN35@getNumFrie
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN36@getNumFrie
$LN35@getNumFrie:
	xor	edi, edi
$LN36@getNumFrie:

; 4227 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebp+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebp+28]
	jae	SHORT $LN47@getNumFrie
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN46@getNumFrie
$LN47@getNumFrie:
	xor	esi, esi
$LN46@getNumFrie:

; 4228 : 
; 4229 : 		if(pLoopUnit != NULL)

	test	edi, edi
	je	SHORT $LN66@getNumFrie

; 4230 : 		{
; 4231 : 			// Don't include an enemy unit, or else it won't let us attack it :)
; 4232 : 			if(!kUnitTeam.isAtWar(pLoopUnit->getTeam()))

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	ecx, DWORD PTR _kUnitTeam$[esp+28]
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN66@getNumFrie

; 4233 : 			{
; 4234 : 				// Units of the same type OR Units belonging to different civs
; 4235 : 				if(pUnit->getOwner() != pLoopUnit->getOwner() || pLoopUnit->AreUnitsOfSameType(*pUnit, bPretendEmbarked))

	mov	eax, DWORD PTR [ebx+40]
	cmp	eax, DWORD PTR [edi+40]
	jne	SHORT $LN4@getNumFrie
	mov	ecx, DWORD PTR _bPretendEmbarked$[esp+24]
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z ; CvUnit::AreUnitsOfSameType
	test	al, al
	je	SHORT $LN65@getNumFrie
$LN4@getNumFrie:

; 4236 : 				{
; 4237 : 					// We should allow as many cargo units as we want
; 4238 : 					if(!pLoopUnit->isCargo())

	mov	ecx, edi
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	test	al, al
	jne	SHORT $LN65@getNumFrie

; 4239 : 					{
; 4240 : 						// Unit is the same domain & combat type, not allowed more than the limit
; 4241 : 						iNumUnitsOfSameType++;

	inc	DWORD PTR _iNumUnitsOfSameType$[esp+28]
$LN65@getNumFrie:

; 4242 : 					}
; 4243 : 				}
; 4244 : 
; 4245 : 				// Does the calling function want us to break out? (saves processing time)
; 4246 : 				if(bBreakOnUnitLimit)

	cmp	BYTE PTR _bBreakOnUnitLimit$[esp+24], 0
	je	SHORT $LN66@getNumFrie

; 4247 : 				{
; 4248 : 					if(iNumUnitsOfSameType > iPlotUnitLimit)

	mov	eax, DWORD PTR _iNumUnitsOfSameType$[esp+28]
	cmp	eax, DWORD PTR _iPlotUnitLimit$[esp+28]
	jg	SHORT $LN68@getNumFrie
$LN66@getNumFrie:

; 4223 : 
; 4224 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL9@getNumFrie
$LN8@getNumFrie:

; 4249 : 					{
; 4250 : 						return iNumUnitsOfSameType;
; 4251 : 					}
; 4252 : 				}
; 4253 : 			}
; 4254 : 		}
; 4255 : 	}
; 4256 : 	return iNumUnitsOfSameType;

	mov	eax, DWORD PTR _iNumUnitsOfSameType$[esp+28]
$LN68@getNumFrie:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4257 : }

	add	esp, 12					; 0000000cH
	ret	8
?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ENDP ; CvPlot::getNumFriendlyUnitsOfType
_TEXT	ENDS
PUBLIC	?isFighting@CvPlot@@QBE_NXZ			; CvPlot::isFighting
; Function compile flags: /Ogtpy
;	COMDAT ?isFighting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isFighting@CvPlot@@QBE_NXZ PROC			; CvPlot::isFighting, COMDAT
; _this$ = ecx

; 4262 : {

	push	esi
	mov	esi, ecx

; 4263 : 	return (isUnitFighting() || isCityFighting());

	call	?isUnitFighting@CvPlot@@QBE_NXZ		; CvPlot::isUnitFighting
	test	al, al
	jne	SHORT $LN3@isFighting
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN13@isFighting
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN13@isFighting
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN13@isFighting
	mov	ecx, eax
	call	?isFighting@CvCity@@QBE_NXZ		; CvCity::isFighting
	test	al, al
	jne	SHORT $LN3@isFighting
$LN13@isFighting:
	xor	eax, eax
	pop	esi

; 4264 : }

	ret	0
$LN3@isFighting:

; 4263 : 	return (isUnitFighting() || isCityFighting());

	mov	eax, 1
	pop	esi

; 4264 : }

	ret	0
?isFighting@CvPlot@@QBE_NXZ ENDP			; CvPlot::isFighting
_TEXT	ENDS
PUBLIC	?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z	; CvPlot::canHaveFeature
EXTRN	?isRequiresRiver@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isRequiresRiver
EXTRN	?isNoAdjacent@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNoAdjacent
EXTRN	?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ:PROC ; CvFeatureInfo::isRequiresFlatlands
EXTRN	?isNoRiver@CvFeatureInfo@@QBE_NXZ:PROC		; CvFeatureInfo::isNoRiver
EXTRN	?isNoCoast@CvFeatureInfo@@QBE_NXZ:PROC		; CvFeatureInfo::isNoCoast
EXTRN	?isTerrain@CvFeatureInfo@@QBE_NH@Z:PROC		; CvFeatureInfo::isTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z
_TEXT	SEGMENT
_pkFeature$ = -4					; size = 4
_eFeature$ = 8						; size = 4
?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z PROC	; CvPlot::canHaveFeature, COMDAT
; _this$ = ecx

; 4302 : {

	push	ecx
	push	esi

; 4303 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 4304 : 
; 4305 : 	if(eFeature == NO_FEATURE)

	mov	esi, DWORD PTR _eFeature$[esp+4]
	push	edi
	mov	edi, ecx
	cmp	esi, -1
	jne	SHORT $LN16@canHaveFea
	pop	edi

; 4306 : 	{
; 4307 : 		return true;

	mov	al, 1
	pop	esi

; 4373 : }

	pop	ecx
	ret	4
$LN16@canHaveFea:

; 4308 : 	}
; 4309 : 
; 4310 : 	if(getFeatureType() != NO_FEATURE)

	cmp	BYTE PTR [edi+432], -1
	je	SHORT $LN15@canHaveFea
$LN46@canHaveFea:
	pop	edi

; 4311 : 	{
; 4312 : 		return false;

	xor	al, al
	pop	esi

; 4373 : }

	pop	ecx
	ret	4
$LN15@canHaveFea:

; 4313 : 	}
; 4314 : 
; 4315 : 	if(isMountain())

	cmp	BYTE PTR [edi+5], 0

; 4316 : 	{
; 4317 : 		return false;

	je	SHORT $LN46@canHaveFea

; 4318 : 	}
; 4319 : 
; 4320 : 	if(isCity())

	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al

; 4321 : 	{
; 4322 : 		return false;

	jne	SHORT $LN46@canHaveFea

; 4323 : 	}
; 4324 : 
; 4325 : 	CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	esi, eax
	mov	DWORD PTR _pkFeature$[esp+12], esi

; 4326 : 	if(pkFeature == NULL)

	test	esi, esi

; 4327 : 	{
; 4328 : 		return false;

	je	SHORT $LN46@canHaveFea

; 4329 : 	}
; 4330 : 
; 4331 : 	if(!pkFeature->isTerrain(getTerrainType()))

	movsx	eax, BYTE PTR [edi+6]
	push	eax
	mov	ecx, esi
	call	?isTerrain@CvFeatureInfo@@QBE_NH@Z	; CvFeatureInfo::isTerrain
	test	al, al

; 4332 : 	{
; 4333 : 		return false;

	je	SHORT $LN46@canHaveFea

; 4334 : 	}
; 4335 : 
; 4336 : 	if(pkFeature->isNoCoast() && isCoastalLand())

	mov	ecx, esi
	call	?isNoCoast@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoCoast
	test	al, al
	je	SHORT $LN10@canHaveFea
	push	-1
	mov	ecx, edi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al

; 4337 : 	{
; 4338 : 		return false;

	jne	SHORT $LN46@canHaveFea
$LN10@canHaveFea:

; 4339 : 	}
; 4340 : 
; 4341 : 	if(pkFeature->isNoRiver() && isRiver())

	mov	ecx, esi
	call	?isNoRiver@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoRiver
	test	al, al
	je	SHORT $LN9@canHaveFea
	cmp	BYTE PTR [edi+457], 0

; 4342 : 	{
; 4343 : 		return false;

	jg	SHORT $LN46@canHaveFea
$LN9@canHaveFea:

; 4344 : 	}
; 4345 : 
; 4346 : 	if(pkFeature->isRequiresFlatlands() && isHills())

	mov	ecx, esi
	call	?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ ; CvFeatureInfo::isRequiresFlatlands
	test	al, al
	je	SHORT $LN8@canHaveFea
	cmp	BYTE PTR [edi+5], 1

; 4347 : 	{
; 4348 : 		return false;

	je	SHORT $LN46@canHaveFea
$LN8@canHaveFea:
	push	ebx
	push	ebp

; 4349 : 	}
; 4350 : 
; 4351 : 	if(pkFeature->isNoAdjacent())

	mov	ecx, esi
	call	?isNoAdjacent@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoAdjacent
	test	al, al
	je	SHORT $LN4@canHaveFea

; 4352 : 	{
; 4353 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebx, WORD PTR [edi+2]
	movsx	ebp, WORD PTR [edi]
	xor	esi, esi
	npad	2
$LL6@canHaveFea:

; 4354 : 		{
; 4355 : 			CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	esi
	push	ebx
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 4356 : 
; 4357 : 			if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN5@canHaveFea

; 4358 : 			{
; 4359 : 				if(pAdjacentPlot->getFeatureType() == eFeature)

	movsx	eax, BYTE PTR [eax+432]
	cmp	eax, DWORD PTR _eFeature$[esp+16]
	je	SHORT $LN42@canHaveFea
$LN5@canHaveFea:

; 4352 : 	{
; 4353 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL6@canHaveFea

; 4358 : 			{
; 4359 : 				if(pAdjacentPlot->getFeatureType() == eFeature)

	mov	esi, DWORD PTR _pkFeature$[esp+20]
$LN4@canHaveFea:

; 4360 : 				{
; 4361 : 					return false;
; 4362 : 				}
; 4363 : 			}
; 4364 : 		}
; 4365 : 	}
; 4366 : 
; 4367 : 	if(!isRiver() && pkFeature->isRequiresRiver())

	cmp	BYTE PTR [edi+457], 0
	jg	SHORT $LN1@canHaveFea
	mov	ecx, esi
	call	?isRequiresRiver@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isRequiresRiver
	test	al, al
	je	SHORT $LN1@canHaveFea
$LN42@canHaveFea:
	pop	ebp
	pop	ebx
	pop	edi

; 4368 : 	{
; 4369 : 		return false;

	xor	al, al
	pop	esi

; 4373 : }

	pop	ecx
	ret	4
$LN1@canHaveFea:
	pop	ebp
	pop	ebx
	pop	edi

; 4370 : 	}
; 4371 : 
; 4372 : 	return true;

	mov	al, 1
	pop	esi

; 4373 : }

	pop	ecx
	ret	4
?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z ENDP	; CvPlot::canHaveFeature
_TEXT	ENDS
PUBLIC	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z	; CvPlot::isValidRoute
EXTRN	?isEnemyRoute@CvUnit@@QBE_NXZ:PROC		; CvUnit::isEnemyRoute
; Function compile flags: /Ogtpy
;	COMDAT ?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z PROC		; CvPlot::isValidRoute, COMDAT
; _this$ = ecx

; 4385 : {

	push	esi
	mov	esi, ecx

; 4386 : 	if((RouteTypes)m_eRouteType != NO_ROUTE && !m_bRoutePillaged)

	cmp	BYTE PTR [esi+447], -1
	push	edi
	mov	edi, DWORD PTR _pUnit$[esp+4]
	je	SHORT $LN5@isValidRou
	test	BYTE PTR [esi+461], 2
	jne	SHORT $LN5@isValidRou

; 4387 : 	{
; 4388 : 		if(!pUnit->isEnemy(getTeam(), this) || pUnit->isEnemyRoute())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN10@isValidRou
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN10@isValidRou
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN9@isValidRou
$LN10@isValidRou:
	or	eax, -1
$LN9@isValidRou:
	push	esi
	push	eax
	mov	ecx, edi
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	test	al, al
	je	SHORT $LN4@isValidRou
	mov	ecx, edi
	call	?isEnemyRoute@CvUnit@@QBE_NXZ		; CvUnit::isEnemyRoute
	test	al, al
	je	SHORT $LN5@isValidRou
$LN4@isValidRou:
	pop	edi

; 4389 : 		{
; 4390 : 			return true;

	mov	al, 1
	pop	esi

; 4404 : }

	ret	4
$LN5@isValidRou:

; 4391 : 		}
; 4392 : 	}
; 4393 : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 4394 : 	if (pUnit->getOwner() != NO_PLAYER && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad())

	mov	eax, DWORD PTR [edi+40]
	cmp	eax, -1
	je	SHORT $LN2@isValidRou
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+325], 0
	je	SHORT $LN2@isValidRou

; 4395 : 	{
; 4396 : 		if (getOwner() == pUnit->getOwner() && (getFeatureType() == FEATURE_FOREST || getFeatureType() == FEATURE_JUNGLE))

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, DWORD PTR [edi+40]
	jne	SHORT $LN2@isValidRou
	mov	al, BYTE PTR [esi+432]
	cmp	al, 5
	je	SHORT $LN4@isValidRou
	cmp	al, 1

; 4397 : 		{
; 4398 : 			return true;

	je	SHORT $LN4@isValidRou
$LN2@isValidRou:
	pop	edi

; 4399 : 		}
; 4400 : 	}
; 4401 : #endif
; 4402 : 
; 4403 : 	return false;

	xor	al, al
	pop	esi

; 4404 : }

	ret	4
?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z ENDP		; CvPlot::isValidRoute
_TEXT	ENDS
PUBLIC	?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z	; CvPlot::SetTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bActive$ = 12						; size = 1
?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z PROC	; CvPlot::SetTradeRoute, COMDAT
; _this$ = ecx

; 4408 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 4409 : 	bool bWasTradeRoute = IsTradeRoute();

	mov	edx, DWORD PTR [esi+388]

; 4410 : 
; 4411 : 	uint uiNewBitValue = (1 << ePlayer);

	mov	ecx, DWORD PTR _ePlayer$[esp+4]
	test	edx, edx
	seta	bl
	mov	eax, 1
	shl	eax, cl

; 4412 : 	if(bActive)

	cmp	BYTE PTR _bActive$[esp+4], 0
	je	SHORT $LN8@SetTradeRo

; 4413 : 	{
; 4414 : 		m_uiTradeRouteBitFlags |= uiNewBitValue;

	or	edx, eax
	mov	DWORD PTR [esi+388], edx

; 4415 : 	}
; 4416 : 	else

	jmp	SHORT $LN7@SetTradeRo
$LN8@SetTradeRo:

; 4417 : 	{
; 4418 : 		m_uiTradeRouteBitFlags &= ~uiNewBitValue;

	not	eax
	and	eax, edx
	mov	DWORD PTR [esi+388], eax
$LN7@SetTradeRo:

; 4419 : 	}
; 4420 : 
; 4421 : 	if(IsTradeRoute() != bWasTradeRoute)

	cmp	DWORD PTR [esi+388], 0
	seta	al
	cmp	al, bl
	je	SHORT $LN3@SetTradeRo
	push	edi

; 4422 : 	{
; 4423 : 		for(int iI = 0; iI < MAX_TEAMS; ++iI)

	xor	edi, edi
	npad	10
$LL5@SetTradeRo:

; 4424 : 		{
; 4425 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 4426 : 			if (iI == OBSERVER_TEAM || ((GET_TEAM((TeamTypes)iI).isAlive()) && GC.getGame().getActiveTeam() == (TeamTypes)iI))
; 4427 : #else
; 4428 : 			if(GET_TEAM((TeamTypes)iI).isAlive() && GC.getGame().getActiveTeam() == (TeamTypes)iI)

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, edi
	imul	eax, 2980				; 00000ba4H
	cmp	DWORD PTR [eax+ecx+12], 0
	jle	SHORT $LN4@SetTradeRo
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, edi
	jne	SHORT $LN4@SetTradeRo

; 4429 : #endif
; 4430 : 			{
; 4431 : 				if(isVisible((TeamTypes)iI))

	cmp	edi, -1
	je	SHORT $LN4@SetTradeRo
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+edi*2], 0
	setg	al
	test	al, al
	je	SHORT $LN4@SetTradeRo

; 4432 : 				{
; 4433 : 					setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	33					; 00000021H
	call	edx
	or	BYTE PTR [esi+462], 1
$LN4@SetTradeRo:
	inc	edi
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL5@SetTradeRo
	pop	edi
$LN3@SetTradeRo:
	pop	esi
	pop	ebx

; 4434 : 				}
; 4435 : 			}
; 4436 : 		}
; 4437 : 	}
; 4438 : }

	ret	8
?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z ENDP	; CvPlot::SetTradeRoute
_TEXT	ENDS
PUBLIC	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction
EXTRN	?IsHoveringUnit@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsHoveringUnit
EXTRN	?canMoveAllTerrain@CvUnit@@QBE_NXZ:PROC		; CvUnit::canMoveAllTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z PROC	; CvPlot::isValidDomainForAction, COMDAT
; _this$ = ecx

; 4487 : {

	push	esi
	push	edi

; 4488 : 	switch(unit.getDomainType())

	mov	edi, DWORD PTR _unit$[esp+4]
	mov	esi, ecx
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ecx, 3
	cmp	eax, ecx
	ja	SHORT $LN1@isValidDom
	jmp	DWORD PTR $LN21@isValidDom[eax*4]
$LN4@isValidDom:

; 4489 : 	{
; 4490 : 	case DOMAIN_SEA:
; 4491 : 		  return (isWater() || unit.canMoveAllTerrain() || IsAllowsSailLand());

	cmp	BYTE PTR [esi+5], cl
	je	SHORT $LN11@isValidDom
	mov	ecx, edi
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al
	jne	SHORT $LN11@isValidDom
	mov	ecx, esi
	call	?IsAllowsSailLand@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsSailLand
	test	al, al
	jne	SHORT $LN11@isValidDom
	pop	edi
	xor	eax, eax
	pop	esi

; 4509 : }

	ret	4
$LN2@isValidDom:

; 4492 : 		break;
; 4493 : 
; 4494 : 	case DOMAIN_AIR:
; 4495 : 		return false;
; 4496 : 		break;
; 4497 : 
; 4498 : 	case DOMAIN_LAND:
; 4499 : 	case DOMAIN_IMMOBILE:
; 4500 : 		return (!isWater() || unit.IsHoveringUnit() || unit.canMoveAllTerrain() || unit.isEmbarked() || IsAllowsWalkWater());

	cmp	BYTE PTR [esi+5], cl
	jne	SHORT $LN11@isValidDom
	mov	ecx, edi
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	test	al, al
	jne	SHORT $LN11@isValidDom
	mov	ecx, edi
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al
	jne	SHORT $LN11@isValidDom
	cmp	BYTE PTR [edi+1652], al
	jne	SHORT $LN11@isValidDom
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN11@isValidDom
	pop	edi
	xor	eax, eax
	pop	esi

; 4509 : }

	ret	4
$LN11@isValidDom:
	pop	edi

; 4492 : 		break;
; 4493 : 
; 4494 : 	case DOMAIN_AIR:
; 4495 : 		return false;
; 4496 : 		break;
; 4497 : 
; 4498 : 	case DOMAIN_LAND:
; 4499 : 	case DOMAIN_IMMOBILE:
; 4500 : 		return (!isWater() || unit.IsHoveringUnit() || unit.canMoveAllTerrain() || unit.isEmbarked() || IsAllowsWalkWater());

	mov	eax, 1
	pop	esi

; 4509 : }

	ret	4
$LN1@isValidDom:
	pop	edi

; 4501 : 		break;
; 4502 : 
; 4503 : 	default:
; 4504 : 		CvAssert(false);
; 4505 : 		break;
; 4506 : 	}
; 4507 : 
; 4508 : 	return false;

	xor	al, al
	pop	esi

; 4509 : }

	ret	4
	npad	1
$LN21@isValidDom:
	DD	$LN4@isValidDom
	DD	$LN1@isValidDom
	DD	$LN2@isValidDom
	DD	$LN2@isValidDom
?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ENDP	; CvPlot::isValidDomainForAction
_TEXT	ENDS
PUBLIC	?waterArea@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::waterArea
; Function compile flags: /Ogtpy
;	COMDAT ?waterArea@CvPlot@@QBEPAVCvArea@@XZ
_TEXT	SEGMENT
_pBestArea$ = -4					; size = 4
?waterArea@CvPlot@@QBEPAVCvArea@@XZ PROC		; CvPlot::waterArea, COMDAT
; _this$ = ecx

; 4547 : {

	push	ecx
	push	ebx
	mov	ebx, ecx

; 4548 : 	CvArea* pBestArea;
; 4549 : 	CvPlot* pAdjacentPlot;
; 4550 : 	int iValue;
; 4551 : 	int iBestValue;
; 4552 : 	int iI;
; 4553 : 
; 4554 : 	if(isWater())

	cmp	BYTE PTR [ebx+5], 3
	jne	SHORT $LN7@waterArea

; 4555 : 	{
; 4556 : 		return area();

	mov	eax, DWORD PTR [ebx+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	pop	ebx

; 4582 : }

	pop	ecx
	ret	0
$LN7@waterArea:
	push	ebp
	push	esi

; 4557 : 	}
; 4558 : 
; 4559 : 	iBestValue = 0;

	xor	ebp, ebp
	push	edi
	xor	edi, edi

; 4560 : 	pBestArea = NULL;

	mov	DWORD PTR _pBestArea$[esp+20], ebp
	npad	6
$LL6@waterArea:

; 4561 : 
; 4562 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)
; 4563 : 	{
; 4564 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4565 : 
; 4566 : 		if(pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN5@waterArea

; 4567 : 		{
; 4568 : 			if(pAdjacentPlot->isWater())

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN5@waterArea

; 4569 : 			{
; 4570 : 				iValue = pAdjacentPlot->area()->getNumTiles();

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles

; 4571 : 
; 4572 : 				if(iValue > iBestValue)

	cmp	eax, edi
	jle	SHORT $LN5@waterArea

; 4573 : 				{
; 4574 : 					iBestValue = iValue;
; 4575 : 					pBestArea = pAdjacentPlot->area();

	mov	esi, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	mov	edi, eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pBestArea$[esp+20], eax
$LN5@waterArea:
	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL6@waterArea

; 4576 : 				}
; 4577 : 			}
; 4578 : 		}
; 4579 : 	}
; 4580 : 
; 4581 : 	return pBestArea;

	mov	eax, DWORD PTR _pBestArea$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4582 : }

	pop	ecx
	ret	0
?waterArea@CvPlot@@QBEPAVCvArea@@XZ ENDP		; CvPlot::waterArea
_TEXT	ENDS
PUBLIC	?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ	; CvPlot::secondWaterArea
; Function compile flags: /Ogtpy
;	COMDAT ?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ
_TEXT	SEGMENT
_pBestArea$ = -8					; size = 4
_pWaterArea$ = -4					; size = 4
?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ PROC		; CvPlot::secondWaterArea, COMDAT
; _this$ = ecx

; 4586 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx

; 4587 : 
; 4588 : 	CvArea* pWaterArea = waterArea();

	call	?waterArea@CvPlot@@QBEPAVCvArea@@XZ	; CvPlot::waterArea

; 4589 : 	CvArea* pBestArea;
; 4590 : 	CvPlot* pAdjacentPlot;
; 4591 : 	int iValue;
; 4592 : 	int iBestValue;
; 4593 : 	int iI;
; 4594 : 
; 4595 : 	CvAssert(!isWater());
; 4596 : 
; 4597 : 	iBestValue = 0;

	xor	edi, edi
	mov	DWORD PTR _pWaterArea$[esp+24], eax
	xor	ebp, ebp

; 4598 : 	pBestArea = NULL;

	mov	DWORD PTR _pBestArea$[esp+24], edi
	npad	6
$LL6@secondWate:

; 4599 : 
; 4600 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)
; 4601 : 	{
; 4602 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4603 : 
; 4604 : 		if(pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN5@secondWate

; 4605 : 		{
; 4606 : 			if(pAdjacentPlot->isWater() && (pAdjacentPlot->getArea() != pWaterArea->GetID()))

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN5@secondWate
	mov	eax, DWORD PTR [esi+356]
	mov	edx, DWORD PTR _pWaterArea$[esp+24]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN5@secondWate

; 4607 : 			{
; 4608 : 				iValue = pAdjacentPlot->area()->getNumTiles();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles

; 4609 : 
; 4610 : 				if(iValue > iBestValue)

	cmp	eax, ebp
	jle	SHORT $LN5@secondWate

; 4611 : 				{
; 4612 : 					iBestValue = iValue;
; 4613 : 					pBestArea = pAdjacentPlot->area();

	mov	esi, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	mov	ebp, eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pBestArea$[esp+24], eax
$LN5@secondWate:
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL6@secondWate

; 4614 : 				}
; 4615 : 			}
; 4616 : 		}
; 4617 : 	}
; 4618 : 
; 4619 : 	return pBestArea;

	mov	eax, DWORD PTR _pBestArea$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4620 : 
; 4621 : }

	add	esp, 8
	ret	0
?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ ENDP		; CvPlot::secondWaterArea
_TEXT	ENDS
PUBLIC	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
EXTRN	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetCultureAdjacentSameType
; Function compile flags: /Ogtpy
;	COMDAT ?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_kImprovement$ = 8					; size = 4
_eValue$ = 12						; size = 4
?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z PROC ; CvPlot::ComputeCultureFromAdjacentImprovement, COMDAT
; _this$ = ecx

; 4808 : {

	push	ebx
	push	ebp

; 4809 : 	CvPlot* pAdjacentPlot;
; 4810 : 	int iRtnValue = 0;
; 4811 : 
; 4812 : 	if(kImprovement.GetCultureAdjacentSameType() > 0)

	mov	ebp, DWORD PTR _kImprovement$[esp+4]
	push	edi
	mov	edi, ecx
	mov	ecx, ebp
	xor	ebx, ebx
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	test	eax, eax
	jle	SHORT $LN16@ComputeCul
	push	esi

; 4813 : 	{
; 4814 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	esi, esi
	npad	7
$LL4@ComputeCul:

; 4815 : 		{
; 4816 : 			pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	esi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 4817 : 			if(pAdjacentPlot && pAdjacentPlot->getImprovementType() == eValue)

	test	eax, eax
	je	SHORT $LN3@ComputeCul
	movsx	edx, BYTE PTR [eax+441]
	cmp	edx, DWORD PTR _eValue$[esp+12]
	jne	SHORT $LN3@ComputeCul

; 4818 : 			{
; 4819 : 				iRtnValue += kImprovement.GetCultureAdjacentSameType();

	mov	ecx, ebp
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	add	ebx, eax
$LN3@ComputeCul:
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL4@ComputeCul
	pop	esi
$LN16@ComputeCul:
	pop	edi
	pop	ebp

; 4820 : 			}
; 4821 : 		}
; 4822 : 	}
; 4823 : 
; 4824 : 	return iRtnValue;

	mov	eax, ebx
	pop	ebx

; 4825 : }

	ret	8
?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ENDP ; CvPlot::ComputeCultureFromAdjacentImprovement
_TEXT	ENDS
PUBLIC	?hasCoastAtSECorner@CvPlot@@QBE_NXZ		; CvPlot::hasCoastAtSECorner
; Function compile flags: /Ogtpy
;	COMDAT ?hasCoastAtSECorner@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?hasCoastAtSECorner@CvPlot@@QBE_NXZ PROC		; CvPlot::hasCoastAtSECorner, COMDAT
; _this$ = ecx

; 5087 : 	CvPlot* pAdjacentPlot;
; 5088 : 
; 5089 : 	if(isWater())

	cmp	BYTE PTR [ecx+5], 3
	jne	SHORT $LN3@hasCoastAt

; 5090 : 	{
; 5091 : 		return true;

	mov	al, 1

; 5107 : }

	ret	0
$LN3@hasCoastAt:
	push	esi

; 5092 : 	}
; 5093 : 
; 5094 : 	pAdjacentPlot = plotDirection(getX(), getY(), DIRECTION_EAST);

	movsx	esi, WORD PTR [ecx+2]
	push	edi
	movsx	edi, WORD PTR [ecx]
	push	1
	push	esi
	push	edi
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 5095 : 	if(pAdjacentPlot != NULL && pAdjacentPlot->isWater())

	test	eax, eax
	je	SHORT $LN2@hasCoastAt
	cmp	BYTE PTR [eax+5], 3

; 5096 : 	{
; 5097 : 		return true;

	je	SHORT $LN22@hasCoastAt
$LN2@hasCoastAt:

; 5098 : 	}
; 5099 : 
; 5100 : 	pAdjacentPlot = plotDirection(getX(), getY(), DIRECTION_SOUTHEAST);

	push	2
	push	esi
	push	edi
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 5101 : 	if(pAdjacentPlot != NULL && pAdjacentPlot->isWater())

	test	eax, eax
	je	SHORT $LN1@hasCoastAt
	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN1@hasCoastAt
$LN22@hasCoastAt:
	pop	edi

; 5102 : 	{
; 5103 : 		return true;

	mov	al, 1
	pop	esi

; 5107 : }

	ret	0
$LN1@hasCoastAt:
	pop	edi

; 5104 : 	}
; 5105 : 
; 5106 : 	return false;

	xor	al, al
	pop	esi

; 5107 : }

	ret	0
?hasCoastAtSECorner@CvPlot@@QBE_NXZ ENDP		; CvPlot::hasCoastAtSECorner
_TEXT	ENDS
PUBLIC	?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsHomeFrontForPlayer
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_iCityLoop$ = 8						; size = 4
_ePlayer$ = 8						; size = 4
?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC ; CvPlot::IsHomeFrontForPlayer, COMDAT
; _this$ = ecx

; 5646 : {

	push	esi

; 5647 : 	// Owned?
; 5648 : 	if(isOwned())

	mov	esi, DWORD PTR _ePlayer$[esp]
	push	edi
	mov	edi, ecx
	mov	al, BYTE PTR [edi+4]
	cmp	al, -1
	je	SHORT $LN5@IsHomeFron

; 5649 : 	{
; 5650 : 		if(getOwner() == ePlayer)

	movsx	eax, al
	cmp	eax, esi
	jne	SHORT $LN5@IsHomeFron
	pop	edi

; 5651 : 		{
; 5652 : 			return true;

	mov	al, 1
	pop	esi

; 5671 : }

	ret	4
$LN5@IsHomeFron:

; 5653 : 		}
; 5654 : 	}
; 5655 : 
; 5656 : 	CvCity* pLoopCity;
; 5657 : 	int iCityLoop;
; 5658 : 
; 5659 : 	int iRange = GC.getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT();
; 5660 : 
; 5661 : 	// Not owned by this player, so we have to check things the hard way, and see how close the Plot is to any of this Player's Cities
; 5662 : 	for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2704
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+12]
	add	ecx, esi
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN2@IsHomeFron
$LL4@IsHomeFron:

; 5663 : 	{
; 5664 : 		if(::plotDistance(getX(), getY(), pLoopCity->getX(), pLoopCity->getY()) < iRange)

	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	movsx	eax, WORD PTR [edi+2]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	jl	SHORT $LN34@IsHomeFron
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+12]
	lea	ecx, DWORD PTR [esi+edx]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL4@IsHomeFron
$LN2@IsHomeFron:
	pop	ebx
	pop	edi

; 5667 : 		}
; 5668 : 	}
; 5669 : 
; 5670 : 	return false;

	xor	al, al
	pop	esi

; 5671 : }

	ret	4
$LN34@IsHomeFron:
	pop	ebx
	pop	edi

; 5665 : 		{
; 5666 : 			return true;

	mov	al, 1
	pop	esi

; 5671 : }

	ret	4
?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP ; CvPlot::IsHomeFrontForPlayer
_TEXT	ENDS
PUBLIC	?IsNaturalWonder@CvPlot@@QBE_NXZ		; CvPlot::IsNaturalWonder
EXTRN	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::IsNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?IsNaturalWonder@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?IsNaturalWonder@CvPlot@@QBE_NXZ PROC			; CvPlot::IsNaturalWonder, COMDAT
; _this$ = ecx

; 6061 : 	FeatureTypes eFeature = getFeatureType();

	movsx	eax, BYTE PTR [ecx+432]

; 6062 : 
; 6063 : 	if(eFeature == NO_FEATURE)

	cmp	eax, -1
	jne	SHORT $LN1@IsNaturalW

; 6064 : 		return false;

	xor	al, al

; 6067 : }

	ret	0
$LN1@IsNaturalW:

; 6065 : 
; 6066 : 	return GC.getFeatureInfo(eFeature)->IsNaturalWonder();

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	jmp	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
?IsNaturalWonder@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsNaturalWonder
_TEXT	ENDS
PUBLIC	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
EXTRN	?IsExtraLuxuryResources@CvCity@@QAE_NXZ:PROC	; CvCity::IsExtraLuxuryResources
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eResource$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z PROC ; CvPlot::getNumResourceForPlayer, COMDAT
; _this$ = ecx

; 6213 : {

	push	ecx
	push	ebx
	mov	ebx, ecx

; 6214 : 	int iRtnValue = m_iResourceNum;
; 6215 : 
; 6216 : 	ResourceTypes eResource = getResourceType(getTeam());

	movsx	eax, BYTE PTR [ebx+4]
	push	ebp
	movsx	ebp, BYTE PTR [ebx+458]
	cmp	eax, -1
	je	SHORT $LN14@getNumReso
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@getNumReso
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN13@getNumReso
$LN14@getNumReso:
	or	eax, -1
$LN13@getNumReso:
	push	eax
	mov	ecx, ebx
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[esp+12], eax

; 6217 : 	if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	$LN57@getNumReso
	push	esi

; 6218 : 	{
; 6219 : 		CvResourceInfo *pkResource = GC.getResourceInfo(eResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	esi, eax

; 6220 : 		if (pkResource)

	test	esi, esi
	je	$LN56@getNumReso

; 6221 : 		{
; 6222 : 			if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) pkResource->getTechReveal()) && 
; 6223 : 				(pkResource->getPolicyReveal() == NO_POLICY || GET_PLAYER(ePlayer).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkResource->getPolicyReveal())))

	movsx	eax, BYTE PTR [ebx+4]
	cmp	eax, -1
	je	SHORT $LN27@getNumReso
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@getNumReso
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN26@getNumReso
$LN27@getNumReso:
	or	eax, -1
$LN26@getNumReso:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, esi
	mov	edi, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	push	eax
	mov	ecx, edi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN53@getNumReso
	mov	ecx, esi
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	cmp	eax, -1
	je	SHORT $LN7@getNumReso
	mov	edi, DWORD PTR _ePlayer$[esp+16]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, esi
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	push	eax
	mov	ecx, edi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	je	$LN53@getNumReso
$LN7@getNumReso:

; 6224 : 			{
; 6225 : 				if(pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ecx, esi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN6@getNumReso

; 6226 : 				{
; 6227 : 					int iQuantityMod = GET_PLAYER(ePlayer).GetPlayerTraits()->GetStrategicResourceQuantityModifier(getTerrainType());

	mov	ecx, DWORD PTR _ePlayer$[esp+16]
	movsx	edi, BYTE PTR [ebx+6]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 6228 : 					iRtnValue *= 100 + iQuantityMod;

	mov	ecx, DWORD PTR [eax+edi*4+568]
	add	ecx, 100				; 00000064H
	imul	ecx, ebp

; 6229 : 					iRtnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebp, eax
	jmp	SHORT $LN58@getNumReso
$LN6@getNumReso:

; 6230 : 				}
; 6231 : 
; 6232 : 				else if(pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, esi
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN58@getNumReso

; 6233 : 				{
; 6234 : 					CvCity* pCity = getWorkingCity();

	mov	ecx, ebx
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity

; 6235 : 					if(pCity)

	test	eax, eax
	je	SHORT $LN58@getNumReso

; 6236 : 					{
; 6237 : 						if(pCity->IsExtraLuxuryResources())

	mov	ecx, eax
	call	?IsExtraLuxuryResources@CvCity@@QAE_NXZ	; CvCity::IsExtraLuxuryResources
	test	al, al
	je	SHORT $LN58@getNumReso

; 6238 : 						{
; 6239 : 							iRtnValue++;

	inc	ebp
$LN58@getNumReso:

; 6240 : 						}
; 6241 : 					}
; 6242 : 				}
; 6243 : 
; 6244 : 				if(GET_PLAYER(ePlayer).GetPlayerTraits()->GetResourceQuantityModifier(eResource) > 0)

	mov	esi, DWORD PTR _ePlayer$[esp+16]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	mov	edi, DWORD PTR _eResource$[esp+20]
	add	ecx, esi
	push	edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetResourceQuantityModifier@CvPlayerTraits@@QBEHW4ResourceTypes@@@Z ; CvPlayerTraits::GetResourceQuantityModifier
	test	eax, eax
	jle	SHORT $LN53@getNumReso

; 6245 : 				{
; 6246 : 					int iQuantityMod = GET_PLAYER(ePlayer).GetPlayerTraits()->GetResourceQuantityModifier(eResource);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	push	edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetResourceQuantityModifier@CvPlayerTraits@@QBEHW4ResourceTypes@@@Z ; CvPlayerTraits::GetResourceQuantityModifier
	mov	ecx, eax

; 6247 : 					iRtnValue *= 100 + iQuantityMod;

	add	ecx, 100				; 00000064H
	imul	ecx, ebp

; 6248 : 					iRtnValue /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	pop	edi
	sar	edx, 5
	pop	esi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	ebp
	add	eax, edx
	pop	ebx

; 6255 : }

	pop	ecx
	ret	4
$LN53@getNumReso:
	pop	edi
	pop	esi

; 6249 : 				}
; 6250 : 			}
; 6251 : 		}
; 6252 : 	}
; 6253 : 
; 6254 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 6255 : }

	pop	ecx
	ret	4
$LN56@getNumReso:
	pop	esi

; 6249 : 				}
; 6250 : 			}
; 6251 : 		}
; 6252 : 	}
; 6253 : 
; 6254 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 6255 : }

	pop	ecx
	ret	4
$LN57@getNumReso:

; 6249 : 				}
; 6250 : 			}
; 6251 : 		}
; 6252 : 	}
; 6253 : 
; 6254 : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 6255 : }

	pop	ecx
	ret	4
?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlot::getNumResourceForPlayer
_TEXT	ENDS
PUBLIC	?SetRoutePillaged@CvPlot@@QAEX_N@Z		; CvPlot::SetRoutePillaged
EXTRN	?Update@CvCityConnections@@QAEXXZ:PROC		; CvCityConnections::Update
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Ogtpy
;	COMDAT ?SetRoutePillaged@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bPillaged$ = 8						; size = 1
?SetRoutePillaged@CvPlot@@QAEX_N@Z PROC			; CvPlot::SetRoutePillaged, COMDAT
; _this$ = ecx

; 6906 : {

	push	ebx

; 6907 : 	if(m_bRoutePillaged != bPillaged)

	mov	bl, BYTE PTR _bPillaged$[esp]
	push	esi
	mov	esi, ecx
	mov	al, BYTE PTR [esi+461]
	shr	al, 1
	and	al, 1
	push	edi
	cmp	al, bl
	je	SHORT $LN61@SetRoutePi

; 6908 : 	{
; 6909 : 		for(int iI = 0; iI < MAX_TEAMS; ++iI)

	xor	edi, edi
	npad	7
$LL11@SetRoutePi:

; 6910 : 		{
; 6911 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 6912 : 			if (iI == OBSERVER_TEAM || (GET_TEAM((TeamTypes)iI).isAlive() && GC.getGame().getActiveTeam() == (TeamTypes)iI))
; 6913 : #else
; 6914 : 			if(GET_TEAM((TeamTypes)iI).isAlive() && GC.getGame().getActiveTeam() == (TeamTypes)iI)

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, edi
	imul	ecx, 2980				; 00000ba4H
	cmp	DWORD PTR [ecx+edx+12], 0
	jle	SHORT $LN10@SetRoutePi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, edi
	jne	SHORT $LN10@SetRoutePi

; 6915 : #endif
; 6916 : 			{
; 6917 : 				if(isVisible((TeamTypes)iI))

	cmp	edi, -1
	je	SHORT $LN10@SetRoutePi
	mov	eax, DWORD PTR [esi+156]
	cmp	WORD PTR [eax+edi*2], 0
	setg	al
	test	al, al
	je	SHORT $LN10@SetRoutePi

; 6918 : 				{
; 6919 : 					setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN10@SetRoutePi:
	inc	edi
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL11@SetRoutePi
$LN61@SetRoutePi:

; 6920 : 				}
; 6921 : 			}
; 6922 : 		}
; 6923 : 	}
; 6924 : 
; 6925 : 	m_bRoutePillaged = bPillaged;

	mov	cl, bl
	add	cl, cl
	xor	cl, BYTE PTR [esi+461]
	and	cl, 2
	xor	BYTE PTR [esi+461], cl

; 6926 : 
; 6927 : 	if(bPillaged && IsTradeRoute(NO_PLAYER))

	test	bl, bl
	je	SHORT $LN3@SetRoutePi
	cmp	DWORD PTR [esi+388], 0
	jbe	SHORT $LN3@SetRoutePi

; 6928 : 	{
; 6929 : 		for(int i = 0; i < MAX_CIV_PLAYERS; i++)

	xor	edi, edi
	npad	2
$LL5@SetRoutePi:

; 6930 : 		{
; 6931 : 			PlayerTypes ePlayer = (PlayerTypes)i;
; 6932 : 			if(GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, edi
	imul	edx, 63236				; 0000f704H
	add	eax, edx
	cmp	BYTE PTR [eax+2256], 0
	je	SHORT $LN4@SetRoutePi

; 6933 : 			{
; 6934 : 				if(IsTradeRoute(ePlayer))

	cmp	edi, -1
	jne	SHORT $LN48@SetRoutePi
	cmp	DWORD PTR [esi+388], 0
	ja	SHORT $LN62@SetRoutePi
	jmp	SHORT $LN4@SetRoutePi
$LN48@SetRoutePi:
	mov	edx, 1
	mov	ecx, edi
	shl	edx, cl
	test	edx, DWORD PTR [esi+388]
	je	SHORT $LN4@SetRoutePi
$LN62@SetRoutePi:

; 6935 : 				{
; 6936 : 					GET_PLAYER(ePlayer).GetCityConnections()->Update();

	mov	ecx, eax
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	ecx, eax
	call	?Update@CvCityConnections@@QAEXXZ	; CvCityConnections::Update
$LN4@SetRoutePi:
	inc	edi
	cmp	edi, 63					; 0000003fH
	jl	SHORT $LL5@SetRoutePi
$LN3@SetRoutePi:
	pop	edi
	pop	esi
	pop	ebx

; 6937 : 				}
; 6938 : 			}
; 6939 : 		}
; 6940 : 	}
; 6941 : }

	ret	4
?SetRoutePillaged@CvPlot@@QAEX_N@Z ENDP			; CvPlot::SetRoutePillaged
_TEXT	ENDS
PUBLIC	?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::SetResourceLinkedCity
EXTRN	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ:PROC	; CvCity::GetIDInfo
; Function compile flags: /Ogtpy
;	COMDAT ?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z
_TEXT	SEGMENT
$T240463 = -8						; size = 8
_pCity$ = 8						; size = 4
?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z PROC	; CvPlot::SetResourceLinkedCity, COMDAT
; _this$ = ecx

; 7033 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 7034 : 	if(GetResourceLinkedCity() != pCity)

	mov	eax, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [esi+128]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	ecx, DWORD PTR _pCity$[esp+16]
	add	esp, 8
	cmp	eax, ecx
	je	SHORT $LN38@SetResourc@2

; 7035 : 	{
; 7036 : 		if(pCity != NULL)

	test	ecx, ecx
	je	SHORT $LN2@SetResourc@2

; 7037 : 		{
; 7038 : 			CvAssertMsg(pCity->getOwner() == getOwner(), "Argument city pNewValue's owner is expected to be the same as the current instance");
; 7039 : 			m_ResourceLinkedCity = pCity->GetIDInfo();

	lea	edx, DWORD PTR $T240463[esp+12]
	push	edx
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+128], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+132], edx
	pop	esi

; 7047 : 		}
; 7048 : 	}
; 7049 : }

	add	esp, 8
	ret	4
$LN2@SetResourc@2:

; 7040 : 		}
; 7041 : 		else
; 7042 : 		{
; 7043 : 			// Set to inactive BEFORE unassigning linked City
; 7044 : 			SetResourceLinkedCityActive(false);

	mov	al, BYTE PTR [esi+462]
	test	al, 16					; 00000010H
	je	SHORT $LN8@SetResourc@2
	movsx	ecx, BYTE PTR [esi+440]
	and	al, 239					; 000000efH
	mov	BYTE PTR [esi+462], al
	movsx	eax, BYTE PTR [esi+458]
	neg	eax
	push	eax
	mov	eax, DWORD PTR [esi+132]
	push	ecx
	mov	ecx, DWORD PTR [esi+128]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	mov	ecx, eax
	call	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z ; CvCity::ChangeNumResourceLocal
$LN8@SetResourc@2:

; 7045 : 
; 7046 : 			m_ResourceLinkedCity.reset();

	or	eax, -1
	mov	DWORD PTR [esi+128], eax
	mov	DWORD PTR [esi+132], eax
$LN38@SetResourc@2:
	pop	esi

; 7047 : 		}
; 7048 : 	}
; 7049 : }

	add	esp, 8
	ret	4
?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ENDP	; CvPlot::SetResourceLinkedCity
_TEXT	ENDS
PUBLIC	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_pCityToExclude$ = 8					; size = 4
?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z PROC ; CvPlot::DoFindCityToLinkResourceTo, COMDAT
; _this$ = ecx

; 7079 : {

	push	esi
	mov	esi, ecx

; 7080 : 	// Make sure we can actually use this Resource first
; 7081 : 
; 7082 : 	// No resource here period
; 7083 : 	if(getResourceType() == NO_RESOURCE)

	cmp	BYTE PTR [esi+440], -1
	je	$LN93@DoFindCity

; 7084 : 		return;
; 7085 : 
; 7086 : 	ResourceTypes eResource = getResourceType(getTeam());

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN35@DoFindCity
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN35@DoFindCity
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN34@DoFindCity
$LN35@DoFindCity:
	or	eax, -1
$LN34@DoFindCity:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 7087 : 
; 7088 : 	// Owner can't see resource here yet
; 7089 : 	if(eResource == NO_RESOURCE)

	cmp	eax, -1
	je	$LN93@DoFindCity
	push	ebp

; 7090 : 		return;
; 7091 : 
; 7092 : 	CvCity* pBestCity = NULL;
; 7093 : 
; 7094 : 	// Loop through nearby plots to find the closest city to link to
; 7095 : 	CvPlot* pLoopPlot;
; 7096 : 	for(int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)

	mov	ebp, DWORD PTR _pCityToExclude$[esp+4]
	push	edi
	xor	edi, edi
$LL12@DoFindCity:

; 7097 : 	{
; 7098 : 		// We're not actually looking around a City but Resources have to be within the RANGE of a City, so we can still use this
; 7099 : 		pLoopPlot = plotCity(getX(), getY(), iJ);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 7100 : 
; 7101 : 		if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN11@DoFindCity

; 7102 : 		{
; 7103 : 			CvCity* pLoopCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN11@DoFindCity
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN11@DoFindCity
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 7104 : 			if(pLoopCity)

	test	eax, eax
	je	SHORT $LN11@DoFindCity

; 7105 : 			{
; 7106 : 				// Owner of the City must match the owner of the Resource Plot Tile (Don't want to give the Resource to another player!)
; 7107 : 				if(pLoopCity->getOwner() == getOwner())

	movsx	ecx, BYTE PTR [esi+4]
	cmp	DWORD PTR [eax+84], ecx
	jne	SHORT $LN11@DoFindCity

; 7108 : 				{
; 7109 : 					if(pLoopCity != pCityToExclude)

	cmp	eax, ebp
	jne	SHORT $LN124@DoFindCity
$LN11@DoFindCity:

; 7090 : 		return;
; 7091 : 
; 7092 : 	CvCity* pBestCity = NULL;
; 7093 : 
; 7094 : 	// Loop through nearby plots to find the closest city to link to
; 7095 : 	CvPlot* pLoopPlot;
; 7096 : 	for(int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)

	inc	edi
	cmp	edi, 37					; 00000025H
	jl	SHORT $LL12@DoFindCity
	pop	edi
	pop	ebp
	pop	esi

; 7130 : 			}
; 7131 : 		}
; 7132 : 	}
; 7133 : }

	ret	4
$LN124@DoFindCity:

; 7110 : 					{
; 7111 : 						pBestCity = pLoopCity;
; 7112 : 
; 7113 : 						break;
; 7114 : 					}
; 7115 : 				}
; 7116 : 			}
; 7117 : 		}
; 7118 : 	}
; 7119 : 
; 7120 : 	if(pBestCity != NULL)
; 7121 : 	{
; 7122 : 		SetResourceLinkedCity(pBestCity);

	push	eax
	mov	ecx, esi
	call	?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::SetResourceLinkedCity

; 7123 : 
; 7124 : 		// Already have a valid improvement here?
; 7125 : 		if(isCity() || getImprovementType() != NO_IMPROVEMENT)

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN128@DoFindCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN128@DoFindCity
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN3@DoFindCity
$LN128@DoFindCity:
	cmp	BYTE PTR [esi+441], -1
	je	$LN129@DoFindCity
$LN3@DoFindCity:

; 7126 : 		{
; 7127 : 			if(isCity() || GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN127@DoFindCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN127@DoFindCity
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN1@DoFindCity
$LN127@DoFindCity:
	movsx	eax, BYTE PTR [esi+440]
	movsx	ecx, BYTE PTR [esi+441]
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN129@DoFindCity
$LN1@DoFindCity:

; 7128 : 			{
; 7129 : 				SetResourceLinkedCityActive(true);

	mov	al, BYTE PTR [esi+462]
	test	al, 16					; 00000010H
	jne	SHORT $LN129@DoFindCity
	movsx	ecx, BYTE PTR [esi+440]
	mov	edx, DWORD PTR [esi+132]
	or	al, 16					; 00000010H
	mov	BYTE PTR [esi+462], al
	movsx	eax, BYTE PTR [esi+458]
	push	eax
	mov	eax, DWORD PTR [esi+128]
	push	ecx
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	mov	ecx, eax
	call	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z ; CvCity::ChangeNumResourceLocal
$LN129@DoFindCity:
	pop	edi
	pop	ebp
$LN93@DoFindCity:
	pop	esi

; 7130 : 			}
; 7131 : 		}
; 7132 : 	}
; 7133 : }

	ret	4
?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ENDP ; CvPlot::DoFindCityToLinkResourceTo
_TEXT	ENDS
PUBLIC	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
EXTRN	?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z:PROC ; CvTerrainInfo::getHillsYieldChange
EXTRN	?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z:PROC ; CvFeatureInfo::getHillsYieldChange
EXTRN	?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z:PROC ; CvTerrainInfo::getRiverYieldChange
EXTRN	?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z:PROC ; CvFeatureInfo::getRiverYieldChange
EXTRN	?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z:PROC ; CvBeliefEntry::GetResourceYieldChange
EXTRN	?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetResourceYieldChange
EXTRN	?getYieldChange@CvResourceInfo@@QBEHH@Z:PROC	; CvResourceInfo::getYieldChange
EXTRN	?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z:PROC ; CvBeliefEntry::GetTerrainYieldChange
EXTRN	?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetTerrainYieldChange
EXTRN	?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isYieldNotAdditive
EXTRN	?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z:PROC ; CvBeliefEntry::GetYieldModifierNaturalWonder
EXTRN	?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetYieldModifierNaturalWonder
EXTRN	?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z:PROC ; CvBeliefEntry::GetYieldChangeNaturalWonder
EXTRN	?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetYieldChangeNaturalWonder
EXTRN	?GetFeatureYieldChange@CvGameLeagues@@QAEHW4PlayerTypes@@W4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvGameLeagues::GetFeatureYieldChange
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
EXTRN	?getYieldChange@CvFeatureInfo@@QBEHH@Z:PROC	; CvFeatureInfo::getYieldChange
EXTRN	?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z:PROC ; CvBeliefEntry::GetFeatureYieldChange
EXTRN	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z:PROC ; CvBeliefXMLEntries::GetEntry
EXTRN	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ:PROC ; CvGlobals::GetGameBeliefs
EXTRN	?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetFeatureYieldChange
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?getLakeChange@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getLakeChange
EXTRN	?getMountainChange@CvYieldInfo@@QBEHXZ:PROC	; CvYieldInfo::getMountainChange
EXTRN	?getHillsChange@CvYieldInfo@@QBEHXZ:PROC	; CvYieldInfo::getHillsChange
EXTRN	?getYield@CvTerrainInfo@@QBEHH@Z:PROC		; CvTerrainInfo::getYield
EXTRN	?GetSecondaryReligionPantheonBelief@CvCityReligions@@QAE?AW4BeliefTypes@@XZ:PROC ; CvCityReligions::GetSecondaryReligionPantheonBelief
EXTRN	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ:PROC ; CvCityReligions::GetReligiousMajority
EXTRN	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ:PROC ; CvCity::GetCityReligions
EXTRN	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z:PROC ; CvGlobals::getYieldInfo
; Function compile flags: /Ogtpy
;	COMDAT ?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eMajority$ = -24					; size = 4
_eSecondaryPantheon$ = -20				; size = 4
_pWorkingCity$ = -16					; size = 4
_iReligionMod$225632 = -12				; size = 4
_iReligionChange$225630 = -12				; size = 4
_pFeatureInfo$225615 = -8				; size = 4
tv770 = -4						; size = 4
_iYield$ = 8						; size = 4
_eYield$ = 8						; size = 4
_eTeam$ = 12						; size = 4
$T240847 = 16						; size = 4
_bIgnoreFeature$ = 16					; size = 1
?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::calculateNatureYield, COMDAT
; _this$ = ecx

; 7395 : {

	sub	esp, 24					; 00000018H
	push	edi

; 7396 : 	ResourceTypes eResource;
; 7397 : 	int iYield;
; 7398 : 	ReligionTypes eMajority = NO_RELIGION;

	or	eax, -1
	mov	edi, ecx

; 7399 : 	BeliefTypes eSecondaryPantheon = NO_BELIEF;
; 7400 : 
; 7401 : 	if(isImpassable() || isMountain())

	test	BYTE PTR [edi+462], 128			; 00000080H
	mov	DWORD PTR _eMajority$[esp+28], eax
	mov	DWORD PTR _eSecondaryPantheon$[esp+28], eax
	jne	SHORT $LN35@calculateN
	cmp	BYTE PTR [edi+5], 0
	jne	SHORT $LN176@calculateN
$LN35@calculateN:

; 7402 : 	{
; 7403 : 		// No Feature, or the Feature isn't a Natural Wonder (which are impassable but allowed to be worked)
; 7404 : 		if(getFeatureType() == NO_FEATURE || !GC.getFeatureInfo(getFeatureType())->IsNaturalWonder())

	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	$LN33@calculateN
	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	$LN33@calculateN
$LN176@calculateN:
	push	ebx
	push	ebp
	push	esi

; 7407 : 		}
; 7408 : 	}
; 7409 : 
; 7410 : 	const CvYieldInfo& kYield = *GC.getYieldInfo(eYield);

	mov	esi, DWORD PTR _eYield$[esp+36]
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo

; 7411 : 
; 7412 : 	CvCity* pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR [edi+116]
	mov	edx, DWORD PTR [edi+112]
	push	ecx
	push	edx
	mov	ebp, eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _pWorkingCity$[esp+40], ebx

; 7413 : 	if(pWorkingCity)

	test	ebx, ebx
	je	SHORT $LN32@calculateN

; 7414 : 	{
; 7415 : 		eMajority = pWorkingCity->GetCityReligions()->GetReligiousMajority();

	mov	ecx, ebx
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority

; 7416 : 		eSecondaryPantheon = pWorkingCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();

	mov	ecx, ebx
	mov	DWORD PTR _eMajority$[esp+40], eax
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetSecondaryReligionPantheonBelief@CvCityReligions@@QAE?AW4BeliefTypes@@XZ ; CvCityReligions::GetSecondaryReligionPantheonBelief
	mov	DWORD PTR _eSecondaryPantheon$[esp+40], eax
$LN32@calculateN:

; 7417 : 	}
; 7418 : 
; 7419 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 7420 : 
; 7421 : 	iYield = GC.getTerrainInfo(getTerrainType())->getYield(eYield);

	movsx	eax, BYTE PTR [edi+6]
	push	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getYield@CvTerrainInfo@@QBEHH@Z	; CvTerrainInfo::getYield

; 7422 : 
; 7423 : 	if(isHills())

	cmp	BYTE PTR [edi+5], 1
	mov	DWORD PTR _iYield$[esp+36], eax
	jne	SHORT $LN31@calculateN

; 7424 : 	{
; 7425 : 		iYield += kYield.getHillsChange();

	mov	ecx, ebp
	call	?getHillsChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getHillsChange
	add	DWORD PTR _iYield$[esp+36], eax
$LN31@calculateN:

; 7426 : 	}
; 7427 : 
; 7428 : 	if(isMountain())

	cmp	BYTE PTR [edi+5], 0
	jne	SHORT $LN30@calculateN

; 7429 : 	{
; 7430 : 		iYield += kYield.getMountainChange();

	mov	ecx, ebp
	call	?getMountainChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getMountainChange
	add	DWORD PTR _iYield$[esp+36], eax
$LN30@calculateN:

; 7431 : 	}
; 7432 : 
; 7433 : 	if(isLake())

	mov	eax, DWORD PTR [edi+360]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	test	eax, eax
	je	SHORT $LN181@calculateN
	mov	ecx, eax
	call	?isLake@CvLandmass@@QBE_NXZ		; CvLandmass::isLake
	test	al, al
	je	SHORT $LN181@calculateN

; 7434 : 	{
; 7435 : 		iYield += kYield.getLakeChange();

	mov	ecx, ebp
	call	?getLakeChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getLakeChange
	add	DWORD PTR _iYield$[esp+36], eax

; 7436 : #ifdef NQ_LAKE_BELIEF_BONUSES
; 7437 : 		if (pWorkingCity != NULL)

	test	ebx, ebx
	je	SHORT $LN181@calculateN

; 7438 : 		{
; 7439 : 			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	eax, DWORD PTR [ebx+84]
	mov	ecx, DWORD PTR _eMajority$[esp+40]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 7440 : 			if (pReligion)

	test	eax, eax
	je	SHORT $LN181@calculateN

; 7441 : 			{
; 7442 : 				iYield += pReligion->m_Beliefs.GetFeatureYieldChange(FEATURE_ICE, eYield);

	push	esi
	push	0
	lea	ecx, DWORD PTR [eax+152]
	call	?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetFeatureYieldChange
	add	DWORD PTR _iYield$[esp+36], eax

; 7443 : 				if (eSecondaryPantheon != NO_BELIEF)

	mov	eax, DWORD PTR _eSecondaryPantheon$[esp+40]
	cmp	eax, -1
	je	SHORT $LN181@calculateN

; 7444 : 				{
; 7445 : 					iYield += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetFeatureYieldChange(FEATURE_ICE, eYield);

	push	esi
	push	0
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetFeatureYieldChange
	add	DWORD PTR _iYield$[esp+36], eax
$LN181@calculateN:

; 7446 : 				}
; 7447 : 			}
; 7448 : 		}
; 7449 : #endif
; 7450 : 	}
; 7451 : 
; 7452 : 	if(!bIgnoreFeature)

	cmp	BYTE PTR _bIgnoreFeature$[esp+36], 0
	jne	$LN11@calculateN

; 7453 : 	{
; 7454 : 		if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	$LN11@calculateN

; 7455 : 		{
; 7456 : 			CvFeatureInfo* pFeatureInfo = GC.getFeatureInfo(getFeatureType());

	movsx	edx, al
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo

; 7457 : 
; 7458 : 			// Some Features REPLACE the Yield of the Plot instead of adding to it
; 7459 : 			int iYieldChange = pFeatureInfo->getYieldChange(eYield);

	push	esi
	mov	ecx, eax
	mov	DWORD PTR _pFeatureInfo$225615[esp+44], eax
	call	?getYieldChange@CvFeatureInfo@@QBEHH@Z	; CvFeatureInfo::getYieldChange
	mov	ebp, eax

; 7460 : 
; 7461 : 			// Player Trait
; 7462 : 			if(m_eOwner != NO_PLAYER && getImprovementType() == NO_IMPROVEMENT)

	mov	al, BYTE PTR [edi+4]
	cmp	al, -1
	je	SHORT $LN23@calculateN
	cmp	BYTE PTR [edi+441], -1
	jne	SHORT $LN23@calculateN

; 7463 : 			{
; 7464 : 				iYieldChange +=  GET_PLAYER((PlayerTypes)m_eOwner).GetPlayerTraits()->GetUnimprovedFeatureYieldChange(getFeatureType(), eYield);

	mov	dl, BYTE PTR [edi+432]
	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	movsx	eax, dl
	push	esi
	push	eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
	add	ebp, eax
$LN23@calculateN:

; 7465 : 			}
; 7466 : 
; 7467 : 			// Leagues
; 7468 : 			if(pWorkingCity != NULL)

	test	ebx, ebx
	je	$LN20@calculateN

; 7469 : 			{
; 7470 : 				iYieldChange += GC.getGame().GetGameLeagues()->GetFeatureYieldChange(pWorkingCity->getOwner(), getFeatureType(), eYield);

	mov	al, BYTE PTR [edi+432]
	mov	ecx, DWORD PTR [ebx+84]
	movsx	edx, al
	push	esi
	push	edx
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetFeatureYieldChange@CvGameLeagues@@QAEHW4PlayerTypes@@W4FeatureTypes@@W4YieldTypes@@@Z ; CvGameLeagues::GetFeatureYieldChange
	add	ebp, eax

; 7471 : 			}
; 7472 : 
; 7473 : 			// Religion
; 7474 : 			if(pWorkingCity != NULL && eMajority != NO_RELIGION)

	mov	eax, DWORD PTR _eMajority$[esp+40]
	cmp	eax, -1
	je	SHORT $LN20@calculateN

; 7475 : 			{
; 7476 : 				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	ecx, DWORD PTR [ebx+84]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 7477 : #ifdef NQ_LAKE_BELIEF_BONUSES
; 7478 : 				if(pReligion && getFeatureType() != FEATURE_ICE)

	test	eax, eax
	je	SHORT $LN20@calculateN
	mov	cl, BYTE PTR [edi+432]
	test	cl, cl
	je	SHORT $LN20@calculateN

; 7479 : #else
; 7480 : 				if(pReligion)
; 7481 : #endif
; 7482 : 				{
; 7483 : 					int iReligionChange = pReligion->m_Beliefs.GetFeatureYieldChange(getFeatureType(), eYield);

	movsx	ecx, cl
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [eax+152]
	call	?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetFeatureYieldChange

; 7484 : 					if (eSecondaryPantheon != NO_BELIEF)

	mov	ecx, DWORD PTR _eSecondaryPantheon$[esp+40]
	mov	ebx, eax
	cmp	ecx, -1
	je	SHORT $LN19@calculateN

; 7485 : 					{
; 7486 : 						iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetFeatureYieldChange(getFeatureType(), eYield);

	mov	al, BYTE PTR [edi+432]
	movsx	edx, al
	push	esi
	push	edx
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetFeatureYieldChange
	add	ebx, eax
$LN19@calculateN:

; 7487 : 					}
; 7488 : 					iYieldChange += iReligionChange;

	add	ebp, ebx
	mov	ebx, DWORD PTR _pWorkingCity$[esp+40]
$LN20@calculateN:

; 7489 : 				}
; 7490 : 			}
; 7491 : 			// Natural Wonders
; 7492 : 			if(m_eOwner != NO_PLAYER && pFeatureInfo->IsNaturalWonder())

	cmp	BYTE PTR [edi+4], -1
	je	$LN13@calculateN
	mov	ecx, DWORD PTR _pFeatureInfo$225615[esp+40]
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	$LN13@calculateN

; 7493 : 			{
; 7494 : 				int iMod = 0;
; 7495 : 
; 7496 : 				// Boost from religion in nearby city?
; 7497 : 				if(pWorkingCity && eMajority != NO_RELIGION)

	mov	eax, DWORD PTR _pWorkingCity$[esp+40]
	xor	ebx, ebx
	test	eax, eax
	je	$LN16@calculateN
	mov	ecx, DWORD PTR _eMajority$[esp+40]
	cmp	ecx, -1
	je	$LN16@calculateN

; 7498 : 				{
; 7499 : 					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	eax, DWORD PTR [eax+84]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 7500 : 					if(pReligion)

	test	eax, eax
	je	SHORT $LN16@calculateN

; 7501 : 					{
; 7502 : 						int iReligionChange = pReligion->m_Beliefs.GetYieldChangeNaturalWonder(eYield);

	lea	ecx, DWORD PTR [eax+152]
	push	esi
	mov	DWORD PTR tv770[esp+44], ecx
	call	?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangeNaturalWonder

; 7503 : 						if (eSecondaryPantheon != NO_BELIEF)

	mov	ebx, DWORD PTR _eSecondaryPantheon$[esp+40]
	mov	DWORD PTR _iReligionChange$225630[esp+40], eax
	cmp	ebx, -1
	je	SHORT $LN177@calculateN

; 7504 : 						{
; 7505 : 							iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldChangeNaturalWonder(eYield);

	push	esi
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangeNaturalWonder
	add	DWORD PTR _iReligionChange$225630[esp+40], eax
$LN177@calculateN:

; 7506 : 						}
; 7507 : 						iYieldChange += iReligionChange;
; 7508 : 
; 7509 : 						int iReligionMod = pReligion->m_Beliefs.GetYieldModifierNaturalWonder(eYield);

	mov	ecx, DWORD PTR tv770[esp+40]
	add	ebp, DWORD PTR _iReligionChange$225630[esp+40]
	push	esi
	call	?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldModifierNaturalWonder
	mov	DWORD PTR _iReligionMod$225632[esp+40], eax

; 7510 : 						if (eSecondaryPantheon != NO_BELIEF)

	cmp	ebx, -1
	je	SHORT $LN14@calculateN

; 7511 : 						{
; 7512 : 							iReligionMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldModifierNaturalWonder(eYield);

	push	esi
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldModifierNaturalWonder
	add	DWORD PTR _iReligionMod$225632[esp+40], eax
$LN14@calculateN:

; 7513 : 						}
; 7514 : 						iMod += iReligionMod;

	mov	ebx, DWORD PTR _iReligionMod$225632[esp+40]
$LN16@calculateN:

; 7515 : 					}
; 7516 : 				}
; 7517 : 
; 7518 : 				iYieldChange += GET_PLAYER((PlayerTypes)m_eOwner).GetPlayerTraits()->GetYieldChangeNaturalWonder(eYield);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 7519 : 
; 7520 : 				iMod += GET_PLAYER((PlayerTypes)m_eOwner).GetPlayerTraits()->GetNaturalWonderYieldModifier();

	movsx	ecx, BYTE PTR [edi+4]
	add	ebp, DWORD PTR [eax+esi*4+472]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	ebx, DWORD PTR [eax+212]

; 7521 : 				if(iMod > 0)

	test	ebx, ebx
	jle	SHORT $LN178@calculateN

; 7522 : 				{
; 7523 : 					iYieldChange *= (100 + iMod);

	add	ebx, 100				; 00000064H
	imul	ebx, ebp

; 7524 : 					iYieldChange /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ebp, eax
$LN178@calculateN:
	mov	ebx, DWORD PTR _pWorkingCity$[esp+40]
$LN13@calculateN:

; 7525 : 				}
; 7526 : 			}
; 7527 : 			
; 7528 : 			if(pFeatureInfo->isYieldNotAdditive())

	mov	ecx, DWORD PTR _pFeatureInfo$225615[esp+40]
	call	?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ ; CvFeatureInfo::isYieldNotAdditive
	test	al, al
	je	SHORT $LN12@calculateN

; 7529 : 			{
; 7530 : 				iYield = iYieldChange;

	mov	DWORD PTR _iYield$[esp+36], ebp

; 7531 : 			}
; 7532 : 			else

	jmp	SHORT $LN11@calculateN
$LN12@calculateN:

; 7533 : 			{
; 7534 : 				iYield += iYieldChange;

	add	DWORD PTR _iYield$[esp+36], ebp
$LN11@calculateN:

; 7535 : 			}
; 7536 : 		}
; 7537 : 	}
; 7538 : 
; 7539 : 	// GJS - this was moved after the Feature terrain yield replacement if statement (just above this) to allow yield changes from religion based on terrain with replacement features
; 7540 : 	// Extra yield for religion on this terrain
; 7541 : 	if(pWorkingCity != NULL && eMajority != NO_RELIGION)

	test	ebx, ebx
	je	SHORT $LN179@calculateN
	mov	ecx, DWORD PTR _eMajority$[esp+40]
	cmp	ecx, -1
	je	SHORT $LN179@calculateN

; 7542 : 	{
; 7543 : 		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	eax, DWORD PTR [ebx+84]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 7544 : 		if(pReligion)

	test	eax, eax
	je	SHORT $LN179@calculateN

; 7545 : 		{
; 7546 : 			int iReligionChange = pReligion->m_Beliefs.GetTerrainYieldChange(getTerrainType(), eYield);

	movsx	ecx, BYTE PTR [edi+6]
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [eax+152]
	call	?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetTerrainYieldChange

; 7547 : 			if (eSecondaryPantheon != NO_BELIEF)

	mov	ecx, DWORD PTR _eSecondaryPantheon$[esp+40]
	mov	ebp, eax
	cmp	ecx, -1
	je	SHORT $LN8@calculateN

; 7548 : 			{
; 7549 : 				iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetTerrainYieldChange(getTerrainType(), eYield);

	movsx	eax, BYTE PTR [edi+6]
	push	esi
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetTerrainYieldChange
	add	ebp, eax
$LN8@calculateN:

; 7550 : 			}
; 7551 : 			iYield += iReligionChange;

	add	DWORD PTR _iYield$[esp+36], ebp
$LN179@calculateN:

; 7552 : 		}
; 7553 : 	}
; 7554 : 
; 7555 : 	if(eTeam != NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp+36]
	cmp	eax, -1
	je	$LN180@calculateN

; 7556 : 	{
; 7557 : 		eResource = getResourceType(eTeam);

	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	ebp, eax

; 7558 : 
; 7559 : 		if(eResource != NO_RESOURCE)

	cmp	ebp, -1
	je	SHORT $LN180@calculateN

; 7560 : 		{
; 7561 : 			iYield += GC.getResourceInfo(eResource)->getYieldChange(eYield);

	push	esi
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getYieldChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getYieldChange
	add	DWORD PTR _iYield$[esp+36], eax

; 7562 : 
; 7563 : 			// Extra yield for religion
; 7564 : 			if(pWorkingCity != NULL && eMajority != NO_RELIGION)

	test	ebx, ebx
	je	SHORT $LN180@calculateN
	mov	eax, DWORD PTR _eMajority$[esp+40]
	cmp	eax, -1
	je	SHORT $LN180@calculateN

; 7565 : 			{
; 7566 : 				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	ebx, DWORD PTR [ebx+84]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 7567 : 				if(pReligion)

	test	eax, eax
	je	SHORT $LN180@calculateN

; 7568 : 				{
; 7569 : 					int iReligionChange = pReligion->m_Beliefs.GetResourceYieldChange(eResource, eYield);

	push	esi
	push	ebp
	lea	ecx, DWORD PTR [eax+152]
	call	?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetResourceYieldChange
	mov	ebx, eax

; 7570 : 					if (eSecondaryPantheon != NO_BELIEF)

	mov	eax, DWORD PTR _eSecondaryPantheon$[esp+40]
	cmp	eax, -1
	je	SHORT $LN3@calculateN

; 7571 : 					{
; 7572 : 						iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetResourceYieldChange(eResource, eYield);

	push	esi
	push	ebp
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetResourceYieldChange
	add	ebx, eax
$LN3@calculateN:

; 7573 : 					}
; 7574 : 					iYield += iReligionChange;

	add	DWORD PTR _iYield$[esp+36], ebx
$LN180@calculateN:

; 7575 : 				}
; 7576 : 			}
; 7577 : 		}
; 7578 : 	}
; 7579 : 
; 7580 : 	if(isRiver())

	cmp	BYTE PTR [edi+457], 0
	jle	SHORT $LN186@calculateN

; 7581 : 	{
; 7582 : 		iYield += ((bIgnoreFeature || (getFeatureType() == NO_FEATURE)) ? GC.getTerrainInfo(getTerrainType())->getRiverYieldChange(eYield) : GC.getFeatureInfo(getFeatureType())->getRiverYieldChange(eYield));

	cmp	BYTE PTR _bIgnoreFeature$[esp+36], 0
	jne	SHORT $LN39@calculateN
	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	SHORT $LN39@calculateN
	movsx	ecx, al
	push	esi
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z ; CvFeatureInfo::getRiverYieldChange
	jmp	SHORT $LN40@calculateN
$LN39@calculateN:
	movsx	eax, BYTE PTR [edi+6]
	push	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z ; CvTerrainInfo::getRiverYieldChange
$LN40@calculateN:
	add	DWORD PTR _iYield$[esp+36], eax
$LN186@calculateN:

; 7583 : 	}
; 7584 : 
; 7585 : 	if(isHills())

	cmp	BYTE PTR [edi+5], 1
	jne	SHORT $LN187@calculateN

; 7586 : 	{
; 7587 : 		iYield += ((bIgnoreFeature || (getFeatureType() == NO_FEATURE)) ? GC.getTerrainInfo(getTerrainType())->getHillsYieldChange(eYield) : GC.getFeatureInfo(getFeatureType())->getHillsYieldChange(eYield));

	cmp	BYTE PTR _bIgnoreFeature$[esp+36], 0
	jne	SHORT $LN41@calculateN
	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	SHORT $LN41@calculateN
	movsx	edx, al
	push	esi
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z ; CvFeatureInfo::getHillsYieldChange
	jmp	SHORT $LN42@calculateN
$LN41@calculateN:
	movsx	eax, BYTE PTR [edi+6]
	push	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z ; CvTerrainInfo::getHillsYieldChange
$LN42@calculateN:
	add	DWORD PTR _iYield$[esp+36], eax
$LN187@calculateN:

; 7588 : 	}
; 7589 : 
; 7590 : 	return std::max(0, iYield);

	cmp	DWORD PTR _iYield$[esp+36], 0
	pop	esi
	pop	ebp
	mov	DWORD PTR $T240847[esp+28], 0
	pop	ebx
	lea	eax, DWORD PTR _iYield$[esp+24]
	jg	SHORT $LN175@calculateN
	lea	eax, DWORD PTR $T240847[esp+24]
$LN175@calculateN:
	mov	eax, DWORD PTR [eax]
	pop	edi

; 7591 : }

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
$LN33@calculateN:

; 7405 : 		{
; 7406 : 			return 0;

	xor	eax, eax
	pop	edi

; 7591 : }

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::calculateNatureYield
_TEXT	ENDS
PUBLIC	?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ; CvPlot::calculateBestNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
$T241146 = 8						; size = 4
_eIndex$ = 8						; size = 4
$T241145 = 12						; size = 4
_eTeam$ = 12						; size = 4
?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z PROC ; CvPlot::calculateBestNatureYield, COMDAT
; _this$ = ecx

; 7596 : {

	push	ebx

; 7597 : 	return std::max(calculateNatureYield(eIndex, eTeam, false), calculateNatureYield(eIndex, eTeam, true));

	mov	ebx, DWORD PTR _eIndex$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+12]
	push	1
	push	edi
	push	ebx
	mov	esi, ecx
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	push	0
	push	edi
	mov	ebp, eax
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR $T241145[esp+24], ebp
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	pop	edi
	pop	esi
	cmp	eax, ebp
	pop	ebp
	mov	DWORD PTR $T241146[esp], eax
	pop	ebx
	lea	eax, DWORD PTR $T241145[esp-4]
	jl	SHORT $LN7@calculateB
	lea	eax, DWORD PTR $T241146[esp-4]
$LN7@calculateB:
	mov	eax, DWORD PTR [eax]

; 7598 : }

	ret	8
?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::calculateBestNatureYield
_TEXT	ENDS
PUBLIC	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::calculateTotalBestNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
$T241219 = -8						; size = 4
$T241197 = -8						; size = 4
$T241175 = -8						; size = 4
$T241181 = -4						; size = 4
$T241218 = 8						; size = 4
$T241196 = 8						; size = 4
$T241174 = 8						; size = 4
_eTeam$ = 8						; size = 4
?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z PROC ; CvPlot::calculateTotalBestNatureYield, COMDAT
; _this$ = ecx

; 7603 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 7604 : 	return (calculateBestNatureYield(YIELD_FOOD, eTeam) + calculateBestNatureYield(YIELD_PRODUCTION, eTeam) + calculateBestNatureYield(YIELD_GOLD, eTeam));

	mov	edi, DWORD PTR _eTeam$[esp+20]
	push	1
	push	edi
	push	0
	mov	esi, ecx
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	push	0
	push	edi
	mov	ebx, eax
	push	0
	mov	ecx, esi
	mov	DWORD PTR $T241174[esp+32], ebx
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR $T241175[esp+24], eax
	cmp	eax, ebx
	lea	eax, DWORD PTR $T241174[esp+20]
	jl	SHORT $LN8@calculateT
	lea	eax, DWORD PTR $T241175[esp+24]
$LN8@calculateT:
	mov	eax, DWORD PTR [eax]
	push	1
	push	edi
	push	1
	mov	ecx, esi
	mov	DWORD PTR $T241181[esp+36], eax
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	push	0
	push	edi
	mov	ebx, eax
	push	1
	mov	ecx, esi
	mov	DWORD PTR $T241196[esp+32], ebx
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR $T241197[esp+24], eax
	cmp	eax, ebx
	lea	eax, DWORD PTR $T241196[esp+20]
	jl	SHORT $LN14@calculateT
	lea	eax, DWORD PTR $T241197[esp+24]
$LN14@calculateT:
	mov	ebp, DWORD PTR [eax]
	push	1
	push	edi
	push	2
	mov	ecx, esi
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	push	0
	push	edi
	mov	ebx, eax
	push	2
	mov	ecx, esi
	mov	DWORD PTR $T241218[esp+32], ebx
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR $T241219[esp+24], eax
	cmp	eax, ebx
	lea	eax, DWORD PTR $T241218[esp+20]
	jl	SHORT $LN20@calculateT
	lea	eax, DWORD PTR $T241219[esp+24]
$LN20@calculateT:
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR $T241181[esp+24]
	pop	edi
	pop	esi
	add	eax, ebp
	pop	ebp
	pop	ebx

; 7605 : }

	add	esp, 8
	ret	4
?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ENDP ; CvPlot::calculateTotalBestNatureYield
_TEXT	ENDS
PUBLIC	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
EXTRN	?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvBeliefEntry::GetImprovementYieldChange
EXTRN	?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetImprovementYieldChange
EXTRN	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetImprovementResourceYield
EXTRN	?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z:PROC ; CvPolicyEntry::GetImprovementYieldChanges
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
EXTRN	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
EXTRN	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechFreshWaterYieldChanges
EXTRN	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechYieldChanges
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
EXTRN	?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvTeam::getImprovementNoFreshWaterYieldChange
EXTRN	?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvTeam::getImprovementFreshWaterYieldChange
EXTRN	?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvTeam::getImprovementYieldChange
EXTRN	?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvPlayerTraits::GetImprovementYieldChange
EXTRN	?getImprovementYieldChange@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvPlayer::getImprovementYieldChange
EXTRN	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetRouteYieldChanges
EXTRN	?getNumRouteInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumRouteInfos
EXTRN	?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetFreshWaterYieldChange
EXTRN	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetAdjacentMountainYieldChange
EXTRN	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetAdjacentCityYieldChange
EXTRN	?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetHillsYieldChange
EXTRN	?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetCoastalLandYieldChange
EXTRN	?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetRiverSideYieldChange
EXTRN	?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChangePerEra
EXTRN	?GetYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_pImprovement$ = -24					; size = 4
$T241229 = -20						; size = 20
_eImprovement$ = 8					; size = 4
_bIsFreshWater$ = 12					; size = 1
_iBestYield$ = 12					; size = 4
_iI$ = 12						; size = 4
_iYieldChangePerEra$ = 12				; size = 4
_eYield$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
_bOptimal$ = 20						; size = 1
$T241230 = 24						; size = 4
_eAssumeThisRoute$ = 24					; size = 4
?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z PROC ; CvPlot::calculateImprovementYieldChange, COMDAT
; _this$ = ecx

; 7610 : {

	sub	esp, 28					; 0000001cH

; 7611 : 	ResourceTypes eResource;
; 7612 : 	int iBestYield;
; 7613 : 	int iYield;
; 7614 : #ifdef AUI_WARNING_FIXES
; 7615 : 	uint iI;
; 7616 : #else
; 7617 : 	int iI;
; 7618 : #endif
; 7619 : 
; 7620 : 	CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$[esp+24]
	push	ebp
	push	edi
	mov	edi, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+40], edi
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ebp, eax
	mov	DWORD PTR _pImprovement$[esp+36], ebp

; 7621 : 	if (!pImprovement)

	test	ebp, ebp
	jne	SHORT $LN45@calculateI
	pop	edi
	pop	ebp

; 7798 : }

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
$LN45@calculateI:
	push	ebx
	push	esi

; 7622 : 		return 0;
; 7623 : 
; 7624 : 	iYield = pImprovement->GetYieldChange(eYield);

	mov	esi, DWORD PTR _eYield$[esp+40]
	push	esi
	mov	ecx, ebp
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange

; 7625 : 
; 7626 : 	int iYieldChangePerEra = pImprovement->GetYieldChangePerEra(eYield);

	push	esi
	mov	ecx, ebp
	mov	ebx, eax
	call	?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChangePerEra

; 7627 : 	if (ePlayer != NO_PLAYER && iYieldChangePerEra > 0)

	mov	ecx, DWORD PTR _ePlayer$[esp+40]
	mov	DWORD PTR _iYieldChangePerEra$[esp+40], eax
	cmp	ecx, -1
	je	SHORT $LN43@calculateI
	test	eax, eax
	jle	SHORT $LN43@calculateI

; 7628 : 	{
; 7629 : 		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
; 7630 : 
; 7631 : 		int iPlotEra = GetArchaeologicalRecord().m_eEra;

	mov	edx, DWORD PTR [edi+464]
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edi+468]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241229[esp+44], edx
	mov	edx, DWORD PTR [edi+472]
	mov	DWORD PTR $T241229[esp+48], eax
	mov	eax, DWORD PTR [edi+476]
	mov	DWORD PTR $T241229[esp+52], edx
	mov	edx, DWORD PTR [edi+480]
	mov	DWORD PTR $T241229[esp+56], eax
	mov	DWORD PTR $T241229[esp+60], edx

; 7632 : 		int iNumEras = kPlayer.GetCurrentEra() - iPlotEra;

	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	ecx, DWORD PTR $T241229[esp+48]
	sub	eax, ecx

; 7633 : 
; 7634 : 		if (iPlotEra != NO_ERA && iNumEras > 0)

	cmp	ecx, -1
	je	SHORT $LN43@calculateI
	test	eax, eax
	jle	SHORT $LN43@calculateI

; 7635 : 		{
; 7636 : 			iYield += (iNumEras * iYieldChangePerEra);

	imul	eax, DWORD PTR _iYieldChangePerEra$[esp+40]
	add	ebx, eax
$LN43@calculateI:

; 7637 : 		}
; 7638 : 	}
; 7639 : 
; 7640 : 	if(isRiverSide())

	mov	ecx, edi
	call	?isRiverSide@CvPlot@@QBE_NXZ		; CvPlot::isRiverSide
	test	al, al
	je	SHORT $LN42@calculateI

; 7641 : 	{
; 7642 : 		iYield += pImprovement->GetRiverSideYieldChange(eYield);

	push	esi
	mov	ecx, ebp
	call	?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetRiverSideYieldChange
	add	ebx, eax
$LN42@calculateI:

; 7643 : 	}
; 7644 : 
; 7645 : 	if(isCoastalLand())

	push	-1
	mov	ecx, edi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	je	SHORT $LN41@calculateI

; 7646 : 	{
; 7647 : 		iYield += pImprovement->GetCoastalLandYieldChange(eYield);

	push	esi
	mov	ecx, ebp
	call	?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetCoastalLandYieldChange
	add	ebx, eax
$LN41@calculateI:

; 7648 : 	}
; 7649 : 
; 7650 : 	if(isHills())

	cmp	BYTE PTR [edi+5], 1
	jne	SHORT $LN40@calculateI

; 7651 : 	{
; 7652 : 		iYield += pImprovement->GetHillsYieldChange(eYield);

	push	esi
	mov	ecx, ebp
	call	?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetHillsYieldChange
	add	ebx, eax
$LN40@calculateI:

; 7653 : 	}
; 7654 : 
; 7655 : 	// Check to see if there's a bonus to apply before doing any looping
; 7656 : 	if(pImprovement->GetAdjacentCityYieldChange(eYield) > 0 ||
; 7657 : 	        pImprovement->GetAdjacentMountainYieldChange(eYield) > 0)

	push	esi
	mov	ecx, ebp
	call	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentCityYieldChange
	test	eax, eax
	jg	SHORT $LN38@calculateI
	push	esi
	mov	ecx, ebp
	call	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentMountainYieldChange
	test	eax, eax
	jle	$LN35@calculateI
$LN38@calculateI:

; 7658 : 	{
; 7659 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[esp+40], 0
	npad	2
$LL37@calculateI:

; 7660 : 		{
; 7661 : 			CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _iI$[esp+40]
	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7662 : 
; 7663 : 			if(pAdjacentPlot != NULL)

	test	edi, edi
	je	SHORT $LN36@calculateI

; 7664 : 			{
; 7665 : 				if(pAdjacentPlot->isCity())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN33@calculateI
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN33@calculateI
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN33@calculateI

; 7666 : 				{
; 7667 : 					// Is the owner of this Plot (with the Improvement) also the owner of an adjacent City?
; 7668 : 					if(pAdjacentPlot->getPlotCity()->getOwner() == getOwner())

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN63@calculateI
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN63@calculateI
	mov	edx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN64@calculateI
$LN63@calculateI:
	xor	eax, eax
$LN64@calculateI:
	mov	ecx, DWORD PTR _this$[esp+44]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	DWORD PTR [eax+84], edx
	jne	SHORT $LN36@calculateI

; 7669 : 					{
; 7670 : 						iYield += pImprovement->GetAdjacentCityYieldChange(eYield);

	push	esi
	mov	ecx, ebp
	call	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentCityYieldChange

; 7671 : 					}
; 7672 : 				}

	jmp	SHORT $LN124@calculateI
$LN33@calculateI:

; 7673 : 				else if(pAdjacentPlot->isMountain())

	cmp	BYTE PTR [edi+5], 0
	jne	SHORT $LN36@calculateI

; 7674 : 				{
; 7675 : 					iYield += pImprovement->GetAdjacentMountainYieldChange(eYield);

	push	esi
	mov	ecx, ebp
	call	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentMountainYieldChange
$LN124@calculateI:
	add	ebx, eax
$LN36@calculateI:

; 7658 : 	{
; 7659 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	eax, DWORD PTR _iI$[esp+40]
	mov	edi, DWORD PTR _this$[esp+44]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$[esp+40], eax
	jl	$LL37@calculateI
$LN35@calculateI:

; 7676 : 				}
; 7677 : 			}
; 7678 : 		}
; 7679 : 	}
; 7680 : 
; 7681 : 	if(bOptimal)

	cmp	BYTE PTR _bOptimal$[esp+40], 0
	je	SHORT $LN28@calculateI

; 7682 : 	{
; 7683 : 		iYield += pImprovement->GetFreshWaterYieldChange(eYield);

	push	esi
	mov	ecx, ebp
	call	?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetFreshWaterYieldChange

; 7684 : 	}
; 7685 : 
; 7686 : 	if(bOptimal)
; 7687 : 	{
; 7688 : 		iBestYield = 0;

	xor	ebp, ebp

; 7689 : 
; 7690 : 		for(iI = 0; iI < GC.getNumRouteInfos(); ++iI)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	ebx, eax
	mov	DWORD PTR _iBestYield$[esp+40], ebp
	xor	edi, edi
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	test	eax, eax
	jle	SHORT $LN25@calculateI
$LL27@calculateI:

; 7691 : 		{
; 7692 : 			iBestYield = std::max(iBestYield, pImprovement->GetRouteYieldChanges(iI, eYield));

	mov	ecx, DWORD PTR _pImprovement$[esp+44]
	push	esi
	push	edi
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	mov	DWORD PTR $T241230[esp+40], eax
	cmp	ebp, eax
	lea	eax, DWORD PTR $T241230[esp+40]
	jl	SHORT $LN79@calculateI
	lea	eax, DWORD PTR _iBestYield$[esp+40]
$LN79@calculateI:
	mov	ebp, DWORD PTR [eax]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBestYield$[esp+40], ebp
	inc	edi
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	cmp	edi, eax
	jl	SHORT $LL27@calculateI
$LN25@calculateI:

; 7693 : 		}
; 7694 : 
; 7695 : 		iYield += iBestYield;
; 7696 : 	}
; 7697 : 	else

	mov	edi, DWORD PTR _this$[esp+44]
	add	ebx, ebp
	mov	ebp, DWORD PTR _pImprovement$[esp+44]
	jmp	SHORT $LN21@calculateI
$LN28@calculateI:

; 7698 : 	{
; 7699 : 		RouteTypes eRouteType = NO_ROUTE;
; 7700 : 		if(eAssumeThisRoute != NUM_ROUTE_TYPES)

	mov	eax, DWORD PTR _eAssumeThisRoute$[esp+40]
	cmp	eax, 2

; 7701 : 		{
; 7702 : 			eRouteType = eAssumeThisRoute;
; 7703 : 		}
; 7704 : #ifdef AUI_PLOT_FIX_IMPROVEMENT_YIELD_CHANGES_CATCH_PILLAGED_ROUTE
; 7705 : 		else if (!IsRoutePillaged())
; 7706 : #else
; 7707 : 		else

	jne	SHORT $LN22@calculateI

; 7708 : #endif
; 7709 : 		{
; 7710 : 			eRouteType = getRouteType();

	movsx	eax, BYTE PTR [edi+447]
$LN22@calculateI:

; 7711 : 		}
; 7712 : 
; 7713 : 		if(eRouteType != NO_ROUTE)

	cmp	eax, -1
	je	SHORT $LN21@calculateI

; 7714 : 		{
; 7715 : 			iYield += pImprovement->GetRouteYieldChanges(eRouteType, eYield);

	push	esi
	push	eax
	mov	ecx, ebp
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	add	ebx, eax
$LN21@calculateI:

; 7716 : 		}
; 7717 : 	}
; 7718 : 
; 7719 : 	bool bIsFreshWater = isFreshWater();

	mov	ecx, edi
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater

; 7720 : 
; 7721 : 	if(bOptimal || ePlayer == NO_PLAYER)

	cmp	BYTE PTR _bOptimal$[esp+40], 0
	mov	BYTE PTR _bIsFreshWater$[esp+40], al
	jne	$LN19@calculateI
	mov	edi, DWORD PTR _ePlayer$[esp+40]
	cmp	edi, -1
	je	$LN19@calculateI

; 7744 : 			}
; 7745 : 		}
; 7746 : 	}
; 7747 : 	else
; 7748 : 	{
; 7749 : 		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 7750 : 		CvTeam& kTeam = GET_TEAM(kPlayer.getTeam());

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN88@calculateI
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN89@calculateI
$LN88@calculateI:
	or	eax, -1
$LN89@calculateI:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 7751 : 
; 7752 : 		iYield += kPlayer.getImprovementYieldChange(eImprovement, eYield);

	push	esi
	mov	ebp, eax
	mov	eax, DWORD PTR _eImprovement$[esp+44]
	push	eax
	mov	ecx, edi
	call	?getImprovementYieldChange@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayer::getImprovementYieldChange

; 7753 : 		iYield += kPlayer.GetPlayerTraits()->GetImprovementYieldChange(eImprovement, eYield);

	mov	ecx, DWORD PTR _eImprovement$[esp+40]
	push	esi
	push	ecx
	mov	ecx, edi
	add	ebx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetImprovementYieldChange

; 7754 : 		iYield += kTeam.getImprovementYieldChange(eImprovement, eYield);

	mov	edi, DWORD PTR _eImprovement$[esp+40]
	push	esi
	push	edi
	mov	ecx, ebp
	add	ebx, eax
	call	?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementYieldChange
	add	ebx, eax

; 7755 : 
; 7756 : 		if(bIsFreshWater)

	cmp	BYTE PTR _bIsFreshWater$[esp+40], 0

; 7757 : 		{
; 7758 : 			iYield += kTeam.getImprovementFreshWaterYieldChange(eImprovement, eYield);

	push	esi
	mov	ecx, ebp
	push	edi
	je	SHORT $LN8@calculateI
	call	?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementFreshWaterYieldChange

; 7759 : 		}
; 7760 : 		else

	mov	ebp, DWORD PTR _pImprovement$[esp+44]
	add	ebx, eax
	jmp	$LN11@calculateI
$LN8@calculateI:

; 7761 : 		{
; 7762 : 			iYield += kTeam.getImprovementNoFreshWaterYieldChange(eImprovement, eYield);

	call	?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementNoFreshWaterYieldChange
	mov	ebp, DWORD PTR _pImprovement$[esp+44]
	add	ebx, eax
	jmp	$LN11@calculateI
$LN19@calculateI:

; 7722 : 	{
; 7723 : 		for(iI = 0; iI < GC.getNumTechInfos(); ++iI)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN16@calculateI
$LL18@calculateI:

; 7724 : 		{
; 7725 : 			iYield += pImprovement->GetTechYieldChanges(iI, eYield);

	push	esi
	push	edi
	mov	ecx, ebp
	call	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechYieldChanges
	add	ebx, eax

; 7726 : 
; 7727 : 			if(bIsFreshWater)

	cmp	BYTE PTR _bIsFreshWater$[esp+40], 0

; 7728 : 			{
; 7729 : 				iYield += pImprovement->GetTechFreshWaterYieldChanges(iI, eYield);

	push	esi
	mov	ecx, ebp
	push	edi
	je	SHORT $LN15@calculateI
	call	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChanges

; 7730 : 			}
; 7731 : 			else

	jmp	SHORT $LN125@calculateI
$LN15@calculateI:

; 7732 : 			{
; 7733 : 				iYield += pImprovement->GetTechNoFreshWaterYieldChanges(iI, eYield);

	call	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
$LN125@calculateI:

; 7722 : 	{
; 7723 : 		for(iI = 0; iI < GC.getNumTechInfos(); ++iI)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals

; 7732 : 			{
; 7733 : 				iYield += pImprovement->GetTechNoFreshWaterYieldChanges(iI, eYield);

	add	ebx, eax
	inc	edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	edi, eax
	jl	SHORT $LL18@calculateI
$LN16@calculateI:

; 7734 : 			}
; 7735 : 		}
; 7736 : 
; 7737 : 		for(iI = 0; iI < GC.getNumPolicyInfos(); ++iI)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	test	eax, eax
	jle	SHORT $LN11@calculateI
	npad	9
$LL13@calculateI:

; 7738 : 		{
; 7739 : 			const PolicyTypes ePolicy = static_cast<PolicyTypes>(iI);
; 7740 : 			CvPolicyEntry* pkPolicyEntry = GC.getPolicyInfo(ePolicy);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo

; 7741 : 			if(pkPolicyEntry)

	test	eax, eax
	je	SHORT $LN12@calculateI

; 7742 : 			{
; 7743 : 				iYield += pkPolicyEntry->GetImprovementYieldChanges(eImprovement, eYield);

	mov	edx, DWORD PTR _eImprovement$[esp+40]
	push	esi
	push	edx
	mov	ecx, eax
	call	?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetImprovementYieldChanges
	add	ebx, eax
$LN12@calculateI:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	edi, eax
	jl	SHORT $LL13@calculateI
$LN11@calculateI:

; 7763 : 		}
; 7764 : 	}
; 7765 : 
; 7766 : 	if(ePlayer != NO_PLAYER)

	mov	eax, DWORD PTR _ePlayer$[esp+40]
	cmp	eax, -1
	je	SHORT $LN123@calculateI

; 7767 : 	{
; 7768 : 		eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN101@calculateI
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN102@calculateI
$LN101@calculateI:
	or	eax, -1
$LN102@calculateI:
	mov	edi, DWORD PTR _this$[esp+44]
	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 7769 : 
; 7770 : 		if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN5@calculateI

; 7771 : 		{
; 7772 : 			iYield += pImprovement->GetImprovementResourceYield(eResource, eYield);

	push	esi
	push	eax
	mov	ecx, ebp
	call	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
	add	ebx, eax
	jmp	SHORT $LN5@calculateI
$LN123@calculateI:
	mov	edi, DWORD PTR _this$[esp+44]
$LN5@calculateI:

; 7773 : 		}
; 7774 : 	}
; 7775 : 
; 7776 : 	// Working city
; 7777 : 	CvCity* pWorkingCity = getWorkingCity();

	mov	edx, DWORD PTR [edi+116]
	mov	eax, DWORD PTR [edi+112]
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	edi, eax
	add	esp, 8

; 7778 : 	if(pWorkingCity)

	test	edi, edi
	je	SHORT $LN2@calculateI

; 7779 : 	{
; 7780 : 		ReligionTypes eMajority = pWorkingCity->GetCityReligions()->GetReligiousMajority();

	mov	ecx, edi
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority

; 7781 : 		if(eMajority != NO_RELIGION)

	cmp	eax, -1
	je	SHORT $LN2@calculateI

; 7782 : 		{
; 7783 : 			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	ecx, DWORD PTR [edi+84]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 7784 : 			if(pReligion)

	test	eax, eax
	je	SHORT $LN2@calculateI

; 7785 : 			{
; 7786 : 				int iReligionChange = pReligion->m_Beliefs.GetImprovementYieldChange(eImprovement, eYield);

	mov	ecx, DWORD PTR _eImprovement$[esp+40]
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [eax+152]
	call	?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetImprovementYieldChange

; 7787 : 				BeliefTypes eSecondaryPantheon = pWorkingCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();

	mov	ecx, edi
	mov	ebp, eax
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetSecondaryReligionPantheonBelief@CvCityReligions@@QAE?AW4BeliefTypes@@XZ ; CvCityReligions::GetSecondaryReligionPantheonBelief

; 7788 : 				if (eSecondaryPantheon != NO_BELIEF)

	cmp	eax, -1
	je	SHORT $LN1@calculateI

; 7789 : 				{
; 7790 : 					iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetImprovementYieldChange(eImprovement, eYield);

	mov	edx, DWORD PTR _eImprovement$[esp+40]
	push	esi
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvBeliefEntry::GetImprovementYieldChange
	add	ebp, eax
$LN1@calculateI:

; 7791 : 				}
; 7792 : 				iYield += iReligionChange;

	add	ebx, ebp
$LN2@calculateI:
	pop	esi

; 7793 : 			}
; 7794 : 		}
; 7795 : 	}
; 7796 : 
; 7797 : 	return iYield;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	ebp

; 7798 : }

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ENDP ; CvPlot::calculateImprovementYieldChange
_TEXT	ENDS
PUBLIC	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z	; CvPlot::calculateYield
EXTRN	?getGoldenAgeYield@CvYieldInfo@@QBEHXZ:PROC	; CvYieldInfo::getGoldenAgeYield
EXTRN	?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getGoldenAgeYieldThreshold
EXTRN	?isGoldenAge@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isGoldenAge
EXTRN	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::getExtraYieldThreshold
EXTRN	?getPlotExtraYield@CvGame@@QBEHHHW4YieldTypes@@@Z:PROC ; CvGame::getPlotExtraYield
EXTRN	?GetCapitalYieldPerPopChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCapitalYieldPerPopChange
EXTRN	?GetCapitalYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCapitalYieldChange
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GetCoastalCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCoastalCityYieldChange
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
EXTRN	?GetCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCityYieldChange
EXTRN	?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getMinCityOnHillsAdjust
EXTRN	?getMinCity@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getMinCity
EXTRN	?getResourceYieldChange@CvPlayer@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z:PROC ; CvPlayer::getResourceYieldChange
EXTRN	?GetResourceExtraYield@CvCity@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetResourceExtraYield
EXTRN	?GetTerrainExtraYield@CvCity@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetTerrainExtraYield
EXTRN	?GetImprovementExtraYield@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvPlayer::GetImprovementExtraYield
EXTRN	?GetImprovementExtraYield@CvCity@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetImprovementExtraYield
EXTRN	?GetFeatureExtraYield@CvCity@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetFeatureExtraYield
EXTRN	?getHillYieldChangesFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getHillYieldChangesFromBuildings
EXTRN	?getMountainScienceYield@CvCity@@QBEHXZ:PROC	; CvCity::getMountainScienceYield
EXTRN	?getRiverPlotYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getRiverPlotYield
EXTRN	?getSeaResourceYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getSeaResourceYield
EXTRN	?getSeaPlotYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getSeaPlotYield
EXTRN	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getLakePlotYield
EXTRN	?getSeaPlotYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::getSeaPlotYield
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getPopulationChangeOffset
EXTRN	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getPopulationChangeDivisor
EXTRN	?getCityChange@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getCityChange
EXTRN	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z:PROC	; CvCity::isRevealed
EXTRN	?getYieldChange@CvRouteInfo@@QBEHH@Z:PROC	; CvRouteInfo::getYieldChange
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z:PROC ; CvPlayerPolicies::GetImprovementCultureChange
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
; Function compile flags: /Ogtpy
;	COMDAT ?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z
_TEXT	SEGMENT
_iYield$ = -32						; size = 4
_ePlayer$ = -28						; size = 4
_kYield$ = -24						; size = 4
tv1016 = -20						; size = 4
_pImprovement$225765 = -20				; size = 4
_pkResourceInfo$225811 = -16				; size = 4
_eImprovement$ = -16					; size = 4
_eResource$225808 = -12					; size = 4
_iCityYield$225783 = -12				; size = 4
_eRoute$ = -12						; size = 4
_pWorkingCity$ = -12					; size = 4
$T241615 = -8						; size = 4
$T241611 = -8						; size = 4
_eTeam$225810 = -8					; size = 4
_pCity$ = -4						; size = 4
tv1115 = 8						; size = 4
_iTemp$225825 = 8					; size = 4
_iMinCityYield$225823 = 8				; size = 4
_bCity$ = 8						; size = 1
_eYield$ = 8						; size = 4
_bDisplay$ = 12						; size = 1
$T241386 = 12						; size = 4
?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z PROC	; CvPlot::calculateYield, COMDAT
; _this$ = ecx

; 7803 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp

; 7804 : 	CvCity* pCity = 0;
; 7805 : 	CvCity* pWorkingCity = 0;
; 7806 : 	ImprovementTypes eImprovement = NO_IMPROVEMENT;
; 7807 : 	RouteTypes eRoute = NO_ROUTE;
; 7808 : 	PlayerTypes ePlayer = NO_PLAYER;
; 7809 : 	bool bCity = false;
; 7810 : 	int iYield = 0;
; 7811 : 
; 7812 : 	const CvYieldInfo& kYield = *GC.getYieldInfo(eYield);

	mov	ebp, DWORD PTR _eYield$[esp+36]
	push	edi
	mov	edi, ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo

; 7813 : 
; 7814 : 	if(bDisplay && GC.getGame().isDebugMode())

	mov	bl, BYTE PTR _bDisplay$[esp+40]
	mov	DWORD PTR _kYield$[esp+44], eax
	test	bl, bl
	je	SHORT $LN64@calculateY
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN64@calculateY

; 7815 : 	{
; 7816 : 		return getYield(eYield);

	mov	eax, DWORD PTR [edi+144]
	movsx	eax, WORD PTR [eax+ebp*2]
	pop	edi
	pop	ebp
	pop	ebx

; 8111 : }

	add	esp, 32					; 00000020H
	ret	8
$LN64@calculateY:

; 7817 : 	}
; 7818 : 
; 7819 : 	if(getTerrainType() == NO_TERRAIN)

	cmp	BYTE PTR [edi+6], -1
	jne	SHORT $LN63@calculateY
$LN248@calculateY:
	pop	edi
	pop	ebp

; 7820 : 	{
; 7821 : 		return 0;

	xor	eax, eax
	pop	ebx

; 8111 : }

	add	esp, 32					; 00000020H
	ret	8
$LN63@calculateY:

; 7822 : 	}
; 7823 : 
; 7824 : 	if(!isPotentialCityWork())

	test	BYTE PTR [edi+461], 128			; 00000080H

; 7825 : 	{
; 7826 : 		return 0;

	je	SHORT $LN248@calculateY
	push	esi

; 7827 : 	}
; 7828 : 
; 7829 : 	bCity = false;

	mov	BYTE PTR _bCity$[esp+44], 0

; 7830 : 
; 7831 : 	if(bDisplay)

	test	bl, bl
	je	SHORT $LN61@calculateY

; 7832 : 	{
; 7833 : 		ePlayer = getRevealedOwner(GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR [edi+160]
	movsx	esi, BYTE PTR [ecx+eax]

; 7834 : 		eImprovement = getRevealedImprovementType(GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _ePlayer$[esp+48], esi
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	edx, DWORD PTR [edi+164]
	movsx	ebx, WORD PTR [edx+eax*2]

; 7835 : 		eRoute = getRevealedRouteType(GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _eImprovement$[esp+48], ebx
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR [edi+168]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _eRoute$[esp+48], edx

; 7836 : 
; 7837 : 		if(ePlayer == NO_PLAYER)

	cmp	esi, -1
	jne	SHORT $LN239@calculateY

; 7838 : 		{
; 7839 : 			ePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	esi, eax

; 7840 : 		}
; 7841 : 	}
; 7842 : 	else

	jmp	SHORT $LN244@calculateY
$LN61@calculateY:

; 7843 : 	{
; 7844 : 		ePlayer = getOwner();
; 7845 : 		eImprovement = getImprovementType();

	movsx	ebx, BYTE PTR [edi+441]

; 7846 : 		eRoute = getRouteType();

	movsx	eax, BYTE PTR [edi+447]
	movsx	esi, BYTE PTR [edi+4]
	mov	DWORD PTR _eImprovement$[esp+48], ebx
	mov	DWORD PTR _eRoute$[esp+48], eax
$LN244@calculateY:
	mov	DWORD PTR _ePlayer$[esp+48], esi

; 7847 : 	}
; 7848 : 
; 7849 : 	iYield = calculateNatureYield(eYield, ((ePlayer != NO_PLAYER) ? GET_PLAYER(ePlayer).getTeam() : NO_TEAM));

	cmp	esi, -1
	je	SHORT $LN67@calculateY
$LN239@calculateY:
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN67@calculateY
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN68@calculateY
$LN67@calculateY:
	or	eax, -1
$LN68@calculateY:
	push	0
	push	eax
	push	ebp
	mov	ecx, edi
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi

; 7850 : 
; 7851 : 	if(eImprovement != NO_IMPROVEMENT && !IsImprovementPillaged())

	cmp	ebx, -1
	je	$LN54@calculateY
	test	BYTE PTR [edi+461], 1
	jne	$LN54@calculateY

; 7852 : 	{
; 7853 : 		int iCultureBoost = calculateImprovementYieldChange(eImprovement, eYield, ePlayer);

	mov	edx, DWORD PTR _ePlayer$[esp+48]
	push	2
	push	0
	push	edx
	push	ebp
	push	ebx
	mov	ecx, edi
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange

; 7854 : 		iYield += iCultureBoost;

	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi

; 7855 : 		if(eYield == YIELD_CULTURE)

	cmp	ebp, 4
	jne	$LN54@calculateY

; 7856 : 		{
; 7857 : 			CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovement$225765[esp+48], eax

; 7858 : 			if(pImprovement && pImprovement->GetYieldChange(YIELD_CULTURE) > 0)

	test	eax, eax
	je	SHORT $LN55@calculateY
	push	ebp
	mov	ecx, eax
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN55@calculateY

; 7859 : 			{
; 7860 : 				int iAdjacentCulture = pImprovement->GetCultureAdjacentSameType();

	mov	ecx, DWORD PTR _pImprovement$225765[esp+48]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType

; 7861 : 				if(iAdjacentCulture > 0)

	test	eax, eax
	jle	SHORT $LN55@calculateY

; 7862 : 				{
; 7863 : 					iYield += ComputeCultureFromAdjacentImprovement(*pImprovement, eImprovement);

	mov	eax, DWORD PTR _pImprovement$225765[esp+48]
	push	ebx
	push	eax
	mov	ecx, edi
	call	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN55@calculateY:

; 7864 : 				}
; 7865 : 			}
; 7866 : 			if(getOwner() != NO_PLAYER)

	mov	al, BYTE PTR [edi+4]
	cmp	al, -1
	je	SHORT $LN54@calculateY

; 7867 : 			{
; 7868 : 				iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_CULTURE_FROM_IMPROVEMENTS);

	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	10					; 0000000aH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 7869 : 				iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetImprovementCultureChange(eImprovement);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	add	esi, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ; CvPlayerPolicies::GetImprovementCultureChange
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN54@calculateY:

; 7870 : 			}
; 7871 : 		}
; 7872 : 
; 7873 : 		
; 7874 : 	}
; 7875 : 
; 7876 : 	if(eRoute != NO_ROUTE && !IsRoutePillaged())

	cmp	DWORD PTR _eRoute$[esp+48], -1
	je	SHORT $LN52@calculateY
	test	BYTE PTR [edi+461], 2
	jne	SHORT $LN52@calculateY

; 7877 : 	{
; 7878 : 		CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	mov	ecx, DWORD PTR _eRoute$[esp+48]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 7879 : 		if(pkRouteInfo)

	test	eax, eax
	je	SHORT $LN52@calculateY

; 7880 : 		{
; 7881 : 			iYield += pkRouteInfo->getYieldChange(eYield);

	push	ebp
	mov	ecx, eax
	call	?getYieldChange@CvRouteInfo@@QBEHH@Z	; CvRouteInfo::getYieldChange
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN52@calculateY:

; 7882 : 		}
; 7883 : 	}
; 7884 : 
; 7885 : 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[esp+48], -1
	je	$LN243@calculateY

; 7886 : 	{
; 7887 : 		pCity = getPlotCity();

	mov	ecx, edi
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ebx, eax
	mov	DWORD PTR _pCity$[esp+48], ebx

; 7888 : 
; 7889 : 		if(pCity != NULL)

	test	ebx, ebx
	je	SHORT $LN49@calculateY

; 7890 : 		{
; 7891 : 			if(!bDisplay || pCity->isRevealed(GC.getGame().getActiveTeam(), false))

	cmp	BYTE PTR _bDisplay$[esp+44], 0
	je	SHORT $LN48@calculateY
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, ebx
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN49@calculateY
$LN48@calculateY:

; 7892 : 			{
; 7893 : 				iYield += kYield.getCityChange();

	mov	ecx, DWORD PTR _kYield$[esp+48]
	call	?getCityChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getCityChange

; 7894 : 
; 7895 : 				if(kYield.getPopulationChangeDivisor() != 0)

	mov	ecx, DWORD PTR _kYield$[esp+48]
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	test	eax, eax
	je	SHORT $LN47@calculateY

; 7896 : 				{
; 7897 : 					iYield += (pCity->getPopulation() + kYield.getPopulationChangeOffset()) / kYield.getPopulationChangeDivisor();

	mov	ecx, DWORD PTR _kYield$[esp+48]
	call	?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeOffset
	mov	ecx, ebx
	mov	DWORD PTR tv1115[esp+44], eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ecx, DWORD PTR tv1115[esp+44]
	lea	ebx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _kYield$[esp+48]
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	mov	ecx, eax
	mov	eax, ebx
	cdq
	idiv	ecx
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN47@calculateY:

; 7898 : 				}
; 7899 : 				bCity = true;

	mov	BYTE PTR _bCity$[esp+44], 1
$LN49@calculateY:

; 7900 : 			}
; 7901 : 		}
; 7902 : 
; 7903 : 		pWorkingCity = getWorkingCity();

	mov	edx, DWORD PTR [edi+116]
	mov	eax, DWORD PTR [edi+112]
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 7904 : 
; 7905 : 		if(isWater())

	cmp	BYTE PTR [edi+5], 3
	mov	ebx, eax
	jne	$LN240@calculateY

; 7906 : 		{
; 7907 : 			if(!isImpassable() && !isMountain())

	test	BYTE PTR [edi+462], 128			; 00000080H
	jne	$LN240@calculateY

; 7908 : 			{
; 7909 : 				iYield += GET_PLAYER(ePlayer).getSeaPlotYield(eYield);

	mov	eax, DWORD PTR _ePlayer$[esp+48]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	add	ecx, eax
	push	ebp
	mov	DWORD PTR tv1016[esp+52], eax
	call	?getSeaPlotYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getSeaPlotYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi

; 7910 : 
; 7911 : 				if(pWorkingCity != NULL)

	test	ebx, ebx
	je	SHORT $LN43@calculateY

; 7912 : 				{
; 7913 : 					if(!bDisplay || pWorkingCity->isRevealed(GC.getGame().getActiveTeam(), false))

	cmp	BYTE PTR _bDisplay$[esp+44], 0
	je	SHORT $LN42@calculateY
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, ebx
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN43@calculateY
$LN42@calculateY:

; 7914 : 					{
; 7915 : 						int iCityYield = 0;
; 7916 : 						if (isLake())

	mov	ecx, edi
	mov	DWORD PTR _iCityYield$225783[esp+48], 0
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake

; 7917 : 						{
; 7918 : 							if (pWorkingCity->getLakePlotYield(eYield) > 0)

	push	ebp
	mov	ecx, ebx
	test	al, al
	je	SHORT $LN41@calculateY
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield
	test	eax, eax
	jle	SHORT $LN39@calculateY

; 7919 : 							{
; 7920 : 								iCityYield = pWorkingCity->getLakePlotYield(eYield);

	push	ebp
	mov	ecx, ebx
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield

; 7921 : 							}
; 7922 : 						}
; 7923 : 						else

	jmp	SHORT $LN245@calculateY
$LN41@calculateY:

; 7924 : 						{
; 7925 : 							iCityYield = pWorkingCity->getSeaPlotYield(eYield);

	call	?getSeaPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaPlotYield
$LN245@calculateY:
	mov	DWORD PTR _iCityYield$225783[esp+48], eax
$LN39@calculateY:

; 7926 : 						}
; 7927 : 						iYield += iCityYield;

	add	esi, DWORD PTR _iCityYield$225783[esp+48]
	mov	DWORD PTR _iYield$[esp+48], esi
$LN43@calculateY:

; 7928 : 					}
; 7929 : 				}
; 7930 : 
; 7931 : 				if(getResourceType(GET_PLAYER(ePlayer).getTeam()) != NO_RESOURCE)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1016[esp+48]
	lea	ecx, DWORD PTR [eax+edx]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN240@calculateY

; 7932 : 				{
; 7933 : 					if(pWorkingCity != NULL)

	test	ebx, ebx
	je	SHORT $LN240@calculateY

; 7934 : 					{
; 7935 : 						if(!bDisplay || pWorkingCity->isRevealed(GC.getGame().getActiveTeam(), false))

	cmp	BYTE PTR _bDisplay$[esp+44], 0
	je	SHORT $LN35@calculateY
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, ebx
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN240@calculateY
$LN35@calculateY:

; 7936 : 						{
; 7937 : 							iYield += pWorkingCity->getSeaResourceYield(eYield);

	push	ebp
	mov	ecx, ebx
	call	?getSeaResourceYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaResourceYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN240@calculateY:

; 7938 : 						}
; 7939 : 					}
; 7940 : 				}
; 7941 : 
; 7942 : 			}
; 7943 : 		}
; 7944 : 
; 7945 : 		if(isRiver())

	cmp	BYTE PTR [edi+457], 0
	jle	SHORT $LN31@calculateY

; 7946 : 		{
; 7947 : 			if(!isImpassable() && !isMountain())

	test	BYTE PTR [edi+462], 128			; 00000080H
	jne	SHORT $LN31@calculateY
	cmp	BYTE PTR [edi+5], 0
	je	SHORT $LN247@calculateY

; 7948 : 			{
; 7949 : 				if(NULL != pWorkingCity)

	test	ebx, ebx
	je	SHORT $LN31@calculateY

; 7950 : 				{
; 7951 : 					if(!bDisplay || pWorkingCity->isRevealed(GC.getGame().getActiveTeam(), false))

	cmp	BYTE PTR _bDisplay$[esp+44], 0
	je	SHORT $LN30@calculateY
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, ebx
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN31@calculateY
$LN30@calculateY:

; 7952 : 					{
; 7953 : 						iYield += pWorkingCity->getRiverPlotYield(eYield);

	push	ebp
	mov	ecx, ebx
	call	?getRiverPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getRiverPlotYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN31@calculateY:

; 7954 : 					}
; 7955 : 				}
; 7956 : 			}
; 7957 : 		}
; 7958 : 		
; 7959 : 		// NQMP GJS - mountain science yield begin
; 7960 : 		if (isMountain() && !IsNaturalWonder())

	cmp	BYTE PTR [edi+5], 0
	jne	SHORT $LN241@calculateY
$LN247@calculateY:
	mov	ecx, edi
	call	?IsNaturalWonder@CvPlot@@QBE_NXZ	; CvPlot::IsNaturalWonder
	test	al, al
	jne	SHORT $LN241@calculateY

; 7961 : 		{
; 7962 : 			if (NULL != pWorkingCity)

	test	ebx, ebx
	je	SHORT $LN241@calculateY

; 7963 : 			{
; 7964 : 				if (eYield == YIELD_SCIENCE)

	cmp	ebp, 3
	jne	SHORT $LN241@calculateY

; 7965 : 				{
; 7966 : 					iYield += pWorkingCity->getMountainScienceYield();

	mov	ecx, ebx
	call	?getMountainScienceYield@CvCity@@QBEHXZ	; CvCity::getMountainScienceYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN241@calculateY:

; 7967 : 				}
; 7968 : 			}
; 7969 : 		}
; 7970 : 		// NQMP GJS - mountain science yield end
; 7971 : 
; 7972 : #ifdef NQ_ALLOW_BUILDING_HILL_YIELD_CHANGES
; 7973 : 		if (isHills())

	cmp	BYTE PTR [edi+5], 1
	jne	SHORT $LN25@calculateY

; 7974 : 		{
; 7975 : 			if (NULL != pWorkingCity)

	test	ebx, ebx
	je	SHORT $LN25@calculateY

; 7976 : 			{
; 7977 : 				iYield += pWorkingCity->getHillYieldChangesFromBuildings(eYield);

	push	ebp
	mov	ecx, ebx
	call	?getHillYieldChangesFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getHillYieldChangesFromBuildings
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN25@calculateY:

; 7978 : 			}
; 7979 : 		}
; 7980 : #endif
; 7981 : 
; 7982 : 		// Extra yield for features
; 7983 : 		if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	SHORT $LN23@calculateY

; 7984 : 		{
; 7985 : 			if(pWorkingCity != NULL)

	test	ebx, ebx
	je	SHORT $LN23@calculateY

; 7986 : 			{
; 7987 : 				iYield += pWorkingCity->GetFeatureExtraYield(getFeatureType(), eYield);

	movsx	ecx, al
	push	ebp
	push	ecx
	mov	ecx, ebx
	call	?GetFeatureExtraYield@CvCity@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvCity::GetFeatureExtraYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN23@calculateY:

; 7988 : 			}
; 7989 : 		}
; 7990 : 
; 7991 : 		if (eImprovement != NO_IMPROVEMENT && !IsImprovementPillaged())

	cmp	DWORD PTR _eImprovement$[esp+48], -1
	je	SHORT $LN21@calculateY
	test	BYTE PTR [edi+461], 1
	jne	SHORT $LN21@calculateY

; 7992 : 		{
; 7993 : 			if(pWorkingCity != NULL)

	test	ebx, ebx
	je	SHORT $LN21@calculateY

; 7994 : 			{
; 7995 : 		
; 7996 : 				//pPlot = plotDirection(getX(), getY(), DIRECTION_NORTHEAST);
; 7997 : 				pWorkingCity = getWorkingCity();

	mov	ecx, edi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity

; 7998 : 				//CvCity* pOwningCity = getOwningCity(pPlot);
; 7999 : 				CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	ebx, DWORD PTR _ePlayer$[esp+48]

; 8000 : 				iYield += pWorkingCity->GetImprovementExtraYield(eImprovement, eYield);

	mov	edx, DWORD PTR _eImprovement$[esp+48]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	edx
	mov	ecx, eax
	mov	DWORD PTR _pWorkingCity$[esp+56], eax
	call	?GetImprovementExtraYield@CvCity@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvCity::GetImprovementExtraYield
	add	esi, eax

; 8001 : 				iYield += kPlayer.GetImprovementExtraYield(eImprovement, eYield);

	mov	eax, DWORD PTR _eImprovement$[esp+48]
	push	ebp
	push	eax
	mov	ecx, ebx
	call	?GetImprovementExtraYield@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayer::GetImprovementExtraYield
	mov	ebx, DWORD PTR _pWorkingCity$[esp+48]
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN21@calculateY:

; 8002 : 		
; 8003 : 			}
; 8004 : 		}
; 8005 : 		// Extra yield for terrain
; 8006 : 		if(getTerrainType() != NO_TERRAIN)

	mov	al, BYTE PTR [edi+6]
	cmp	al, -1
	je	SHORT $LN19@calculateY

; 8007 : 		{
; 8008 : 			if(pWorkingCity != NULL && !isImpassable() && !isMountain())

	test	ebx, ebx
	je	SHORT $LN19@calculateY
	test	BYTE PTR [edi+462], 128			; 00000080H
	jne	SHORT $LN19@calculateY
	cmp	BYTE PTR [edi+5], 0
	je	SHORT $LN19@calculateY

; 8009 : 			{
; 8010 : 				iYield += pWorkingCity->GetTerrainExtraYield(getTerrainType(), eYield);

	movsx	eax, al
	push	ebp
	push	eax
	mov	ecx, ebx
	call	?GetTerrainExtraYield@CvCity@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ; CvCity::GetTerrainExtraYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN19@calculateY:

; 8011 : 			}
; 8012 : 		}
; 8013 : 
; 8014 : 		ResourceTypes eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	eax, DWORD PTR _ePlayer$[esp+48]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv1016[esp+48], eax
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN178@calculateY
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN179@calculateY
$LN178@calculateY:
	or	eax, -1
$LN179@calculateY:
	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$225808[esp+48], eax

; 8015 : 		if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	$LN17@calculateY

; 8016 : 		{
; 8017 : 			TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1016[esp+48]
	lea	ecx, DWORD PTR [eax+edx]
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 8018 : 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	ecx, DWORD PTR _eResource$225808[esp+48]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eTeam$225810[esp+52], eax
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$225811[esp+48], eax

; 8019 : 			if(pkResourceInfo != NULL && eTeam != NO_TEAM && GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes) pkResourceInfo->getTechReveal()))

	test	eax, eax
	je	$LN17@calculateY
	cmp	DWORD PTR _eTeam$225810[esp+48], -1
	je	$LN17@calculateY
	mov	eax, DWORD PTR _eTeam$225810[esp+48]
	mov	ecx, DWORD PTR _pkResourceInfo$225811[esp+48]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T241611[esp+48], eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	mov	ecx, DWORD PTR $T241611[esp+48]
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN17@calculateY

; 8020 : 			{
; 8021 : 				if (pkResourceInfo->getPolicyReveal() == NO_POLICY || GET_PLAYER(ePlayer).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkResourceInfo->getPolicyReveal()))

	mov	ecx, DWORD PTR _pkResourceInfo$225811[esp+48]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	cmp	eax, -1
	je	SHORT $LN15@calculateY
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1016[esp+48]
	mov	ecx, DWORD PTR _pkResourceInfo$225811[esp+48]
	add	eax, edx
	mov	DWORD PTR $T241615[esp+48], eax
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	mov	ecx, DWORD PTR $T241615[esp+48]
	push	eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	je	SHORT $LN242@calculateY
$LN15@calculateY:

; 8022 : 				{
; 8023 : 					// Extra yield from resources
; 8024 : 					if(pWorkingCity != NULL)

	test	ebx, ebx
	je	SHORT $LN14@calculateY

; 8025 : 						iYield += pWorkingCity->GetResourceExtraYield(eResource, eYield);

	mov	ecx, DWORD PTR _eResource$225808[esp+48]
	push	ebp
	push	ecx
	mov	ecx, ebx
	call	?GetResourceExtraYield@CvCity@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvCity::GetResourceExtraYield
	add	esi, eax
$LN14@calculateY:

; 8026 : 
; 8027 : 					// Extra yield from Trait
; 8028 : 					if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ebx, DWORD PTR _pkResourceInfo$225811[esp+48]
	mov	ecx, ebx
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN13@calculateY

; 8029 : 					{
; 8030 : 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeStrategicResources(eYield);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv1016[esp+48]
	lea	ecx, DWORD PTR [eax+edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	esi, DWORD PTR [eax+ebp*4+424]
	jmp	SHORT $LN242@calculateY
$LN13@calculateY:

; 8031 : 					}
; 8032 : 					// NQMP GJS - New Netherlands UA BEGIN
; 8033 : 					else if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, ebx
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN242@calculateY

; 8034 : 					{
; 8035 : 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeLuxuryResources(eYield);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv1016[esp+48]
	add	ecx, edx
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	esi, DWORD PTR [eax+ebp*4+448]
$LN242@calculateY:

; 8036 : 					}
; 8037 : 					// NQMP GJS - New Netherlands UA END
; 8038 : 				}
; 8039 : 				CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 8040 : 				iYield += kPlayer.getResourceYieldChange(eResource, eYield);

	mov	edx, DWORD PTR _eResource$225808[esp+48]
	mov	ecx, DWORD PTR tv1016[esp+48]
	push	ebp
	add	ecx, eax
	push	edx
	call	?getResourceYieldChange@CvPlayer@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvPlayer::getResourceYieldChange
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN17@calculateY:

; 8041 : 			}
; 8042 : 		}
; 8043 : 	}
; 8044 : 
; 8045 : 	if(bCity)

	cmp	BYTE PTR _bCity$[esp+44], 0
	je	$LN243@calculateY

; 8046 : 	{
; 8047 : #ifdef NQM_YIELD_MIN_CITY_ON_HILLS_ADJUST
; 8048 : 		int iMinCityYield = kYield.getMinCity();

	mov	ecx, DWORD PTR _kYield$[esp+48]
	call	?getMinCity@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getMinCity

; 8049 : 		if (isHills())

	cmp	BYTE PTR [edi+5], 1
	mov	ebx, eax
	mov	DWORD PTR _iMinCityYield$225823[esp+44], ebx
	jne	SHORT $LN9@calculateY

; 8050 : 		{
; 8051 : 			iMinCityYield += kYield.getMinCityOnHillsAdjust();

	mov	ecx, DWORD PTR _kYield$[esp+48]
	call	?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getMinCityOnHillsAdjust
	add	ebx, eax
	mov	DWORD PTR _iMinCityYield$225823[esp+44], ebx
$LN9@calculateY:

; 8052 : 		}
; 8053 : 		iYield = MAX(iYield, iMinCityYield);

	cmp	esi, ebx
	lea	eax, DWORD PTR _iMinCityYield$225823[esp+44]
	jl	SHORT $LN204@calculateY
	lea	eax, DWORD PTR _iYield$[esp+48]
$LN204@calculateY:

; 8054 : #else
; 8055 : 		iYield = std::max(iYield, kYield.getMinCity());
; 8056 : #endif
; 8057 : #ifndef AUI_PLOT_FIX_CITY_YIELD_CHANGE_RELOCATED
; 8058 : 		// Mod for Player; used for Policies and such
; 8059 : 		int iTemp = GET_PLAYER(getOwner()).GetCityYieldChange(eYield);	// In hundreds - will be added to capitalYieldChange below

	movsx	ecx, BYTE PTR [edi+4]
	mov	esi, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?GetCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCityYieldChange

; 8060 : 
; 8061 : 		// Coastal City Mod
; 8062 : 		if(pCity->isCoastal())

	mov	ebx, DWORD PTR _pCity$[esp+48]
	push	-1
	mov	ecx, ebx
	mov	DWORD PTR _iTemp$225825[esp+48], eax
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN8@calculateY

; 8063 : 		{
; 8064 : 			iYield += GET_PLAYER(getOwner()).GetCoastalCityYieldChange(eYield);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?GetCoastalCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCoastalCityYieldChange
	add	esi, eax
$LN8@calculateY:

; 8065 : 		}
; 8066 : 
; 8067 : 		// Capital Mod
; 8068 : 		if(pCity->isCapital())

	mov	ecx, ebx
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN7@calculateY

; 8069 : 		{
; 8070 : 			iTemp += GET_PLAYER(getOwner()).GetCapitalYieldChange(eYield);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?GetCapitalYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldChange

; 8071 : 
; 8072 : 			int iPerPopYield = pCity->getPopulation() * GET_PLAYER(getOwner()).GetCapitalYieldPerPopChange(eYield);

	movsx	ecx, BYTE PTR [edi+4]
	add	DWORD PTR _iTemp$225825[esp+44], eax
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?GetCapitalYieldPerPopChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldPerPopChange
	mov	ecx, DWORD PTR _pCity$[esp+48]
	mov	ebx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	ebx, eax

; 8073 : 			iPerPopYield /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 8074 : 			iYield += iPerPopYield;

	add	esi, eax
$LN7@calculateY:

; 8075 : 		}
; 8076 : 
; 8077 : 		iYield += (iTemp / 100);

	mov	eax, 1374389535				; 51eb851fH
	imul	DWORD PTR _iTemp$225825[esp+44]
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esi, ecx
$LN243@calculateY:

; 8078 : #endif
; 8079 : 	}
; 8080 : 
; 8081 : 	iYield += GC.getGame().getPlotExtraYield(m_iX, m_iY, eYield);

	movsx	edx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebp
	push	edx
	push	eax
	call	?getPlotExtraYield@CvGame@@QBEHHHW4YieldTypes@@@Z ; CvGame::getPlotExtraYield

; 8082 : 
; 8083 : 	if(ePlayer != NO_PLAYER)

	mov	ebx, DWORD PTR _ePlayer$[esp+48]
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
	cmp	ebx, -1
	je	$LN1@calculateY

; 8084 : 	{
; 8085 : 		if(GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield) > 0)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebx, 63236				; 0000f704H
	add	ecx, ebx
	push	ebp
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	test	eax, eax
	jle	SHORT $LN4@calculateY

; 8086 : 		{
; 8087 : 			if(iYield >= GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]
	push	ebp
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	cmp	esi, eax
	jl	SHORT $LN4@calculateY

; 8088 : 			{
; 8089 : 				iYield += GC.getEXTRA_YIELD();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6608
	mov	DWORD PTR _iYield$[esp+48], esi
$LN4@calculateY:

; 8090 : 			}
; 8091 : 		}
; 8092 : 
; 8093 : 		if(GET_PLAYER(ePlayer).isGoldenAge())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+eax]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN1@calculateY

; 8094 : 		{
; 8095 : 			if(iYield >= kYield.getGoldenAgeYieldThreshold())

	mov	ecx, DWORD PTR _kYield$[esp+48]
	call	?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getGoldenAgeYieldThreshold
	cmp	esi, eax
	jl	SHORT $LN2@calculateY

; 8096 : 			{
; 8097 : 				iYield += kYield.getGoldenAgeYield();

	mov	ecx, DWORD PTR _kYield$[esp+48]
	call	?getGoldenAgeYield@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getGoldenAgeYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+48], esi
$LN2@calculateY:

; 8098 : 			}
; 8099 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 8100 : 			// this is super hacky, I am a bad person and I should feel bad...
; 8101 : 			if (eYield == YIELD_FAITH && calculateYield(YIELD_GOLD, bDisplay) > 0)

	cmp	ebp, 5
	jne	SHORT $LN1@calculateY
	mov	ecx, DWORD PTR _bDisplay$[esp+44]
	push	ecx
	push	2
	mov	ecx, edi
	call	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	test	eax, eax
	jle	SHORT $LN1@calculateY

; 8102 : 			{
; 8103 : 				iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetGoldenAgeTileBonusFaith();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	esi, DWORD PTR [eax+132]
	mov	DWORD PTR _iYield$[esp+48], esi
$LN1@calculateY:

; 8104 : 			}
; 8105 : //int CvPlot::getYieldWithBuild(BuildTypes eBuild, YieldTypes eYield, bool bWithUpgrade, PlayerTypes ePlayer) const
; 8106 : #endif
; 8107 : 		}
; 8108 : 	}
; 8109 : 
; 8110 : 	return std::max(0, iYield);

	test	esi, esi
	mov	DWORD PTR $T241386[esp+44], 0
	pop	esi
	lea	eax, DWORD PTR _iYield$[esp+44]
	jg	SHORT $LN238@calculateY
	lea	eax, DWORD PTR $T241386[esp+40]
$LN238@calculateY:
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	ebp
	pop	ebx

; 8111 : }

	add	esp, 32					; 00000020H
	ret	8
?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ENDP	; CvPlot::calculateYield
_TEXT	ENDS
PUBLIC	?updateYield@CvPlot@@QAEXXZ			; CvPlot::updateYield
EXTRN	?ChangeBaseYieldRateFromTerrain@CvCity@@QAEXW4YieldTypes@@H@Z:PROC ; CvCity::ChangeBaseYieldRateFromTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?updateYield@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?updateYield@CvPlot@@QAEXXZ PROC			; CvPlot::updateYield, COMDAT
; _this$ = ecx

; 8133 : {

	push	esi
	mov	esi, ecx

; 8134 : 	CvCity* pWorkingCity;
; 8135 : 	bool bChange;
; 8136 : 	short iNewYield;
; 8137 : 	int iOldYield;
; 8138 : 	int iI;
; 8139 : 
; 8140 : 	if(area() == NULL)

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	$LN1@updateYiel
	push	ebx
	push	ebp
	push	edi

; 8141 : 	{
; 8142 : 		return;
; 8143 : 	}
; 8144 : 
; 8145 : 	bChange = false;

	xor	bl, bl

; 8146 : 
; 8147 : 	for(iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	xor	edi, edi
$LL32@updateYiel:

; 8148 : 	{
; 8149 : 		iNewYield = (short)calculateYield((YieldTypes)iI);

	push	0
	push	edi
	mov	ecx, esi
	call	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	movzx	ecx, ax

; 8150 : 
; 8151 : 		if(getYield((YieldTypes)iI) != (int)iNewYield)

	mov	eax, DWORD PTR [esi+144]
	cmp	WORD PTR [eax+edi*2], cx
	je	SHORT $LN6@updateYiel
	mov	edx, eax

; 8152 : 		{
; 8153 : 			iOldYield = getYield((YieldTypes)iI);

	movsx	ebp, WORD PTR [edx+edi*2]
	lea	eax, DWORD PTR [edx+edi*2]

; 8154 : 
; 8155 : 			m_aiYield[iI] = iNewYield;

	mov	WORD PTR [eax], cx

; 8156 : 			CvAssertMsg(getYield((YieldTypes)iI) >= 0 && getYield((YieldTypes)iI) < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 8157 : 
; 8158 : 			pWorkingCity = getWorkingCity();

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	ebx, eax
	add	esp, 8

; 8159 : 
; 8160 : 			if(pWorkingCity != NULL)

	test	ebx, ebx
	je	SHORT $LN2@updateYiel

; 8161 : 			{
; 8162 : 				if(isBeingWorked())

	mov	edx, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [esi+112]
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@updateYiel
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	je	SHORT $LN2@updateYiel

; 8163 : 				{
; 8164 : 					pWorkingCity->ChangeBaseYieldRateFromTerrain(((YieldTypes)iI), (getYield((YieldTypes)iI) - iOldYield));

	mov	ecx, DWORD PTR [esi+144]
	movsx	edx, WORD PTR [ecx+edi*2]
	sub	edx, ebp
	push	edx
	push	edi
	mov	ecx, ebx
	call	?ChangeBaseYieldRateFromTerrain@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromTerrain
$LN2@updateYiel:

; 8165 : 				}
; 8166 : 
; 8167 : 				// JON: New City Citizens AI shoulud update here 08/17/09
; 8168 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 8169 : 				pWorkingCity->GetCityCitizens()->DoSelfConsistencyCheck();
; 8170 : #endif
; 8171 : 			}
; 8172 : 
; 8173 : 			bChange = true;

	mov	bl, 1
$LN6@updateYiel:

; 8146 : 
; 8147 : 	for(iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL32@updateYiel
	pop	edi
	pop	ebp

; 8174 : 		}
; 8175 : 	}
; 8176 : 
; 8177 : 	if(bChange)

	test	bl, bl
	pop	ebx
	je	SHORT $LN1@updateYiel

; 8178 : 	{
; 8179 : 		updateSymbols();

	mov	ecx, esi
	pop	esi
	jmp	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols
$LN1@updateYiel:
	pop	esi

; 8180 : 	}
; 8181 : }

	ret	0
?updateYield@CvPlot@@QAEXXZ ENDP			; CvPlot::updateYield
_TEXT	ENDS
PUBLIC	?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z ; CvPlot::isBestAdjacentFound
; Function compile flags: /Ogtpy
;	COMDAT ?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv216 = -4						; size = 4
_iI$ = 8						; size = 4
_eIndex$ = 8						; size = 4
?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlot::isBestAdjacentFound, COMDAT
; _this$ = ecx

; 8200 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 8201 : 	CvPlot* pAdjacentPlot;
; 8202 : 	int iI;
; 8203 : 
; 8204 : 	CvPlayer& thisPlayer = GET_PLAYER(eIndex);

	mov	esi, DWORD PTR _eIndex$[esp+12]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebx, ecx

; 8205 : 	int iPlotValue = thisPlayer.AI_foundValue(getX(), getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	mov	edx, DWORD PTR [esi]
	push	0
	push	-1
	push	eax
	mov	eax, DWORD PTR [edx+48]
	push	ecx
	mov	ecx, esi
	call	eax
	mov	ebp, eax

; 8206 : 
; 8207 : 	if(iPlotValue == 0)

	test	ebp, ebp
	jne	SHORT $LN6@isBestAdja
	pop	esi
	pop	ebp

; 8208 : 	{
; 8209 : 		return false;

	xor	al, al
	pop	ebx

; 8226 : }

	pop	ecx
	ret	4
$LN6@isBestAdja:

; 8210 : 	}
; 8211 : 
; 8212 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[esp+12], 0
	push	edi
$LL31@isBestAdja:

; 8213 : 	{
; 8214 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _iI$[esp+16]
	movsx	edx, WORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx]
	push	ecx
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 8215 : 
; 8216 : 		if((pAdjacentPlot != NULL) && pAdjacentPlot->isRevealed(thisPlayer.getTeam()))

	test	edi, edi
	je	SHORT $LN4@isBestAdja
	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv216[esp+20], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv216[esp+20]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [edi+edx*4+8]
	je	SHORT $LN4@isBestAdja

; 8217 : 		{
; 8218 : 			if(thisPlayer.AI_foundValue(pAdjacentPlot->getX(), pAdjacentPlot->getY()) > iPlotValue)

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	push	0
	push	-1
	push	eax
	mov	eax, DWORD PTR [edx+48]
	push	ecx
	mov	ecx, esi
	call	eax
	cmp	eax, ebp
	jg	SHORT $LN28@isBestAdja
$LN4@isBestAdja:

; 8210 : 	}
; 8211 : 
; 8212 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	eax, DWORD PTR _iI$[esp+16]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$[esp+16], eax
	jl	SHORT $LL31@isBestAdja
	pop	edi
	pop	esi
	pop	ebp

; 8221 : 			}
; 8222 : 		}
; 8223 : 	}
; 8224 : 
; 8225 : 	return true;

	mov	al, 1
	pop	ebx

; 8226 : }

	pop	ecx
	ret	4
$LN28@isBestAdja:
	pop	edi
	pop	esi
	pop	ebp

; 8219 : 			{
; 8220 : 				return false;

	xor	al, al
	pop	ebx

; 8226 : }

	pop	ecx
	ret	4
?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlot::isBestAdjacentFound
_TEXT	ENDS
PUBLIC	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z ; CvPlot::getRevealedTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z PROC ; CvPlot::getRevealedTeam, COMDAT
; _this$ = ecx

; 8422 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8423 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8424 : 
; 8425 : 	PlayerTypes eRevealedOwner = getRevealedOwner(eTeam, bDebug);

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN6@getReveale@4
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN6@getReveale@4
	movsx	eax, BYTE PTR [esi+4]
	jmp	SHORT $LN5@getReveale@4
$LN6@getReveale@4:
	mov	eax, DWORD PTR [esi+160]
	mov	ecx, DWORD PTR _eTeam$[esp]
	movsx	eax, BYTE PTR [eax+ecx]
$LN5@getReveale@4:
	pop	esi

; 8426 : 
; 8427 : 	if(eRevealedOwner != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getReveale@4

; 8428 : 	{
; 8429 : 		return GET_PLAYER(eRevealedOwner).getTeam();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getReveale@4
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 8434 : 	}
; 8435 : }

	ret	8
$LN2@getReveale@4:

; 8430 : 	}
; 8431 : 	else
; 8432 : 	{
; 8433 : 		return NO_TEAM;

	or	eax, -1

; 8434 : 	}
; 8435 : }

	ret	8
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z ENDP ; CvPlot::getRevealedTeam
_TEXT	ENDS
PUBLIC	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z ; CvPlot::getRevealedTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z PROC	; CvPlot::getRevealedTeam, COMDAT
; _this$ = ecx

; 8450 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8451 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8452 : 
; 8453 : 	PlayerTypes eRevealedOwner = getRevealedOwner(eTeam);

	mov	eax, DWORD PTR [ecx+160]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, BYTE PTR [eax+ecx]

; 8454 : 
; 8455 : 	if(eRevealedOwner != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getReveale@5

; 8456 : 	{
; 8457 : 		return GET_PLAYER(eRevealedOwner).getTeam();

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getReveale@5
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 8462 : 	}
; 8463 : }

	ret	4
$LN2@getReveale@5:

; 8458 : 	}
; 8459 : 	else
; 8460 : 	{
; 8461 : 		return NO_TEAM;

	or	eax, -1

; 8462 : 	}
; 8463 : }

	ret	4
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z ENDP	; CvPlot::getRevealedTeam
_TEXT	ENDS
PUBLIC	?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ; CvPlot::updateRevealedOwner
; Function compile flags: /Ogtpy
;	COMDAT ?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z PROC	; CvPlot::updateRevealedOwner, COMDAT
; _this$ = ecx

; 8491 : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 8492 : 	CvPlot* pAdjacentPlot;
; 8493 : 	bool bRevealed;
; 8494 : 	int iI;
; 8495 : 
; 8496 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8497 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8498 : 
; 8499 : 	bRevealed = false;
; 8500 : 
; 8501 : 	if(!bRevealed)
; 8502 : 	{
; 8503 : 		if(isVisible(eTeam))

	mov	edi, DWORD PTR _eTeam$[esp+12]
	mov	ebx, ecx
	cmp	edi, -1
	je	SHORT $LN48@updateReve
	mov	eax, DWORD PTR [ebx+156]
	cmp	WORD PTR [eax+edi*2], 0
	setg	al
	test	al, al

; 8504 : 		{
; 8505 : 			bRevealed = true;
; 8506 : 		}
; 8507 : 	}
; 8508 : 
; 8509 : 	if(!bRevealed)

	jne	SHORT $LN49@updateReve
$LN48@updateReve:

; 8510 : 	{
; 8511 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebp, WORD PTR [ebx+2]
	xor	esi, esi
$LL5@updateReve:

; 8512 : 		{
; 8513 : 			pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [ebx]
	push	esi
	push	ebp
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 8514 : 
; 8515 : 			if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@updateReve

; 8516 : 			{
; 8517 : 				if(pAdjacentPlot->isVisible(eTeam))

	cmp	edi, -1
	je	SHORT $LN4@updateReve
	mov	ecx, DWORD PTR [eax+156]
	cmp	WORD PTR [ecx+edi*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN49@updateReve
$LN4@updateReve:

; 8510 : 	{
; 8511 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL5@updateReve

; 8518 : 				{
; 8519 : 					bRevealed = true;
; 8520 : 					break;
; 8521 : 				}
; 8522 : 			}
; 8523 : 		}
; 8524 : 	}
; 8525 : 
; 8526 : 	setRevealedOwner(eTeam, ((bRevealed) ? getOwner() : NO_PLAYER));

	or	eax, -1
$LN12@updateReve:
	mov	edx, DWORD PTR [ebx+160]
	lea	ecx, DWORD PTR [edx+edi]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, eax
	je	SHORT $LN29@updateReve
	mov	BYTE PTR [ecx], al
	cmp	eax, -1
	je	SHORT $LN29@updateReve
	mov	ecx, edi
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	push	eax
	call	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ; CvTeam::SetHasFoundPlayersTerritory
$LN29@updateReve:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 8527 : }

	ret	4
$LN49@updateReve:

; 8518 : 				{
; 8519 : 					bRevealed = true;
; 8520 : 					break;
; 8521 : 				}
; 8522 : 			}
; 8523 : 		}
; 8524 : 	}
; 8525 : 
; 8526 : 	setRevealedOwner(eTeam, ((bRevealed) ? getOwner() : NO_PLAYER));

	movsx	eax, BYTE PTR [ebx+4]
	jmp	SHORT $LN12@updateReve
?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ENDP	; CvPlot::updateRevealedOwner
_TEXT	ENDS
PUBLIC	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
; Function compile flags: /Ogtpy
;	COMDAT ?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z PROC ; CvPlot::updateRiverCrossing, COMDAT
; _this$ = ecx

; 8548 : {

	push	ebx
	push	esi
	push	edi

; 8549 : 
; 8550 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8551 : 	CvAssertMsg(eIndex < NUM_DIRECTION_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8552 : 
; 8553 : 	bool bValid = false;
; 8554 : 	CvPlot* pPlot = plotDirection(getX(), getY(), eIndex);

	mov	edi, DWORD PTR _eIndex$[esp+8]
	mov	esi, ecx
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	xor	bl, bl
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 8555 : 
; 8556 : 	if((NULL == pPlot) || (!pPlot->isWater() && !isWater()))  // if there is no plot in that direction or both plots are land

	test	eax, eax
	je	SHORT $LN16@updateRive
	mov	cl, 3
	cmp	BYTE PTR [eax+5], cl
	je	SHORT $LN5@updateRive
	cmp	BYTE PTR [esi+5], cl
	je	SHORT $LN5@updateRive
$LN16@updateRive:

; 8557 : 	{
; 8558 : 		switch(eIndex)

	cmp	edi, 5
	ja	SHORT $LN5@updateRive
	jmp	DWORD PTR $LN47@updateRive[edi*4]
$LN13@updateRive:

; 8559 : 		{
; 8560 : 
; 8561 : 		case DIRECTION_NORTHEAST:
; 8562 : 		{
; 8563 : 			if(pPlot && pPlot->isNEOfRiver())

	test	eax, eax
	je	SHORT $LN40@updateRive
	test	BYTE PTR [eax+461], 16			; 00000010H
	je	SHORT $LN40@updateRive

; 8564 : 			{
; 8565 : 				bValid = true;

	mov	bl, 1

; 8566 : 				break;

	jmp	SHORT $LN40@updateRive
$LN11@updateRive:

; 8567 : 			}
; 8568 : 		}
; 8569 : 		break;
; 8570 : 
; 8571 : 		case DIRECTION_EAST:
; 8572 : 			bValid = isWOfRiver();

	mov	bl, BYTE PTR [esi+461]
	shr	bl, 5
	and	bl, 1

; 8573 : 			break;

	jmp	SHORT $LN40@updateRive
$LN10@updateRive:

; 8574 : 
; 8575 : 		case DIRECTION_SOUTHEAST:
; 8576 : 			bValid = isNWOfRiver();

	mov	bl, BYTE PTR [esi+461]
	shr	bl, 6
	and	bl, 1

; 8577 : 			break;

	jmp	SHORT $LN40@updateRive
$LN9@updateRive:

; 8578 : 
; 8579 : 		case DIRECTION_SOUTHWEST:
; 8580 : 			bValid = isNEOfRiver();

	mov	bl, BYTE PTR [esi+461]
	shr	bl, 4
	and	bl, 1

; 8581 : 			break;

	jmp	SHORT $LN40@updateRive
$LN8@updateRive:

; 8582 : 
; 8583 : 		case DIRECTION_WEST:
; 8584 : 			if(pPlot != NULL)

	test	eax, eax
	je	SHORT $LN40@updateRive

; 8585 : 			{
; 8586 : 				bValid = pPlot->isWOfRiver();

	mov	bl, BYTE PTR [eax+461]
	shr	bl, 5
	and	bl, 1

; 8587 : 			}
; 8588 : 			break;

	jmp	SHORT $LN40@updateRive
$LN6@updateRive:

; 8589 : 
; 8590 : 		case DIRECTION_NORTHWEST:
; 8591 : 			if(pPlot != NULL)

	test	eax, eax
	je	SHORT $LN40@updateRive

; 8592 : 			{
; 8593 : 				bValid = pPlot->isNWOfRiver();

	mov	bl, BYTE PTR [eax+461]
	shr	bl, 6
	and	bl, 1

; 8594 : 			}
; 8595 : 			break;
; 8596 : 
; 8597 : 		default:
; 8598 : 			CvAssert(false);
; 8599 : 			break;
; 8600 : 		}
; 8601 : 	}
; 8602 : 
; 8603 : 	if(isRiverCrossing(eIndex) != bValid)

	jmp	SHORT $LN40@updateRive
$LN5@updateRive:
	cmp	edi, -1
	je	SHORT $LN45@updateRive
$LN40@updateRive:
	mov	dl, BYTE PTR [esi+460]
	mov	ecx, edi
	mov	eax, 1
	shl	eax, cl
	movsx	ecx, dl
	test	eax, ecx
	setne	al
	cmp	al, bl
	je	SHORT $LN45@updateRive

; 8604 : 	{
; 8605 : 		char iFlowMask = 1 << eIndex;

	mov	al, 1
	mov	ecx, edi
	shl	al, cl

; 8606 : 		if(bValid)

	test	bl, bl
	je	SHORT $LN2@updateRive

; 8607 : 		{
; 8608 : 			m_cRiverCrossing |= iFlowMask;

	or	dl, al

; 8609 : 			changeRiverCrossingCount(1);

	inc	BYTE PTR [esi+457]
	pop	edi
	mov	BYTE PTR [esi+460], dl
	pop	esi
	pop	ebx

; 8615 : 		}
; 8616 : 	}
; 8617 : }

	ret	4
$LN2@updateRive:

; 8610 : 		}
; 8611 : 		else
; 8612 : 		{
; 8613 : 			m_cRiverCrossing &= ~iFlowMask;

	not	al
	and	al, dl

; 8614 : 			changeRiverCrossingCount(-1);

	dec	BYTE PTR [esi+457]
	mov	BYTE PTR [esi+460], al
$LN45@updateRive:
	pop	edi
	pop	esi
	pop	ebx

; 8615 : 		}
; 8616 : 	}
; 8617 : }

	ret	4
$LN47@updateRive:
	DD	$LN13@updateRive
	DD	$LN11@updateRive
	DD	$LN10@updateRive
	DD	$LN9@updateRive
	DD	$LN8@updateRive
	DD	$LN6@updateRive
?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ENDP ; CvPlot::updateRiverCrossing
_TEXT	ENDS
PUBLIC	?updateRiverCrossing@CvPlot@@QAEXXZ		; CvPlot::updateRiverCrossing
; Function compile flags: /Ogtpy
;	COMDAT ?updateRiverCrossing@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?updateRiverCrossing@CvPlot@@QAEXXZ PROC		; CvPlot::updateRiverCrossing, COMDAT
; _this$ = ecx

; 8622 : {

	push	esi
	push	edi
	mov	edi, ecx

; 8623 : 	int iI;
; 8624 : 
; 8625 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	esi, esi
$LL3@updateRive@2:

; 8626 : 	{
; 8627 : 		updateRiverCrossing((DirectionTypes)iI);

	push	esi
	mov	ecx, edi
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL3@updateRive@2
	pop	edi
	pop	esi

; 8628 : 	}
; 8629 : }

	ret	0
?updateRiverCrossing@CvPlot@@QAEXXZ ENDP		; CvPlot::updateRiverCrossing
_TEXT	ENDS
PUBLIC	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv167 = -4						; size = 4
_eTeam$ = 8						; size = 4
?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isAdjacentRevealed, COMDAT
; _this$ = ecx

; 9046 : {

	push	ecx

; 9047 : 	CvPlot* pAdjacentPlot;
; 9048 : 	int iI;
; 9049 : 
; 9050 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	eax, WORD PTR [ecx]
	push	ebx
	movsx	ebx, WORD PTR [ecx+2]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+16]
	xor	esi, esi
	mov	DWORD PTR tv167[esp+20], eax
$LL19@isAdjacent@11:

; 9051 : 	{
; 9052 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR tv167[esp+20]
	push	esi
	push	ebx
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 9053 : 
; 9054 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent@11

; 9055 : 		{
; 9056 : 			if(pAdjacentPlot->isRevealed(eTeam))

	mov	edx, edi
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	ebp, ecx
	mov	ecx, edi
	sub	ecx, ebp
	mov	ebp, 1
	shl	ebp, cl
	test	ebp, DWORD PTR [eax+edx*4+8]
	jne	SHORT $LN17@isAdjacent@11
$LN4@isAdjacent@11:

; 9047 : 	CvPlot* pAdjacentPlot;
; 9048 : 	int iI;
; 9049 : 
; 9050 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL19@isAdjacent@11
	pop	edi
	pop	esi
	pop	ebp

; 9059 : 			}
; 9060 : 		}
; 9061 : 	}
; 9062 : 
; 9063 : 	return false;

	xor	al, al
	pop	ebx

; 9064 : }

	pop	ecx
	ret	4
$LN17@isAdjacent@11:
	pop	edi
	pop	esi
	pop	ebp

; 9057 : 			{
; 9058 : 				return true;

	mov	al, 1
	pop	ebx

; 9064 : }

	pop	ecx
	ret	4
?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isAdjacentRevealed
_TEXT	ENDS
PUBLIC	?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonrevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv167 = -4						; size = 4
_eTeam$ = 8						; size = 4
?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC ; CvPlot::isAdjacentNonrevealed, COMDAT
; _this$ = ecx

; 9068 : {

	push	ecx

; 9069 : 	CvPlot* pAdjacentPlot;
; 9070 : 	int iI;
; 9071 : 
; 9072 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	eax, WORD PTR [ecx]
	push	ebx
	movsx	ebx, WORD PTR [ecx+2]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+16]
	xor	esi, esi
	mov	DWORD PTR tv167[esp+20], eax
$LL19@isAdjacent@12:

; 9073 : 	{
; 9074 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR tv167[esp+20]
	push	esi
	push	ebx
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 9075 : 
; 9076 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@isAdjacent@12

; 9077 : 		{
; 9078 : 			if(!pAdjacentPlot->isRevealed(eTeam))

	mov	edx, edi
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	ebp, ecx
	mov	ecx, edi
	sub	ecx, ebp
	mov	ebp, 1
	shl	ebp, cl
	test	ebp, DWORD PTR [eax+edx*4+8]
	je	SHORT $LN17@isAdjacent@12
$LN4@isAdjacent@12:

; 9069 : 	CvPlot* pAdjacentPlot;
; 9070 : 	int iI;
; 9071 : 
; 9072 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL19@isAdjacent@12
	pop	edi
	pop	esi
	pop	ebp

; 9081 : 			}
; 9082 : 		}
; 9083 : 	}
; 9084 : 
; 9085 : 	return false;

	xor	al, al
	pop	ebx

; 9086 : }

	pop	ecx
	ret	4
$LN17@isAdjacent@12:
	pop	edi
	pop	esi
	pop	ebp

; 9079 : 			{
; 9080 : 				return true;

	mov	al, 1
	pop	ebx

; 9086 : }

	pop	ecx
	ret	4
?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP ; CvPlot::isAdjacentNonrevealed
_TEXT	ENDS
PUBLIC	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonrevealed
; Function compile flags: /Ogtpy
;	COMDAT ?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_iCount$ = -8						; size = 4
tv167 = -4						; size = 4
_eTeam$ = 8						; size = 4
?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z PROC ; CvPlot::getNumAdjacentNonrevealed, COMDAT
; _this$ = ecx

; 9094 : {

	sub	esp, 8

; 9095 : 	CvPlot* pAdjacentPlot;
; 9096 : 	int iCount = 0;
; 9097 : 
; 9098 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 9099 : 	int iMaxDX, iDX;
; 9100 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 9101 : 	{
; 9102 : 		iMaxDX = iRange - MAX(0, iDY);
; 9103 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9104 : 		{
; 9105 : 			// No need for range check because loops are set up properly
; 9106 : 			pAdjacentPlot = plotXY(getX(), getY(), iDX, iDY);
; 9107 : #else
; 9108 : 	for(int i = 0; i < NUM_DIRECTION_TYPES; ++i)

	movsx	eax, WORD PTR [ecx]
	push	ebx
	movsx	ebx, WORD PTR [ecx+2]
	push	ebp
	push	esi
	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+20]
	mov	DWORD PTR _iCount$[esp+24], esi
	mov	DWORD PTR tv167[esp+24], eax
	npad	4
$LL19@getNumAdja@2:

; 9109 : 	{
; 9110 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)i));

	mov	ecx, DWORD PTR tv167[esp+24]
	push	esi
	push	ebx
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 9111 : #endif
; 9112 : 
; 9113 : 		if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN4@getNumAdja@2

; 9114 : 		{
; 9115 : 			if(!pAdjacentPlot->isRevealed(eTeam))

	mov	edx, edi
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	ebp, ecx
	mov	ecx, edi
	sub	ecx, ebp
	mov	ebp, 1
	shl	ebp, cl
	test	ebp, DWORD PTR [eax+edx*4+8]
	jne	SHORT $LN4@getNumAdja@2

; 9116 : 			{
; 9117 : 				iCount++;

	inc	DWORD PTR _iCount$[esp+24]
$LN4@getNumAdja@2:

; 9095 : 	CvPlot* pAdjacentPlot;
; 9096 : 	int iCount = 0;
; 9097 : 
; 9098 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 9099 : 	int iMaxDX, iDX;
; 9100 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 9101 : 	{
; 9102 : 		iMaxDX = iRange - MAX(0, iDY);
; 9103 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9104 : 		{
; 9105 : 			// No need for range check because loops are set up properly
; 9106 : 			pAdjacentPlot = plotXY(getX(), getY(), iDX, iDY);
; 9107 : #else
; 9108 : 	for(int i = 0; i < NUM_DIRECTION_TYPES; ++i)

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL19@getNumAdja@2

; 9118 : 			}
; 9119 : 		}
; 9120 : 	}
; 9121 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 9122 : 	}
; 9123 : #endif
; 9124 : 
; 9125 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9126 : }

	add	esp, 8
	ret	4
?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ENDP ; CvPlot::getNumAdjacentNonrevealed
_TEXT	ENDS
PUBLIC	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
EXTRN	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvTeam::AddNotification
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$1
__ehfuncinfo$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_strSummary$226294 = -68				; size = 28
_strBuffer$226291 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_eNewValue$ = 12					; size = 4
?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z PROC ; CvPlot::setRevealedImprovementType, COMDAT
; _this$ = ecx

; 9156 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebx

; 9157 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9158 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9159 : 
; 9160 : 	ImprovementTypes eOldImprovementType = getRevealedImprovementType(eTeam);

	mov	ebx, DWORD PTR _eTeam$[esp+68]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+164]
	movsx	ecx, WORD PTR [eax+ebx*2]
	lea	eax, DWORD PTR [eax+ebx*2]
	push	edi

; 9161 : 	if(eOldImprovementType != eNewValue)

	mov	edi, DWORD PTR _eNewValue$[esp+76]
	cmp	ecx, edi
	je	$LN3@setReveale@2

; 9162 : 	{
; 9163 : 		m_aeRevealedImprovementType[eTeam] = eNewValue;

	mov	WORD PTR [eax], di

; 9164 : 		if(eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebx, eax
	jne	SHORT $LN13@setReveale@2

; 9165 : 		{
; 9166 : 			updateSymbols();

	mov	ecx, esi
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 9167 : 			setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN13@setReveale@2:

; 9168 : 		}
; 9169 : 
; 9170 : 		// Found a Barbarian Camp
; 9171 : 		if(eNewValue == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	jne	$LN1@setReveale@2
	push	ebp

; 9172 : 		{
; 9173 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_BARB_CAMP");

	lea	ecx, DWORD PTR _strBuffer$226291[esp+84]
	push	OFFSET $SG226293
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 9174 : 			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_BARB_CAMP");

	lea	edx, DWORD PTR _strSummary$226294[esp+92]
	push	OFFSET $SG226296
	push	edx
	mov	DWORD PTR __$EHRec$[esp+108], 0
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 16					; 00000010H

; 9175 : 			GET_TEAM(eTeam).AddNotification(NOTIFICATION_BARBARIAN, strBuffer, strSummary, getX(), getY());

	movsx	edi, WORD PTR [esi+2]
	movsx	esi, WORD PTR [esi]
	lea	ecx, DWORD PTR _strSummary$226294[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strBuffer$226291[esp+84]
	mov	ebp, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	mov	ecx, ebx
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	push	esi
	push	ebp
	push	eax
	push	1892367718				; 70cb3d66H
	call	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification

; 9176 : 		}

	lea	ecx, DWORD PTR _strSummary$226294[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$226291[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebp
$LN1@setReveale@2:
	pop	edi
	pop	esi

; 9177 : 
; 9178 : 		return true;

	mov	al, 1
	pop	ebx

; 9179 : 	}
; 9180 : 	return false;
; 9181 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
$LN3@setReveale@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$226291[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$226294[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ENDP ; CvPlot::setRevealedImprovementType
PUBLIC	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_eNewValue$ = 12					; size = 4
?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z PROC ; CvPlot::setRevealedRouteType, COMDAT
; _this$ = ecx

; 9211 : {

	push	ebx

; 9212 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9213 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9214 : 
; 9215 : 	if(getRevealedRouteType(eTeam, false) != eNewValue)

	mov	ebx, DWORD PTR _eNewValue$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+168]
	push	edi
	mov	edi, DWORD PTR _eTeam$[esp+8]
	movsx	ecx, WORD PTR [eax+edi*2]
	cmp	ecx, ebx
	je	SHORT $LN2@setReveale@3

; 9216 : 	{
; 9217 : 		if(eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	edi, eax
	jne	SHORT $LN16@setReveale@3

; 9218 : 		{
; 9219 : 			setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN16@setReveale@3:

; 9220 : 		}
; 9221 : 		m_aeRevealedRouteType[eTeam] = eNewValue;

	mov	ecx, DWORD PTR [esi+168]
	mov	WORD PTR [ecx+edi*2], bx
	pop	edi
	pop	esi

; 9222 : 		return true;

	mov	al, 1
	pop	ebx

; 9225 : 
; 9226 : }

	ret	8
$LN2@setReveale@3:
	pop	edi
	pop	esi

; 9223 : 	}
; 9224 : 	return false;

	xor	al, al
	pop	ebx

; 9225 : 
; 9226 : }

	ret	8
?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ENDP ; CvPlot::setRevealedRouteType
_TEXT	ENDS
PUBLIC	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
; Function compile flags: /Ogtpy
;	COMDAT ?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
_TEXT	SEGMENT
$T242193 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ PROC ; CvPlot::getCenterUnit, COMDAT
; _this$ = ecx

; 9506 : {

	push	ecx

; 9507 : 	return m_pCenterUnit;

	mov	eax, DWORD PTR [ecx+188]
	mov	cl, BYTE PTR [ecx+192]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR $T242193[esp+8], 0
	mov	DWORD PTR [esi], eax
	mov	BYTE PTR [esi+4], cl
	test	eax, eax
	je	SHORT $LN10@getCenterU
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN10@getCenterU:
	mov	eax, esi
	pop	esi

; 9508 : }

	pop	ecx
	ret	4
?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ENDP ; CvPlot::getCenterUnit
_TEXT	ENDS
PUBLIC	?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
; Function compile flags: /Ogtpy
;	COMDAT ?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ
_TEXT	SEGMENT
$T242210 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ PROC ; CvPlot::getCenterUnit, COMDAT
; _this$ = ecx

; 9512 : {

	push	ecx

; 9513 : 	return m_pCenterUnit;

	mov	eax, DWORD PTR [ecx+188]
	mov	cl, BYTE PTR [ecx+192]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR $T242210[esp+8], 0
	mov	DWORD PTR [esi], eax
	mov	BYTE PTR [esi+4], cl
	test	eax, eax
	je	SHORT $LN10@getCenterU@2
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN10@getCenterU@2:
	mov	eax, esi
	pop	esi

; 9514 : }

	pop	ecx
	ret	4
?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ ENDP ; CvPlot::getCenterUnit
_TEXT	ENDS
PUBLIC	?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ	; CvPlot::getDebugCenterUnit
; Function compile flags: /Ogtpy
;	COMDAT ?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ
_TEXT	SEGMENT
$T242226 = -8						; size = 8
?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ PROC	; CvPlot::getDebugCenterUnit, COMDAT
; _this$ = ecx

; 9519 : {

	sub	esp, 8
	push	esi
	push	edi

; 9520 : 	const CvUnit* pCenterUnit;
; 9521 : 
; 9522 : 	pCenterUnit = getCenterUnit().pointer();

	lea	eax, DWORD PTR $T242226[esp+16]
	push	eax
	mov	esi, ecx
	call	?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	ecx, DWORD PTR $T242226[esp+16]
	mov	edi, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@getDebugCe
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN13@getDebugCe:

; 9523 : 
; 9524 : 	if(pCenterUnit == NULL)

	test	edi, edi
	jne	SHORT $LN29@getDebugCe

; 9525 : 	{
; 9526 : 		if(GC.getGame().isDebugMode())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN29@getDebugCe

; 9527 : 		{
; 9528 : 			const IDInfo* pUnitNode = headUnitNode();

	cmp	DWORD PTR [esi+28], edi
	jbe	SHORT $LN27@getDebugCe
	mov	esi, DWORD PTR [esi+24]

; 9529 : 			if(pUnitNode == NULL)

	test	esi, esi
	jne	SHORT $LN2@getDebugCe
$LN27@getDebugCe:
	pop	edi

; 9530 : 				pCenterUnit = NULL;

	xor	eax, eax
	pop	esi

; 9537 : }

	add	esp, 8
	ret	0
$LN2@getDebugCe:

; 9531 : 			else
; 9532 : 				pCenterUnit = GetPlayerUnit(*pUnitNode);

	push	esi
	call	?GetPlayerUnit@@YAPBVCvUnit@@ABUIDInfo@@@Z ; GetPlayerUnit
	add	esp, 4
	pop	edi
	pop	esi

; 9537 : }

	add	esp, 8
	ret	0
$LN29@getDebugCe:

; 9533 : 		}
; 9534 : 	}
; 9535 : 
; 9536 : 	return pCenterUnit;

	mov	eax, edi
	pop	edi
	pop	esi

; 9537 : }

	add	esp, 8
	ret	0
?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ ENDP	; CvPlot::getDebugCenterUnit
_TEXT	ENDS
PUBLIC	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit
EXTRN	?setInfoBarDirty@CvUnit@@QAEX_N@Z:PROC		; CvUnit::setInfoBarDirty
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3
__ehfuncinfo$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_pOldValue$ = -28					; size = 8
_newCenterUnit$226476 = -20				; size = 8
$T242281 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pNewValue$ = 8						; size = 8
?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvPlot::setCenterUnit, COMDAT
; _this$ = ecx

; 9542 : {

	push	-1
	push	__ehhandler$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebp
	push	esi
	mov	esi, ecx

; 9543 : 	UnitHandle pOldValue;

	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+44], 0
	mov	DWORD PTR _pOldValue$[esp+36], ebp
	mov	BYTE PTR _pOldValue$[esp+40], 0

; 9544 : 
; 9545 : 	pOldValue = getCenterUnit();

	lea	eax, DWORD PTR $T242281[esp+36]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+48], 1
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	lea	ecx, DWORD PTR _pOldValue$[esp+36]
	mov	BYTE PTR __$EHRec$[esp+44], 2
	cmp	eax, ecx
	je	SHORT $LN18@setCenterU
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _pOldValue$[esp+36], ebp
	test	ebp, ebp
	je	SHORT $LN18@setCenterU
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@setCenterU:
	mov	ecx, DWORD PTR $T242281[esp+36]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	test	ecx, ecx
	je	SHORT $LN23@setCenterU
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@setCenterU:
	push	edi

; 9546 : 
; 9547 : 	m_pCenterUnit = pNewValue;

	lea	edi, DWORD PTR [esi+188]
	lea	edx, DWORD PTR _pNewValue$[esp+36]
	cmp	edx, edi
	je	SHORT $LN59@setCenterU
	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN30@setCenterU
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@setCenterU:
	mov	ecx, DWORD PTR _pNewValue$[esp+36]
	mov	DWORD PTR [edi], ecx
	test	ecx, ecx
	je	SHORT $LN59@setCenterU
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@setCenterU:

; 9548 : 	m_pCenterUnit.ignoreDestruction(true);
; 9549 : 
; 9550 : 	if(pOldValue != pNewValue)

	cmp	DWORD PTR _pNewValue$[esp+36], 0
	mov	BYTE PTR [esi+192], 1
	setne	al
	test	ebp, ebp
	setne	cl
	pop	edi
	cmp	cl, al
	je	SHORT $LN60@setCenterU

; 9551 : 	{
; 9552 : 		UnitHandle newCenterUnit = getCenterUnit();

	lea	edx, DWORD PTR _newCenterUnit$226476[esp+36]
	push	edx
	mov	ecx, esi
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit

; 9553 : 		if(newCenterUnit)

	mov	esi, DWORD PTR _newCenterUnit$226476[esp+36]
	mov	BYTE PTR __$EHRec$[esp+44], 3
	test	esi, esi
	je	SHORT $LN1@setCenterU

; 9554 : 		{
; 9555 : 			newCenterUnit->setInfoBarDirty(true);

	push	1
	mov	ecx, esi
	call	?setInfoBarDirty@CvUnit@@QAEX_N@Z	; CvUnit::setInfoBarDirty
$LN1@setCenterU:

; 9556 : 		}
; 9557 : 	}

	mov	BYTE PTR __$EHRec$[esp+44], 1
	test	esi, esi
	je	SHORT $LN60@setCenterU
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN60@setCenterU:

; 9558 : }

	mov	BYTE PTR __$EHRec$[esp+44], 0
	test	ebp, ebp
	je	SHORT $LN52@setCenterU
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN52@setCenterU:
	mov	ecx, DWORD PTR _pNewValue$[esp+32]
	pop	esi
	mov	DWORD PTR __$EHRec$[esp+40], -1
	pop	ebp
	test	ecx, ecx
	je	SHORT $LN57@setCenterU
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@setCenterU:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pNewValue$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _pOldValue$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR $T242281[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _newCenterUnit$226476[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvPlot::setCenterUnit
PUBLIC	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z	; CvPlot::getUnitByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z PROC		; CvPlot::getUnitByIndex, COMDAT
; _this$ = ecx

; 9753 : 	const IDInfo* pUnitNode;
; 9754 : 
; 9755 : 	pUnitNode = m_units.nodeNum(iIndex);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+28]
	jae	SHORT $LN2@getUnitByI
	mov	ecx, DWORD PTR [ecx+24]
	lea	edx, DWORD PTR [ecx+eax*8]

; 9756 : 
; 9757 : 	if(pUnitNode != NULL)

	test	edx, edx
	je	SHORT $LN2@getUnitByI

; 9758 : 	{
; 9759 : 		return (CvUnit*)GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jl	SHORT $LN2@getUnitByI
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN2@getUnitByI
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _iIndex$[esp-4], edx
	mov	eax, DWORD PTR [eax+16]
	jmp	eax
$LN2@getUnitByI:

; 9760 : 	}
; 9761 : 	else
; 9762 : 	{
; 9763 : 		return NULL;

	xor	eax, eax

; 9764 : 	}
; 9765 : }

	ret	4
?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ENDP		; CvPlot::getUnitByIndex
_TEXT	ENDS
PUBLIC	?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z		; CvPlot::getUnitIndex
EXTRN	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ:PROC	; CvUnit::GetIDInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z
_TEXT	SEGMENT
_kUnitInfo$226591 = -8					; size = 8
_pUnit$ = 8						; size = 4
?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z PROC		; CvPlot::getUnitIndex, COMDAT
; _this$ = ecx

; 9770 : {

	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 9771 : 	int iIndex = 0;
; 9772 : 	if(pUnit)

	mov	ecx, DWORD PTR _pUnit$[esp+12]
	push	edi
	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN2@getUnitInd

; 9773 : 	{
; 9774 : 		IDInfo kUnitInfo = pUnit->GetIDInfo();

	lea	eax, DWORD PTR _kUnitInfo$226591[esp+20]
	push	eax
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo

; 9775 : 
; 9776 : 		const IDInfo* pUnitNode = headUnitNode();

	cmp	DWORD PTR [esi+28], edi
	jbe	SHORT $LN10@getUnitInd
	mov	eax, DWORD PTR [esi+24]
	jmp	SHORT $LN9@getUnitInd
$LN10@getUnitInd:
	xor	eax, eax
$LN9@getUnitInd:

; 9777 : 
; 9778 : 		while(pUnitNode != NULL)

	test	eax, eax
	je	SHORT $LN2@getUnitInd
	mov	edx, DWORD PTR _kUnitInfo$226591[esp+24]
	mov	ebx, DWORD PTR _kUnitInfo$226591[esp+20]
$LL3@getUnitInd:

; 9779 : 		{
; 9780 : 			if(*pUnitNode == kUnitInfo)

	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN19@getUnitInd
	cmp	DWORD PTR [eax+4], edx
	je	SHORT $LN36@getUnitInd
$LN19@getUnitInd:

; 9782 : 
; 9783 : 			++iIndex;
; 9784 : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR [esi+24]
	sub	eax, ecx
	add	eax, 8
	sar	eax, 3
	inc	edi
	cmp	eax, DWORD PTR [esi+28]
	jae	SHORT $LN28@getUnitInd
	lea	eax, DWORD PTR [ecx+eax*8]
	jmp	SHORT $LN27@getUnitInd
$LN28@getUnitInd:
	xor	eax, eax
$LN27@getUnitInd:

; 9777 : 
; 9778 : 		while(pUnitNode != NULL)

	test	eax, eax
	jne	SHORT $LL3@getUnitInd
$LN2@getUnitInd:
	pop	edi
	pop	esi

; 9785 : 		}
; 9786 : 	}
; 9787 : 	return -1;

	or	eax, -1
	pop	ebx

; 9788 : }

	add	esp, 8
	ret	4
$LN36@getUnitInd:

; 9781 : 				return iIndex;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 9788 : }

	add	esp, 8
	ret	4
?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z ENDP		; CvPlot::getUnitIndex
_TEXT	ENDS
PUBLIC	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z	; CvPlot::nextUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z PROC	; CvPlot::nextUnitNode, COMDAT
; _this$ = ecx

; 9880 : 	return m_units.next(pNode);

	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	add	eax, 8
	sar	eax, 3
	cmp	eax, DWORD PTR [ecx+28]
	jae	SHORT $LN8@nextUnitNo@2
	lea	eax, DWORD PTR [edx+eax*8]

; 9881 : }

	ret	4

; 9880 : 	return m_units.next(pNode);

$LN8@nextUnitNo@2:
	xor	eax, eax

; 9881 : }

	ret	4
?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ENDP	; CvPlot::nextUnitNode
_TEXT	ENDS
PUBLIC	?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z	; CvPlot::prevUnitNode
; Function compile flags: /Ogtpy
;	COMDAT ?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z PROC	; CvPlot::prevUnitNode, COMDAT
; _this$ = ecx

; 9892 : 	return m_units.prev(pNode);

	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _pNode$[esp-4]
	sub	eax, edx
	sub	eax, 8
	sar	eax, 3
	cmp	eax, DWORD PTR [ecx+28]
	jae	SHORT $LN8@prevUnitNo@2
	lea	eax, DWORD PTR [edx+eax*8]

; 9893 : }

	ret	4

; 9892 : 	return m_units.prev(pNode);

$LN8@prevUnitNo@2:
	xor	eax, eax

; 9893 : }

	ret	4
?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ENDP	; CvPlot::prevUnitNode
_TEXT	ENDS
PUBLIC	?processArea@CvPlot@@IAEXPAVCvArea@@H@Z		; CvPlot::processArea
EXTRN	?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z:PROC ; CvArea::setTargetCity
EXTRN	?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z:PROC ; CvArea::getTargetCity
EXTRN	?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z:PROC ; CvArea::changeYieldRateModifier
EXTRN	?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetAreaYieldModifier
EXTRN	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumActiveBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z:PROC ; CvArea::changePopulationPerPlayer
EXTRN	?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z:PROC ; CvArea::changeCitiesPerPlayer
EXTRN	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z:PROC ; CvArea::changeNumRevealedTiles
EXTRN	?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z:PROC ; CvArea::changeUnitsPerPlayer
EXTRN	?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z:PROC		; PUF_isPlayer
EXTRN	?changeNumStartingPlots@CvArea@@QAEXH@Z:PROC	; CvArea::changeNumStartingPlots
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
EXTRN	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z:PROC ; CvArea::changeNumImprovements
EXTRN	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z:PROC ; CvArea::changeNumResources
EXTRN	?changeNumRiverEdges@CvArea@@QAEXH@Z:PROC	; CvArea::changeNumRiverEdges
EXTRN	?changeNumOwnedTiles@CvArea@@QAEXH@Z:PROC	; CvArea::changeNumOwnedTiles
EXTRN	?changeNumTiles@CvArea@@QAEXH@Z:PROC		; CvArea::changeNumTiles
; Function compile flags: /Ogtpy
;	COMDAT ?processArea@CvPlot@@IAEXPAVCvArea@@H@Z
_TEXT	SEGMENT
_iI$ = -8						; size = 4
_pkBuildingInfo$226776 = -4				; size = 4
_pArea$ = 8						; size = 4
_iChange$ = 12						; size = 4
?processArea@CvPlot@@IAEXPAVCvArea@@H@Z PROC		; CvPlot::processArea, COMDAT
; _this$ = ecx

; 9957 : {

	sub	esp, 8
	push	ebx

; 9958 : 	CvCity* pCity;
; 9959 : #ifdef AUI_WARNING_FIXES
; 9960 : 	uint iI;
; 9961 : 	int iJ;
; 9962 : #else
; 9963 : 	int iI, iJ;
; 9964 : #endif
; 9965 : 
; 9966 : 	pArea->changeNumTiles(iChange);

	mov	ebx, DWORD PTR _pArea$[esp+8]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _iChange$[esp+16]
	push	edi
	mov	ebp, ecx
	push	esi
	mov	ecx, ebx
	call	?changeNumTiles@CvArea@@QAEXH@Z		; CvArea::changeNumTiles

; 9967 : 
; 9968 : 	if(isOwned())

	cmp	BYTE PTR [ebp+4], -1
	je	SHORT $LN27@processAre

; 9969 : 	{
; 9970 : 		pArea->changeNumOwnedTiles(iChange);

	push	esi
	mov	ecx, ebx
	call	?changeNumOwnedTiles@CvArea@@QAEXH@Z	; CvArea::changeNumOwnedTiles
$LN27@processAre:

; 9971 : 	}
; 9972 : 
; 9973 : 	if(isNEOfRiver())

	test	BYTE PTR [ebp+461], 16			; 00000010H
	je	SHORT $LN26@processAre

; 9974 : 	{
; 9975 : 		pArea->changeNumRiverEdges(iChange);

	push	esi
	mov	ecx, ebx
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN26@processAre:

; 9976 : 	}
; 9977 : 	if(isNWOfRiver())

	test	BYTE PTR [ebp+461], 64			; 00000040H
	je	SHORT $LN25@processAre

; 9978 : 	{
; 9979 : 		pArea->changeNumRiverEdges(iChange);

	push	esi
	mov	ecx, ebx
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN25@processAre:

; 9980 : 	}
; 9981 : 	if(isWOfRiver())

	test	BYTE PTR [ebp+461], 32			; 00000020H
	je	SHORT $LN24@processAre

; 9982 : 	{
; 9983 : 		pArea->changeNumRiverEdges(iChange);

	push	esi
	mov	ecx, ebx
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN24@processAre:

; 9984 : 	}
; 9985 : 
; 9986 : 	if(getResourceType() != NO_RESOURCE)

	mov	al, BYTE PTR [ebp+440]
	cmp	al, -1
	je	SHORT $LN23@processAre

; 9987 : 	{
; 9988 : 		pArea->changeNumResources(getResourceType(), iChange);

	movsx	eax, al
	push	esi
	push	eax
	mov	ecx, ebx
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN23@processAre:

; 9989 : 	}
; 9990 : 
; 9991 : 	if(getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [ebp+441]
	cmp	al, -1
	je	SHORT $LN22@processAre

; 9992 : 	{
; 9993 : 		pArea->changeNumImprovements(getImprovementType(), iChange);

	movsx	ecx, al
	push	esi
	push	ecx
	mov	ecx, ebx
	call	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
$LN22@processAre:

; 9994 : 	}
; 9995 : 
; 9996 : 	for(iI = 0; iI < MAX_PLAYERS; ++iI)

	xor	esi, esi
	xor	edi, edi
	npad	6
$LL21@processAre:

; 9997 : 	{
; 9998 : 		if(GET_PLAYER((PlayerTypes)iI).getStartingPlot() == this)

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	cmp	eax, ebp
	jne	SHORT $LN18@processAre

; 9999 : 		{
; 10000: 			pArea->changeNumStartingPlots(iChange);

	mov	eax, DWORD PTR _iChange$[esp+20]
	push	eax
	mov	ecx, ebx
	call	?changeNumStartingPlots@CvArea@@QAEXH@Z	; CvArea::changeNumStartingPlots
$LN18@processAre:

; 10001: 		}
; 10002: 
; 10003: 		pArea->changeUnitsPerPlayer(((PlayerTypes)iI), (plotCount(PUF_isPlayer, iI) * iChange));

	push	-1
	push	-1
	push	0
	push	-1
	push	-1
	push	-1
	push	esi
	push	OFFSET ?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z ; PUF_isPlayer
	mov	ecx, ebp
	call	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
	imul	eax, DWORD PTR _iChange$[esp+20]
	push	eax
	push	esi
	mov	ecx, ebx
	call	?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeUnitsPerPlayer
	add	edi, 63236				; 0000f704H
	inc	esi
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL21@processAre

; 10004: 	}
; 10005: 
; 10006: 	for(iI = 0; iI < MAX_TEAMS; ++iI)

	xor	esi, esi
$LL17@processAre:

; 10007: 	{
; 10008: 		if(isRevealed(((TeamTypes)iI)))

	mov	eax, esi
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, esi
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [ebp+eax*4+8]
	je	SHORT $LN16@processAre

; 10009: 		{
; 10010: 			pArea->changeNumRevealedTiles(((TeamTypes)iI), iChange);

	mov	eax, DWORD PTR _iChange$[esp+20]
	push	eax
	push	esi
	mov	ecx, ebx
	call	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ; CvArea::changeNumRevealedTiles
$LN16@processAre:
	inc	esi
	cmp	esi, 64					; 00000040H
	jl	SHORT $LL17@processAre

; 10011: 		}
; 10012: 	}
; 10013: 
; 10014: 	pCity = getPlotCity();

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	$LN2@processAre
	cmp	eax, 64					; 00000040H
	jge	$LN2@processAre
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 10015: 
; 10016: 	if(pCity != NULL)

	test	edi, edi
	je	$LN2@processAre

; 10017: 	{
; 10018: 		// XXX make sure all of this syncs up...
; 10019: 		pArea->changeCitiesPerPlayer(pCity->getOwner(), iChange);

	mov	ebp, DWORD PTR _iChange$[esp+20]
	mov	edx, DWORD PTR [edi+84]
	push	ebp
	push	edx
	mov	ecx, ebx
	call	?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeCitiesPerPlayer

; 10020: 		pArea->changePopulationPerPlayer(pCity->getOwner(), (pCity->getPopulation() * iChange));

	mov	esi, DWORD PTR [edi+84]
	mov	ecx, edi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, ebp
	push	eax
	push	esi
	mov	ecx, ebx
	call	?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changePopulationPerPlayer

; 10021: 
; 10022: 		for(iI = 0; iI < GC.getNumBuildingInfos(); ++iI)

	xor	ebp, ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$[esp+24], ebp
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	test	eax, eax
	jle	$LN112@processAre
	npad	7
$LL12@processAre:

; 10023: 		{
; 10024: 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
; 10025: 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$226776[esp+24], eax

; 10026: 			if(pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN11@processAre

; 10027: 			{
; 10028: 				if(pCity->GetCityBuildings()->GetNumActiveBuilding(eBuilding) > 0)

	push	ebp
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	test	eax, eax
	jle	SHORT $LN11@processAre

; 10029: 				{
; 10030: 					for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)

	xor	esi, esi
$LL111@processAre:

; 10031: 					{
; 10032: 						pArea->changeYieldRateModifier(pCity->getOwner(), ((YieldTypes)iJ), (pkBuildingInfo->GetAreaYieldModifier(iJ) * iChange * pCity->GetCityBuildings()->GetNumActiveBuilding(eBuilding)));

	mov	ebx, DWORD PTR [edi+84]
	push	ebp
	mov	ecx, edi
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	mov	ecx, DWORD PTR _pkBuildingInfo$226776[esp+24]
	push	esi
	mov	ebp, eax
	call	?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetAreaYieldModifier
	imul	ebp, eax
	imul	ebp, DWORD PTR _iChange$[esp+20]
	push	ebp
	push	esi
	push	ebx
	mov	ebx, DWORD PTR _pArea$[esp+32]
	mov	ecx, ebx
	call	?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z ; CvArea::changeYieldRateModifier
	mov	ebp, DWORD PTR _iI$[esp+24]
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL111@processAre
$LN11@processAre:

; 10021: 
; 10022: 		for(iI = 0; iI < GC.getNumBuildingInfos(); ++iI)

	inc	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$[esp+24], ebp
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	ebp, eax
	jl	SHORT $LL12@processAre
$LN112@processAre:

; 10033: 					}
; 10034: 				}
; 10035: 			}
; 10036: 		}
; 10037: 
; 10038: 		for(iI = 0; iI < MAX_PLAYERS; ++iI)

	xor	esi, esi
	npad	5
$LL4@processAre:

; 10039: 		{
; 10040: 			if(pArea->getTargetCity((PlayerTypes)iI) == pCity)

	push	esi
	mov	ecx, ebx
	call	?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvArea::getTargetCity
	cmp	eax, edi
	jne	SHORT $LN3@processAre

; 10041: 			{
; 10042: 				pArea->setTargetCity(((PlayerTypes)iI), NULL);

	push	0
	push	esi
	mov	ecx, ebx
	call	?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z ; CvArea::setTargetCity
$LN3@processAre:
	inc	esi
	cmp	esi, 64					; 00000040H
	jl	SHORT $LL4@processAre
$LN2@processAre:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 10043: 			}
; 10044: 		}
; 10045: 	}
; 10046: }

	add	esp, 8
	ret	8
?processArea@CvPlot@@IAEXPAVCvArea@@H@Z ENDP		; CvPlot::processArea
_TEXT	ENDS
PUBLIC	?write@CvPlot@@QBEXAAVFDataStream@@@Z		; CvPlot::write
EXTRN	?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z:PROC ; BuildArrayHelpers::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator<<
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4FeatureTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4RouteTypes@@@Z:PROC ; operator<<
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$?write@CvPlot@@QBEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write@CvPlot@@QBEXAAVFDataStream@@@Z$0
__ehfuncinfo$?write@CvPlot@@QBEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?write@CvPlot@@QBEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?write@CvPlot@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
$T242782 = -61						; size = 1
$T242781 = -61						; size = 1
$T242780 = -61						; size = 1
$T242779 = -61						; size = 1
$T242778 = -61						; size = 1
$T242777 = -61						; size = 1
$T242776 = -61						; size = 1
$T242775 = -61						; size = 1
$T242774 = -61						; size = 1
$T242773 = -61						; size = 1
$T242772 = -61						; size = 1
$T242771 = -61						; size = 1
_uLength$ = -60						; size = 4
_uiVersion$ = -56					; size = 4
$T243064 = -52						; size = 4
$T242784 = -52						; size = 4
$T242783 = -52						; size = 4
_uiVersion$243069 = -48					; size = 4
$T243067 = -44						; size = 4
_scriptData$227004 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_hasScriptData$ = 8					; size = 1
_kStream$ = 8						; size = 4
?write@CvPlot@@QBEXAAVFDataStream@@@Z PROC		; CvPlot::write, COMDAT
; _this$ = ecx

; 10284: {

	push	-1
	push	__ehhandler$?write@CvPlot@@QBEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi

; 10285: 	// Current version number
; 10286: 	uint uiVersion = g_CurrentCvPlotVersion;
; 10287: 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+72]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+80]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+84], 7
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 10288: 
; 10289: 	kStream << m_iX;

	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10290: 	kStream << m_iY;

	lea	ecx, DWORD PTR [edi+2]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10291: 	kStream << m_iArea;

	lea	edx, DWORD PTR [edi+356]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10292: 	kStream << m_iFeatureVariety;

	lea	eax, DWORD PTR [edi+453]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10293: 	kStream << m_iOwnershipDuration;

	lea	ecx, DWORD PTR [edi+380]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10294: 	kStream << m_iImprovementDuration;

	lea	edx, DWORD PTR [edi+382]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10295: 	kStream << m_iUpgradeProgress;

	lea	eax, DWORD PTR [edi+384]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10296: 	kStream << m_iCulture;

	lea	ecx, DWORD PTR [edi+386]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10297: 	kStream << m_iNumMajorCivsRevealed;

	lea	edx, DWORD PTR [edi+454]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10298: 	kStream << m_iCityRadiusCount;

	lea	eax, DWORD PTR [edi+455]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10299: 	kStream << m_iReconCount;

	lea	ecx, DWORD PTR [edi+456]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10300: 	kStream << m_iRiverCrossingCount;

	lea	edx, DWORD PTR [edi+457]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10301: 	kStream << m_iResourceNum;

	lea	eax, DWORD PTR [edi+458]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10302: 	kStream << m_cBuilderAIScratchPadPlayer;

	lea	ecx, DWORD PTR [edi+368]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10303: 	kStream << m_sBuilderAIScratchPadTurn;

	lea	edx, DWORD PTR [edi+370]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10304: 	kStream << m_sBuilderAIScratchPadValue;

	lea	eax, DWORD PTR [edi+372]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10305: 	kStream << m_eBuilderAIScratchPadRoute;

	lea	ecx, DWORD PTR [edi+376]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4RouteTypes@@@Z ; operator<<
	add	esp, 8

; 10306: 	kStream << m_iLandmass;

	lea	edx, DWORD PTR [edi+360]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10307: 	kStream << m_uiTradeRouteBitFlags;

	lea	eax, DWORD PTR [edi+388]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 10308: 
; 10309: 	kStream << m_bStartingPlot;

	movzx	ecx, BYTE PTR [edi+461]
	shr	cl, 2
	and	cl, 1
	lea	edx, DWORD PTR $T242771[esp+80]
	mov	BYTE PTR $T242771[esp+80], cl
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10310: 	kStream << m_bHills;

	movzx	eax, BYTE PTR [edi+461]
	shr	al, 3
	lea	ecx, DWORD PTR $T242772[esp+80]
	and	al, 1
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR $T242772[esp+84], al
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10311: 	kStream << m_bNEOfRiver;

	movzx	edx, BYTE PTR [edi+461]
	shr	dl, 4
	lea	eax, DWORD PTR $T242773[esp+80]
	and	dl, 1
	push	eax
	mov	ecx, esi
	mov	BYTE PTR $T242773[esp+84], dl
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10312: 	kStream << m_bWOfRiver;

	movzx	ecx, BYTE PTR [edi+461]
	shr	cl, 5
	and	cl, 1
	lea	edx, DWORD PTR $T242774[esp+80]
	mov	BYTE PTR $T242774[esp+80], cl
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10313: 	kStream << m_bNWOfRiver;

	movzx	eax, BYTE PTR [edi+461]
	shr	al, 6
	lea	ecx, DWORD PTR $T242775[esp+80]
	and	al, 1
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR $T242775[esp+84], al
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10314: 	kStream << m_bPotentialCityWork;

	movzx	edx, BYTE PTR [edi+461]
	lea	eax, DWORD PTR $T242776[esp+80]
	shr	dl, 7
	push	eax
	mov	ecx, esi
	mov	BYTE PTR $T242776[esp+84], dl
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10315: 	kStream << m_bImprovementPillaged;

	movzx	ecx, BYTE PTR [edi+461]
	and	cl, 1
	lea	edx, DWORD PTR $T242777[esp+80]
	mov	BYTE PTR $T242777[esp+80], cl
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10316: 	kStream << m_bRoutePillaged;

	movzx	eax, BYTE PTR [edi+461]
	shr	al, 1
	lea	ecx, DWORD PTR $T242778[esp+80]
	and	al, 1
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR $T242778[esp+84], al
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10317: 	kStream << m_bBarbCampNotConverting;

	movzx	edx, BYTE PTR [edi+462]
	shr	dl, 2
	lea	eax, DWORD PTR $T242779[esp+80]
	and	dl, 1
	push	eax
	mov	ecx, esi
	mov	BYTE PTR $T242779[esp+84], dl
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10318: 	kStream << m_bRoughFeature;

	movzx	ecx, BYTE PTR [edi+462]
	shr	cl, 3
	and	cl, 1
	mov	BYTE PTR $T242780[esp+80], cl
	lea	edx, DWORD PTR $T242780[esp+80]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10319: 	kStream << m_bResourceLinkedCityActive;

	movzx	eax, BYTE PTR [edi+462]
	shr	al, 4
	lea	ecx, DWORD PTR $T242781[esp+80]
	and	al, 1
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR $T242781[esp+84], al
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10320: 	kStream << m_bImprovedByGiftFromMajor;

	movzx	edx, BYTE PTR [edi+462]
	shr	dl, 5
	lea	eax, DWORD PTR $T242782[esp+80]
	and	dl, 1
	push	eax
	mov	ecx, esi
	mov	BYTE PTR $T242782[esp+84], dl
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10321: 	// m_bPlotLayoutDirty not saved
; 10322: 	// m_bLayoutStateWorked not saved
; 10323: 
; 10324: 	kStream << m_eOwner;

	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10325: 	kStream << m_ePlotType;

	lea	edx, DWORD PTR [edi+5]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10326: 	kStream << m_eTerrainType;

	lea	eax, DWORD PTR [edi+6]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10327: 	CvInfosSerializationHelper::WriteHashed(kStream, (const FeatureTypes)m_eFeatureType.get());

	movsx	ecx, BYTE PTR [edi+432]
	push	ecx
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4FeatureTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 10328: 	CvInfosSerializationHelper::WriteHashed(kStream, (const ResourceTypes)m_eResourceType);

	movsx	edx, BYTE PTR [edi+440]
	push	edx
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 10329: 	CvInfosSerializationHelper::WriteHashed(kStream, (const ImprovementTypes)m_eImprovementType);

	movsx	eax, BYTE PTR [edi+441]
	push	eax
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 10330: 	CvInfosSerializationHelper::WriteHashed(kStream, (const ImprovementTypes)m_eImprovementTypeUnderConstruction);

	movsx	ecx, BYTE PTR [edi+442]
	push	ecx
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 32					; 00000020H

; 10331: 	kStream << m_ePlayerBuiltImprovement;

	lea	edx, DWORD PTR [edi+443]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10332: 	kStream << m_ePlayerResponsibleForImprovement;

	lea	eax, DWORD PTR [edi+444]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10333: 	kStream << m_ePlayerResponsibleForRoute;

	lea	ecx, DWORD PTR [edi+445]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10334: 	kStream << m_ePlayerThatClearedBarbCampHere;

	lea	edx, DWORD PTR [edi+446]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10335: 	kStream << m_eRouteType;

	lea	eax, DWORD PTR [edi+447]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10336: 	kStream << m_eWorldAnchor;

	lea	ecx, DWORD PTR [edi+448]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10337: 	kStream << m_cWorldAnchorData;

	lea	edx, DWORD PTR [edi+449]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10338: 	kStream << m_eRiverEFlowDirection;

	lea	eax, DWORD PTR [edi+450]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10339: 	kStream << m_eRiverSEFlowDirection;

	lea	ecx, DWORD PTR [edi+451]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10340: 	kStream << m_eRiverSWFlowDirection;

	lea	edx, DWORD PTR [edi+452]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10341: 
; 10342: 	kStream << m_plotCity.eOwner;

	lea	eax, DWORD PTR [edi+104]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10343: 	kStream << m_plotCity.iID;

	lea	ecx, DWORD PTR [edi+108]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10344: 	kStream << m_workingCity.eOwner;

	lea	edx, DWORD PTR [edi+112]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10345: 	kStream << m_workingCity.iID;

	lea	eax, DWORD PTR [edi+116]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10346: 	kStream << m_workingCityOverride.eOwner;

	lea	ecx, DWORD PTR [edi+120]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10347: 	kStream << m_workingCityOverride.iID;

	lea	edx, DWORD PTR [edi+124]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10348: 	kStream << m_ResourceLinkedCity.eOwner;

	lea	eax, DWORD PTR [edi+128]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10349: 	kStream << m_ResourceLinkedCity.iID;

	lea	ecx, DWORD PTR [edi+132]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10350: 	kStream << m_purchaseCity.eOwner;

	lea	edx, DWORD PTR [edi+136]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10351: 	kStream << m_purchaseCity.iID;

	lea	eax, DWORD PTR [edi+140]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	xor	ebp, ebp
	npad	8
$LL36@write:

; 10352: 
; 10353: 	for(uint i = 0; i < NUM_YIELD_TYPES; i++)
; 10354: 		kStream << m_aiYield[i];

	mov	eax, DWORD PTR [edi+144]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	add	ebp, 2
	cmp	ebp, 12					; 0000000cH
	jb	SHORT $LL36@write

; 10355: 
; 10356: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	xor	ebp, ebp
	npad	6
$LL33@write:

; 10357: 		kStream << m_aiFoundValue[i];

	mov	eax, DWORD PTR [edi+148]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebp, 4
	cmp	ebp, 320				; 00000140H
	jb	SHORT $LL33@write

; 10358: 
; 10359: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	xor	ebp, ebp
	npad	3
$LL30@write:

; 10360: 		kStream << m_aiPlayerCityRadiusCount[i];

	mov	eax, DWORD PTR [edi+152]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write
	inc	ebp
	cmp	ebp, 80					; 00000050H
	jb	SHORT $LL30@write

; 10361: 
; 10362: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
	npad	8
$LL27@write:

; 10363: 		kStream << m_aiVisibilityCount[i];

	mov	eax, DWORD PTR [edi+156]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	add	ebp, 2
	cmp	ebp, 160				; 000000a0H
	jb	SHORT $LL27@write

; 10364: 
; 10365: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
	npad	3
$LL24@write:

; 10366: 		kStream << m_aiRevealedOwner[i];

	mov	eax, DWORD PTR [edi+160]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write
	inc	ebp
	cmp	ebp, 80					; 00000050H
	jb	SHORT $LL24@write

; 10367: 
; 10368: 	kStream << m_cRiverCrossing;

	lea	ecx, DWORD PTR [edi+460]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write
	lea	ebx, DWORD PTR [edi+8]
	mov	ebp, 4
	npad	4
$LL21@write:

; 10369: 
; 10370: 	//for(uint i = 0; i < REALLY_MAX_TEAMS;i++)
; 10371: 	//	kStream << m_abRevealed[i];
; 10372: 
; 10373: 	for(uint i = 0; i<PlotBoolField::eCount; ++i)
; 10374: 	{
; 10375: 		kStream << m_bfRevealed.m_dwBits[i];

	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL21@write

; 10376: 	}
; 10377: 
; 10378: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebx, ebx
$LL18@write:

; 10379: 		kStream << m_abResourceForceReveal[i];

	mov	eax, DWORD PTR [edi+176]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	ebp
	cmp	ebp, 80					; 00000050H
	jb	SHORT $LL18@write

; 10380: 
; 10381: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
	npad	6
$LL15@write:

; 10382: 	{
; 10383: 		CvInfosSerializationHelper::WriteHashed(kStream, (const ImprovementTypes)m_aeRevealedImprovementType[i]);

	mov	edx, DWORD PTR [edi+164]
	movsx	eax, WORD PTR [edx+ebp]
	push	eax
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	ebp, 2
	add	esp, 8
	cmp	ebp, 160				; 000000a0H
	jb	SHORT $LL15@write

; 10384: 	}
; 10385: 
; 10386: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
$LL12@write:

; 10387: 		kStream << m_aeRevealedRouteType[i];

	mov	eax, DWORD PTR [edi+168]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	add	ebp, 2
	cmp	ebp, 160				; 000000a0H
	jb	SHORT $LL12@write

; 10388: 
; 10389: 	for(uint i = 0; i < MAX_MAJOR_CIVS; i++)

	xor	ebp, ebp
	npad	2
$LL9@write:

; 10390: 		kStream << m_abNoSettling[i];

	mov	eax, DWORD PTR [edi+172]
	add	eax, ebp
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	ebp
	cmp	ebp, 22					; 00000016H
	jb	SHORT $LL9@write

; 10391: 
; 10392: 	// char * should have died in 1989...
; 10393: 	bool hasScriptData = (m_szScriptData != NULL);

	cmp	DWORD PTR [edi+180], ebx

; 10394: 	kStream << hasScriptData;

	lea	edx, DWORD PTR _hasScriptData$[esp+76]
	setne	cl
	mov	BYTE PTR _hasScriptData$[esp+76], cl
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10395: 	if(hasScriptData)

	cmp	BYTE PTR _hasScriptData$[esp+76], 0
	je	SHORT $LN6@write

; 10396: 	{
; 10397: 		const std::string scriptData(m_szScriptData);

	mov	eax, DWORD PTR [edi+180]
	push	eax
	lea	ecx, DWORD PTR _scriptData$227004[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 10398: 		kStream << scriptData;

	lea	ecx, DWORD PTR _scriptData$227004[esp+80]
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+96], ebx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator<<
	add	esp, 8

; 10399: 	}

	lea	ecx, DWORD PTR _scriptData$227004[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@write:

; 10400: 
; 10401: 	if(NULL == m_paiBuildProgress)

	cmp	DWORD PTR [edi+184], ebx
	jne	SHORT $LN5@write

; 10402: 	{
; 10403: 		kStream << (int)0;

	lea	edx, DWORD PTR $T242783[esp+80]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR $T242783[esp+84], ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10404: 	}
; 10405: 	else

	jmp	SHORT $LN4@write
$LN5@write:

; 10406: 	{
; 10407: 		kStream << (int)GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	DWORD PTR $T242784[esp+80], eax
	lea	eax, DWORD PTR $T242784[esp+80]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10408: 		BuildArrayHelpers::Write(kStream, m_paiBuildProgress, GC.getNumBuildInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	ecx, DWORD PTR [edi+184]
	push	eax
	push	ecx
	push	esi
	call	?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z ; BuildArrayHelpers::Write
	add	esp, 12					; 0000000cH
$LN4@write:

; 10409: 	}
; 10410: 
; 10411: 	kStream << m_apaiInvisibleVisibilityCount;

	lea	ebx, DWORD PTR [edi+196]
	mov	ebp, 80					; 00000050H
$LL168@write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	add	ebx, 2
	sub	ebp, 1
	jne	SHORT $LL168@write

; 10412: 
; 10413: 	//  Write m_units.Write(kStream);
; 10414: 	UINT uLength = (UINT)m_units.getLength();

	mov	edx, DWORD PTR [edi+28]

; 10415: 	kStream << uLength;

	lea	eax, DWORD PTR _uLength$[esp+80]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uLength$[esp+84], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 10416: 	for(UINT uIdx = 0; uIdx < uLength; ++uIdx)

	cmp	DWORD PTR _uLength$[esp+80], ebp
	jbe	SHORT $LN1@write
	npad	2
$LL230@write:

; 10417: 	{
; 10418: 		const IDInfo* pData = m_units.getAt(uIdx);

	cmp	ebp, DWORD PTR [edi+28]
	jae	SHORT $LN185@write
	mov	ecx, DWORD PTR [edi+24]
	lea	ebx, DWORD PTR [ecx+ebp*8]
	jmp	SHORT $LN184@write
$LN185@write:
	xor	ebx, ebx
$LN184@write:

; 10419: 
; 10420: 		kStream << pData->eOwner;

	push	ebx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10421: 		kStream << pData->iID;

	add	ebx, 4
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebp
	cmp	ebp, DWORD PTR _uLength$[esp+80]
	jb	SHORT $LL230@write
$LN1@write:

; 10422: 	}
; 10423: 
; 10424: 	kStream << m_cContinentType;

	lea	edx, DWORD PTR [edi+459]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10425: 	kStream << m_kArchaeologyData;

	lea	eax, DWORD PTR _uiVersion$243069[esp+80]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$243069[esp+84], 2
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR [edi+464]
	lea	edx, DWORD PTR $T243064[esp+80]
	mov	DWORD PTR $T243064[esp+80], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	eax, DWORD PTR [edi+468]
	push	eax
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<
	lea	ecx, DWORD PTR [edi+472]
	push	ecx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	lea	edx, DWORD PTR [edi+476]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	mov	eax, DWORD PTR [edi+480]
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR $T243067[esp+80]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T243067[esp+84], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10426: }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 64					; 00000040H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write@CvPlot@@QBEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _scriptData$227004[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?write@CvPlot@@QBEXAAVFDataStream@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?write@CvPlot@@QBEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write@CvPlot@@QBEXAAVFDataStream@@@Z ENDP		; CvPlot::write
PUBLIC	?updateLayout@CvPlot@@QAEX_N@Z			; CvPlot::updateLayout
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?updateLayout@CvPlot@@QAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$1
__ehfuncinfo$?updateLayout@CvPlot@@QAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?updateLayout@CvPlot@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateLayout@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_eThisImprovement$ = -32				; size = 4
_improvementState$ = -28				; size = 4
_eThisResource$ = -24					; size = 4
_eActiveTeam$ = -20					; size = 4
_eFOWMode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
$T243110 = 8						; size = 4
_pDllPlot$ = 8						; size = 4
_bDebug$ = 8						; size = 1
?updateLayout@CvPlot@@QAEX_N@Z PROC			; CvPlot::updateLayout, COMDAT
; _this$ = ecx

; 10463: {

	push	-1
	push	__ehhandler$?updateLayout@CvPlot@@QAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 10464: 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	esi, eax

; 10465: 
; 10466: 	FogOfWarModeTypes eFOWMode = GetActiveFogOfWarMode();

	mov	ecx, edi
	mov	DWORD PTR _eActiveTeam$[esp+48], esi
	call	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode
	mov	ebp, eax

; 10467: 
; 10468: 	ResourceTypes eThisResource = (isCity() || eFOWMode == FOGOFWARMODE_UNEXPLORED) ? NO_RESOURCE : getResourceType(eActiveTeam);

	mov	eax, DWORD PTR [edi+104]
	mov	DWORD PTR _eFOWMode$[esp+48], ebp
	test	eax, eax
	jl	SHORT $LN115@updateLayo
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN115@updateLayo
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN119@updateLayo
$LN115@updateLayo:
	cmp	ebp, 1
	je	SHORT $LN119@updateLayo
	push	esi
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eThisResource$[esp+48], eax
	jmp	SHORT $LN40@updateLayo
$LN119@updateLayo:
	mov	DWORD PTR _eThisResource$[esp+48], -1
$LN40@updateLayo:

; 10469: 
; 10470: 	ImprovementTypes eThisImprovement = getRevealedImprovementType(eActiveTeam, bDebug);

	cmp	BYTE PTR _bDebug$[esp+44], 0
	je	SHORT $LN53@updateLayo
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN53@updateLayo
	movsx	edx, BYTE PTR [edi+441]
	mov	DWORD PTR _eThisImprovement$[esp+48], edx
	jmp	SHORT $LN52@updateLayo
$LN53@updateLayo:
	mov	eax, DWORD PTR [edi+164]
	movsx	ecx, WORD PTR [eax+esi*2]
	mov	DWORD PTR _eThisImprovement$[esp+48], ecx
$LN52@updateLayo:

; 10471: 	bool bShowHalfBuilt = false;

	xor	bl, bl

; 10472: 	if(eThisImprovement == NO_IMPROVEMENT && getAnyBuildProgress() && eFOWMode == FOGOFWARMODE_OFF)

	cmp	DWORD PTR _eThisImprovement$[esp+48], -1
	jne	SHORT $LN121@updateLayo
	cmp	DWORD PTR [edi+184], 0
	je	SHORT $LN121@updateLayo
	test	ebp, ebp
	jne	SHORT $LN121@updateLayo

; 10473: 	{
; 10474: 		// see if we are improving the tile
; 10475: #ifdef AUI_WARNING_FIXES
; 10476: 		for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 10477: #else
; 10478: 		for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN121@updateLayo
	npad	6
$LL35@updateLayo:

; 10479: #endif
; 10480: 		{
; 10481: 			BuildTypes eBuild = (BuildTypes)iBuildIndex;
; 10482: 			CvBuildInfo* build = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 10483: 			if(build)

	test	eax, eax
	je	SHORT $LN34@updateLayo

; 10484: 			{
; 10485: 				ImprovementTypes eInnerImprovement = (ImprovementTypes)build->getImprovement();

	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement

; 10486: 				if(eInnerImprovement == NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN34@updateLayo

; 10487: 				{
; 10488: 					continue;
; 10489: 				}
; 10490: 
; 10491: 				int iProgress = getBuildProgress(eBuild);

	mov	ecx, DWORD PTR [edi+184]
	test	ecx, ecx
	je	SHORT $LN34@updateLayo
	movsx	ecx, WORD PTR [ecx+esi*2]

; 10492: 				if(iProgress > 0)

	test	ecx, ecx
	jg	SHORT $LN111@updateLayo
$LN34@updateLayo:

; 10473: 	{
; 10474: 		// see if we are improving the tile
; 10475: #ifdef AUI_WARNING_FIXES
; 10476: 		for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 10477: #else
; 10478: 		for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL35@updateLayo

; 10574: 					if(iProgress > 0)

	jmp	SHORT $LN121@updateLayo
$LN111@updateLayo:

; 10493: 				{
; 10494: 					eThisImprovement = eInnerImprovement;

	mov	DWORD PTR _eThisImprovement$[esp+48], eax

; 10495: 					bShowHalfBuilt = true;

	mov	bl, 1
$LN121@updateLayo:

; 10496: 					break;
; 10497: 				}
; 10498: 			}
; 10499: 
; 10500: 		}
; 10501: 	}
; 10502: 
; 10503: 	int improvementState = 2; // half-built = 1, full built = 2, pillaged = 3
; 10504: 	if(IsImprovementPillaged() && eFOWMode == FOGOFWARMODE_OFF)

	test	BYTE PTR [edi+461], 1
	mov	DWORD PTR _improvementState$[esp+48], 2
	je	SHORT $LN29@updateLayo
	test	ebp, ebp
	jne	SHORT $LN29@updateLayo

; 10505: 	{
; 10506: 		improvementState = 3;

	mov	DWORD PTR _improvementState$[esp+48], 3
	jmp	SHORT $LN27@updateLayo
$LN29@updateLayo:

; 10507: 	}
; 10508: 	else if(bShowHalfBuilt)

	test	bl, bl
	je	SHORT $LN27@updateLayo

; 10509: 	{
; 10510: 		improvementState = 1;

	mov	DWORD PTR _improvementState$[esp+48], 1
$LN27@updateLayo:

; 10511: 	}
; 10512: 
; 10513: 	RouteTypes eRoute = getRevealedRouteType(eActiveTeam, bDebug);

	cmp	BYTE PTR _bDebug$[esp+44], 0
	je	SHORT $LN68@updateLayo
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN68@updateLayo
	movsx	ebp, BYTE PTR [edi+447]
	jmp	SHORT $LN67@updateLayo
$LN68@updateLayo:
	mov	edx, DWORD PTR [edi+168]
	mov	eax, DWORD PTR _eActiveTeam$[esp+48]
	movsx	ebp, WORD PTR [edx+eax*2]
$LN67@updateLayo:

; 10514: 	byte eRoadTypeValue = NUM_ROAD_RR_TYPES;

	mov	bl, 8

; 10515: 	if(eRoute != NO_ROUTE)

	cmp	ebp, -1
	je	SHORT $LN26@updateLayo

; 10516: 	{
; 10517: 		switch(eRoute)

	mov	eax, ebp
	sub	eax, 0
	je	SHORT $LN23@updateLayo
	sub	eax, 1
	jne	$LN120@updateLayo

; 10525: 			{
; 10526: 				eRoadTypeValue = ROAD_TRADE_ROUTE;
; 10527: 			}
; 10528: 			else
; 10529: 			{
; 10530: 				eRoadTypeValue = ROAD_REGULAR;
; 10531: 			}
; 10532: 			break;
; 10533: 		case ROUTE_RAILROAD:
; 10534: 			if(IsRoutePillaged())

	test	BYTE PTR [edi+461], 2
	je	SHORT $LN17@updateLayo

; 10535: 			{
; 10536: 				eRoadTypeValue = RR_PILLAGED;

	mov	bl, 3
	jmp	$LN120@updateLayo
$LN17@updateLayo:

; 10537: 			}
; 10538: 			else if(IsTradeRoute())

	xor	ecx, ecx
	cmp	ecx, DWORD PTR [edi+388]
	sbb	bl, bl
	and	bl, 6
	inc	bl

; 10539: 			{
; 10540: 				eRoadTypeValue = RR_TRADE_ROUTE;
; 10541: 			}
; 10542: 			else
; 10543: 			{
; 10544: 				eRoadTypeValue = RR_REGULAR;
; 10545: 			}
; 10546: 			break;

	jmp	$LN120@updateLayo
$LN23@updateLayo:

; 10518: 		{
; 10519: 		case ROUTE_ROAD:
; 10520: 			if(IsRoutePillaged())

	test	BYTE PTR [edi+461], 2
	je	SHORT $LN22@updateLayo

; 10521: 			{
; 10522: 				eRoadTypeValue = ROAD_PILLAGED;

	mov	bl, 2
	jmp	$LN120@updateLayo
$LN22@updateLayo:

; 10523: 			}
; 10524: 			else if(IsTradeRoute())

	xor	edx, edx
	cmp	edx, DWORD PTR [edi+388]
	sbb	bl, bl
	and	bl, 6

; 10547: 		}
; 10548: 	}
; 10549: 	else

	jmp	SHORT $LN120@updateLayo
$LN26@updateLayo:

; 10550: 	{
; 10551: 		bShowHalfBuilt = false;
; 10552: #ifdef AUI_WARNING_FIXES
; 10553: 		if (getAnyBuildProgress() && eFOWMode == FOGOFWARMODE_OFF)
; 10554: 		{
; 10555: 			for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 10556: #else
; 10557: 		if(eRoute == NO_ROUTE && getAnyBuildProgress() && eFOWMode == FOGOFWARMODE_OFF)

	cmp	DWORD PTR [edi+184], 0
	je	SHORT $LN120@updateLayo
	cmp	DWORD PTR _eFOWMode$[esp+48], 0
	jne	SHORT $LN120@updateLayo

; 10558: 		{
; 10559: 			// see if we are improving the tile
; 10560: 			for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN120@updateLayo
	npad	10
$LL11@updateLayo:

; 10561: #endif
; 10562: 			{
; 10563: 				BuildTypes eBuild = (BuildTypes)iBuildIndex;
; 10564: 				CvBuildInfo* build = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 10565: 				if(build)

	test	eax, eax
	je	SHORT $LN10@updateLayo

; 10566: 				{
; 10567: 					RouteTypes eInnerRoute = (RouteTypes)build->getRoute();

	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute

; 10568: 					if(eInnerRoute == NO_ROUTE)

	cmp	eax, -1
	je	SHORT $LN10@updateLayo

; 10569: 					{
; 10570: 						continue;
; 10571: 					}
; 10572: 
; 10573: 					int iProgress = getBuildProgress(eBuild);

	mov	ecx, DWORD PTR [edi+184]
	test	ecx, ecx
	je	SHORT $LN10@updateLayo
	movsx	ecx, WORD PTR [ecx+esi*2]

; 10574: 					if(iProgress > 0)

	test	ecx, ecx
	jg	SHORT $LN112@updateLayo
$LN10@updateLayo:

; 10558: 		{
; 10559: 			// see if we are improving the tile
; 10560: 			for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL11@updateLayo

; 10574: 					if(iProgress > 0)

	jmp	SHORT $LN120@updateLayo
$LN112@updateLayo:

; 10575: 					{
; 10576: 						eRoute = eInnerRoute;

	mov	ebp, eax

; 10577: 						bShowHalfBuilt = true;
; 10578: 						break;
; 10579: 					}
; 10580: 				}
; 10581: 
; 10582: 			}
; 10583: 		}
; 10584: 		if(bShowHalfBuilt)
; 10585: 		{
; 10586: 			switch(eRoute)

	sub	eax, 0
	je	SHORT $LN2@updateLayo
	sub	eax, 1
	jne	SHORT $LN120@updateLayo

; 10590: 				break;
; 10591: 			case ROUTE_RAILROAD:
; 10592: 				eRoadTypeValue = RR_UNDER_CONSTRUCTION;

	mov	bl, 5

; 10593: 				break;

	jmp	SHORT $LN120@updateLayo
$LN2@updateLayo:

; 10587: 			{
; 10588: 			case ROUTE_ROAD:
; 10589: 				eRoadTypeValue = ROAD_UNDER_CONSTRUCTION;

	mov	bl, 4
$LN120@updateLayo:

; 10594: 			}
; 10595: 		}
; 10596: 	}
; 10597: 
; 10598: 	auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T243110[esp+44], eax
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+56], esi
	cmp	eax, esi
	je	SHORT $LN41@updateLayo
	push	edi
	mov	ecx, eax
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	esi, eax
$LN41@updateLayo:
	mov	DWORD PTR _pDllPlot$[esp+44], esi

; 10599: 	gDLL->GameplayPlotStateChange
; 10600: 	(
; 10601: 	    pDllPlot.get(),
; 10602: 	    eThisResource,
; 10603: 	    eThisImprovement,
; 10604: 	    improvementState,
; 10605: 	    eRoute,
; 10606: 	    eRoadTypeValue
; 10607: 	);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+692]
	movzx	edx, bl
	push	edx
	mov	edx, DWORD PTR _improvementState$[esp+52]
	push	ebp
	push	edx
	mov	edx, DWORD PTR _eThisImprovement$[esp+60]
	push	edx
	mov	edx, DWORD PTR _eThisResource$[esp+64]
	push	edx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+80], 1
	call	eax

; 10608: }

	mov	DWORD PTR __$EHRec$[esp+56], -1
	test	esi, esi
	je	SHORT $LN106@updateLayo
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
$LN106@updateLayo:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$0:
	mov	eax, DWORD PTR $T243110[ebp-4]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$[ebp-4]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?updateLayout@CvPlot@@QAEX_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?updateLayout@CvPlot@@QAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateLayout@CvPlot@@QAEX_N@Z ENDP			; CvPlot::updateLayout
PUBLIC	?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z ; CvPlot::getVisibleImprovementState
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
_bWorked$ = 12						; size = 4
?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z PROC ; CvPlot::getVisibleImprovementState, COMDAT
; _this$ = ecx

; 10625: {

	push	ebp

; 10626: 	eType = NO_IMPROVEMENT;
; 10627: 	bWorked = false;

	mov	ebp, DWORD PTR _bWorked$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eType$[esp+8]
	mov	DWORD PTR [edi], -1
	mov	esi, ecx
	mov	BYTE PTR [ebp], 0

; 10628: 
; 10629: 	if(GC.getGame().getActiveTeam() == NO_TEAM)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, -1
	je	$LN1@getVisible@2

; 10630: 	{
; 10631: 		return;
; 10632: 	}
; 10633: 
; 10634: 	eType = getRevealedImprovementType(GC.getGame().getActiveTeam(), true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN10@getVisible@2
	movsx	eax, BYTE PTR [esi+441]
	jmp	SHORT $LN9@getVisible@2
$LN10@getVisible@2:
	mov	eax, DWORD PTR [esi+164]
	movsx	eax, WORD PTR [eax+ebx*2]
$LN9@getVisible@2:
	mov	DWORD PTR [edi], eax

; 10635: 
; 10636: 	// worked state
; 10637: 	if(isActiveVisible(false) && isBeingWorked())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	pop	ebx
	cmp	eax, -1
	je	SHORT $LN1@getVisible@2
	mov	ecx, DWORD PTR [esi+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	je	SHORT $LN1@getVisible@2
	mov	edx, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [esi+112]
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@getVisible@2
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	je	SHORT $LN1@getVisible@2

; 10638: 	{
; 10639: 		bWorked = true;

	mov	BYTE PTR [ebp], 1
$LN1@getVisible@2:
	pop	edi
	pop	esi
	pop	ebp

; 10640: 	}
; 10641: }

	ret	8
?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z ENDP ; CvPlot::getVisibleImprovementState
_TEXT	ENDS
PUBLIC	?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z ; CvPlot::getVisibleResourceState
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
_bImproved$ = 12					; size = 4
_bWorked$ = 16						; size = 4
?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z PROC ; CvPlot::getVisibleResourceState, COMDAT
; _this$ = ecx

; 10646: 	eType = NO_RESOURCE;
; 10647: 	bImproved = false;
; 10648: 	bWorked = false;

	mov	eax, DWORD PTR _bWorked$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR _bImproved$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _eType$[esp+8]
	mov	DWORD PTR [edi], -1
	mov	BYTE PTR [ebp], 0
	mov	esi, ecx
	mov	BYTE PTR [eax], 0

; 10649: 
; 10650: 	if(GC.getGame().getActiveTeam() == NO_TEAM)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, -1
	je	$LN1@getVisible@3

; 10651: 	{
; 10652: 		return;
; 10653: 	}
; 10654: 
; 10655: 	if(GC.getGame().isDebugMode())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN5@getVisible@3

; 10656: 	{
; 10657: 		eType = getResourceType();

	movsx	ecx, BYTE PTR [esi+440]
	mov	DWORD PTR [edi], ecx
	jmp	SHORT $LN3@getVisible@3
$LN5@getVisible@3:

; 10658: 	}
; 10659: 	else if(isRevealed(GC.getGame().getActiveTeam()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	ebx, ecx
	mov	ecx, eax
	sub	ecx, ebx
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	je	SHORT $LN3@getVisible@3

; 10660: 	{
; 10661: 		eType = getResourceType(GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR [edi], eax
$LN3@getVisible@3:

; 10662: 	}
; 10663: 
; 10664: 	// improved and worked states ...
; 10665: 	if(eType != NO_RESOURCE)

	cmp	DWORD PTR [edi], -1
	je	SHORT $LN48@getVisible@3

; 10666: 	{
; 10667: 		ImprovementTypes eRevealedImprovement = getRevealedImprovementType(GC.getGame().getActiveTeam(), true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, eax
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN41@getVisible@3
	movsx	eax, BYTE PTR [esi+441]
	jmp	SHORT $LN40@getVisible@3
$LN41@getVisible@3:
	mov	ecx, DWORD PTR [esi+164]
	movsx	eax, WORD PTR [ecx+ebx*2]
$LN40@getVisible@3:

; 10668: 
; 10669: 		if((eRevealedImprovement != NO_IMPROVEMENT) && GC.getImprovementInfo(eRevealedImprovement)->IsImprovementResourceTrade(eType))

	cmp	eax, -1
	je	SHORT $LN48@getVisible@3
	mov	edx, DWORD PTR [edi]
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN48@getVisible@3

; 10670: 		{
; 10671: 			bImproved = true;
; 10672: 			bWorked = isBeingWorked();

	mov	ecx, esi
	mov	BYTE PTR [ebp], 1
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	mov	ecx, DWORD PTR _bWorked$[esp+12]
	mov	BYTE PTR [ecx], al
$LN48@getVisible@3:
	pop	ebx
$LN1@getVisible@3:
	pop	edi
	pop	esi
	pop	ebp

; 10673: 		}
; 10674: 	}
; 10675: }

	ret	12					; 0000000cH
?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z ENDP ; CvPlot::getVisibleResourceState
_TEXT	ENDS
PUBLIC	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
EXTRN	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetImprovementUpgrade
EXTRN	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z:PROC	; CvBuildInfo::isFeatureRemove
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_bCity$ = -25						; size = 1
_iYield$ = -24						; size = 4
tv928 = -20						; size = 4
$T243668 = -16						; size = 4
$T243664 = -16						; size = 4
$T243441 = -16						; size = 4
_bIgnoreFeature$ = -12					; size = 1
_pCity$ = -12						; size = 4
_eRoute$ = -12						; size = 4
_kYield$ = -8						; size = 4
_eResource$227239 = -4					; size = 4
_eBuild$ = 8						; size = 4
$T243423 = 12						; size = 4
_iTemp$227253 = 12					; size = 4
$T243422 = 12						; size = 4
_pkResourceInfo$227241 = 12				; size = 4
_eYield$ = 12						; size = 4
_bWithUpgrade$ = 16					; size = 1
_ePlayer$ = 20						; size = 4
?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z PROC ; CvPlot::getYieldWithBuild, COMDAT
; _this$ = ecx

; 10679: {

	sub	esp, 28					; 0000001cH
	push	esi

; 10680: 	int iYield;
; 10681: 
; 10682: 	const CvYieldInfo& kYield = *GC.getYieldInfo(eYield);

	mov	esi, DWORD PTR _eYield$[esp+28]
	push	edi
	mov	edi, ecx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo

; 10683: 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kYield$[esp+36], eax
	mov	eax, DWORD PTR _ePlayer$[esp+32]
	imul	eax, 63236				; 0000f704H
	mov	DWORD PTR tv928[esp+36], eax
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN75@getYieldWi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T243441[esp+36], edx
	jmp	SHORT $LN76@getYieldWi
$LN75@getYieldWi:
	mov	DWORD PTR $T243441[esp+36], -1
$LN76@getYieldWi:

; 10684: 
; 10685: 	if(getTerrainType() == NO_TERRAIN)

	cmp	BYTE PTR [edi+6], -1
	jne	SHORT $LN66@getYieldWi
$LN253@getYieldWi:
	pop	edi

; 10686: 		return 0;

	xor	eax, eax
	pop	esi

; 11013: }

	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
$LN66@getYieldWi:

; 10687: 
; 10688: 	if(!isPotentialCityWork())

	test	BYTE PTR [edi+461], 128			; 00000080H

; 10689: 		return 0;

	je	SHORT $LN253@getYieldWi

; 10690: 
; 10691: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IGNORE_FEATURE_EXTENDS_TO_CITY
; 10692: 	CvCity* pCity = getPlotCity();
; 10693: 	bool bCity = pCity != NULL;
; 10694: 
; 10695: 	// Will the build remove the feature?
; 10696: 	bool bIgnoreFeature = bCity;
; 10697: #else
; 10698: 	bool bCity = false;
; 10699: 
; 10700: 	// Will the build remove the feature?
; 10701: 	bool bIgnoreFeature = false;
; 10702: #endif
; 10703: 	if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [edi+432]
	push	ebx
	mov	ebx, DWORD PTR _eBuild$[esp+36]
	push	ebp
	mov	BYTE PTR _bCity$[esp+44], 0
	mov	BYTE PTR _bIgnoreFeature$[esp+44], 0
	cmp	al, -1
	je	SHORT $LN239@getYieldWi

; 10704: 	{
; 10705: 		if(GC.getBuildInfo(eBuild)->isFeatureRemove(getFeatureType()))

	movsx	eax, al
	push	eax
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	SHORT $LN239@getYieldWi

; 10706: 			bIgnoreFeature = true;

	mov	BYTE PTR _bIgnoreFeature$[esp+44], 1
$LN239@getYieldWi:

; 10707: 	}
; 10708: 
; 10709: 	// Nature yield
; 10710: 	iYield = calculateNatureYield(eYield, getTeam(), bIgnoreFeature);

	movsx	eax, BYTE PTR [edi+4]
	cmp	eax, -1
	je	SHORT $LN93@getYieldWi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN93@getYieldWi
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN92@getYieldWi
$LN93@getYieldWi:
	or	eax, -1
$LN92@getYieldWi:
	mov	ecx, DWORD PTR _bIgnoreFeature$[esp+44]
	push	ecx
	push	eax
	push	esi
	mov	ecx, edi
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	esi, eax

; 10711: 
; 10712: 	ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iYield$[esp+48], esi
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	ebp, eax

; 10713: 
; 10714: 	// If we're not changing the improvement that's here, use the improvement that's here already
; 10715: 	if(eImprovement == NO_IMPROVEMENT)

	cmp	ebp, -1
	jne	SHORT $LN238@getYieldWi

; 10716: 	{
; 10717: 		if(!IsImprovementPillaged() || GC.getBuildInfo(eBuild)->isRepair())

	test	BYTE PTR [edi+461], 1
	je	SHORT $LN60@getYieldWi
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	test	al, al
	je	$LN52@getYieldWi
$LN60@getYieldWi:

; 10718: 		{
; 10719: 			eImprovement = getImprovementType();

	movsx	ebp, BYTE PTR [edi+441]

; 10720: 		}
; 10721: 	}
; 10722: 
; 10723: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IMPROVEMENT_WITH_ROUTE
; 10724: 	RouteTypes eRoute = (RouteTypes)GC.getBuildInfo(eBuild)->getRoute();
; 10725: 
; 10726: 	// If we're not changing the route that's here, use the route that's here already
; 10727: 	if (eRoute == NO_ROUTE)
; 10728: 	{
; 10729: 		if (!IsRoutePillaged() || GC.getBuildInfo(eBuild)->isRepair())
; 10730: 		{
; 10731: 			eRoute = getRouteType();
; 10732: 		}
; 10733: 	}
; 10734: 
; 10735: 	if (eRoute != NO_ROUTE)
; 10736: 	{
; 10737: 		CvRouteInfo* pRouteInfo = GC.getRouteInfo(eRoute);
; 10738: 		if (pRouteInfo)
; 10739: 			iYield += pRouteInfo->getYieldChange(eYield);
; 10740: 	}
; 10741: #endif
; 10742: 
; 10743: 	if(eImprovement != NO_IMPROVEMENT)

	cmp	ebp, -1
	je	$LN52@getYieldWi
$LN238@getYieldWi:

; 10744: 	{
; 10745: 		if(bWithUpgrade)

	cmp	BYTE PTR _bWithUpgrade$[esp+40], 0
	je	SHORT $LN53@getYieldWi

; 10746: 		{
; 10747: 			//in the case that improvements upgrade, use 2 upgrade levels higher for the
; 10748: 			//yield calculations.
; 10749: 			ImprovementTypes eUpgradeImprovement = (ImprovementTypes)GC.getImprovementInfo(eImprovement)->GetImprovementUpgrade();

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	mov	ebx, eax

; 10750: 			if(eUpgradeImprovement != NO_IMPROVEMENT)

	cmp	ebx, -1
	je	SHORT $LN53@getYieldWi

; 10751: 			{
; 10752: 				//unless it's trade on a low food tile, in which case only use 1 level higher
; 10753: 				if((eYield != YIELD_GOLD) || (getYield(YIELD_FOOD) >= GC.getFOOD_CONSUMPTION_PER_POPULATION()))

	cmp	DWORD PTR _eYield$[esp+40], 2
	jne	SHORT $LN55@getYieldWi
	mov	edx, DWORD PTR [edi+144]
	movsx	eax, WORD PTR [edx]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6328
	jl	SHORT $LN54@getYieldWi
$LN55@getYieldWi:

; 10754: 				{
; 10755: 					ImprovementTypes eUpgradeImprovement2 = (ImprovementTypes)GC.getImprovementInfo(eUpgradeImprovement)->GetImprovementUpgrade();

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade

; 10756: 					if(eUpgradeImprovement2 != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN54@getYieldWi

; 10757: 					{
; 10758: 						eUpgradeImprovement = eUpgradeImprovement2;

	mov	ebx, eax
$LN54@getYieldWi:

; 10759: 					}
; 10760: 				}
; 10761: 			}
; 10762: 
; 10763: 			if((eUpgradeImprovement != NO_IMPROVEMENT) && (eUpgradeImprovement != eImprovement))

	cmp	ebx, -1
	je	SHORT $LN53@getYieldWi
	cmp	ebx, ebp
	je	SHORT $LN53@getYieldWi

; 10764: 			{
; 10765: 				eImprovement = eUpgradeImprovement;

	mov	ebp, ebx
$LN53@getYieldWi:

; 10766: 			}
; 10767: 		}
; 10768: 
; 10769: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IMPROVEMENT_WITH_ROUTE
; 10770: 		iYield += calculateImprovementYieldChange(eImprovement, eYield, ePlayer, false, eRoute);
; 10771: #else
; 10772: 		iYield += calculateImprovementYieldChange(eImprovement, eYield, ePlayer, false);

	mov	ecx, DWORD PTR _ePlayer$[esp+40]
	mov	ebx, DWORD PTR _eYield$[esp+40]
	push	2
	push	0
	push	ecx
	push	ebx
	push	ebp
	mov	ecx, edi
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi

; 10773: #endif
; 10774: 
; 10775: 		if (eYield == YIELD_CULTURE && getOwner() != NO_PLAYER)

	cmp	ebx, 4
	jne	SHORT $LN251@getYieldWi
	cmp	BYTE PTR [edi+4], -1
	je	SHORT $LN251@getYieldWi

; 10776: 		{
; 10777: 			CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ebx, eax

; 10778: 			if(pImprovement && pImprovement->GetYieldChange(YIELD_CULTURE) > 0)

	test	ebx, ebx
	je	SHORT $LN50@getYieldWi
	push	4
	mov	ecx, ebx
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN50@getYieldWi

; 10779: 			{
; 10780: 				int iAdjacentCulture = pImprovement->GetCultureAdjacentSameType();

	mov	ecx, ebx
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType

; 10781: 				if(iAdjacentCulture > 0)

	test	eax, eax
	jle	SHORT $LN50@getYieldWi

; 10782: 				{
; 10783: 					iYield += ComputeCultureFromAdjacentImprovement(*pImprovement, eImprovement);

	push	ebp
	push	ebx
	mov	ecx, edi
	call	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
	add	esi, eax
$LN50@getYieldWi:

; 10784: 				}
; 10785: 			}
; 10786: 
; 10787: 			iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_CULTURE_FROM_IMPROVEMENTS);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	10					; 0000000aH
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier

; 10788: 			iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetImprovementCultureChange(eImprovement);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	add	esi, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ; CvPlayerPolicies::GetImprovementCultureChange
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN251@getYieldWi:
	mov	ebx, DWORD PTR _eBuild$[esp+40]
$LN52@getYieldWi:

; 10789: 		}
; 10790: 	}
; 10791: 
; 10792: #ifndef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IMPROVEMENT_WITH_ROUTE
; 10793: 	RouteTypes eRoute = (RouteTypes)GC.getBuildInfo(eBuild)->getRoute();

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eRoute$[esp+44], eax

; 10794: 
; 10795: 	// If we're not changing the route that's here, use the route that's here already
; 10796: 	if(eRoute == NO_ROUTE)

	cmp	eax, -1
	jne	SHORT $LN237@getYieldWi

; 10797: 	{
; 10798: 		if(!IsRoutePillaged() || GC.getBuildInfo(eBuild)->isRepair())

	test	BYTE PTR [edi+461], 2
	je	SHORT $LN47@getYieldWi
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	test	al, al
	je	SHORT $LN241@getYieldWi
$LN47@getYieldWi:

; 10799: 		{
; 10800: 			eRoute = getRouteType();

	movsx	eax, BYTE PTR [edi+447]
	mov	DWORD PTR _eRoute$[esp+44], eax

; 10801: 		}
; 10802: 	}
; 10803: 
; 10804: 	if(eRoute != NO_ROUTE)

	cmp	eax, -1
	je	SHORT $LN241@getYieldWi
$LN237@getYieldWi:

; 10805: 	{
; 10806: 		eImprovement = getImprovementType();

	movsx	ebx, BYTE PTR [edi+441]

; 10807: 		if(eImprovement != NO_IMPROVEMENT)

	cmp	ebx, -1
	je	SHORT $LN241@getYieldWi

; 10808: 		{
; 10809: 			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)

	xor	ebp, ebp
$LL44@getYieldWi:

; 10810: 			{
; 10811: 				iYield += GC.getImprovementInfo(eImprovement)->GetRouteYieldChanges(eRoute, iI);

	mov	edx, DWORD PTR _eRoute$[esp+44]
	push	ebp
	push	edx
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	add	esi, eax

; 10812: 				if(getRouteType() != NO_ROUTE)

	mov	al, BYTE PTR [edi+447]
	cmp	al, -1
	je	SHORT $LN43@getYieldWi

; 10813: 				{
; 10814: 					iYield -= GC.getImprovementInfo(eImprovement)->GetRouteYieldChanges(getRouteType(), iI);

	movsx	eax, al
	push	ebp
	push	eax
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	sub	esi, eax
$LN43@getYieldWi:
	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL44@getYieldWi

; 10810: 			{
; 10811: 				iYield += GC.getImprovementInfo(eImprovement)->GetRouteYieldChanges(eRoute, iI);

	mov	DWORD PTR _iYield$[esp+44], esi
$LN241@getYieldWi:

; 10815: 				}
; 10816: 			}
; 10817: 		}
; 10818: 	}
; 10819: #endif
; 10820: 
; 10821: #ifndef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IGNORE_FEATURE_EXTENDS_TO_CITY
; 10822: 	CvCity* pCity = getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN133@getYieldWi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN133@getYieldWi
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebp, eax
	mov	DWORD PTR _pCity$[esp+44], ebp
	jmp	SHORT $LN134@getYieldWi
$LN133@getYieldWi:
	mov	DWORD PTR _pCity$[esp+44], 0
	mov	ebp, DWORD PTR _pCity$[esp+44]
$LN134@getYieldWi:

; 10823: #endif
; 10824: 
; 10825: 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[esp+40], -1
	je	$LN246@getYieldWi

; 10826: 	{
; 10827: 		// City plot yield
; 10828: 		if(pCity != NULL)

	test	ebp, ebp
	je	SHORT $LN242@getYieldWi

; 10829: 		{
; 10830: 			if(pCity->isRevealed(eTeam, false))

	mov	edx, DWORD PTR $T243441[esp+44]
	push	0
	push	edx
	mov	ecx, ebp
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN242@getYieldWi

; 10831: 			{
; 10832: 				iYield += kYield.getCityChange();

	mov	ebx, DWORD PTR _kYield$[esp+44]
	mov	ecx, ebx
	call	?getCityChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getCityChange
	add	esi, eax

; 10833: 
; 10834: 				if(kYield.getPopulationChangeDivisor() != 0)

	mov	ecx, ebx
	mov	DWORD PTR _iYield$[esp+44], esi
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	test	eax, eax
	je	SHORT $LN37@getYieldWi

; 10835: 					iYield += (pCity->getPopulation() + kYield.getPopulationChangeOffset()) / kYield.getPopulationChangeDivisor();

	mov	ecx, ebp
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ecx, ebx
	mov	ebp, eax
	call	?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeOffset
	mov	ecx, ebx
	add	ebp, eax
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	mov	ecx, eax
	mov	eax, ebp
	cdq
	idiv	ecx
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN37@getYieldWi:

; 10836: 
; 10837: 				bCity = true;

	mov	BYTE PTR _bCity$[esp+44], 1
$LN242@getYieldWi:

; 10838: 			}
; 10839: 		}
; 10840: 
; 10841: 		CvCity* pWorkingCity = getWorkingCity();

	mov	edx, DWORD PTR [edi+116]
	mov	eax, DWORD PTR [edi+112]
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 10842: 
; 10843: 		// Water plots
; 10844: 		if(isWater())

	cmp	BYTE PTR [edi+5], 3
	mov	ebp, eax
	jne	$LN244@getYieldWi

; 10845: 		{
; 10846: 			if(!isImpassable() && !isMountain())

	test	BYTE PTR [edi+462], 128			; 00000080H
	jne	$LN244@getYieldWi

; 10847: 			{
; 10848: 				// Player sea plot yield
; 10849: 				iYield += GET_PLAYER(ePlayer).getSeaPlotYield(eYield);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR tv928[esp+44]
	mov	ebx, DWORD PTR _eYield$[esp+40]
	add	ecx, edx
	push	ebx
	call	?getSeaPlotYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getSeaPlotYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi

; 10850: 
; 10851: 				if(pWorkingCity != NULL)

	test	ebp, ebp
	je	SHORT $LN33@getYieldWi

; 10852: 				{
; 10853: 					if(pWorkingCity->isRevealed(eTeam, false))

	mov	eax, DWORD PTR $T243441[esp+44]
	push	0
	push	eax
	mov	ecx, ebp
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN33@getYieldWi

; 10854: 					{
; 10855: 						int iCityYield;
; 10856: 
; 10857: 						// Worked lake plot
; 10858: 						if(pWorkingCity->getLakePlotYield(eYield) > 0 && isLake())

	push	ebx
	mov	ecx, ebp
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield
	test	eax, eax
	jle	SHORT $LN32@getYieldWi
	mov	ecx, edi
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	test	al, al
	je	SHORT $LN32@getYieldWi

; 10859: 							iCityYield = pWorkingCity->getLakePlotYield(eYield);

	push	ebx
	mov	ecx, ebp
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield

; 10860: 						// Worked sea plot
; 10861: 						else

	jmp	SHORT $LN31@getYieldWi
$LN32@getYieldWi:

; 10862: 							iCityYield = pWorkingCity->getSeaPlotYield(eYield);

	push	ebx
	mov	ecx, ebp
	call	?getSeaPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaPlotYield
$LN31@getYieldWi:

; 10863: 
; 10864: 						iYield += iCityYield;

	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN33@getYieldWi:

; 10865: 					}
; 10866: 				}
; 10867: 
; 10868: 				// Worked water resources
; 10869: 				if(getResourceType(GET_PLAYER(ePlayer).getTeam()) != NO_RESOURCE)

	mov	edx, DWORD PTR tv928[esp+44]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN247@getYieldWi

; 10870: 				{
; 10871: 					if(pWorkingCity != NULL)

	test	ebp, ebp
	je	SHORT $LN247@getYieldWi

; 10872: 					{
; 10873: 						if(pWorkingCity->isRevealed(eTeam, false))

	mov	eax, DWORD PTR $T243441[esp+44]
	push	0
	push	eax
	mov	ecx, ebp
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN247@getYieldWi

; 10874: 							iYield += pWorkingCity->getSeaResourceYield(eYield);

	push	ebx
	mov	ecx, ebp
	call	?getSeaResourceYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaResourceYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
	jmp	SHORT $LN247@getYieldWi
$LN244@getYieldWi:
	mov	ebx, DWORD PTR _eYield$[esp+40]
$LN247@getYieldWi:

; 10875: 					}
; 10876: 				}
; 10877: 
; 10878: 			}
; 10879: 		}
; 10880: 
; 10881: 		// Worked river plot
; 10882: 		if(isRiver())

	cmp	BYTE PTR [edi+457], 0
	jle	SHORT $LN248@getYieldWi

; 10883: 		{
; 10884: 			if(!isImpassable() && !isMountain())

	test	BYTE PTR [edi+462], 128			; 00000080H
	jne	SHORT $LN248@getYieldWi
	cmp	BYTE PTR [edi+5], 0
	je	SHORT $LN248@getYieldWi

; 10885: 			{
; 10886: 				if(NULL != pWorkingCity)

	test	ebp, ebp
	je	SHORT $LN248@getYieldWi

; 10887: 				{
; 10888: 					if(pWorkingCity->isRevealed(eTeam, false))

	mov	ecx, DWORD PTR $T243441[esp+44]
	push	0
	push	ecx
	mov	ecx, ebp
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN248@getYieldWi

; 10889: 					{
; 10890: 						iYield += pWorkingCity->getRiverPlotYield(eYield);

	push	ebx
	mov	ecx, ebp
	call	?getRiverPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getRiverPlotYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN248@getYieldWi:

; 10891: 					}
; 10892: 				}
; 10893: 			}
; 10894: 		}
; 10895: 
; 10896: #ifdef NQ_ALLOW_BUILDING_HILL_YIELD_CHANGES
; 10897: 		if (isHills())

	cmp	BYTE PTR [edi+5], 1
	jne	SHORT $LN22@getYieldWi

; 10898: 		{
; 10899: 			if (NULL != pWorkingCity)

	test	ebp, ebp
	je	SHORT $LN22@getYieldWi

; 10900: 			{
; 10901: 				iYield += pWorkingCity->getHillYieldChangesFromBuildings(eYield);

	push	ebx
	mov	ecx, ebp
	call	?getHillYieldChangesFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getHillYieldChangesFromBuildings
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN22@getYieldWi:

; 10902: 			}
; 10903: 		}
; 10904: #endif
; 10905: 
; 10906: 		// Worked Feature extra yield (e.g. University bonus)
; 10907: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IGNORE_FEATURE_EXTENDS_TO_CITY
; 10908: 		if (getFeatureType() != NO_FEATURE && !bIgnoreFeature)
; 10909: #else
; 10910: 		if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	SHORT $LN20@getYieldWi

; 10911: #endif
; 10912: 		{
; 10913: 			if(pWorkingCity != NULL)

	test	ebp, ebp
	je	SHORT $LN20@getYieldWi

; 10914: 				iYield += pWorkingCity->GetFeatureExtraYield(getFeatureType(), eYield);

	movsx	edx, al
	push	ebx
	push	edx
	mov	ecx, ebp
	call	?GetFeatureExtraYield@CvCity@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvCity::GetFeatureExtraYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN20@getYieldWi:

; 10915: 		}
; 10916: 
; 10917: 
; 10918: 		// Extra yield for terrain
; 10919: 		if(getTerrainType() != NO_TERRAIN)

	mov	al, BYTE PTR [edi+6]
	cmp	al, -1
	je	SHORT $LN18@getYieldWi

; 10920: 		{
; 10921: 			if(pWorkingCity != NULL && !isImpassable() && !isMountain())

	test	ebp, ebp
	je	SHORT $LN18@getYieldWi
	test	BYTE PTR [edi+462], 128			; 00000080H
	jne	SHORT $LN18@getYieldWi
	cmp	BYTE PTR [edi+5], 0
	je	SHORT $LN18@getYieldWi

; 10922: 			{
; 10923: 				iYield += pWorkingCity->GetTerrainExtraYield(getTerrainType(), eYield);

	movsx	eax, al
	push	ebx
	push	eax
	mov	ecx, ebp
	call	?GetTerrainExtraYield@CvCity@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ; CvCity::GetTerrainExtraYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN18@getYieldWi:

; 10924: 			}
; 10925: 		}
; 10926: 
; 10927: 		ResourceTypes eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv928[esp+44]
	mov	eax, DWORD PTR [ecx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN180@getYieldWi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN181@getYieldWi
$LN180@getYieldWi:
	or	eax, -1
$LN181@getYieldWi:
	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$227239[esp+44], eax

; 10928: 		if(eResource != NO_RESOURCE)

	cmp	eax, -1
	je	$LN245@getYieldWi

; 10929: 		{
; 10930: 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	edx, eax
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$227241[esp+40], eax

; 10931: 			if(pkResourceInfo != NULL && eTeam != NO_TEAM && GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes) pkResourceInfo->getTechReveal()))

	test	eax, eax
	je	$LN245@getYieldWi
	cmp	DWORD PTR $T243441[esp+44], -1
	je	$LN245@getYieldWi
	mov	eax, DWORD PTR $T243441[esp+44]
	mov	ecx, DWORD PTR _pkResourceInfo$227241[esp+40]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243664[esp+44], eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	mov	ecx, DWORD PTR $T243664[esp+44]
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN245@getYieldWi

; 10932: 			{
; 10933: 				if (pkResourceInfo->getPolicyReveal() == NO_POLICY || GET_PLAYER(ePlayer).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkResourceInfo->getPolicyReveal()))

	mov	ecx, DWORD PTR _pkResourceInfo$227241[esp+40]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	cmp	eax, -1
	je	SHORT $LN14@getYieldWi
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv928[esp+44]
	add	ecx, eax
	mov	DWORD PTR $T243668[esp+44], ecx
	mov	ecx, DWORD PTR _pkResourceInfo$227241[esp+40]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	mov	ecx, DWORD PTR $T243668[esp+44]
	push	eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	je	SHORT $LN245@getYieldWi
$LN14@getYieldWi:

; 10934: 				{
; 10935: 					// Extra yield from resources
; 10936: 					if(pWorkingCity != NULL)

	test	ebp, ebp
	je	SHORT $LN13@getYieldWi

; 10937: 						iYield += pWorkingCity->GetResourceExtraYield(eResource, eYield);

	mov	edx, DWORD PTR _eResource$227239[esp+44]
	push	ebx
	push	edx
	mov	ecx, ebp
	call	?GetResourceExtraYield@CvCity@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvCity::GetResourceExtraYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN13@getYieldWi:

; 10938: 
; 10939: 					// Extra yield from Resources with Trait
; 10940: 					if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ebp, DWORD PTR _pkResourceInfo$227241[esp+40]
	mov	ecx, ebp
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN12@getYieldWi

; 10941: 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeStrategicResources(eYield);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv928[esp+44]
	add	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	esi, DWORD PTR [eax+ebx*4+424]
	jmp	SHORT $LN252@getYieldWi
$LN12@getYieldWi:

; 10942: 					// NQMP GJS - New Netherlands UA BEGIN
; 10943: 					else if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, ebp
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN245@getYieldWi

; 10944: 					{
; 10945: 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeLuxuryResources(eYield);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR tv928[esp+44]
	lea	ecx, DWORD PTR [eax+edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	esi, DWORD PTR [eax+ebx*4+448]
$LN252@getYieldWi:
	mov	DWORD PTR _iYield$[esp+44], esi
$LN245@getYieldWi:

; 10946: 					}
; 10947: 					// NQMP GJS - New Netherlands UA END
; 10948: 				}
; 10949: 			}
; 10950: 		}
; 10951: 	}
; 10952: 
; 10953: 	if(bCity)

	cmp	BYTE PTR _bCity$[esp+44], 0
	je	$LN250@getYieldWi

; 10954: 	{
; 10955: #ifdef AUI_PLOT_FIX_CITY_YIELD_CHANGE_RELOCATED
; 10956: 		iYield = MAX(iYield, kYield.getMinCity());
; 10957: #else
; 10958: 		iYield = std::max(iYield, kYield.getMinCity());

	mov	ecx, DWORD PTR _kYield$[esp+44]
	call	?getMinCity@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getMinCity
	mov	DWORD PTR $T243422[esp+40], eax
	cmp	esi, eax
	lea	eax, DWORD PTR $T243422[esp+40]
	jl	SHORT $LN200@getYieldWi
	lea	eax, DWORD PTR _iYield$[esp+44]
$LN200@getYieldWi:

; 10959: 
; 10960: 		// Mod for Player; used for Policies and such
; 10961: 		int iTemp = GET_PLAYER(getOwner()).GetCityYieldChange(eYield);	// In hundreds - will be added to capitalYieldChange below

	movsx	ecx, BYTE PTR [edi+4]
	mov	esi, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	call	?GetCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCityYieldChange

; 10962: 
; 10963: 		// Coastal City Mod
; 10964: 		if(pCity->isCoastal())

	mov	ebp, DWORD PTR _pCity$[esp+44]
	push	-1
	mov	ecx, ebp
	mov	DWORD PTR _iTemp$227253[esp+44], eax
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN8@getYieldWi

; 10965: 		{
; 10966: 			iYield += GET_PLAYER(getOwner()).GetCoastalCityYieldChange(eYield);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	call	?GetCoastalCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCoastalCityYieldChange
	add	esi, eax
$LN8@getYieldWi:

; 10967: 		}
; 10968: 
; 10969: 		// Capital Mod
; 10970: 		if(pCity->isCapital())

	mov	ecx, ebp
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN7@getYieldWi

; 10971: 		{
; 10972: 			iTemp += GET_PLAYER(getOwner()).GetCapitalYieldChange(eYield);

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	call	?GetCapitalYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldChange

; 10973: 
; 10974: 			int iPerPopYield = pCity->getPopulation() * GET_PLAYER(getOwner()).GetCapitalYieldPerPopChange(eYield);

	movsx	ecx, BYTE PTR [edi+4]
	add	DWORD PTR _iTemp$227253[esp+40], eax
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	call	?GetCapitalYieldPerPopChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldPerPopChange
	mov	ecx, DWORD PTR _pCity$[esp+44]
	mov	ebp, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	ebp, eax

; 10975: 			iPerPopYield /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ebp
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 10976: 			iYield += iPerPopYield;

	add	esi, ecx
$LN7@getYieldWi:

; 10977: 		}
; 10978: 
; 10979: 		iYield += (iTemp / 100);

	mov	eax, 1374389535				; 51eb851fH
	imul	DWORD PTR _iTemp$227253[esp+40]
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	esi, eax
	jmp	SHORT $LN250@getYieldWi
$LN246@getYieldWi:
	mov	ebx, DWORD PTR _eYield$[esp+40]
$LN250@getYieldWi:

; 10980: #endif
; 10981: 	}
; 10982: 
; 10983: 	iYield += GC.getGame().getPlotExtraYield(m_iX, m_iY, eYield);

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	mov	ebp, DWORD PTR tv928[esp+44]
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edx
	call	?getPlotExtraYield@CvGame@@QBEHHHW4YieldTypes@@@Z ; CvGame::getPlotExtraYield
	add	esi, eax

; 10984: 
; 10985: 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[esp+40], -1
	mov	DWORD PTR _iYield$[esp+44], esi
	je	$LN1@getYieldWi

; 10986: 	{
; 10987: 		if(GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield) > 0)

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+ebp]
	push	ebx
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	test	eax, eax
	jle	SHORT $LN4@getYieldWi

; 10988: 		{
; 10989: 			if(iYield >= GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	push	ebx
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	cmp	esi, eax
	jl	SHORT $LN4@getYieldWi

; 10990: 			{
; 10991: 				iYield += GC.getEXTRA_YIELD();

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6608
	mov	DWORD PTR _iYield$[esp+44], esi
$LN4@getYieldWi:

; 10992: 			}
; 10993: 		}
; 10994: 
; 10995: 		if(GET_PLAYER(ePlayer).isGoldenAge())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	test	al, al
	je	SHORT $LN1@getYieldWi

; 10996: 		{
; 10997: 			if(iYield >= kYield.getGoldenAgeYieldThreshold())

	mov	ecx, DWORD PTR _kYield$[esp+44]
	call	?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getGoldenAgeYieldThreshold
	cmp	esi, eax
	jl	SHORT $LN2@getYieldWi

; 10998: 			{
; 10999: 				iYield += kYield.getGoldenAgeYield();

	mov	ecx, DWORD PTR _kYield$[esp+44]
	call	?getGoldenAgeYield@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getGoldenAgeYield
	add	esi, eax
	mov	DWORD PTR _iYield$[esp+44], esi
$LN2@getYieldWi:

; 11000: 			}
; 11001: #ifdef NQ_GOLDEN_PILGRIMAGE
; 11002: 			// this is super hacky, I am a bad person and I should feel bad...
; 11003: 			if (eYield == YIELD_FAITH && getYieldWithBuild(eBuild, YIELD_GOLD, bWithUpgrade, ePlayer) > 0)

	cmp	ebx, 5
	jne	SHORT $LN1@getYieldWi
	mov	eax, DWORD PTR _ePlayer$[esp+40]
	mov	ecx, DWORD PTR _bWithUpgrade$[esp+40]
	mov	edx, DWORD PTR _eBuild$[esp+40]
	push	eax
	push	ecx
	push	2
	push	edx
	mov	ecx, edi
	call	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
	test	eax, eax
	jle	SHORT $LN1@getYieldWi

; 11004: 			{
; 11005: 				iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetGoldenAgeTileBonusFaith();

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	add	esi, DWORD PTR [eax+132]
	mov	DWORD PTR _iYield$[esp+44], esi
$LN1@getYieldWi:
	pop	ebp

; 11006: 			}
; 11007: //int CvPlot::getYieldWithBuild(BuildTypes eBuild, YieldTypes eYield, bool bWithUpgrade, PlayerTypes ePlayer) const
; 11008: #endif
; 11009: 		}
; 11010: 	}
; 11011: 
; 11012: 	return std::max(0, iYield);

	mov	DWORD PTR $T243423[esp+36], 0
	pop	ebx
	lea	eax, DWORD PTR _iYield$[esp+36]
	test	esi, esi
	jg	SHORT $LN234@getYieldWi
	lea	eax, DWORD PTR $T243423[esp+32]
$LN234@getYieldWi:
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi

; 11013: }

	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ENDP ; CvPlot::getYieldWithBuild
_TEXT	ENDS
PUBLIC	?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z	; CvPlot::canTrain
EXTRN	?GetMinAreaSize@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetMinAreaSize
EXTRN	?getNumTotalResources@CvArea@@QBEHXZ:PROC	; CvArea::getNumTotalResources
EXTRN	?IsPrereqResources@CvUnitEntry@@QBE_NXZ:PROC	; CvUnitEntry::IsPrereqResources
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
; Function compile flags: /Ogtpy
;	COMDAT ?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z
_TEXT	SEGMENT
_eUnit$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z PROC		; CvPlot::canTrain, COMDAT
; _this$ = ecx

; 11018: 	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[esp-4]
	push	ebp
	push	esi
	mov	esi, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ebp, eax

; 11019: 	if(pkUnitInfo == NULL)

	test	ebp, ebp
	jne	SHORT $LN25@canTrain
	pop	esi

; 11020: 	{
; 11021: 		return false;

	xor	al, al
	pop	ebp

; 11109: }

	ret	12					; 0000000cH
$LN25@canTrain:
	push	ebx
	push	edi

; 11022: 	}
; 11023: 
; 11024: 	CvUnitEntry& thisUnitEntry = *pkUnitInfo;
; 11025: 	DomainTypes thisUnitDomain = (DomainTypes) thisUnitEntry.GetDomainType();

	mov	ecx, ebp
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType

; 11026: 
; 11027: 	if(thisUnitEntry.IsPrereqResources())

	mov	ecx, ebp
	mov	ebx, eax
	call	?IsPrereqResources@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsPrereqResources
	test	al, al
	je	SHORT $LN73@canTrain

; 11028: 	{
; 11029: 		if(thisUnitDomain == DOMAIN_SEA)

	test	ebx, ebx
	jne	SHORT $LN23@canTrain

; 11030: 		{
; 11031: 			bool bValid = false;
; 11032: 
; 11033: 			for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	edi, edi
	npad	4
$LL22@canTrain:

; 11034: 			{
; 11035: 				CvPlot* pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	edi
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 11036: 
; 11037: 				if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN21@canTrain

; 11038: 				{
; 11039: 					if(pLoopPlot->isWater())

	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN21@canTrain

; 11040: 					{
; 11041: 						if(pLoopPlot->area()->getNumTotalResources() > 0)

	mov	eax, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTotalResources@CvArea@@QBEHXZ	; CvArea::getNumTotalResources
	test	eax, eax
	jg	SHORT $LN73@canTrain
$LN21@canTrain:

; 11030: 		{
; 11031: 			bool bValid = false;
; 11032: 
; 11033: 			for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL22@canTrain
$LN3@canTrain:
	pop	edi
	pop	ebx
	pop	esi

; 11100: 			}
; 11101: 		}
; 11102: 		else
; 11103: 		{
; 11104: 			return false;

	xor	al, al
	pop	ebp

; 11109: }

	ret	12					; 0000000cH
$LN23@canTrain:

; 11042: 						{
; 11043: 							bValid = true;
; 11044: 							break;
; 11045: 						}
; 11046: 					}
; 11047: 				}
; 11048: 			}
; 11049: 
; 11050: 			if(!bValid)
; 11051: 			{
; 11052: 				return false;
; 11053: 			}
; 11054: 		}
; 11055: 		else
; 11056: 		{
; 11057: 			if(area()->getNumTotalResources() > 0)

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTotalResources@CvArea@@QBEHXZ	; CvArea::getNumTotalResources
	test	eax, eax

; 11058: 			{
; 11059: 				return false;

	jg	SHORT $LN3@canTrain
$LN73@canTrain:

; 11060: 			}
; 11061: 		}
; 11062: 	}
; 11063: 
; 11064: 	if(isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN13@canTrain
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN13@canTrain
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN13@canTrain

; 11065: 	{
; 11066: 		if(thisUnitDomain == DOMAIN_SEA)

	test	ebx, ebx
	jne	SHORT $LN12@canTrain

; 11067: 		{
; 11068: 			if(!isWater() && !isCoastalLand(thisUnitEntry.GetMinAreaSize()))

	cmp	BYTE PTR [esi+5], 3
	je	$LN2@canTrain
	mov	ecx, ebp
	call	?GetMinAreaSize@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetMinAreaSize
	push	eax
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	jne	$LN2@canTrain
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 11109: }

	ret	12					; 0000000cH
$LN12@canTrain:

; 11069: 			{
; 11070: 				return false;
; 11071: 			}
; 11072: 		}
; 11073: 		else
; 11074: 		{
; 11075: 			if(area()->getNumTiles() < thisUnitEntry.GetMinAreaSize())

	mov	esi, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	ecx, ebp
	mov	esi, eax
	call	?GetMinAreaSize@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetMinAreaSize
	cmp	esi, eax
	jge	SHORT $LN2@canTrain
	pop	edi
	pop	ebx
	pop	esi

; 11100: 			}
; 11101: 		}
; 11102: 		else
; 11103: 		{
; 11104: 			return false;

	xor	al, al
	pop	ebp

; 11109: }

	ret	12					; 0000000cH
$LN13@canTrain:

; 11076: 			{
; 11077: 				return false;
; 11078: 			}
; 11079: 		}
; 11080: 	}
; 11081: 	else
; 11082: 	{
; 11083: 		if(area()->getNumTiles() < thisUnitEntry.GetMinAreaSize())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	ecx, ebp
	mov	edi, eax
	call	?GetMinAreaSize@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetMinAreaSize
	cmp	edi, eax

; 11084: 		{
; 11085: 			return false;

	jl	$LN3@canTrain

; 11086: 		}
; 11087: 
; 11088: 		if(thisUnitDomain == DOMAIN_SEA)

	test	ebx, ebx
	jne	SHORT $LN6@canTrain

; 11089: 		{
; 11090: 			if(!isWater())

	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN2@canTrain
	pop	edi
	pop	ebx
	pop	esi

; 11100: 			}
; 11101: 		}
; 11102: 		else
; 11103: 		{
; 11104: 			return false;

	xor	al, al
	pop	ebp

; 11109: }

	ret	12					; 0000000cH
$LN6@canTrain:

; 11091: 			{
; 11092: 				return false;
; 11093: 			}
; 11094: 		}
; 11095: 		else if(thisUnitDomain == DOMAIN_LAND)

	cmp	ebx, 2
	jne	$LN3@canTrain

; 11096: 		{
; 11097: 			if(isWater())

	cmp	BYTE PTR [esi+5], 3

; 11098: 			{
; 11099: 				return false;

	je	$LN3@canTrain
$LN2@canTrain:
	pop	edi
	pop	ebx
	pop	esi

; 11105: 		}
; 11106: 	}
; 11107: 
; 11108: 	return true;

	mov	al, 1
	pop	ebp

; 11109: }

	ret	12					; 0000000cH
?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z ENDP		; CvPlot::canTrain
_TEXT	ENDS
PUBLIC	?GetPlotIndex@CvPlot@@QBEHXZ			; CvPlot::GetPlotIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetPlotIndex@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?GetPlotIndex@CvPlot@@QBEHXZ PROC			; CvPlot::GetPlotIndex, COMDAT
; _this$ = ecx

; 11202: 	return GC.getMap().plotNum(getX(),getY());

	movsx	eax, WORD PTR [ecx+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	eax, DWORD PTR [edx+4020]
	movsx	ecx, WORD PTR [ecx]
	add	eax, ecx

; 11203: }

	ret	0
?GetPlotIndex@CvPlot@@QBEHXZ ENDP			; CvPlot::GetPlotIndex
_TEXT	ENDS
PUBLIC	?updateImpassable@CvPlot@@IAEXXZ		; CvPlot::updateImpassable
EXTRN	?isImpassable@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isImpassable
EXTRN	?isImpassable@CvTerrainInfo@@QBE_NXZ:PROC	; CvTerrainInfo::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?updateImpassable@CvPlot@@IAEXXZ
_TEXT	SEGMENT
?updateImpassable@CvPlot@@IAEXXZ PROC			; CvPlot::updateImpassable, COMDAT
; _this$ = ecx

; 11388: {

	push	esi
	mov	esi, ecx

; 11389: 	const TerrainTypes eTerrain = getTerrainType();

	movsx	eax, BYTE PTR [esi+6]

; 11390: 	const FeatureTypes eFeature = getFeatureType();
; 11391: 
; 11392: 	m_bIsImpassable = false;

	and	BYTE PTR [esi+462], 127			; 0000007fH
	movsx	ecx, BYTE PTR [esi+432]

; 11393: 
; 11394: 	if(eTerrain != NO_TERRAIN)

	cmp	eax, -1
	je	SHORT $LN1@updateImpa

; 11395: 	{
; 11396: 		if(eFeature == NO_FEATURE)

	cmp	ecx, -1
	jne	SHORT $LN4@updateImpa

; 11397: 		{
; 11398: 			CvTerrainInfo* pkTerrainInfo = GC.getTerrainInfo(eTerrain);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo

; 11399: 			if(pkTerrainInfo)

	test	eax, eax
	je	SHORT $LN1@updateImpa

; 11400: 				m_bIsImpassable = pkTerrainInfo->isImpassable();

	mov	ecx, eax
	call	?isImpassable@CvTerrainInfo@@QBE_NXZ	; CvTerrainInfo::isImpassable
	mov	cl, BYTE PTR [esi+462]
	shl	al, 7
	and	cl, 127					; 0000007fH
	or	al, cl

; 11406: 				m_bIsImpassable = pkFeatureInfo->isImpassable();

	mov	BYTE PTR [esi+462], al
	pop	esi

; 11407: 		}
; 11408: 	}
; 11409: }

	ret	0
$LN4@updateImpa:

; 11401: 		}
; 11402: 		else
; 11403: 		{
; 11404: 			CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo(eFeature);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo

; 11405: 			if(pkFeatureInfo)

	test	eax, eax
	je	SHORT $LN1@updateImpa

; 11406: 				m_bIsImpassable = pkFeatureInfo->isImpassable();

	mov	ecx, eax
	call	?isImpassable@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isImpassable
	mov	dl, BYTE PTR [esi+462]
	shl	al, 7
	and	dl, 127					; 0000007fH
	or	al, dl
	mov	BYTE PTR [esi+462], al
$LN1@updateImpa:
	pop	esi

; 11407: 		}
; 11408: 	}
; 11409: }

	ret	0
?updateImpassable@CvPlot@@IAEXXZ ENDP			; CvPlot::updateImpassable
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::end
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Eiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 474  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 475  : 			++(*(const_iterator *)this);

	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc

; 476  : 			return (*this);

	mov	eax, esi
	pop	esi

; 477  : 			}

	ret	0
??Eiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN31@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 1000				; 000003e8H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 1000			; 000003e8H
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+4012], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize
_TEXT	ENDS
PUBLIC	?equal_range@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::equal_range
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::equal_range, COMDAT
; _this$ = ecx

; 1024 : 		return (_Eqrange(_Keyval));

	mov	eax, DWORD PTR __Keyval$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	push	eax
	push	esi
	call	?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange
	mov	eax, esi
	pop	esi

; 1025 : 		}

	ret	8
?equal_range@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::equal_range
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 76695844				; 04924924H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buy
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::resize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN4@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::resize
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,25,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+212], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,50,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,50,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
	npad	6
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN31@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 50					; 00000032H
	jbe	SHORT $LN15@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@3
$LN15@GrowSize@3:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 50			; 00000032H
$LN14@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+412], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,50,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z PROC ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize@4
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize@4:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize@4
	npad	1
$LL10@GrowSize@4:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN35@GrowSize@4

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@4

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@4
$LN35@GrowSize@4:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize@4:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize@4
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize@4

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebx
	call	_memcpy

; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 16					; 00000010H
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@4:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z ENDP ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
__Erasednode$ = -84					; size = 4
$T244210 = -80						; size = 28
$T244209 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	sub	esp, 72					; 00000048H
	cmp	BYTE PTR [eax+17], 0
	push	ebp
	mov	ebp, ecx
	je	SHORT $LN40@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T244210[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T244209[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T244210[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T244209[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T244209[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T244209[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T244209[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN293@erase:
$LN40@erase:
	push	ebx
	push	esi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	mov	ebx, eax
	push	edi

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	DWORD PTR __Erasednode$[esp+100], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LN39@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN288@erase
$LN39@erase:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [edx+17], 0
	je	SHORT $LN37@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN288@erase
$LN37@erase:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebx
	jne	SHORT $LN35@erase
$LN288@erase:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+17], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN34@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN33@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase
$LN33@erase:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN31@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase
$LN31@erase:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR __Erasednode$[esp+100]
	jne	SHORT $LN29@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+17], 0
	je	SHORT $LN43@erase
	mov	eax, esi
	jmp	SHORT $LN44@erase
$LN43@erase:
	push	edi
	call	?_Min@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Min
	add	esp, 4
$LN44@erase:
	mov	DWORD PTR [ebx], eax
$LN29@erase:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR __Erasednode$[esp+100]
	cmp	DWORD PTR [ebx+8], ecx
	jne	SHORT $LN173@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+17], 0
	je	SHORT $LN45@erase
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN45@erase:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase
$LN35@erase:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebx+8]
	jne	SHORT $LN26@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase
$LN26@erase:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+17], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+4], ebx
	jne	SHORT $LN23@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase
$LN23@erase:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx], ebx
	jne	SHORT $LN21@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase
$LN21@erase:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebx+16]
	add	eax, 16					; 00000010H
	cmp	eax, ecx
	je	SHORT $LN173@erase
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	edx, DWORD PTR __Erasednode$[esp+100]
	mov	bl, 1
	cmp	BYTE PTR [edx+16], bl
	jne	$LN19@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN16@erase
	npad	6
$LL18@erase:
	cmp	BYTE PTR [edi+16], bl
	jne	$LN16@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+16], 0
	jne	SHORT $LN14@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+16], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+16], 0
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN14@erase:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+16], bl
	je	SHORT $LN292@erase
$LN11@erase:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN9@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+16], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+16], 0
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
$LN9@erase:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+16]
	mov	BYTE PTR [eax+16], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+16], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+16], bl
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN15@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+16], 0
	jne	SHORT $LN7@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+16], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [esi+16], 0
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN7@erase:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+17], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN291@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN4@erase
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+16], bl
	jne	SHORT $LN4@erase
$LN292@erase:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+16], 0
$LN291@erase:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ebp+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase
$LN4@erase:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+16], bl
	jne	SHORT $LN2@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+16], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	ecx, ebp
	mov	BYTE PTR [eax+16], 0
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
$LN2@erase:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	cl, BYTE PTR [esi+16]
	mov	BYTE PTR [eax+16], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+16], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR [edx+16], bl
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate
$LN16@erase:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+16], bl
$LN19@erase:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[esp+100]
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR [ebp+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ebp+8], eax
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN290@erase:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T244210[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T244209[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0
$LN4@Buynode:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+17], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+17], 0
	mov	edi, esi
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@2
	mov	DWORD PTR [eax], 0
$LN27@Buynode@2:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@2
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@2:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@2
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@2:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+16], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+17], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	??$_Distance2@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>, COMDAT

; 1858 : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $LN1@Distance2
	mov	edx, DWORD PTR __Off$[esp]
$LL12@Distance2:

; 1859 : 		++_Off;

	inc	DWORD PTR [edx]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN51@Distance2
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN48@Distance2
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN26@Distance2
	npad	4

; 1858 : 	for (; _First != _Last; ++_First)

$LL27@Distance2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL27@Distance2
	jmp	SHORT $LN26@Distance2
$LN48@Distance2:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN10@Distance2
$LL11@Distance2:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN10@Distance2
	mov	ecx, eax
	mov	DWORD PTR __First$[esp], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL11@Distance2
$LN10@Distance2:
	mov	ecx, eax
$LN26@Distance2:
	mov	DWORD PTR __First$[esp], ecx
$LN51@Distance2:
	cmp	ecx, esi
	jne	SHORT $LL12@Distance2
$LN1@Distance2:
	pop	esi

; 1860 : 	}

	ret	0
??$_Distance2@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@@Z ; std::_Destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@@Z PROC ; std::_Destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	jmp	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
??$_Destroy@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@@Z ENDP ; std::_Destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@5
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@5:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@5
	npad	6
$LL8@GrowSize@5:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@5

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@5

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@5
$LN31@GrowSize@5:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@5:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 8
	jbe	SHORT $LN15@GrowSize@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@5
$LN15@GrowSize@5:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 8
$LN14@GrowSize@5:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@5:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+76], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
_TEXT	ENDS
PUBLIC	??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator->, COMDAT
; _this$ = ecx

; 269  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 270  : 			}

	ret	0
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator->
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode@3
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0
$LN4@Buynode@3:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN32@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL6@lower_boun
$LN32@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$5
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
_TEXT	SEGMENT
$T245275 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR __Wherenode$[ebp], esi

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	DWORD PTR $T245275[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN4@Buynode@4
	mov	eax, DWORD PTR __Larg$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [esi+44], dl
	mov	BYTE PTR [esi+45], 0
$LN4@Buynode@4:

; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN35@Buynode@4:
$LN34@Buynode@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245275[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??$distance@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YAHV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0@Z ; std::distance<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$distance@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YAHV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YAHV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0@Z PROC ; std::distance<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> > >, COMDAT

; 1883 : 	typename iterator_traits<_InIt>::difference_type _Off = 0;
; 1884 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	eax, DWORD PTR __First$[esp-4]
	sar	eax, 2

; 1885 : 	return (_Off);
; 1886 : 	}

	ret	0
??$distance@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@@std@@YAHV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@0@Z ENDP ; std::distance<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode@5
	mov	DWORD PTR [eax], 0
$LN27@Buynode@5:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN37@Buynode@5:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@5
	mov	DWORD PTR [ecx], 0
$LN47@Buynode@5:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+44], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+45], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z ; std::_Find<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,FAutoVariableBase const *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z PROC ; std::_Find<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,FAutoVariableBase const *>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN19@Find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL7@Find:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN19@Find
	add	ecx, 4
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL7@Find
$LN19@Find:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z ENDP ; std::_Find<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,FAutoVariableBase const *>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 16					; 00000010H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?ClearPlotDeltas@FSerialization@@YAXXZ		; FSerialization::ClearPlotDeltas
EXTRN	?clearDelta@FAutoArchive@@QAEXXZ:PROC		; FAutoArchive::clearDelta
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?ClearPlotDeltas@FSerialization@@YAXXZ
_TEXT	SEGMENT
?ClearPlotDeltas@FSerialization@@YAXXZ PROC		; FSerialization::ClearPlotDeltas, COMDAT

; 91   : 	std::set<CvPlot*>::iterator i;
; 92   : 	for(i = plotsToCheck.begin(); i != plotsToCheck.end(); ++i)

	mov	ecx, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	push	esi
	mov	esi, DWORD PTR [ecx]
	cmp	esi, ecx
	je	SHORT $LN2@ClearPlotD
	npad	3
$LL27@ClearPlotD:

; 93   : 	{
; 94   : 		CvPlot* plot = *i;

	mov	eax, DWORD PTR [esi+12]

; 95   : 
; 96   : 		if(plot)

	test	eax, eax
	je	SHORT $LN3@ClearPlotD

; 97   : 		{
; 98   : 			FAutoArchive& archive = plot->getSyncArchive();

	lea	ecx, DWORD PTR [eax+392]

; 99   : 			archive.clearDelta();

	call	?clearDelta@FAutoArchive@@QAEXXZ	; FAutoArchive::clearDelta
	mov	ecx, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
$LN3@ClearPlotD:

; 91   : 	std::set<CvPlot*>::iterator i;
; 92   : 	for(i = plotsToCheck.begin(); i != plotsToCheck.end(); ++i)

	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN80@ClearPlotD
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN77@ClearPlotD
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN80@ClearPlotD
$LL42@ClearPlotD:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL42@ClearPlotD
	jmp	SHORT $LN80@ClearPlotD
$LN77@ClearPlotD:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN25@ClearPlotD
$LL26@ClearPlotD:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN25@ClearPlotD
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL26@ClearPlotD
$LN25@ClearPlotD:
	mov	esi, eax
$LN80@ClearPlotD:
	cmp	esi, ecx
	jne	SHORT $LL27@ClearPlotD
$LN2@ClearPlotD:
	pop	esi

; 100  : 		}
; 101  : 	}
; 102  : }

	ret	0
?ClearPlotDeltas@FSerialization@@YAXXZ ENDP		; FSerialization::ClearPlotDeltas
_TEXT	ENDS
PUBLIC	??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@FFastSmall@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@FFastSmall@2:
	ret	0
??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>
_TEXT	ENDS
PUBLIC	?updateVisibility@CvPlot@@QAEXXZ		; CvPlot::updateVisibility
EXTRN	??3CvDllUnit@@SAXPAX@Z:PROC			; CvDllUnit::operator delete
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z:PROC ; CvPlotManager::GetUnitsByIndex
EXTRN	??0CvDllUnit@@QAE@PAVCvUnit@@@Z:PROC		; CvDllUnit::CvDllUnit
EXTRN	??2CvDllUnit@@SAPAXI@Z:PROC			; CvDllUnit::operator new
EXTRN	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ:PROC ; CvUnit::getInvisibleType
EXTRN	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ:PROC	; CvGlobals::IsGraphicsInitialized
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?updateVisibility@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$3
__ehfuncinfo$?updateVisibility@CvPlot@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?updateVisibility@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateVisibility@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
_eActiveTeam$ = -36					; size = 4
_kUnits$222561 = -32					; size = 4
_iLayer$222557 = -28					; size = 4
_kPlotManager$222555 = -24				; size = 4
_iNumLayers$222556 = -20				; size = 4
$T245878 = -20						; size = 4
_pDllUnit$222545 = -20					; size = 4
$T245884 = -16						; size = 4
_pDllUnit$222575 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?updateVisibility@CvPlot@@QAEXXZ PROC			; CvPlot::updateVisibility, COMDAT
; _this$ = ecx

; 579  : {

	push	-1
	push	__ehhandler$?updateVisibility@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	edi
	mov	edi, ecx

; 580  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+44], edi
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	$LN6@updateVisi

; 581  : 	{
; 582  : 		return;
; 583  : 	}
; 584  : 
; 585  : 	setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	33					; 00000021H
	call	edx
	or	BYTE PTR [edi+462], 1

; 586  : 
; 587  : 	// Any unit that has visibility rules (it can become invisible to another player) needs to update itself.
; 588  : 	const TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eActiveTeam$[esp+44], eax

; 589  : 	CvAssert(eActiveTeam != NO_TEAM);
; 590  : 	if (eActiveTeam != NO_TEAM)

	cmp	eax, -1
	je	$LN6@updateVisi

; 591  : 	{
; 592  : 		IDInfo* pUnitNode = headUnitNode();

	mov	eax, DWORD PTR [edi+28]
	push	esi
	test	eax, eax
	jbe	SHORT $LN39@updateVisi
	mov	esi, DWORD PTR [edi+24]
	jmp	SHORT $LN38@updateVisi
$LN39@updateVisi:
	xor	esi, esi
$LN38@updateVisi:
	push	ebx
	push	ebp

; 593  : 		while (pUnitNode != NULL)

	test	esi, esi
	je	$LN11@updateVisi
	npad	3
$LL12@updateVisi:

; 594  : 		{
; 595  : 			CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN46@updateVisi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN46@updateVisi
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	ebp, eax
	jmp	SHORT $LN47@updateVisi
$LN46@updateVisi:
	xor	ebp, ebp
$LN47@updateVisi:

; 596  : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+28]
	jae	SHORT $LN58@updateVisi
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN57@updateVisi
$LN58@updateVisi:
	xor	esi, esi
$LN57@updateVisi:

; 597  : 
; 598  : 			if (pLoopUnit)

	test	ebp, ebp
	je	$LN81@updateVisi

; 599  : 			{
; 600  : 				InvisibleTypes eInvisibleType = pLoopUnit->getInvisibleType();

	mov	ecx, ebp
	call	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getInvisibleType
	mov	ebx, eax

; 601  : 				if (eInvisibleType != NO_INVISIBLE)

	cmp	ebx, -1
	je	$LN116@updateVisi

; 602  : 				{
; 603  : 					// This unit has visibility rules, send a message that it needs to update itself.
; 604  : 					auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T245878[esp+56], eax
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+64], edi
	cmp	eax, edi
	je	SHORT $LN17@updateVisi
	push	ebp
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	edi, eax
$LN17@updateVisi:
	mov	DWORD PTR _pDllUnit$222545[esp+56], edi

; 605  : 					gDLL->GameplayUnitVisibility(pDllUnit.get(), (pLoopUnit->getTeam() == eActiveTeam)?true:isInvisibleVisible(eActiveTeam, eInvisibleType), true, 0.01f);

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+64], 1
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	ecx, DWORD PTR _eActiveTeam$[esp+56]
	cmp	eax, ecx
	jne	SHORT $LN19@updateVisi
	mov	al, 1
	jmp	SHORT $LN20@updateVisi
$LN19@updateVisi:
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN71@updateVisi
	test	ebx, ebx
	ja	SHORT $LN71@updateVisi
	mov	eax, DWORD PTR _this$[esp+56]
	add	ebx, ecx
	movsx	eax, WORD PTR [eax+ebx*2+196]
	jmp	SHORT $LN73@updateVisi
$LN71@updateVisi:
	xor	eax, eax
$LN73@updateVisi:
	test	eax, eax
	setg	al
$LN20@updateVisi:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+640]
	push	edi
	call	eax

; 606  : 				}

	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	edi, edi
	je	SHORT $LN116@updateVisi
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN116@updateVisi:
	mov	edi, DWORD PTR _this$[esp+56]
$LN81@updateVisi:

; 593  : 		while (pUnitNode != NULL)

	test	esi, esi
	jne	$LL12@updateVisi
$LN11@updateVisi:

; 607  : 			}
; 608  : 		}
; 609  : 
; 610  : 		// Must update the other layers as well
; 611  : 		CvPlotManager& kPlotManager = GC.getMap().plotManager();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, 4184				; 00001058H

; 612  : 		int iNumLayers = kPlotManager.GetNumLayers();

	mov	ecx, esi
	mov	DWORD PTR _kPlotManager$222555[esp+56], esi
	call	?GetNumLayers@CvPlotManager@@QBEHXZ	; CvPlotManager::GetNumLayers

; 613  : 		for (int iLayer = 0; iLayer < iNumLayers; ++iLayer)

	xor	ebp, ebp
	mov	DWORD PTR _iNumLayers$222556[esp+56], eax
	mov	DWORD PTR _iLayer$222557[esp+56], ebp
	test	eax, eax
	jle	$LN122@updateVisi
	jmp	SHORT $LN8@updateVisi
	npad	3
$LL119@updateVisi:
	mov	esi, DWORD PTR _kPlotManager$222555[esp+56]
$LN8@updateVisi:

; 614  : 		{	
; 615  : 			const CvIDInfoFixedVector &kUnits = kPlotManager.GetUnitsByIndex(m_iX, m_iY, iLayer);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebp
	push	eax
	push	ecx
	mov	ecx, esi
	call	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ; CvPlotManager::GetUnitsByIndex
	mov	esi, eax

; 616  : 			for (CvIDInfoFixedVector::const_iterator itrUnit = kUnits.begin(); itrUnit != kUnits.end(); ++itrUnit)

	mov	ebx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [ebx+edx*8]
	mov	DWORD PTR _kUnits$222561[esp+56], esi
	cmp	ebx, eax
	je	$LN7@updateVisi
	npad	5
$LL5@updateVisi:

; 617  : 			{
; 618  : 				CvUnit* pLoopUnit = ::getUnit(*itrUnit);

	push	ebx
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	mov	edi, eax
	add	esp, 4

; 619  : 				if (pLoopUnit)

	test	edi, edi
	je	$LN4@updateVisi

; 620  : 				{
; 621  : 					InvisibleTypes eInvisibleType = pLoopUnit->getInvisibleType();

	mov	ecx, edi
	call	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getInvisibleType
	mov	ebp, eax

; 622  : 					if (eInvisibleType != NO_INVISIBLE)

	cmp	ebp, -1
	je	$LN4@updateVisi

; 623  : 					{
; 624  : 						// This unit has visibility rules, send a message that it needs to update itself.
; 625  : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T245884[esp+56], eax
	mov	DWORD PTR __$EHRec$[esp+64], 2
	test	eax, eax
	je	SHORT $LN21@updateVisi
	push	edi
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN22@updateVisi
$LN21@updateVisi:
	xor	esi, esi
$LN22@updateVisi:
	mov	DWORD PTR _pDllUnit$222575[esp+56], esi

; 626  : 						gDLL->GameplayUnitVisibility(pDllUnit.get(), (pLoopUnit->getTeam() == eActiveTeam)?true:isInvisibleVisible(eActiveTeam, eInvisibleType), true, 0.01f);

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+64], 3
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	ecx, DWORD PTR _eActiveTeam$[esp+56]
	cmp	eax, ecx
	jne	SHORT $LN23@updateVisi
	mov	al, 1
	jmp	SHORT $LN24@updateVisi
$LN23@updateVisi:
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN98@updateVisi
	test	ebp, ebp
	ja	SHORT $LN98@updateVisi
	add	ebp, ecx
	mov	ecx, DWORD PTR _this$[esp+56]
	movsx	eax, WORD PTR [ecx+ebp*2+196]
	jmp	SHORT $LN100@updateVisi
$LN98@updateVisi:
	xor	eax, eax
$LN100@updateVisi:
	test	eax, eax
	setg	al
$LN24@updateVisi:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+640]
	push	esi
	call	eax

; 627  : 					}

	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	esi, esi
	je	SHORT $LN117@updateVisi
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
$LN117@updateVisi:
	mov	esi, DWORD PTR _kUnits$222561[esp+56]
$LN4@updateVisi:

; 616  : 			for (CvIDInfoFixedVector::const_iterator itrUnit = kUnits.begin(); itrUnit != kUnits.end(); ++itrUnit)

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	add	ebx, 8
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	ebx, edx
	jne	$LL5@updateVisi
	mov	edi, DWORD PTR _this$[esp+56]
	mov	ebp, DWORD PTR _iLayer$222557[esp+56]
$LN7@updateVisi:
	inc	ebp
	cmp	ebp, DWORD PTR _iNumLayers$222556[esp+56]
	mov	DWORD PTR _iLayer$222557[esp+56], ebp
	jl	$LL119@updateVisi
$LN122@updateVisi:
	pop	ebp
	pop	ebx
	pop	esi
$LN6@updateVisi:

; 628  : 				}
; 629  : 			}
; 630  : 		}
; 631  : 	}
; 632  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$0:
	mov	eax, DWORD PTR $T245878[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$1:
	lea	ecx, DWORD PTR _pDllUnit$222545[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$2:
	mov	eax, DWORD PTR $T245884[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$3:
	lea	ecx, DWORD PTR _pDllUnit$222575[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?updateVisibility@CvPlot@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?updateVisibility@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateVisibility@CvPlot@@QAEXXZ ENDP			; CvPlot::updateVisibility
PUBLIC	?getNearestLandArea@CvPlot@@QBEHXZ		; CvPlot::getNearestLandArea
; Function compile flags: /Ogtpy
;	COMDAT ?getNearestLandArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getNearestLandArea@CvPlot@@QBEHXZ PROC			; CvPlot::getNearestLandArea, COMDAT
; _this$ = ecx

; 1317 : 	CvPlot* pPlot = getNearestLandPlot();

	push	0
	call	?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z ; CvPlot::getNearestLandPlotInternal

; 1318 : 	return pPlot ? pPlot->getArea() : -1;

	test	eax, eax
	je	SHORT $LN3@getNearest@2
	mov	eax, DWORD PTR [eax+356]

; 1319 : }

	ret	0
$LN3@getNearest@2:

; 1318 : 	return pPlot ? pPlot->getArea() : -1;

	or	eax, -1

; 1319 : }

	ret	0
?getNearestLandArea@CvPlot@@QBEHXZ ENDP			; CvPlot::getNearestLandArea
_TEXT	ENDS
PUBLIC	?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::canHaveImprovement
EXTRN	?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetPrereqNatureYield
EXTRN	?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetRequiresXAdjacentLand
EXTRN	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetFeatureMakesValid
EXTRN	?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetImprovementMakesValid
EXTRN	?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetTerrainMakesValid
EXTRN	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRiverSideMakesValid
EXTRN	?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsFreshWaterMakesValid
EXTRN	?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsWaterAdjacencyMakesValid
EXTRN	?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsHillsMakesValid
EXTRN	?IsCoastal@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsCoastal
EXTRN	?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresImprovement
EXTRN	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresFeature
EXTRN	?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
EXTRN	?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresFlatlands
EXTRN	?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsNoFreshWater
EXTRN	?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceMakesValid
EXTRN	?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsBuildableOnResources
EXTRN	?isNoImprovement@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNoImprovement
EXTRN	?IsWater@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_bValid$ = -10						; size = 1
$T246145 = -9						; size = 1
_bIsFreshWater$ = -9					; size = 1
_iRequiredAdjacentLand$ = -8				; size = 4
_pkImprovementInfo$ = -4				; size = 4
_iAdjacentLand$223383 = 8				; size = 4
_eImprovement$ = 8					; size = 4
_eTeam$ = 12						; size = 4
___formal$ = 16						; size = 1
?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::canHaveImprovement, COMDAT
; _this$ = ecx

; 2063 : {

	sub	esp, 12					; 0000000cH

; 2064 : 	CvPlot* pLoopPlot;
; 2065 : 	bool bValid;
; 2066 : 	int iI;
; 2067 : 
; 2068 : 	CvAssertMsg(eImprovement != NO_IMPROVEMENT, "Improvement is not assigned a valid value");
; 2069 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 2070 : 
; 2071 : 	CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$[esp+8]
	push	ebx
	push	esi
	mov	esi, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ebx, eax
	mov	DWORD PTR _pkImprovementInfo$[esp+20], ebx

; 2072 : 	if(pkImprovementInfo == NULL)

	test	ebx, ebx
	jne	SHORT $LN48@canHaveImp
$LN132@canHaveImp:
	pop	esi

; 2073 : 	{
; 2074 : 		return false;

	xor	al, al
	pop	ebx

; 2263 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN48@canHaveImp:

; 2075 : 	}
; 2076 : 
; 2077 : 	bValid = false;
; 2078 : 
; 2079 : 	if(isCity())

	mov	eax, DWORD PTR [esi+104]
	mov	BYTE PTR _bValid$[esp+20], 0
	test	eax, eax
	jl	SHORT $LN47@canHaveImp
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN47@canHaveImp
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al

; 2080 : 	{
; 2081 : 		return false;

	jne	SHORT $LN132@canHaveImp
$LN47@canHaveImp:

; 2082 : 	}
; 2083 : 
; 2084 : 	if(isImpassable() || isMountain())

	test	BYTE PTR [esi+462], 128			; 00000080H
	jne	SHORT $LN132@canHaveImp
	mov	al, BYTE PTR [esi+5]
	test	al, al
	je	SHORT $LN132@canHaveImp

; 2085 : 	{
; 2086 : 		return false;
; 2087 : 	}
; 2088 : 
; 2089 : 	if(pkImprovementInfo->IsWater() != isWater())

	cmp	al, 3
	mov	ecx, ebx
	sete	BYTE PTR $T246145[esp+20]
	call	?IsWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsWater
	cmp	al, BYTE PTR $T246145[esp+20]

; 2090 : 	{
; 2091 : 		return false;

	jne	SHORT $LN132@canHaveImp

; 2092 : 	}
; 2093 : 
; 2094 : 	if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN42@canHaveImp

; 2095 : 	{
; 2096 : 		if(GC.getFeatureInfo(getFeatureType())->isNoImprovement())

	movsx	edx, al
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isNoImprovement@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoImprovement
	test	al, al

; 2097 : 		{
; 2098 : 			return false;

	jne	$LN132@canHaveImp
$LN42@canHaveImp:

; 2099 : 		}
; 2100 : 	}
; 2101 : 
; 2102 : 	ResourceTypes thisResource = getResourceType(eTeam);

	mov	eax, DWORD PTR _eTeam$[esp+16]
	push	edi
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	edi, eax

; 2103 : 	// The functionality of this line is different in Civ 4: in that game a "Valid" Resource ALLOWS an Improvement on a Tile.  In Civ 5 this makes a Resource REQUIRE a certain Improvement
; 2104 : 	if(thisResource != NO_RESOURCE &&
; 2105 : 	        !pkImprovementInfo->IsBuildableOnResources() &&	// Some improvements can be built anywhere
; 2106 : 	        !pkImprovementInfo->IsImprovementResourceMakesValid(thisResource))

	cmp	edi, -1
	je	SHORT $LN39@canHaveImp
	mov	ecx, ebx
	call	?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsBuildableOnResources
	test	al, al
	jne	SHORT $LN41@canHaveImp
	push	edi
	mov	ecx, ebx
	call	?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceMakesValid
	test	al, al

; 2107 : 	{
; 2108 : 		return false;

	je	$LN131@canHaveImp
$LN41@canHaveImp:

; 2109 : 	}
; 2110 : 	// If there IS a valid resource here then set validity to true (because something has to)
; 2111 : 	else if(thisResource != NO_RESOURCE)
; 2112 : 	{
; 2113 : 		bValid = true;

	mov	BYTE PTR _bValid$[esp+24], 1
$LN39@canHaveImp:

; 2114 : 	}
; 2115 : 
; 2116 : 	const bool bIsFreshWater = isFreshWater();

	mov	ecx, esi
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater

; 2117 : 
; 2118 : 	if(pkImprovementInfo->IsNoFreshWater() && bIsFreshWater)

	mov	ecx, ebx
	mov	BYTE PTR _bIsFreshWater$[esp+24], al
	call	?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsNoFreshWater
	test	al, al
	je	SHORT $LN38@canHaveImp
	cmp	BYTE PTR _bIsFreshWater$[esp+24], 0

; 2119 : 	{
; 2120 : 		return false;

	jne	$LN131@canHaveImp
$LN38@canHaveImp:

; 2121 : 	}
; 2122 : 
; 2123 : 	if(pkImprovementInfo->IsRequiresFlatlands() && !isFlatlands())

	mov	ecx, ebx
	call	?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlands
	test	al, al
	je	SHORT $LN37@canHaveImp
	cmp	BYTE PTR [esi+5], 2

; 2124 : 	{
; 2125 : 		return false;

	jne	$LN131@canHaveImp
$LN37@canHaveImp:

; 2126 : 	}
; 2127 : 
; 2128 : 	if(pkImprovementInfo->IsRequiresFlatlandsOrFreshWater() && !isFlatlands() && !bIsFreshWater)

	mov	ecx, ebx
	call	?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
	test	al, al
	je	SHORT $LN36@canHaveImp
	cmp	BYTE PTR [esi+5], 2
	je	SHORT $LN36@canHaveImp
	cmp	BYTE PTR _bIsFreshWater$[esp+24], 0

; 2129 : 	{
; 2130 : 		return false;

	je	$LN131@canHaveImp
$LN36@canHaveImp:

; 2131 : 	}
; 2132 : 
; 2133 : 	if(pkImprovementInfo->IsRequiresFeature() && (getFeatureType() == NO_FEATURE))

	mov	ecx, ebx
	call	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFeature
	test	al, al
	je	SHORT $LN35@canHaveImp
	cmp	BYTE PTR [esi+432], -1

; 2134 : 	{
; 2135 : 		return false;

	je	$LN131@canHaveImp
$LN35@canHaveImp:

; 2136 : 	}
; 2137 : 
; 2138 : 	if(pkImprovementInfo->IsRequiresImprovement())

	mov	ecx, ebx
	call	?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresImprovement
	test	al, al
	je	SHORT $LN32@canHaveImp

; 2139 : 	{
; 2140 : 		if (getImprovementType() == NO_IMPROVEMENT)

	cmp	BYTE PTR [esi+441], -1

; 2141 : 		{
; 2142 : 			return false;

	je	$LN131@canHaveImp

; 2143 : 		}
; 2144 : 		else
; 2145 : 		{
; 2146 : 			bValid = false;

	mov	BYTE PTR _bValid$[esp+24], 0
$LN32@canHaveImp:

; 2147 : 		}
; 2148 : 	}
; 2149 : 
; 2150 : 	if(pkImprovementInfo->IsCoastal() && !isCoastalLand())

	mov	ecx, ebx
	call	?IsCoastal@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsCoastal
	test	al, al
	je	SHORT $LN31@canHaveImp
	push	-1
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al

; 2151 : 	{
; 2152 : 		return false;

	je	$LN131@canHaveImp
$LN31@canHaveImp:

; 2153 : 	}
; 2154 : 
; 2155 : 	if(pkImprovementInfo->IsHillsMakesValid() && isHills())

	mov	ecx, ebx
	call	?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsHillsMakesValid
	test	al, al
	je	SHORT $LN30@canHaveImp
	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN30@canHaveImp

; 2156 : 	{
; 2157 : 		bValid = true;

	mov	BYTE PTR _bValid$[esp+24], 1
$LN30@canHaveImp:

; 2158 : 	}
; 2159 : 
; 2160 : 	if(pkImprovementInfo->IsWaterAdjacencyMakesValid())

	mov	ecx, ebx
	call	?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsWaterAdjacencyMakesValid
	test	al, al
	je	SHORT $LN26@canHaveImp

; 2161 : 	{
; 2162 : 		if (isCoastalLand() || isFreshWater() || isRiver()) 

	push	-1
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	jne	SHORT $LN27@canHaveImp
	mov	ecx, esi
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater
	test	al, al
	jne	SHORT $LN27@canHaveImp
	cmp	BYTE PTR [esi+457], al

; 2165 : 
; 2166 : 		}
; 2167 : 		else
; 2168 : 		{
; 2169 : 			bValid = false;

	mov	BYTE PTR _bValid$[esp+24], al
	jle	SHORT $LN26@canHaveImp
$LN27@canHaveImp:

; 2163 : 		{
; 2164 : 			bValid = true;

	mov	BYTE PTR _bValid$[esp+24], 1
$LN26@canHaveImp:

; 2170 : 		}
; 2171 : 	}
; 2172 : 
; 2173 : 	if(pkImprovementInfo->IsFreshWaterMakesValid() && bIsFreshWater)

	mov	ecx, ebx
	call	?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsFreshWaterMakesValid
	test	al, al
	je	SHORT $LN25@canHaveImp
	cmp	BYTE PTR _bIsFreshWater$[esp+24], 0
	je	SHORT $LN25@canHaveImp

; 2174 : 	{
; 2175 : 		bValid = true;

	mov	BYTE PTR _bValid$[esp+24], 1
$LN25@canHaveImp:

; 2176 : 	}
; 2177 : 
; 2178 : 	if(pkImprovementInfo->IsRiverSideMakesValid() && isRiverSide())

	mov	ecx, ebx
	call	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRiverSideMakesValid
	test	al, al
	je	SHORT $LN24@canHaveImp
	mov	ecx, esi
	call	?isRiverSide@CvPlot@@QBE_NXZ		; CvPlot::isRiverSide
	test	al, al
	je	SHORT $LN24@canHaveImp

; 2179 : 	{
; 2180 : 		bValid = true;

	mov	BYTE PTR _bValid$[esp+24], 1
$LN24@canHaveImp:

; 2181 : 	}
; 2182 : 
; 2183 : 	if(pkImprovementInfo->GetTerrainMakesValid(getTerrainType()))

	movsx	eax, BYTE PTR [esi+6]
	push	eax
	mov	ecx, ebx
	call	?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetTerrainMakesValid
	test	al, al
	je	SHORT $LN125@canHaveImp

; 2184 : 	{
; 2185 : 		bValid = true;

	mov	BYTE PTR _bValid$[esp+24], 1
$LN125@canHaveImp:

; 2186 : 	}
; 2187 : 
; 2188 : 	if((getImprovementType() != NO_IMPROVEMENT) && pkImprovementInfo->GetImprovementMakesValid(getImprovementType()))

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	SHORT $LN126@canHaveImp
	movsx	eax, al
	push	eax
	mov	ecx, ebx
	call	?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetImprovementMakesValid
	test	al, al
	je	SHORT $LN126@canHaveImp

; 2189 : 	{
; 2190 : 		bValid = true;

	mov	BYTE PTR _bValid$[esp+24], 1
$LN126@canHaveImp:

; 2191 : 	}
; 2192 : 
; 2193 : 	if((getFeatureType() != NO_FEATURE) && pkImprovementInfo->GetFeatureMakesValid(getFeatureType()))

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN21@canHaveImp
	movsx	ecx, al
	push	ecx
	mov	ecx, ebx
	call	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
	test	al, al

; 2194 : 	{
; 2195 : 		bValid = true;
; 2196 : 	}
; 2197 : 
; 2198 : 	if(!bValid)

	jne	SHORT $LN20@canHaveImp
$LN21@canHaveImp:
	cmp	BYTE PTR _bValid$[esp+24], 0
	jne	SHORT $LN20@canHaveImp
$LN131@canHaveImp:
	pop	edi
	pop	esi

; 2199 : 	{
; 2200 : 		return false;

	xor	al, al
	pop	ebx

; 2263 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN20@canHaveImp:
	push	ebp

; 2201 : 	}
; 2202 : 
; 2203 : 	if(pkImprovementInfo->IsRiverSideMakesValid())

	mov	ecx, ebx
	call	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRiverSideMakesValid
	test	al, al
	je	SHORT $LN127@canHaveImp

; 2204 : 	{
; 2205 : 		bValid = false;
; 2206 : 
; 2207 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebp, ebp
$LL18@canHaveImp:

; 2208 : 		{
; 2209 : 			pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	push	ebp
	push	eax
	movsx	eax, WORD PTR [esi]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 2210 : 
; 2211 : 			if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN17@canHaveImp

; 2212 : 			{
; 2213 : 				if(isRiverCrossing(directionXY(this, pLoopPlot)))

	push	edi
	push	esi
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, esi
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	test	al, al
	je	SHORT $LN17@canHaveImp

; 2214 : 				{
; 2215 : 					if(pLoopPlot->getImprovementType() != eImprovement)

	movsx	edx, BYTE PTR [edi+441]
	cmp	edx, DWORD PTR _eImprovement$[esp+24]
	jne	SHORT $LN127@canHaveImp
$LN17@canHaveImp:

; 2204 : 	{
; 2205 : 		bValid = false;
; 2206 : 
; 2207 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL18@canHaveImp
$LN118@canHaveImp:
	pop	ebp
	pop	edi
	pop	esi

; 2216 : 					{
; 2217 : 						bValid = true;
; 2218 : 						break;
; 2219 : 					}
; 2220 : 				}
; 2221 : 			}
; 2222 : 		}
; 2223 : 
; 2224 : 		if(!bValid)
; 2225 : 		{
; 2226 : 			return false;

	xor	al, al
	pop	ebx

; 2263 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN127@canHaveImp:

; 2227 : 		}
; 2228 : 	}
; 2229 : 
; 2230 : 	int iRequiredAdjacentLand = pkImprovementInfo->GetRequiresXAdjacentLand();

	mov	ecx, ebx
	call	?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetRequiresXAdjacentLand

; 2231 : 	if (iRequiredAdjacentLand > -1)

	cmp	eax, -1
	mov	DWORD PTR _iRequiredAdjacentLand$[esp+28], eax
	jle	SHORT $LN5@canHaveImp

; 2232 : 	{
; 2233 : 		int iAdjacentLand = 0;
; 2234 : 
; 2235 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	movsx	ebp, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	xor	edi, edi
	mov	DWORD PTR _iAdjacentLand$223383[esp+24], edi
	npad	1
$LL10@canHaveImp:

; 2236 : 		{
; 2237 : 			pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	push	edi
	push	ebp
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 2238 : 
; 2239 : 			if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN9@canHaveImp

; 2240 : 			{
; 2241 : 				if (!pLoopPlot->isWater())

	cmp	BYTE PTR [eax+5], 3
	je	SHORT $LN9@canHaveImp

; 2242 : 				{
; 2243 : 					iAdjacentLand++;

	inc	DWORD PTR _iAdjacentLand$223383[esp+24]
$LN9@canHaveImp:

; 2232 : 	{
; 2233 : 		int iAdjacentLand = 0;
; 2234 : 
; 2235 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL10@canHaveImp

; 2244 : 				}
; 2245 : 			}
; 2246 : 		}
; 2247 : 
; 2248 : 		if (iAdjacentLand < iRequiredAdjacentLand)

	mov	eax, DWORD PTR _iRequiredAdjacentLand$[esp+28]
	cmp	DWORD PTR _iAdjacentLand$223383[esp+24], eax

; 2249 : 		{
; 2250 : 			return false;

	jl	SHORT $LN118@canHaveImp

; 2244 : 				}
; 2245 : 			}
; 2246 : 		}
; 2247 : 
; 2248 : 		if (iAdjacentLand < iRequiredAdjacentLand)

	mov	ebx, DWORD PTR _pkImprovementInfo$[esp+28]
$LN5@canHaveImp:

; 2251 : 		}
; 2252 : 	}
; 2253 : 
; 2254 : 	for(iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	xor	edi, edi
	npad	1
$LL128@canHaveImp:

; 2255 : 	{
; 2256 : 		if(calculateNatureYield(((YieldTypes)iI), eTeam) < pkImprovementInfo->GetPrereqNatureYield(iI))

	mov	ecx, DWORD PTR _eTeam$[esp+24]
	push	0
	push	ecx
	push	edi
	mov	ecx, esi
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	push	edi
	mov	ecx, ebx
	mov	ebp, eax
	call	?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetPrereqNatureYield
	cmp	ebp, eax
	jl	SHORT $LN118@canHaveImp
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL128@canHaveImp
	pop	ebp
	pop	edi
	pop	esi

; 2257 : 		{
; 2258 : 			return false;
; 2259 : 		}
; 2260 : 	}
; 2261 : 
; 2262 : 	return true;

	mov	al, 1
	pop	ebx

; 2263 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::canHaveImprovement
_TEXT	ENDS
PUBLIC	?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ; CvPlot::canBuild
EXTRN	?getValue@CvRouteInfo@@QBEHXZ:PROC		; CvRouteInfo::getValue
EXTRN	?IsWater@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::IsWater
EXTRN	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsOnlyCityStateTerritory
EXTRN	?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsInAdjacentFriendly
EXTRN	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsOutsideBorders
EXTRN	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsIgnoreOwnership
EXTRN	?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsNoTwoAdjacent
EXTRN	?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsAdjacentLuxury
EXTRN	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z:PROC ; finalImprovementUpgrade
EXTRN	?IsPermanent@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsPermanent
EXTRN	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ:PROC	; CvBuildInfo::IsRemoveRoute
; Function compile flags: /Ogtpy
;	COMDAT ?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z
_TEXT	SEGMENT
_bHasNoAdjacencyRequirement$223433 = -13		; size = 1
$T246284 = -12						; size = 4
_thisBuildInfo$ = -8					; size = 4
_eImprovement$ = -4					; size = 4
_eBuild$ = 8						; size = 4
_bHasLuxuryRequirement$223432 = 12			; size = 1
_ePlayer$ = 12						; size = 4
_bTestVisible$ = 16					; size = 1
_bLuxuryRequirementMet$223436 = 16			; size = 1
_bTestPlotOwner$ = 20					; size = 1
?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z PROC ; CvPlot::canBuild, COMDAT
; _this$ = ecx

; 2268 : {

	sub	esp, 16					; 00000010H
	push	ebp

; 2269 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	ebp, DWORD PTR _ePlayer$[esp+16]
	mov	eax, ebp
	imul	eax, 63236				; 0000f704H
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN70@canBuild
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T246284[esp+24], edx
	jmp	SHORT $LN71@canBuild
$LN70@canBuild:
	mov	DWORD PTR $T246284[esp+24], -1
$LN71@canBuild:

; 2270 : 
; 2271 : 	ImprovementTypes eImprovement;
; 2272 : 	ImprovementTypes eFinalImprovementType;
; 2273 : 	RouteTypes eRoute;
; 2274 : 	bool bValid;
; 2275 : 
; 2276 : 	// Can't build nothing!
; 2277 : 	if(eBuild == NO_BUILD)

	mov	eax, DWORD PTR _eBuild$[esp+20]
	cmp	eax, -1
	jne	SHORT $LN61@canBuild
	pop	edi

; 2278 : 	{
; 2279 : 		return false;

	xor	al, al
	pop	ebp

; 2563 : }

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
$LN61@canBuild:
	push	ebx
	push	esi

; 2280 : 	}
; 2281 : 
; 2282 : 	bValid = false;
; 2283 : 
; 2284 : 	// Repairing an Improvement that's been pillaged
; 2285 : 	CvBuildInfo& thisBuildInfo = *GC.getBuildInfo(eBuild);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	bl, bl
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	esi, eax

; 2286 : 	if(thisBuildInfo.isRepair())

	mov	ecx, esi
	mov	DWORD PTR _thisBuildInfo$[esp+32], esi
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	test	al, al
	je	SHORT $LN57@canBuild

; 2287 : 	{
; 2288 : 		if(IsImprovementPillaged() || IsRoutePillaged())

	test	BYTE PTR [edi+461], 3

; 2291 : 		}
; 2292 : 		else
; 2293 : 		{
; 2294 : 			return false;

	je	$LN159@canBuild

; 2289 : 		{
; 2290 : 			bValid = true;

	mov	bl, 1
$LN57@canBuild:

; 2295 : 		}
; 2296 : 	}
; 2297 : 
; 2298 : 	if(thisBuildInfo.IsRemoveRoute())

	mov	ecx, esi
	call	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ	; CvBuildInfo::IsRemoveRoute
	test	al, al
	je	SHORT $LN50@canBuild

; 2299 : 	{
; 2300 : 		if(!getPlotCity() && getRouteType() != NO_ROUTE)

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN157@canBuild
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN157@canBuild
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	jne	$LN159@canBuild
$LN157@canBuild:
	cmp	BYTE PTR [edi+447], -1
	je	$LN159@canBuild

; 2301 : 		{
; 2302 : 			if(getOwner() == ePlayer)

	mov	al, BYTE PTR [edi+4]
	movsx	edx, al
	cmp	edx, ebp

; 2303 : 			{
; 2304 : 				bValid = true;

	je	SHORT $LN166@canBuild

; 2305 : 			}
; 2306 : 			else if(getOwner() == NO_PLAYER && GetPlayerResponsibleForRoute() == ePlayer)

	cmp	al, -1
	jne	$LN159@canBuild
	movsx	eax, BYTE PTR [edi+445]
	cmp	eax, ebp
	jne	$LN159@canBuild
$LN166@canBuild:

; 2303 : 			{
; 2304 : 				bValid = true;

	mov	bl, 1
$LN50@canBuild:

; 2307 : 			{
; 2308 : 				bValid = true;
; 2309 : 			}
; 2310 : 			else
; 2311 : 			{
; 2312 : 				return false;
; 2313 : 			}
; 2314 : 		}
; 2315 : 		else
; 2316 : 		{
; 2317 : 			return false;
; 2318 : 		}
; 2319 : 	}
; 2320 : 
; 2321 : 	eImprovement = ((ImprovementTypes)(thisBuildInfo.getImprovement()));

	mov	ecx, esi
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	ebp, eax
	mov	DWORD PTR _eImprovement$[esp+32], ebp

; 2322 : 
; 2323 : 	// Improvement
; 2324 : 	if(eImprovement != NO_IMPROVEMENT)

	cmp	ebp, -1
	je	$LN49@canBuild

; 2325 : 	{
; 2326 : 		// Player must be able to build this Improvement
; 2327 : 		if(!canHaveImprovement(eImprovement, eTeam, bTestVisible))

	mov	ebx, DWORD PTR _bTestVisible$[esp+28]
	mov	ecx, DWORD PTR $T246284[esp+32]
	push	ebx
	push	ecx
	push	ebp
	mov	ecx, edi
	call	?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::canHaveImprovement
	test	al, al

; 2328 : 		{
; 2329 : 			return false;

	je	$LN159@canBuild

; 2330 : 		}
; 2331 : 
; 2332 : 		// Already an improvement here
; 2333 : 		if(getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [edi+441]
	cmp	al, -1
	je	SHORT $LN160@canBuild

; 2334 : 		{
; 2335 : 
; 2336 : 			if(GC.getImprovementInfo(getImprovementType())->IsPermanent())

	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsPermanent@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsPermanent
	test	al, al

; 2337 : 			{
; 2338 : 				return false;

	jne	$LN159@canBuild

; 2339 : 			}
; 2340 : 
; 2341 : 			if(getImprovementType() == eImprovement)

	movsx	eax, BYTE PTR [edi+441]
	cmp	eax, ebp

; 2342 : 			{
; 2343 : 				return false;

	je	$LN159@canBuild

; 2344 : 			}
; 2345 : 
; 2346 : 			eFinalImprovementType = finalImprovementUpgrade(getImprovementType());

	push	0
	push	eax
	call	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ; finalImprovementUpgrade
	mov	esi, eax
	add	esp, 8

; 2347 : 
; 2348 : 			if(eFinalImprovementType != NO_IMPROVEMENT)

	cmp	esi, -1
	je	SHORT $LN160@canBuild

; 2349 : 			{
; 2350 : 				if(eFinalImprovementType == finalImprovementUpgrade(eImprovement))

	push	0
	push	ebp
	call	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ; finalImprovementUpgrade
	add	esp, 8
	cmp	esi, eax
	jne	SHORT $LN160@canBuild

; 2351 : 				{
; 2352 : 					if(!IsImprovementPillaged())

	test	BYTE PTR [edi+461], 1

; 2353 : 					{
; 2354 : 						return false;

	je	$LN159@canBuild
$LN160@canBuild:

; 2355 : 					}
; 2356 : 				}
; 2357 : 			}
; 2358 : 		}
; 2359 : 
; 2360 : #ifdef AUI_WARNING_FIXES
; 2361 : 		const CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);
; 2362 : 		if (pkImprovement)
; 2363 : 		{
; 2364 : #endif
; 2365 : 
; 2366 : 		// Requirements on adjacent plots?
; 2367 : 		if (!bTestVisible)

	test	bl, bl
	jne	$LN13@canBuild

; 2368 : 		{
; 2369 : #ifdef AUI_WARNING_FIXES
; 2370 : 			bool bHasLuxuryRequirement = pkImprovement->IsAdjacentLuxury();
; 2371 : 			bool bHasNoAdjacencyRequirement = pkImprovement->IsNoTwoAdjacent();
; 2372 : 			if (bHasLuxuryRequirement || bHasNoAdjacencyRequirement)
; 2373 : #else
; 2374 : 			CvImprovementEntry *pkImprovement = GC.getImprovementInfo(eImprovement);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	esi, eax

; 2375 : 			bool bHasLuxuryRequirement = pkImprovement->IsAdjacentLuxury();

	mov	ecx, esi
	call	?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsAdjacentLuxury
	mov	bl, al

; 2376 : 			bool bHasNoAdjacencyRequirement = pkImprovement->IsNoTwoAdjacent();

	mov	ecx, esi
	mov	BYTE PTR _bHasLuxuryRequirement$223432[esp+28], bl
	call	?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsNoTwoAdjacent
	mov	BYTE PTR _bHasNoAdjacencyRequirement$223433[esp+32], al

; 2377 : 			if (pkImprovement && (bHasLuxuryRequirement || bHasNoAdjacencyRequirement))

	test	esi, esi
	je	$LN158@canBuild
	test	bl, bl
	jne	SHORT $LN39@canBuild
	test	al, al
	je	$LN158@canBuild
$LN39@canBuild:

; 2378 : #endif
; 2379 : 			{
; 2380 : 				bool bLuxuryRequirementMet = !bHasLuxuryRequirement;

	cmp	BYTE PTR _bHasLuxuryRequirement$223432[esp+28], 0
	sete	BYTE PTR _bLuxuryRequirementMet$223436[esp+28]

; 2381 : 				for (int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebx, ebx
$LL38@canBuild:

; 2382 : 				{
; 2383 : 					CvPlot *pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	edx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	push	ebx
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2384 : 					if (pAdjacentPlot != NULL)

	test	esi, esi
	je	SHORT $LN37@canBuild

; 2385 : 					{
; 2386 : #ifdef AUI_WARNING_FIXES
; 2387 : 						if (!bLuxuryRequirementMet)
; 2388 : #else
; 2389 : 						if (bHasLuxuryRequirement)

	cmp	BYTE PTR _bHasLuxuryRequirement$223432[esp+28], 0
	je	SHORT $LN161@canBuild

; 2390 : #endif
; 2391 : 						{
; 2392 : 							ResourceTypes eResource = pAdjacentPlot->getResourceType();

	movsx	eax, BYTE PTR [esi+440]

; 2393 : 							if (eResource != NO_RESOURCE)

	cmp	eax, -1
	je	SHORT $LN161@canBuild

; 2394 : 							{
; 2395 : 								CvResourceInfo *pkResourceInfo = GC.getResourceInfo(eResource);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 2396 : 								if (pkResourceInfo && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	test	eax, eax
	je	SHORT $LN161@canBuild
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN161@canBuild

; 2397 : 								{
; 2398 : 									bLuxuryRequirementMet = true;

	mov	BYTE PTR _bLuxuryRequirementMet$223436[esp+28], 1
$LN161@canBuild:

; 2399 : #ifdef AUI_WARNING_FIXES
; 2400 : 									if (!bHasNoAdjacencyRequirement)
; 2401 : 										break;
; 2402 : #endif
; 2403 : 								}
; 2404 : 							}
; 2405 : 						}
; 2406 : 						if (bHasNoAdjacencyRequirement)

	cmp	BYTE PTR _bHasNoAdjacencyRequirement$223433[esp+32], 0
	je	SHORT $LN37@canBuild

; 2407 : 						{
; 2408 : 							ImprovementTypes eAdjacentImprovement =  pAdjacentPlot->getImprovementType();

	movsx	eax, BYTE PTR [esi+441]

; 2409 : 							if (eAdjacentImprovement != NO_IMPROVEMENT && eAdjacentImprovement == eImprovement)

	cmp	eax, -1
	je	SHORT $LN30@canBuild
	cmp	eax, ebp
	je	$LN159@canBuild
$LN30@canBuild:

; 2410 : 							{
; 2411 : 								return false;
; 2412 : 							}
; 2413 : 							int iBuildProgress = pAdjacentPlot->getBuildProgress(eBuild);

	mov	ecx, DWORD PTR _eBuild$[esp+28]
	push	ecx
	mov	ecx, esi
	call	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress

; 2414 : 							if (iBuildProgress > 0)

	test	eax, eax
	jg	$LN159@canBuild
$LN37@canBuild:

; 2381 : 				for (int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL38@canBuild

; 2415 : 							{
; 2416 : 								return false;
; 2417 : 							}
; 2418 : 						}
; 2419 : 					}
; 2420 : 				}
; 2421 : 				if (bHasLuxuryRequirement && !bLuxuryRequirementMet)

	cmp	BYTE PTR _bHasLuxuryRequirement$223432[esp+28], 0
	je	SHORT $LN158@canBuild
	cmp	BYTE PTR _bLuxuryRequirementMet$223436[esp+28], 0

; 2422 : 				{
; 2423 : 					return false;

	je	$LN159@canBuild
$LN158@canBuild:

; 2424 : 				}
; 2425 : 			}
; 2426 : #ifdef AUI_WARNING_FIXES
; 2427 : 			if (!pkImprovement->IsIgnoreOwnership())
; 2428 : #else
; 2429 : 		}
; 2430 : 
; 2431 : 		if(!bTestVisible)
; 2432 : 		{
; 2433 : 			if(!GC.getImprovementInfo(eImprovement)->IsIgnoreOwnership())

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsIgnoreOwnership
	test	al, al
	jne	$LN13@canBuild

; 2434 : #endif
; 2435 : 			{
; 2436 : 				// Gifts for minors can ignore borders requirements
; 2437 : 				if(bTestPlotOwner)

	cmp	BYTE PTR _bTestPlotOwner$[esp+28], al
	je	$LN13@canBuild

; 2438 : 				{
; 2439 : 					// Outside Borders - Can be built in or outside our lands, but not in other lands
; 2440 : #ifdef AUI_WARNING_FIXES
; 2441 : 					if (pkImprovement->IsOutsideBorders())
; 2442 : #else
; 2443 : 					if(GC.getImprovementInfo(eImprovement)->IsOutsideBorders())

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOutsideBorders
	test	al, al
	je	SHORT $LN24@canBuild

; 2444 : #endif
; 2445 : 					{
; 2446 : 						if (getTeam() != eTeam && getTeam() != NO_TEAM)

	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	cmp	eax, DWORD PTR $T246284[esp+32]
	je	$LN13@canBuild
	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	cmp	eax, -1
	je	$LN13@canBuild
	pop	esi
	pop	ebx
	pop	edi

; 2447 : 						{
; 2448 : 							return false;

	xor	al, al
	pop	ebp

; 2563 : }

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
$LN24@canBuild:

; 2449 : 						}
; 2450 : 					}
; 2451 : 					// In Adjacent Friendly - Can be built in or adjacent to our lands
; 2452 : #ifdef AUI_WARNING_FIXES
; 2453 : 					else if (pkImprovement->IsInAdjacentFriendly())
; 2454 : #else
; 2455 : 					else if (GC.getImprovementInfo(eImprovement)->IsInAdjacentFriendly())

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsInAdjacentFriendly
	test	al, al
	je	SHORT $LN21@canBuild

; 2456 : #endif
; 2457 : 					{
; 2458 : 						if (getTeam() != eTeam && !isAdjacentTeam(eTeam, false))

	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	mov	ecx, DWORD PTR $T246284[esp+32]
	cmp	eax, ecx
	je	SHORT $LN13@canBuild
	push	0
	push	ecx
	mov	ecx, edi
	call	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentTeam
	test	al, al
	jne	SHORT $LN13@canBuild
	pop	esi
	pop	ebx
	pop	edi
	pop	ebp

; 2563 : }

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
$LN21@canBuild:

; 2459 : 						{
; 2460 : 							return false;
; 2461 : 						}
; 2462 : 					}
; 2463 : 					// Only City State Territory - Can only be built in City-State territory (not our own lands)
; 2464 : #ifdef AUI_WARNING_FIXES
; 2465 : 					else if (pkImprovement->IsOnlyCityStateTerritory())
; 2466 : 					{
; 2467 : 						if (!isOwned() || !GET_PLAYER(getOwner()).isMinorCiv())
; 2468 : #else
; 2469 : 					else if (GC.getImprovementInfo(eImprovement)->IsOnlyCityStateTerritory())

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOnlyCityStateTerritory
	test	al, al
	je	SHORT $LN18@canBuild

; 2470 : 					{
; 2471 : 						bool bCityStateTerritory = false;
; 2472 : 						if (isOwned())

	mov	al, BYTE PTR [edi+4]
	cmp	al, -1
	je	SHORT $LN159@canBuild

; 2473 : 						{
; 2474 : 							if (GET_PLAYER(getOwner()).isMinorCiv())

	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 2475 : 							{
; 2476 : 								bCityStateTerritory = true;
; 2477 : 							}
; 2478 : 						}
; 2479 : 
; 2480 : 						if (!bCityStateTerritory)

	jne	SHORT $LN13@canBuild
$LN159@canBuild:
	pop	esi
	pop	ebx
	pop	edi

; 2481 : #endif
; 2482 : 						{
; 2483 : 							return false;

	xor	al, al
	pop	ebp

; 2563 : }

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
$LN18@canBuild:

; 2484 : 						}
; 2485 : 					}
; 2486 : 					else if(getTeam() != eTeam) 

	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	cmp	eax, DWORD PTR $T246284[esp+32]

; 2487 : 					{//only buildable in own culture
; 2488 : 						return false;

	jne	SHORT $LN159@canBuild
$LN13@canBuild:

; 2489 : 					}
; 2490 : 				}
; 2491 : 			}
; 2492 : 		}
; 2493 : 
; 2494 : 		bValid = true;

	mov	bl, 1
$LN49@canBuild:

; 2495 : #ifdef AUI_WARNING_FIXES
; 2496 : 		}
; 2497 : #endif
; 2498 : 	}
; 2499 : 
; 2500 : 	eRoute = ((RouteTypes)(GC.getBuildInfo(eBuild)->getRoute()));

	mov	edx, DWORD PTR _eBuild$[esp+28]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	ebp, eax

; 2501 : 
; 2502 : 	// Route
; 2503 : 	if(eRoute != NO_ROUTE)

	cmp	ebp, -1
	je	SHORT $LN12@canBuild

; 2504 : 	{
; 2505 : 		if(getRouteType() != NO_ROUTE)

	cmp	BYTE PTR [edi+447], -1
	je	SHORT $LN7@canBuild

; 2506 : 		{
; 2507 : 			if (isWater() && !thisBuildInfo.IsWater())

	cmp	BYTE PTR [edi+5], 3
	jne	SHORT $LN10@canBuild
	mov	ecx, DWORD PTR _thisBuildInfo$[esp+32]
	call	?IsWater@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::IsWater
	test	al, al

; 2508 : 			{
; 2509 : 				return false;

	je	SHORT $LN159@canBuild
$LN10@canBuild:

; 2510 : 			}
; 2511 : 
; 2512 : 			CvRouteInfo* pkPlotRoute = GC.getRouteInfo(getRouteType());

	movsx	eax, BYTE PTR [edi+447]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 2513 : 			CvRouteInfo* pkBuildRoute = GC.getRouteInfo(eRoute);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 2514 : 			if(pkPlotRoute && pkBuildRoute)

	test	esi, esi
	je	SHORT $LN7@canBuild
	test	eax, eax
	je	SHORT $LN7@canBuild

; 2515 : 			{
; 2516 : 				// Can't build an older, less useful Route over the top of an existing one
; 2517 : 				if(pkPlotRoute->getValue() >= pkBuildRoute->getValue())

	mov	ecx, eax
	call	?getValue@CvRouteInfo@@QBEHXZ		; CvRouteInfo::getValue
	mov	ecx, esi
	mov	ebx, eax
	call	?getValue@CvRouteInfo@@QBEHXZ		; CvRouteInfo::getValue
	cmp	eax, ebx
	jl	SHORT $LN7@canBuild

; 2518 : 				{
; 2519 : 					if(!IsRoutePillaged())

	test	BYTE PTR [edi+461], 2

; 2520 : 					{
; 2521 : 						return false;

	je	$LN159@canBuild
$LN7@canBuild:

; 2522 : 					}
; 2523 : 				}
; 2524 : 			}
; 2525 : 		}
; 2526 : 
; 2527 : 		bValid = true;

	mov	bl, 1
$LN12@canBuild:

; 2528 : 	}
; 2529 : 
; 2530 : 	// In general, cannot clear features in the lands of players that aren't on our team or that we're at war with
; 2531 : 	if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	$LN5@canBuild

; 2532 : 	{
; 2533 : 		if(GC.getBuildInfo(eBuild)->isFeatureRemove(getFeatureType()))

	mov	ecx, DWORD PTR _eBuild$[esp+28]
	movsx	eax, al
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	SHORT $LN5@canBuild

; 2534 : 		{
; 2535 : 			if(bTestPlotOwner)

	cmp	BYTE PTR _bTestPlotOwner$[esp+28], 0
	je	SHORT $LN1@canBuild

; 2536 : 			{
; 2537 : 				if(isOwned() && (eTeam != getTeam()) && !atWar(eTeam, getTeam()))

	cmp	BYTE PTR [edi+4], -1
	je	SHORT $LN1@canBuild
	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	mov	esi, DWORD PTR $T246284[esp+32]
	cmp	esi, eax
	je	SHORT $LN1@canBuild
	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	push	eax
	push	esi
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	jne	SHORT $LN1@canBuild

; 2538 : 				{
; 2539 : 					if (eImprovement == NO_IMPROVEMENT)

	mov	esi, DWORD PTR _eImprovement$[esp+32]
	cmp	esi, -1

; 2540 : 					{
; 2541 : 						return false;

	je	$LN159@canBuild

; 2542 : 					}
; 2543 : 
; 2544 : 					// Some improvements are exceptions
; 2545 : #ifdef AUI_WARNING_FIXES
; 2546 : 					CvImprovementEntry *pkImprovement = GC.getImprovementInfo(eImprovement);
; 2547 : 					if (pkImprovement && !pkImprovement->IsIgnoreOwnership() && !pkImprovement->IsOnlyCityStateTerritory())
; 2548 : #else
; 2549 : 					if (!GC.getImprovementInfo(eImprovement)->IsIgnoreOwnership() &&
; 2550 : 						!GC.getImprovementInfo(eImprovement)->IsOnlyCityStateTerritory())

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsIgnoreOwnership
	test	al, al
	jne	SHORT $LN1@canBuild
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOnlyCityStateTerritory
	test	al, al

; 2551 : #endif
; 2552 : 					{
; 2553 : 						return false;

	je	$LN159@canBuild
$LN1@canBuild:

; 2554 : 					}
; 2555 : 				}
; 2556 : 			}
; 2557 : 
; 2558 : 			bValid = true;

	mov	bl, 1
$LN5@canBuild:
	pop	esi

; 2559 : 		}
; 2560 : 	}
; 2561 : 
; 2562 : 	return bValid;

	mov	al, bl
	pop	ebx
	pop	edi
	pop	ebp

; 2563 : }

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ENDP ; CvPlot::canBuild
_TEXT	ENDS
PUBLIC	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
; Function compile flags: /Ogtpy
;	COMDAT ?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
_TEXT	SEGMENT
$T246463 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_eOwner$ = 12						; size = 4
_eAttackingPlayer$ = 16					; size = 4
_pAttacker$ = 20					; size = 4
_bTestAtWar$ = 24					; size = 1
_bTestPotentialEnemy$ = 28				; size = 1
_bTestCanMove$ = 32					; size = 1
_bNoncombatAllowed$ = 36				; size = 1
?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z PROC ; CvPlot::getBestDefender, COMDAT
; _this$ = ecx

; 2919 : {

	push	ecx

; 2920 : 	// accesses another internal method, user code sees this (mutable) method and const guarantees are maintained
; 2921 : 	return (const_cast<const CvPlot*>(this)->getBestDefender(eOwner, eAttackingPlayer, pAttacker, bTestAtWar, bTestPotentialEnemy, bTestCanMove, bNoncombatAllowed));

	mov	eax, DWORD PTR _bNoncombatAllowed$[esp]
	mov	edx, DWORD PTR _bTestCanMove$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	eax
	mov	eax, DWORD PTR _bTestPotentialEnemy$[esp+8]
	push	edx
	mov	edx, DWORD PTR _bTestAtWar$[esp+12]
	push	eax
	mov	eax, DWORD PTR _pAttacker$[esp+16]
	push	edx
	mov	edx, DWORD PTR _eAttackingPlayer$[esp+20]
	push	eax
	mov	eax, DWORD PTR _eOwner$[esp+24]
	push	edx
	push	eax
	push	esi
	mov	DWORD PTR $T246463[esp+40], 0
	call	?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	eax, esi
	pop	esi

; 2922 : }

	pop	ecx
	ret	32					; 00000020H
?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ENDP ; CvPlot::getBestDefender
_TEXT	ENDS
PUBLIC	?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ	; CvPlot::getSelectedUnit
; Function compile flags: /Ogtpy
;	COMDAT ?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ PROC		; CvPlot::getSelectedUnit, COMDAT
; _this$ = ecx

; 2976 : 	return const_cast<CvUnit*>(const_cast<const CvPlot*>(this)->getSelectedUnit());

	jmp	?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ ; CvPlot::getSelectedUnit
?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ ENDP		; CvPlot::getSelectedUnit
_TEXT	ENDS
PUBLIC	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
; Function compile flags: /Ogtpy
;	COMDAT ?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_func$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvPlot::plotAction, COMDAT
; _this$ = ecx

; 3365 : {

	push	ebx
	mov	ebx, ecx

; 3366 : 	IDInfo* pUnitNode;
; 3367 : 	CvUnit* pLoopUnit;
; 3368 : 
; 3369 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], 0
	push	esi
	jbe	SHORT $LN13@plotAction
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN12@plotAction
$LN13@plotAction:
	xor	esi, esi
$LN12@plotAction:

; 3370 : 
; 3371 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN6@plotAction
	push	ebp

; 3374 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ebp, DWORD PTR _eTeam$[esp+8]
	push	edi
	npad	1
$LL7@plotAction:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN20@plotAction

; 3372 : 	{
; 3373 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	cmp	eax, 64					; 00000040H
	jge	SHORT $LN20@plotAction
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN21@plotAction
$LN20@plotAction:
	xor	edi, edi
$LN21@plotAction:

; 3374 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN32@plotAction
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN31@plotAction
$LN32@plotAction:
	xor	esi, esi
$LN31@plotAction:

; 3375 : 
; 3376 : 		if(pLoopUnit)

	test	edi, edi
	je	SHORT $LN44@plotAction

; 3377 : 		{
; 3378 : 			if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	mov	eax, DWORD PTR _eOwner$[esp+12]
	cmp	eax, -1
	je	SHORT $LN3@plotAction
	cmp	DWORD PTR [edi+40], eax
	jne	SHORT $LN44@plotAction
$LN3@plotAction:

; 3379 : 			{
; 3380 : 				if((eTeam == NO_TEAM) || (pLoopUnit->getTeam() == eTeam))

	cmp	ebp, -1
	je	SHORT $LN1@plotAction
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, ebp
	jne	SHORT $LN44@plotAction
$LN1@plotAction:

; 3381 : 				{
; 3382 : 					func(pLoopUnit, iData1, iData2);

	mov	eax, DWORD PTR _iData2$[esp+12]
	mov	ecx, DWORD PTR _iData1$[esp+12]
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR _func$[esp+24]
	add	esp, 12					; 0000000cH
$LN44@plotAction:

; 3370 : 
; 3371 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL7@plotAction
	pop	edi
	pop	ebp
$LN6@plotAction:
	pop	esi
	pop	ebx

; 3383 : 				}
; 3384 : 			}
; 3385 : 		}
; 3386 : 	}
; 3387 : }

	ret	20					; 00000014H
?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::plotAction
_TEXT	ENDS
PUBLIC	?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z
_TEXT	SEGMENT
_funcA$ = 8						; size = 4
_iData1A$ = 12						; size = 4
_iData2A$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
_funcB$ = 28						; size = 4
_iData1B$ = 32						; size = 4
_iData2B$ = 36						; size = 4
?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z PROC ; CvPlot::plotCheck, COMDAT
; _this$ = ecx

; 3436 : {

	push	ebx
	push	ebp
	mov	ebx, ecx

; 3437 : 	IDInfo* pUnitNode;
; 3438 : 	CvUnit* pLoopUnit;
; 3439 : 
; 3440 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], 0
	push	esi
	push	edi
	jbe	SHORT $LN16@plotCheck
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN15@plotCheck
$LN16@plotCheck:
	xor	esi, esi
$LN15@plotCheck:

; 3441 : 
; 3442 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN9@plotCheck

; 3445 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ebp, DWORD PTR _funcB$[esp+12]
	npad	1
$LL10@plotCheck:

; 3443 : 	{
; 3444 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN23@plotCheck
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN23@plotCheck
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	edi, eax
	jmp	SHORT $LN24@plotCheck
$LN23@plotCheck:
	xor	edi, edi
$LN24@plotCheck:

; 3445 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN35@plotCheck
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN34@plotCheck
$LN35@plotCheck:
	xor	esi, esi
$LN34@plotCheck:

; 3446 : 
; 3447 : 		if(pLoopUnit)

	test	edi, edi
	je	SHORT $LN47@plotCheck

; 3448 : 		{
; 3449 : 			if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	mov	eax, DWORD PTR _eOwner$[esp+12]
	cmp	eax, -1
	je	SHORT $LN6@plotCheck
	cmp	DWORD PTR [edi+40], eax
	jne	SHORT $LN47@plotCheck
$LN6@plotCheck:

; 3450 : 			{
; 3451 : 				if((eTeam == NO_TEAM) || (pLoopUnit->getTeam() == eTeam))

	cmp	DWORD PTR _eTeam$[esp+12], -1
	je	SHORT $LN4@plotCheck
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eTeam$[esp+12]
	jne	SHORT $LN47@plotCheck
$LN4@plotCheck:

; 3452 : 				{
; 3453 : 					if(funcA(pLoopUnit, iData1A, iData2A))

	mov	eax, DWORD PTR _iData2A$[esp+12]
	mov	ecx, DWORD PTR _iData1A$[esp+12]
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR _funcA$[esp+24]
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN47@plotCheck

; 3454 : 					{
; 3455 : 						if((funcB == NULL) || funcB(pLoopUnit, iData1B, iData2B))

	test	ebp, ebp
	je	SHORT $LN1@plotCheck
	mov	edx, DWORD PTR _iData2B$[esp+12]
	mov	eax, DWORD PTR _iData1B$[esp+12]
	push	edx
	push	eax
	push	edi
	call	ebp
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN1@plotCheck
$LN47@plotCheck:

; 3441 : 
; 3442 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL10@plotCheck
$LN9@plotCheck:
	pop	edi
	pop	esi
	pop	ebp

; 3458 : 						}
; 3459 : 					}
; 3460 : 				}
; 3461 : 			}
; 3462 : 		}
; 3463 : 	}
; 3464 : 
; 3465 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 3466 : }

	ret	32					; 00000020H
$LN1@plotCheck:

; 3456 : 						{
; 3457 : 							return pLoopUnit;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3466 : }

	ret	32					; 00000020H
?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ENDP ; CvPlot::plotCheck
_TEXT	ENDS
PUBLIC	?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::IsActualEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_bCombatUnitsOnly$ = 12					; size = 1
?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z PROC ; CvPlot::IsActualEnemyUnit, COMDAT
; _this$ = ecx

; 4137 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN16@IsActualEn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN17@IsActualEn
$LN16@IsActualEn:
	or	eax, -1
$LN17@IsActualEn:

; 4138 : 	CvTeam& kTeam = GET_TEAM(eTeam);

	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 4139 : 
; 4140 : #ifdef AUI_WARNING_FIXES
; 4141 : 	for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 4142 : #else
; 4143 : 	for(int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	xor	edi, edi
	cmp	edi, DWORD PTR [ebp+28]
	mov	ebx, eax
	jge	SHORT $LN5@IsActualEn
$LN56@IsActualEn:

; 4144 : #endif
; 4145 : 	{
; 4146 : 		CvUnit* pkUnit = getUnitByIndex(iUnitLoop);

	jae	SHORT $LN6@IsActualEn
	mov	edx, DWORD PTR [ebp+24]
	lea	edx, DWORD PTR [edx+edi*8]
	test	edx, edx
	je	SHORT $LN6@IsActualEn
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jl	SHORT $LN6@IsActualEn
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN6@IsActualEn
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	esi, eax

; 4147 : 		if(pkUnit)

	test	esi, esi
	je	SHORT $LN6@IsActualEn

; 4148 : 		{
; 4149 : 			if(kTeam.isAtWar(pkUnit->getTeam()))

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, ebx
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN6@IsActualEn

; 4150 : 			{
; 4151 : 				if(!bCombatUnitsOnly || pkUnit->IsCombatUnit())

	cmp	BYTE PTR _bCombatUnitsOnly$[esp+12], 0
	je	SHORT $LN1@IsActualEn
	cmp	DWORD PTR [esi+1044], 0
	jg	SHORT $LN1@IsActualEn
$LN6@IsActualEn:

; 4139 : 
; 4140 : #ifdef AUI_WARNING_FIXES
; 4141 : 	for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 4142 : #else
; 4143 : 	for(int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	inc	edi
	cmp	edi, DWORD PTR [ebp+28]
	jl	SHORT $LN56@IsActualEn
$LN5@IsActualEn:
	pop	edi
	pop	esi
	pop	ebp

; 4154 : 				}
; 4155 : 			}
; 4156 : 		}
; 4157 : 	}
; 4158 : 
; 4159 : 	return false;

	xor	al, al
	pop	ebx

; 4160 : }

	ret	8
$LN1@IsActualEn:
	pop	edi
	pop	esi
	pop	ebp

; 4152 : 				{
; 4153 : 					return true;

	mov	al, 1
	pop	ebx

; 4160 : }

	ret	8
?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ENDP ; CvPlot::IsActualEnemyUnit
_TEXT	ENDS
PUBLIC	?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z	; CvPlot::HasAlliedUnit
; Function compile flags: /Ogtpy
;	COMDAT ?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
$T246820 = 8						; size = 4
_ePlayer$ = 8						; size = 4
_bCombatUnitsOnly$ = 12					; size = 1
?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z PROC	; CvPlot::HasAlliedUnit, COMDAT
; _this$ = ecx

; 4165 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	push	ebx
	push	ebp
	mov	ebp, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	push	esi
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN16@HasAlliedU
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T246820[esp+12], edx
	jmp	SHORT $LN17@HasAlliedU
$LN16@HasAlliedU:
	mov	DWORD PTR $T246820[esp+12], -1
$LN17@HasAlliedU:

; 4166 : 
; 4167 : #ifdef AUI_WARNING_FIXES
; 4168 : 	for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 4169 : #else
; 4170 : 	for (int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	xor	edi, edi
	cmp	edi, DWORD PTR [ebp+28]
	jge	SHORT $LN5@HasAlliedU

; 4171 : #endif
; 4172 : 	{
; 4173 : 		CvUnit* pkUnit = getUnitByIndex(iUnitLoop);

	mov	bl, BYTE PTR _bCombatUnitsOnly$[esp+12]
$LN54@HasAlliedU:
	jae	SHORT $LN6@HasAlliedU
	mov	eax, DWORD PTR [ebp+24]
	lea	edx, DWORD PTR [eax+edi*8]
	test	edx, edx
	je	SHORT $LN6@HasAlliedU
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jl	SHORT $LN6@HasAlliedU
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN6@HasAlliedU
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	esi, eax

; 4174 : 		if (pkUnit)

	test	esi, esi
	je	SHORT $LN6@HasAlliedU

; 4175 : 		{
; 4176 : 			if (pkUnit->getTeam() == eTeam)

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR $T246820[esp+12]
	jne	SHORT $LN6@HasAlliedU

; 4177 : 			{
; 4178 : 				if (!bCombatUnitsOnly || pkUnit->IsCombatUnit())

	test	bl, bl
	je	SHORT $LN1@HasAlliedU
	cmp	DWORD PTR [esi+1044], 0
	jg	SHORT $LN1@HasAlliedU
$LN6@HasAlliedU:

; 4166 : 
; 4167 : #ifdef AUI_WARNING_FIXES
; 4168 : 	for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 4169 : #else
; 4170 : 	for (int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	inc	edi
	cmp	edi, DWORD PTR [ebp+28]
	jl	SHORT $LN54@HasAlliedU
$LN5@HasAlliedU:
	pop	edi
	pop	esi
	pop	ebp

; 4181 : 				}
; 4182 : 			}
; 4183 : 		}
; 4184 : 	}
; 4185 : 
; 4186 : 	return false;

	xor	al, al
	pop	ebx

; 4187 : }

	ret	8
$LN1@HasAlliedU:
	pop	edi
	pop	esi
	pop	ebp

; 4179 : 				{
; 4180 : 					return true;

	mov	al, 1
	pop	ebx

; 4187 : }

	ret	8
?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ENDP	; CvPlot::HasAlliedUnit
_TEXT	ENDS
PUBLIC	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation
EXTRN	?canLoad@CvUnit@@QBE_NABVCvPlot@@@Z:PROC	; CvUnit::canLoad
; Function compile flags: /Ogtpy
;	COMDAT ?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z PROC ; CvPlot::isValidDomainForLocation, COMDAT
; _this$ = ecx

; 4470 : {

	push	esi
	push	edi

; 4471 : 	if(isValidDomainForAction(unit))

	mov	edi, DWORD PTR _unit$[esp+4]
	push	edi
	mov	esi, ecx
	call	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction
	test	al, al
	je	SHORT $LN2@isValidDom@2
$LN10@isValidDom@2:
	pop	edi

; 4472 : 	{
; 4473 : 		return true;

	mov	al, 1
	pop	esi

; 4482 : }

	ret	4
$LN2@isValidDom@2:

; 4474 : 	}
; 4475 : 
; 4476 : 	if (unit.getDomainType() == DOMAIN_AIR && unit.canLoad(*this))

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN1@isValidDom@2
	push	esi
	mov	ecx, edi
	call	?canLoad@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::canLoad
	test	al, al

; 4477 : 	{
; 4478 : 		return true;

	jne	SHORT $LN10@isValidDom@2
$LN1@isValidDom@2:

; 4479 : 	}
; 4480 : 
; 4481 : 	return isCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN5@isValidDom@2
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN5@isValidDom@2
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	pop	edi
	setne	al
	pop	esi

; 4482 : }

	ret	4

; 4479 : 	}
; 4480 : 
; 4481 : 	return isCity();

$LN5@isValidDom@2:
	pop	edi
	xor	al, al
	pop	esi

; 4482 : }

	ret	4
?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ENDP ; CvPlot::isValidDomainForLocation
_TEXT	ENDS
PUBLIC	?setArea@CvPlot@@QAEXH@Z			; CvPlot::setArea
; Function compile flags: /Ogtpy
;	COMDAT ?setArea@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setArea@CvPlot@@QAEXH@Z PROC				; CvPlot::setArea, COMDAT
; _this$ = ecx

; 4625 : {

	push	esi
	push	edi

; 4626 : 	bool bOldLake;
; 4627 : 
; 4628 : 	if(getArea() != iNewValue)

	mov	edi, DWORD PTR _iNewValue$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+356], edi
	je	$LN1@setArea

; 4629 : 	{
; 4630 : 		bOldLake = isLake();

	mov	eax, DWORD PTR [esi+360]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	test	eax, eax
	je	SHORT $LN8@setArea
	mov	ecx, eax
	call	?isLake@CvLandmass@@QBE_NXZ		; CvLandmass::isLake
$LN8@setArea:

; 4631 : 
; 4632 : 		if(area() != NULL)

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN2@setArea

; 4633 : 		{
; 4634 : 			processArea(area(), -1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	push	eax
	mov	ecx, esi
	call	?processArea@CvPlot@@IAEXPAVCvArea@@H@Z	; CvPlot::processArea
$LN2@setArea:

; 4635 : 		}
; 4636 : 
; 4637 : 		m_iArea = iNewValue;

	mov	DWORD PTR [esi+356], edi

; 4638 : 
; 4639 : 		if(area() != NULL)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN1@setArea

; 4640 : 		{
; 4641 : 			processArea(area(), 1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	push	eax
	mov	ecx, esi
	call	?processArea@CvPlot@@IAEXPAVCvArea@@H@Z	; CvPlot::processArea

; 4642 : 
; 4643 : 			updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN1@setArea:
	pop	edi
	pop	esi

; 4644 : 		}
; 4645 : 	}
; 4646 : }

	ret	4
?setArea@CvPlot@@QAEXH@Z ENDP				; CvPlot::setArea
_TEXT	ENDS
PUBLIC	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
_eRiverDir$ = 12					; size = 4
?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z PROC ; CvPlot::setNEOfRiver, COMDAT
; _this$ = ecx

; 4894 : 	CvPlot* pAdjacentPlot;
; 4895 : 	int iI;
; 4896 : 
; 4897 : 	if((isNEOfRiver() != bNewValue) || (eRiverDir != m_eRiverSWFlowDirection))

	mov	al, BYTE PTR _bNewValue$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	dl, BYTE PTR [edi+461]
	mov	cl, dl
	shr	cl, 4
	and	cl, 1
	cmp	cl, al
	jne	SHORT $LN50@setNEOfRiv
	movsx	esi, BYTE PTR [edi+452]
	cmp	DWORD PTR _eRiverDir$[esp+4], esi
	je	$LN8@setNEOfRiv

; 4898 : 	{
; 4899 : 		CvAssertMsg(m_eRiverSWFlowDirection == NO_FLOWDIRECTION && eRiverDir != NO_FLOWDIRECTION, "invalid parameter");
; 4900 : 		if(isNEOfRiver() != bNewValue)

	cmp	cl, al
	je	$LN1@setNEOfRiv
$LN50@setNEOfRiv:

; 4901 : 		{
; 4902 : 			m_bNEOfRiver = bNewValue;

	shl	al, 4
	xor	al, dl
	and	al, 16					; 00000010H
	xor	al, dl
	mov	BYTE PTR [edi+461], al

; 4903 : 
; 4904 : 			updateRiverCrossing();

	xor	esi, esi
$LL17@setNEOfRiv:
	push	esi
	mov	ecx, edi
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL17@setNEOfRiv
	push	ebx
	push	ebp

; 4905 : 			updateYield();

	mov	ecx, edi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 4906 : 
; 4907 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebx, ebx
	npad	3
$LL5@setNEOfRiv:

; 4908 : 			{
; 4909 : 				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebp, eax
	add	esp, 12					; 0000000cH

; 4910 : 
; 4911 : 				if(pAdjacentPlot != NULL)

	test	ebp, ebp
	je	SHORT $LN4@setNEOfRiv

; 4912 : 				{
; 4913 : 					pAdjacentPlot->updateRiverCrossing();

	xor	esi, esi
	npad	6
$LL26@setNEOfRiv:
	push	esi
	mov	ecx, ebp
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL26@setNEOfRiv

; 4914 : 					pAdjacentPlot->updateYield();

	mov	ecx, ebp
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN4@setNEOfRiv:
	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL5@setNEOfRiv

; 4915 : 				}
; 4916 : 			}
; 4917 : 
; 4918 : 			if(area() != NULL)

	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	pop	ebp
	pop	ebx
	test	eax, eax
	je	SHORT $LN1@setNEOfRiv

; 4919 : 			{
; 4920 : 				area()->changeNumRiverEdges((isNEOfRiver()) ? 1 : -1);

	mov	dl, BYTE PTR [edi+461]
	mov	eax, DWORD PTR [edi+356]
	shr	dl, 4
	and	dl, 1
	mov	ecx, 0
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN1@setNEOfRiv:

; 4921 : 			}
; 4922 : 		}
; 4923 : 
; 4924 : 		CvAssertMsg(eRiverDir == FLOWDIRECTION_NORTHWEST || eRiverDir == FLOWDIRECTION_SOUTHEAST || eRiverDir == NO_FLOWDIRECTION, "invalid parameter");
; 4925 : 		m_eRiverSWFlowDirection = eRiverDir;

	mov	dl, BYTE PTR _eRiverDir$[esp+4]
	mov	BYTE PTR [edi+452], dl
$LN8@setNEOfRiv:
	pop	edi
	pop	esi

; 4926 : 	}
; 4927 : }

	ret	8
?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ENDP ; CvPlot::setNEOfRiver
_TEXT	ENDS
PUBLIC	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
_eRiverDir$ = 12					; size = 4
?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z PROC ; CvPlot::setWOfRiver, COMDAT
; _this$ = ecx

; 4940 : 	CvPlot* pAdjacentPlot;
; 4941 : 	int iI;
; 4942 : 
; 4943 : 	if((isWOfRiver() != bNewValue) || (eRiverDir != m_eRiverEFlowDirection))

	mov	al, BYTE PTR _bNewValue$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	dl, BYTE PTR [edi+461]
	mov	cl, dl
	shr	cl, 5
	and	cl, 1
	cmp	cl, al
	jne	SHORT $LN50@setWOfRive
	movsx	esi, BYTE PTR [edi+450]
	cmp	DWORD PTR _eRiverDir$[esp+4], esi
	je	$LN8@setWOfRive

; 4944 : 	{
; 4945 : 		CvAssertMsg(m_eRiverEFlowDirection == NO_FLOWDIRECTION && eRiverDir != NO_FLOWDIRECTION, "invalid parameter");
; 4946 : 		if(isWOfRiver() != bNewValue)

	cmp	cl, al
	je	$LN1@setWOfRive
$LN50@setWOfRive:

; 4947 : 		{
; 4948 : 			m_bWOfRiver = bNewValue;

	shl	al, 5
	xor	al, dl
	and	al, 32					; 00000020H
	xor	al, dl
	mov	BYTE PTR [edi+461], al

; 4949 : 
; 4950 : 			updateRiverCrossing();

	xor	esi, esi
$LL17@setWOfRive:
	push	esi
	mov	ecx, edi
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL17@setWOfRive
	push	ebx
	push	ebp

; 4951 : 			updateYield();

	mov	ecx, edi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 4952 : 
; 4953 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebx, ebx
	npad	3
$LL5@setWOfRive:

; 4954 : 			{
; 4955 : 				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebp, eax
	add	esp, 12					; 0000000cH

; 4956 : 
; 4957 : 				if(pAdjacentPlot != NULL)

	test	ebp, ebp
	je	SHORT $LN4@setWOfRive

; 4958 : 				{
; 4959 : 					pAdjacentPlot->updateRiverCrossing();

	xor	esi, esi
	npad	6
$LL26@setWOfRive:
	push	esi
	mov	ecx, ebp
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL26@setWOfRive

; 4960 : 					pAdjacentPlot->updateYield();

	mov	ecx, ebp
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN4@setWOfRive:
	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL5@setWOfRive

; 4961 : 				}
; 4962 : 			}
; 4963 : 
; 4964 : 			if(area())

	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	pop	ebp
	pop	ebx
	test	eax, eax
	je	SHORT $LN1@setWOfRive

; 4965 : 			{
; 4966 : 				area()->changeNumRiverEdges((isWOfRiver()) ? 1 : -1);

	mov	dl, BYTE PTR [edi+461]
	mov	eax, DWORD PTR [edi+356]
	shr	dl, 5
	and	dl, 1
	mov	ecx, 0
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN1@setWOfRive:

; 4967 : 			}
; 4968 : 		}
; 4969 : 
; 4970 : 		CvAssertMsg(eRiverDir == FLOWDIRECTION_NORTH || eRiverDir == FLOWDIRECTION_SOUTH || eRiverDir == NO_FLOWDIRECTION, "invalid parameter");
; 4971 : 		m_eRiverEFlowDirection= eRiverDir;

	mov	dl, BYTE PTR _eRiverDir$[esp+4]
	mov	BYTE PTR [edi+450], dl
$LN8@setWOfRive:
	pop	edi
	pop	esi

; 4972 : 	}
; 4973 : }

	ret	8
?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ENDP ; CvPlot::setWOfRiver
_TEXT	ENDS
PUBLIC	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
_eRiverDir$ = 12					; size = 4
?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z PROC ; CvPlot::setNWOfRiver, COMDAT
; _this$ = ecx

; 4986 : 	CvPlot* pAdjacentPlot;
; 4987 : 	int iI;
; 4988 : 
; 4989 : 	if((isNWOfRiver() != bNewValue) || (eRiverDir != m_eRiverSEFlowDirection))

	mov	al, BYTE PTR _bNewValue$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	dl, BYTE PTR [edi+461]
	mov	cl, dl
	shr	cl, 6
	and	cl, 1
	cmp	cl, al
	jne	SHORT $LN50@setNWOfRiv
	movsx	esi, BYTE PTR [edi+451]
	cmp	DWORD PTR _eRiverDir$[esp+4], esi
	je	$LN8@setNWOfRiv

; 4990 : 	{
; 4991 : 		CvAssertMsg(m_eRiverSEFlowDirection == NO_FLOWDIRECTION && eRiverDir != NO_FLOWDIRECTION, "invalid parameter");
; 4992 : 		if(isNWOfRiver() != bNewValue)

	cmp	cl, al
	je	$LN1@setNWOfRiv
$LN50@setNWOfRiv:

; 4993 : 		{
; 4994 : 			m_bNWOfRiver = bNewValue;

	shl	al, 6
	xor	al, dl
	and	al, 64					; 00000040H
	xor	al, dl
	mov	BYTE PTR [edi+461], al

; 4995 : 
; 4996 : 			updateRiverCrossing();

	xor	esi, esi
$LL17@setNWOfRiv:
	push	esi
	mov	ecx, edi
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL17@setNWOfRiv
	push	ebx
	push	ebp

; 4997 : 			updateYield();

	mov	ecx, edi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 4998 : 
; 4999 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebx, ebx
	npad	3
$LL5@setNWOfRiv:

; 5000 : 			{
; 5001 : 				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	ebx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebp, eax
	add	esp, 12					; 0000000cH

; 5002 : 
; 5003 : 				if(pAdjacentPlot != NULL)

	test	ebp, ebp
	je	SHORT $LN4@setNWOfRiv

; 5004 : 				{
; 5005 : 					pAdjacentPlot->updateRiverCrossing();

	xor	esi, esi
	npad	6
$LL26@setNWOfRiv:
	push	esi
	mov	ecx, ebp
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	inc	esi
	cmp	esi, 6
	jl	SHORT $LL26@setNWOfRiv

; 5006 : 					pAdjacentPlot->updateYield();

	mov	ecx, ebp
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN4@setNWOfRiv:
	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL5@setNWOfRiv

; 5007 : 				}
; 5008 : 			}
; 5009 : 
; 5010 : 			if(area())

	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	pop	ebp
	pop	ebx
	test	eax, eax
	je	SHORT $LN1@setNWOfRiv

; 5011 : 			{
; 5012 : 				area()->changeNumRiverEdges((isNWOfRiver()) ? 1 : -1);

	mov	dl, BYTE PTR [edi+461]
	mov	eax, DWORD PTR [edi+356]
	shr	dl, 6
	and	dl, 1
	mov	ecx, 0
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN1@setNWOfRiv:

; 5013 : 			}
; 5014 : 		}
; 5015 : 
; 5016 : 		CvAssertMsg(eRiverDir == FLOWDIRECTION_NORTHEAST || eRiverDir == FLOWDIRECTION_SOUTHWEST || eRiverDir == NO_FLOWDIRECTION, "invalid parameter");
; 5017 : 		m_eRiverSEFlowDirection = eRiverDir;

	mov	dl, BYTE PTR _eRiverDir$[esp+4]
	mov	BYTE PTR [edi+451], dl
$LN8@setNWOfRiv:
	pop	edi
	pop	esi

; 5018 : 	}
; 5019 : }

	ret	8
?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ENDP ; CvPlot::setNWOfRiver
_TEXT	ENDS
PUBLIC	?getInlandCorner@CvPlot@@QBEPAV1@XZ		; CvPlot::getInlandCorner
EXTRN	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z:PROC	; shuffleArray
EXTRN	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ:PROC	; CvGame::getMapRand
; Function compile flags: /Ogtpy
;	COMDAT ?getInlandCorner@CvPlot@@QBEPAV1@XZ
_TEXT	SEGMENT
_iI$224618 = -20					; size = 4
_aiShuffle$ = -16					; size = 16
?getInlandCorner@CvPlot@@QBEPAV1@XZ PROC		; CvPlot::getInlandCorner, COMDAT
; _this$ = ecx

; 5047 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	ebx, ecx

; 5048 : 	CvPlot* pRiverPlot = NULL; // will be a plot through whose SE corner we want the river to run
; 5049 : 	int aiShuffle[4];
; 5050 : 
; 5051 : 	shuffleArray(aiShuffle, 4, GC.getGame().getMapRand());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getMapRand
	push	eax
	lea	eax, DWORD PTR _aiShuffle$[esp+40]
	push	4
	push	eax
	call	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z	; shuffleArray
	add	esp, 12					; 0000000cH

; 5052 : 
; 5053 : 	for(int iI = 0; iI < 4; ++iI)

	xor	edi, edi
	mov	DWORD PTR _iI$224618[esp+36], edi
	npad	6
$LL11@getInlandC:

; 5054 : 	{
; 5055 : 		switch(aiShuffle[iI])

	mov	eax, DWORD PTR _aiShuffle$[esp+edi*4+36]
	cmp	eax, 3
	ja	$LN2@getInlandC
	jmp	DWORD PTR $LN68@getInlandC[eax*4]
$LN6@getInlandC:

; 5056 : 		{
; 5057 : 		case 0:
; 5058 : 			pRiverPlot = GC.getMap().plotCheckInvalid(getX(), getY());

	movsx	eax, WORD PTR [ebx]
	movsx	ecx, WORD PTR [ebx+2]
	cmp	eax, -2147483647			; 80000001H
	je	$LN2@getInlandC
	cmp	ecx, -2147483647			; 80000001H
	je	$LN2@getInlandC
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4020]
	imul	esi, ecx
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [edx+4068]
	jmp	SHORT $LN7@getInlandC
$LN5@getInlandC:

; 5059 : 			break;
; 5060 : 		case 1:
; 5061 : 			pRiverPlot = plotDirection(getX(), getY(), DIRECTION_NORTH);

	movsx	ecx, WORD PTR [ebx+2]
	movsx	edx, WORD PTR [ebx]
	push	0
	push	ecx
	push	edx

; 5062 : 			break;

	jmp	SHORT $LN67@getInlandC
$LN4@getInlandC:

; 5063 : 		case 2:
; 5064 : 			pRiverPlot = plotDirection(getX(), getY(), DIRECTION_NORTHWEST);

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	5
	push	eax
	push	ecx

; 5065 : 			break;

	jmp	SHORT $LN67@getInlandC
$LN3@getInlandC:

; 5066 : 		case 3:
; 5067 : 			pRiverPlot = plotDirection(getX(), getY(), DIRECTION_WEST);

	movsx	edx, WORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx]
	push	4
	push	edx
	push	eax
$LN67@getInlandC:
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	esi, eax
$LN7@getInlandC:

; 5068 : 			break;
; 5069 : 		}
; 5070 : 		if(pRiverPlot != NULL && !pRiverPlot->hasCoastAtSECorner())

	test	esi, esi
	je	SHORT $LN2@getInlandC
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN2@getInlandC
	movsx	edi, WORD PTR [esi+2]
	movsx	ebp, WORD PTR [esi]
	push	1
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN43@getInlandC
	cmp	BYTE PTR [eax+5], 3
	je	SHORT $LN66@getInlandC
$LN43@getInlandC:
	push	2
	push	edi
	push	ebp
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN65@getInlandC
	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN65@getInlandC
$LN66@getInlandC:
	mov	edi, DWORD PTR _iI$224618[esp+36]
$LN2@getInlandC:

; 5052 : 
; 5053 : 	for(int iI = 0; iI < 4; ++iI)

	inc	edi

; 5071 : 		{
; 5072 : 			break;
; 5073 : 		}
; 5074 : 		else
; 5075 : 		{
; 5076 : 			pRiverPlot = NULL;

	xor	eax, eax
	cmp	edi, 4
	mov	DWORD PTR _iI$224618[esp+36], edi
	jl	$LL11@getInlandC
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5081 : }

	add	esp, 20					; 00000014H
	ret	0
$LN65@getInlandC:
	pop	edi

; 5077 : 		}
; 5078 : 	}
; 5079 : 
; 5080 : 	return pRiverPlot;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 5081 : }

	add	esp, 20					; 00000014H
	ret	0
	npad	1
$LN68@getInlandC:
	DD	$LN6@getInlandC
	DD	$LN5@getInlandC
	DD	$LN4@getInlandC
	DD	$LN3@getInlandC
?getInlandCorner@CvPlot@@QBEPAV1@XZ ENDP		; CvPlot::getInlandCorner
_TEXT	ENDS
PUBLIC	?updatePotentialCityWork@CvPlot@@QAEXXZ		; CvPlot::updatePotentialCityWork
; Function compile flags: /Ogtpy
;	COMDAT ?updatePotentialCityWork@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?updatePotentialCityWork@CvPlot@@QAEXXZ PROC		; CvPlot::updatePotentialCityWork, COMDAT
; _this$ = ecx

; 5145 : {

	push	ebx
	push	esi
	push	edi

; 5146 : 	CvPlot* pLoopPlot;
; 5147 : 	bool bValid;
; 5148 : 	int iI;
; 5149 : 
; 5150 : 	bValid = false;

	xor	bl, bl
	mov	esi, ecx

; 5151 : 
; 5152 : 	for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	xor	edi, edi
	npad	7
$LL6@updatePote:

; 5153 : 	{
; 5154 : 		pLoopPlot = plotCity(getX(), getY(), iI);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 5155 : 
; 5156 : 		if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN5@updatePote

; 5157 : 		{
; 5158 : 			if(!(pLoopPlot->isWater()))

	cmp	BYTE PTR [eax+5], 3
	jne	SHORT $LN18@updatePote
$LN5@updatePote:

; 5151 : 
; 5152 : 	for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	inc	edi
	cmp	edi, 37					; 00000025H
	jl	SHORT $LL6@updatePote

; 5157 : 		{
; 5158 : 			if(!(pLoopPlot->isWater()))

	jmp	SHORT $LN4@updatePote
$LN18@updatePote:

; 5159 : 			{
; 5160 : 				bValid = true;

	mov	bl, 1
$LN4@updatePote:

; 5161 : 				break;
; 5162 : 			}
; 5163 : 		}
; 5164 : 	}
; 5165 : 
; 5166 : 	if(isPotentialCityWork() != bValid)

	mov	al, BYTE PTR [esi+461]
	mov	cl, al
	shr	cl, 7
	pop	edi
	cmp	cl, bl
	je	SHORT $LN1@updatePote

; 5167 : 	{
; 5168 : 		m_bPotentialCityWork = bValid;

	shl	bl, 7
	and	al, 127					; 0000007fH
	or	al, bl
	mov	BYTE PTR [esi+461], al

; 5169 : 
; 5170 : 		updateYield();

	mov	ecx, esi
	pop	esi
	pop	ebx
	jmp	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN1@updatePote:
	pop	esi
	pop	ebx

; 5171 : 	}
; 5172 : }

	ret	0
?updatePotentialCityWork@CvPlot@@QAEXXZ ENDP		; CvPlot::updatePotentialCityWork
_TEXT	ENDS
PUBLIC	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
EXTRN	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z:PROC ; CvMap::changeNumResourcesOnLand
EXTRN	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z:PROC ; CvMap::changeNumResources
; Function compile flags: /Ogtpy
;	COMDAT ?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z
_TEXT	SEGMENT
_eNewValue$ = 8						; size = 4
_iResourceNum$ = 12					; size = 4
_bForMinorCivPlot$ = 16					; size = 1
?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z PROC ; CvPlot::setResourceType, COMDAT
; _this$ = ecx

; 6128 : {

	push	ebx

; 6129 : 	if(m_eResourceType != eNewValue)

	mov	ebx, DWORD PTR _eNewValue$[esp]
	push	esi
	mov	esi, ecx
	movsx	eax, BYTE PTR [esi+440]
	cmp	eax, ebx
	je	$LN54@setResourc

; 6130 : 	{
; 6131 : 		if (eNewValue != -1)

	cmp	ebx, -1
	je	SHORT $LN8@setResourc

; 6132 : 		{
; 6133 : 			CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eNewValue);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 6134 : 			if (pkResourceInfo)

	test	eax, eax
	je	SHORT $LN8@setResourc

; 6135 : 			{
; 6136 : 				if (pkResourceInfo->isOnlyMinorCivs())

	mov	ecx, eax
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	test	al, al
	je	SHORT $LN8@setResourc

; 6137 : 				{
; 6138 : 					if (!bForMinorCivPlot)

	cmp	BYTE PTR _bForMinorCivPlot$[esp+4], 0
	je	$LN54@setResourc
$LN8@setResourc:

; 6139 : 					{
; 6140 : 						CvAssertMsg(false, "Tried to place a city-state unique luxury when not allowed.  PLEASE send Anton your save game, settings, and version!");
; 6141 : 						return;
; 6142 : 					}
; 6143 : 				}
; 6144 : 			}
; 6145 : 		}
; 6146 : 
; 6147 : 		if(m_eResourceType != NO_RESOURCE)

	cmp	BYTE PTR [esi+440], -1
	je	SHORT $LN5@setResourc

; 6148 : 		{
; 6149 : 			if(area())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN6@setResourc

; 6150 : 			{
; 6151 : 				area()->changeNumResources((ResourceTypes)m_eResourceType, -1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	movsx	ecx, BYTE PTR [esi+440]
	push	-1
	push	ecx
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN6@setResourc:

; 6152 : 			}
; 6153 : 			GC.getMap().changeNumResources((ResourceTypes)m_eResourceType, -1);

	movsx	edx, BYTE PTR [esi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	edx
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources

; 6154 : 
; 6155 : 			if(!isWater())

	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN5@setResourc

; 6156 : 			{
; 6157 : 				GC.getMap().changeNumResourcesOnLand((ResourceTypes)m_eResourceType, -1);

	movsx	eax, BYTE PTR [esi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	eax
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN5@setResourc:

; 6158 : 			}
; 6159 : 
; 6160 : 		}
; 6161 : 
; 6162 : 		m_eResourceType = eNewValue; // !!! Here is where we actually change the value
; 6163 : 
; 6164 : 		setNumResource(iResourceNum);

	mov	cl, BYTE PTR _iResourceNum$[esp+4]
	mov	BYTE PTR [esi+440], bl
	mov	BYTE PTR [esi+458], cl

; 6165 : 
; 6166 : 		if(m_eResourceType != NO_RESOURCE)

	cmp	bl, -1
	je	SHORT $LN59@setResourc

; 6167 : 		{
; 6168 : 			if(area())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN58@setResourc

; 6169 : 			{
; 6170 : 				area()->changeNumResources((ResourceTypes)m_eResourceType, 1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	movsx	edx, BYTE PTR [esi+440]
	push	1
	push	edx
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN58@setResourc:

; 6171 : 			}
; 6172 : 			GC.getMap().changeNumResources((ResourceTypes)m_eResourceType, 1);

	movsx	eax, BYTE PTR [esi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	eax
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources

; 6173 : 
; 6174 : 			if(!isWater())

	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN59@setResourc

; 6175 : 			{
; 6176 : 				GC.getMap().changeNumResourcesOnLand((ResourceTypes)m_eResourceType, 1);

	movsx	ecx, BYTE PTR [esi+440]
	push	1
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN59@setResourc:

; 6177 : 			}
; 6178 : 		}
; 6179 : 
; 6180 : 		updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6181 : 
; 6182 : 		if(GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN54@setResourc

; 6183 : 		{
; 6184 : 			setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN54@setResourc:
	pop	esi
	pop	ebx

; 6185 : 		}
; 6186 : 	}
; 6187 : }

	ret	12					; 0000000cH
?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ENDP ; CvPlot::setResourceType
_TEXT	ENDS
PUBLIC	?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z ; CvPlot::getImprovementTypeNeededToImproveResource
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_eResource$ = -16					; size = 4
_this$ = -12						; size = 4
_eImprovementNeeded$ = -8				; size = 4
_pBuildInfo$225160 = -4					; size = 4
_ePlayer$ = 8						; size = 4
_bTestPlotOwner$ = 12					; size = 1
?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z PROC ; CvPlot::getImprovementTypeNeededToImproveResource, COMDAT
; _this$ = ecx

; 6265 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 6266 : 	CvAssertMsg(ePlayer == NO_PLAYER || ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 6267 : 	CvAssertMsg(ePlayer == NO_PLAYER || ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 6268 : 
; 6269 : 	ResourceTypes eResource = NO_RESOURCE;
; 6270 : 	if(ePlayer != NO_PLAYER)

	mov	ebp, DWORD PTR _ePlayer$[esp+20]
	push	esi
	or	esi, -1
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+28], ebx
	cmp	ebp, esi
	je	SHORT $LN15@getImprove

; 6271 : 	{
; 6272 : 		eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, ebp
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN24@getImprove
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	push	eax
	mov	ecx, ebx
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[esp+28], eax

; 6273 : 	}
; 6274 : 	else

	jmp	SHORT $LN34@getImprove

; 6271 : 	{
; 6272 : 		eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

$LN24@getImprove:
	mov	eax, esi
	push	eax
	mov	ecx, ebx
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[esp+28], eax

; 6273 : 	}
; 6274 : 	else

	jmp	SHORT $LN34@getImprove
$LN15@getImprove:

; 6275 : 	{
; 6276 : 		eResource = getResourceType();

	movsx	edx, BYTE PTR [ebx+440]
	mov	DWORD PTR _eResource$[esp+28], edx
$LN34@getImprove:

; 6277 : 	}
; 6278 : 
; 6279 : 	if(eResource == NO_RESOURCE)

	cmp	DWORD PTR _eResource$[esp+28], esi
	jne	SHORT $LN13@getImprove

; 6280 : 	{
; 6281 : 		return NO_IMPROVEMENT;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 6330 : }

	add	esp, 16					; 00000010H
	ret	8
$LN13@getImprove:
	push	edi

; 6282 : 	}
; 6283 : 
; 6284 : 	ImprovementTypes eImprovementNeeded = NO_IMPROVEMENT;
; 6285 : 
; 6286 : 	// see if we can improve the resource
; 6287 : #ifdef AUI_WARNING_FIXES
; 6288 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 6289 : #else
; 6290 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eImprovementNeeded$[esp+32], esi
	xor	edi, edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN10@getImprove
	npad	3
$LL55@getImprove:

; 6291 : #endif
; 6292 : 	{
; 6293 : 		BuildTypes eBuild = (BuildTypes) iBuildIndex;
; 6294 : 		CvBuildInfo* pBuildInfo = GC.getBuildInfo(eBuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pBuildInfo$225160[esp+32], eax

; 6295 : 		if(pBuildInfo == NULL)

	test	eax, eax
	je	$LN11@getImprove

; 6296 : 			continue;
; 6297 : 
; 6298 : 		if(!canBuild(eBuild, ePlayer, false /*bTestVisible*/, bTestPlotOwner))

	mov	esi, DWORD PTR _bTestPlotOwner$[esp+28]
	push	esi
	push	0
	push	ebp
	push	edi
	mov	ecx, ebx
	call	?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ; CvPlot::canBuild
	test	al, al
	je	$LN11@getImprove

; 6299 : 			continue;
; 6300 : 
; 6301 : 		if(ePlayer != NO_PLAYER)

	cmp	ebp, -1
	je	SHORT $LN6@getImprove

; 6302 : 		{
; 6303 : 			if(!GET_PLAYER(ePlayer).canBuild(this, eBuild, false /*bTestEra*/, false /*bTestVisible*/, false /*bTestGold*/, bTestPlotOwner))

	push	esi
	mov	ecx, ebp
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	0
	push	0
	push	edi
	push	ebx
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	test	al, al
	je	SHORT $LN11@getImprove
$LN6@getImprove:

; 6304 : 			{
; 6305 : 				continue;
; 6306 : 			}
; 6307 : 		}
; 6308 : 
; 6309 : 		ImprovementTypes eImprovement = (ImprovementTypes) pBuildInfo->getImprovement();

	mov	ecx, DWORD PTR _pBuildInfo$225160[esp+32]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	ebp, eax

; 6310 : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	ebp, -1
	je	SHORT $LN53@getImprove

; 6311 : 			continue;
; 6312 : 
; 6313 : 		CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	esi, eax

; 6314 : 		if(pImprovementInfo == NULL)

	test	esi, esi
	je	SHORT $LN53@getImprove

; 6315 : 			continue;
; 6316 : 
; 6317 : 		if(!pImprovementInfo->IsImprovementResourceTrade(eResource))

	mov	eax, DWORD PTR _eResource$[esp+32]
	push	eax
	mov	ecx, esi
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN53@getImprove

; 6318 : 			continue;
; 6319 : 
; 6320 : 		if(pImprovementInfo->IsCreatedByGreatPerson())

	mov	ecx, esi
	call	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsCreatedByGreatPerson
	test	al, al
	jne	SHORT $LN53@getImprove

; 6321 : 			continue;
; 6322 : 
; 6323 : 		if(pImprovementInfo->IsWater() != isWater())

	cmp	BYTE PTR [ebx+5], 3
	mov	ecx, esi
	sete	bl
	call	?IsWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsWater
	cmp	al, bl

; 6324 : 			continue;
; 6325 : 
; 6326 : 		eImprovementNeeded = eImprovement;

	mov	ebx, DWORD PTR _this$[esp+32]
	jne	SHORT $LN53@getImprove
	mov	DWORD PTR _eImprovementNeeded$[esp+32], ebp
$LN53@getImprove:
	mov	ebp, DWORD PTR _ePlayer$[esp+28]
$LN11@getImprove:

; 6282 : 	}
; 6283 : 
; 6284 : 	ImprovementTypes eImprovementNeeded = NO_IMPROVEMENT;
; 6285 : 
; 6286 : 	// see if we can improve the resource
; 6287 : #ifdef AUI_WARNING_FIXES
; 6288 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 6289 : #else
; 6290 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	$LL55@getImprove
$LN10@getImprove:

; 6327 : 	}
; 6328 : 
; 6329 : 	return eImprovementNeeded;

	mov	eax, DWORD PTR _eImprovementNeeded$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 6330 : }

	add	esp, 16					; 00000010H
	ret	8
?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z ENDP ; CvPlot::getImprovementTypeNeededToImproveResource
_TEXT	ENDS
PUBLIC	?SetImprovementPillaged@CvPlot@@QAEX_N@Z	; CvPlot::SetImprovementPillaged
EXTRN	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlayer::changeNumResourceTotal
EXTRN	?getTechCityTrade@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechCityTrade
; Function compile flags: /Ogtpy
;	COMDAT ?SetImprovementPillaged@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bWasPillaged$ = -1					; size = 1
_bPillaged$ = 8						; size = 1
?SetImprovementPillaged@CvPlot@@QAEX_N@Z PROC		; CvPlot::SetImprovementPillaged, COMDAT
; _this$ = ecx

; 6649 : {

	push	ecx
	push	ebx

; 6650 : 	bool bWasPillaged = m_bImprovementPillaged;
; 6651 : 
; 6652 : 	if(bPillaged != bWasPillaged)

	mov	bl, BYTE PTR _bPillaged$[esp+4]
	push	esi
	mov	esi, ecx
	mov	al, BYTE PTR [esi+461]
	mov	cl, al
	and	cl, 1
	mov	BYTE PTR _bWasPillaged$[esp+12], cl
	cmp	bl, cl
	je	$LN134@SetImprove

; 6653 : 	{
; 6654 : 		m_bImprovementPillaged = bPillaged;

	mov	cl, al
	xor	cl, bl
	and	cl, 1
	xor	cl, al
	mov	BYTE PTR [esi+461], cl

; 6655 : 		updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6656 : 
; 6657 : 		// Quantified Resource changes
; 6658 : 		if(getResourceType() != NO_RESOURCE && getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [esi+440]
	cmp	al, -1
	je	$LN134@SetImprove
	cmp	BYTE PTR [esi+441], -1
	je	$LN134@SetImprove

; 6659 : 		{
; 6660 : 			if(getTeam() != NO_TEAM)

	movsx	ecx, BYTE PTR [esi+4]
	cmp	ecx, -1
	je	$LN134@SetImprove
	cmp	ecx, 63					; 0000003fH
	ja	$LN134@SetImprove
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	cmp	DWORD PTR [edx+ecx*4], -1
	je	$LN134@SetImprove
	push	ebp
	push	edi

; 6661 : 			{
; 6662 : 				if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	mov	ecx, esi
	movsx	ebp, al
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	mov	edi, eax
	imul	edi, 2980				; 00000ba4H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, edi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN137@SetImprove

; 6663 : 				{
; 6664 : 					if(GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	movsx	eax, BYTE PTR [esi+440]
	movsx	ecx, BYTE PTR [esi+441]
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN137@SetImprove

; 6665 : 					{
; 6666 : 						if(bPillaged)
; 6667 : 						{
; 6668 : 							GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), -getNumResourceForPlayer(getOwner()));

	movsx	eax, BYTE PTR [esi+4]
	movsx	ebp, BYTE PTR [esi+440]
	mov	edi, eax
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	mov	ecx, esi
	push	eax
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	mov	ecx, edi
	test	bl, bl
	je	SHORT $LN5@SetImprove
	neg	eax
	push	eax
	push	ebp
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6669 : 
; 6670 : 							// Disconnect resource link
; 6671 : 							if(GetResourceLinkedCity() != NULL)

	mov	ecx, esi
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN137@SetImprove

; 6672 : 								SetResourceLinkedCityActive(false);

	push	0

; 6673 : 						}
; 6674 : 						else

	jmp	SHORT $LN139@SetImprove
$LN5@SetImprove:

; 6675 : 						{
; 6676 : 							GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), getNumResourceForPlayer(getOwner()));

	push	eax
	push	ebp
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6677 : 
; 6678 : 							// Reconnect resource link
; 6679 : 							if(GetResourceLinkedCity() != NULL)

	mov	ecx, esi
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN137@SetImprove

; 6680 : 								SetResourceLinkedCityActive(true);

	push	1
$LN139@SetImprove:
	mov	ecx, esi
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive
$LN137@SetImprove:
	pop	edi
	pop	ebp
$LN134@SetImprove:

; 6681 : 						}
; 6682 : 					}
; 6683 : 				}
; 6684 : 			}
; 6685 : 		}
; 6686 : 	}
; 6687 : 
; 6688 : 	if(bWasPillaged != m_bImprovementPillaged)

	mov	al, BYTE PTR [esi+461]
	and	al, 1
	cmp	BYTE PTR _bWasPillaged$[esp+12], al
	je	SHORT $LN130@SetImprove

; 6689 : 	{
; 6690 : 		setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN130@SetImprove:
	pop	esi
	pop	ebx

; 6691 : 	}
; 6692 : }

	pop	ecx
	ret	4
?SetImprovementPillaged@CvPlot@@QAEX_N@Z ENDP		; CvPlot::SetImprovementPillaged
_TEXT	ENDS
PUBLIC	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z	; CvPlot::setRouteType
EXTRN	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeNumResourceUsed
EXTRN	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z:PROC ; CvRouteInfo::getResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeBaseImprovementGoldMaintenance
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::GetGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z
_TEXT	SEGMENT
_oldRouteInfo$225357 = -4				; size = 4
_iNumResourceInfos$225377 = 8				; size = 4
_eNewValue$ = 8						; size = 4
?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z PROC		; CvPlot::setRouteType, COMDAT
; _this$ = ecx

; 6789 : {

	push	ecx
	push	ebx

; 6790 : 	bool bOldRoute;
; 6791 : 	RouteTypes eOldRoute = getRouteType();
; 6792 : 	int iI;
; 6793 : 
; 6794 : 	if(eOldRoute != eNewValue || (eOldRoute == eNewValue && IsRoutePillaged()))

	mov	ebx, DWORD PTR _eNewValue$[esp+4]
	push	esi
	mov	esi, ecx
	push	edi
	movsx	edi, BYTE PTR [esi+447]
	cmp	edi, ebx
	jne	SHORT $LN23@setRouteTy
	test	BYTE PTR [esi+461], 2
	je	$LN24@setRouteTy
$LN23@setRouteTy:
	push	ebp

; 6795 : 	{
; 6796 : 		bOldRoute = isRoute(); // XXX is this right???
; 6797 : 
; 6798 : 		// Remove old effects
; 6799 : 		if(eOldRoute != NO_ROUTE && !isCity())

	cmp	edi, -1
	je	$LN120@setRouteTy
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN118@setRouteTy
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN118@setRouteTy
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN120@setRouteTy
$LN118@setRouteTy:

; 6800 : 		{
; 6801 : 			// Owned by someone
; 6802 : 			if(isOwned())

	cmp	BYTE PTR [esi+4], -1
	je	$LN17@setRouteTy

; 6803 : 			{
; 6804 : 				CvRouteInfo& oldRouteInfo = *GC.getRouteInfo(eOldRoute);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _oldRouteInfo$225357[esp+20], eax

; 6805 : 				CvPlayer& owningPlayer = GET_PLAYER(getOwner());

	movsx	eax, BYTE PTR [esi+4]
	mov	ebp, eax
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 6806 : 
; 6807 : 				// Maintenance change!
; 6808 : 				if(MustPayMaintenanceHere(getOwner()))

	push	eax
	mov	ecx, esi
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN20@setRouteTy

; 6809 : 				{
; 6810 : #ifdef AUI_WARNING_FIXES
; 6811 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-oldRouteInfo.GetGoldMaintenance());
; 6812 : #else
; 6813 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	movsx	edi, BYTE PTR [esi+4]
	movsx	eax, BYTE PTR [esi+447]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN20@setRouteTy:

; 6814 : #endif
; 6815 : 				}
; 6816 : 
; 6817 : 				// Update the amount of a Resource used up by a Route which was previously here
; 6818 : 				int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ebx, eax

; 6819 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN123@setRouteTy
	npad	1
$LL19@setRouteTy:

; 6820 : 				{
; 6821 : 					int iRequiredResources = oldRouteInfo.getResourceQuantityRequirement(iResourceLoop);

	mov	ecx, DWORD PTR _oldRouteInfo$225357[esp+20]
	push	edi
	call	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getResourceQuantityRequirement

; 6822 : 					if(iRequiredResources > 0)

	test	eax, eax
	jle	SHORT $LN18@setRouteTy

; 6823 : 					{
; 6824 : 						owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, -iRequiredResources);

	neg	eax
	push	eax
	push	edi
	mov	ecx, ebp
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN18@setRouteTy:
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL19@setRouteTy
$LN123@setRouteTy:

; 6819 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	mov	ebx, DWORD PTR _eNewValue$[esp+16]
$LN17@setRouteTy:

; 6825 : 					}
; 6826 : 				}
; 6827 : 			}
; 6828 : 
; 6829 : 			// Someone built a route here in an unowned plot, remove the effects of it (since we're changing it to something else)
; 6830 : 			if(GetPlayerResponsibleForRoute() != NO_PLAYER)

	mov	al, BYTE PTR [esi+445]
	cmp	al, -1
	je	SHORT $LN120@setRouteTy

; 6831 : 			{
; 6832 : 				// Maintenance change!
; 6833 : 				if(MustPayMaintenanceHere(GetPlayerResponsibleForRoute()))

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN58@setRouteTy
	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN124@setRouteTy
$LN58@setRouteTy:

; 6834 : 				{
; 6835 : 					CvRouteInfo* pkRouteInfo = GC.getRouteInfo(getRouteType());

	movsx	eax, BYTE PTR [esi+447]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 6836 : 					if(pkRouteInfo)

	test	eax, eax
	je	SHORT $LN124@setRouteTy

; 6837 : 					{
; 6838 : 						GET_PLAYER(GetPlayerResponsibleForRoute()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pkRouteInfo->GetGoldMaintenance());

	movsx	edi, BYTE PTR [esi+445]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN124@setRouteTy:

; 6839 : 					}
; 6840 : 				}
; 6841 : 
; 6842 : 				SetPlayerResponsibleForRoute(NO_PLAYER);

	cmp	BYTE PTR [esi+445], -1
	je	SHORT $LN120@setRouteTy
	mov	BYTE PTR [esi+445], -1
$LN120@setRouteTy:

; 6843 : 			}
; 6844 : 		}
; 6845 : 
; 6846 : 		// Route switch here!
; 6847 : 		m_eRouteType = eNewValue;
; 6848 : 
; 6849 : 		// Apply new effects
; 6850 : 		if(isOwned() && eNewValue != NO_ROUTE && !isCity())

	cmp	BYTE PTR [esi+4], -1
	mov	BYTE PTR [esi+447], bl
	je	$LN122@setRouteTy
	cmp	ebx, -1
	je	$LN122@setRouteTy
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN117@setRouteTy
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN117@setRouteTy
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN122@setRouteTy
$LN117@setRouteTy:

; 6851 : 		{
; 6852 : 			CvRouteInfo* newRouteInfo = GC.getRouteInfo(eNewValue);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ebx, eax

; 6853 : 			if(newRouteInfo)

	test	ebx, ebx
	je	SHORT $LN122@setRouteTy

; 6854 : 			{
; 6855 : 				CvPlayer& owningPlayer = GET_PLAYER(getOwner());

	movsx	eax, BYTE PTR [esi+4]
	mov	ebp, eax
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 6856 : 
; 6857 : 				// Maintenance
; 6858 : 				if(MustPayMaintenanceHere(getOwner()))

	push	eax
	mov	ecx, esi
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN10@setRouteTy

; 6859 : 				{
; 6860 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(newRouteInfo->GetGoldMaintenance());

	movsx	edi, BYTE PTR [esi+4]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebx
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN10@setRouteTy:

; 6861 : 				}
; 6862 : 
; 6863 : 				// Update the amount of a Resource used up by this Route
; 6864 : 				int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos

; 6865 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	xor	edi, edi
	mov	DWORD PTR _iNumResourceInfos$225377[esp+16], eax
	test	eax, eax
	jle	SHORT $LN122@setRouteTy
$LL9@setRouteTy:

; 6866 : 				{
; 6867 : 					int iRequiredResources = newRouteInfo->getResourceQuantityRequirement(iResourceLoop);

	push	edi
	mov	ecx, ebx
	call	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getResourceQuantityRequirement

; 6868 : 					if(iRequiredResources > 0)

	test	eax, eax
	jle	SHORT $LN8@setRouteTy

; 6869 : 					{
; 6870 : 						owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, iRequiredResources);

	push	eax
	push	edi
	mov	ecx, ebp
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN8@setRouteTy:
	inc	edi
	cmp	edi, DWORD PTR _iNumResourceInfos$225377[esp+16]
	jl	SHORT $LL9@setRouteTy
$LN122@setRouteTy:

; 6871 : 					}
; 6872 : 				}
; 6873 : 			}
; 6874 : 		}
; 6875 : 
; 6876 : 		// make sure this plot is not disabled
; 6877 : 		SetRoutePillaged(false);

	push	0
	mov	ecx, esi
	call	?SetRoutePillaged@CvPlot@@QAEX_N@Z	; CvPlot::SetRoutePillaged

; 6878 : 
; 6879 : 		for(iI = 0; iI < MAX_TEAMS; ++iI)

	xor	edi, edi
	pop	ebp
	npad	6
$LL5@setRouteTy:

; 6880 : 		{
; 6881 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 6882 : 			if (iI == OBSERVER_TEAM || GET_TEAM((TeamTypes)iI).isAlive())
; 6883 : #else
; 6884 : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, edi
	imul	eax, 2980				; 00000ba4H
	cmp	DWORD PTR [eax+ecx+12], 0
	jle	SHORT $LN4@setRouteTy

; 6885 : #endif
; 6886 : 			{
; 6887 : 				if(isVisible((TeamTypes)iI))

	cmp	edi, -1
	je	SHORT $LN4@setRouteTy
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+edi*2], 0
	setg	al
	test	al, al
	je	SHORT $LN4@setRouteTy

; 6888 : 				{
; 6889 : 					setRevealedRouteType((TeamTypes)iI, getRouteType());

	movsx	eax, BYTE PTR [esi+447]
	push	eax
	push	edi
	mov	ecx, esi
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
$LN4@setRouteTy:
	inc	edi
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL5@setRouteTy

; 6890 : 				}
; 6891 : 			}
; 6892 : 		}
; 6893 : 
; 6894 : 		updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN24@setRouteTy:
	pop	edi
	pop	esi
	pop	ebx

; 6895 : 	}
; 6896 : }

	pop	ecx
	ret	4
?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ENDP		; CvPlot::setRouteType
_TEXT	ENDS
PUBLIC	?updateCityRoute@CvPlot@@QAEXXZ			; CvPlot::updateCityRoute
EXTRN	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::getBestRoute
; Function compile flags: /Ogtpy
;	COMDAT ?updateCityRoute@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?updateCityRoute@CvPlot@@QAEXXZ PROC			; CvPlot::updateCityRoute, COMDAT
; _this$ = ecx

; 6945 : {

	push	esi
	mov	esi, ecx

; 6946 : 	RouteTypes eCityRoute;
; 6947 : 
; 6948 : 	if(isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN2@updateCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN2@updateCity
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN2@updateCity

; 6949 : 	{
; 6950 : 		CvAssertMsg(isOwned(), "isOwned is expected to be true");
; 6951 : 
; 6952 : 		eCityRoute = GET_PLAYER(getOwner()).getBestRoute();

	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute

; 6953 : 
; 6954 : 		if(eCityRoute == NO_ROUTE)

	cmp	eax, -1
	jne	SHORT $LN14@updateCity

; 6955 : 		{
; 6956 : 			eCityRoute = ((RouteTypes)(GC.getINITIAL_CITY_ROUTE_TYPE()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8448
$LN14@updateCity:

; 6957 : 		}
; 6958 : 
; 6959 : 		setRouteType(eCityRoute);

	push	eax
	mov	ecx, esi
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType
$LN2@updateCity:
	pop	esi

; 6960 : 	}
; 6961 : }

	ret	0
?updateCityRoute@CvPlot@@QAEXXZ ENDP			; CvPlot::updateCityRoute
_TEXT	ENDS
PUBLIC	?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z		; CvPlot::setPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
$T248043 = -8						; size = 8
_pNewValue$ = 8						; size = 4
?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z PROC		; CvPlot::setPlotCity, COMDAT
; _this$ = ecx

; 7137 : {

	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 7138 : 	CvPlot* pLoopPlot;
; 7139 : 	int iI;
; 7140 : 
; 7141 : 	if(getPlotCity() != pNewValue)

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN129@setPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN129@setPlotCit
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN21@setPlotCit
$LN129@setPlotCit:
	xor	eax, eax
$LN21@setPlotCit:
	mov	ebx, DWORD PTR _pNewValue$[esp+12]
	cmp	eax, ebx
	je	$LN17@setPlotCit

; 7142 : 	{
; 7143 : 		if(isCity())

	mov	eax, DWORD PTR [esi+104]
	push	ebp
	push	edi
	test	eax, eax
	jl	$LN11@setPlotCit
	cmp	eax, 64					; 00000040H
	jge	$LN11@setPlotCit
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	$LN11@setPlotCit

; 7144 : 		{
; 7145 : 			// Is a route is here?  If so, we may now need to pay maintenance for it.  Yes, yes, I know, we're removing a city
; 7146 : 			// so most likely the owner will loose the plot shortly, but it is best to keep the costs in sync, else bad things happen
; 7147 : 			// if it doesn't get properly updated (like it has been == negative maintenance costs asserts)
; 7148 : 			if(getRouteType() != NO_ROUTE && getPlotCity()->getOwner() == getOwner())

	cmp	BYTE PTR [esi+447], -1
	je	SHORT $LN14@setPlotCit
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN32@setPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN32@setPlotCit
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN33@setPlotCit
$LN32@setPlotCit:
	xor	eax, eax
$LN33@setPlotCit:
	movsx	ecx, BYTE PTR [esi+4]
	cmp	DWORD PTR [eax+84], ecx
	jne	SHORT $LN14@setPlotCit

; 7149 : 			{
; 7150 : 				// Maintenance change!
; 7151 : 				if(MustPayMaintenanceHere(getOwner()))

	push	ecx
	mov	ecx, esi
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN14@setPlotCit

; 7152 : 				{
; 7153 : #ifdef AUI_WARNING_FIXES
; 7154 : 					CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 7155 : 					if (pRouteInfo)
; 7156 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(pRouteInfo->GetGoldMaintenance());
; 7157 : #else
; 7158 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	movsx	edi, BYTE PTR [esi+4]
	movsx	eax, BYTE PTR [esi+447]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN14@setPlotCit:

; 7159 : #endif
; 7160 : 				}
; 7161 : 			}
; 7162 : 
; 7163 : 			for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	xor	ebp, ebp
$LL13@setPlotCit:

; 7164 : 			{
; 7165 : 				pLoopPlot = plotCity(getX(), getY(), iI);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7166 : 
; 7167 : 				if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN12@setPlotCit

; 7168 : 				{
; 7169 : 					pLoopPlot->changeCityRadiusCount(-1);

	dec	BYTE PTR [edi+455]

; 7170 : 					pLoopPlot->changePlayerCityRadiusCount(getPlotCity()->getOwner(), -1);

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN57@setPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN57@setPlotCit
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN58@setPlotCit
$LN57@setPlotCit:
	xor	eax, eax
$LN58@setPlotCit:
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [edi+152]
	add	eax, ecx
	dec	BYTE PTR [eax]
$LN12@setPlotCit:
	inc	ebp
	cmp	ebp, 37					; 00000025H
	jl	SHORT $LL13@setPlotCit
$LN11@setPlotCit:

; 7171 : 				}
; 7172 : 			}
; 7173 : 		}
; 7174 : 
; 7175 : 		if(pNewValue != NULL)

	test	ebx, ebx
	je	SHORT $LN9@setPlotCit

; 7176 : 		{
; 7177 : 			m_plotCity = pNewValue->GetIDInfo();

	lea	edx, DWORD PTR $T248043[esp+24]
	push	edx
	mov	ecx, ebx
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+108], edx

; 7178 : 		}
; 7179 : 		else

	jmp	SHORT $LN69@setPlotCit
$LN9@setPlotCit:

; 7180 : 		{
; 7181 : 			m_plotCity.reset();

	or	eax, -1
	mov	DWORD PTR [esi+104], eax
	mov	DWORD PTR [esi+108], eax
$LN69@setPlotCit:

; 7182 : 		}
; 7183 : 
; 7184 : 		if(isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN1@setPlotCit
	cmp	eax, 64					; 00000040H
	jge	$LN1@setPlotCit
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	$LN1@setPlotCit

; 7185 : 		{
; 7186 : 			for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	xor	ebp, ebp
	npad	5
$LL6@setPlotCit:

; 7187 : 			{
; 7188 : 				pLoopPlot = plotCity(getX(), getY(), iI);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 7189 : 
; 7190 : 				if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN5@setPlotCit

; 7191 : 				{
; 7192 : 					pLoopPlot->changeCityRadiusCount(1);

	inc	BYTE PTR [edi+455]

; 7193 : 					pLoopPlot->changePlayerCityRadiusCount(getPlotCity()->getOwner(), 1);

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN82@setPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN82@setPlotCit
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN83@setPlotCit
$LN82@setPlotCit:
	xor	eax, eax
$LN83@setPlotCit:
	mov	eax, DWORD PTR [eax+84]
	mov	ecx, DWORD PTR [edi+152]
	add	eax, ecx
	inc	BYTE PTR [eax]
$LN5@setPlotCit:
	inc	ebp
	cmp	ebp, 37					; 00000025H
	jl	SHORT $LL6@setPlotCit

; 7194 : 				}
; 7195 : 			}
; 7196 : 
; 7197 : 			// Is a route is here?  If we already owned this plot, then we were paying maintenance, now we don't have to.
; 7198 : 			if(getRouteType() != NO_ROUTE && getPlotCity()->getOwner() == getOwner())

	cmp	BYTE PTR [esi+447], -1
	je	$LN1@setPlotCit
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN96@setPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN96@setPlotCit
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN97@setPlotCit
$LN96@setPlotCit:
	xor	eax, eax
$LN97@setPlotCit:
	movsx	ecx, BYTE PTR [esi+4]
	cmp	DWORD PTR [eax+84], ecx
	jne	SHORT $LN1@setPlotCit

; 7199 : 			{
; 7200 : 				// Maintenance change!
; 7201 : 				if(MustPayMaintenanceHere(getOwner()))

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN109@setPlotCit
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN1@setPlotCit
$LN109@setPlotCit:

; 7202 : 				{
; 7203 : #ifdef AUI_WARNING_FIXES
; 7204 : 					CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 7205 : 					if (pRouteInfo)
; 7206 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pRouteInfo->GetGoldMaintenance());
; 7207 : #else
; 7208 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	movsx	edi, BYTE PTR [esi+4]
	movsx	eax, BYTE PTR [esi+447]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN1@setPlotCit:

; 7209 : #endif
; 7210 : 				}
; 7211 : 			}
; 7212 : 
; 7213 : 		}
; 7214 : 
; 7215 : 		updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
	pop	edi
	pop	ebp
$LN17@setPlotCit:
	pop	esi
	pop	ebx

; 7216 : 	}
; 7217 : }

	add	esp, 8
	ret	4
?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z ENDP		; CvPlot::setPlotCity
_TEXT	ENDS
PUBLIC	?updateWorkingCity@CvPlot@@QAEXXZ		; CvPlot::updateWorkingCity
EXTRN	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ:PROC ; CvCityCitizens::DoAddBestCitizenFromUnassigned
EXTRN	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z:PROC ; CvCityCitizens::SetWorkingPlot
EXTRN	?getGameTurnFounded@CvCity@@QBEHXZ:PROC		; CvCity::getGameTurnFounded
EXTRN	?getCityPlotPriority@CvGlobals@@QAEPAHXZ:PROC	; CvGlobals::getCityPlotPriority
; Function compile flags: /Ogtpy
;	COMDAT ?updateWorkingCity@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_pBestCity$ = -12					; size = 4
tv385 = -8						; size = 4
$T248267 = -8						; size = 8
?updateWorkingCity@CvPlot@@QAEXXZ PROC			; CvPlot::updateWorkingCity, COMDAT
; _this$ = ecx

; 7228 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 7229 : 	CvCity* pOldWorkingCity;
; 7230 : 	CvCity* pLoopCity;
; 7231 : 	CvCity* pBestCity;
; 7232 : 	CvPlot* pLoopPlot;
; 7233 : 	int iBestPlot;
; 7234 : 	int iI;
; 7235 : 
; 7236 : 	pBestCity = getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	push	edi
	test	eax, eax
	jl	SHORT $LN65@updateWork
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN65@updateWork
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax

; 7237 : 
; 7238 : 	if(pBestCity == NULL)

	test	ebx, ebx
	jne	$LN12@updateWork
$LN65@updateWork:

; 7239 : 	{
; 7240 : 		pBestCity = getWorkingCityOverride();

	mov	edx, DWORD PTR [esi+124]
	mov	eax, DWORD PTR [esi+120]
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	mov	DWORD PTR _pBestCity$[esp+24], eax

; 7241 : 		CvAssertMsg((pBestCity == NULL) || (pBestCity->getOwner() == getOwner()), "pBest city is expected to either be NULL or the current plot instance's");
; 7242 : 	}
; 7243 : 
; 7244 : 	if((pBestCity == NULL) && isOwned())

	test	eax, eax
	jne	$LN67@updateWork
	cmp	BYTE PTR [esi+4], -1
	je	$LN67@updateWork
	push	ebp

; 7245 : 	{
; 7246 : 		iBestPlot = 0;
; 7247 : 
; 7248 : 		for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	xor	ebp, ebp
	mov	DWORD PTR tv385[esp+28], ebp
$LL70@updateWork:

; 7249 : 		{
; 7250 : 			pLoopPlot = plotCity(getX(), getY(), iI);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 7251 : 
; 7252 : 			if(pLoopPlot != NULL)

	test	eax, eax
	je	$LN13@updateWork

; 7253 : 			{
; 7254 : 				pLoopCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	$LN13@updateWork
	cmp	ecx, 64					; 00000040H
	jge	$LN13@updateWork
	mov	edx, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 7255 : 
; 7256 : 				if(pLoopCity != NULL)

	test	edi, edi
	je	$LN13@updateWork

; 7257 : 				{
; 7258 : 					if(pLoopCity->getOwner() == getOwner())

	movsx	eax, BYTE PTR [esi+4]
	cmp	DWORD PTR [edi+84], eax
	jne	$LN13@updateWork

; 7259 : 					{
; 7260 : 						// XXX use getGameTurnAcquired() instead???
; 7261 : 						if((pBestCity == NULL) ||
; 7262 : 						        (GC.getCityPlotPriority()[iI] < GC.getCityPlotPriority()[iBestPlot]) ||
; 7263 : 						        ((GC.getCityPlotPriority()[iI] == GC.getCityPlotPriority()[iBestPlot]) &&
; 7264 : 						         ((pLoopCity->getGameTurnFounded() < pBestCity->getGameTurnFounded()) ||
; 7265 : 						          ((pLoopCity->getGameTurnFounded() == pBestCity->getGameTurnFounded()) &&
; 7266 : 						           (pLoopCity->GetID() < pBestCity->GetID())))))

	cmp	DWORD PTR _pBestCity$[esp+28], 0
	je	SHORT $LN62@updateWork
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	lea	ebx, DWORD PTR [eax+ebp*4]
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR tv385[esp+28]
	cmp	ecx, DWORD PTR [eax+edx]
	jl	SHORT $LN62@updateWork
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	lea	ebx, DWORD PTR [eax+ebp*4]
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR tv385[esp+28]
	cmp	ecx, DWORD PTR [eax+edx]
	jne	SHORT $LN13@updateWork
	mov	ecx, edi
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	mov	ecx, DWORD PTR _pBestCity$[esp+28]
	mov	ebx, eax
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	cmp	ebx, eax
	jl	SHORT $LN62@updateWork
	mov	ecx, edi
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	mov	ecx, DWORD PTR _pBestCity$[esp+28]
	mov	ebx, eax
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	cmp	ebx, eax
	jne	SHORT $LN13@updateWork
	mov	eax, DWORD PTR [edi+120]
	mov	ecx, DWORD PTR _pBestCity$[esp+28]
	cmp	eax, DWORD PTR [ecx+120]
	jge	SHORT $LN13@updateWork
$LN62@updateWork:

; 7245 : 	{
; 7246 : 		iBestPlot = 0;
; 7247 : 
; 7248 : 		for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	lea	edx, DWORD PTR [ebp*4]
	mov	DWORD PTR tv385[esp+28], edx

; 7267 : 						{
; 7268 : 							iBestPlot = iI;
; 7269 : 							pBestCity = pLoopCity;

	mov	DWORD PTR _pBestCity$[esp+28], edi
$LN13@updateWork:
	inc	ebp
	cmp	ebp, 37					; 00000025H
	jl	$LL70@updateWork
	pop	ebp
$LN67@updateWork:

; 7245 : 	{
; 7246 : 		iBestPlot = 0;
; 7247 : 
; 7248 : 		for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	ebx, DWORD PTR _pBestCity$[esp+24]
$LN12@updateWork:

; 7270 : 						}
; 7271 : 					}
; 7272 : 				}
; 7273 : 			}
; 7274 : 		}
; 7275 : 	}
; 7276 : 
; 7277 : 	pOldWorkingCity = getWorkingCity();

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	edi, eax
	add	esp, 8

; 7278 : 
; 7279 : 	if(pOldWorkingCity != pBestCity)

	cmp	edi, ebx
	je	SHORT $LN5@updateWork

; 7280 : 	{
; 7281 : 		// Change what City's allowed to work this Plot
; 7282 : 		if(pBestCity != NULL)

	test	ebx, ebx
	je	SHORT $LN4@updateWork

; 7283 : 		{
; 7284 : 			// Remove Citizen from this plot if another City's using it
; 7285 : 			if(pOldWorkingCity != NULL)

	test	edi, edi
	je	SHORT $LN68@updateWork

; 7286 : 			{
; 7287 : 				// Remove citizen
; 7288 : 				pOldWorkingCity->GetCityCitizens()->SetWorkingPlot(this, false);

	push	1
	push	0
	push	esi
	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot
$LN68@updateWork:

; 7289 : 			}
; 7290 : 
; 7291 : 			CvAssertMsg(isOwned(), "isOwned is expected to be true");
; 7292 : 			CvAssertMsg(!isBeingWorked(), "isBeingWorked did not return false as expected");
; 7293 : 			m_workingCity = pBestCity->GetIDInfo();

	lea	edx, DWORD PTR $T248267[esp+24]
	push	edx
	mov	ecx, ebx
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+112], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+116], edx

; 7294 : 
; 7295 : 			// If we told a City to stop working this plot, tell it to do something else instead
; 7296 : 			if(pOldWorkingCity != NULL)

	test	edi, edi
	je	SHORT $LN55@updateWork

; 7297 : 			{
; 7298 : 				// Re-add citizen somewhere else
; 7299 : 				pOldWorkingCity->GetCityCitizens()->DoAddBestCitizenFromUnassigned();

	mov	ecx, edi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ ; CvCityCitizens::DoAddBestCitizenFromUnassigned

; 7300 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 7301 : 				pOldWorkingCity->GetCityCitizens()->DoSelfConsistencyCheck();
; 7302 : #endif
; 7303 : 			}
; 7304 : 		}
; 7305 : 		else

	jmp	SHORT $LN55@updateWork
$LN4@updateWork:

; 7306 : 		{
; 7307 : 			m_workingCity.reset();

	or	eax, -1
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi+116], eax
$LN55@updateWork:

; 7308 : 		}
; 7309 : 
; 7310 : 		updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 7311 : 
; 7312 : 		GC.GetEngineUserInterface()->setDirty(ColoredPlots_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	24					; 00000018H
	call	edx
$LN5@updateWork:
	pop	edi
	pop	esi
	pop	ebx

; 7313 : 	}
; 7314 : }

	add	esp, 12					; 0000000cH
	ret	0
?updateWorkingCity@CvPlot@@QAEXXZ ENDP			; CvPlot::updateWorkingCity
_TEXT	ENDS
PUBLIC	?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::setWorkingCityOverride
; Function compile flags: /Ogtpy
;	COMDAT ?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z
_TEXT	SEGMENT
$T248363 = -8						; size = 8
_pNewValue$ = 8						; size = 4
?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z PROC	; CvPlot::setWorkingCityOverride, COMDAT
; _this$ = ecx

; 7326 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 7327 : 	if(getWorkingCityOverride() != pNewValue)

	mov	eax, DWORD PTR [esi+124]
	mov	ecx, DWORD PTR [esi+120]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	mov	ecx, DWORD PTR _pNewValue$[esp+16]
	add	esp, 8
	cmp	eax, ecx
	je	SHORT $LN3@setWorking

; 7328 : 	{
; 7329 : 		if(pNewValue != NULL)

	test	ecx, ecx
	je	SHORT $LN2@setWorking

; 7330 : 		{
; 7331 : 			CvAssertMsg(pNewValue->getOwner() == getOwner(), "Argument city pNewValue's owner is expected to be the same as the current instance");
; 7332 : 			m_workingCityOverride = pNewValue->GetIDInfo();

	lea	edx, DWORD PTR $T248363[esp+12]
	push	edx
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+120], ecx
	mov	edx, DWORD PTR [eax+4]

; 7337 : 		}
; 7338 : 
; 7339 : 		updateWorkingCity();

	mov	ecx, esi
	mov	DWORD PTR [esi+124], edx
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity
	pop	esi

; 7340 : 	}
; 7341 : }

	add	esp, 8
	ret	4
$LN2@setWorking:

; 7333 : 		}
; 7334 : 		else
; 7335 : 		{
; 7336 : 			m_workingCityOverride.reset();

	or	eax, -1

; 7337 : 		}
; 7338 : 
; 7339 : 		updateWorkingCity();

	mov	ecx, esi
	mov	DWORD PTR [esi+120], eax
	mov	DWORD PTR [esi+124], eax
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity
$LN3@setWorking:
	pop	esi

; 7340 : 	}
; 7341 : }

	add	esp, 8
	ret	4
?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z ENDP	; CvPlot::setWorkingCityOverride
_TEXT	ENDS
PUBLIC	?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z	; CvPlot::getLayerUnit
EXTRN	?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z:PROC ; CvPlotManager::GetUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z
_TEXT	SEGMENT
_kManager$226550 = 8					; size = 4
_iIndex$ = 8						; size = 4
_iNumLayers$226551 = 12					; size = 4
_iLayerID$ = 12						; size = 4
?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z PROC		; CvPlot::getLayerUnit, COMDAT
; _this$ = ecx

; 9662 : {

	push	ebx

; 9663 : 	if (iIndex >= 0)

	mov	ebx, DWORD PTR _iIndex$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	jl	$LN1@getLayerUn

; 9664 : 	{
; 9665 : 		if (iLayerID == DEFAULT_UNIT_MAP_LAYER)

	mov	eax, DWORD PTR _iLayerID$[esp+12]
	test	eax, eax
	jne	SHORT $LN12@getLayerUn
$LN41@getLayerUn:

; 9666 : 			// The base layer
; 9667 : 			return getUnitByIndex(iIndex);

	push	ebx
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9699 : }

	ret	8
$LN12@getLayerUn:

; 9668 : 		else
; 9669 : 		if (iLayerID == -1)

	cmp	eax, -1
	jne	SHORT $LN10@getLayerUn

; 9670 : 		{
; 9671 : 			// All layers
; 9672 : 			int iCount = m_units.getLength();

	mov	ebp, DWORD PTR [edi+28]

; 9673 : 			if (iIndex < iCount)

	cmp	ebx, ebp

; 9674 : 				return getUnitByIndex(iIndex);

	jl	SHORT $LN41@getLayerUn

; 9675 : 			else
; 9676 : 			{
; 9677 : 				const CvPlotManager& kManager = GC.getMap().plotManager();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, 4184				; 00001058H
	mov	DWORD PTR _kManager$226550[esp+12], ecx

; 9678 : 				int iNumLayers = kManager.GetNumLayers();

	call	?GetNumLayers@CvPlotManager@@QBEHXZ	; CvPlotManager::GetNumLayers

; 9679 : 				for (int iLayerIndex = 0; iLayerIndex < iNumLayers; ++iLayerIndex)

	xor	esi, esi
	mov	DWORD PTR _iNumLayers$226551[esp+12], eax
	test	eax, eax
	jle	SHORT $LN1@getLayerUn
$LL7@getLayerUn:

; 9680 : 				{		
; 9681 : 					const CvIDInfoFixedVector& kUnits = kManager.GetUnitsByIndex(m_iX, m_iY, iLayerIndex);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	esi
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _kManager$226550[esp+24]
	call	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ; CvPlotManager::GetUnitsByIndex

; 9682 : 					if (iIndex < (iCount + (int)kUnits.size()))

	mov	edx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [edx+ebp]
	cmp	ebx, ecx
	jl	SHORT $LN39@getLayerUn
	inc	esi
	cmp	esi, DWORD PTR _iNumLayers$226551[esp+12]

; 9684 : 					else
; 9685 : 						iCount += kUnits.size();

	mov	ebp, ecx
	jl	SHORT $LL7@getLayerUn
	pop	edi
	pop	esi
	pop	ebp

; 9695 : 		}
; 9696 : 	}
; 9697 : 
; 9698 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 9699 : }

	ret	8
$LN39@getLayerUn:

; 9683 : 						return ::getUnit( kUnits[iIndex - iCount] );

	sub	ebx, ebp
$LN42@getLayerUn:
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+ebx*8]
	push	eax
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 9699 : }

	ret	8
$LN10@getLayerUn:

; 9686 : 				}				
; 9687 : 			}
; 9688 : 		}
; 9689 : 		else
; 9690 : 		{
; 9691 : 			// Specific layer
; 9692 : 			const CvIDInfoFixedVector& kUnits = GC.getMap().plotManager().GetUnits(m_iX, m_iY, iLayerID);

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	add	ecx, 4184				; 00001058H
	call	?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z ; CvPlotManager::GetUnits

; 9693 : 			if (iIndex < (int)kUnits.size())

	cmp	ebx, DWORD PTR [eax+4]

; 9694 : 				return ::getUnit( kUnits[iIndex] );

	jl	SHORT $LN42@getLayerUn
$LN1@getLayerUn:
	pop	edi
	pop	esi
	pop	ebp

; 9695 : 		}
; 9696 : 	}
; 9697 : 
; 9698 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 9699 : }

	ret	8
?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z ENDP		; CvPlot::getLayerUnit
_TEXT	ENDS
PUBLIC	?GetNumCombatUnits@CvPlot@@QAEHXZ		; CvPlot::GetNumCombatUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCombatUnits@CvPlot@@QAEHXZ
_TEXT	SEGMENT
?GetNumCombatUnits@CvPlot@@QAEHXZ PROC			; CvPlot::GetNumCombatUnits, COMDAT
; _this$ = ecx

; 9721 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 9722 : 	int iCount = 0;

	xor	ebx, ebx

; 9723 : 
; 9724 : 	IDInfo* pUnitNode;
; 9725 : 	CvUnit* pLoopUnit;
; 9726 : #endif
; 9727 : 
; 9728 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [edi+28], ebx
	jbe	SHORT $LN9@GetNumComb
	mov	esi, DWORD PTR [edi+24]
	jmp	SHORT $LN8@GetNumComb
$LN9@GetNumComb:
	xor	esi, esi
$LN8@GetNumComb:

; 9729 : 
; 9730 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	SHORT $LN41@GetNumComb
$LL3@GetNumComb:

; 9731 : 	{
; 9732 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN1@GetNumComb
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@GetNumComb
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx

; 9733 : 
; 9734 : 		if(pLoopUnit && pLoopUnit->IsCombatUnit())

	test	eax, eax
	je	SHORT $LN1@GetNumComb
	cmp	DWORD PTR [eax+1044], 0
	jle	SHORT $LN1@GetNumComb

; 9735 : 		{
; 9736 : 			iCount++;

	inc	ebx
$LN1@GetNumComb:

; 9737 : 		}
; 9738 : 
; 9739 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+28]
	jae	SHORT $LN32@GetNumComb
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN31@GetNumComb
$LN32@GetNumComb:
	xor	esi, esi
$LN31@GetNumComb:

; 9729 : 
; 9730 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	SHORT $LL3@GetNumComb
$LN41@GetNumComb:
	pop	edi
	pop	esi

; 9740 : 	}
; 9741 : 
; 9742 : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 9743 : }

	ret	0
?GetNumCombatUnits@CvPlot@@QAEHXZ ENDP			; CvPlot::GetNumCombatUnits
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z ; FStaticVector<CvPlot *,1000,1,297,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+4012], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::clear, COMDAT
; _this$ = ecx

; 849  :         mVec.resize( 0 );

	mov	DWORD PTR [ecx+4], 0

; 850  :     };

	ret	0
?clear@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXXZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::clear
_TEXT	ENDS
PUBLIC	?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ; FFastSmallFixedList<IDInfo,25,1,297,0>::insertAtEnd
; Function compile flags: /Ogtpy
;	COMDAT ?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z
_TEXT	SEGMENT
_ptData$ = 8						; size = 4
?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::insertAtEnd, COMDAT
; _this$ = ecx

; 1026 :     { 

	push	esi
	mov	esi, ecx

; 1027 :         mVec.push_back( *ptData );       

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+212], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN3@insertAtEn
	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN3@insertAtEn:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN10@insertAtEn
	mov	ecx, DWORD PTR _ptData$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN10@insertAtEn:
	inc	DWORD PTR [esi+4]
	pop	esi

; 1028 :     };

	ret	4
?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::insertAtEnd
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,50,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,50,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+412], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,50,1,297,0>::GrowSize
$LN1@push_back@3:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@3
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,50,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z PROC ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	esi
	mov	esi, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@4

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back@4:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@4
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@4:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 381  : 	};

	ret	4
?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z ENDP ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize@2

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN4@resize@2:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::resize
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
$T248692 = -80						; size = 28
$T248691 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 1073741822		; 3ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T248692[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T248691[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T248692[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T248691[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T248691[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T248691[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T248691[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+16], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+16], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+16], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR $T248692[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR $T248691[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::clear
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+17], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_ptr<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	??$_Distance@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T249211 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAI@Z PROC ; std::_Distance<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>, COMDAT

; 1892 : 	{	// add to _Off distance between iterators

	push	ecx

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	eax, DWORD PTR $T249211[esp+4]
	mov	ecx, DWORD PTR __Off$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Distance2@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>

; 1894 : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Distance@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@@Z ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@@Z PROC ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@QAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@@Z ENDP ; std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+76], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@5

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN1@push_back@5:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@5
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@5:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T249242 = -80						; size = 28
$T249241 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 1073741822		; 3ffffffeH
	jb	SHORT $LN17@Insert@2

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T249242[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T249241[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T249242[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T249241[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T249241[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T249241[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T249241[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert@2:
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert@2
$LN14@Insert@2:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert@2

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+16], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert@2
	npad	5
$LL10@Insert@2:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN7@Insert@2

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert@2
$LN7@Insert@2:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
$LN5@Insert@2:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert@2
$LN8@Insert@2:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN3@Insert@2

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert@2
$LN3@Insert@2:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
$LN1@Insert@2:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN170@Insert@2
	mov	DWORD PTR [edx+4], eax
$LN170@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert@2
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert@2
$LN169@Insert@2:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert@2
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert@2
$LN167@Insert@2:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert@2:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert@2:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+16], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert@2
$LN9@Insert@2:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+16], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T249242[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2:
	lea	ecx, DWORD PTR $T249241[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
PUBLIC	??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
; Function compile flags: /Ogtpy
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
$T249650 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find, COMDAT
; _this$ = ecx

; 977  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ecx

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+45], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jae	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 983  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	DWORD PTR $T249650[esp+8], eax
	lea	eax, DWORD PTR $T249650[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 983  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T249812 = -80						; size = 28
$T249811 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 134217726		; 07fffffeH
	jb	SHORT $LN17@Insert@3

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T249812[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T249811[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T249812[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T249811[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T249811[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T249811[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T249811[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert@3:
$LN17@Insert@3:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert@3

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert@3
$LN16@Insert@3:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert@3

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert@3

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert@3
$LN14@Insert@3:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert@3

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert@3:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+44], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert@3
	npad	5
$LL10@Insert@3:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert@3

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+44], 0
	jne	SHORT $LN7@Insert@3

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+44], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+44], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+44], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert@3
$LN7@Insert@3:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert@3

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
$LN5@Insert@3:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+44], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+44], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert@3
$LN8@Insert@3:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+44], 0
	jne	SHORT $LN3@Insert@3

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+44], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+44], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+44], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert@3
$LN3@Insert@3:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert@3

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
$LN1@Insert@3:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+44], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+44], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+45], 0
	jne	SHORT $LN170@Insert@3
	mov	DWORD PTR [edx+4], eax
$LN170@Insert@3:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert@3
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert@3
$LN169@Insert@3:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert@3
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert@3
$LN167@Insert@3:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert@3:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert@3:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+44], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert@3
$LN9@Insert@3:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+44], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T249812[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$2:
	lea	ecx, DWORD PTR $T249811[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
PUBLIC	??$find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z ; std::find<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,FAutoVariableBase const *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z PROC ; std::find<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,FAutoVariableBase const *>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN21@find@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@find@2:
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN21@find@2
	add	ecx, 4
	cmp	ecx, eax
	jne	SHORT $LL9@find@2
$LN21@find@2:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@std@@PBVFAutoVariableBase@@@std@@YA?AV?$_Vector_const_iterator@PAVFAutoVariableBase@@V?$allocator@PAVFAutoVariableBase@@@std@@@0@V10@0ABQBVFAutoVariableBase@@@Z ENDP ; std::find<std::_Vector_const_iterator<FAutoVariableBase *,std::allocator<FAutoVariableBase *> >,FAutoVariableBase const *>
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+45], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	ecx, 16					; 00000010H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?setupGraphical@CvPlot@@QAEXXZ			; CvPlot::setupGraphical
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?setupGraphical@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?setupGraphical@CvPlot@@QAEXXZ PROC			; CvPlot::setupGraphical, COMDAT
; _this$ = ecx

; 333  : {

	push	esi
	mov	esi, ecx

; 334  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN2@setupGraph

; 335  : 	{
; 336  : 		return;
; 337  : 	}
; 338  : 
; 339  : 	updateSymbols();

	mov	ecx, esi
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 340  : 
; 341  : 	updateVisibility();

	mov	ecx, esi
	pop	esi
	jmp	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
$LN2@setupGraph:
	pop	esi

; 342  : }

	ret	0
?setupGraphical@CvPlot@@QAEXXZ ENDP			; CvPlot::setupGraphical
_TEXT	ENDS
PUBLIC	?updateFog@CvPlot@@QAEX_N@Z			; CvPlot::updateFog
; Function compile flags: /Ogtpy
;	COMDAT ?updateFog@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_bDefer$ = 8						; size = 1
?updateFog@CvPlot@@QAEX_N@Z PROC			; CvPlot::updateFog, COMDAT
; _this$ = ecx

; 553  : {

	push	edi
	mov	edi, ecx

; 554  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	$LN23@updateFog

; 555  : 	{
; 556  : 		return;
; 557  : 	}
; 558  : 
; 559  : 	FogOfWarModeTypes eFOWMode = GetActiveFogOfWarMode();

	mov	ecx, edi
	call	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode

; 560  : 
; 561  : 	if(!bDefer)

	cmp	BYTE PTR _bDefer$[esp], 0
	jne	SHORT $LN6@updateFog

; 562  : 	{
; 563  : 		gDLL->GameplayFOWChanged(getX(), getY(), eFOWMode, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+712]
	push	0
	push	eax
	movsx	eax, WORD PTR [edi+2]
	push	eax
	movsx	eax, WORD PTR [edi]
	push	eax
	call	edx
	pop	edi

; 574  : 	}
; 575  : }

	ret	4
$LN6@updateFog:
	push	ebx
	push	esi

; 564  : 	}
; 565  : 	else
; 566  : 	{
; 567  : 		CvMap::DeferredPlotArray& plotList = GC.getMap().m_vDeferredFogPlots;

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 568  : 		for (CvMap::DeferredPlotArray::const_iterator itr = plotList.begin(); itr != plotList.end(); ++itr)

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	esi, 4
	lea	edx, DWORD PTR [eax+ecx*4]
	cmp	eax, edx
	je	SHORT $LN2@updateFog
	npad	5
$LL4@updateFog:

; 569  : 		{
; 570  : 			if((*itr) == this)

	cmp	DWORD PTR [eax], edi
	je	SHORT $LN32@updateFog
	mov	ebx, DWORD PTR [esi]
	mov	edx, ecx
	add	eax, 4
	lea	edx, DWORD PTR [ebx+edx*4]
	cmp	eax, edx
	jne	SHORT $LL4@updateFog
$LN2@updateFog:

; 571  : 				return;	// Already in
; 572  : 		}
; 573  : 		plotList.push_back(this);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+4012], 0
	cmp	ecx, eax
	jne	SHORT $LN22@updateFog
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize
$LN22@updateFog:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN25@updateFog
	mov	DWORD PTR [eax], edi
$LN25@updateFog:
	inc	DWORD PTR [esi+4]
$LN32@updateFog:
	pop	esi
	pop	ebx
$LN23@updateFog:
	pop	edi

; 574  : 	}
; 575  : }

	ret	4
?updateFog@CvPlot@@QAEX_N@Z ENDP			; CvPlot::updateFog
_TEXT	ENDS
PUBLIC	?updateCenterUnit@CvPlot@@QAEXXZ		; CvPlot::updateCenterUnit
EXTRN	?IsGarrisoned@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGarrisoned
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?updateCenterUnit@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$9
__ehfuncinfo$?updateCenterUnit@CvPlot@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?updateCenterUnit@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateCenterUnit@CvPlot@@QAEXXZ
_TEXT	SEGMENT
$T250419 = -28						; size = 4
_this$ = -28						; size = 4
$T250429 = -24						; size = 4
_pDllUnit$222676 = -24					; size = 4
$T250426 = -24						; size = 4
$T250423 = -24						; size = 4
$T250420 = -24						; size = 4
$T250427 = -20						; size = 8
$T250425 = -20						; size = 8
_hBestDefender$222651 = -20				; size = 8
$T250422 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?updateCenterUnit@CvPlot@@QAEXXZ PROC			; CvPlot::updateCenterUnit, COMDAT
; _this$ = ecx

; 644  : {

	push	-1
	push	__ehhandler$?updateCenterUnit@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 645  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+44], edi
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	$LN4@updateCent

; 646  : 	{
; 647  : 		return;
; 648  : 	}
; 649  : 
; 650  : 	if(!isActiveVisible(true))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, eax
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	jne	SHORT $LN146@updateCent
	cmp	esi, -1
	je	SHORT $LN145@updateCent
	mov	eax, DWORD PTR [edi+156]
	cmp	WORD PTR [eax+esi*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN146@updateCent
$LN145@updateCent:

; 651  : 	{
; 652  : 		setCenterUnit(NULL);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T250419[esp+52], esp
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit

; 707  : 	}
; 708  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN146@updateCent:

; 653  : 		return;
; 654  : 	}
; 655  : 
; 656  : 	setCenterUnit(getSelectedUnit());

	mov	ecx, edi
	call	?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ ; CvPlot::getSelectedUnit
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T250420[esp+52], esp
	mov	DWORD PTR [ecx], eax
	mov	BYTE PTR [ecx+4], 0
	test	eax, eax
	je	SHORT $LN50@updateCent
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@updateCent:
	mov	ecx, edi
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit

; 657  : 
; 658  : 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam

; 659  : 
; 660  : 	if(!getCenterUnit())

	lea	ecx, DWORD PTR $T250422[esp+44]
	push	ecx
	mov	ecx, edi
	mov	ebp, eax
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T250422[esp+44]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN59@updateCent
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@updateCent:
	test	bl, bl
	je	SHORT $LN148@updateCent

; 661  : 	{
; 662  : 		UnitHandle hBestDefender = getBestDefender(NO_PLAYER, GC.getGame().getActivePlayer());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	push	0
	push	0
	push	0
	push	0
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	push	-1
	lea	edx, DWORD PTR _hBestDefender$222651[esp+72]
	push	edx
	mov	ecx, edi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 663  : 		if(hBestDefender && hBestDefender->getDomainType() != DOMAIN_AIR && !hBestDefender->isInvisible(eActiveTeam,false))

	mov	ecx, DWORD PTR _hBestDefender$222651[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], 0
	test	ecx, ecx
	je	SHORT $LN147@updateCent
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN144@updateCent
	mov	ecx, DWORD PTR _hBestDefender$222651[esp+44]
	push	1
	push	0
	push	ebp
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN144@updateCent

; 664  : 			setCenterUnit(hBestDefender);

	sub	esp, 8
	lea	eax, DWORD PTR _hBestDefender$222651[esp+52]
	mov	ecx, esp
	mov	DWORD PTR $T250423[esp+52], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit
$LN144@updateCent:
	mov	ecx, DWORD PTR _hBestDefender$222651[esp+44]
$LN147@updateCent:

; 665  : 	}

	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN148@updateCent
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN148@updateCent:

; 666  : 
; 667  : 	// okay, all of the other checks failed - if there is any unit here, make it the center unit
; 668  : 	if(!getCenterUnit())

	lea	ecx, DWORD PTR $T250425[esp+44]
	push	ecx
	mov	ecx, edi
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T250425[esp+44]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN79@updateCent
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN79@updateCent:
	test	bl, bl
	je	SHORT $LN151@updateCent

; 669  : 	{
; 670  : 		IDInfo* pUnitNode;
; 671  : 		CvUnit* pLoopUnit;
; 672  : 
; 673  : 		pUnitNode = headUnitNode();

	cmp	DWORD PTR [edi+28], 0
	jbe	SHORT $LN151@updateCent
	mov	eax, DWORD PTR [edi+24]

; 674  : 
; 675  : 		if(pUnitNode != NULL)

	test	eax, eax
	je	SHORT $LN151@updateCent

; 676  : 		{
; 677  : 			pLoopUnit = GetPlayerUnit(*pUnitNode);

	push	eax
	call	?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z ; GetPlayerUnit
	mov	esi, eax
	add	esp, 4

; 678  : 			if(pLoopUnit && !pLoopUnit->IsGarrisoned() && pLoopUnit->getDomainType() != DOMAIN_AIR && !pLoopUnit->isInvisible(eActiveTeam,false))

	test	esi, esi
	je	SHORT $LN151@updateCent
	mov	ecx, esi
	call	?IsGarrisoned@CvUnit@@QBE_NXZ		; CvUnit::IsGarrisoned
	test	al, al
	jne	SHORT $LN151@updateCent
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN151@updateCent
	push	1
	push	0
	push	ebp
	mov	ecx, esi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN151@updateCent

; 679  : 			{
; 680  : 				setCenterUnit(pLoopUnit);

	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T250426[esp+52], esp
	push	esi
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	mov	ecx, edi
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit
$LN151@updateCent:

; 681  : 			}
; 682  : 		}
; 683  : 	}
; 684  : 
; 685  : 	IDInfo* pUnitNode;
; 686  : 	CvUnit* pLoopUnit;
; 687  : 	CvUnit* pCenterUnit = getCenterUnit().pointer();

	lea	edx, DWORD PTR $T250427[esp+44]
	push	edx
	mov	ecx, edi
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	ecx, DWORD PTR $T250427[esp+44]
	mov	ebx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN96@updateCent
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN96@updateCent:

; 688  : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [edi+28], 0
	jbe	SHORT $LN101@updateCent
	mov	esi, DWORD PTR [edi+24]
	jmp	SHORT $LN100@updateCent
$LN101@updateCent:
	xor	esi, esi
$LN100@updateCent:

; 689  : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN4@updateCent
$LL5@updateCent:

; 690  : 	{
; 691  : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN108@updateCent
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN108@updateCent
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	ebp, eax
	jmp	SHORT $LN109@updateCent
$LN108@updateCent:
	xor	ebp, ebp
$LN109@updateCent:

; 692  : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+28]
	jae	SHORT $LN120@updateCent
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN119@updateCent
$LN120@updateCent:
	xor	esi, esi
$LN119@updateCent:

; 693  : 
; 694  : 		if(pLoopUnit)

	test	ebp, ebp
	je	SHORT $LN139@updateCent

; 695  : 		{
; 696  : 			auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T250429[esp+44], eax
	mov	DWORD PTR __$EHRec$[esp+52], 1
	test	eax, eax
	je	SHORT $LN15@updateCent
	push	ebp
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	edi, eax
	jmp	SHORT $LN16@updateCent
$LN15@updateCent:
	xor	edi, edi
$LN16@updateCent:
	mov	DWORD PTR _pDllUnit$222676[esp+44], edi

; 697  : 
; 698  : 			if(pCenterUnit == pLoopUnit)
; 699  : 			{
; 700  : 				gDLL->GameplayUnitVisibility(pDllUnit.get(), true, false, 0.01f);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+640]
	push	ecx
	mov	DWORD PTR [esp], 1008981770		; 3c23d70aH
	mov	DWORD PTR __$EHRec$[esp+56], 2
	push	0
	cmp	ebx, ebp
	jne	SHORT $LN2@updateCent
	push	1

; 701  : 			}
; 702  : 			else

	jmp	SHORT $LN153@updateCent
$LN2@updateCent:

; 703  : 			{
; 704  : 				gDLL->GameplayUnitVisibility(pDllUnit.get(), false, false, 0.01f);

	push	0
$LN153@updateCent:
	push	edi
	call	edx

; 705  : 			}
; 706  : 		}

	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	edi, edi
	je	SHORT $LN149@updateCent
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx
$LN149@updateCent:
	mov	edi, DWORD PTR _this$[esp+44]
$LN139@updateCent:

; 689  : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL5@updateCent
$LN4@updateCent:

; 707  : 	}
; 708  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$3:
	lea	ecx, DWORD PTR _hBestDefender$222651[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$8:
	mov	eax, DWORD PTR $T250429[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$9:
	lea	ecx, DWORD PTR _pDllUnit$222676[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?updateCenterUnit@CvPlot@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?updateCenterUnit@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateCenterUnit@CvPlot@@QAEXXZ ENDP			; CvPlot::updateCenterUnit
PUBLIC	?verifyUnitValidPlot@CvPlot@@QAEXXZ		; CvPlot::verifyUnitValidPlot
EXTRN	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z:PROC ; CvUnit::canEnterTerritory
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ:PROC	; CvUnit::jumpToNearestValidPlot
EXTRN	?isInCombat@CvUnit@@QBE_NXZ:PROC		; CvUnit::isInCombat
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?verifyUnitValidPlot@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?verifyUnitValidPlot@CvPlot@@QAEXXZ$0
__ehfuncinfo$?verifyUnitValidPlot@CvPlot@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?verifyUnitValidPlot@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?verifyUnitValidPlot@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_iVectorLoop$222760 = -436				; size = 4
_iUnitListSize$ = -432					; size = 4
_oldUnitList$ = -428					; size = 416
__$EHRec$ = -12						; size = 12
?verifyUnitValidPlot@CvPlot@@QAEXXZ PROC		; CvPlot::verifyUnitValidPlot, COMDAT
; _this$ = ecx

; 713  : {

	push	-1
	push	__ehhandler$?verifyUnitValidPlot@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	ebp
	push	esi

; 714  : 	FStaticVector<IDInfo, 50, true, c_eCiv5GameplayDLL, 0> oldUnitList;

	mov	eax, 50					; 00000032H
	lea	edx, DWORD PTR _oldUnitList$[esp+460]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _oldUnitList$[esp+460], eax
	mov	DWORD PTR _oldUnitList$[esp+452], edx

; 715  : 
; 716  : 	IDInfo* pUnitNode;
; 717  : 	CvUnit* pLoopUnit;
; 718  : 
; 719  : 	oldUnitList.clear();

	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[esp+460], 0
	mov	DWORD PTR _oldUnitList$[esp+456], ecx

; 720  : 
; 721  : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [edi+28], ecx
	jbe	SHORT $LN53@verifyUnit
	mov	esi, DWORD PTR [edi+24]
	jmp	SHORT $LN52@verifyUnit
$LN53@verifyUnit:
	xor	esi, esi
$LN52@verifyUnit:

; 722  : 
; 723  : 	while(pUnitNode != NULL)

	test	esi, esi
	je	SHORT $LN29@verifyUnit
	jmp	SHORT $LN30@verifyUnit
	npad	11
$LL143@verifyUnit:
	mov	eax, DWORD PTR _oldUnitList$[esp+460]
$LN30@verifyUnit:

; 724  : 	{
; 725  : 		oldUnitList.push_back(*pUnitNode);

	mov	BYTE PTR _oldUnitList$[esp+864], 0
	cmp	ecx, eax
	jne	SHORT $LN60@verifyUnit
	push	eax
	lea	ecx, DWORD PTR _oldUnitList$[esp+456]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,50,1,297,0>::GrowSize
	mov	ecx, DWORD PTR _oldUnitList$[esp+456]
$LN60@verifyUnit:
	mov	eax, DWORD PTR _oldUnitList$[esp+452]
	lea	eax, DWORD PTR [eax+ecx*8]
	test	eax, eax
	je	SHORT $LN63@verifyUnit
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _oldUnitList$[esp+456]
$LN63@verifyUnit:

; 726  : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi+24]
	sub	esi, eax
	add	esi, 8
	inc	ecx
	sar	esi, 3
	mov	DWORD PTR _oldUnitList$[esp+456], ecx
	cmp	esi, DWORD PTR [edi+28]
	jae	SHORT $LN74@verifyUnit
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN73@verifyUnit
$LN74@verifyUnit:
	xor	esi, esi
$LN73@verifyUnit:

; 722  : 
; 723  : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	SHORT $LL143@verifyUnit
	mov	edx, DWORD PTR _oldUnitList$[esp+452]
$LN29@verifyUnit:

; 727  : 	}
; 728  : 
; 729  : 	int iUnitListSize = (int) oldUnitList.size();
; 730  : 	for(int iVectorLoop = 0; iVectorLoop < (int) iUnitListSize; ++iVectorLoop)

	xor	ebx, ebx
	mov	eax, ecx
	mov	DWORD PTR _iUnitListSize$[esp+452], eax
	mov	DWORD PTR _iVectorLoop$222760[esp+452], ebx
	test	ecx, ecx
	jle	$LN26@verifyUnit
	npad	1
$LL28@verifyUnit:

; 731  : 	{
; 732  : 		pLoopUnit = GetPlayerUnit(oldUnitList[iVectorLoop]);

	mov	eax, DWORD PTR [edx+ebx*8]
	test	eax, eax
	jl	$LN27@verifyUnit
	cmp	eax, 64					; 00000040H
	jge	$LN27@verifyUnit
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+ebx*8+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	esi, eax

; 733  : 		if(pLoopUnit != NULL)

	test	esi, esi
	je	$LN27@verifyUnit

; 734  : 		{
; 735  : 			if(!pLoopUnit->isDelayedDeath())

	mov	ecx, esi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN27@verifyUnit

; 736  : 			{
; 737  : 				if(pLoopUnit->atPlot(*this))

	push	edi
	mov	ecx, esi
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	je	$LN27@verifyUnit

; 738  : 				{
; 739  : 					if(!(pLoopUnit->isCargo()))

	mov	ecx, esi
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	test	al, al
	jne	$LN27@verifyUnit

; 740  : 					{
; 741  : 						if(!(pLoopUnit->isInCombat()))

	mov	ecx, esi
	call	?isInCombat@CvUnit@@QBE_NXZ		; CvUnit::isInCombat
	test	al, al
	jne	$LN27@verifyUnit

; 742  : 						{
; 743  : 							// Unit not allowed to be here
; 744  : 							if(getNumFriendlyUnitsOfType(pLoopUnit) > /*1*/ GC.getPLOT_UNIT_LIMIT())

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	push	1
	push	esi
	mov	ecx, edi
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, ebp
	jle	SHORT $LN19@verifyUnit

; 745  : 							{
; 746  : 								if (!pLoopUnit->jumpToNearestValidPlot())

	mov	ecx, esi
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	test	al, al
	jne	SHORT $LN19@verifyUnit

; 747  : 								{
; 748  : 									pLoopUnit->kill(false);

	push	-1
	push	0
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 749  : 									pLoopUnit = NULL;
; 750  : 								}
; 751  : 							}
; 752  : 							
; 753  : 							if (pLoopUnit != NULL)

	jmp	SHORT $LN27@verifyUnit
$LN19@verifyUnit:

; 754  : 							{
; 755  : #ifdef NQ_NEVER_PUSH_OUT_OF_MINORS_ON_PEACE
; 756  : 								bool bIsOwnedByMinor = false;
; 757  : 								if (isOwned())

	mov	al, BYTE PTR [edi+4]
	xor	bl, bl
	cmp	al, -1
	je	SHORT $LN16@verifyUnit

; 758  : 								{
; 759  : 									if (GET_PLAYER(getOwner()).isMinorCiv())

	movsx	eax, al
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN16@verifyUnit

; 760  : 									{
; 761  : 										bIsOwnedByMinor = true;

	mov	bl, 1
$LN16@verifyUnit:

; 762  : 									}
; 763  : 								}
; 764  : 								// may want to make an extra check here about if it's owned by minor, we can still enter territory but with ignoring right of passage
; 765  : 								if(!isValidDomainForLocation(*pLoopUnit) || (!bIsOwnedByMinor && !(pLoopUnit->canEnterTerritory(getTeam(), false /*bIgnoreRightOfPassage*/, isCity()))))

	push	esi
	mov	ecx, edi
	call	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation
	test	al, al
	je	SHORT $LN14@verifyUnit
	test	bl, bl
	jne	SHORT $LN139@verifyUnit
	push	0
	mov	ecx, edi
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	push	ecx
	push	0
	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	push	eax
	mov	ecx, esi
	call	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z ; CvUnit::canEnterTerritory
	test	al, al
	jne	SHORT $LN139@verifyUnit
$LN14@verifyUnit:

; 766  : #else
; 767  : 								if(!isValidDomainForLocation(*pLoopUnit) || !(pLoopUnit->canEnterTerritory(getTeam(), false /*bIgnoreRightOfPassage*/, isCity())))
; 768  : #endif
; 769  : 								{
; 770  : 									if (!pLoopUnit->jumpToNearestValidPlot())

	mov	ecx, esi
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	test	al, al
	jne	SHORT $LN139@verifyUnit

; 771  : 										pLoopUnit->kill(false);

	push	-1
	push	0
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN139@verifyUnit:
	mov	ebx, DWORD PTR _iVectorLoop$222760[esp+452]
$LN27@verifyUnit:

; 727  : 	}
; 728  : 
; 729  : 	int iUnitListSize = (int) oldUnitList.size();
; 730  : 	for(int iVectorLoop = 0; iVectorLoop < (int) iUnitListSize; ++iVectorLoop)

	mov	eax, DWORD PTR _iUnitListSize$[esp+452]
	mov	edx, DWORD PTR _oldUnitList$[esp+452]
	inc	ebx
	cmp	ebx, eax
	mov	DWORD PTR _iVectorLoop$222760[esp+452], ebx
	jl	$LL28@verifyUnit
$LN26@verifyUnit:

; 772  : 								}
; 773  : 							}
; 774  : 						}
; 775  : 					}
; 776  : 				}
; 777  : 			}
; 778  : 		}
; 779  : 	}
; 780  : 
; 781  : 	// Unit not allowed in a plot owned by someone?
; 782  : 	if(isOwned())

	cmp	BYTE PTR [edi+4], -1
	je	$LN9@verifyUnit

; 783  : 	{
; 784  : 		for(int iVectorLoop = 0; iVectorLoop < (int) iUnitListSize; ++iVectorLoop)

	xor	ebp, ebp
	test	eax, eax
	jle	$LN9@verifyUnit
$LL11@verifyUnit:

; 785  : 		{
; 786  : 			pLoopUnit = GetPlayerUnit(oldUnitList[iVectorLoop]);

	mov	eax, DWORD PTR [edx+ebp*8]
	test	eax, eax
	jl	$LN10@verifyUnit
	cmp	eax, 64					; 00000040H
	jge	$LN10@verifyUnit
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+ebp*8+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	esi, eax

; 787  : 			if(pLoopUnit != NULL)

	test	esi, esi
	je	$LN10@verifyUnit

; 788  : 			{
; 789  : 				if(!pLoopUnit->isDelayedDeath())

	mov	ecx, esi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN10@verifyUnit

; 790  : 				{
; 791  : 					if(pLoopUnit->atPlot(*this))  // it may have jumped

	push	edi
	mov	ecx, esi
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	je	SHORT $LN10@verifyUnit

; 792  : 					{
; 793  : 						if(!(pLoopUnit->isInCombat()))

	mov	ecx, esi
	call	?isInCombat@CvUnit@@QBE_NXZ		; CvUnit::isInCombat
	test	al, al
	jne	SHORT $LN10@verifyUnit

; 794  : 						{
; 795  : #ifdef NQ_NEVER_PUSH_OUT_OF_MINORS_ON_PEACE
; 796  : 							if(pLoopUnit->getTeam() != getTeam() && !GET_PLAYER(getOwner()).isMinorCiv())

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	ecx, edi
	mov	ebx, eax
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	cmp	ebx, eax
	je	SHORT $LN10@verifyUnit
	movsx	eax, BYTE PTR [edi+4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN10@verifyUnit

; 797  : #else
; 798  : 							if(pLoopUnit->getTeam() != getTeam()) // && getTeam() == NO_TEAM)// || !GET_TEAM(getTeam()).isVassal(pLoopUnit->getTeam())))
; 799  : #endif
; 800  : 							{
; 801  : 								if(isVisibleEnemyUnit(pLoopUnit))

	push	esi
	mov	ecx, edi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	je	SHORT $LN10@verifyUnit

; 802  : 								{
; 803  : 									if(!(pLoopUnit->isInvisible(getTeam(), false)))

	push	1
	push	0
	mov	ecx, edi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	push	eax
	mov	ecx, esi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al
	jne	SHORT $LN10@verifyUnit

; 804  : 									{
; 805  : 										if (!pLoopUnit->jumpToNearestValidPlot())

	mov	ecx, esi
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	test	al, al
	jne	SHORT $LN10@verifyUnit

; 806  : 											pLoopUnit->kill(false);

	push	-1
	push	0
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN10@verifyUnit:
	mov	edx, DWORD PTR _oldUnitList$[esp+452]
	inc	ebp
	cmp	ebp, DWORD PTR _iUnitListSize$[esp+452]
	jl	$LL11@verifyUnit
$LN9@verifyUnit:
	pop	edi
	pop	esi

; 807  : 									}
; 808  : 								}
; 809  : 							}
; 810  : 						}
; 811  : 					}
; 812  : 				}
; 813  : 			}
; 814  : 		}
; 815  : 	}
; 816  : }

	lea	ecx, DWORD PTR _oldUnitList$[esp+456]
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+448], -1
	pop	ebx
	cmp	edx, ecx
	je	SHORT $LN117@verifyUnit
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN117@verifyUnit:
	mov	ecx, DWORD PTR __$EHRec$[esp+436]
	mov	DWORD PTR fs:0, ecx
	add	esp, 436				; 000001b4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?verifyUnitValidPlot@CvPlot@@QAEXXZ$0:
	lea	ecx, DWORD PTR _oldUnitList$[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>
__ehhandler$?verifyUnitValidPlot@CvPlot@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?verifyUnitValidPlot@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?verifyUnitValidPlot@CvPlot@@QAEXXZ ENDP		; CvPlot::verifyUnitValidPlot
PUBLIC	?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z
_TEXT	SEGMENT
_funcA$ = 8						; size = 4
_iData1A$ = 12						; size = 4
_iData2A$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
_funcB$ = 28						; size = 4
_iData1B$ = 32						; size = 4
_iData2B$ = 36						; size = 4
?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z PROC ; CvPlot::plotCheck, COMDAT
; _this$ = ecx

; 3431 : 	return const_cast<CvPlot*>(this)->plotCheck(funcA, iData1A, iData2A, eOwner, eTeam, funcB, iData1B, iData2B);

	jmp	?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCheck
?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ENDP ; CvPlot::plotCheck
_TEXT	ENDS
PUBLIC	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
EXTRN	?DoUpdateHappiness@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateHappiness
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?isLocalPlayer@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isLocalPlayer
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	__imp__strncmp:PROC
EXTRN	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetResourceQuantityRequirement
EXTRN	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlayer::changeSiphonLuxuryCount
EXTRN	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
EXTRN	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetGoldMaintenance
EXTRN	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z:PROC ; CvPlayer::changeImprovementCount
; Function compile flags: /Ogtpy
;	COMDAT ?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_bGiftFromMajor$ = -17					; size = 1
_owningPlayerID$225185 = -16				; size = 4
_newImprovementEntry$225222 = -12			; size = 4
_eOldImprovement$ = -8					; size = 4
_owningPlayer$225270 = -4				; size = 4
_owningPlayer$225232 = -4				; size = 4
_oldImprovementEntry$225187 = -4			; size = 4
_eNewValue$ = 8						; size = 4
_eBuilder$ = 12						; size = 4
?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::setImprovementType, COMDAT
; _this$ = ecx

; 6335 : {

	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, ecx

; 6336 : 	int iI;
; 6337 : 	ImprovementTypes eOldImprovement = getImprovementType();
; 6338 : 	bool bGiftFromMajor = false;
; 6339 : 	if (eBuilder != NO_PLAYER)

	mov	ecx, DWORD PTR _eBuilder$[esp+20]
	push	edi
	movsx	edi, BYTE PTR [esi+441]
	mov	DWORD PTR _eOldImprovement$[esp+28], edi
	mov	BYTE PTR _bGiftFromMajor$[esp+28], 0
	cmp	ecx, -1
	je	SHORT $LN69@setImprove

; 6340 : 	{
; 6341 : 		if (getOwner() != eBuilder && !GET_PLAYER(eBuilder).isMinorCiv())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, ecx
	je	SHORT $LN69@setImprove
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN69@setImprove

; 6342 : 		{
; 6343 : 			bGiftFromMajor = true;

	mov	BYTE PTR _bGiftFromMajor$[esp+28], 1
$LN69@setImprove:

; 6344 : 		}
; 6345 : 	}
; 6346 : 	bool bIgnoreResourceTechPrereq = bGiftFromMajor; // If it is a gift from a major civ, our tech limitations do not apply
; 6347 : 
; 6348 : 	if(eOldImprovement != eNewValue)

	cmp	edi, DWORD PTR _eNewValue$[esp+24]
	je	$LN519@setImprove
	push	ebx
	push	ebp

; 6349 : 	{
; 6350 : #ifdef AUI_PLOT_FIX_PILLAGED_PLOT_ON_NEW_IMPROVEMENT
; 6351 : 		SetImprovementPillaged(false);

	push	0
	mov	ecx, esi
	call	?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged

; 6352 : #endif
; 6353 : 		PlayerTypes owningPlayerID = getOwner();

	movsx	ecx, BYTE PTR [esi+4]
	mov	DWORD PTR _owningPlayerID$225185[esp+36], ecx

; 6354 : 		if(eOldImprovement != NO_IMPROVEMENT)

	cmp	edi, -1
	je	$LN137@setImprove

; 6355 : 		{
; 6356 : 			CvImprovementEntry& oldImprovementEntry = *GC.getImprovementInfo(eOldImprovement);

	mov	ebx, edi
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 6357 : 
; 6358 : 			// If this improvement can add culture to nearby improvements, update them as well
; 6359 : 			if(oldImprovementEntry.GetCultureAdjacentSameType() > 0)

	mov	ecx, eax
	mov	DWORD PTR _oldImprovementEntry$225187[esp+36], eax
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	test	eax, eax
	jle	SHORT $LN63@setImprove

; 6360 : 			{
; 6361 : 				for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	edi, edi
$LL65@setImprove:

; 6362 : 				{
; 6363 : 					CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edi
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 6364 : 					if(pAdjacentPlot && pAdjacentPlot->getImprovementType() == eOldImprovement)

	test	eax, eax
	je	SHORT $LN64@setImprove
	movsx	ecx, BYTE PTR [eax+441]
	cmp	ecx, ebx
	jne	SHORT $LN64@setImprove

; 6365 : 					{
; 6366 : 						pAdjacentPlot->updateYield();

	mov	ecx, eax
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN64@setImprove:
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL65@setImprove
$LN63@setImprove:

; 6367 : 					}
; 6368 : 				}
; 6369 : 			}
; 6370 : 
; 6371 : 			if(area())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN539@setImprove

; 6372 : 			{
; 6373 : 				area()->changeNumImprovements(eOldImprovement, -1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	ebx
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
$LN539@setImprove:

; 6374 : 			}
; 6375 : 			// Someone owns this plot
; 6376 : 			if(owningPlayerID != NO_PLAYER)

	cmp	DWORD PTR _owningPlayerID$225185[esp+36], -1
	je	$LN54@setImprove

; 6377 : 			{
; 6378 : 				CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	edi, DWORD PTR _owningPlayerID$225185[esp+36]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edi, 63236				; 0000f704H

; 6379 : 				owningPlayer.changeImprovementCount(eOldImprovement, -1);

	mov	eax, DWORD PTR _eOldImprovement$[esp+36]
	lea	ebx, DWORD PTR [edi+edx]
	push	-1
	push	eax
	mov	ecx, ebx
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 6380 : 
; 6381 : 				// Maintenance change!
; 6382 : 				if(MustPayMaintenanceHere(owningPlayerID))

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN101@setImprove
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN59@setImprove
$LN101@setImprove:

; 6383 : 				{
; 6384 : #ifdef AUI_WARNING_FIXES
; 6385 : 					GET_PLAYER(owningPlayerID).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-oldImprovementEntry.GetGoldMaintenance());
; 6386 : #else
; 6387 : 					GET_PLAYER(owningPlayerID).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	movsx	eax, BYTE PTR [esi+441]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	add	edi, edx
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN59@setImprove:

; 6388 : #endif
; 6389 : 				}
; 6390 : 
; 6391 : 				// Siphon resource changes
; 6392 : 				PlayerTypes eOldBuilder = GetPlayerThatBuiltImprovement();
; 6393 : 				if(oldImprovementEntry.GetLuxuryCopiesSiphonedFromMinor() > 0 && eOldBuilder != NO_PLAYER)

	mov	ebp, DWORD PTR _oldImprovementEntry$225187[esp+36]
	movsx	edi, BYTE PTR [esi+443]
	mov	ecx, ebp
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN57@setImprove
	cmp	edi, -1
	je	SHORT $LN57@setImprove

; 6394 : 				{
; 6395 : 					if (owningPlayer.isMinorCiv())

	mov	ecx, ebx
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN57@setImprove

; 6396 : 					{
; 6397 : 						GET_PLAYER(eOldBuilder).changeSiphonLuxuryCount(owningPlayerID, -1 * oldImprovementEntry.GetLuxuryCopiesSiphonedFromMinor());

	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebp
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	neg	eax
	push	eax
	mov	eax, DWORD PTR _owningPlayerID$225185[esp+40]
	push	eax
	mov	ecx, edi
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN57@setImprove:

; 6398 : 					}
; 6399 : 				}
; 6400 : 
; 6401 : 				// Update the amount of a Resource used up by the previous Improvement that is being removed
; 6402 : 				int iNumResourceInfos= GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ebp, eax

; 6403 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $LN54@setImprove
	npad	6
$LL56@setImprove:

; 6404 : 				{
; 6405 : 					if(oldImprovementEntry.GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	ecx, DWORD PTR _oldImprovementEntry$225187[esp+36]
	push	edi
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	SHORT $LN55@setImprove

; 6406 : 					{
; 6407 : 						owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, -oldImprovementEntry.GetResourceQuantityRequirement(iResourceLoop));

	mov	ecx, DWORD PTR _oldImprovementEntry$225187[esp+36]
	push	edi
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	neg	eax
	push	eax
	push	edi
	mov	ecx, ebx
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN55@setImprove:
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL56@setImprove
$LN54@setImprove:

; 6408 : 					}
; 6409 : 				}
; 6410 : 			}
; 6411 : 
; 6412 : 			// Someone had built something here in an unowned plot, remove effects of the old improvement
; 6413 : 			if(GetPlayerResponsibleForImprovement() != NO_PLAYER)

	mov	al, BYTE PTR [esi+444]
	cmp	al, -1
	je	SHORT $LN137@setImprove

; 6414 : 			{
; 6415 : 				// Maintenance change!
; 6416 : 				if(MustPayMaintenanceHere(GetPlayerResponsibleForImprovement()))

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN122@setImprove
	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN51@setImprove
$LN122@setImprove:

; 6417 : 				{
; 6418 : #ifdef AUI_WARNING_FIXES
; 6419 : 					GET_PLAYER(GetPlayerResponsibleForImprovement()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-oldImprovementEntry.GetGoldMaintenance());
; 6420 : #else
; 6421 : 					GET_PLAYER(GetPlayerResponsibleForImprovement()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	movsx	edi, BYTE PTR [esi+444]
	movsx	eax, BYTE PTR [esi+441]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN51@setImprove:

; 6422 : #endif
; 6423 : 				}
; 6424 : 
; 6425 : 				SetPlayerResponsibleForImprovement(NO_PLAYER);

	cmp	BYTE PTR [esi+444], -1
	je	SHORT $LN137@setImprove
	mov	BYTE PTR [esi+444], -1
$LN137@setImprove:

; 6426 : 			}
; 6427 : 		}
; 6428 : 
; 6429 : 		m_eImprovementType = eNewValue;

	mov	ebx, DWORD PTR _eNewValue$[esp+32]
	mov	BYTE PTR [esi+441], bl

; 6430 : 
; 6431 : 		if(getImprovementType() == NO_IMPROVEMENT)

	cmp	bl, -1
	jne	SHORT $LN144@setImprove

; 6432 : 		{
; 6433 : 			setImprovementDuration(0);

	xor	ecx, ecx
	mov	WORD PTR [esi+382], cx
$LN144@setImprove:

; 6434 : 		}
; 6435 : 
; 6436 : 		// Reset who cleared a Barb camp here last (if we're putting a new one down)
; 6437 : 		if(eNewValue == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	cmp	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	jne	SHORT $LN148@setImprove

; 6438 : 		{
; 6439 : 			SetPlayerThatClearedBarbCampHere(NO_PLAYER);

	mov	BYTE PTR [esi+446], -1
$LN148@setImprove:

; 6440 : 		}
; 6441 : 
; 6442 : 		setUpgradeProgress(0);

	xor	edx, edx
	mov	WORD PTR [esi+384], dx

; 6443 : 
; 6444 : #ifndef AUI_PLOT_FIX_PILLAGED_PLOT_ON_NEW_IMPROVEMENT
; 6445 : 		// make sure this plot is not disabled
; 6446 : 		SetImprovementPillaged(false);
; 6447 : #endif
; 6448 : 
; 6449 : 		for(iI = 0; iI < MAX_TEAMS; ++iI)

	xor	edi, edi
	npad	12
$LL48@setImprove:

; 6450 : 		{
; 6451 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 6452 : 			if (iI == OBSERVER_TEAM || GET_TEAM((TeamTypes)iI).isAlive())
; 6453 : #else
; 6454 : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	eax, edi
	imul	eax, 2980				; 00000ba4H
	cmp	DWORD PTR [eax+ecx+12], 0
	jle	SHORT $LN47@setImprove

; 6455 : #endif
; 6456 : 			{
; 6457 : 				if(isVisible((TeamTypes)iI))

	cmp	edi, -1
	je	SHORT $LN47@setImprove
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+edi*2], 0
	setg	al
	test	al, al
	je	SHORT $LN47@setImprove

; 6458 : 				{
; 6459 : 					setRevealedImprovementType((TeamTypes)iI, eNewValue);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
$LN47@setImprove:
	inc	edi
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL48@setImprove

; 6460 : 				}
; 6461 : 			}
; 6462 : 		}
; 6463 : 
; 6464 : 		if(m_eImprovementType != NO_IMPROVEMENT)

	cmp	BYTE PTR [esi+441], -1
	je	$LN541@setImprove

; 6465 : 		{
; 6466 : 			CvImprovementEntry& newImprovementEntry = *GC.getImprovementInfo(eNewValue);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 6467 : 
; 6468 : 			// If this improvement can add culture to nearby improvements, update them as well
; 6469 : 			if(newImprovementEntry.GetCultureAdjacentSameType() > 0)

	mov	ecx, eax
	mov	DWORD PTR _newImprovementEntry$225222[esp+36], eax
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	test	eax, eax
	jle	SHORT $LN39@setImprove

; 6470 : 			{
; 6471 : 				for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	edi, edi
$LL41@setImprove:

; 6472 : 				{
; 6473 : 					CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 6474 : 					if(pAdjacentPlot && pAdjacentPlot->getImprovementType() == eNewValue)

	test	eax, eax
	je	SHORT $LN40@setImprove
	movsx	edx, BYTE PTR [eax+441]
	cmp	edx, ebx
	jne	SHORT $LN40@setImprove

; 6475 : 					{
; 6476 : 						pAdjacentPlot->updateYield();

	mov	ecx, eax
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN40@setImprove:
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL41@setImprove
$LN39@setImprove:

; 6477 : 					}
; 6478 : 				}
; 6479 : 			}
; 6480 : 
; 6481 : 			if(area())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN37@setImprove

; 6482 : 			{
; 6483 : 				area()->changeNumImprovements(eNewValue, 1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	ebx
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
$LN37@setImprove:

; 6484 : 			}
; 6485 : 			if(isOwned())

	cmp	BYTE PTR [esi+4], -1
	je	$LN541@setImprove

; 6486 : 			{
; 6487 : 				CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	ebp, DWORD PTR _owningPlayerID$225185[esp+36]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, ebp
	imul	edi, 63236				; 0000f704H

; 6488 : 				owningPlayer.changeImprovementCount(eNewValue, 1);

	push	1
	lea	ecx, DWORD PTR [edi+eax]
	push	ebx
	mov	DWORD PTR _owningPlayer$225232[esp+44], ecx
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 6489 : 
; 6490 : 				//DLC_04 Achievement
; 6491 : 				if(owningPlayerID == GC.getGame().getActivePlayer() && strncmp(newImprovementEntry.GetType(), "IMPROVEMENT_MOTTE_BAILEY", 64) == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	ebp, eax
	jne	SHORT $LN34@setImprove
	mov	ecx, DWORD PTR _newImprovementEntry$225222[esp+36]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	64					; 00000040H
	push	OFFSET $SG225234
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN34@setImprove

; 6492 : 				{
; 6493 : 					//string compares are faster than testing if the mod is activated, so perform this after the compare test.
; 6494 : 					if(gDLL->IsModActivated(CIV5_DLC_04_SCENARIO_MODID))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	push	OFFSET $SG92482
	call	eax
	test	al, al
	je	SHORT $LN34@setImprove

; 6495 : 					{
; 6496 : 						gDLL->UnlockAchievement(ACHIEVEMENT_SCENARIO_04_BUILD_MOTTE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	157					; 0000009dH
	call	eax
$LN34@setImprove:

; 6497 : 					}
; 6498 : 				}
; 6499 : 				
; 6500 : 				// XP2 Achievement
; 6501 : 				if (eBuilder != NO_PLAYER && !GC.getGame().isGameMultiPlayer())

	mov	ebx, DWORD PTR _eBuilder$[esp+32]
	cmp	ebx, -1
	je	$LN30@setImprove
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN30@setImprove

; 6502 : 				{
; 6503 : 					if (GET_PLAYER(eBuilder).isHuman() && GET_PLAYER(eBuilder).isLocalPlayer() && strncmp(newImprovementEntry.GetType(), "IMPROVEMENT_FEITORIA", 64) == 0)

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebp, ebx
	imul	ebp, 63236				; 0000f704H
	add	ecx, ebp
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN30@setImprove
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edx+ebp]
	call	?isLocalPlayer@CvPlayer@@QBE_NXZ	; CvPlayer::isLocalPlayer
	test	al, al
	je	SHORT $LN30@setImprove
	mov	ecx, DWORD PTR _newImprovementEntry$225222[esp+36]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	64					; 00000040H
	push	OFFSET $SG225238
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@setImprove

; 6504 : 					{
; 6505 : 						if (owningPlayer.isMinorCiv())

	mov	ebp, DWORD PTR _owningPlayer$225232[esp+36]
	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN30@setImprove

; 6506 : 						{
; 6507 : 							PlayerTypes eAlly = owningPlayer.GetMinorCivAI()->GetAlly();

	mov	ecx, ebp
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly

; 6508 : 							if (eAlly != NO_PLAYER && eAlly != eBuilder)

	cmp	eax, -1
	je	SHORT $LN30@setImprove
	cmp	eax, ebx
	je	SHORT $LN30@setImprove

; 6509 : 							{
; 6510 : 								gDLL->UnlockAchievement(ACHIEVEMENT_XP2_24);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	266					; 0000010aH
	call	edx
$LN30@setImprove:

; 6511 : 							}
; 6512 : 						}
; 6513 : 					}
; 6514 : 				}
; 6515 : 
; 6516 : 				// Maintenance
; 6517 : 				if(MustPayMaintenanceHere(owningPlayerID))

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN203@setImprove
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN543@setImprove
$LN203@setImprove:

; 6518 : 				{
; 6519 : 					GET_PLAYER(owningPlayerID).GetTreasury()->ChangeBaseImprovementGoldMaintenance(newImprovementEntry.GetGoldMaintenance());

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebp, DWORD PTR _newImprovementEntry$225222[esp+36]
	add	edi, ecx
	mov	ecx, ebp
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
	jmp	SHORT $LN29@setImprove
$LN543@setImprove:
	mov	ebp, DWORD PTR _newImprovementEntry$225222[esp+36]
$LN29@setImprove:

; 6520 : 				}
; 6521 : 
; 6522 : 				// Siphon resource changes
; 6523 : 				if(newImprovementEntry.GetLuxuryCopiesSiphonedFromMinor() > 0 && eBuilder != NO_PLAYER)

	mov	ecx, ebp
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN544@setImprove
	cmp	ebx, -1
	je	SHORT $LN544@setImprove

; 6524 : 				{
; 6525 : 					if (owningPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _owningPlayer$225232[esp+36]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN544@setImprove

; 6526 : 					{
; 6527 : 						GET_PLAYER(eBuilder).changeSiphonLuxuryCount(owningPlayerID, newImprovementEntry.GetLuxuryCopiesSiphonedFromMinor());

	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebp
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	mov	edx, DWORD PTR _owningPlayerID$225185[esp+36]
	push	eax
	push	edx
	mov	ecx, edi
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN544@setImprove:

; 6528 : 					}
; 6529 : 				}
; 6530 : 
; 6531 : 				// Add Resource Quantity to total
; 6532 : 				if(getResourceType() != NO_RESOURCE)

	mov	al, BYTE PTR [esi+440]
	cmp	al, -1
	je	$LN540@setImprove

; 6533 : 				{
; 6534 : 					if(bIgnoreResourceTechPrereq || GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	cmp	BYTE PTR _bGiftFromMajor$[esp+36], 0
	jne	SHORT $LN547@setImprove
	movsx	ecx, al
	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN251@setImprove
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN251@setImprove
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN250@setImprove
$LN251@setImprove:
	or	eax, -1
$LN250@setImprove:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, edi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN540@setImprove
$LN547@setImprove:

; 6535 : 					{
; 6536 : 						if(newImprovementEntry.IsImprovementResourceTrade(getResourceType()))

	movsx	eax, BYTE PTR [esi+440]
	push	eax
	mov	ecx, ebp
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN540@setImprove

; 6537 : 						{
; 6538 : 							owningPlayer.changeNumResourceTotal(getResourceType(), getNumResourceForPlayer(owningPlayerID));

	mov	eax, DWORD PTR _owningPlayerID$225185[esp+36]
	movsx	edi, BYTE PTR [esi+440]
	push	0
	push	eax
	mov	ecx, esi
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	mov	ecx, DWORD PTR _owningPlayer$225232[esp+40]
	push	eax
	push	edi
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6539 : 
; 6540 : 							// Activate Resource city link?
; 6541 : 							if(GetResourceLinkedCity() != NULL && !IsResourceLinkedCityActive())

	mov	ecx, DWORD PTR [esi+132]
	mov	edx, DWORD PTR [esi+128]
	push	ecx
	push	edx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN540@setImprove
	mov	al, BYTE PTR [esi+462]
	test	al, 16					; 00000010H
	jne	SHORT $LN540@setImprove

; 6542 : 								SetResourceLinkedCityActive(true);

	movsx	ecx, BYTE PTR [esi+440]
	or	al, 16					; 00000010H
	mov	BYTE PTR [esi+462], al
	movsx	eax, BYTE PTR [esi+458]
	push	eax
	mov	eax, DWORD PTR [esi+132]
	push	ecx
	mov	ecx, DWORD PTR [esi+128]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	mov	ecx, eax
	call	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z ; CvCity::ChangeNumResourceLocal
$LN540@setImprove:

; 6543 : 						}
; 6544 : 					}
; 6545 : 				}
; 6546 : 
; 6547 : 				ResourceTypes eResource = getResourceType(getTeam());

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN334@setImprove
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN334@setImprove
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN333@setImprove
$LN334@setImprove:
	or	eax, -1
$LN333@setImprove:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 6548 : 				if(bIgnoreResourceTechPrereq)

	cmp	BYTE PTR _bGiftFromMajor$[esp+36], 0
	mov	edi, eax
	je	SHORT $LN351@setImprove

; 6549 : 					eResource = getResourceType();

	movsx	edi, BYTE PTR [esi+440]
$LN351@setImprove:

; 6550 : 
; 6551 : 				if(eResource != NO_RESOURCE)

	cmp	edi, -1
	je	SHORT $LN541@setImprove

; 6552 : 				{
; 6553 : 					if(newImprovementEntry.IsImprovementResourceTrade(eResource))

	mov	ecx, DWORD PTR _newImprovementEntry$225222[esp+36]
	push	edi
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN541@setImprove

; 6554 : 					{
; 6555 : 						if(GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN541@setImprove

; 6556 : 						{
; 6557 : 							owningPlayer.DoUpdateHappiness();

	mov	ecx, DWORD PTR _owningPlayer$225232[esp+36]
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN541@setImprove:

; 6558 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6559 : 							owningPlayer.doSelfConsistencyCheckAllCities();
; 6560 : #endif
; 6561 : 						}
; 6562 : 					}
; 6563 : 				}
; 6564 : 			}
; 6565 : 		}
; 6566 : 
; 6567 : 		// If we're removing an Improvement that hooked up a resource then we need to take away the bonus
; 6568 : 		if(eOldImprovement != NO_IMPROVEMENT && !isCity())

	cmp	DWORD PTR _eOldImprovement$[esp+36], -1
	je	$LN8@setImprove
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN536@setImprove
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN536@setImprove
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	$LN8@setImprove
$LN536@setImprove:

; 6569 : 		{
; 6570 : 			if(isOwned())

	mov	cl, BYTE PTR [esi+4]
	cmp	cl, -1
	je	$LN8@setImprove

; 6571 : 			{
; 6572 : 				CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	ebx, DWORD PTR _owningPlayerID$225185[esp+36]

; 6573 : 				// Remove Resource Quantity from total
; 6574 : 				if(getResourceType() != NO_RESOURCE)

	mov	al, BYTE PTR [esi+440]
	mov	ebp, ebx
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	al, -1
	je	$LN549@setImprove

; 6575 : 				{
; 6576 : 					if(IsImprovedByGiftFromMajor() || // If old improvement was a gift, it ignored our tech limits, so be sure to remove resources properly
; 6577 : 						GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	test	BYTE PTR [esi+462], 32			; 00000020H
	jne	SHORT $LN548@setImprove
	movsx	edx, al
	movsx	eax, cl
	cmp	eax, -1
	je	SHORT $LN411@setImprove
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN411@setImprove
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN410@setImprove
$LN411@setImprove:
	or	eax, -1
$LN410@setImprove:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, edi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN549@setImprove
$LN548@setImprove:

; 6578 : 					{
; 6579 : 						if(GC.getImprovementInfo(eOldImprovement)->IsImprovementResourceTrade(getResourceType()))

	movsx	eax, BYTE PTR [esi+440]
	mov	edx, DWORD PTR _eOldImprovement$[esp+36]
	push	eax
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN549@setImprove

; 6580 : 						{
; 6581 : 							owningPlayer.changeNumResourceTotal(getResourceType(), -getNumResourceForPlayer(owningPlayerID));

	movsx	edi, BYTE PTR [esi+440]
	push	0
	push	ebx
	mov	ecx, esi
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	neg	eax
	push	eax
	push	edi
	mov	ecx, ebp
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6582 : 
; 6583 : 							// Disconnect resource link
; 6584 : 							if(GetResourceLinkedCity() != NULL)

	mov	eax, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [esi+128]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN549@setImprove

; 6585 : 								SetResourceLinkedCityActive(false);

	mov	al, BYTE PTR [esi+462]
	test	al, 16					; 00000010H
	je	SHORT $LN549@setImprove
	movsx	ecx, BYTE PTR [esi+440]
	mov	edx, DWORD PTR [esi+132]
	and	al, 239					; 000000efH
	mov	BYTE PTR [esi+462], al
	movsx	eax, BYTE PTR [esi+458]
	neg	eax
	push	eax
	mov	eax, DWORD PTR [esi+128]
	push	ecx
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	mov	ecx, eax
	call	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z ; CvCity::ChangeNumResourceLocal
$LN549@setImprove:

; 6586 : 						}
; 6587 : 					}
; 6588 : 				}
; 6589 : 
; 6590 : 				ResourceTypes eResource = getResourceType(getTeam());

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN492@setImprove
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN492@setImprove
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN491@setImprove
$LN492@setImprove:
	or	eax, -1
$LN491@setImprove:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	edi, eax

; 6591 : 
; 6592 : 				if(eResource != NO_RESOURCE)

	cmp	edi, -1
	je	SHORT $LN8@setImprove

; 6593 : 				{
; 6594 : 					if(GC.getImprovementInfo(eOldImprovement)->IsImprovementResourceTrade(eResource))

	mov	eax, DWORD PTR _eOldImprovement$[esp+36]
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN8@setImprove

; 6595 : 					{
; 6596 : 						if(GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN8@setImprove

; 6597 : 						{
; 6598 : 							owningPlayer.DoUpdateHappiness();

	mov	ecx, ebp
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN8@setImprove:

; 6599 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6600 : 							owningPlayer.doSelfConsistencyCheckAllCities();
; 6601 : #endif
; 6602 : 						}
; 6603 : 					}
; 6604 : 				}
; 6605 : 			}
; 6606 : 		}
; 6607 : 
; 6608 : 		updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6609 : 
; 6610 : 		// Update the amount of a Resource used up by this Improvement
; 6611 : 		if(isOwned() && eNewValue != NO_IMPROVEMENT)

	cmp	BYTE PTR [esi+4], -1
	je	SHORT $LN538@setImprove
	cmp	DWORD PTR _eNewValue$[esp+32], -1
	je	SHORT $LN538@setImprove

; 6612 : 		{
; 6613 : 			CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	eax, DWORD PTR _owningPlayerID$225185[esp+36]

; 6614 : 			CvImprovementEntry& newImprovementEntry = *GC.getImprovementInfo(eNewValue);

	mov	ecx, DWORD PTR _eNewValue$[esp+32]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _owningPlayer$225270[esp+40], eax
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 6615 : 			int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ebp, eax

; 6616 : 			for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $LN538@setImprove
$LL6@setImprove:

; 6617 : 			{
; 6618 : 				if(newImprovementEntry.GetResourceQuantityRequirement(iResourceLoop) > 0)

	push	edi
	mov	ecx, ebx
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	SHORT $LN5@setImprove

; 6619 : 				{
; 6620 : 					owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, newImprovementEntry.GetResourceQuantityRequirement(iResourceLoop));

	push	edi
	mov	ecx, ebx
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	mov	ecx, DWORD PTR _owningPlayer$225270[esp+36]
	push	eax
	push	edi
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN5@setImprove:
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL6@setImprove
$LN538@setImprove:

; 6621 : 				}
; 6622 : 			}
; 6623 : 		}
; 6624 : 
; 6625 : 		// Update the most recent builder
; 6626 : 		if (GetPlayerThatBuiltImprovement() != eBuilder)

	movsx	edx, BYTE PTR [esi+443]
	mov	eax, DWORD PTR _eBuilder$[esp+32]
	pop	ebp
	pop	ebx
	cmp	edx, eax
	je	SHORT $LN512@setImprove

; 6627 : 		{
; 6628 : 			SetPlayerThatBuiltImprovement(eBuilder);

	mov	BYTE PTR [esi+443], al
$LN512@setImprove:

; 6629 : 		}
; 6630 : 
; 6631 : 		SetImprovedByGiftFromMajor(bGiftFromMajor); // Assumes that only one tile improvement can be on this plot at a time

	mov	al, BYTE PTR _bGiftFromMajor$[esp+28]
	shl	al, 5
	xor	al, BYTE PTR [esi+462]
	and	al, 32					; 00000020H
	xor	BYTE PTR [esi+462], al

; 6632 : 
; 6633 : 		if(GC.getGame().isDebugMode())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN519@setImprove

; 6634 : 		{
; 6635 : 			setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	33					; 00000021H
	call	edx
	or	BYTE PTR [esi+462], 1
$LN519@setImprove:
	pop	edi
	pop	esi

; 6636 : 		}
; 6637 : 	}
; 6638 : }

	add	esp, 20					; 00000014H
	ret	8
?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::setImprovementType
_TEXT	ENDS
PUBLIC	__real@40400000
PUBLIC	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z	; CvPlot::setRevealed
EXTRN	?setRevealed@CvCity@@QAE_NW4TeamTypes@@_N@Z:PROC ; CvCity::setRevealed
EXTRN	?CancelActivePlayerEndTurn@@YA_NXZ:PROC		; CancelActivePlayerEndTurn
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?getNumMembers@CvTeam@@QBEHXZ:PROC		; CvTeam::getNumMembers
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?getBarbCampGold@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getBarbCampGold
EXTRN	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z:PROC ; CvGlobals::getHandicapInfo
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?getFirstFinderGold@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getFirstFinderGold
EXTRN	?isObserver@CvTeam@@QBE_NXZ:PROC		; CvTeam::isObserver
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?ChangeNumNaturalWondersDiscoveredInArea@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeNumNaturalWondersDiscoveredInArea
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?GetNumNaturalWonders@CvMap@@QBEHXZ:PROC	; CvMap::GetNumNaturalWonders
EXTRN	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ:PROC ; CvTeam::GetNumNaturalWondersDiscovered
EXTRN	?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z:PROC ; CvTeam::ChangeNumNaturalWondersDiscovered
EXTRN	_memset:PROC
;	COMDAT __real@40400000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
_TEXT	SEGMENT
_bImprovementVisibilityChanged$226215 = -1054		; size = 1
_bEligibleForAchievement$226084 = -1054			; size = 1
$T252790 = -1053					; size = 1
_bFirstFinder$226122 = -1053				; size = 1
_bResult$226094 = -1053					; size = 1
tv2162 = -1052						; size = 4
_iFinderGold$226121 = -1052				; size = 4
_args$226093 = -1052					; size = 4
_bVisbilityUpdated$ = -1045				; size = 1
tv2216 = -1044						; size = 4
_fDelay$226160 = -1044					; size = 4
_kTeam$226123 = -1044					; size = 4
_pCity$ = -1040						; size = 4
_eActiveTeam$ = -1036					; size = 4
tv1519 = -1032						; size = 4
$T252116 = -1032					; size = 4
_pDllPlot$226187 = -1032				; size = 4
_iGoldPerTeamMember$226149 = -1032			; size = 4
_pInterface$ = -1028					; size = 4
tv1482 = -1024						; size = 4
_strSummary$226197 = -1020				; size = 28
_strFeatureType$226176 = -1020				; size = 28
_strBuffer$226194 = -992				; size = 28
_strText$226096 = -964					; size = 80
_strSummary$226105 = -884				; size = 80
_kPopupInfo$226170 = -804				; size = 536
_text$226159 = -268					; size = 256
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_bTerrainOnly$ = 16					; size = 1
_eFromTeam$ = 20					; size = 4
?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z PROC	; CvPlot::setRevealed, COMDAT
; _this$ = ecx

; 8668 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1044				; 00000414H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 8669 : 	int iI;
; 8670 : 
; 8671 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8672 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8673 : 
; 8674 : 	CvCity* pCity = getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	push	edi
	test	eax, eax
	jl	SHORT $LN95@setReveale@4
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN95@setReveale@4
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pCity$[esp+1072], eax
	jmp	SHORT $LN96@setReveale@4
$LN95@setReveale@4:
	mov	DWORD PTR _pCity$[esp+1072], 0
$LN96@setReveale@4:

; 8675 : 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam

; 8676 : 	ICvUserInterface2* pInterface =  GC.GetEngineUserInterface();
; 8677 : 
; 8678 : 	bool bVisbilityUpdated = false;
; 8679 : 	if(isRevealed(eTeam) != bNewValue)

	mov	ebp, DWORD PTR _eTeam$[esp+1068]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edi, ebp
	shr	edi, 5
	mov	edx, edi
	shl	edx, 5
	mov	DWORD PTR _eActiveTeam$[esp+1072], eax
	mov	ecx, ebp
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _pInterface$[esp+1072], ebx
	mov	BYTE PTR _bVisbilityUpdated$[esp+1072], 0
	mov	DWORD PTR tv1482[esp+1072], edi
	test	eax, DWORD PTR [esi+edi*4+8]
	setne	cl
	cmp	cl, BYTE PTR _bNewValue$[esp+1068]
	je	$LN18@setReveale@4

; 8680 : 	{
; 8681 : 
; 8682 : 		m_bfRevealed.ToggleBit(eTeam);

	mov	edx, edi
	shl	edx, 5
	mov	ecx, ebp
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	xor	DWORD PTR [esi+edi*4+8], eax

; 8683 : 
; 8684 : 		bool bEligibleForAchievement = GET_PLAYER(GC.getGame().getActivePlayer()).isHuman() && !GC.getGame().isGameMultiPlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN83@setReveale@4
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	mov	BYTE PTR _bEligibleForAchievement$226084[esp+1072], 1
	test	al, al
	je	SHORT $LN84@setReveale@4
$LN83@setReveale@4:
	mov	BYTE PTR _bEligibleForAchievement$226084[esp+1072], 0
$LN84@setReveale@4:

; 8685 : 
; 8686 : 		if(area())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN79@setReveale@4

; 8687 : 		{
; 8688 : 			area()->changeNumRevealedTiles(eTeam, (bNewValue ? 1 : -1));

	mov	eax, DWORD PTR [esi+356]
	xor	ecx, ecx
	cmp	BYTE PTR _bNewValue$[esp+1068], cl
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebp
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ; CvArea::changeNumRevealedTiles
$LN79@setReveale@4:

; 8689 : 		}
; 8690 : 
; 8691 : 		// Natural Wonder
; 8692 : 		if(eTeam != BARBARIAN_TEAM)

	cmp	ebp, 63					; 0000003fH
	je	$LN76@setReveale@4

; 8693 : 		{
; 8694 : 			if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	$LN76@setReveale@4

; 8695 : 			{
; 8696 : 				if(GC.getFeatureInfo(getFeatureType())->IsNaturalWonder())

	movsx	edx, al
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	$LN76@setReveale@4

; 8697 : 				{
; 8698 : 					GET_TEAM(eTeam).ChangeNumNaturalWondersDiscovered(1);

	mov	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edi, ebp
	imul	edi, 2980				; 00000ba4H
	push	1
	lea	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR tv1519[esp+1076], edi
	call	?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z ; CvTeam::ChangeNumNaturalWondersDiscovered

; 8699 : 
; 8700 : 					int iNumNaturalWondersLeft = GC.getMap().GetNumNaturalWonders() - GET_TEAM(eTeam).GetNumNaturalWondersDiscovered();

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	add	ecx, edi
	call	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ ; CvTeam::GetNumNaturalWondersDiscovered
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, eax
	call	?GetNumNaturalWonders@CvMap@@QBEHXZ	; CvMap::GetNumNaturalWonders

; 8701 : 
; 8702 : 					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edi, eax
	mov	eax, DWORD PTR [edx+12]
	sub	edi, ebx
	call	eax
	mov	ebx, eax

; 8703 : 					if (pkScriptSystem) 

	test	ebx, ebx
	je	$LN75@setReveale@4

; 8704 : 					{
; 8705 : 						CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226093[esp+1072]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 8706 : 						args->Push(eTeam);

	mov	ecx, DWORD PTR _args$226093[esp+1072]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+1084], 0
	call	eax

; 8707 : 						args->Push(getFeatureType());

	mov	al, BYTE PTR [esi+432]
	mov	ecx, DWORD PTR _args$226093[esp+1072]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	movsx	eax, al
	push	eax
	call	edx

; 8708 : 						args->Push(getX());

	mov	ecx, DWORD PTR _args$226093[esp+1072]
	movsx	edx, WORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	call	eax

; 8709 : 						args->Push(getY());

	mov	ecx, DWORD PTR _args$226093[esp+1072]
	movsx	eax, WORD PTR [esi+2]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 8710 : 						args->Push((getNumMajorCivsRevealed() == 0)); // bFirst

	cmp	BYTE PTR [esi+454], 0
	mov	ecx, DWORD PTR _args$226093[esp+1072]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	sete	dl
	movzx	edx, dl
	push	edx
	call	eax

; 8711 : 
; 8712 : 						bool bResult = false;
; 8713 : 						LuaSupport::CallHook(pkScriptSystem, "NaturalWonderDiscovered", args.get(), bResult);

	mov	edx, DWORD PTR _args$226093[esp+1072]
	lea	ecx, DWORD PTR _bResult$226094[esp+1072]
	push	ecx
	push	edx
	push	OFFSET $SG226095
	push	ebx
	mov	BYTE PTR _bResult$226094[esp+1088], 0
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 8714 : 					}

	lea	ecx, DWORD PTR _args$226093[esp+1072]
	mov	DWORD PTR __$EHRec$[esp+1080], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN75@setReveale@4:

; 8715 : 
; 8716 : 					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_FOUND_NATURAL_WONDER");

	mov	ebx, DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	lea	eax, DWORD PTR _strText$226096[esp+1072]
	push	OFFSET $SG226098
	push	eax
	call	ebx
	add	esp, 8

; 8717 : 					strText << iNumNaturalWondersLeft;

	push	edi
	lea	ecx, DWORD PTR _strText$226096[esp+1076]
	mov	DWORD PTR __$EHRec$[esp+1084], 1
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 8718 : 					strText << GC.getFeatureInfo(getFeatureType())->GetTextKey();

	movsx	ecx, BYTE PTR [esi+432]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	push	eax
	lea	ecx, DWORD PTR _strText$226096[esp+1076]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 8719 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_NATURAL_WONDER");

	lea	edx, DWORD PTR _strSummary$226105[esp+1072]
	push	OFFSET $SG226107
	push	edx
	call	ebx
	add	esp, 8
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+1080], 2
	mov	DWORD PTR tv2162[esp+1072], ebx
	npad	11
$LL74@setReveale@4:

; 8720 : 
; 8721 : 					// Loop through all players to give them a Notification
; 8722 : 					for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)
; 8723 : 					{
; 8724 : 						CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 8725 : 						if(playerI.isAlive())

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	edi, DWORD PTR [ebx+eax]
	je	$LN73@setReveale@4

; 8726 : 						{
; 8727 : 							if(playerI.getTeam() == eTeam)

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN184@setReveale@4
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN185@setReveale@4
$LN184@setReveale@4:
	or	eax, -1
$LN185@setReveale@4:
	cmp	eax, ebp
	jne	$LN73@setReveale@4

; 8728 : 							{
; 8729 : 								// Num Natural Wonders found in a player's area
; 8730 : 								if(playerI.getStartingPlot() != NULL)

	mov	ecx, edi
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	je	SHORT $LN434@setReveale@4

; 8731 : 								{
; 8732 : 									if(getArea() == playerI.getStartingPlot()->getArea())

	mov	ebx, DWORD PTR [esi+356]
	mov	ecx, edi
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	cmp	ebx, DWORD PTR [eax+356]
	jne	SHORT $LN432@setReveale@4

; 8733 : 									{
; 8734 : 										playerI.ChangeNumNaturalWondersDiscoveredInArea(1);

	push	1
	mov	ecx, edi
	call	?ChangeNumNaturalWondersDiscoveredInArea@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumNaturalWondersDiscoveredInArea
$LN432@setReveale@4:
	mov	ebx, DWORD PTR tv2162[esp+1072]
$LN434@setReveale@4:

; 8735 : 									}
; 8736 : 								}
; 8737 : 
; 8738 : 								playerI.DoUpdateHappiness();

	mov	ecx, edi
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness

; 8739 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 8740 : 								playerI.doSelfConsistencyCheckAllCities();
; 8741 : #endif
; 8742 : 
; 8743 : 								// Add World Anchor
; 8744 : 								if(eTeam == eActiveTeam)

	cmp	ebp, DWORD PTR _eActiveTeam$[esp+1072]
	jne	SHORT $LN67@setReveale@4

; 8745 : 									SetWorldAnchor(WORLD_ANCHOR_NATURAL_WONDER, getFeatureType());

	movsx	eax, BYTE PTR [esi+432]
	push	eax
	push	0
	mov	ecx, esi
	call	?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z ; CvPlot::SetWorldAnchor
$LN67@setReveale@4:

; 8746 : 
; 8747 : 								// Notification
; 8748 : 								CvNotifications* pNotifications = GET_PLAYER((PlayerTypes)iI).GetNotifications();

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebx
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	edi, eax

; 8749 : 								if(pNotifications)

	test	edi, edi
	je	SHORT $LN73@setReveale@4

; 8750 : 								{
; 8751 : 									pNotifications->Add(NOTIFICATION_EXPLORATION_RACE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), getFeatureType());

	mov	al, BYTE PTR [esi+432]
	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	-1
	movsx	eax, al
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strSummary$226105[esp+1088]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strText$226096[esp+1092]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-1753116946				; 97818eeeH
	mov	ecx, edi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN73@setReveale@4:
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	mov	DWORD PTR tv2162[esp+1072], ebx
	jl	$LL74@setReveale@4

; 8752 : 								}
; 8753 : 							}
; 8754 : 						}
; 8755 : 					}
; 8756 : 
; 8757 : 					// FIRST (MAJOR CIV) FINDER?
; 8758 : 					int iFinderGold = 0;
; 8759 : 					bool bFirstFinder = false;
; 8760 : 					CvTeam& kTeam = GET_TEAM(eTeam);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	edx, DWORD PTR tv1519[esp+1072]
	add	ecx, edx
	mov	DWORD PTR _iFinderGold$226121[esp+1072], 0
	mov	BYTE PTR _bFirstFinder$226122[esp+1072], 0
	mov	DWORD PTR _kTeam$226123[esp+1072], ecx

; 8761 : 					if(!kTeam.isMinorCiv() && !kTeam.isBarbarian() && !kTeam.isObserver())

	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	test	al, al
	jne	$LN437@setReveale@4
	mov	ecx, DWORD PTR _kTeam$226123[esp+1072]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	test	al, al
	jne	$LN437@setReveale@4
	mov	ecx, DWORD PTR _kTeam$226123[esp+1072]
	call	?isObserver@CvTeam@@QBE_NXZ		; CvTeam::isObserver
	test	al, al
	jne	$LN437@setReveale@4

; 8762 : 					{
; 8763 : 						if(getNumMajorCivsRevealed() == 0)

	cmp	BYTE PTR [esi+454], al
	jne	SHORT $LN64@setReveale@4

; 8764 : 						{
; 8765 : 							changeNumMajorCivsRevealed(1);
; 8766 : 							bFirstFinder = true;
; 8767 : 
; 8768 : 							// Does it yields gold to the first major civ finder?
; 8769 : 							iFinderGold = GC.getFeatureInfo(getFeatureType())->getFirstFinderGold();

	movsx	eax, BYTE PTR [esi+432]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR [esi+454], 1
	mov	BYTE PTR _bFirstFinder$226122[esp+1076], 1
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getFirstFinderGold@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getFirstFinderGold
	mov	DWORD PTR _iFinderGold$226121[esp+1072], eax
	xor	ebx, ebx
	npad	9
$LL63@setReveale@4:

; 8770 : 
; 8771 : 							// Does a player on this team have a trait that gives first finder gold?
; 8772 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)
; 8773 : 							{
; 8774 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 8775 : 								if(playerI.isAlive())

	cmp	BYTE PTR [ebx+ecx+2256], 0
	lea	edi, DWORD PTR [ebx+ecx]
	je	SHORT $LN62@setReveale@4

; 8776 : 								{
; 8777 : 									if(playerI.getTeam() == eTeam)

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	eax, ebp
	jne	SHORT $LN62@setReveale@4

; 8778 : 									{
; 8779 : 										iFinderGold += playerI.GetPlayerTraits()->GetNaturalWonderFirstFinderGold();

	mov	ecx, edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	edx, DWORD PTR [eax+204]
	add	DWORD PTR _iFinderGold$226121[esp+1072], edx
$LN62@setReveale@4:
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	jl	SHORT $LL63@setReveale@4

; 8780 : 									}
; 8781 : 								}
; 8782 : 							}
; 8783 : 						}
; 8784 : 						else

	jmp	SHORT $LN55@setReveale@4
$LN64@setReveale@4:

; 8785 : 						{
; 8786 : 							// Does a player on this team have a trait that gives subsequent finder gold?
; 8787 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	xor	ebx, ebx
	npad	15
$LL57@setReveale@4:

; 8788 : 							{
; 8789 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 8790 : 								if(playerI.isAlive())

	cmp	BYTE PTR [ebx+eax+2256], 0
	lea	edi, DWORD PTR [ebx+eax]
	je	SHORT $LN56@setReveale@4

; 8791 : 								{
; 8792 : 									if(playerI.getTeam() == eTeam)

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	eax, ebp
	jne	SHORT $LN56@setReveale@4

; 8793 : 									{
; 8794 : 										iFinderGold += playerI.GetPlayerTraits()->GetNaturalWonderSubsequentFinderGold();

	mov	ecx, edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [eax+208]
	add	DWORD PTR _iFinderGold$226121[esp+1072], ecx
$LN56@setReveale@4:
	add	ebx, 63236				; 0000f704H
	cmp	ebx, 1391192				; 00153a58H
	jl	SHORT $LL57@setReveale@4
$LN55@setReveale@4:

; 8795 : 									}
; 8796 : 								}
; 8797 : 							}
; 8798 : 						}
; 8799 : 
; 8800 : 						// Scale up or down based on difficulty
; 8801 : 						if(iFinderGold > 0)

	cmp	DWORD PTR _iFinderGold$226121[esp+1072], 0
	jle	$LN437@setReveale@4

; 8802 : 						{
; 8803 : 							const int iStandardHandicap = GC.getInfoTypeForString("HANDICAP_PRINCE");

	push	0
	push	OFFSET $SG226143
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 8804 : 							if(iStandardHandicap >= 0)

	test	eax, eax
	jl	SHORT $LN436@setReveale@4

; 8805 : 							{
; 8806 : 								const CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo((HandicapTypes)iStandardHandicap);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo

; 8807 : 								if(pkHandicapInfo)

	test	eax, eax
	je	SHORT $LN436@setReveale@4

; 8808 : 								{
; 8809 : 									iFinderGold *= pkHandicapInfo->getBarbCampGold();

	mov	ecx, eax
	call	?getBarbCampGold@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getBarbCampGold

; 8810 : 									iFinderGold /= GC.getGame().getHandicapInfo().getBarbCampGold();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	imul	edi, DWORD PTR _iFinderGold$226121[esp+1072]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getBarbCampGold@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getBarbCampGold
	mov	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	DWORD PTR _iFinderGold$226121[esp+1072], eax
$LN436@setReveale@4:

; 8811 : 								}
; 8812 : 							}
; 8813 : 						}
; 8814 : 
; 8815 : 						if(iFinderGold > 0)

	cmp	DWORD PTR _iFinderGold$226121[esp+1072], 0
	jle	$LN437@setReveale@4

; 8816 : 						{
; 8817 : 							// Compute gold per team member
; 8818 : 							int iGoldPerTeamMember = iFinderGold;
; 8819 : 
; 8820 : 							if(kTeam.getNumMembers() > 0)

	mov	edi, DWORD PTR _kTeam$226123[esp+1072]
	mov	ebx, DWORD PTR _iFinderGold$226121[esp+1072]
	mov	ecx, edi
	mov	DWORD PTR _iGoldPerTeamMember$226149[esp+1072], ebx
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	test	eax, eax
	jle	SHORT $LN48@setReveale@4

; 8821 : 							{
; 8822 : 								iGoldPerTeamMember = iFinderGold / kTeam.getNumMembers();

	mov	ecx, edi
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	mov	ecx, eax
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	DWORD PTR _iGoldPerTeamMember$226149[esp+1072], eax
$LN48@setReveale@4:

; 8823 : 							}
; 8824 : 
; 8825 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	xor	edi, edi
	npad	4
$LL47@setReveale@4:

; 8826 : 							{
; 8827 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 8828 : 								if(playerI.isAlive())

	cmp	BYTE PTR [edi+edx+2256], 0
	lea	ecx, DWORD PTR [edi+edx]
	je	SHORT $LN43@setReveale@4

; 8829 : 								{
; 8830 : 									if(playerI.getTeam() == eTeam)

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN249@setReveale@4
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN250@setReveale@4
$LN249@setReveale@4:
	or	eax, -1
$LN250@setReveale@4:
	cmp	eax, ebp
	jne	SHORT $LN43@setReveale@4

; 8831 : 									{
; 8832 : 										playerI.GetTreasury()->ChangeGold(iGoldPerTeamMember);

	mov	eax, DWORD PTR _iGoldPerTeamMember$226149[esp+1072]
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold
$LN43@setReveale@4:

; 8833 : 									}
; 8834 : 								}
; 8835 : 
; 8836 : 								if(eTeam == eActiveTeam)

	cmp	ebp, DWORD PTR _eActiveTeam$[esp+1072]
	jne	SHORT $LN46@setReveale@4

; 8837 : 								{
; 8838 : 									char text[256] = {0};

	push	255					; 000000ffH
	lea	ecx, DWORD PTR _text$226159[esp+1077]
	push	0
	push	ecx
	call	_memset

; 8839 : 									float fDelay = GC.getPOST_COMBAT_TEXT_DELAY() * 3;

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8040
	fmul	DWORD PTR __real@40400000

; 8840 : 									text[0] = NULL;
; 8841 : 									sprintf_s(text, "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]", iFinderGold);

	push	ebx
	lea	edx, DWORD PTR _text$226159[esp+1088]
	push	OFFSET $SG226166
	push	edx
	fstp	DWORD PTR _fDelay$226160[esp+1096]
	mov	BYTE PTR _text$226159[esp+1096], 0
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>

; 8842 : 									GC.GetEngineUserInterface()->AddPopupText(getX(), getY(), text, fDelay);

	mov	edx, DWORD PTR _fDelay$226160[esp+1096]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+184]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp], edx
	lea	edx, DWORD PTR _text$226159[esp+1076]
	push	edx
	movsx	edx, WORD PTR [esi+2]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	call	eax
$LN46@setReveale@4:
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jl	$LL47@setReveale@4
$LN437@setReveale@4:

; 8843 : 								}
; 8844 : 							}
; 8845 : 						}
; 8846 : 					}
; 8847 : 
; 8848 : 					// If it's the active team then tell them they found something
; 8849 : 					if(eTeam == eActiveTeam)

	cmp	ebp, DWORD PTR _eActiveTeam$[esp+1072]
	jne	$LN440@setReveale@4

; 8850 : 					{
; 8851 : 						bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+456]
	call	eax

; 8852 : #ifdef AUI_PLOT_OBSERVER_NO_NW_POPUPS
; 8853 : 						if (eTeam == OBSERVER_TEAM)
; 8854 : 							bDontShowRewardPopup = true;
; 8855 : #endif
; 8856 : 
; 8857 : 						// Popup (no MP)
; 8858 : 						if(!GC.getGame().isNetworkMultiPlayer() && !bDontShowRewardPopup)	// KWG: candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	bl, al
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	jne	$LN439@setReveale@4
	test	bl, bl
	jne	$LN439@setReveale@4

; 8859 : 						{
; 8860 : 							CvPopupInfo kPopupInfo(BUTTONPOPUP_NATURAL_WONDER_REWARD, getX(), getY(), iFinderGold, 0 /*iFlags */, bFirstFinder);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR _iFinderGold$226121[esp+1072]
	mov	DWORD PTR _kPopupInfo$226170[esp+1076], eax
	mov	al, BYTE PTR _bFirstFinder$226122[esp+1072]
	mov	DWORD PTR _kPopupInfo$226170[esp+1072], ecx

; 8861 : 							pInterface->AddPopup(kPopupInfo);

	mov	ecx, DWORD PTR _pInterface$[esp+1072]
	mov	DWORD PTR _kPopupInfo$226170[esp+1080], edx
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+180]
	mov	BYTE PTR _kPopupInfo$226170[esp+1088], al
	lea	eax, DWORD PTR _kPopupInfo$226170[esp+1072]
	push	eax
	mov	DWORD PTR _kPopupInfo$226170[esp+1088], 0
	mov	BYTE PTR _kPopupInfo$226170[esp+1093], bl
	mov	DWORD PTR _kPopupInfo$226170[esp+1096], 56 ; 00000038H
	mov	BYTE PTR _kPopupInfo$226170[esp+1100], bl
	call	edx

; 8862 : 							CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 8863 : 							if (kActivePlayer.getTeam() == eActiveTeam)

	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN280@setReveale@4
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN281@setReveale@4
$LN280@setReveale@4:
	or	eax, -1
$LN281@setReveale@4:
	cmp	eax, DWORD PTR _eActiveTeam$[esp+1072]
	jne	SHORT $LN39@setReveale@4

; 8864 : 							{
; 8865 : 								// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
; 8866 : 								CancelActivePlayerEndTurn();

	call	?CancelActivePlayerEndTurn@@YA_NXZ	; CancelActivePlayerEndTurn
$LN39@setReveale@4:

; 8867 : 							}
; 8868 : 
; 8869 : 							//Add Stat and check for Achievement
; 8870 : 							if(bEligibleForAchievement && !GC.getGame().isGameMultiPlayer())

	cmp	BYTE PTR _bEligibleForAchievement$226084[esp+1072], 0
	je	SHORT $LN439@setReveale@4
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN439@setReveale@4

; 8871 : 							{
; 8872 : 								gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_NATURALWONDERS, 100, ACHIEVEMENT_ALL_NATURALWONDER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+848]
	push	88					; 00000058H
	push	100					; 00000064H
	push	116					; 00000074H
	call	edx
$LN439@setReveale@4:

; 8873 : 							}
; 8874 : 
; 8875 : 						}
; 8876 : 
; 8877 : 						//DLC2 Natural Wonder Achievements
; 8878 : 						{
; 8879 : 							CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo(getFeatureType());

	movsx	eax, BYTE PTR [esi+432]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo

; 8880 : 							if(pkFeatureInfo)

	test	eax, eax
	je	$LN37@setReveale@4

; 8881 : 							{
; 8882 : 								CvString strFeatureType = pkFeatureInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN298@setReveale@4
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN298@setReveale@4:
	push	eax
	lea	ecx, DWORD PTR _strFeatureType$226176[esp+1076]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 8883 : 								if(strFeatureType == "FEATURE_FOUNTAIN_YOUTH")

	mov	edi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	ecx, DWORD PTR _strFeatureType$226176[esp+1072]
	push	OFFSET $SG226178
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+1088], 3
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN36@setReveale@4

; 8884 : 									gDLL->UnlockAchievement(ACHIEVEMENT_SCENARIO_02_DISCOVER_FOUNTAIN);

	push	137					; 00000089H
	jmp	SHORT $LN443@setReveale@4
$LN36@setReveale@4:

; 8885 : 								else if(strFeatureType == "FEATURE_EL_DORADO")

	lea	ecx, DWORD PTR _strFeatureType$226176[esp+1072]
	push	OFFSET $SG226181
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN34@setReveale@4

; 8886 : 									gDLL->UnlockAchievement(ACHIEVEMENT_SCENARIO_02_DISCOVER_EL_DORADO);

	push	138					; 0000008aH
$LN443@setReveale@4:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN34@setReveale@4:

; 8887 : 							}

	lea	ecx, DWORD PTR _strFeatureType$226176[esp+1072]
	mov	BYTE PTR __$EHRec$[esp+1080], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN37@setReveale@4:

; 8888 : 						}
; 8889 : 
; 8890 : 						auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T252116[esp+1072], eax
	mov	BYTE PTR __$EHRec$[esp+1080], 4
	test	eax, eax
	je	SHORT $LN85@setReveale@4
	push	esi
	mov	ecx, eax
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	edi, eax
	jmp	SHORT $LN86@setReveale@4
$LN85@setReveale@4:
	xor	edi, edi
$LN86@setReveale@4:
	mov	DWORD PTR _pDllPlot$226187[esp+1072], edi

; 8891 : 						gDLL->GameplayNaturalWonderRevealed(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+700]
	push	edi
	mov	BYTE PTR __$EHRec$[esp+1084], 5
	call	eax

; 8892 : 					}

	mov	BYTE PTR __$EHRec$[esp+1080], 2
	test	edi, edi
	je	SHORT $LN440@setReveale@4
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN440@setReveale@4:

; 8893 : 				}

	mov	edi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _strSummary$226105[esp+1072]
	mov	BYTE PTR __$EHRec$[esp+1080], 1
	call	edi
	lea	ecx, DWORD PTR _strText$226096[esp+1072]
	mov	DWORD PTR __$EHRec$[esp+1080], -1
	call	edi
	mov	edi, DWORD PTR tv1482[esp+1072]
	mov	ebx, DWORD PTR _pInterface$[esp+1072]
$LN76@setReveale@4:

; 8894 : 			}
; 8895 : 		}
; 8896 : 
; 8897 : 		if(eTeam == eActiveTeam)

	cmp	ebp, DWORD PTR _eActiveTeam$[esp+1072]
	jne	$LN20@setReveale@4

; 8898 : 		{
; 8899 : 			bVisbilityUpdated = true;
; 8900 : 			updateSymbols();

	mov	ecx, esi
	mov	BYTE PTR _bVisbilityUpdated$[esp+1072], 1
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 8901 : 			updateFog(true);

	push	1
	mov	ecx, esi
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog

; 8902 : 			updateVisibility();

	mov	ecx, esi
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility

; 8903 : 
; 8904 : 			// Active player is seeing this Plot for the first time
; 8905 : 			if(isRevealed(eTeam))

	mov	eax, edi
	shl	eax, 5
	mov	ecx, ebp
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+edi*4+8]
	je	$LN20@setReveale@4

; 8906 : 			{
; 8907 : 				// update the resources
; 8908 : 				if(getResourceType(eTeam) != NO_RESOURCE)

	push	ebp
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN325@setReveale@4

; 8909 : 				{
; 8910 : 					// If we've force revealed the resource for this team, then don't send another event
; 8911 : 					if(!IsResourceForceReveal(eTeam))

	mov	eax, DWORD PTR [esi+176]
	cmp	BYTE PTR [eax+ebp], 0
	jne	SHORT $LN325@setReveale@4

; 8912 : 					{
; 8913 : 						setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN325@setReveale@4:

; 8914 : 					}
; 8915 : 				}
; 8916 : 
; 8917 : 				// Found a Goody Hut
; 8918 : 				if(getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	$LN28@setReveale@4

; 8919 : 				{
; 8920 : 					if(GC.getImprovementInfo(getImprovementType())->IsGoody())

	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	test	al, al
	je	$LN28@setReveale@4

; 8921 : 					{
; 8922 : 						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_GOODY_HUT");

	lea	ecx, DWORD PTR _strBuffer$226194[esp+1072]
	push	OFFSET $SG226196
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText

; 8923 : 						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_GOODY_HUT");

	lea	edx, DWORD PTR _strSummary$226197[esp+1080]
	push	OFFSET $SG226199
	push	edx
	mov	DWORD PTR __$EHRec$[esp+1096], 6
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 16					; 00000010H

; 8924 : 						if(bEligibleForAchievement)

	cmp	BYTE PTR _bEligibleForAchievement$226084[esp+1072], 0
	mov	BYTE PTR __$EHRec$[esp+1080], 7
	je	SHORT $LN27@setReveale@4

; 8925 : 						{
; 8926 : 							gDLL->UnlockAchievement(ACHIEVEMENT_ANCIENT_RUIN);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	49					; 00000031H
	call	edx
$LN27@setReveale@4:

; 8927 : 							OutputDebugString("RUINS!");
; 8928 : 						}
; 8929 : 						for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR tv2216[esp+1072], 0
	npad	1
$LL26@setReveale@4:

; 8930 : 						{
; 8931 : 							CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, DWORD PTR tv2216[esp+1072]
	add	ecx, eax

; 8932 : 							if(playerI.isAlive())

	cmp	BYTE PTR [ecx+2256], 0
	je	SHORT $LN25@setReveale@4

; 8933 : 							{
; 8934 : 								if(playerI.getTeam() == eTeam)

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN345@setReveale@4
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN346@setReveale@4
$LN345@setReveale@4:
	or	eax, -1
$LN346@setReveale@4:
	cmp	eax, DWORD PTR _eTeam$[esp+1068]
	jne	SHORT $LN25@setReveale@4

; 8935 : 								{
; 8936 : 									CvNotifications* pNotifications = playerI.GetNotifications();

	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ebp, eax

; 8937 : 									if(pNotifications)

	test	ebp, ebp
	je	SHORT $LN25@setReveale@4

; 8938 : 									{
; 8939 : 										pNotifications->Add(NOTIFICATION_GOODY, strBuffer, strSummary, getX(), getY(), -1);

	movsx	edi, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	lea	ecx, DWORD PTR _strSummary$226197[esp+1072]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	edi
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strBuffer$226194[esp+1092]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-597231081				; dc66fa17H
	mov	ecx, ebp
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN25@setReveale@4:
	mov	eax, DWORD PTR tv2216[esp+1072]
	add	eax, 63236				; 0000f704H
	cmp	eax, 1391192				; 00153a58H
	mov	DWORD PTR tv2216[esp+1072], eax
	jl	$LL26@setReveale@4

; 8940 : 									}
; 8941 : 								}
; 8942 : 							}
; 8943 : 						}
; 8944 : 					}

	lea	ecx, DWORD PTR _strSummary$226197[esp+1072]
	mov	BYTE PTR __$EHRec$[esp+1080], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$226194[esp+1072]
	mov	DWORD PTR __$EHRec$[esp+1080], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebp, DWORD PTR _eTeam$[esp+1068]
	mov	edi, DWORD PTR tv1482[esp+1072]
	mov	ebx, DWORD PTR _pInterface$[esp+1072]
$LN28@setReveale@4:

; 8945 : 				}
; 8946 : 				if(bEligibleForAchievement)

	cmp	BYTE PTR _bEligibleForAchievement$226084[esp+1072], 0
	je	SHORT $LN20@setReveale@4

; 8947 : 				{
; 8948 : 					gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_TILESDISCOVERED, 1000, ACHIEVEMENT_1000TILES);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+848]
	push	94					; 0000005eH
	push	1000					; 000003e8H
	push	127					; 0000007fH
	call	edx
$LN20@setReveale@4:

; 8949 : 				}
; 8950 : 
; 8951 : 
; 8952 : 			}
; 8953 : 		}
; 8954 : 
; 8955 : 		if(bNewValue)

	cmp	BYTE PTR _bNewValue$[esp+1068], 0
	je	SHORT $LN18@setReveale@4

; 8956 : 		{
; 8957 : 			if(pInterface->GetHeadSelectedUnit() != NULL)

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, ebx
	call	edx
	test	eax, eax
	je	SHORT $LN18@setReveale@4

; 8958 : 			{
; 8959 : 				// This is what determines if the camera jumps quickly or slowly - if we're revealing new plots go slower.  The following function sets this flag
; 8960 : 				pInterface->SetSelectedUnitRevealingNewPlots(true);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+232]
	push	1
	mov	ecx, ebx
	call	edx
$LN18@setReveale@4:

; 8961 : 			}
; 8962 : 		}
; 8963 : 	}
; 8964 : 
; 8965 : 	if(!bTerrainOnly)

	cmp	BYTE PTR _bTerrainOnly$[esp+1068], 0
	jne	$LN426@setReveale@4

; 8966 : 	{
; 8967 : 		bool bVisibilityChanged = false;
; 8968 : 		bool bImprovementVisibilityChanged = false;
; 8969 : 		if(isRevealed(eTeam))

	mov	eax, edi
	shl	eax, 5
	mov	ecx, ebp
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	xor	bl, bl
	mov	BYTE PTR _bImprovementVisibilityChanged$226215[esp+1072], bl
	test	edx, DWORD PTR [esi+edi*4+8]
	je	$LN16@setReveale@4

; 8970 : 		{
; 8971 : 			// If this plot is owned by someone, let the team know
; 8972 : 			if(getOwner() != NO_PLAYER)

	mov	al, BYTE PTR [esi+4]
	cmp	al, -1
	je	SHORT $LN15@setReveale@4

; 8973 : 			{
; 8974 : 				bVisibilityChanged |= GET_TEAM(eTeam).SetHasFoundPlayersTerritory(getOwner(), true);

	mov	ecx, ebp
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	movsx	eax, al
	push	1
	push	eax
	call	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ; CvTeam::SetHasFoundPlayersTerritory
	mov	bl, al
$LN15@setReveale@4:

; 8975 : 			}
; 8976 : 
; 8977 : 			if(eFromTeam == NO_TEAM)

	mov	edi, DWORD PTR _eFromTeam$[esp+1068]
	cmp	edi, -1
	jne	SHORT $LN14@setReveale@4

; 8978 : 			{
; 8979 : 				bVisibilityChanged |= setRevealedOwner(eTeam, getOwner());

	movsx	eax, BYTE PTR [esi+4]
	push	eax
	push	ebp
	mov	ecx, esi
	call	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner
	or	bl, al

; 8980 : 				bImprovementVisibilityChanged |= setRevealedImprovementType(eTeam, getImprovementType());

	movsx	eax, BYTE PTR [esi+441]
	push	eax
	push	ebp
	mov	ecx, esi
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
	mov	BYTE PTR _bImprovementVisibilityChanged$226215[esp+1072], al

; 8981 : 				bVisibilityChanged |= setRevealedRouteType(eTeam, getRouteType());

	movsx	eax, BYTE PTR [esi+447]
	push	eax
	push	ebp
	mov	ecx, esi
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType

; 8982 : 
; 8983 : 				if(pCity != NULL)

	mov	ecx, DWORD PTR _pCity$[esp+1072]
	or	bl, al
	test	ecx, ecx
	je	$LN429@setReveale@4

; 8984 : 				{
; 8985 : 					bVisibilityChanged |= pCity->setRevealed(eTeam, true);

	push	1

; 8986 : 				}
; 8987 : 			}
; 8988 : 			else

	jmp	$LN444@setReveale@4
$LN14@setReveale@4:

; 8989 : 			{
; 8990 : 				if(getRevealedOwner(eFromTeam) == getOwner())

	mov	eax, DWORD PTR [esi+160]
	mov	al, BYTE PTR [edi+eax]
	cmp	al, BYTE PTR [esi+4]
	jne	SHORT $LN11@setReveale@4

; 8991 : 				{
; 8992 : 					bVisibilityChanged |= setRevealedOwner(eTeam, getRevealedOwner(eFromTeam));

	movsx	eax, al
	push	eax
	push	ebp
	mov	ecx, esi
	call	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner
	or	bl, al
$LN11@setReveale@4:

; 8993 : 				}
; 8994 : 
; 8995 : 				if(getRevealedImprovementType(eFromTeam) == getImprovementType())

	mov	ecx, DWORD PTR [esi+164]
	movzx	eax, WORD PTR [ecx+edi*2]
	movsx	dx, BYTE PTR [esi+441]
	cmp	ax, dx
	jne	SHORT $LN10@setReveale@4

; 8996 : 				{
; 8997 : 					bImprovementVisibilityChanged |= setRevealedImprovementType(eTeam, getRevealedImprovementType(eFromTeam));

	cwde
	push	eax
	push	ebp
	mov	ecx, esi
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
	mov	BYTE PTR _bImprovementVisibilityChanged$226215[esp+1072], al
$LN10@setReveale@4:

; 8998 : 				}
; 8999 : 
; 9000 : 				if(getRevealedRouteType(eFromTeam) == getRouteType())

	mov	eax, DWORD PTR [esi+168]
	movzx	eax, WORD PTR [eax+edi*2]
	movsx	cx, BYTE PTR [esi+447]
	cmp	ax, cx
	jne	SHORT $LN9@setReveale@4

; 9001 : 				{
; 9002 : 					bVisibilityChanged |= setRevealedRouteType(eTeam, getRevealedRouteType(eFromTeam));

	cwde
	push	eax
	push	ebp
	mov	ecx, esi
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
	or	bl, al
$LN9@setReveale@4:

; 9003 : 				}
; 9004 : 
; 9005 : 				if(pCity != NULL)

	cmp	DWORD PTR _pCity$[esp+1072], 0
	je	SHORT $LN429@setReveale@4

; 9006 : 				{
; 9007 : 					if(pCity->isRevealed(eFromTeam, false))

	mov	ecx, DWORD PTR _pCity$[esp+1072]
	push	0
	push	edi
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	je	SHORT $LN429@setReveale@4

; 9008 : 					{
; 9009 : 						bVisibilityChanged |= pCity->setRevealed(eTeam, true);

	push	1

; 9010 : 					}
; 9011 : 				}
; 9012 : 			}
; 9013 : 		}
; 9014 : 		else

	jmp	SHORT $LN445@setReveale@4
$LN16@setReveale@4:

; 9015 : 		{
; 9016 : 			bVisibilityChanged |= setRevealedOwner(eTeam, NO_PLAYER);

	mov	edx, DWORD PTR [esi+160]
	cmp	BYTE PTR [edx+ebp], -1
	lea	eax, DWORD PTR [edx+ebp]
	je	SHORT $LN401@setReveale@4
	mov	BYTE PTR [eax], -1
	mov	BYTE PTR $T252790[esp+1072], 1
	jmp	SHORT $LN402@setReveale@4
$LN401@setReveale@4:
	mov	BYTE PTR $T252790[esp+1072], 0
$LN402@setReveale@4:

; 9017 : 			bImprovementVisibilityChanged |= setRevealedImprovementType(eTeam, NO_IMPROVEMENT);

	push	-1
	push	ebp
	mov	ecx, esi
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType

; 9018 : 			bVisibilityChanged |= setRevealedRouteType(eTeam, NO_ROUTE);

	push	-1
	push	ebp
	mov	ecx, esi
	mov	BYTE PTR _bImprovementVisibilityChanged$226215[esp+1080], al
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
	mov	bl, al
	or	bl, BYTE PTR $T252790[esp+1072]

; 9019 : 
; 9020 : 			if(pCity != NULL)

	cmp	DWORD PTR _pCity$[esp+1072], 0
	je	SHORT $LN429@setReveale@4

; 9021 : 			{
; 9022 : 				bVisibilityChanged |= pCity->setRevealed(eTeam, false);

	push	0
$LN445@setReveale@4:
	mov	ecx, DWORD PTR _pCity$[esp+1076]
$LN444@setReveale@4:
	push	ebp
	call	?setRevealed@CvCity@@QAE_NW4TeamTypes@@_N@Z ; CvCity::setRevealed
	or	bl, al
$LN429@setReveale@4:

; 9023 : 			}
; 9024 : 		}
; 9025 : 
; 9026 : 		if (!bVisbilityUpdated && (bVisibilityChanged || bImprovementVisibilityChanged))

	mov	al, BYTE PTR _bVisbilityUpdated$[esp+1072]
	test	al, al
	jne	SHORT $LN4@setReveale@4
	test	bl, bl
	jne	SHORT $LN441@setReveale@4
	cmp	BYTE PTR _bImprovementVisibilityChanged$226215[esp+1072], bl
	je	SHORT $LN4@setReveale@4
$LN441@setReveale@4:

; 9027 : 		{
; 9028 : 			if(eTeam == eActiveTeam)

	cmp	ebp, DWORD PTR _eActiveTeam$[esp+1072]
	jne	SHORT $LN2@setReveale@4

; 9029 : 			{
; 9030 : 				if (!bImprovementVisibilityChanged)	// Don't bother sending again if the improvement change already sent the message

	cmp	BYTE PTR _bImprovementVisibilityChanged$226215[esp+1072], 0
	jne	SHORT $LN1@setReveale@4

; 9031 : 					updateSymbols();

	mov	ecx, esi
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols
$LN1@setReveale@4:

; 9032 : 
; 9033 : 				updateFog(true);

	push	1
	mov	ecx, esi
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog

; 9034 : 				updateVisibility();

	mov	ecx, esi
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
$LN2@setReveale@4:

; 9035 : 			}
; 9036 : 
; 9037 : 			bVisbilityUpdated = true;

	mov	al, 1
	jmp	SHORT $LN4@setReveale@4
$LN426@setReveale@4:

; 9038 : 		}
; 9039 : 	}
; 9040 : 
; 9041 : 	return bVisbilityUpdated;

	mov	al, BYTE PTR _bVisbilityUpdated$[esp+1072]
$LN4@setReveale@4:

; 9042 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1072]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1056				; 00000420H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$0:
	lea	ecx, DWORD PTR _args$226093[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$1:
	lea	ecx, DWORD PTR _strText$226096[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$2:
	lea	ecx, DWORD PTR _strSummary$226105[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$3:
	lea	ecx, DWORD PTR _strFeatureType$226176[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$4:
	mov	eax, DWORD PTR $T252116[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$5:
	lea	ecx, DWORD PTR _pDllPlot$226187[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$6:
	lea	ecx, DWORD PTR _strBuffer$226194[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$7:
	lea	ecx, DWORD PTR _strSummary$226197[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:
	mov	eax, OFFSET __ehfuncinfo$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ENDP	; CvPlot::setRevealed
PUBLIC	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$1
__ehfuncinfo$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_bNewInvisibleVisible$ = 8				; size = 1
$T252835 = 8						; size = 4
_pDllUnit$226522 = 8					; size = 4
_eTeam$ = 8						; size = 4
_eInvisible$ = 12					; size = 4
_activeTeam$226509 = 16					; size = 4
_iChange$ = 16						; size = 4
?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z PROC ; CvPlot::changeInvisibleVisibilityCount, COMDAT
; _this$ = ecx

; 9582 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi

; 9583 : 	bool bOldInvisibleVisible;
; 9584 : 	bool bNewInvisibleVisible;
; 9585 : 	const int iNumInvisibleInfos = NUM_INVISIBLE_TYPES;
; 9586 : 	DEBUG_VARIABLE(iNumInvisibleInfos);
; 9587 : 
; 9588 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9589 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9590 : 	CvAssertMsg(eInvisible >= 0, "eInvisible is expected to be non-negative (invalid Index)");
; 9591 : 	CvAssertMsg(eInvisible < iNumInvisibleInfos, "eInvisible is expected to be within maximum bounds (invalid Index)");
; 9592 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return;

	mov	esi, DWORD PTR _eTeam$[esp+20]
	push	edi
	mov	ebp, ecx
	cmp	esi, 63					; 0000003fH
	ja	$LN7@changeInvi

; 9593 : 	if(eInvisible < 0 || eInvisible >= NUM_INVISIBLE_TYPES) return;

	mov	eax, DWORD PTR _eInvisible$[esp+24]
	test	eax, eax
	ja	$LN7@changeInvi

; 9594 : 
; 9595 : 	if(iChange != 0)

	mov	edi, DWORD PTR _iChange$[esp+24]
	test	edi, edi
	je	$LN7@changeInvi

; 9596 : 	{
; 9597 : 		bOldInvisibleVisible = isInvisibleVisible(eTeam, eInvisible);

	push	eax
	push	esi
	call	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible

; 9598 : 
; 9599 : 		m_apaiInvisibleVisibilityCount[eTeam][eInvisible] = (m_apaiInvisibleVisibilityCount[eTeam][eInvisible] + iChange);

	mov	ecx, DWORD PTR _eInvisible$[esp+24]
	mov	bl, al
	lea	eax, DWORD PTR [esi+ecx]
	add	WORD PTR [ebp+eax*2+196], di

; 9600 : 
; 9601 : 		CvAssertFmt(m_apaiInvisibleVisibilityCount[eTeam][eInvisible] >= 0, "Invisible Visibility going negative for %d, %d", m_iX, m_iY);
; 9602 : 
; 9603 : 		bNewInvisibleVisible = isInvisibleVisible(eTeam, eInvisible);

	push	ecx
	lea	eax, DWORD PTR [ebp+eax*2+196]
	push	esi
	mov	ecx, ebp
	call	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
	mov	BYTE PTR _bNewInvisibleVisible$[esp+24], al

; 9604 : 
; 9605 : 		if(bOldInvisibleVisible != bNewInvisibleVisible)

	cmp	bl, al
	je	$LN7@changeInvi

; 9606 : 		{
; 9607 : 			TeamTypes activeTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _activeTeam$226509[esp+24], eax

; 9608 : 			if(eTeam == activeTeam)

	cmp	esi, eax
	jne	$LN7@changeInvi

; 9609 : 			{
; 9610 : 				// for all (nominally invisible) units in this plot
; 9611 : 				// tell the engine to flip whether they are being drawn or not
; 9612 : 				IDInfo* pUnitNode;
; 9613 : 				CvUnit* pLoopUnit = NULL;
; 9614 : 				pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebp+28], 0
	jbe	SHORT $LN22@changeInvi
	mov	eax, DWORD PTR [ebp+24]
	jmp	SHORT $LN21@changeInvi
$LN22@changeInvi:
	xor	eax, eax
$LN21@changeInvi:
	mov	edi, eax

; 9615 : 				while(pUnitNode != NULL)

	test	eax, eax
	je	$LN2@changeInvi
	mov	ebx, DWORD PTR _bNewInvisibleVisible$[esp+24]
$LL3@changeInvi:

; 9616 : 				{
; 9617 : 					pLoopUnit = GetPlayerUnit(*pUnitNode);

	push	edi
	call	?GetPlayerUnit@@YAPAVCvUnit@@AAUIDInfo@@@Z ; GetPlayerUnit
	add	esp, 4

; 9618 : 					pUnitNode = nextUnitNode(pUnitNode);

	push	edi
	mov	ecx, ebp
	mov	esi, eax
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	edi, eax

; 9619 : 
; 9620 : 					if(NULL != pLoopUnit && pLoopUnit->getTeam() != activeTeam && pLoopUnit->getInvisibleType() == eInvisible)

	test	esi, esi
	je	$LN41@changeInvi
	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _activeTeam$226509[esp+24]
	je	SHORT $LN41@changeInvi
	mov	ecx, esi
	call	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getInvisibleType
	cmp	eax, DWORD PTR _eInvisible$[esp+24]
	jne	SHORT $LN41@changeInvi

; 9621 : 					{
; 9622 : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T252835[esp+24], eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	eax, eax
	je	SHORT $LN13@changeInvi
	push	esi
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN14@changeInvi
$LN13@changeInvi:
	xor	esi, esi
$LN14@changeInvi:
	mov	DWORD PTR _pDllUnit$226522[esp+24], esi

; 9623 : 						gDLL->GameplayUnitVisibility(pDllUnit.get(), bNewInvisibleVisible, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+640]
	push	ecx
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	push	1
	push	ebx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+52], 1
	call	eax

; 9624 : 					}

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	esi, esi
	je	SHORT $LN41@changeInvi
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
$LN41@changeInvi:

; 9615 : 				while(pUnitNode != NULL)

	test	edi, edi
	jne	$LL3@changeInvi
$LN2@changeInvi:

; 9625 : 				}
; 9626 : 
; 9627 : 				updateCenterUnit();

	mov	ecx, ebp
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN7@changeInvi:

; 9628 : 
; 9629 : 			}
; 9630 : 		}
; 9631 : 	}
; 9632 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$0:
	mov	eax, DWORD PTR $T252835[ebp-4]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$1:
	lea	ecx, DWORD PTR _pDllUnit$226522[ebp-4]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ENDP ; CvPlot::changeInvisibleVisibilityCount
PUBLIC	?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z ; CvPlot::getUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z
_TEXT	SEGMENT
_uiCount$ = -4						; size = 4
_pkInfoVector$ = 8					; size = 4
?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z PROC ; CvPlot::getUnits, COMDAT
; _this$ = ecx

; 9921 : {

	push	ecx
	push	ebx
	push	edi

; 9922 : 	uint uiCount = 0;
; 9923 : 	if (pkInfoVector)

	mov	edi, DWORD PTR _pkInfoVector$[esp+8]
	mov	ebx, ecx
	xor	ecx, ecx
	mov	DWORD PTR _uiCount$[esp+12], ecx
	cmp	edi, ecx
	je	SHORT $LN48@getUnits

; 9924 : 	{
; 9925 : 		pkInfoVector->clear();

	mov	DWORD PTR [edi+4], ecx
	push	esi

; 9926 : 	
; 9927 : 		const IDInfo* pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], ecx
	jbe	SHORT $LN17@getUnits
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN16@getUnits
$LN17@getUnits:
	xor	esi, esi
$LN16@getUnits:

; 9928 : 
; 9929 : 		while (pUnitNode != NULL)

	cmp	esi, ecx
	je	SHORT $LN47@getUnits
$LL2@getUnits:

; 9930 : 		{
; 9931 : 			pkInfoVector->push_back(*pUnitNode);

	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN24@getUnits
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize
	mov	ecx, DWORD PTR _uiCount$[esp+16]
$LN24@getUnits:
	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+eax*8]
	test	eax, eax
	je	SHORT $LN27@getUnits
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
$LN27@getUnits:
	inc	DWORD PTR [edi+4]

; 9932 : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN38@getUnits
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN37@getUnits
$LN38@getUnits:
	xor	esi, esi
$LN37@getUnits:

; 9933 : 			++uiCount;

	inc	ecx
	mov	DWORD PTR _uiCount$[esp+16], ecx
	test	esi, esi
	jne	SHORT $LL2@getUnits
$LN47@getUnits:
	pop	esi
	pop	edi

; 9934 : 		}
; 9935 : 	}
; 9936 : 	return uiCount;

	mov	eax, ecx
	pop	ebx

; 9937 : }

	pop	ecx
	ret	4
$LN48@getUnits:
	pop	edi

; 9934 : 		}
; 9935 : 	}
; 9936 : 	return uiCount;

	mov	eax, ecx
	pop	ebx

; 9937 : }

	pop	ecx
	ret	4
?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z ENDP ; CvPlot::getUnits
_TEXT	ENDS
PUBLIC	?clear@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXXZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXXZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::clear, COMDAT
; _this$ = ecx

; 849  :         mVec.resize( 0 );

	mov	DWORD PTR [ecx+4], 0

; 850  :     };

	ret	0
?clear@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXXZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::clear
_TEXT	ENDS
PUBLIC	?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::insertAtEnd
; Function compile flags: /Ogtpy
;	COMDAT ?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z
_TEXT	SEGMENT
_ptData$ = 8						; size = 4
?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::insertAtEnd, COMDAT
; _this$ = ecx

; 1026 :     { 

	push	esi
	mov	esi, ecx

; 1027 :         mVec.push_back( *ptData );       

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+76], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN3@insertAtEn@2
	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN3@insertAtEn@2:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN10@insertAtEn@2
	mov	ecx, DWORD PTR _ptData$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN10@insertAtEn@2:
	inc	DWORD PTR [esi+4]
	pop	esi

; 1028 :     };

	ret	4
?insertAtEnd@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::insertAtEnd
_TEXT	ENDS
PUBLIC	?insertBefore@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@0@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::insertBefore
; Function compile flags: /Ogtpy
;	COMDAT ?insertBefore@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@0@Z
_TEXT	SEGMENT
_ptData$ = 8						; size = 4
_ptBefore$ = 12						; size = 4
?insertBefore@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@0@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::insertBefore, COMDAT
; _this$ = ecx

; 1049 :     {        

	push	ebx
	push	ebp
	push	esi

; 1050 :         UINT uSize = mVec.size();
; 1051 : 
; 1052 : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 1053 : 		unsigned int iIndex = ptBefore - &mVec[0];
; 1054 : #else
; 1055 : 		INT iIndex = ptBefore - &mVec[ 0 ];

	mov	esi, DWORD PTR _ptBefore$[esp+8]
	push	edi
	mov	edi, ecx
	sub	esi, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+4]

; 1056 : #endif
; 1057 : 
; 1058 : 		mVec.resize( uSize + 1 );

	lea	ebp, DWORD PTR [ebx+1]
	sar	esi, 3
	cmp	DWORD PTR [edi+8], ebp
	jae	SHORT $LN10@insertBefo
	push	ebp
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN10@insertBefo:

; 1059 : 
; 1060 : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 1061 : 		for (unsigned int iIdx = uSize; iIdx > iIndex; --iIdx)
; 1062 : #else
; 1063 :         for( INT iIdx = (INT)uSize; iIdx > iIndex; --iIdx )

	cmp	ebx, esi
	mov	DWORD PTR [edi+4], ebp
	mov	ecx, ebx
	jle	SHORT $LN1@insertBefo
	npad	7
$LL3@insertBefo:
	mov	eax, DWORD PTR [edi]

; 1064 : #endif
; 1065 :         {
; 1066 :             mVec[ iIdx ] = mVec[ iIdx - 1 ];

	mov	edx, DWORD PTR [eax+ecx*8-8]
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [eax-4]
	dec	ecx
	cmp	ecx, esi
	mov	DWORD PTR [eax+4], edx
	jg	SHORT $LL3@insertBefo
$LN1@insertBefo:

; 1067 :         }
; 1068 : 
; 1069 :         mVec[ iIndex ] = *ptData;

	mov	eax, DWORD PTR _ptData$[esp+12]
	mov	edi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+esi*8], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+esi*8+4], edx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1070 : 
; 1071 :     }

	ret	8
?insertBefore@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@0@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::insertBefore
_TEXT	ENDS
PUBLIC	?deleteNode@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ; FFastSmallFixedList<IDInfo,8,1,297,0>::deleteNode
; Function compile flags: /Ogtpy
;	COMDAT ?deleteNode@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_tData$ = 8						; size = 4
?deleteNode@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::deleteNode, COMDAT
; _this$ = ecx

; 1094 :     {

	push	ebx
	push	esi
	push	edi

; 1095 :         UINT uDeletePos = tData - &mVec[ 0 ];

	mov	edi, DWORD PTR _tData$[esp+8]
	mov	esi, ecx
	sub	edi, DWORD PTR [esi]
	sar	edi, 3

; 1096 : 
; 1097 :         for( UINT uIdx = uDeletePos; uIdx + 1 < mVec.size(); ++uIdx )

	lea	edx, DWORD PTR [edi+1]
	cmp	edx, DWORD PTR [esi+4]
	jae	SHORT $LN3@deleteNode

; 1095 :         UINT uDeletePos = tData - &mVec[ 0 ];

	lea	ecx, DWORD PTR [edi*8]
	npad	3
$LL5@deleteNode:

; 1098 :         {
; 1099 :             mVec[ uIdx ] = mVec[ uIdx + 1 ];

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [eax+12]
	inc	edx
	mov	DWORD PTR [eax+4], ebx
	add	ecx, 8
	cmp	edx, DWORD PTR [esi+4]
	jb	SHORT $LL5@deleteNode
$LN3@deleteNode:

; 1100 :         }
; 1101 : 
; 1102 :         //  List shrinks by 1
; 1103 :         mVec.resize( mVec.size() - 1 );

	mov	ebx, DWORD PTR [esi+4]
	dec	ebx
	cmp	DWORD PTR [esi+8], ebx
	jae	SHORT $LN18@deleteNode
	push	ebx
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN18@deleteNode:
	mov	DWORD PTR [esi+4], ebx

; 1104 : 
; 1105 :         if( uDeletePos < mVec.size() )

	cmp	edi, ebx
	jae	SHORT $LN2@deleteNode

; 1106 :         {
; 1107 : 	        return &mVec[ uDeletePos ];

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+edi*8]
	pop	edi
	pop	esi
	pop	ebx

; 1112 :         }
; 1113 :     };

	ret	4
$LN2@deleteNode:
	pop	edi
	pop	esi

; 1108 :         }
; 1109 :         else
; 1110 :         {
; 1111 :             return NULL;

	xor	eax, eax
	pop	ebx

; 1112 :         }
; 1113 :     };

	ret	4
?deleteNode@?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAEPAUIDInfo@@PAU2@@Z ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::deleteNode
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T253124 = 12						; size = 4
$T253122 = 12						; size = 4
__Where$227624 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+17], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$227624[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T253122[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$227624[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T253124[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert
_TEXT	ENDS
PUBLIC	??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::FFastSmallFixedList<IDInfo,25,1,297,0>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::FFastSmallFixedList<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 841  :     FFastSmallFixedList()

	push	-1
	push	__ehhandler$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+8], 25			; 00000019H
	mov	DWORD PTR [eax], ecx

; 842  :     {
; 843  :         clear();
; 844  :     };

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
__ehhandler$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::FFastSmallFixedList<IDInfo,25,1,297,0>
PUBLIC	??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T253299 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@2
	cmp	edx, eax
	jne	SHORT $LN101@erase@2

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@2:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@2
	npad	2
$LL2@erase@2:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+17], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@2
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN103@erase@2
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN79@erase@2
	npad	5
$LL80@erase@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL80@erase@2
$LN79@erase@2:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@2
$LN103@erase@2:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN63@erase@2
	npad	7
$LL64@erase@2:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@2
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL64@erase@2
$LN63@erase@2:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@2:
	push	edx
	lea	eax, DWORD PTR $T253299[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@2
$LN1@erase@2:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T253622 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T253622[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp+12]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+16]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
$LL3@Destroy_ra:

; 234  : 		_Al.destroy(_First);

	lea	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 56					; 00000038H
	mov	DWORD PTR __First$[esp+16], esi
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:

; 235  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:
	mov	ecx, DWORD PTR __First$[ebp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T253817 = 12						; size = 4
$T253815 = 12						; size = 4
__Where$198734 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+17], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert@2
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert@2:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert@2
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert@2
$LN13@insert@2:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert@2:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL10@insert@2
$LN9@insert@2:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$198734[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert@2

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T253815[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert@2
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert@2:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$198734[esp+12]
$LN57@insert@2:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert@2

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T253817[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert@2:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T253954 = 12						; size = 4
$T253952 = 12						; size = 4
__Where$202343 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+45], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert@3
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert@3:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert@3
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert@3
$LN13@insert@3:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert@3:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL10@insert@3
$LN9@insert@3:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$202343[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert@3

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T253952[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert@3
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert@3:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$202343[esp+12]
$LN57@insert@3:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert@3

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T253954[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert@3:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T254171 = -80						; size = 28
$T254170 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+80]
	cmp	BYTE PTR [eax+45], 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+88], ebx
	je	SHORT $LN40@erase@3

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T254171[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T254170[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T254171[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T254170[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T254170[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T254170[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T254170[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN306@erase@3:
$LN40@erase@3:
	push	ebp
	push	esi
	push	edi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	ebp, eax
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+45], 0
	je	SHORT $LN39@erase@3

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]
	jmp	SHORT $LN301@erase@3
$LN39@erase@3:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebp+8]
	cmp	BYTE PTR [edx+45], 0
	je	SHORT $LN37@erase@3

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN301@erase@3
$LN37@erase@3:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebp
	jne	SHORT $LN35@erase@3
$LN301@erase@3:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+45], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN34@erase@3

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@3:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN33@erase@3

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@3
$LN33@erase@3:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN31@erase@3

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@3
$LN31@erase@3:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@3:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ebx], ebp
	jne	SHORT $LN29@erase@3

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+45], 0
	je	SHORT $LN43@erase@3
	mov	eax, esi
	jmp	SHORT $LN44@erase@3
$LN43@erase@3:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Min
	add	esp, 4
$LN44@erase@3:
	mov	DWORD PTR [ebx], eax
$LN29@erase@3:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[esp+100]
	mov	ebx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ebx+8], ebp
	jne	SHORT $LN173@erase@3

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+45], 0
	je	SHORT $LN45@erase@3
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@3
$LN45@erase@3:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@3
$LN35@erase@3:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebp+8]
	jne	SHORT $LN26@erase@3

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@3
$LN26@erase@3:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+45], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@3

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@3:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@3:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx+4], ebp
	jne	SHORT $LN23@erase@3

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@3
$LN23@erase@3:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx], ebp
	jne	SHORT $LN21@erase@3

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@3
$LN21@erase@3:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@3:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebp+44]
	add	eax, 44					; 0000002cH
	cmp	eax, ecx
	je	SHORT $LN173@erase@3
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase@3:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	bl, 1
	cmp	BYTE PTR [ebp+44], bl
	jne	$LN19@erase@3

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR _this$[esp+100]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx+4]
	je	$LN16@erase@3
	npad	8
$LL18@erase@3:
	cmp	BYTE PTR [edi+44], bl
	jne	$LN16@erase@3

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase@3

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+44], 0
	jne	SHORT $LN14@erase@3

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+44], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+44], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN14@erase@3:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+45], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN304@erase@3

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+44], bl
	jne	SHORT $LN11@erase@3
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+44], bl
	je	SHORT $LN305@erase@3
$LN11@erase@3:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+44], bl
	jne	SHORT $LN9@erase@3

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+44], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+44], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN9@erase@3:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+44]
	mov	BYTE PTR [eax+44], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+44], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+44], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@3
$LN15@erase@3:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+44], 0
	jne	SHORT $LN7@erase@3

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+44], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+44], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN7@erase@3:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+45], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN304@erase@3

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+44], bl
	jne	SHORT $LN4@erase@3
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+44], bl
	jne	SHORT $LN4@erase@3
$LN305@erase@3:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+44], 0
$LN304@erase@3:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ecx+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase@3

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@3
$LN4@erase@3:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+44], bl
	jne	SHORT $LN2@erase@3

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+44], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+44], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN2@erase@3:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+44]
	mov	BYTE PTR [eax+44], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+44], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+44], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
$LN16@erase@3:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+44], bl
$LN19@erase@3:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	lea	ecx, DWORD PTR [ebp+16]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	ebp
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[esp+104]
	mov	eax, DWORD PTR [ecx+8]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	test	eax, eax
	jbe	SHORT $LN1@erase@3

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@3:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN303@erase@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T254171[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T254170[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
; Function compile flags: /Ogtpy
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	cmp	BYTE PTR [edi+45], 0
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $LN1@Erase@2
$LL3@Erase@2:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	lea	ecx, DWORD PTR [edi+16]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	cmp	BYTE PTR [esi+45], 0
	mov	edi, esi
	je	SHORT $LL3@Erase@2
$LN1@Erase@2:
	pop	edi
	pop	esi
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?uninit@CvPlot@@QAEXXZ				; CvPlot::uninit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?uninit@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?uninit@CvPlot@@QAEXXZ PROC				; CvPlot::uninit, COMDAT
; _this$ = ecx

; 190  : {

	push	esi
	mov	esi, ecx

; 191  : 	SAFE_DELETE_ARRAY(m_szScriptData);

	mov	eax, DWORD PTR [esi+180]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+180], edi

; 192  : 
; 193  : 	m_pCenterUnit = NULL;

	mov	ecx, DWORD PTR [esi+188]
	add	esp, 4
	cmp	ecx, edi
	je	SHORT $LN9@uninit
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@uninit:
	mov	DWORD PTR [esi+188], edi

; 194  : 
; 195  : 	SAFE_DELETE_ARRAY(m_paiBuildProgress);

	mov	ecx, DWORD PTR [esi+184]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+184], edi
	add	esp, 4

; 196  : 
; 197  : 	m_units.clear();

	mov	DWORD PTR [esi+28], edi
	pop	edi
	pop	esi

; 198  : }

	ret	0
?uninit@CvPlot@@QAEXXZ ENDP				; CvPlot::uninit
_TEXT	ENDS
PUBLIC	?doTurn@CvPlot@@QAEXXZ				; CvPlot::doTurn
; Function compile flags: /Ogtpy
;	COMDAT ?doTurn@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?doTurn@CvPlot@@QAEXXZ PROC				; CvPlot::doTurn, COMDAT
; _this$ = ecx

; 399  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 400  : 	if(isOwned())

	or	ebx, -1
	cmp	BYTE PTR [esi+4], bl
	je	SHORT $LN9@doTurn

; 401  : 	{
; 402  : 		changeOwnershipDuration(1);

	movsx	eax, WORD PTR [esi+380]
	inc	eax
	push	eax
	call	?setOwnershipDuration@CvPlot@@QAEXH@Z	; CvPlot::setOwnershipDuration
$LN9@doTurn:

; 403  : 	}
; 404  : 
; 405  : 	if(getImprovementType() != NO_IMPROVEMENT)

	cmp	BYTE PTR [esi+441], bl
	je	SHORT $LN19@doTurn

; 406  : 	{
; 407  : 		changeImprovementDuration(1);

	inc	WORD PTR [esi+382]
$LN19@doTurn:

; 408  : 	}
; 409  : 
; 410  : 	verifyUnitValidPlot();

	mov	ecx, esi
	call	?verifyUnitValidPlot@CvPlot@@QAEXXZ	; CvPlot::verifyUnitValidPlot

; 411  : 
; 412  : 	// Clear world anchor
; 413  : 	SetWorldAnchor(NO_WORLD_ANCHOR);

	movsx	eax, BYTE PTR [esi+448]
	mov	BYTE PTR [esi+448], bl
	mov	BYTE PTR [esi+449], bl
	cmp	eax, ebx
	je	SHORT $LN22@doTurn
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	push	edi
	movsx	edi, WORD PTR [esi+2]
	movsx	esi, WORD PTR [esi]
	push	ebx
	push	edi
	push	esi
	push	0
	push	eax
	mov	eax, DWORD PTR [edx+792]
	call	eax
	pop	edi
$LN22@doTurn:
	pop	esi
	pop	ebx

; 414  : 
; 415  : 	// XXX
; 416  : #ifdef _DEBUG
; 417  : 	{
; 418  : 		IDInfo* pUnitNode;
; 419  : 		CvUnit* pLoopUnit;
; 420  : 
; 421  : 		pUnitNode = headUnitNode();
; 422  : 
; 423  : 		while(pUnitNode != NULL)
; 424  : 		{
; 425  : 			pLoopUnit = GetPlayerUnit(*pUnitNode);
; 426  : 			pUnitNode = nextUnitNode(pUnitNode);
; 427  : 
; 428  : 			if(pLoopUnit)
; 429  : 			{
; 430  : 				CvAssertMsg(pLoopUnit->atPlot(*this), "pLoopUnit is expected to be at the current plot instance");
; 431  : 				if(!pLoopUnit->atPlot(*this))
; 432  : 				{
; 433  : 					removeUnit(pLoopUnit, true);
; 434  : 				}
; 435  : 			}
; 436  : 		}
; 437  : 	}
; 438  : #endif
; 439  : 	// XXX
; 440  : }

	ret	0
?doTurn@CvPlot@@QAEXXZ ENDP				; CvPlot::doTurn
_TEXT	ENDS
PUBLIC	?doImprovementUpgrade@CvPlot@@IAEXXZ		; CvPlot::doImprovementUpgrade
; Function compile flags: /Ogtpy
;	COMDAT ?doImprovementUpgrade@CvPlot@@IAEXXZ
_TEXT	SEGMENT
?doImprovementUpgrade@CvPlot@@IAEXXZ PROC		; CvPlot::doImprovementUpgrade, COMDAT
; _this$ = ecx

; 510  : {

	push	esi
	mov	esi, ecx

; 511  : 	if(getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	$LN1@doImprovem

; 512  : 	{
; 513  : 		ImprovementTypes eImprovementUpdrade = (ImprovementTypes)GC.getImprovementInfo(getImprovementType())->GetImprovementUpgrade();

	movsx	eax, al
	push	ebx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	mov	ebx, eax

; 514  : 		if(eImprovementUpdrade != NO_IMPROVEMENT)

	cmp	ebx, -1
	je	$LN36@doImprovem

; 515  : 		{
; 516  : 			if(isBeingWorked() || GC.getImprovementInfo(eImprovementUpdrade)->IsOutsideBorders())

	mov	eax, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR [esi+112]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@doImprovem
	push	esi
	mov	ecx, eax
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	test	al, al
	jne	SHORT $LN2@doImprovem
$LN35@doImprovem:
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOutsideBorders
	test	al, al
	je	SHORT $LN36@doImprovem
$LN2@doImprovem:

; 517  : 			{
; 518  : 				changeUpgradeProgress(GET_PLAYER(getOwner()).getImprovementUpgradeRate());

	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	call	?getImprovementUpgradeRate@CvPlayer@@QBEHXZ ; CvPlayer::getImprovementUpgradeRate
	add	WORD PTR [esi+384], ax
	movzx	eax, WORD PTR [esi+384]

; 519  : 
; 520  : 				if(getUpgradeProgress() >= (GC.getGame().getImprovementUpgradeTime(getImprovementType(), this)) * 100)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	movsx	edi, ax
	movsx	eax, BYTE PTR [esi+441]
	push	esi
	push	eax
	call	?getImprovementUpgradeTime@CvGame@@QBEHW4ImprovementTypes@@PBVCvPlot@@@Z ; CvGame::getImprovementUpgradeTime
	imul	eax, 100				; 00000064H
	cmp	edi, eax
	pop	edi
	jl	SHORT $LN36@doImprovem

; 521  : 				{
; 522  : 					setImprovementType(eImprovementUpdrade, GetPlayerThatBuiltImprovement());

	movsx	edx, BYTE PTR [esi+443]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
$LN36@doImprovem:
	pop	ebx
$LN1@doImprovem:
	pop	esi

; 523  : 				}
; 524  : 			}
; 525  : 		}
; 526  : 	}
; 527  : }

	ret	0
?doImprovementUpgrade@CvPlot@@IAEXXZ ENDP		; CvPlot::doImprovementUpgrade
_TEXT	ENDS
PUBLIC	?removeGoody@CvPlot@@QAEXXZ			; CvPlot::removeGoody
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
; Function compile flags: /Ogtpy
;	COMDAT ?removeGoody@CvPlot@@QAEXXZ
_TEXT	SEGMENT
?removeGoody@CvPlot@@QAEXXZ PROC			; CvPlot::removeGoody, COMDAT
; _this$ = ecx

; 3696 : {

	push	esi

; 3697 : 	setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
	xor	esi, esi
	npad	4
$LL4@removeGood:

; 3698 : 	// Make sure the player's redo their goody hut searches
; 3699 : 	for(int i = 0; i < MAX_PLAYERS; i++)
; 3700 : 	{
; 3701 : 		if(GET_PLAYER((PlayerTypes)i).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	lea	ecx, DWORD PTR [esi+eax]
	je	SHORT $LN3@removeGood

; 3702 : 		{
; 3703 : 			GET_PLAYER((PlayerTypes)i).GetEconomicAI()->m_bExplorationPlotsDirty = true;

	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	BYTE PTR [eax], 1
$LN3@removeGood:
	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL4@removeGood
	pop	esi

; 3704 : 		}
; 3705 : 	}
; 3706 : }

	ret	0
?removeGoody@CvPlot@@QAEXXZ ENDP			; CvPlot::removeGoody
_TEXT	ENDS
PUBLIC	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
EXTRN	?isHuman@CvCity@@QBE_NXZ:PROC			; CvCity::isHuman
EXTRN	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::meet
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?isHuman@CvTeam@@QBE_NXZ:PROC			; CvTeam::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_iChange$ = 12						; size = 4
_eSeeInvisible$ = 16					; size = 4
_bInformExplorationTracking$ = 20			; size = 1
_eResult$ = 24						; size = 4
_bAlwaysSeeInvisible$ = 24				; size = 1
?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z PROC ; CvPlot::changeVisibilityCount, COMDAT
; _this$ = ecx

; 8271 : {

	push	esi
	push	edi

; 8272 : 	CvCity* pCity;
; 8273 : 	CvPlot* pAdjacentPlot;
; 8274 : 	bool bOldVisible;
; 8275 : 
; 8276 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8277 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8278 : 
; 8279 : 	PlotVisibilityChangeResult eResult = VISIBILTY_CHANGE_NONE;
; 8280 : 	if(iChange != 0)

	mov	edi, DWORD PTR _iChange$[esp+4]
	xor	eax, eax
	mov	esi, ecx
	test	edi, edi
	je	$LN1@changeVisi
	push	ebx
	push	ebp

; 8281 : 	{
; 8282 : 		bOldVisible = isVisible(eTeam);

	mov	ebp, DWORD PTR _eTeam$[esp+12]
	cmp	ebp, -1
	jne	SHORT $LN35@changeVisi
	xor	bl, bl
	jmp	SHORT $LN36@changeVisi
$LN35@changeVisi:
	mov	eax, DWORD PTR [esi+156]
	cmp	WORD PTR [eax+ebp*2], 0
	setg	bl
$LN36@changeVisi:

; 8283 : 
; 8284 : 		m_aiVisibilityCount[eTeam] += iChange;

	mov	ecx, DWORD PTR [esi+156]
	add	WORD PTR [ecx+ebp*2], di

; 8285 : 		CvAssertFmt(m_aiVisibilityCount[eTeam]>=0, "Changing plot X:%d, Y:%d to a negative visibility", getX(), getY());
; 8286 : 		if (m_aiVisibilityCount[eTeam] < 0)

	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+ebp*2], 0
	lea	eax, DWORD PTR [ecx+ebp*2]
	jge	SHORT $LN31@changeVisi

; 8287 : 			m_aiVisibilityCount[eTeam] = 0;

	mov	eax, edx
	xor	ecx, ecx
	mov	WORD PTR [eax+ebp*2], cx
$LN31@changeVisi:

; 8288 : 
; 8289 : 		if(eSeeInvisible != NO_INVISIBLE)

	mov	eax, DWORD PTR _eSeeInvisible$[esp+12]
	cmp	eax, -1
	je	SHORT $LN30@changeVisi

; 8290 : 		{
; 8291 : 			changeInvisibleVisibilityCount(eTeam, eSeeInvisible, iChange);

	push	edi
	push	eax
	push	ebp
	mov	ecx, esi
	call	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
$LN30@changeVisi:

; 8292 : 		}
; 8293 : 
; 8294 : 		if(bAlwaysSeeInvisible)

	cmp	BYTE PTR _bAlwaysSeeInvisible$[esp+12], 0
	je	SHORT $LN26@changeVisi

; 8295 : 		{
; 8296 : 			for(int iI = 0; iI < NUM_INVISIBLE_TYPES; iI++)
; 8297 : 			{
; 8298 : 				changeInvisibleVisibilityCount(eTeam, (InvisibleTypes) iI, iChange);

	push	edi
	push	0
	push	ebp
	mov	ecx, esi
	call	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
$LN26@changeVisi:

; 8299 : 			}
; 8300 : 		}
; 8301 : 
; 8302 : 		if(bOldVisible != isVisible(eTeam))

	cmp	ebp, -1
	jne	SHORT $LN40@changeVisi
	xor	al, al
	jmp	SHORT $LN41@changeVisi
$LN40@changeVisi:
	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+ebp*2], 0
	setg	al
$LN41@changeVisi:
	cmp	bl, al
	je	$LN149@changeVisi

; 8303 : 		{
; 8304 : 			// We couldn't see the Plot before but we can now
; 8305 : 			if(isVisible(eTeam))

	cmp	ebp, -1
	je	$LN24@changeVisi
	mov	eax, DWORD PTR [esi+156]
	cmp	WORD PTR [eax+ebp*2], 0
	setg	al
	test	al, al
	je	$LN24@changeVisi

; 8306 : 			{
; 8307 : 				eResult = VISIBILITY_CHANGE_TO_VISIBLE;
; 8308 : 				bool bOldRevealed = isRevealed(eTeam);

	mov	eax, ebp
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, ebp
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl

; 8309 : 				if (!setRevealed(eTeam, true))	// Change to revealed, returns true if the visibility was changed

	push	-1
	push	0
	push	1
	test	edx, DWORD PTR [esi+eax*4+8]
	push	ebp
	mov	ecx, esi
	mov	DWORD PTR _eResult$[esp+28], 2
	setne	bl
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
	test	al, al
	jne	SHORT $LN22@changeVisi

; 8310 : 				{
; 8311 : 					// The visibility was not changed because it was already revealed, but we are changing to a visible state as well, so we must update.
; 8312 : 					// Just trying to avoid redundant messages.
; 8313 : 					if (eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebp, eax
	jne	SHORT $LN22@changeVisi

; 8314 : 					{
; 8315 : 						updateSymbols();

	mov	ecx, esi
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 8316 : 						updateFog(true);

	push	1
	mov	ecx, esi
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog

; 8317 : #ifndef AUI_PLOT_FIX_RESPONSIVE_VISIBILITY_UPDATE
; 8318 : 						updateVisibility();

	mov	ecx, esi
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
$LN22@changeVisi:

; 8319 : #endif
; 8320 : 					}
; 8321 : 				}
; 8322 : 
; 8323 : 				if(bInformExplorationTracking && !bOldRevealed)

	cmp	BYTE PTR _bInformExplorationTracking$[esp+12], 0
	je	SHORT $LN18@changeVisi
	test	bl, bl
	jne	SHORT $LN18@changeVisi

; 8324 : 				{
; 8325 : 					// slewis - ghetto-tastic hack. ugh
; 8326 : 					for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	npad	1
$LL20@changeVisi:

; 8327 : 					{
; 8328 : 						CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 8329 : 						if(playerI.isAlive())

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	ecx, DWORD PTR [edi+eax]
	je	SHORT $LN19@changeVisi

; 8330 : 						{
; 8331 : 							if(playerI.getTeam() == eTeam)

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN66@changeVisi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN67@changeVisi
$LN66@changeVisi:
	or	eax, -1
$LN67@changeVisi:
	cmp	eax, ebp
	jne	SHORT $LN19@changeVisi

; 8332 : 							{
; 8333 : 								playerI.GetEconomicAI()->m_bExplorationPlotsDirty = true;

	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	BYTE PTR [eax], 1
$LN19@changeVisi:
	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	SHORT $LL20@changeVisi
$LN18@changeVisi:

; 8334 : 							}
; 8335 : 						}
; 8336 : 					}
; 8337 : 				}
; 8338 : 
; 8339 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	edi, edi
$LL15@changeVisi:

; 8340 : 				{
; 8341 : 					pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 8342 : 
; 8343 : 					if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN14@changeVisi

; 8344 : 					{
; 8345 : 						pAdjacentPlot->updateRevealedOwner(eTeam);

	push	ebp
	mov	ecx, eax
	call	?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ; CvPlot::updateRevealedOwner
$LN14@changeVisi:
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL15@changeVisi

; 8346 : 					}
; 8347 : 				}
; 8348 : 
; 8349 : 				// If there are any Units here, meet their owners
; 8350 : #ifdef AUI_WARNING_FIXES
; 8351 : 				for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 8352 : #else
; 8353 : 				for(int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	xor	ebp, ebp
	cmp	ebp, DWORD PTR [esi+28]
	jge	$LN9@changeVisi
$LN159@changeVisi:

; 8354 : #endif
; 8355 : 				{
; 8356 : 					// If the AI spots a human Unit, don't meet - wait for the human to find the AI
; 8357 : 					CvUnit* loopUnit = getUnitByIndex(iUnitLoop);

	jae	SHORT $LN10@changeVisi
	mov	edx, DWORD PTR [esi+24]
	lea	edx, DWORD PTR [edx+ebp*8]
	test	edx, edx
	je	SHORT $LN10@changeVisi
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jl	SHORT $LN10@changeVisi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN10@changeVisi
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	ebx, eax

; 8358 : 
; 8359 : 					if(!loopUnit) continue;

	test	ebx, ebx
	je	SHORT $LN10@changeVisi

; 8360 : 
; 8361 : 					if(!GET_TEAM(eTeam).isHuman() && loopUnit->isHuman())

	mov	edi, DWORD PTR _eTeam$[esp+12]
	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	edi, 2980				; 00000ba4H
	add	ecx, edi
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	jne	SHORT $LN7@changeVisi
	mov	ecx, ebx
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	SHORT $LN10@changeVisi
$LN7@changeVisi:

; 8362 : 					{
; 8363 : 						continue;
; 8364 : 					}
; 8365 : 
; 8366 : 					GET_TEAM(eTeam).meet(loopUnit->getTeam(), false);

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	mov	ecx, ebx
	add	edi, edx
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, edi
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
$LN10@changeVisi:
	inc	ebp
	cmp	ebp, DWORD PTR [esi+28]
	jl	SHORT $LN159@changeVisi
$LN9@changeVisi:

; 8367 : 				}
; 8368 : 
; 8369 : 				// If there's a City here, meet its owner
; 8370 : 				if(isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN155@changeVisi
	cmp	eax, 64					; 00000040H
	jge	$LN155@changeVisi
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN155@changeVisi

; 8371 : 				{
; 8372 : 					// If the AI spots a human City, don't meet - wait for the human to find the AI
; 8373 : 					if(GET_TEAM(eTeam).isHuman() || !getPlotCity()->isHuman())

	mov	edi, DWORD PTR _eTeam$[esp+12]
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	edi, 2980				; 00000ba4H
	lea	ecx, DWORD PTR [edi+edx]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	test	al, al
	jne	SHORT $LN4@changeVisi
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN111@changeVisi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN111@changeVisi
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN112@changeVisi
$LN111@changeVisi:
	xor	eax, eax
$LN112@changeVisi:
	mov	ecx, eax
	call	?isHuman@CvCity@@QBE_NXZ		; CvCity::isHuman
	test	al, al
	jne	SHORT $LN155@changeVisi
$LN4@changeVisi:

; 8374 : 					{
; 8375 : 						GET_TEAM(eTeam).meet(getTeam(), false);	// If there's a City here, we can assume its owner is the same as the plot owner

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN117@changeVisi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN117@changeVisi
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN116@changeVisi
$LN117@changeVisi:
	or	eax, -1
$LN116@changeVisi:
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	0
	push	eax
	lea	ecx, DWORD PTR [edi+edx]
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
$LN155@changeVisi:

; 8376 : 					}
; 8377 : 				}
; 8378 : 			}
; 8379 : 			else

	mov	ebp, DWORD PTR _eTeam$[esp+12]
$LN2@changeVisi:

; 8384 : 			}
; 8385 : 
; 8386 : 			pCity = getPlotCity();

	mov	ecx, DWORD PTR [esi+104]
	test	ecx, ecx
	jl	SHORT $LN133@changeVisi
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN133@changeVisi
	mov	eax, DWORD PTR [esi+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
$LN133@changeVisi:

; 8387 : 
; 8388 : 			if(eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebp, eax
	jne	SHORT $LN148@changeVisi

; 8389 : 			{
; 8390 : 				//updateFog();
; 8391 : #ifndef AUI_PLOT_FIX_RESPONSIVE_VISIBILITY_UPDATE
; 8392 : 				updateVisibility();

	mov	ecx, esi
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility

; 8393 : #endif
; 8394 : 				updateCenterUnit();

	mov	ecx, esi
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN148@changeVisi:

; 8395 : 			}
; 8396 : 		}
; 8397 : 	}
; 8398 : 
; 8399 : 	return eResult;

	mov	eax, DWORD PTR _eResult$[esp+12]
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 8400 : }

	ret	20					; 00000014H
$LN24@changeVisi:

; 8380 : 			{
; 8381 : 				eResult = VISIBILITY_CHANGE_TO_INVISIBLE;
; 8382 : 				if(eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _eResult$[esp+12], 1
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebp, eax
	jne	SHORT $LN2@changeVisi

; 8383 : 					updateFog(true);

	push	1
	mov	ecx, esi
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog
	jmp	SHORT $LN2@changeVisi
$LN149@changeVisi:
	pop	ebp

; 8395 : 			}
; 8396 : 		}
; 8397 : 	}
; 8398 : 
; 8399 : 	return eResult;

	xor	eax, eax
	pop	ebx
$LN1@changeVisi:
	pop	edi
	pop	esi

; 8400 : }

	ret	20					; 00000014H
?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ENDP ; CvPlot::changeVisibilityCount
_TEXT	ENDS
PUBLIC	?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z		; CvPlot::addUnit
EXTRN	?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z:PROC	; isBeforeUnitCycle
; Function compile flags: /Ogtpy
;	COMDAT ?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_unitIDInfo$226614 = -8					; size = 8
_unitIDInfo$226611 = -8					; size = 8
_pUnit$ = 8						; size = 4
_bUpdate$ = 12						; size = 1
?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z PROC		; CvPlot::addUnit, COMDAT
; _this$ = ecx

; 9792 : {

	sub	esp, 12					; 0000000cH
	push	ebx

; 9793 : 	CvAssertMsg(pUnit, "pUnit is expected to be non-NULL");
; 9794 : 	if(pUnit == NULL)

	mov	ebx, DWORD PTR _pUnit$[esp+12]
	push	ebp
	mov	ebp, ecx
	mov	DWORD PTR _this$[esp+20], ebp
	test	ebx, ebx
	je	$LN1@addUnit

; 9795 : 		return;
; 9796 : 
; 9797 : 	CvAssertMsg(pUnit->at(getX(), getY()), "pUnit is expected to be at getX_INLINE and getY_INLINE");
; 9798 : 
; 9799 : 	IDInfo* pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebp+28], 0
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+24]
	jbe	SHORT $LN13@addUnit
	mov	esi, DWORD PTR [edi]
	jmp	SHORT $LN12@addUnit
$LN13@addUnit:
	xor	esi, esi
$LN12@addUnit:

; 9800 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	SHORT $LN3@addUnit
	npad	4
$LL6@addUnit:

; 9801 : 	{
; 9802 : 		CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN20@addUnit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN20@addUnit
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	jmp	SHORT $LN21@addUnit
$LN20@addUnit:
	xor	eax, eax
$LN21@addUnit:

; 9803 : 		if(!isBeforeUnitCycle(pLoopUnit, pUnit))

	push	ebx
	push	eax
	call	?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z	; isBeforeUnitCycle
	add	esp, 8
	test	al, al
	je	SHORT $LN68@addUnit

; 9804 : 		{
; 9805 : 			break;
; 9806 : 		}
; 9807 : 
; 9808 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+4]
	jae	SHORT $LN32@addUnit
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN31@addUnit
$LN32@addUnit:
	xor	esi, esi
$LN31@addUnit:

; 9800 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	SHORT $LL6@addUnit
$LN3@addUnit:

; 9817 : 	{
; 9818 : 		IDInfo unitIDInfo = pUnit->GetIDInfo();

	lea	edx, DWORD PTR _unitIDInfo$226614[esp+28]
	push	edx
	mov	ecx, ebx
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo

; 9819 : 		m_units.insertAtEnd(&unitIDInfo);

	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [edi+76], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN59@addUnit
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN59@addUnit:
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN62@addUnit
	mov	edx, DWORD PTR _unitIDInfo$226614[esp+28]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _unitIDInfo$226614[esp+32]
	mov	DWORD PTR [eax+4], ecx
$LN62@addUnit:
	inc	DWORD PTR [edi+4]
$LN60@addUnit:

; 9820 : 	}
; 9821 : 
; 9822 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 9823 : 	if (pUnit->getTeam() != getTeam() && getWorkingCity())
; 9824 : 		getWorkingCity()->GetCityCitizens()->DoSelfConsistencyCheck();
; 9825 : #endif
; 9826 : 
; 9827 : 	if(bUpdate)

	cmp	BYTE PTR _bUpdate$[esp+24], 0
	pop	edi
	pop	esi
	je	SHORT $LN1@addUnit

; 9828 : 	{
; 9829 : 		updateCenterUnit();

	mov	ecx, ebp
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN1@addUnit:
	pop	ebp
	pop	ebx

; 9830 : 	}
; 9831 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN68@addUnit:

; 9809 : 	}
; 9810 : 
; 9811 : 	if(pUnitNode != NULL)
; 9812 : 	{
; 9813 : 		IDInfo unitIDInfo = pUnit->GetIDInfo();

	lea	eax, DWORD PTR _unitIDInfo$226611[esp+28]
	push	eax
	mov	ecx, ebx
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo

; 9814 : 		m_units.insertBefore(&unitIDInfo, pUnitNode);

	sub	esi, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+4]
	lea	ebp, DWORD PTR [ebx+1]
	sar	esi, 3
	cmp	DWORD PTR [edi+8], ebp
	jae	SHORT $LN48@addUnit
	push	ebp
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN48@addUnit:
	cmp	ebx, esi
	mov	DWORD PTR [edi+4], ebp
	mov	ecx, ebx
	jle	SHORT $LN39@addUnit
	npad	5
$LL41@addUnit:
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [eax-8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [eax-4]
	dec	ecx
	cmp	ecx, esi
	mov	DWORD PTR [eax+4], edx
	jg	SHORT $LL41@addUnit
$LN39@addUnit:
	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR _unitIDInfo$226611[esp+28]

; 9815 : 	}
; 9816 : 	else

	mov	ebp, DWORD PTR _this$[esp+28]
	mov	DWORD PTR [edi+esi*8], eax
	mov	ecx, DWORD PTR _unitIDInfo$226611[esp+32]
	mov	DWORD PTR [edi+esi*8+4], ecx
	jmp	SHORT $LN60@addUnit
?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z ENDP		; CvPlot::addUnit
_TEXT	ENDS
PUBLIC	?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z		; CvPlot::removeUnit
EXTRN	?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z:PROC ; CvPlotManager::RemoveUnit
; Function compile flags: /Ogtpy
;	COMDAT ?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z
_TEXT	SEGMENT
$T255327 = -8						; size = 8
_pUnit$ = 8						; size = 4
_bUpdate$ = 12						; size = 1
?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z PROC		; CvPlot::removeUnit, COMDAT
; _this$ = ecx

; 9836 : {

	sub	esp, 8
	push	ebx
	push	esi
	mov	ebx, ecx

; 9837 : 	IDInfo* pUnitNode;
; 9838 : 
; 9839 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], 0
	push	edi
	lea	edi, DWORD PTR [ebx+24]
	jbe	SHORT $LN11@removeUnit
	mov	esi, DWORD PTR [edi]
	jmp	SHORT $LN10@removeUnit
$LN11@removeUnit:
	xor	esi, esi
$LN10@removeUnit:
	push	ebp

; 9840 : 
; 9841 : 	while(pUnitNode != NULL)

	mov	ebp, DWORD PTR _pUnit$[esp+20]
	test	esi, esi
	je	$LN4@removeUnit
$LL5@removeUnit:

; 9842 : 	{
; 9843 : 		if(GetPlayerUnit(*pUnitNode) == pUnit)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN18@removeUnit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN18@removeUnit
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	jmp	SHORT $LN19@removeUnit
$LN18@removeUnit:
	xor	eax, eax
$LN19@removeUnit:
	cmp	eax, ebp
	je	SHORT $LN67@removeUnit

; 9847 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 9848 : 			if (pUnit->getTeam() != getTeam() && getWorkingCity())
; 9849 : 				getWorkingCity()->GetCityCitizens()->DoSelfConsistencyCheck();
; 9850 : #endif
; 9851 : 			break;
; 9852 : 		}
; 9853 : 		else
; 9854 : 		{
; 9855 : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+4]
	jae	SHORT $LN54@removeUnit
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN53@removeUnit
$LN54@removeUnit:
	xor	esi, esi
$LN53@removeUnit:

; 9840 : 
; 9841 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	SHORT $LL5@removeUnit

; 9842 : 	{
; 9843 : 		if(GetPlayerUnit(*pUnitNode) == pUnit)

	jmp	SHORT $LN4@removeUnit
$LN67@removeUnit:

; 9844 : 		{
; 9845 : 			CvAssertMsg(GetPlayerUnit(*pUnitNode)->at(getX(), getY()), "The current unit instance is expected to be at getX_INLINE and getY_INLINE");
; 9846 : 			m_units.deleteNode(pUnitNode);

	sub	esi, DWORD PTR [edi]
	sar	esi, 3
	lea	edx, DWORD PTR [esi+1]
	cmp	edx, DWORD PTR [edi+4]
	jae	SHORT $LN25@removeUnit
	lea	ecx, DWORD PTR [esi*8]
	npad	6
$LL27@removeUnit:
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [eax+12]
	inc	edx
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	cmp	edx, DWORD PTR [edi+4]
	jb	SHORT $LL27@removeUnit
$LN25@removeUnit:
	mov	esi, DWORD PTR [edi+4]
	dec	esi
	cmp	DWORD PTR [edi+8], esi
	jae	SHORT $LN40@removeUnit
	push	esi
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN40@removeUnit:
	mov	DWORD PTR [edi+4], esi
$LN4@removeUnit:

; 9856 : 		}
; 9857 : 	}
; 9858 : 
; 9859 : #ifdef AUI_WARNING_FIXES
; 9860 : 	GC.getMap().plotManager().RemoveUnit(pUnit->GetIDInfo(), m_iX, m_iY, MAX_UNSIGNED_INT);
; 9861 : #else
; 9862 : 	GC.getMap().plotManager().RemoveUnit(pUnit->GetIDInfo(), m_iX, m_iY, -1);

	movsx	ecx, WORD PTR [ebx+2]
	movsx	edx, WORD PTR [ebx]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T255327[esp+36]
	push	eax
	mov	ecx, ebp
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo
	push	eax
	lea	ecx, DWORD PTR [esi+4184]
	call	?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z ; CvPlotManager::RemoveUnit

; 9863 : #endif
; 9864 : 
; 9865 : 	if(bUpdate)

	cmp	BYTE PTR _bUpdate$[esp+20], 0
	pop	ebp
	je	SHORT $LN1@removeUnit

; 9866 : 	{
; 9867 : 		updateCenterUnit();

	mov	ecx, ebx
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN1@removeUnit:
	pop	edi
	pop	esi
	pop	ebx

; 9868 : 	}
; 9869 : }

	add	esp, 8
	ret	8
?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z ENDP		; CvPlot::removeUnit
_TEXT	ENDS
PUBLIC	?Validate@CvPlot@@QAEHAAVCvMap@@@Z		; CvPlot::Validate
; Function compile flags: /Ogtpy
;	COMDAT ?Validate@CvPlot@@QAEHAAVCvMap@@@Z
_TEXT	SEGMENT
_iError$ = -12						; size = 4
_this$ = -8						; size = 4
_pkUnit$227389 = -4					; size = 4
_kParentMap$ = 8					; size = 4
?Validate@CvPlot@@QAEHAAVCvMap@@@Z PROC			; CvPlot::Validate, COMDAT
; _this$ = ecx

; 11260: {

	sub	esp, 12					; 0000000cH
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi

; 11261: 	int iError = 0;

	xor	eax, eax

; 11262: 	IDInfo* pUnitNode = headUnitNode();

	lea	edi, DWORD PTR [ebp+24]
	mov	DWORD PTR _this$[esp+24], ebp
	mov	DWORD PTR _iError$[esp+24], eax
	cmp	DWORD PTR [edi+4], eax
	jbe	SHORT $LN16@Validate
	mov	esi, DWORD PTR [edi]
	jmp	SHORT $LN15@Validate
$LN16@Validate:
	xor	esi, esi
$LN15@Validate:

; 11263: 
; 11264: 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN9@Validate
	push	ebx
	npad	7
$LL10@Validate:

; 11265: 	{
; 11266: 		CvUnit* pkUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN149@Validate
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN149@Validate
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	mov	ebx, eax
	mov	DWORD PTR _pkUnit$227389[esp+28], ebx

; 11267: 		if(pkUnit == NULL)

	test	ebx, ebx
	jne	SHORT $LN8@Validate
$LN149@Validate:

; 11268: 		{
; 11269: 			m_units.deleteNode(pUnitNode);

	sub	esi, DWORD PTR [edi]
	sar	esi, 3
	lea	edx, DWORD PTR [esi+1]
	cmp	edx, DWORD PTR [edi+4]
	jae	SHORT $LN30@Validate
	lea	ecx, DWORD PTR [esi*8]
	npad	4
$LL32@Validate:
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [eax+12]
	inc	edx
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	cmp	edx, DWORD PTR [edi+4]
	jb	SHORT $LL32@Validate
$LN30@Validate:
	mov	esi, DWORD PTR [edi+4]
	dec	esi
	cmp	DWORD PTR [edi+8], esi
	jae	SHORT $LN45@Validate
	push	esi
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN45@Validate:

; 11270: 			pUnitNode = headUnitNode();

	mov	ecx, ebp
	mov	DWORD PTR [edi+4], esi
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode

; 11271: 			iError |= 1;

	or	DWORD PTR _iError$[esp+28], 1

; 11272: 		}
; 11273: 		else

	jmp	$LN155@Validate
$LN8@Validate:

; 11274: 		{
; 11275: 			if(pkUnit->getX() != m_iX || pkUnit->getY() != m_iY)

	movsx	ecx, WORD PTR [ebp]
	cmp	DWORD PTR [ebx+76], ecx
	jne	SHORT $LN5@Validate
	movsx	edx, WORD PTR [ebp+2]
	cmp	DWORD PTR [ebx+88], edx
	jne	SHORT $LN5@Validate

; 11294: 			}
; 11295: 			else
; 11296: 				pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [edi+4]
	jae	SHORT $LN137@Validate
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	$LN1@Validate
$LN137@Validate:
	xor	esi, esi
	jmp	$LN1@Validate
$LN5@Validate:

; 11278: 				// Unit thinks it is in another plot.  Unit wins.
; 11279: 				m_units.deleteNode(pUnitNode);

	sub	esi, DWORD PTR [edi]
	or	DWORD PTR _iError$[esp+28], 1
	sar	esi, 3
	lea	edx, DWORD PTR [esi+1]
	cmp	edx, DWORD PTR [edi+4]
	jae	SHORT $LN62@Validate

; 11276: 			{
; 11277: 				iError |= 1;

	lea	ecx, DWORD PTR [esi*8]

; 11278: 				// Unit thinks it is in another plot.  Unit wins.
; 11279: 				m_units.deleteNode(pUnitNode);

$LL64@Validate:
	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+ecx+8]
	add	eax, ecx
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [eax+12]
	inc	edx
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	cmp	edx, DWORD PTR [edi+4]
	jb	SHORT $LL64@Validate
$LN62@Validate:
	mov	esi, DWORD PTR [edi+4]
	dec	esi
	cmp	DWORD PTR [edi+8], esi
	jae	SHORT $LN77@Validate
	push	esi
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN77@Validate:
	mov	DWORD PTR [edi+4], esi

; 11280: 
; 11281: 				CvPlot* pkCorrectPlot = kParentMap.plot(pkUnit->getX(), pkUnit->getY());

	mov	eax, DWORD PTR [ebx+76]
	mov	ebp, DWORD PTR [ebx+88]
	cmp	eax, -2147483647			; 80000001H
	je	$LN153@Validate
	cmp	ebp, -2147483647			; 80000001H
	je	$LN153@Validate
	mov	edx, DWORD PTR _kParentMap$[esp+24]
	cmp	BYTE PTR [edx+4056], 0
	mov	ecx, DWORD PTR [edx+4020]
	je	SHORT $LN102@Validate
	test	eax, eax
	jge	SHORT $LN104@Validate
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR _kParentMap$[esp+24]
	add	esi, ecx
	jmp	SHORT $LN106@Validate
$LN104@Validate:
	cmp	eax, ecx
	jl	SHORT $LN102@Validate
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR _kParentMap$[esp+24]
	jmp	SHORT $LN106@Validate
$LN102@Validate:
	mov	esi, eax
$LN106@Validate:
	cmp	BYTE PTR [edx+4057], 0
	mov	ebx, DWORD PTR [edx+4024]
	je	SHORT $LN152@Validate
	test	ebp, ebp
	jge	SHORT $LN114@Validate
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN116@Validate
$LN114@Validate:
	cmp	ebp, ebx
	jl	SHORT $LN152@Validate
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN116@Validate
$LN152@Validate:
	mov	edx, ebp
$LN116@Validate:
	test	esi, esi
	jl	SHORT $LN153@Validate
	cmp	esi, ecx
	jge	SHORT $LN153@Validate
	test	edx, edx
	jl	SHORT $LN153@Validate
	cmp	edx, ebx
	jge	SHORT $LN153@Validate
	imul	ecx, edx
	mov	edx, DWORD PTR _kParentMap$[esp+24]
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	esi, ecx

; 11282: 				if(pkCorrectPlot)

	je	SHORT $LN153@Validate

; 11283: 				{
; 11284: 					if(pkCorrectPlot->getUnitIndex(pkUnit) < 0)	// Already in there?

	mov	ebx, DWORD PTR _pkUnit$227389[esp+28]
	push	ebx
	call	?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z	; CvPlot::getUnitIndex
	test	eax, eax
	jge	SHORT $LN154@Validate

; 11285: 						pkCorrectPlot->addUnit(pkUnit, false);		// Nope, add it.

	push	0
	push	ebx
	mov	ecx, esi
	call	?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z	; CvPlot::addUnit

; 11286: 				}
; 11287: 				else

	jmp	SHORT $LN154@Validate
$LN153@Validate:

; 11288: 				{
; 11289: 					// Drat, that plot does not exist.
; 11290: 					iError |= 2;

	or	DWORD PTR _iError$[esp+28], 2
$LN154@Validate:

; 11291: 				}
; 11292: 
; 11293: 				pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[esp+28]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	ebp, ecx
$LN155@Validate:
	mov	esi, eax
$LN1@Validate:

; 11263: 
; 11264: 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL10@Validate

; 11297: 		}
; 11298: 	}
; 11299: 
; 11300: 	return iError;

	mov	eax, DWORD PTR _iError$[esp+28]
	pop	ebx
$LN9@Validate:
	pop	edi
	pop	esi
	pop	ebp

; 11301: }

	add	esp, 12					; 0000000cH
	ret	4
?Validate@CvPlot@@QAEHAAVCvMap@@@Z ENDP			; CvPlot::Validate
_TEXT	ENDS
PUBLIC	??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::FFastSmallFixedList<IDInfo,8,1,297,0>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::FFastSmallFixedList<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 841  :     FFastSmallFixedList()

	push	-1
	push	__ehhandler$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx

; 842  :     {
; 843  :         clear();
; 844  :     };

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
__ehhandler$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::FFastSmallFixedList<IDInfo,8,1,297,0>
PUBLIC	??1?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T255957 = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T255957[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z
_TEXT	SEGMENT
$T255987 = -8						; size = 4
__Where$ = -8						; size = 8
$T255999 = 8						; size = 1
__Num$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase, COMDAT
; _this$ = ecx

; 949  : 		{	// erase and count all that match _Keyval

	sub	esp, 8

; 950  : 		_Pairii _Where = equal_range(_Keyval);

	mov	eax, DWORD PTR __Keyval$[esp+4]
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	push	eax
	lea	ecx, DWORD PTR __Where$[esp+24]
	push	ecx
	mov	ecx, esi
	call	?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange

; 951  : 		size_type _Num = 0;
; 952  : 		_Distance(_Where.first, _Where.second, _Num);

	mov	edi, DWORD PTR __Where$[esp+24]
	mov	ebx, DWORD PTR __Where$[esp+20]
	mov	DWORD PTR __Num$[esp+16], 0
	mov	edx, DWORD PTR $T255999[esp+16]
	push	edx
	lea	eax, DWORD PTR __Num$[esp+20]
	push	eax
	push	edi
	push	ebx
	call	??$_Distance2@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::iterator,unsigned int>
	add	esp, 16					; 00000010H

; 953  : 		erase(_Where.first, _Where.second);

	push	edi
	push	ebx
	lea	ecx, DWORD PTR $T255987[esp+28]
	push	ecx
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase

; 954  : 		return (_Num);

	mov	eax, DWORD PTR __Num$[esp+16]
	pop	edi
	pop	esi
	pop	ebx

; 955  : 		}

	add	esp, 8
	ret	4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
_TEXT	ENDS
PUBLIC	?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ; FAutoArchive::touch
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchive.h
;	COMDAT ?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T256009 = -8						; size = 8
$T256008 = 8						; size = 4
_dirtyVariable$ = 8					; size = 4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z PROC	; FAutoArchive::touch, COMDAT
; _this$ = ecx

; 55   : 	{

	sub	esp, 8

; 56   : #ifdef FAUTOARCHIVE_DEBUG
; 57   : 		debugHelp(dirtyVariable);
; 58   : #endif//FAUTOARCHIVE_DEBUG
; 59   : 		m_deltas.insert(&dirtyVariable);

	mov	eax, DWORD PTR _dirtyVariable$[esp+4]
	lea	edx, DWORD PTR $T256008[esp+4]
	mov	DWORD PTR $T256008[esp+4], eax
	push	edx
	lea	eax, DWORD PTR $T256009[esp+12]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 60   : 	}

	add	esp, 8
	ret	4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ENDP	; FAutoArchive::touch
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+17], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$256181 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Cat$256181[esp+4]
	mov	ecx, DWORD PTR __Al$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 226  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	?set@?$FAutoVariable@DVCvPlot@@@@QAEXABD@Z	; FAutoVariable<char,CvPlot>::set
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?set@?$FAutoVariable@DVCvPlot@@@@QAEXABD@Z
_TEXT	SEGMENT
$T256190 = -8						; size = 8
$T256189 = 8						; size = 4
_source$ = 8						; size = 4
?set@?$FAutoVariable@DVCvPlot@@@@QAEXABD@Z PROC		; FAutoVariable<char,CvPlot>::set, COMDAT
; _this$ = ecx

; 225  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 226  : 	if(m_value != source)

	mov	al, BYTE PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _source$[esp+12]
	cmp	al, BYTE PTR [edi]
	je	SHORT $LN1@set

; 227  : 	{
; 228  : 		m_owner.touch(*this);

	lea	ecx, DWORD PTR $T256189[esp+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T256190[esp+20]
	push	edx
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T256189[esp+20], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 229  : 		m_value = source;

	mov	al, BYTE PTR [edi]
	mov	BYTE PTR [esi+4], al
$LN1@set:
	pop	edi
	pop	esi

; 230  : 	}
; 231  : }

	add	esp, 8
	ret	4
?set@?$FAutoVariable@DVCvPlot@@@@QAEXABD@Z ENDP		; FAutoVariable<char,CvPlot>::set
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T256202 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@4

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@4:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@4
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jae	$LN1@insert@4

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@4:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@4

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jae	$LN1@insert@4

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@4:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jbe	SHORT $LN305@insert@4
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jae	SHORT $LN8@insert@4

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+45], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@4
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@4:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@4:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@4:
	jae	SHORT $LN1@insert@4
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@4
	cmp	ebp, DWORD PTR [eax+12]
	jae	SHORT $LN1@insert@4
$LN3@insert@4:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+45], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@4
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@4:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@4:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T256202[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+45], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	??1?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ ; std::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >::~set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T257030 = -4						; size = 4
??1?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ PROC ; std::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >::~set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T257030[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ ENDP ; std::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >::~set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??1CvPlot@@QAE@XZ				; CvPlot::~CvPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPlot@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$3
__ehfuncinfo$??1CvPlot@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvPlot@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlot@@QAE@XZ
_TEXT	SEGMENT
$T257058 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlot@@QAE@XZ PROC					; CvPlot::~CvPlot, COMDAT
; _this$ = ecx

; 168  : {

	push	-1
	push	__ehhandler$??1CvPlot@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi

; 169  : 	FSerialization::plotsToCheck.erase(this);

	lea	eax, DWORD PTR $T257058[esp+28]
	push	eax
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	mov	DWORD PTR __$EHRec$[esp+40], 3
	mov	DWORD PTR $T257058[esp+32], esi
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase

; 170  : 	uninit();

	mov	eax, DWORD PTR [esi+180]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+180], ebx
	mov	ecx, DWORD PTR [esi+188]
	add	esp, 4
	cmp	ecx, ebx
	je	SHORT $LN15@CvPlot
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN15@CvPlot:
	mov	DWORD PTR [esi+188], ebx
	mov	eax, DWORD PTR [esi+184]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+184], ebx
	add	esp, 4

; 171  : }

	lea	ecx, DWORD PTR [esi+428]
	mov	DWORD PTR [esi+28], ebx
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
	lea	ecx, DWORD PTR [esi+392]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	??1FAutoArchive@@UAE@XZ			; FAutoArchive::~FAutoArchive
	mov	ecx, DWORD PTR [esi+188]
	mov	BYTE PTR __$EHRec$[esp+36], bl
	cmp	ecx, ebx
	je	SHORT $LN32@CvPlot
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN32@CvPlot:
	mov	eax, DWORD PTR [esi+24]
	add	esi, 36					; 00000024H
	cmp	eax, esi
	pop	esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	pop	ebx
	je	SHORT $LN39@CvPlot
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN39@CvPlot:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlot@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
__unwindfunclet$??1CvPlot@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 188				; 000000bcH
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$??1CvPlot@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ
__unwindfunclet$??1CvPlot@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	jmp	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
__ehhandler$??1CvPlot@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPlot@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlot@@QAE@XZ ENDP					; CvPlot::~CvPlot
PUBLIC	?doImprovement@CvPlot@@QAEXXZ			; CvPlot::doImprovement
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getRandomResourceQuantity
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetImprovementResourceDiscoverRand
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?doImprovement@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$3
__ehfuncinfo$?doImprovement@CvPlot@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?doImprovement@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?doImprovement@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_thisResourceInfo$222406 = -84				; size = 4
$T257212 = -80						; size = 4
_thisTeam$ = -80					; size = 4
$T257214 = -76						; size = 8
$T257211 = -76						; size = 4
_iNumResourceInfos$222400 = -76				; size = 4
_iResourceNum$ = -76					; size = 4
_strBuffer$ = -68					; size = 28
$T257213 = -40						; size = 28
$T257210 = -40						; size = 28
$T257209 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?doImprovement@CvPlot@@QAEXXZ PROC			; CvPlot::doImprovement, COMDAT
; _this$ = ecx

; 445  : {

	push	-1
	push	__ehhandler$?doImprovement@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	mov	esi, ecx

; 446  : 	CvCity* pCity;
; 447  : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 448  : 	int iI;
; 449  : 	int iResourceNum = 0;
; 450  : 	CvTeam& thisTeam = GET_TEAM(getTeam());

	movsx	eax, BYTE PTR [esi+4]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+100], ebx
	cmp	eax, -1
	je	SHORT $LN26@doImprovem@2
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN26@doImprovem@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN25@doImprovem@2
$LN26@doImprovem@2:
	or	eax, -1
$LN25@doImprovem@2:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 451  : 
; 452  : 	CvAssert(isBeingWorked() && isOwned());
; 453  : 
; 454  : 	if(m_eImprovementType != NO_IMPROVEMENT)

	cmp	BYTE PTR [esi+441], -1
	mov	DWORD PTR _thisTeam$[esp+92], eax
	je	$LN160@doImprovem@2

; 455  : 	{
; 456  : 		if(m_eResourceType == NO_RESOURCE)

	cmp	BYTE PTR [esi+440], -1
	jne	$LN160@doImprovem@2
	push	ebp
	push	edi

; 457  : 		{
; 458  : 			CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvPlot::doImprovement");
; 459  : 			int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	edi, eax

; 460  : 			CvImprovementEntry* thisImprovementInfo = GC.getImprovementInfo((ImprovementTypes)m_eImprovementType);

	movsx	eax, BYTE PTR [esi+441]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iNumResourceInfos$222400[esp+104], edi
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ebp, eax

; 461  : 			for(iI = 0; iI < iNumResourceInfos; ++iI)

	test	edi, edi
	jle	$LN163@doImprovem@2
$LL13@doImprovem@2:

; 462  : 			{
; 463  : 				CvResourceInfo* thisResourceInfo = GC.getResourceInfo((ResourceTypes) iI);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _thisResourceInfo$222406[esp+100], eax

; 464  : 				if (thisResourceInfo)

	test	eax, eax
	je	SHORT $LN12@doImprovem@2

; 465  : 				{
; 466  : 					if(thisTeam.GetTeamTechs()->HasTech((TechTypes)(thisResourceInfo->getTechReveal())))

	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	mov	ecx, DWORD PTR _thisTeam$[esp+100]
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN12@doImprovem@2

; 467  : 					{
; 468  : 						if(thisImprovementInfo->GetImprovementResourceDiscoverRand(iI) > 0)

	push	ebx
	mov	ecx, ebp
	call	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetImprovementResourceDiscoverRand
	test	eax, eax
	jle	SHORT $LN12@doImprovem@2

; 469  : 						{
; 470  : 							if(GC.getGame().getJonRandNum(thisImprovementInfo->GetImprovementResourceDiscoverRand(iI), "Resource Discovery") == 0)

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222413
	push	ebx
	mov	ecx, ebp
	call	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetImprovementResourceDiscoverRand
	push	eax
	mov	ecx, edi
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	test	eax, eax
	je	SHORT $LN144@doImprovem@2
	mov	edi, DWORD PTR _iNumResourceInfos$222400[esp+100]
$LN12@doImprovem@2:

; 461  : 			for(iI = 0; iI < iNumResourceInfos; ++iI)

	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL13@doImprovem@2

; 469  : 						{
; 470  : 							if(GC.getGame().getJonRandNum(thisImprovementInfo->GetImprovementResourceDiscoverRand(iI), "Resource Discovery") == 0)

	jmp	$LN163@doImprovem@2
$LN144@doImprovem@2:

; 471  : 							{
; 472  : 								iResourceNum = GC.getMap().getRandomResourceQuantity((ResourceTypes)iI);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	call	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getRandomResourceQuantity

; 473  : 								setResourceType((ResourceTypes)iI, iResourceNum);

	movsx	ecx, BYTE PTR [esi+440]
	mov	DWORD PTR _iResourceNum$[esp+100], eax
	cmp	ecx, ebx
	je	$LN159@doImprovem@2
	cmp	ebx, -1
	je	SHORT $LN154@doImprovem@2
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	test	eax, eax
	je	SHORT $LN154@doImprovem@2
	mov	ecx, eax
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	test	al, al
	jne	$LN159@doImprovem@2
$LN154@doImprovem@2:
	cmp	BYTE PTR [esi+440], -1
	je	SHORT $LN155@doImprovem@2
	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN49@doImprovem@2
	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	movsx	edx, BYTE PTR [esi+440]
	push	-1
	push	edx
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN49@doImprovem@2:
	movsx	eax, BYTE PTR [esi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	eax
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN155@doImprovem@2
	movsx	ecx, BYTE PTR [esi+440]
	push	-1
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN155@doImprovem@2:
	mov	dl, BYTE PTR _iResourceNum$[esp+100]
	mov	BYTE PTR [esi+440], bl
	mov	BYTE PTR [esi+458], dl
	cmp	bl, -1
	je	SHORT $LN157@doImprovem@2
	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN156@doImprovem@2
	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	movsx	ecx, BYTE PTR [esi+440]
	push	1
	push	ecx
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN156@doImprovem@2:
	movsx	edx, BYTE PTR [esi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	edx
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN157@doImprovem@2
	movsx	eax, BYTE PTR [esi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	eax
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN157@doImprovem@2:
	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN159@doImprovem@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN159@doImprovem@2:

; 474  : 								if(getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	movsx	edi, BYTE PTR [esi+4]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	edi, eax
	jne	$LN163@doImprovem@2

; 475  : 								{
; 476  : 									pCity = GC.getMap().findCity(getX(), getY(), getOwner(), NO_TEAM, false);

	movsx	eax, BYTE PTR [esi+4]
	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	0
	push	-1
	push	-1
	push	0
	push	0
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	ebp, eax

; 477  : 									if(pCity != NULL)

	test	ebp, ebp
	je	$LN163@doImprovem@2

; 478  : 									{
; 479  : 										if(strcmp(thisResourceInfo->GetType(), "RESOURCE_ARTIFACTS") == 0)

	mov	ebx, DWORD PTR _thisResourceInfo$222406[esp+100]
	add	ebx, 176				; 000000b0H
	mov	ecx, ebx
	mov	edi, OFFSET $SG222419
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	6
$LL146@doImprovem@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN147@doImprovem@2
	test	cl, cl
	je	SHORT $LN148@doImprovem@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN147@doImprovem@2
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL146@doImprovem@2
$LN148@doImprovem@2:
	xor	eax, eax
	jmp	SHORT $LN149@doImprovem@2
$LN147@doImprovem@2:
	sbb	eax, eax
	sbb	eax, -1
$LN149@doImprovem@2:
	test	eax, eax
	jne	SHORT $LN4@doImprovem@2

; 480  : 										{
; 481  : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, ebp
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	ecx, DWORD PTR $T257209[esp+104]
	push	OFFSET $SG222426
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+108], 1
	jmp	$LN165@doImprovem@2
$LN4@doImprovem@2:

; 482  : 										}
; 483  : 										else if(strcmp(thisResourceInfo->GetType(), "RESOURCE_HIDDEN_ARTIFACTS") == 0)

	mov	ecx, ebx
	mov	edi, OFFSET $SG222429
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	6
$LL150@doImprovem@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edi]
	jne	SHORT $LN151@doImprovem@2
	test	cl, cl
	je	SHORT $LN152@doImprovem@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edi+1]
	jne	SHORT $LN151@doImprovem@2
	add	eax, 2
	add	edi, 2
	test	cl, cl
	jne	SHORT $LL150@doImprovem@2
$LN152@doImprovem@2:
	xor	eax, eax
	jmp	SHORT $LN153@doImprovem@2
$LN151@doImprovem@2:
	sbb	eax, eax
	sbb	eax, -1
$LN153@doImprovem@2:

; 484  : 										{
; 485  : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_HIDDEN_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, ebp
	test	eax, eax
	jne	SHORT $LN2@doImprovem@2
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	lea	edx, DWORD PTR $T257210[esp+104]
	push	OFFSET $SG222431
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[esp+108], 2

; 486  : 										}
; 487  : 										else

	jmp	SHORT $LN165@doImprovem@2
$LN2@doImprovem@2:

; 488  : 										{
; 489  : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_NEW_RESOURCE", thisResourceInfo->GetTextKey(), pCity->getNameKey());

	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	ecx, DWORD PTR _thisResourceInfo$222406[esp+100]
	mov	DWORD PTR $T257211[esp+100], eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T257212[esp+100], eax
	lea	eax, DWORD PTR $T257211[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T257212[esp+104]
	push	ecx
	lea	edx, DWORD PTR $T257213[esp+108]
	push	OFFSET $SG222443
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+108], 3
$LN165@doImprovem@2:
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+104]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T257213[esp+100]
	mov	BYTE PTR __$EHRec$[esp+108], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 490  : 										}
; 491  : 
; 492  : 										GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_DISCOVERRESOURCE", MESSAGE_TYPE_MINOR_EVENT, thisResourceInfo.GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX(), getY(), true, true*/);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	lea	ecx, DWORD PTR _strBuffer$[esp+100]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	movsx	ecx, BYTE PTR [esi+4]
	push	0
	push	0
	mov	edi, DWORD PTR [ebx]
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	push	eax
	push	0
	push	ecx
	lea	ecx, DWORD PTR $T257214[esp+148]
	push	ecx
	mov	ecx, ebp
	add	edi, 172				; 000000acH
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	edx, DWORD PTR [edi]
	push	eax
	push	0
	mov	ecx, ebx
	call	edx
$LN163@doImprovem@2:
	pop	edi
	pop	ebp
$LN160@doImprovem@2:

; 493  : 									}
; 494  : 								}
; 495  : 
; 496  : 								break;
; 497  : 							}
; 498  : 						}
; 499  : 					}
; 500  : 				}
; 501  : 			}
; 502  : 		}
; 503  : 	}
; 504  : 
; 505  : 	doImprovementUpgrade();

	mov	ecx, esi
	call	?doImprovementUpgrade@CvPlot@@IAEXXZ	; CvPlot::doImprovementUpgrade

; 506  : }

	lea	ecx, DWORD PTR _strBuffer$[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T257209[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T257210[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T257213[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?doImprovement@CvPlot@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?doImprovement@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?doImprovement@CvPlot@@QAEXXZ ENDP			; CvPlot::doImprovement
PUBLIC	?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z ; CvPlot::changeSeeFromSight
; Function compile flags: /Ogtpy
;	COMDAT ?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_eDirection$ = 12					; size = 4
_iFromLevel$ = 16					; size = 4
_bIncrement$ = 20					; size = 1
_eSeeInvisible$ = 24					; size = 4
?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z PROC ; CvPlot::changeSeeFromSight, COMDAT
; _this$ = ecx

; 1406 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 1407 : 	CvPlot* pPlot;
; 1408 : 	int iThroughLevel;
; 1409 : 
; 1410 : 	iThroughLevel = seeThroughLevel();

	movsx	eax, BYTE PTR [esi+6]
	push	edi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getSeeThroughLevel
	mov	edi, eax
	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN10@changeSeeF
	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	add	edi, eax
$LN10@changeSeeF:
	mov	al, BYTE PTR [esi+5]
	test	al, al
	jne	SHORT $LN9@changeSeeF
	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6212
$LN9@changeSeeF:
	cmp	al, 1
	jne	SHORT $LN8@changeSeeF
	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6220
$LN8@changeSeeF:
	cmp	al, 3
	jne	SHORT $LN7@changeSeeF
	add	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6228
$LN7@changeSeeF:

; 1411 : 
; 1412 : 	if(iFromLevel >= iThroughLevel)

	mov	ebx, DWORD PTR _iFromLevel$[esp+8]
	cmp	ebx, edi
	jl	SHORT $LN2@changeSeeF

; 1413 : 	{
; 1414 : 		pPlot = plotDirection(getX(), getY(), eDirection);

	mov	ecx, DWORD PTR _eDirection$[esp+8]
	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	ecx
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1415 : 
; 1416 : 		if(pPlot != NULL)

	test	esi, esi
	je	SHORT $LN2@changeSeeF

; 1417 : 		{
; 1418 : 			if((iFromLevel > iThroughLevel) || (pPlot->seeFromLevel(eTeam) > iFromLevel))

	cmp	ebx, edi
	mov	edi, DWORD PTR _eTeam$[esp+8]
	jg	SHORT $LN1@changeSeeF
	push	edi
	mov	ecx, esi
	call	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel
	cmp	eax, ebx
	jle	SHORT $LN2@changeSeeF
$LN1@changeSeeF:

; 1419 : 			{
; 1420 : 				pPlot->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, false);

	mov	ecx, DWORD PTR _eSeeInvisible$[esp+8]
	xor	edx, edx
	cmp	BYTE PTR _bIncrement$[esp+8], dl
	push	0
	setne	dl
	push	1
	push	ecx
	mov	ecx, esi
	lea	edx, DWORD PTR [edx+edx-1]
	push	edx
	push	edi
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN2@changeSeeF:
	pop	edi
	pop	esi
	pop	ebx

; 1421 : 			}
; 1422 : 		}
; 1423 : 	}
; 1424 : }

	ret	20					; 00000014H
?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z ENDP ; CvPlot::changeSeeFromSight
_TEXT	ENDS
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fe0000000000000
PUBLIC	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
EXTRN	?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z:PROC ; CvGlobals::getTurnRightDirection
;	COMDAT __real@3fa999999999999a
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
CONST	ENDS
;	COMDAT ?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z
_TEXT	SEGMENT
_bFirstHalfBlocked$223093 = -94				; size = 1
_bSecondHalfBlocked$223094 = -93			; size = 1
_thisRing$ = -92					; size = 4
_iFirstInwardLevel$223091 = -88				; size = 4
_iThisPlotLevel$223111 = -84				; size = 4
_iCenterLevel$ = -80					; size = 4
_iSecondInwardLevel$223092 = -76			; size = 4
_eDirectionOfNextTileToCheck$ = -72			; size = 4
_iDX$ = -68						; size = 4
_iDY$ = -64						; size = 4
_this$ = -60						; size = 4
_iPlotCounter$ = -56					; size = 4
_iMaxPlotNumberOnThisRing$ = -52			; size = 4
tv1300 = -48						; size = 4
tv1299 = -48						; size = 4
tv1298 = -48						; size = 4
tv1297 = -48						; size = 4
tv1290 = -48						; size = 4
tv1289 = -48						; size = 4
tv1200 = -48						; size = 4
tv1199 = -48						; size = 4
_fSecondDist$223137 = -48				; size = 8
_fSecondInwardY$223134 = -48				; size = 8
_fFirstDist$223131 = -40				; size = 8
_fFirstInwardY$223128 = -40				; size = 8
_fP0X$223113 = -40					; size = 8
_fSecondInwardX$223132 = -32				; size = 8
_fFirstInwardX$223126 = -32				; size = 8
_fP1X$223117 = -32					; size = 8
_b$223124 = -24						; size = 8
_a$223123 = -16						; size = 8
_fP0Y$223115 = -16					; size = 8
_c$223125 = -8						; size = 8
_fP1Y$223119 = -8					; size = 8
_eTeam$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bIncrement$ = 16					; size = 1
_eSeeInvisible$ = 20					; size = 4
_eFacingDirection$ = 24					; size = 4
_bBasedOnUnit$ = 28					; size = 1
?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z PROC ; CvPlot::changeAdjacentSight, COMDAT
; _this$ = ecx

; 1429 : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 116				; 00000074H

; 1430 : 	//check one extra outer ring
; 1431 : 	int iRangeWithOneExtraRing = iRange + 1;
; 1432 : 
; 1433 : 	// start in the center going NE
; 1434 : 	int thisRing = 0;
; 1435 : 	DirectionTypes eDirectionOfNextTileToCheck = DIRECTION_NORTHWEST;
; 1436 : 	CvPlot* pPlotToCheck = this;
; 1437 : 	int iDX = 0;
; 1438 : 	int iDY = 0;
; 1439 : 	int iCenterLevel = seeFromLevel(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _iRange$[ebp]
	push	esi
	push	edi
	xor	edi, edi
	push	eax
	mov	DWORD PTR _this$[esp+132], ecx
	inc	ebx
	mov	DWORD PTR _thisRing$[esp+132], edi
	mov	DWORD PTR _eDirectionOfNextTileToCheck$[esp+132], 5
	mov	esi, ecx
	mov	DWORD PTR _iDX$[esp+132], edi
	mov	DWORD PTR _iDY$[esp+132], edi
	call	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel

; 1440 : 	int iPlotCounter = 0;
; 1441 : 	int iMaxPlotNumberOnThisRing = 0;
; 1442 : 
; 1443 : 	while(thisRing <= iRangeWithOneExtraRing)

	cmp	ebx, edi
	mov	DWORD PTR _iCenterLevel$[esp+128], eax
	mov	DWORD PTR _iPlotCounter$[esp+128], edi
	mov	DWORD PTR _iMaxPlotNumberOnThisRing$[esp+128], edi
	jl	$LN58@changeAdja
	jmp	SHORT $LN59@changeAdja
	npad	5
$LL259@changeAdja:
	xor	edi, edi
$LN59@changeAdja:

; 1444 : 	{
; 1445 : 		if(pPlotToCheck)

	cmp	esi, edi
	je	$LN208@changeAdja

; 1446 : 		{
; 1447 : 			//always reveal adjacent plots when using line of sight - but then clear it out
; 1448 : 			if(thisRing <= 1)

	cmp	DWORD PTR _thisRing$[esp+128], 1
	jg	SHORT $LN55@changeAdja

; 1449 : 			{
; 1450 : 				if(eFacingDirection != NO_DIRECTION)

	cmp	DWORD PTR _eFacingDirection$[ebp], -1
	je	SHORT $LN55@changeAdja

; 1451 : 				{
; 1452 : 					pPlotToCheck->changeVisibilityCount(eTeam, 1, eSeeInvisible, false /*bInformExplorationTracking*/, false);

	mov	edi, DWORD PTR _eSeeInvisible$[ebp]
	mov	ebx, DWORD PTR _eTeam$[ebp]
	push	0
	push	0
	push	edi
	push	1
	push	ebx
	mov	ecx, esi
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount

; 1453 : 					pPlotToCheck->changeVisibilityCount(eTeam, -1, eSeeInvisible, false /*bInformExplorationTracking*/, false);

	push	0
	push	0
	push	edi
	push	-1
	push	ebx
	mov	ecx, esi
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN55@changeAdja:

; 1454 : 				}
; 1455 : 			}
; 1456 : 
; 1457 : 			// see if this plot is in the visibility wedge
; 1458 : 			if(shouldProcessDisplacementPlot(iDX, iDY, iRange, eFacingDirection))

	mov	ecx, DWORD PTR _eFacingDirection$[ebp]
	mov	edx, DWORD PTR _iRange$[ebp]
	mov	eax, DWORD PTR _iDY$[esp+128]
	push	ecx
	mov	ecx, DWORD PTR _iDX$[esp+132]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+144]
	call	?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ; CvPlot::shouldProcessDisplacementPlot
	test	al, al
	je	$LN208@changeAdja

; 1459 : 			{
; 1460 : 				if(thisRing != 0)

	cmp	DWORD PTR _thisRing$[esp+128], 0
	je	$LN53@changeAdja

; 1461 : 				{
; 1462 : 					CvPlot* pFirstInwardPlot = NULL;
; 1463 : 					CvPlot* pSecondInwardPlot = NULL;
; 1464 : 					const int INVALID_RING = -1;
; 1465 : 					const int HALF_BLOCKED = 0x01000000;
; 1466 : 					int iRingOfFirstInwardPlot = INVALID_RING;
; 1467 : 					int iRingOfSecondInwardPlot = INVALID_RING;
; 1468 : 					int iFirstInwardLevel = INVALID_RING;

	or	eax, -1
	mov	DWORD PTR _iFirstInwardLevel$223091[esp+128], eax

; 1469 : 					int iSecondInwardLevel = INVALID_RING;

	mov	DWORD PTR _iSecondInwardLevel$223092[esp+128], eax

; 1470 : 					bool bFirstHalfBlocked = false;
; 1471 : 					bool bSecondHalfBlocked = false;
; 1472 : 
; 1473 : 					// try to look at the two plot inwards
; 1474 : 					switch(eDirectionOfNextTileToCheck)

	mov	eax, DWORD PTR _eDirectionOfNextTileToCheck$[esp+128]
	xor	ebx, ebx
	xor	edi, edi
	mov	BYTE PTR _bFirstHalfBlocked$223093[esp+128], 0
	mov	BYTE PTR _bSecondHalfBlocked$223094[esp+128], 0
	cmp	eax, 5
	ja	$LN39@changeAdja
	jmp	DWORD PTR $LN287@changeAdja[eax*4]
$LN50@changeAdja:

; 1475 : 					{
; 1476 : 					case DIRECTION_NORTHEAST:
; 1477 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_EAST);

	movsx	edi, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	1
	push	edi
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection

; 1478 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHEAST);

	push	2

; 1479 : 						break;

	jmp	SHORT $LN272@changeAdja
$LN49@changeAdja:

; 1480 : 					case DIRECTION_EAST:
; 1481 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHWEST);

	movsx	edi, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	3
	push	edi
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection

; 1482 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHEAST);

	push	2

; 1483 : 						break;

	jmp	SHORT $LN272@changeAdja
$LN48@changeAdja:

; 1484 : 					case DIRECTION_SOUTHEAST:
; 1485 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHWEST);

	movsx	edi, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	3
	push	edi
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection

; 1486 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_WEST);

	push	4

; 1487 : 						break;

	jmp	SHORT $LN272@changeAdja
$LN47@changeAdja:

; 1488 : 					case DIRECTION_SOUTHWEST:
; 1489 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_WEST);

	movsx	edi, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	4
	push	edi
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection

; 1490 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHWEST);

	push	5

; 1491 : 						break;

	jmp	SHORT $LN272@changeAdja
$LN46@changeAdja:

; 1492 : 					case DIRECTION_WEST:
; 1493 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHWEST);

	push	5

; 1494 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHEAST);
; 1495 : 						break;

	jmp	SHORT $LN273@changeAdja
$LN45@changeAdja:

; 1496 : 					case DIRECTION_NORTHWEST:
; 1497 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_EAST);

	push	1
$LN273@changeAdja:
	movsx	edi, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edi
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection

; 1498 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHEAST);

	push	0
$LN272@changeAdja:
	mov	ebx, eax
	movsx	eax, WORD PTR [esi]
	push	edi
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 24					; 00000018H
	mov	edi, eax

; 1499 : 						break;
; 1500 : 					}
; 1501 : 					if(pFirstInwardPlot)

	test	ebx, ebx
	je	SHORT $LN42@changeAdja

; 1502 : 					{
; 1503 : 						iRingOfFirstInwardPlot = plotDistance(getX(),getY(),pFirstInwardPlot->getX(),pFirstInwardPlot->getY());
; 1504 : 						if(iRingOfFirstInwardPlot == thisRing - 1)

	movsx	edx, WORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx]
	push	edx
	push	eax
	mov	eax, DWORD PTR _this$[esp+136]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ecx, DWORD PTR _thisRing$[esp+144]
	dec	ecx
	add	esp, 16					; 00000010H
	cmp	eax, ecx
	jne	SHORT $LN42@changeAdja

; 1505 : 						{
; 1506 : 							iFirstInwardLevel = pFirstInwardPlot->getScratchPad();

	mov	eax, DWORD PTR [ebx+364]

; 1507 : 							if(iFirstInwardLevel >= HALF_BLOCKED)

	cmp	eax, 16777216				; 01000000H
	mov	DWORD PTR _iFirstInwardLevel$223091[esp+128], eax
	jl	SHORT $LN42@changeAdja

; 1508 : 							{
; 1509 : 								iFirstInwardLevel -= HALF_BLOCKED;

	sub	eax, 16777216				; 01000000H
	mov	DWORD PTR _iFirstInwardLevel$223091[esp+128], eax

; 1510 : 								bFirstHalfBlocked = true;

	mov	BYTE PTR _bFirstHalfBlocked$223093[esp+128], 1
$LN42@changeAdja:

; 1511 : 							}
; 1512 : 						}
; 1513 : 					}
; 1514 : 					if(pSecondInwardPlot)

	test	edi, edi
	je	SHORT $LN39@changeAdja

; 1515 : 					{
; 1516 : 						iRingOfSecondInwardPlot = plotDistance(getX(),getY(),pSecondInwardPlot->getX(),pSecondInwardPlot->getY());
; 1517 : 						if(iRingOfSecondInwardPlot == thisRing - 1)

	movsx	edx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	push	edx
	push	eax
	mov	eax, DWORD PTR _this$[esp+136]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ecx, DWORD PTR _thisRing$[esp+144]
	dec	ecx
	add	esp, 16					; 00000010H
	cmp	eax, ecx
	jne	SHORT $LN39@changeAdja

; 1518 : 						{
; 1519 : 							iSecondInwardLevel = pSecondInwardPlot->getScratchPad();

	mov	eax, DWORD PTR [edi+364]

; 1520 : 							if(iSecondInwardLevel >= HALF_BLOCKED)

	cmp	eax, 16777216				; 01000000H
	mov	DWORD PTR _iSecondInwardLevel$223092[esp+128], eax
	jl	SHORT $LN39@changeAdja

; 1521 : 							{
; 1522 : 								iSecondInwardLevel -= HALF_BLOCKED;

	sub	eax, 16777216				; 01000000H
	mov	DWORD PTR _iSecondInwardLevel$223092[esp+128], eax

; 1523 : 								bSecondHalfBlocked = true;

	mov	BYTE PTR _bSecondHalfBlocked$223094[esp+128], 1
$LN39@changeAdja:

; 1524 : 							}
; 1525 : 						}
; 1526 : 					}
; 1527 : 					int iThisPlotLevel = pPlotToCheck->seeThroughLevel(thisRing != iRangeWithOneExtraRing);

	mov	eax, DWORD PTR _iRange$[ebp]
	inc	eax
	cmp	DWORD PTR _thisRing$[esp+128], eax
	mov	ecx, esi
	setne	dl
	movzx	eax, dl
	push	eax
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel

; 1528 : 					if(iFirstInwardLevel != INVALID_RING && iSecondInwardLevel != INVALID_RING && iFirstInwardLevel != iSecondInwardLevel && !bFirstHalfBlocked && !bSecondHalfBlocked)

	mov	ecx, DWORD PTR _iFirstInwardLevel$223091[esp+128]
	mov	DWORD PTR _iThisPlotLevel$223111[esp+128], eax
	mov	eax, DWORD PTR _iSecondInwardLevel$223092[esp+128]
	cmp	ecx, -1
	je	$LN20@changeAdja
	cmp	eax, -1
	je	$LN38@changeAdja
	cmp	ecx, eax
	je	$LN38@changeAdja
	cmp	BYTE PTR _bFirstHalfBlocked$223093[esp+128], 0
	jne	$LN20@changeAdja
	cmp	BYTE PTR _bSecondHalfBlocked$223094[esp+128], 0
	jne	$LN257@changeAdja

; 1529 : 					{
; 1530 : 						double fP0X = (double) getX();

	mov	eax, DWORD PTR _this$[esp+128]
	movsx	ecx, WORD PTR [eax]

; 1531 : 						double fP0Y = (double) getY();

	movzx	eax, WORD PTR [eax+2]
	mov	DWORD PTR tv1300[esp+128], ecx

; 1532 : 						double fP1X = (double) pPlotToCheck->getX();

	movsx	ecx, WORD PTR [esi]
	fild	DWORD PTR tv1300[esp+128]
	movsx	edx, ax
	fstp	QWORD PTR _fP0X$223113[esp+128]
	mov	DWORD PTR tv1299[esp+128], edx
	fild	DWORD PTR tv1299[esp+128]
	mov	DWORD PTR tv1298[esp+128], ecx

; 1533 : 						double fP1Y = (double) pPlotToCheck->getY();

	movzx	ecx, WORD PTR [esi+2]
	movsx	edx, cx
	fstp	QWORD PTR _fP0Y$223115[esp+128]
	fild	DWORD PTR tv1298[esp+128]
	mov	DWORD PTR tv1297[esp+128], edx
	fstp	QWORD PTR _fP1X$223117[esp+128]
	fild	DWORD PTR tv1297[esp+128]
	fstp	QWORD PTR _fP1Y$223119[esp+128]

; 1534 : 						if(getY() & 1)

	test	al, 1
	je	SHORT $LN37@changeAdja

; 1535 : 						{
; 1536 : 							fP0X += 0.5;

	fld	QWORD PTR _fP0X$223113[esp+128]
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _fP0X$223113[esp+128]
$LN37@changeAdja:

; 1537 : 						}
; 1538 : 						if(pPlotToCheck->getY() & 1)

	test	cl, 1
	je	SHORT $LN36@changeAdja

; 1539 : 						{
; 1540 : 							fP1X += 0.5;

	fld	QWORD PTR _fP1X$223117[esp+128]
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _fP1X$223117[esp+128]
$LN36@changeAdja:

; 1541 : 						}
; 1542 : 
; 1543 : 						double a = fP1Y - fP0Y;

	fld	QWORD PTR _fP1Y$223119[esp+128]

; 1544 : 						double b = fP0X - fP1X;
; 1545 : 						double c = fP0Y * fP1X - fP1Y * fP0X;
; 1546 : 
; 1547 : 						double fFirstInwardX = (double) pFirstInwardPlot->getX();

	movsx	eax, WORD PTR [ebx]
	fld	ST(0)
	mov	DWORD PTR tv1290[esp+128], eax
	fld	QWORD PTR _fP0Y$223115[esp+128]

; 1548 : 						double fFirstInwardY = (double) pFirstInwardPlot->getY();

	movzx	eax, WORD PTR [ebx+2]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	movsx	ecx, ax
	fstp	QWORD PTR _a$223123[esp+128]
	fld	QWORD PTR _fP0X$223113[esp+128]
	fld	ST(0)
	fld	QWORD PTR _fP1X$223117[esp+128]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _b$223124[esp+128]
	fmulp	ST(2), ST(0)
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _c$223125[esp+128]
	fild	DWORD PTR tv1290[esp+128]
	mov	DWORD PTR tv1289[esp+128], ecx
	fstp	QWORD PTR _fFirstInwardX$223126[esp+128]
	fild	DWORD PTR tv1289[esp+128]
	fstp	QWORD PTR _fFirstInwardY$223128[esp+128]

; 1549 : 						if(pFirstInwardPlot->getY() & 1)

	test	al, 1
	je	SHORT $LN35@changeAdja

; 1550 : 						{
; 1551 : 							fFirstInwardX += 0.5;

	fld	QWORD PTR _fFirstInwardX$223126[esp+128]
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _fFirstInwardX$223126[esp+128]
$LN35@changeAdja:

; 1552 : 						}
; 1553 : 						double fFirstDist = a * fFirstInwardX + b * fFirstInwardY + c;

	fld	QWORD PTR _fFirstInwardY$223128[esp+128]

; 1554 : 						fFirstDist = abs(fFirstDist);

	sub	esp, 8
	fmul	QWORD PTR _b$223124[esp+136]
	mov	eax, esp
	fld	QWORD PTR _fFirstInwardX$223126[esp+136]
	fmul	QWORD PTR _a$223123[esp+136]
	faddp	ST(1), ST(0)
	fadd	QWORD PTR _c$223125[esp+136]
	fstp	QWORD PTR _fFirstDist$223131[esp+136]
	mov	edx, DWORD PTR _fFirstDist$223131[esp+136]
	mov	ecx, DWORD PTR _fFirstDist$223131[esp+140]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	call	?abs@@YANN@Z				; abs
	fstp	QWORD PTR _fFirstDist$223131[esp+136]

; 1555 : 						// skip the extra distance since it is the same for both equations
; 1556 : 
; 1557 : 						double fSecondInwardX = (double) pSecondInwardPlot->getX();

	movsx	edx, WORD PTR [edi]

; 1558 : 						double fSecondInwardY = (double) pSecondInwardPlot->getY();

	movzx	eax, WORD PTR [edi+2]
	mov	DWORD PTR tv1200[esp+136], edx
	movsx	ecx, ax
	fild	DWORD PTR tv1200[esp+136]
	mov	DWORD PTR tv1199[esp+136], ecx
	add	esp, 8
	fstp	QWORD PTR _fSecondInwardX$223132[esp+128]
	fild	DWORD PTR tv1199[esp+128]
	fstp	QWORD PTR _fSecondInwardY$223134[esp+128]

; 1559 : 						if(pSecondInwardPlot->getY() & 1)

	test	al, 1
	je	SHORT $LN34@changeAdja

; 1560 : 						{
; 1561 : 							fSecondInwardX += 0.5;

	fld	QWORD PTR _fSecondInwardX$223132[esp+128]
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR _fSecondInwardX$223132[esp+128]
$LN34@changeAdja:

; 1562 : 						}
; 1563 : 						double fSecondDist = a * fSecondInwardX + b * fSecondInwardY + c;

	fld	QWORD PTR _fSecondInwardY$223134[esp+128]

; 1564 : 						fSecondDist = abs(fSecondDist);

	sub	esp, 8
	fmul	QWORD PTR _b$223124[esp+136]
	mov	eax, esp
	fld	QWORD PTR _fSecondInwardX$223132[esp+136]
	fmul	QWORD PTR _a$223123[esp+136]
	faddp	ST(1), ST(0)
	fadd	QWORD PTR _c$223125[esp+136]
	fstp	QWORD PTR _fSecondDist$223137[esp+136]
	mov	edx, DWORD PTR _fSecondDist$223137[esp+136]
	mov	ecx, DWORD PTR _fSecondDist$223137[esp+140]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	call	?abs@@YANN@Z				; abs
	fstp	QWORD PTR _fSecondDist$223137[esp+136]

; 1565 : 						// skip the extra distance since it is the same for both equations
; 1566 : 
; 1567 : 						if(fFirstDist - fSecondDist > 0.05)  // we are closer to the second point

	fld	QWORD PTR _fFirstDist$223131[esp+136]
	add	esp, 8
	fld	ST(0)
	fld	QWORD PTR _fSecondDist$223137[esp+128]
	fsub	ST(1), ST(0)
	fld	QWORD PTR __real@3fa999999999999a
	fcom	ST(2)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 5
	jp	SHORT $LN33@changeAdja

; 1568 : 						{
; 1569 : 							int iHighestLevel = (iSecondInwardLevel > iThisPlotLevel) ? iSecondInwardLevel : iThisPlotLevel;

	mov	ecx, DWORD PTR _iSecondInwardLevel$223092[esp+128]
	fstp	ST(2)
	mov	edx, DWORD PTR _iThisPlotLevel$223111[esp+128]
	fstp	ST(1)
	fstp	ST(0)

; 1570 : 							pPlotToCheck->setScratchPad(iHighestLevel);
; 1571 : 							if(iSecondInwardLevel < iThisPlotLevel || ((iCenterLevel >= iSecondInwardLevel) && (thisRing < iRangeWithOneExtraRing)))
; 1572 : 							{								
; 1573 : 								pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	jmp	SHORT $LN284@changeAdja
$LN33@changeAdja:

; 1574 : 							}
; 1575 : 						}
; 1576 : 						else if(fSecondDist - fFirstDist > 0.05)   // we are closer to the first point
; 1577 : 						{
; 1578 : 							int iHighestLevel = (iFirstInwardLevel > iThisPlotLevel) ? iFirstInwardLevel : iThisPlotLevel;

	mov	ecx, DWORD PTR _iFirstInwardLevel$223091[esp+128]
	fsubrp	ST(2), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN29@changeAdja
	mov	edx, DWORD PTR _iThisPlotLevel$223111[esp+128]

; 1579 : 							pPlotToCheck->setScratchPad(iHighestLevel);
; 1580 : 							if(iFirstInwardLevel < iThisPlotLevel || ((iCenterLevel >= iFirstInwardLevel) && (thisRing < iRangeWithOneExtraRing)))
; 1581 : 							{								
; 1582 : 								pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	jmp	SHORT $LN284@changeAdja
$LN29@changeAdja:

; 1583 : 							}
; 1584 : 						}
; 1585 : 						else
; 1586 : 						{
; 1587 : 							int iHighestInwardLevel = (iFirstInwardLevel > iSecondInwardLevel) ? iFirstInwardLevel : iSecondInwardLevel;

	mov	eax, DWORD PTR _iSecondInwardLevel$223092[esp+128]
	cmp	ecx, eax
	mov	edi, ecx
	jg	SHORT $LN275@changeAdja
	mov	edi, eax
	jmp	SHORT $LN72@changeAdja
$LN275@changeAdja:

; 1588 : 							int iLowestInwardLevel = (iFirstInwardLevel > iSecondInwardLevel) ? iSecondInwardLevel : iFirstInwardLevel;

	mov	ecx, eax
$LN72@changeAdja:

; 1589 : 							int iHighestLevel = (iHighestInwardLevel > iThisPlotLevel) ? iHighestInwardLevel : iThisPlotLevel;

	mov	eax, DWORD PTR _iThisPlotLevel$223111[esp+128]
	cmp	edi, eax
	mov	ebx, edi
	jg	SHORT $LN75@changeAdja
	mov	ebx, eax
$LN75@changeAdja:

; 1590 : 							int iHighestLowestLevel = (iLowestInwardLevel > iThisPlotLevel) ? iLowestInwardLevel : iThisPlotLevel;

	cmp	ecx, eax
	mov	edx, ecx
	jg	SHORT $LN77@changeAdja
	mov	edx, eax
$LN77@changeAdja:

; 1591 : 							if(iHighestInwardLevel > iThisPlotLevel)

	cmp	edi, eax
	jle	SHORT $LN25@changeAdja

; 1592 : 							{
; 1593 : 								pPlotToCheck->setScratchPad(iHighestLowestLevel + HALF_BLOCKED);

	add	edx, 16777216				; 01000000H
	mov	DWORD PTR [esi+364], edx

; 1598 : 							}
; 1599 : 							if(iLowestInwardLevel < iThisPlotLevel || ((iCenterLevel >= iLowestInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	cmp	ecx, eax

; 1600 : 							{								
; 1601 : 								pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	jmp	SHORT $LN282@changeAdja
$LN25@changeAdja:

; 1594 : 							}
; 1595 : 							else
; 1596 : 							{
; 1597 : 								pPlotToCheck->setScratchPad(iHighestLevel);

	mov	DWORD PTR [esi+364], ebx

; 1598 : 							}
; 1599 : 							if(iLowestInwardLevel < iThisPlotLevel || ((iCenterLevel >= iLowestInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	cmp	ecx, eax

; 1600 : 							{								
; 1601 : 								pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	jmp	SHORT $LN282@changeAdja
$LN38@changeAdja:

; 1602 : 							}
; 1603 : 						}
; 1604 : 					}
; 1605 : 					else if(iFirstInwardLevel != INVALID_RING && !bFirstHalfBlocked)

	cmp	BYTE PTR _bFirstHalfBlocked$223093[esp+128], 0
	jne	SHORT $LN20@changeAdja
$LN257@changeAdja:

; 1606 : 					{
; 1607 : 						int iHighestLevel = (iFirstInwardLevel > iThisPlotLevel) ? iFirstInwardLevel : iThisPlotLevel;

	mov	edx, DWORD PTR _iThisPlotLevel$223111[esp+128]

; 1608 : 						pPlotToCheck->setScratchPad(iHighestLevel);
; 1609 : 						if(iFirstInwardLevel < iThisPlotLevel || ((iCenterLevel >= iFirstInwardLevel) && (thisRing < iRangeWithOneExtraRing)))
; 1610 : 						{							
; 1611 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	jmp	SHORT $LN284@changeAdja
$LN20@changeAdja:

; 1612 : 						}
; 1613 : 					}
; 1614 : 					else if(iSecondInwardLevel != INVALID_RING && !bSecondHalfBlocked)

	cmp	eax, -1
	je	SHORT $LN16@changeAdja
	cmp	BYTE PTR _bSecondHalfBlocked$223094[esp+128], 0
	jne	SHORT $LN16@changeAdja

; 1615 : 					{
; 1616 : 						int iHighestLevel = (iSecondInwardLevel > iThisPlotLevel) ? iSecondInwardLevel : iThisPlotLevel;

	mov	edx, DWORD PTR _iThisPlotLevel$223111[esp+128]

; 1617 : 						pPlotToCheck->setScratchPad(iHighestLevel);
; 1618 : 						if(iSecondInwardLevel < iThisPlotLevel || ((iCenterLevel >= iSecondInwardLevel) && (thisRing < iRangeWithOneExtraRing)))
; 1619 : 						{							
; 1620 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	jmp	SHORT $LN286@changeAdja
$LN16@changeAdja:

; 1621 : 						}
; 1622 : 					}
; 1623 : 					else if(iFirstInwardLevel != INVALID_RING)
; 1624 : 					{
; 1625 : 						int iHighestLevel = (iFirstInwardLevel > iThisPlotLevel) ? iFirstInwardLevel : iThisPlotLevel;

	mov	edx, DWORD PTR _iThisPlotLevel$223111[esp+128]
	cmp	ecx, -1
	je	SHORT $LN12@changeAdja
$LN284@changeAdja:
	cmp	ecx, edx
	mov	eax, ecx
	jg	SHORT $LN89@changeAdja
	mov	eax, edx
$LN89@changeAdja:

; 1626 : 						pPlotToCheck->setScratchPad(iHighestLevel);

	mov	DWORD PTR [esi+364], eax

; 1627 : 						if(iFirstInwardLevel < iThisPlotLevel || ((iCenterLevel >= iFirstInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	cmp	ecx, edx
$LN282@changeAdja:
	jl	SHORT $LN6@changeAdja
	cmp	DWORD PTR _iCenterLevel$[esp+128], ecx

; 1628 : 						{
; 1629 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	jmp	SHORT $LN276@changeAdja
$LN12@changeAdja:

; 1630 : 						}
; 1631 : 					}
; 1632 : 					else if(iSecondInwardLevel != INVALID_RING)

	cmp	eax, -1
	je	SHORT $LN8@changeAdja
$LN286@changeAdja:

; 1633 : 					{
; 1634 : 						int iHighestLevel = (iSecondInwardLevel > iThisPlotLevel) ? iSecondInwardLevel : iThisPlotLevel;

	cmp	eax, edx
	mov	ecx, eax
	jg	SHORT $LN280@changeAdja
	mov	ecx, edx
$LN280@changeAdja:

; 1635 : 						pPlotToCheck->setScratchPad(iHighestLevel);

	mov	DWORD PTR [esi+364], ecx

; 1636 : 						if(iSecondInwardLevel < iThisPlotLevel || ((iCenterLevel >= iSecondInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	jl	SHORT $LN6@changeAdja
	cmp	DWORD PTR _iCenterLevel$[esp+128], eax
$LN276@changeAdja:
	jl	SHORT $LN208@changeAdja
	mov	eax, DWORD PTR _iRange$[ebp]
	inc	eax
	cmp	DWORD PTR _thisRing$[esp+128], eax
	jge	SHORT $LN208@changeAdja
$LN6@changeAdja:

; 1637 : 						{							
; 1638 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	cmp	BYTE PTR _bBasedOnUnit$[ebp], 0
	je	SHORT $LN94@changeAdja
	cmp	DWORD PTR _thisRing$[esp+128], 2
	jge	SHORT $LN94@changeAdja
	mov	al, 1
	jmp	SHORT $LN95@changeAdja
$LN94@changeAdja:
	xor	al, al
$LN95@changeAdja:
	mov	edx, DWORD PTR _eSeeInvisible$[ebp]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	eax
	xor	eax, eax
	cmp	BYTE PTR _bIncrement$[ebp], al
	push	1
	setne	al
	push	edx
	lea	eax, DWORD PTR [eax+eax-1]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount

; 1639 : 						}
; 1640 : 					}
; 1641 : 					else // I have no idea how this can happen, but...

	jmp	SHORT $LN208@changeAdja
$LN8@changeAdja:

; 1642 : 					{
; 1643 : 						// set our value in the scratch pad
; 1644 : 						pPlotToCheck->setScratchPad(iThisPlotLevel);

	mov	DWORD PTR [esi+364], edx

; 1645 : 					}
; 1646 : 				}
; 1647 : 				else // this is the center point

	jmp	SHORT $LN208@changeAdja
$LN53@changeAdja:

; 1648 : 				{					
; 1649 : #ifdef AUI_WARNING_FIXES
; 1650 : 					pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, bBasedOnUnit ? true : false);
; 1651 : #else
; 1652 : 					pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	cmp	BYTE PTR _bBasedOnUnit$[ebp], 0
	mov	edx, DWORD PTR _eTeam$[ebp]
	setne	al
	xor	ecx, ecx
	cmp	BYTE PTR _bIncrement$[ebp], cl
	setne	cl
	push	eax
	mov	eax, DWORD PTR _eSeeInvisible$[ebp]
	push	1
	push	eax
	lea	ecx, DWORD PTR [ecx+ecx-1]
	push	ecx
	push	edx
	mov	ecx, esi
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount

; 1653 : #endif
; 1654 : 					pPlotToCheck->setScratchPad(0);

	mov	DWORD PTR [esi+364], 0
$LN208@changeAdja:

; 1655 : 				}
; 1656 : 			}
; 1657 : 
; 1658 : 		}
; 1659 : 
; 1660 : 		int iNextDX;
; 1661 : 		int iNextDY;
; 1662 : 		if(iPlotCounter >= iMaxPlotNumberOnThisRing)  // we have processed all of the plots in this ring

	mov	ecx, DWORD PTR _iMaxPlotNumberOnThisRing$[esp+128]
	cmp	DWORD PTR _iPlotCounter$[esp+128], ecx
	jl	SHORT $LN3@changeAdja

; 1663 : 		{
; 1664 : 			// if that fails go out one ring in the NE direction traveling E
; 1665 : 			eDirectionOfNextTileToCheck = DIRECTION_NORTHEAST;
; 1666 : 			iNextDX = iDX + GC.getPlotDirectionX()[eDirectionOfNextTileToCheck];

	mov	edx, DWORD PTR _iDX$[esp+128]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+112

; 1667 : 			iNextDY = iDY + GC.getPlotDirectionY()[eDirectionOfNextTileToCheck];

	mov	esi, DWORD PTR _iDY$[esp+128]
	add	eax, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+136
	add	esi, edx

; 1668 : 			thisRing++;

	mov	edx, DWORD PTR _thisRing$[esp+128]
	inc	edx
	mov	DWORD PTR _thisRing$[esp+128], edx

; 1669 : 			iMaxPlotNumberOnThisRing += thisRing * 6;

	lea	edx, DWORD PTR [edx+edx*2]
	lea	ecx, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR _iMaxPlotNumberOnThisRing$[esp+128], ecx

; 1670 : 			eDirectionOfNextTileToCheck = DIRECTION_EAST;

	mov	DWORD PTR _eDirectionOfNextTileToCheck$[esp+128], 1

; 1671 : 			// (if that is further out than the extended range, we are done)
; 1672 : 		}
; 1673 : 		else

	jmp	$LN1@changeAdja
$LN3@changeAdja:

; 1674 : 		{
; 1675 : 			iNextDX = iDX + GC.getPlotDirectionX()[eDirectionOfNextTileToCheck];

	mov	ecx, DWORD PTR _eDirectionOfNextTileToCheck$[esp+128]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	add	eax, DWORD PTR _iDX$[esp+128]

; 1676 : 			iNextDY = iDY + GC.getPlotDirectionY()[eDirectionOfNextTileToCheck];

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]
	add	esi, DWORD PTR _iDY$[esp+128]

; 1677 : 			if(hexDistance(iNextDX,iNextDY) > thisRing)

	mov	edx, 0
	setns	dl
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	cmp	ecx, edx
	mov	edx, eax
	jne	SHORT $LN219@changeAdja
	test	eax, eax
	jge	SHORT $LN223@changeAdja
	neg	edx
$LN223@changeAdja:
	mov	ecx, esi
	test	esi, esi
	jge	SHORT $LN225@changeAdja
	neg	ecx
$LN225@changeAdja:
	add	ecx, edx
	jmp	SHORT $LN230@changeAdja
$LN219@changeAdja:
	test	eax, eax
	jge	SHORT $LN227@changeAdja
	neg	edx
$LN227@changeAdja:
	mov	ecx, esi
	test	esi, esi
	jge	SHORT $LN229@changeAdja
	neg	ecx
$LN229@changeAdja:
	cmp	edx, ecx
	jl	SHORT $LN230@changeAdja
	mov	ecx, edx
$LN230@changeAdja:
	cmp	ecx, DWORD PTR _thisRing$[esp+128]
	jle	SHORT $LN1@changeAdja

; 1678 : 			{
; 1679 : 				// try to turn right
; 1680 : 				eDirectionOfNextTileToCheck = GC.getTurnRightDirection(eDirectionOfNextTileToCheck);

	mov	edx, DWORD PTR _eDirectionOfNextTileToCheck$[esp+128]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z ; CvGlobals::getTurnRightDirection
	mov	ecx, eax

; 1681 : 				iNextDX = iDX + GC.getPlotDirectionX()[eDirectionOfNextTileToCheck];

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]

; 1682 : 				iNextDY = iDY + GC.getPlotDirectionY()[eDirectionOfNextTileToCheck];

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]
	add	eax, DWORD PTR _iDX$[esp+128]
	add	esi, DWORD PTR _iDY$[esp+128]
	mov	DWORD PTR _eDirectionOfNextTileToCheck$[esp+128], ecx
$LN1@changeAdja:

; 1683 : 			}
; 1684 : 		}
; 1685 : 
; 1686 : 		iPlotCounter++;

	inc	DWORD PTR _iPlotCounter$[esp+128]

; 1687 : 
; 1688 : 		iDX = iNextDX;
; 1689 : 		iDY = iNextDY;
; 1690 : 		pPlotToCheck = plotXYWithRangeCheck(getX(),getY(),iDX,iDY,iRangeWithOneExtraRing);

	xor	ecx, ecx
	test	esi, esi
	setge	cl
	xor	edx, edx
	test	eax, eax
	setge	dl
	mov	DWORD PTR _iDX$[esp+128], eax
	mov	DWORD PTR _iDY$[esp+128], esi
	cmp	edx, ecx
	mov	edx, eax
	jne	SHORT $LN242@changeAdja
	test	eax, eax
	jge	SHORT $LN246@changeAdja
	neg	edx
$LN246@changeAdja:
	mov	ecx, esi
	test	esi, esi
	jge	SHORT $LN248@changeAdja
	neg	ecx
$LN248@changeAdja:
	add	ecx, edx
	jmp	SHORT $LN253@changeAdja
$LN242@changeAdja:
	test	eax, eax
	jge	SHORT $LN250@changeAdja
	neg	edx
$LN250@changeAdja:
	mov	ecx, esi
	test	esi, esi
	jge	SHORT $LN252@changeAdja
	neg	ecx
$LN252@changeAdja:
	cmp	edx, ecx
	jl	SHORT $LN253@changeAdja
	mov	ecx, edx
$LN253@changeAdja:
	mov	edx, DWORD PTR _iRange$[ebp]
	inc	edx
	cmp	ecx, edx
	jle	SHORT $LN240@changeAdja
	xor	esi, esi
	jmp	SHORT $LN243@changeAdja
$LN240@changeAdja:
	push	esi
	push	eax
	mov	eax, DWORD PTR _this$[esp+136]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	mov	esi, eax
$LN243@changeAdja:
	mov	eax, DWORD PTR _iRange$[ebp]
	inc	eax
	cmp	DWORD PTR _thisRing$[esp+128], eax
	jle	$LL259@changeAdja
$LN58@changeAdja:

; 1691 : 	}
; 1692 : 
; 1693 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	2
$LN287@changeAdja:
	DD	$LN50@changeAdja
	DD	$LN49@changeAdja
	DD	$LN48@changeAdja
	DD	$LN47@changeAdja
	DD	$LN46@changeAdja
	DD	$LN45@changeAdja
?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ENDP ; CvPlot::changeAdjacentSight
_TEXT	ENDS
PUBLIC	?updateSight@CvPlot@@QAEX_N@Z			; CvPlot::updateSight
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?getReconPlot@CvUnit@@QBEPAVCvPlot@@XZ:PROC	; CvUnit::getReconPlot
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?visibilityRange@CvUnit@@QBEHXZ:PROC		; CvUnit::visibilityRange
EXTRN	?getSeeInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ:PROC ; CvUnit::getSeeInvisibleType
EXTRN	?getFacingDirection@CvUnit@@QBE?AW4DirectionTypes@@_N@Z:PROC ; CvUnit::getFacingDirection
EXTRN	?canChangeVisibility@CvUnit@@QBE_NXZ:PROC	; CvUnit::canChangeVisibility
EXTRN	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z:PROC ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
EXTRN	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ:PROC ; CvPlayer::GetEspionage
; Function compile flags: /Ogtpy
;	COMDAT ?updateSight@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_bIncrement$ = 8					; size = 1
?updateSight@CvPlot@@QAEX_N@Z PROC			; CvPlot::updateSight, COMDAT
; _this$ = ecx

; 1818 : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebx, ecx

; 1819 : 	IDInfo* pUnitNode;
; 1820 : 	CvCity* pCity;
; 1821 : 	CvUnit* pLoopUnit;
; 1822 : 	int iLoop;
; 1823 : 	int iI;
; 1824 : 
; 1825 : 	pCity = getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	push	esi
	push	edi
	test	eax, eax
	jl	SHORT $LN125@updateSigh
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN125@updateSigh
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax
	jmp	SHORT $LN24@updateSigh
$LN125@updateSigh:
	xor	edi, edi
$LN24@updateSigh:

; 1826 : 
; 1827 : 	// Owned
; 1828 : 	if(isOwned())

	mov	al, BYTE PTR [ebx+4]
	cmp	al, -1
	je	$LN126@updateSigh

; 1829 : 	{
; 1830 : 		changeAdjacentSight(getTeam(), GC.getPLOT_VISIBILITY_RANGE(), bIncrement, NO_INVISIBLE, NO_DIRECTION, false);

	movsx	eax, al
	cmp	eax, -1
	je	SHORT $LN35@updateSigh
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN35@updateSigh
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN34@updateSigh
$LN35@updateSigh:
	or	eax, -1
$LN34@updateSigh:
	mov	ebp, DWORD PTR _bIncrement$[esp+16]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	push	0
	push	-1
	push	-1
	push	ebp
	push	edx
	push	eax
	mov	ecx, ebx
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight

; 1831 : 
; 1832 : 		// if this tile is owned by a minor share the visibility with my ally
; 1833 : 		if(pCity)

	test	edi, edi
	je	SHORT $LN16@updateSigh

; 1834 : 		{
; 1835 : 			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	esi, esi
	npad	7
$LL18@updateSigh:

; 1836 : 			{
; 1837 : 				PlayerTypes ePlayer = (PlayerTypes)ui;
; 1838 : 				if(GET_PLAYER(ePlayer).GetEspionage()->HasEstablishedSurveillanceInCity(pCity))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	push	edi
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
	test	al, al
	je	SHORT $LN17@updateSigh

; 1839 : 				{
; 1840 : 					changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), bIncrement, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN57@updateSigh
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN58@updateSigh
$LN57@updateSigh:
	or	eax, -1
$LN58@updateSigh:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	push	0
	push	-1
	push	-1
	push	ebp
	push	edx
	push	eax
	mov	ecx, ebx
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN17@updateSigh:
	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jb	SHORT $LL18@updateSigh
$LN16@updateSigh:

; 1841 : 				}
; 1842 : 			}
; 1843 : 		}
; 1844 : 
; 1845 : 		PlayerTypes ownerID = getOwner();

	movsx	eax, BYTE PTR [ebx+4]

; 1846 : 		if(ownerID >= MAX_MAJOR_CIVS && ownerID != BARBARIAN_PLAYER)

	cmp	eax, 22					; 00000016H
	jl	SHORT $LN126@updateSigh
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN126@updateSigh

; 1847 : 		{
; 1848 : 			CvPlayer& thisPlayer = GET_PLAYER(ownerID);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1849 : 			CvMinorCivAI* pMinorCivAI = thisPlayer.GetMinorCivAI();

	mov	ecx, eax
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	esi, eax

; 1850 : 			if(pMinorCivAI && pMinorCivAI->GetAlly() != NO_PLAYER)

	test	esi, esi
	je	SHORT $LN126@updateSigh
	mov	ecx, esi
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	je	SHORT $LN126@updateSigh

; 1851 : 			{
; 1852 : 				changeAdjacentSight(GET_PLAYER(pMinorCivAI->GetAlly()).getTeam(), GC.getPLOT_VISIBILITY_RANGE(), bIncrement, NO_INVISIBLE, NO_DIRECTION, false);

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	ecx, esi
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN74@updateSigh
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN75@updateSigh
$LN74@updateSigh:
	or	eax, -1
$LN75@updateSigh:
	push	0
	push	-1
	push	-1
	push	ebp
	push	edi
	push	eax
	mov	ecx, ebx
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN126@updateSigh:

; 1853 : 			}
; 1854 : 		}
; 1855 : 	}
; 1856 : 
; 1857 : 	pUnitNode = headUnitNode();

	cmp	DWORD PTR [ebx+28], 0
	jbe	SHORT $LN82@updateSigh
	mov	esi, DWORD PTR [ebx+24]
	jmp	SHORT $LN81@updateSigh
$LN82@updateSigh:
	xor	esi, esi
$LN81@updateSigh:

; 1858 : 
; 1859 : 	// Unit
; 1860 : 	while(pUnitNode != NULL)

	test	esi, esi
	je	$LN11@updateSigh
$LL12@updateSigh:

; 1861 : 	{
; 1862 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jl	SHORT $LN89@updateSigh
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN89@updateSigh
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	mov	edi, eax
	jmp	SHORT $LN90@updateSigh
$LN89@updateSigh:
	xor	edi, edi
$LN90@updateSigh:

; 1863 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [ebx+24]
	sub	esi, eax
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR [ebx+28]
	jae	SHORT $LN101@updateSigh
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN100@updateSigh
$LN101@updateSigh:
	xor	esi, esi
$LN100@updateSigh:

; 1864 : 
; 1865 : 		if(pLoopUnit)

	test	edi, edi
	je	SHORT $LN123@updateSigh

; 1866 : 		{
; 1867 : 			if (pLoopUnit->canChangeVisibility())

	mov	ecx, edi
	call	?canChangeVisibility@CvUnit@@QBE_NXZ	; CvUnit::canChangeVisibility
	test	al, al
	je	SHORT $LN123@updateSigh

; 1868 : 				changeAdjacentSight(pLoopUnit->getTeam(), pLoopUnit->visibilityRange(), bIncrement, pLoopUnit->getSeeInvisibleType(), pLoopUnit->getFacingDirection(true));

	push	1
	push	1
	mov	ecx, edi
	call	?getFacingDirection@CvUnit@@QBE?AW4DirectionTypes@@_N@Z ; CvUnit::getFacingDirection
	push	eax
	mov	ecx, edi
	call	?getSeeInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getSeeInvisibleType
	mov	ecx, DWORD PTR _bIncrement$[esp+24]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?visibilityRange@CvUnit@@QBEHXZ		; CvUnit::visibilityRange
	push	eax
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, ebx
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN123@updateSigh:

; 1858 : 
; 1859 : 	// Unit
; 1860 : 	while(pUnitNode != NULL)

	test	esi, esi
	jne	$LL12@updateSigh
$LN11@updateSigh:

; 1869 : 		}
; 1870 : 	}
; 1871 : 
; 1872 : 	if(getReconCount() > 0)

	cmp	BYTE PTR [ebx+456], 0
	jle	$LN5@updateSigh

; 1873 : 	{
; 1874 : 		int iRange = GC.getRECON_VISIBILITY_RANGE();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6192
	xor	edi, edi
	npad	6
$LL7@updateSigh:

; 1876 : 		{
; 1877 : 			for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+24]
	lea	ecx, DWORD PTR [edi+edx]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN6@updateSigh
	npad	5
$LL4@updateSigh:

; 1878 : 			{
; 1879 : 				if(pLoopUnit->getReconPlot() == this && pLoopUnit->canChangeVisibility())

	mov	ecx, esi
	call	?getReconPlot@CvUnit@@QBEPAVCvPlot@@XZ	; CvUnit::getReconPlot
	cmp	eax, ebx
	jne	SHORT $LN3@updateSigh
	mov	ecx, esi
	call	?canChangeVisibility@CvUnit@@QBE_NXZ	; CvUnit::canChangeVisibility
	test	al, al
	je	SHORT $LN3@updateSigh

; 1880 : 				{
; 1881 : 					changeAdjacentSight(pLoopUnit->getTeam(), iRange, bIncrement, pLoopUnit->getSeeInvisibleType(), pLoopUnit->getFacingDirection(true));

	push	1
	push	1
	mov	ecx, esi
	call	?getFacingDirection@CvUnit@@QBE?AW4DirectionTypes@@_N@Z ; CvUnit::getFacingDirection
	push	eax
	mov	ecx, esi
	call	?getSeeInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getSeeInvisibleType
	mov	ecx, DWORD PTR _bIncrement$[esp+24]
	push	eax
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, ebx
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN3@updateSigh:
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+24]
	lea	ecx, DWORD PTR [edi+edx]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL4@updateSigh
$LN6@updateSigh:

; 1875 : 		for(iI = 0; iI < MAX_PLAYERS; ++iI)

	add	edi, 63236				; 0000f704H
	cmp	edi, 4047104				; 003dc100H
	jl	$LL7@updateSigh
$LN5@updateSigh:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1882 : 				}
; 1883 : 			}
; 1884 : 		}
; 1885 : 	}
; 1886 : }

	pop	ecx
	ret	4
?updateSight@CvPlot@@QAEX_N@Z ENDP			; CvPlot::updateSight
_TEXT	ENDS
PUBLIC	?updateSeeFromSight@CvPlot@@QAEX_N@Z		; CvPlot::updateSeeFromSight
EXTRN	?GetVisibilityChange@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetVisibilityChange
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?updateSeeFromSight@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv301 = -16						; size = 4
_iRange$ = -16						; size = 4
tv209 = -12						; size = 4
$T258195 = -12						; size = 4
$T258194 = -12						; size = 4
_this$ = -8						; size = 4
tv205 = -4						; size = 4
_bIncrement$ = 8					; size = 1
?updateSeeFromSight@CvPlot@@QAEX_N@Z PROC		; CvPlot::updateSeeFromSight, COMDAT
; _this$ = ecx

; 1891 : {

	sub	esp, 16					; 00000010H
	push	ebp
	push	esi
	push	edi

; 1892 : 	CvPlot* pLoopPlot;
; 1893 : 	int iDX, iDY;
; 1894 : 
; 1895 : 	int iRange = GC.getUNIT_VISIBILITY_RANGE() + 1;

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6200
	mov	DWORD PTR _this$[esp+28], ecx
	inc	edi

; 1896 : #ifdef AUI_WARNING_FIXES
; 1897 : 	for (uint iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); ++iPromotion)
; 1898 : #else
; 1899 : 	for(int iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); ++iPromotion)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iRange$[esp+28], edi
	xor	esi, esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	test	eax, eax
	jle	SHORT $LN9@updateSeeF
$LL11@updateSeeF:

; 1900 : #endif
; 1901 : 	{
; 1902 : 		const PromotionTypes ePromotion = static_cast<PromotionTypes>(iPromotion);
; 1903 : 		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo

; 1904 : 		if(pkPromotionInfo)

	test	eax, eax
	je	SHORT $LN10@updateSeeF

; 1905 : 		{
; 1906 : 			iRange += pkPromotionInfo->GetVisibilityChange();

	mov	ecx, eax
	call	?GetVisibilityChange@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetVisibilityChange
	add	edi, eax
$LN10@updateSeeF:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jl	SHORT $LL11@updateSeeF
	mov	DWORD PTR _iRange$[esp+28], edi
$LN9@updateSeeF:

; 1907 : 		}
; 1908 : 	}
; 1909 : 
; 1910 : #ifdef NQM_FAST_COMP
; 1911 : 	iRange = MAX(GC.getRECON_VISIBILITY_RANGE() + 1, iRange);
; 1912 : #ifndef AUI_PLOT_SEE_FROM_SIGHT_NO_MAXIMUM_SIGHT_RANGE
; 1913 : 	iRange = MIN(8, iRange); // I don't care, I'm not looking more than 8 out, deal
; 1914 : #endif
; 1915 : #else
; 1916 : 	iRange = std::max(GC.getRECON_VISIBILITY_RANGE() + 1, iRange);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6192
	inc	eax
	mov	DWORD PTR $T258194[esp+28], eax
	cmp	eax, edi
	lea	eax, DWORD PTR _iRange$[esp+28]
	jl	SHORT $LN21@updateSeeF
	lea	eax, DWORD PTR $T258194[esp+28]
$LN21@updateSeeF:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iRange$[esp+28], eax

; 1917 : #ifndef AUI_PLOT_SEE_FROM_SIGHT_NO_MAXIMUM_SIGHT_RANGE
; 1918 : 	iRange = std::min(8, iRange); // I don't care, I'm not looking more than 8 out, deal

	cmp	eax, 8
	mov	DWORD PTR $T258195[esp+28], 8
	lea	eax, DWORD PTR _iRange$[esp+28]
	jl	SHORT $LN25@updateSeeF
	lea	eax, DWORD PTR $T258195[esp+28]
$LN25@updateSeeF:
	mov	ebp, DWORD PTR [eax]

; 1919 : #endif
; 1920 : #endif
; 1921 : 
; 1922 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1923 : 	int iMaxDX;
; 1924 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 1925 : 	{
; 1926 : 		iMaxDX = iRange - MAX(0, iDY);
; 1927 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1928 : 		{
; 1929 : 			pLoopPlot = plotXY(getX(), getY(), iDX, iDY);
; 1930 : #else
; 1931 : 	for(iDX = -iRange; iDX <= iRange; iDX++)

	mov	esi, ebp
	neg	esi
	mov	edi, esi
	cmp	edi, ebp
	mov	DWORD PTR tv205[esp+28], esi
	jg	$LN5@updateSeeF
	mov	edx, edi
	neg	edx
	mov	DWORD PTR tv301[esp+28], edx
	push	ebx
	npad	2
$LL53@updateSeeF:

; 1932 : 	{
; 1933 : 		for(iDY = -iRange; iDY <= iRange; iDY++)

	cmp	esi, ebp
	jg	$LN6@updateSeeF

; 1934 : 		{
; 1935 : 			pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	ebx, esi
	neg	ebx
	mov	DWORD PTR tv209[esp+32], eax
$LL52@updateSeeF:
	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv209[esp+32], ecx
	mov	ecx, edi
	jne	SHORT $LN32@updateSeeF
	test	edi, edi
	jge	SHORT $LN36@updateSeeF
	mov	ecx, edx
$LN36@updateSeeF:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN38@updateSeeF
	mov	eax, ebx
$LN38@updateSeeF:
	add	eax, ecx
	jmp	SHORT $LN43@updateSeeF
$LN32@updateSeeF:
	test	edi, edi
	jge	SHORT $LN40@updateSeeF
	mov	ecx, edx
$LN40@updateSeeF:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN42@updateSeeF
	mov	eax, ebx
$LN42@updateSeeF:
	cmp	ecx, eax
	jl	SHORT $LN43@updateSeeF
	mov	eax, ecx
$LN43@updateSeeF:
	cmp	eax, ebp
	jg	SHORT $LN3@updateSeeF
	mov	eax, DWORD PTR _this$[esp+32]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	esi
	push	edi
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 1936 : #endif
; 1937 : 
; 1938 : 			if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN51@updateSeeF

; 1939 : 			{
; 1940 : 				pLoopPlot->updateSight(bIncrement);

	mov	ecx, DWORD PTR _bIncrement$[esp+28]
	push	ecx
	mov	ecx, eax
	call	?updateSight@CvPlot@@QAEX_N@Z		; CvPlot::updateSight
$LN51@updateSeeF:
	mov	edx, DWORD PTR tv301[esp+32]
$LN3@updateSeeF:

; 1932 : 	{
; 1933 : 		for(iDY = -iRange; iDY <= iRange; iDY++)

	inc	esi
	dec	ebx
	cmp	esi, ebp
	jle	SHORT $LL52@updateSeeF
	mov	esi, DWORD PTR tv205[esp+32]
$LN6@updateSeeF:

; 1919 : #endif
; 1920 : #endif
; 1921 : 
; 1922 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1923 : 	int iMaxDX;
; 1924 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 1925 : 	{
; 1926 : 		iMaxDX = iRange - MAX(0, iDY);
; 1927 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1928 : 		{
; 1929 : 			pLoopPlot = plotXY(getX(), getY(), iDX, iDY);
; 1930 : #else
; 1931 : 	for(iDX = -iRange; iDX <= iRange; iDX++)

	inc	edi
	dec	edx
	cmp	edi, ebp
	mov	DWORD PTR tv301[esp+32], edx
	jle	$LL53@updateSeeF
	pop	ebx
$LN5@updateSeeF:
	pop	edi
	pop	esi
	pop	ebp

; 1941 : 			}
; 1942 : 		}
; 1943 : 	}
; 1944 : }

	add	esp, 16					; 00000010H
	ret	4
?updateSeeFromSight@CvPlot@@QAEX_N@Z ENDP		; CvPlot::updateSeeFromSight
_TEXT	ENDS
PUBLIC	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z	; CvPlot::setOwner
EXTRN	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z:PROC ; CvGlobals::WrapPlotPointer
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z:PROC ; CvGlobals::UnwrapCityPointer
EXTRN	?SetCityDistanceHighwaterMark@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::SetCityDistanceHighwaterMark
EXTRN	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetCityDistanceHighwaterMark
EXTRN	?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z:PROC ; CvBarbarians::DoBarbCampCleared
EXTRN	?doGoody@CvPlayer@@QAEXPAVCvPlot@@PAVCvUnit@@@Z:PROC ; CvPlayer::doGoody
EXTRN	?changeTotalLand@CvTeam@@QAEXH@Z:PROC		; CvTeam::changeTotalLand
EXTRN	?changeTotalLand@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::changeTotalLand
EXTRN	?changeOwnedPlots@CvMap@@QAEXH@Z:PROC		; CvMap::changeOwnedPlots
EXTRN	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z:PROC ; CvGame::addReplayMessage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
_TEXT	SEGMENT
_bestHighWaterMark$224757 = -88				; size = 4
_newPlayer$224722 = -84					; size = 4
tv3527 = -80						; size = 4
tv3539 = -76						; size = 4
_pOldCity$ = -76					; size = 4
tv2830 = -72						; size = 4
_pDllPlot$224841 = -72					; size = 4
$T258271 = -68						; size = 28
_strBuffer$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pDllPlot$224873 = 8					; size = 4
_pDllPlot$224869 = 8					; size = 4
$T258282 = 8						; size = 4
_eNewValue$ = 8						; size = 4
_pHeadSelectedCity$224828 = 12				; size = 4
_iMaxCityHighWaterMark$224755 = 12			; size = 4
_iAcquiringCityID$ = 12					; size = 4
$T258286 = 16						; size = 4
$T258284 = 16						; size = 4
_bCheckUnits$ = 16					; size = 1
___formal$ = 20						; size = 1
?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z PROC	; CvPlot::setOwner, COMDAT
; _this$ = ecx

; 5176 : {

	push	-1
	push	__ehhandler$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	mov	esi, ecx

; 5177 : 	IDInfo* pUnitNode;
; 5178 : 	CvCity* pOldCity;
; 5179 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5180 : 	int iI;
; 5181 : 
; 5182 : 	// Remove effects for old owner before changing the member
; 5183 : 	if(getOwner() != eNewValue)

	movsx	ebx, BYTE PTR [esi+4]
	mov	DWORD PTR __$EHRec$[esp+104], 0
	cmp	ebx, DWORD PTR _eNewValue$[esp+92]
	je	$LN837@setOwner
	push	ebp
	push	edi

; 5184 : 	{
; 5185 : 		PlayerTypes eOldOwner = getOwner();;
; 5186 : 
; 5187 : 		GC.getGame().addReplayMessage(REPLAY_MESSAGE_PLOT_OWNER_CHANGE, eNewValue, "", getX(), getY());

	push	OFFSET $SG224681
	lea	ecx, DWORD PTR $T258271[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR _eNewValue$[esp+104]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	edx, DWORD PTR $T258271[esp+112]
	push	edx
	push	eax
	push	2
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
	lea	ecx, DWORD PTR $T258271[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5188 : 
; 5189 : 		pOldCity = getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN129@setOwner
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN129@setOwner
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebp, eax
	mov	DWORD PTR _pOldCity$[esp+104], eax
	jmp	SHORT $LN130@setOwner
$LN129@setOwner:
	xor	ebp, ebp
	mov	DWORD PTR _pOldCity$[esp+104], ebp
$LN130@setOwner:

; 5190 : 
; 5191 : 		{
; 5192 : 			setOwnershipDuration(0);

	push	0
	mov	ecx, esi
	call	?setOwnershipDuration@CvPlot@@QAEXH@Z	; CvPlot::setOwnershipDuration

; 5193 : 
; 5194 : 			// Plot was owned by someone else
; 5195 : 			if(isOwned())

	mov	al, BYTE PTR [esi+4]
	cmp	al, -1
	je	$LN85@setOwner

; 5196 : 			{
; 5197 : 				changeAdjacentSight(getTeam(), GC.getPLOT_VISIBILITY_RANGE(), false, NO_INVISIBLE, NO_DIRECTION, false);

	movsx	eax, al
	cmp	eax, -1
	je	SHORT $LN141@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN141@setOwner
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN140@setOwner
$LN141@setOwner:
	or	eax, -1
$LN140@setOwner:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	push	0
	push	-1
	push	-1
	push	0
	push	edx
	push	eax
	mov	ecx, esi
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight

; 5198 : 
; 5199 : 				// if this tile is owned by a minor share the visibility with my ally
; 5200 : 				if(pOldCity)

	test	ebp, ebp
	je	SHORT $LN81@setOwner

; 5201 : 				{
; 5202 : 					for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	edi, edi
$LL83@setOwner:

; 5203 : 					{
; 5204 : 						PlayerTypes ePlayer = (PlayerTypes)ui;
; 5205 : 						if(GET_PLAYER(ePlayer).GetEspionage()->HasEstablishedSurveillanceInCity(pOldCity))

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	push	ebp
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
	test	al, al
	je	SHORT $LN82@setOwner

; 5206 : 						{
; 5207 : 							changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), false, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN163@setOwner
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN164@setOwner
$LN163@setOwner:
	or	eax, -1
$LN164@setOwner:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	push	0
	push	-1
	push	-1
	push	0
	push	edx
	push	eax
	mov	ecx, esi
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN82@setOwner:
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jb	SHORT $LL83@setOwner
$LN81@setOwner:

; 5208 : 						}
; 5209 : 					}
; 5210 : 				}
; 5211 : 
; 5212 : 				if(eOldOwner >= MAX_MAJOR_CIVS && eOldOwner != BARBARIAN_PLAYER)

	cmp	ebx, 22					; 00000016H
	jl	SHORT $LN78@setOwner
	cmp	ebx, 63					; 0000003fH
	je	SHORT $LN78@setOwner

; 5213 : 				{
; 5214 : 					CvPlayer& thisPlayer = GET_PLAYER(eOldOwner);

	mov	ecx, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5215 : 					CvMinorCivAI* pMinorCivAI = thisPlayer.GetMinorCivAI();

	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	edi, eax

; 5216 : 					if(pMinorCivAI && pMinorCivAI->GetAlly() != NO_PLAYER)

	test	edi, edi
	je	SHORT $LN78@setOwner
	mov	ecx, edi
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	je	SHORT $LN78@setOwner

; 5217 : 					{
; 5218 : 						changeAdjacentSight(GET_PLAYER(pMinorCivAI->GetAlly()).getTeam(), GC.getPLOT_VISIBILITY_RANGE(), false, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	ecx, edi
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	ecx, eax
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	-1
	push	-1
	push	0
	push	ebp
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, esi
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN78@setOwner:

; 5219 : 					}
; 5220 : 				}
; 5221 : 
; 5222 : 				if(area())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN869@setOwner

; 5223 : 				{
; 5224 : 					area()->changeNumOwnedTiles(-1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumOwnedTiles@CvArea@@QAEXH@Z	; CvArea::changeNumOwnedTiles
$LN869@setOwner:

; 5225 : 				}
; 5226 : 				GC.getMap().changeOwnedPlots(-1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	call	?changeOwnedPlots@CvMap@@QAEXH@Z	; CvMap::changeOwnedPlots

; 5227 : 
; 5228 : 				if(!isWater())

	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN75@setOwner

; 5229 : 				{
; 5230 : 					GET_PLAYER(getOwner()).changeTotalLand(-1);

	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	call	?changeTotalLand@CvPlayer@@QAEXH@Z	; CvPlayer::changeTotalLand

; 5231 : 					GET_TEAM(getTeam()).changeTotalLand(-1);

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN195@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN202@setOwner
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN194@setOwner
$LN202@setOwner:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN194@setOwner
$LN195@setOwner:
	or	ecx, -1
$LN194@setOwner:
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	-1
	call	?changeTotalLand@CvTeam@@QAEXH@Z	; CvTeam::changeTotalLand

; 5232 : 
; 5233 : 					if(isOwnershipScore())

	movsx	eax, WORD PTR [esi+380]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6252
	jl	SHORT $LN75@setOwner

; 5234 : 					{
; 5235 : 						GET_PLAYER(getOwner()).changeTotalLandScored(-1);

	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	call	?changeTotalLandScored@CvPlayer@@QAEXH@Z ; CvPlayer::changeTotalLandScored
$LN75@setOwner:

; 5236 : 					}
; 5237 : 				}
; 5238 : 
; 5239 : 				// Improvement is here
; 5240 : 				if(getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	$LN870@setOwner

; 5241 : 				{
; 5242 : 					GET_PLAYER(getOwner()).changeImprovementCount(getImprovementType(), -1);

	movsx	ecx, al
	push	-1
	push	ecx
	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 5243 : 
; 5244 : 					// Remove siphoned resources
; 5245 : 					CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(getImprovementType());

	movsx	eax, BYTE PTR [esi+441]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	edi, eax

; 5246 : 					if (pImprovementInfo != NULL && pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor() > 0)

	test	edi, edi
	je	SHORT $LN71@setOwner
	mov	ecx, edi
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN71@setOwner

; 5247 : 					{
; 5248 : 						if (GetPlayerThatBuiltImprovement() != NO_PLAYER)

	cmp	BYTE PTR [esi+443], -1
	je	SHORT $LN71@setOwner

; 5249 : 						{
; 5250 : 							if (GET_PLAYER(eOldOwner).isMinorCiv())

	mov	ecx, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN71@setOwner

; 5251 : 							{
; 5252 : 								GET_PLAYER(GetPlayerThatBuiltImprovement()).changeSiphonLuxuryCount(eOldOwner, -1 * pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor());

	movsx	eax, BYTE PTR [esi+443]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, edi
	mov	ebp, eax
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	neg	eax
	push	eax
	push	ebx
	mov	ecx, ebp
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN71@setOwner:

; 5253 : 							}
; 5254 : 						}
; 5255 : 					}
; 5256 : 
; 5257 : 					// Maintenance change!
; 5258 : 					if(MustPayMaintenanceHere(getOwner()))

	cmp	BYTE PTR [esi+5], 1
	movsx	eax, BYTE PTR [esi+4]
	jne	SHORT $LN239@setOwner
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN870@setOwner
$LN239@setOwner:

; 5259 : 					{
; 5260 : #ifdef AUI_WARNING_FIXES
; 5261 : 						if (pImprovementInfo)
; 5262 : 							GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pImprovementInfo->GetGoldMaintenance());
; 5263 : #else
; 5264 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	movsx	eax, BYTE PTR [esi+4]
	movsx	ecx, BYTE PTR [esi+441]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN870@setOwner:

; 5265 : #endif
; 5266 : 					}
; 5267 : 				}
; 5268 : 
; 5269 : 				// Route is here
; 5270 : 				if(getRouteType() != NO_ROUTE && !isCity())

	cmp	BYTE PTR [esi+447], -1
	je	$LN68@setOwner
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN855@setOwner
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN855@setOwner
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN68@setOwner
$LN855@setOwner:

; 5271 : 				{
; 5272 : 					// Maintenance change!
; 5273 : 					if(MustPayMaintenanceHere(getOwner()))

	cmp	BYTE PTR [esi+5], 1
	movsx	eax, BYTE PTR [esi+4]
	jne	SHORT $LN263@setOwner
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN68@setOwner
$LN263@setOwner:

; 5274 : 					{
; 5275 : #ifdef AUI_WARNING_FIXES
; 5276 : 						CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 5277 : 						if (pRouteInfo)
; 5278 : 							GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pRouteInfo->GetGoldMaintenance());
; 5279 : #else
; 5280 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	movsx	eax, BYTE PTR [esi+4]
	movsx	ecx, BYTE PTR [esi+447]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN68@setOwner:

; 5281 : #endif
; 5282 : 					}
; 5283 : 				}
; 5284 : 
; 5285 : 				// Remove Resource Quantity from total
; 5286 : 				if(getResourceType() != NO_RESOURCE)

	movsx	eax, BYTE PTR [esi+440]
	cmp	eax, -1
	je	$LN861@setOwner

; 5287 : 				{
; 5288 : 					// Disconnect resource link
; 5289 : 					if(GetResourceLinkedCity() != NULL)

	mov	eax, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [esi+128]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN66@setOwner

; 5290 : 					{
; 5291 : 						SetResourceLinkedCity(NULL);

	push	0
	mov	ecx, esi
	call	?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::SetResourceLinkedCity
$LN66@setOwner:

; 5292 : 					}
; 5293 : 
; 5294 : 					if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	movsx	eax, BYTE PTR [esi+4]
	movsx	ecx, BYTE PTR [esi+440]
	cmp	eax, -1
	je	SHORT $LN315@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN315@setOwner
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN314@setOwner
$LN315@setOwner:
	or	eax, -1
$LN314@setOwner:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, edi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN861@setOwner

; 5295 : 					{
; 5296 : 						if(getImprovementType() != NO_IMPROVEMENT && GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	$LN861@setOwner
	movsx	ecx, BYTE PTR [esi+440]
	movsx	eax, al
	push	ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	$LN861@setOwner

; 5297 : 						{
; 5298 : 							if(!IsImprovementPillaged())

	test	BYTE PTR [esi+461], 1
	jne	$LN861@setOwner

; 5299 : 							{
; 5300 : 								GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), -getNumResourceForPlayer(getOwner()));

	movsx	eax, BYTE PTR [esi+4]
	movsx	ebp, BYTE PTR [esi+440]
	mov	edi, eax
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	mov	ecx, esi
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	neg	eax
	push	eax
	push	ebp
	mov	ecx, edi
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 5301 : 							}
; 5302 : 						}
; 5303 : 					}
; 5304 : 				}
; 5305 : 			}
; 5306 : 			// Plot is unowned
; 5307 : 			else

	jmp	$LN861@setOwner
$LN85@setOwner:

; 5308 : 			{
; 5309 : 				// Someone paying for this improvement
; 5310 : 				if(GetPlayerResponsibleForImprovement() != NO_PLAYER)

	mov	al, BYTE PTR [esi+444]
	cmp	al, -1
	je	SHORT $LN385@setOwner

; 5311 : 				{
; 5312 : 					if(MustPayMaintenanceHere(GetPlayerResponsibleForImprovement()))

	movsx	eax, al
	push	eax
	mov	ecx, esi
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN60@setOwner

; 5313 : 					{
; 5314 : 						GET_PLAYER(GetPlayerResponsibleForImprovement()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	movsx	eax, BYTE PTR [esi+444]
	movsx	ecx, BYTE PTR [esi+441]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN60@setOwner:

; 5315 : 					}
; 5316 : 					SetPlayerResponsibleForImprovement(NO_PLAYER);

	cmp	BYTE PTR [esi+444], -1
	je	SHORT $LN385@setOwner
	mov	BYTE PTR [esi+444], -1
$LN385@setOwner:

; 5317 : 				}
; 5318 : 				// Someone paying for this Route
; 5319 : 				if(GetPlayerResponsibleForRoute() != NO_PLAYER)

	mov	al, BYTE PTR [esi+445]
	cmp	al, -1
	je	SHORT $LN861@setOwner

; 5320 : 				{
; 5321 : 					if(MustPayMaintenanceHere(GetPlayerResponsibleForRoute()))

	movsx	eax, al
	push	eax
	mov	ecx, esi
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN58@setOwner

; 5322 : 					{
; 5323 : 						GET_PLAYER(GetPlayerResponsibleForRoute()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	movsx	eax, BYTE PTR [esi+445]
	movsx	ecx, BYTE PTR [esi+447]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN58@setOwner:

; 5324 : 					}
; 5325 : 					SetPlayerResponsibleForRoute(NO_PLAYER);

	cmp	BYTE PTR [esi+445], -1
	je	SHORT $LN861@setOwner
	mov	BYTE PTR [esi+445], -1
$LN861@setOwner:

; 5326 : 				}
; 5327 : 			}
; 5328 : 
; 5329 : 			// This plot is ABOUT TO BE owned. Pop Goody Huts/remove barb camps, etc. Otherwise it will try to reduce the # of Improvements we have in our borders, and these guys shouldn't apply to that count
; 5330 : 			if(eNewValue != NO_PLAYER)

	mov	ebx, DWORD PTR _eNewValue$[esp+100]
	or	edi, -1
	cmp	ebx, edi
	je	SHORT $LN425@setOwner

; 5331 : 			{
; 5332 : 				// Pop Goody Huts here
; 5333 : 				if(isGoody())

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	SHORT $LN56@setOwner
	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	test	al, al
	je	SHORT $LN56@setOwner

; 5334 : 				{
; 5335 : 					GET_PLAYER(eNewValue).doGoody(this, NULL);

	mov	ecx, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	esi
	call	?doGoody@CvPlayer@@QAEXPAVCvPlot@@PAVCvUnit@@@Z ; CvPlayer::doGoody
$LN56@setOwner:

; 5336 : 				}
; 5337 : 
; 5338 : 				// If there's a camp here, clear it
; 5339 : 				if(getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	movsx	eax, BYTE PTR [esi+441]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	jne	SHORT $LN425@setOwner

; 5340 : 				{
; 5341 : 					setImprovementType(NO_IMPROVEMENT);

	push	edi
	push	edi
	mov	ecx, esi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 5342 : 					CvBarbarians::DoBarbCampCleared(this, eNewValue);

	push	ebx
	push	esi
	call	?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z ; CvBarbarians::DoBarbCampCleared
	add	esp, 8

; 5343 : 					SetPlayerThatClearedBarbCampHere(eNewValue);

	mov	BYTE PTR [esi+446], bl
$LN425@setOwner:

; 5344 : 
; 5345 : 					// Don't give gold for Camps cleared by settling
; 5346 : 				}
; 5347 : 			}
; 5348 : 
; 5349 : 			pUnitNode = headUnitNode();
; 5350 : 
; 5351 : 			// ACTUALLY CHANGE OWNERSHIP HERE
; 5352 : 			m_eOwner = eNewValue;
; 5353 : 
; 5354 : 			setWorkingCityOverride(NULL);

	mov	ecx, DWORD PTR [esi+124]
	mov	edx, DWORD PTR [esi+120]
	push	ecx
	push	edx
	mov	BYTE PTR [esi+4], bl
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN439@setOwner
	mov	ecx, esi
	mov	DWORD PTR [esi+120], edi
	mov	DWORD PTR [esi+124], edi
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity
$LN439@setOwner:

; 5355 : 			updateWorkingCity();

	mov	ecx, esi
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity

; 5356 : 
; 5357 : 			// Post ownership switch
; 5358 : 
; 5359 : 			if(isOwned())

	mov	cl, BYTE PTR [esi+4]
	cmp	cl, -1
	je	$LN735@setOwner

; 5360 : 			{
; 5361 : 				CvPlayerAI& newPlayer = GET_PLAYER(eNewValue);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebx, 63236				; 0000f704H
	lea	edx, DWORD PTR [ebx+eax]

; 5362 : 				if(iAcquiringCityID >= 0)

	mov	eax, DWORD PTR _iAcquiringCityID$[esp+100]
	mov	DWORD PTR _newPlayer$224722[esp+104], edx
	test	eax, eax
	jl	SHORT $LN53@setOwner

; 5363 : 				{
; 5364 : 					m_purchaseCity.eOwner = eNewValue;

	mov	edx, DWORD PTR _eNewValue$[esp+100]
	mov	DWORD PTR [esi+136], edx

; 5365 : 					m_purchaseCity.iID = iAcquiringCityID;
; 5366 : 				}
; 5367 : 				else

	jmp	SHORT $LN876@setOwner
$LN53@setOwner:

; 5368 : 				{
; 5369 : 					m_purchaseCity.eOwner = NO_PLAYER;

	or	eax, -1
	mov	DWORD PTR [esi+136], eax
$LN876@setOwner:

; 5370 : 					m_purchaseCity.iID = -1;

	mov	DWORD PTR [esi+140], eax

; 5371 : 				}
; 5372 : 
; 5373 : 				changeAdjacentSight(getTeam(), GC.getPLOT_VISIBILITY_RANGE(), true, NO_INVISIBLE, NO_DIRECTION, false);

	movsx	eax, cl
	cmp	eax, -1
	je	SHORT $LN455@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN455@setOwner
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN454@setOwner
$LN455@setOwner:
	or	eax, -1
$LN454@setOwner:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	push	0
	push	-1
	push	-1
	push	1
	push	ecx
	push	eax
	mov	ecx, esi
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight

; 5374 : 
; 5375 : 				// if this tile is owned by a minor share the visibility with my ally
; 5376 : 				if(pOldCity)

	mov	ebp, DWORD PTR _pOldCity$[esp+104]
	test	ebp, ebp
	je	SHORT $LN48@setOwner

; 5377 : 				{
; 5378 : 					for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	edi, edi
$LL50@setOwner:

; 5379 : 					{
; 5380 : 						PlayerTypes ePlayer = (PlayerTypes)ui;
; 5381 : 						if(GET_PLAYER(ePlayer).GetEspionage()->HasEstablishedSurveillanceInCity(pOldCity))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	push	ebp
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
	test	al, al
	je	SHORT $LN49@setOwner

; 5382 : 						{
; 5383 : 							changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), true, NO_INVISIBLE, NO_DIRECTION, false);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN477@setOwner
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN478@setOwner
$LN477@setOwner:
	or	eax, -1
$LN478@setOwner:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	push	0
	push	-1
	push	-1
	push	1
	push	ecx
	push	eax
	mov	ecx, esi
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN49@setOwner:
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jb	SHORT $LL50@setOwner
$LN48@setOwner:

; 5384 : 						}
; 5385 : 					}
; 5386 : 				}
; 5387 : 
; 5388 : 				if(eNewValue >= MAX_MAJOR_CIVS && eNewValue != BARBARIAN_PLAYER)

	mov	eax, DWORD PTR _eNewValue$[esp+100]
	cmp	eax, 22					; 00000016H
	jl	SHORT $LN45@setOwner
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN45@setOwner

; 5389 : 				{
; 5390 : 					CvPlayer& thisPlayer = GET_PLAYER(eNewValue);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]

; 5391 : 					CvMinorCivAI* pMinorCivAI = thisPlayer.GetMinorCivAI();

	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	edi, eax

; 5392 : 					if(pMinorCivAI && pMinorCivAI->GetAlly() != NO_PLAYER)

	test	edi, edi
	je	SHORT $LN45@setOwner
	mov	ecx, edi
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	je	SHORT $LN45@setOwner

; 5393 : 					{
; 5394 : 						changeAdjacentSight(GET_PLAYER(pMinorCivAI->GetAlly()).getTeam(), GC.getPLOT_VISIBILITY_RANGE(), true, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	ecx, edi
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN492@setOwner
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN493@setOwner
$LN492@setOwner:
	or	eax, -1
$LN493@setOwner:
	push	0
	push	-1
	push	-1
	push	1
	push	ebp
	push	eax
	mov	ecx, esi
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN45@setOwner:

; 5395 : 					}
; 5396 : 				}
; 5397 : 
; 5398 : 				if(area())

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN866@setOwner

; 5399 : 				{
; 5400 : 					area()->changeNumOwnedTiles(1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?changeNumOwnedTiles@CvArea@@QAEXH@Z	; CvArea::changeNumOwnedTiles
$LN866@setOwner:

; 5401 : 				}
; 5402 : 				GC.getMap().changeOwnedPlots(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	call	?changeOwnedPlots@CvMap@@QAEXH@Z	; CvMap::changeOwnedPlots

; 5403 : 
; 5404 : 				if(!isWater())

	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN867@setOwner

; 5405 : 				{
; 5406 : 					GET_PLAYER(getOwner()).changeTotalLand(1);

	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	call	?changeTotalLand@CvPlayer@@QAEXH@Z	; CvPlayer::changeTotalLand

; 5407 : 					GET_TEAM(getTeam()).changeTotalLand(1);

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN518@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN525@setOwner
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN517@setOwner
$LN525@setOwner:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN517@setOwner
$LN518@setOwner:
	or	ecx, -1
$LN517@setOwner:
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	1
	call	?changeTotalLand@CvTeam@@QAEXH@Z	; CvTeam::changeTotalLand

; 5408 : 
; 5409 : 					if(isOwnershipScore())

	movsx	edx, WORD PTR [esi+380]
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6252
	jl	SHORT $LN867@setOwner

; 5410 : 					{
; 5411 : 						GET_PLAYER(getOwner()).changeTotalLandScored(1);

	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	call	?changeTotalLandScored@CvPlayer@@QAEXH@Z ; CvPlayer::changeTotalLandScored
$LN867@setOwner:

; 5412 : 					}
; 5413 : 				}
; 5414 : 
; 5415 : 				// Improvement is here
; 5416 : 				if(getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	$LN862@setOwner

; 5417 : 				{
; 5418 : 					GET_PLAYER(eNewValue).changeImprovementCount(getImprovementType(), 1);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	movsx	eax, al
	push	1
	push	eax
	add	ecx, ebx
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 5419 : 
; 5420 : 					// Add siphoned resources
; 5421 : 					CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(getImprovementType());

	movsx	eax, BYTE PTR [esi+441]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	edi, eax

; 5422 : 					if (pImprovementInfo != NULL && pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor() > 0)

	test	edi, edi
	je	SHORT $LN38@setOwner
	mov	ecx, edi
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN38@setOwner

; 5423 : 					{
; 5424 : 						if (GetPlayerThatBuiltImprovement() != NO_PLAYER)

	cmp	BYTE PTR [esi+443], -1
	je	SHORT $LN38@setOwner

; 5425 : 						{
; 5426 : 							if (GET_PLAYER(eNewValue).isMinorCiv())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN38@setOwner

; 5427 : 							{
; 5428 : 								GET_PLAYER(GetPlayerThatBuiltImprovement()).changeSiphonLuxuryCount(eNewValue, pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor());

	movsx	eax, BYTE PTR [esi+443]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, edi
	mov	ebp, eax
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	push	eax
	mov	eax, DWORD PTR _eNewValue$[esp+104]
	push	eax
	mov	ecx, ebp
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN38@setOwner:

; 5429 : 							}
; 5430 : 						}
; 5431 : 					}
; 5432 : 
; 5433 : 					// Maintenance change!
; 5434 : 					if(MustPayMaintenanceHere(eNewValue))

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN558@setOwner
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebx
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN862@setOwner
$LN558@setOwner:

; 5435 : 					{
; 5436 : #ifdef AUI_WARNING_FIXES
; 5437 : 						if (pImprovementInfo)
; 5438 : 							GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(pImprovementInfo->GetGoldMaintenance());
; 5439 : #else
; 5440 : 						GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	movsx	eax, BYTE PTR [esi+441]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	lea	edi, DWORD PTR [ebx+edx]
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN862@setOwner:

; 5441 : #endif
; 5442 : 					}
; 5443 : 				}
; 5444 : 
; 5445 : 				// Route is here
; 5446 : 				if(getRouteType() != NO_ROUTE && !isCity())

	cmp	BYTE PTR [esi+447], -1
	je	$LN872@setOwner
	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN858@setOwner
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN858@setOwner
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN872@setOwner
$LN858@setOwner:

; 5447 : 				{
; 5448 : 					// Maintenance change!
; 5449 : 					if(MustPayMaintenanceHere(eNewValue))

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN578@setOwner
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ebx+edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN872@setOwner
$LN578@setOwner:

; 5450 : 					{
; 5451 : #ifdef AUI_WARNING_FIXES
; 5452 : 						CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 5453 : 						if (pRouteInfo)
; 5454 : 							GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(pRouteInfo->GetGoldMaintenance());
; 5455 : #else
; 5456 : 						GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	movsx	eax, BYTE PTR [esi+447]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edi, DWORD PTR [ebx+ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, edi
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN872@setOwner:

; 5457 : #endif
; 5458 : 					}
; 5459 : 				}
; 5460 : 
; 5461 : 				if(getResourceType() != NO_RESOURCE)

	movsx	ecx, BYTE PTR [esi+440]
	cmp	ecx, -1
	je	$LN30@setOwner

; 5462 : 				{
; 5463 : 					// Add Resource Quantity to total
; 5464 : 					if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN626@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN626@setOwner
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN625@setOwner
$LN626@setOwner:
	or	eax, -1
$LN625@setOwner:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, edi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN31@setOwner

; 5465 : 					{
; 5466 : 						if(getImprovementType() != NO_IMPROVEMENT && GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	SHORT $LN31@setOwner
	movsx	ecx, BYTE PTR [esi+440]
	movsx	eax, al
	push	ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	je	SHORT $LN31@setOwner

; 5467 : 						{
; 5468 : 							if(!IsImprovementPillaged())

	test	BYTE PTR [esi+461], 1
	jne	SHORT $LN31@setOwner

; 5469 : 							{
; 5470 : 								GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), getNumResourceForPlayer(getOwner()));

	movsx	eax, BYTE PTR [esi+4]
	movsx	ebp, BYTE PTR [esi+440]
	mov	edi, eax
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	mov	ecx, esi
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	push	eax
	push	ebp
	mov	ecx, edi
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal
$LN31@setOwner:

; 5471 : 							}
; 5472 : 						}
; 5473 : 					}
; 5474 : 
; 5475 : 					// Should we link the Resource here with a City so special Buildings may be constructed?
; 5476 : 					if(GetResourceLinkedCity() == NULL)

	mov	eax, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [esi+128]
	push	eax
	push	ecx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@setOwner

; 5477 : 					{
; 5478 : 						DoFindCityToLinkResourceTo();

	push	eax
	mov	ecx, esi
	call	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo
$LN30@setOwner:

; 5479 : 					}
; 5480 : 				}
; 5481 : 
; 5482 : 				// update the high water mark for player (if human)
; 5483 : 				int iMaxCityHighWaterMark = GC.getMAX_CITY_DIST_HIGHWATER_MARK();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7804

; 5484 : 				if(newPlayer.isHuman() && newPlayer.GetCityDistanceHighwaterMark() < iMaxCityHighWaterMark)

	mov	ecx, DWORD PTR _newPlayer$224722[esp+104]
	mov	DWORD PTR _iMaxCityHighWaterMark$224755[esp+100], ebp
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN735@setOwner
	mov	ecx, DWORD PTR _newPlayer$224722[esp+104]
	call	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ ; CvPlayer::GetCityDistanceHighwaterMark
	cmp	eax, ebp
	jge	$LN735@setOwner

; 5485 : 				{
; 5486 : 					int bestHighWaterMark = newPlayer.GetCityDistanceHighwaterMark();

	mov	ecx, DWORD PTR _newPlayer$224722[esp+104]
	call	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ ; CvPlayer::GetCityDistanceHighwaterMark
	mov	edi, eax

; 5487 : 					for(int iDX = -iMaxCityHighWaterMark; iDX <= iMaxCityHighWaterMark && bestHighWaterMark < iMaxCityHighWaterMark; iDX++)

	mov	eax, ebp
	neg	eax
	mov	ebx, eax
	cmp	ebx, ebp
	mov	DWORD PTR _bestHighWaterMark$224757[esp+104], edi
	mov	DWORD PTR tv2830[esp+104], eax
	jg	$LN26@setOwner
	mov	ecx, ebx
	neg	ecx
	mov	DWORD PTR tv3539[esp+104], ecx
	jmp	SHORT $LN28@setOwner
	npad	8
$LL868@setOwner:

; 5485 : 				{
; 5486 : 					int bestHighWaterMark = newPlayer.GetCityDistanceHighwaterMark();

	mov	eax, DWORD PTR tv2830[esp+104]
	mov	ebp, DWORD PTR _iMaxCityHighWaterMark$224755[esp+100]
$LN28@setOwner:

; 5487 : 					for(int iDX = -iMaxCityHighWaterMark; iDX <= iMaxCityHighWaterMark && bestHighWaterMark < iMaxCityHighWaterMark; iDX++)

	cmp	edi, ebp
	jge	$LN26@setOwner

; 5488 : 					{
; 5489 : 						for(int iDY = -iMaxCityHighWaterMark; iDY <= iMaxCityHighWaterMark && bestHighWaterMark < iMaxCityHighWaterMark; iDY++)

	mov	edi, eax
	cmp	edi, ebp
	jg	$LN27@setOwner
	neg	eax
	mov	DWORD PTR tv3527[esp+104], eax
$LL863@setOwner:
	mov	edx, DWORD PTR _iMaxCityHighWaterMark$224755[esp+100]
	cmp	DWORD PTR _bestHighWaterMark$224757[esp+104], edx
	jge	$LN27@setOwner

; 5490 : 						{
; 5491 : 							int hexRange;
; 5492 : 
; 5493 : 							// I'm assuming iDX and iDY are in hex-space
; 5494 : 							if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	test	edi, edi
	setge	al
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	cmp	ecx, eax

; 5495 : 							{
; 5496 : 								int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, ebx
	jne	SHORT $LN22@setOwner
	test	ebx, ebx
	jge	SHORT $LN90@setOwner
	mov	ecx, DWORD PTR tv3539[esp+104]
$LN90@setOwner:

; 5497 : 								int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN92@setOwner
	mov	eax, DWORD PTR tv3527[esp+104]
$LN92@setOwner:

; 5498 : 								hexRange = iAbsDX + iAbsDY;

	lea	ebp, DWORD PTR [eax+ecx]

; 5499 : 							}
; 5500 : 							else

	jmp	SHORT $LN98@setOwner
$LN22@setOwner:

; 5501 : 							{
; 5502 : 								int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	ebx, ebx
	jge	SHORT $LN94@setOwner
	mov	ecx, DWORD PTR tv3539[esp+104]
$LN94@setOwner:

; 5503 : 								int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN96@setOwner
	mov	eax, DWORD PTR tv3527[esp+104]
$LN96@setOwner:

; 5504 : 								hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	mov	ebp, ecx
	jge	SHORT $LN98@setOwner
	mov	ebp, eax
$LN98@setOwner:

; 5505 : 							}
; 5506 : 
; 5507 : 							if(hexRange > bestHighWaterMark && hexRange <= iMaxCityHighWaterMark)

	cmp	ebp, DWORD PTR _bestHighWaterMark$224757[esp+104]
	jle	SHORT $LN24@setOwner
	cmp	ebp, edx
	jg	SHORT $LN24@setOwner

; 5508 : 							{
; 5509 : 								CvPlot* pLoopPlot = plotXY(getX(), getY(), iDX, iDY);

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edi
	push	ebx
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 5510 : 								if(pLoopPlot)

	test	eax, eax
	je	SHORT $LN24@setOwner

; 5511 : 								{
; 5512 : 									CvCity* thisCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN24@setOwner
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN24@setOwner
	mov	edx, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 5513 : 									if(thisCity)

	test	eax, eax
	je	SHORT $LN24@setOwner

; 5514 : 									{
; 5515 : 										if(thisCity->getOwner() == eNewValue)

	mov	ecx, DWORD PTR _eNewValue$[esp+100]
	cmp	DWORD PTR [eax+84], ecx
	jne	SHORT $LN24@setOwner

; 5516 : 										{
; 5517 : 											bestHighWaterMark = hexRange;

	mov	DWORD PTR _bestHighWaterMark$224757[esp+104], ebp
$LN24@setOwner:

; 5488 : 					{
; 5489 : 						for(int iDY = -iMaxCityHighWaterMark; iDY <= iMaxCityHighWaterMark && bestHighWaterMark < iMaxCityHighWaterMark; iDY++)

	dec	DWORD PTR tv3527[esp+104]
	inc	edi
	cmp	edi, DWORD PTR _iMaxCityHighWaterMark$224755[esp+100]
	jle	$LL863@setOwner
$LN27@setOwner:

; 5487 : 					for(int iDX = -iMaxCityHighWaterMark; iDX <= iMaxCityHighWaterMark && bestHighWaterMark < iMaxCityHighWaterMark; iDX++)

	dec	DWORD PTR tv3539[esp+104]
	mov	edi, DWORD PTR _bestHighWaterMark$224757[esp+104]
	inc	ebx
	cmp	ebx, DWORD PTR _iMaxCityHighWaterMark$224755[esp+100]
	jle	$LL868@setOwner
$LN26@setOwner:

; 5518 : 										}
; 5519 : 									}
; 5520 : 								}
; 5521 : 							}
; 5522 : 						}
; 5523 : 					}
; 5524 : 					if(bestHighWaterMark > newPlayer.GetCityDistanceHighwaterMark())

	mov	ecx, DWORD PTR _newPlayer$224722[esp+104]
	call	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ ; CvPlayer::GetCityDistanceHighwaterMark
	cmp	edi, eax
	jle	$LN735@setOwner

; 5525 : 					{
; 5526 : 						newPlayer.SetCityDistanceHighwaterMark(bestHighWaterMark);

	mov	ecx, DWORD PTR _newPlayer$224722[esp+104]
	push	edi
	call	?SetCityDistanceHighwaterMark@CvPlayer@@QAEXH@Z ; CvPlayer::SetCityDistanceHighwaterMark

; 5527 : 						if(GC.GetEngineUserInterface()->isCityScreenUp())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+312]
	call	eax
	test	al, al
	je	$LN735@setOwner

; 5528 : 						{
; 5529 : 							auto_ptr<ICvCity1> pHeadSelectedCity(GC.GetEngineUserInterface()->getHeadSelectedCity());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+136]
	call	eax
	mov	ebp, eax
	mov	DWORD PTR _pHeadSelectedCity$224828[esp+100], ebp
	mov	BYTE PTR __$EHRec$[esp+112], 2

; 5530 : 							if(pHeadSelectedCity.get())

	test	ebp, ebp
	je	SHORT $LN730@setOwner

; 5531 : 							{
; 5532 : 								CvCity* pkHeadSelectedCity = GC.UnwrapCityPointer(pHeadSelectedCity.get());

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z ; CvGlobals::UnwrapCityPointer

; 5533 : 								auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pkHeadSelectedCity->plot());

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	lea	ecx, DWORD PTR $T258282[esp+104]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllPlot$224841[esp+104], edi
	mov	eax, DWORD PTR $T258282[esp+100]
	mov	BYTE PTR __$EHRec$[esp+112], 3
	test	eax, eax
	je	SHORT $LN721@setOwner
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN721@setOwner:

; 5534 : 								GC.GetEngineUserInterface()->lookAt(pDllPlot.get(), CAMERALOOKAT_CITY_ZOOM_IN);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+272]
	push	1
	push	edi
	call	eax

; 5535 : 							}

	mov	BYTE PTR __$EHRec$[esp+112], 2
	test	edi, edi
	je	SHORT $LN730@setOwner
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+4]
	push	edi
	call	edx
$LN730@setOwner:

; 5536 : 						}

	mov	BYTE PTR __$EHRec$[esp+112], 0
	test	ebp, ebp
	je	SHORT $LN735@setOwner
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ebp
	call	ecx
$LN735@setOwner:

; 5537 : 					}
; 5538 : 				}
; 5539 : 			}
; 5540 : 
; 5541 : 			pUnitNode = headUnitNode();
; 5542 : 
; 5543 : 			for(iI = 0; iI < MAX_TEAMS; ++iI)

	xor	ebp, ebp
	xor	edi, edi
	npad	9
$LL13@setOwner:

; 5544 : 			{
; 5545 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 5546 : 				if (iI == OBSERVER_TEAM || GET_TEAM((TeamTypes)iI).isAlive())
; 5547 : #else
; 5548 : 				if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	cmp	DWORD PTR [edi+edx+12], 0
	jle	SHORT $LN12@setOwner

; 5549 : #endif
; 5550 : 				{
; 5551 : 					updateRevealedOwner((TeamTypes)iI);

	push	ebp
	mov	ecx, esi
	call	?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ; CvPlot::updateRevealedOwner
$LN12@setOwner:
	add	edi, 2980				; 00000ba4H
	inc	ebp
	cmp	edi, 190720				; 0002e900H
	jl	SHORT $LL13@setOwner

; 5552 : 				}
; 5553 : 			}
; 5554 : 
; 5555 : 			updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 5556 : 
; 5557 : 			// Update happiness if there's a luxury or natural wonder here
; 5558 : 			if(isOwned())

	cmp	BYTE PTR [esi+4], -1
	je	$LN865@setOwner

; 5559 : 			{
; 5560 : 				bool bShouldUpdateHappiness = false;
; 5561 : 
; 5562 : 				if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN864@setOwner

; 5563 : 				{
; 5564 : 					if(GC.getFeatureInfo(getFeatureType())->IsNaturalWonder())

	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	jne	SHORT $LN853@setOwner
$LN864@setOwner:

; 5565 : 					{
; 5566 : 						bShouldUpdateHappiness = true;
; 5567 : 					}
; 5568 : 				}
; 5569 : 
; 5570 : 				if(!bShouldUpdateHappiness && getResourceType(getTeam()) != NO_RESOURCE)

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN765@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN765@setOwner
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN764@setOwner
$LN765@setOwner:
	or	eax, -1
$LN764@setOwner:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN865@setOwner

; 5571 : 				{
; 5572 : 					if(GC.getResourceInfo(getResourceType(getTeam()))->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN778@setOwner
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN778@setOwner
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN777@setOwner
$LN778@setOwner:
	or	eax, -1
$LN777@setOwner:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN865@setOwner

; 5573 : 					{
; 5574 : 						if(getImprovementType() != NO_IMPROVEMENT)

	cmp	BYTE PTR [esi+441], -1
	je	SHORT $LN865@setOwner
$LN853@setOwner:

; 5575 : 						{
; 5576 : 							bShouldUpdateHappiness = true;
; 5577 : 						}
; 5578 : 					}
; 5579 : 				}
; 5580 : 
; 5581 : 				if(bShouldUpdateHappiness)
; 5582 : 				{
; 5583 : 					GET_PLAYER(getOwner()).DoUpdateHappiness();

	movsx	ecx, BYTE PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN865@setOwner:

; 5584 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 5585 : 					GET_PLAYER(getOwner()).doSelfConsistencyCheckAllCities();
; 5586 : #endif
; 5587 : 				}
; 5588 : 			}
; 5589 : 
; 5590 : 			if(bCheckUnits)

	cmp	BYTE PTR _bCheckUnits$[esp+100], 0
	je	SHORT $LN2@setOwner

; 5591 : 			{
; 5592 : 				verifyUnitValidPlot();

	mov	ecx, esi
	call	?verifyUnitValidPlot@CvPlot@@QAEXXZ	; CvPlot::verifyUnitValidPlot
$LN2@setOwner:

; 5593 : 			}
; 5594 : 
; 5595 : 			if(GC.getGame().isDebugMode())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN873@setOwner

; 5596 : 			{
; 5597 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(this);

	push	esi
	lea	eax, DWORD PTR $T258284[esp+104]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllPlot$224869[esp+100], edi
	mov	eax, DWORD PTR $T258284[esp+100]
	mov	BYTE PTR __$EHRec$[esp+112], 4
	test	eax, eax
	je	SHORT $LN806@setOwner
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN806@setOwner:

; 5598 : 				GC.GetEngineUserInterface()->UpdateCountryBorder(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+424]
	push	edi
	call	edx

; 5599 : 			}

	mov	BYTE PTR __$EHRec$[esp+112], 0
	test	edi, edi
	je	SHORT $LN873@setOwner
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx
$LN873@setOwner:

; 5600 : 		}
; 5601 : 
; 5602 : 		auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(this);

	push	esi
	lea	edx, DWORD PTR $T258286[esp+104]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllPlot$224873[esp+100], edi
	mov	eax, DWORD PTR $T258286[esp+100]
	mov	BYTE PTR __$EHRec$[esp+112], 5
	test	eax, eax
	je	SHORT $LN826@setOwner
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN826@setOwner:

; 5603 : 		GC.GetEngineUserInterface()->UpdateCountryBorder(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+424]
	push	edi
	call	edx

; 5604 : 		GC.GetEngineUserInterface()->setDirty(NationalBorders_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	31					; 0000001fH
	call	edx

; 5605 : 		updateSymbols();

	mov	ecx, esi
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 5606 : 	}

	mov	BYTE PTR __$EHRec$[esp+112], 0
	test	edi, edi
	je	SHORT $LN875@setOwner
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx
$LN875@setOwner:
	pop	edi
	pop	ebp
$LN837@setOwner:

; 5607 : }

	lea	ecx, DWORD PTR _strBuffer$[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$1:
	lea	ecx, DWORD PTR $T258271[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$2:
	lea	ecx, DWORD PTR _pHeadSelectedCity$224828[ebp-4]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$4:
	lea	ecx, DWORD PTR _pDllPlot$224841[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$6:
	lea	ecx, DWORD PTR _pDllPlot$224869[ebp-4]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$8:
	lea	ecx, DWORD PTR _pDllPlot$224873[ebp-4]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z:
	mov	eax, OFFSET __ehfuncinfo$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z ENDP	; CvPlot::setOwner
PUBLIC	??0?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ ; std::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ??0?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ PROC ; std::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 80   : 		{	// construct empty set from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+17], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 81   : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@QAE@XZ ENDP ; std::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >::set<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$260243 = 12					; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR __Cat$260243[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+4]
	push	ecx
	push	edx
	call	??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 16					; 00000010H

; 1120 : 		}

	ret	8
?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Destroy
_TEXT	ENDS
PUBLIC	??4?$FAutoVariable@DVCvPlot@@@@QAEAADABD@Z	; FAutoVariable<char,CvPlot>::operator=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??4?$FAutoVariable@DVCvPlot@@@@QAEAADABD@Z
_TEXT	SEGMENT
$T260262 = -8						; size = 8
$T260261 = 8						; size = 4
_rhs$ = 8						; size = 4
??4?$FAutoVariable@DVCvPlot@@@@QAEAADABD@Z PROC		; FAutoVariable<char,CvPlot>::operator=, COMDAT
; _this$ = ecx

; 201  : {

	sub	esp, 8
	push	esi
	push	edi

; 202  : 	if(rhs != m_value)

	mov	edi, DWORD PTR _rhs$[esp+12]
	mov	al, BYTE PTR [edi]
	cmp	al, BYTE PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	je	SHORT $LN9@operator@9

; 203  : 	{
; 204  : 		set(rhs);

	mov	DWORD PTR $T260261[esp+12], ecx
	mov	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR $T260261[esp+12]
	push	edx
	lea	eax, DWORD PTR $T260262[esp+20]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	cl, BYTE PTR [edi]
	mov	BYTE PTR [esi], cl
$LN9@operator@9:
	pop	edi

; 205  : 	}
; 206  : 	return m_value;

	mov	eax, esi
	pop	esi

; 207  : }

	add	esp, 8
	ret	4
??4?$FAutoVariable@DVCvPlot@@@@QAEAADABD@Z ENDP		; FAutoVariable<char,CvPlot>::operator=
_TEXT	ENDS
PUBLIC	??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$1
__ehfuncinfo$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
_TEXT	SEGMENT
$T260272 = -72						; size = 28
$T260271 = -44						; size = 32
__$EHRec$ = -12						; size = 12
$T260274 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z PROC ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebp

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	ebp, DWORD PTR __Keyval$[esp+72]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+45], 0
	mov	esi, ecx
	jne	SHORT $LN11@operator@10
	mov	ecx, DWORD PTR [ebp]
$LL12@operator@10:
	cmp	DWORD PTR [eax+12], ecx
	jae	SHORT $LN10@operator@10
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN9@operator@10
$LN10@operator@10:
	mov	esi, eax
	mov	eax, DWORD PTR [eax]
$LN9@operator@10:
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL12@operator@10
$LN11@operator@10:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN1@operator@10
	mov	eax, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [esi+12]
	jae	SHORT $LN68@operator@10
$LN1@operator@10:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	lea	ecx, DWORD PTR $T260272[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR $T260271[esp+84], ecx
	push	eax
	lea	ecx, DWORD PTR $T260271[esp+92]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	edx, DWORD PTR $T260271[esp+84]
	push	edx
	push	esi
	lea	eax, DWORD PTR $T260274[esp+88]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+104], 1
	call	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
	mov	esi, DWORD PTR [eax]
	lea	ecx, DWORD PTR $T260271[esp+88]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T260272[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN68@operator@10:

; 174  : 		return ((*_Where).second);
; 175  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	lea	eax, DWORD PTR [esi+16]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$0:
	lea	ecx, DWORD PTR $T260272[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$1:
	lea	ecx, DWORD PTR $T260271[ebp]
	jmp	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z:
	mov	eax, OFFSET __ehfuncinfo$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z ENDP ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T260454 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@4
	cmp	edx, eax
	jne	SHORT $LN101@erase@4

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@4:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@4
	npad	2
$LL2@erase@4:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+45], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@4
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN103@erase@4
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN79@erase@4
	npad	5
$LL80@erase@4:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL80@erase@4
$LN79@erase@4:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@4
$LN103@erase@4:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+45], 0
	jne	SHORT $LN63@erase@4
	npad	7
$LL64@erase@4:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@4
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+45], 0
	je	SHORT $LL64@erase@4
$LN63@erase@4:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@4:
	push	edx
	lea	eax, DWORD PTR $T260454[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@4
$LN1@erase@4:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
_TEXT	ENDS
PUBLIC	?reset@CvPlot@@QAEXHH_N@Z			; CvPlot::reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?reset@CvPlot@@QAEXHH_N@Z
_TEXT	SEGMENT
$T260861 = -8						; size = 8
$T260860 = 8						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_bConstructorCall$ = 16					; size = 1
?reset@CvPlot@@QAEXHH_N@Z PROC				; CvPlot::reset, COMDAT
; _this$ = ecx

; 204  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 205  : 	//--------------------------------
; 206  : 	// Uninit class
; 207  : 	uninit();

	mov	eax, DWORD PTR [esi+180]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebp, ebp
	mov	DWORD PTR [esi+180], ebp
	mov	ecx, DWORD PTR [esi+188]
	add	esp, 4
	cmp	ecx, ebp
	je	SHORT $LN48@reset
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@reset:
	mov	DWORD PTR [esi+188], ebp
	mov	ecx, DWORD PTR [esi+184]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]

; 208  : 
; 209  : 	m_iX = iX;

	mov	dx, WORD PTR _iX$[esp+24]

; 210  : 	m_iY = iY;

	mov	ax, WORD PTR _iY$[esp+24]
	mov	DWORD PTR [esi+184], ebp
	mov	DWORD PTR [esi+28], ebp

; 211  : 	m_iArea = FFreeList::INVALID_INDEX;

	or	ebx, -1
	mov	WORD PTR [esi], dx
	mov	WORD PTR [esi+2], ax

; 212  : 	m_iLandmass = FFreeList::INVALID_INDEX;
; 213  : 	m_iFeatureVariety = 0;
; 214  : 	m_iOwnershipDuration = 0;
; 215  : 	m_iImprovementDuration = 0;
; 216  : 	m_iUpgradeProgress = 0;

	xor	eax, eax
	xor	ecx, ecx
	xor	edx, edx

; 217  : 	m_iCulture = 0;
; 218  : 	m_iNumMajorCivsRevealed = 0;
; 219  : 	m_iCityRadiusCount = 0;
; 220  : 	m_iReconCount = 0;
; 221  : 	m_iRiverCrossingCount = 0;
; 222  : 	m_iResourceNum = 0;
; 223  : 	m_cContinentType = 0;
; 224  : 
; 225  : 	m_uiTradeRouteBitFlags = 0;
; 226  : 
; 227  : 	m_bStartingPlot = false;
; 228  : 	m_bHills = false;
; 229  : 	m_bNEOfRiver = false;
; 230  : 	m_bWOfRiver = false;
; 231  : 	m_bNWOfRiver = false;
; 232  : 	m_bPotentialCityWork = false;
; 233  : 	m_bPlotLayoutDirty = false;
; 234  : 	m_bLayoutStateWorked = false;
; 235  : 	m_bImprovementPillaged = false;
; 236  : 	m_bRoutePillaged = false;
; 237  : 	m_bBarbCampNotConverting = false;
; 238  : 	m_bRoughFeature = false;
; 239  : 	m_bResourceLinkedCityActive = false;
; 240  : 	m_bImprovedByGiftFromMajor = false;
; 241  : 	m_bIsAdjacentToLand = false;
; 242  : 	m_bIsImpassable = false;
; 243  : 
; 244  : 	m_eOwner = NO_PLAYER;
; 245  : 	m_ePlotType = PLOT_OCEAN;
; 246  : 	m_eTerrainType = NO_TERRAIN;
; 247  : 	m_eFeatureType = NO_FEATURE;

	lea	edi, DWORD PTR [esi+428]
	add	esp, 4
	mov	DWORD PTR [esi+356], ebx
	mov	DWORD PTR [esi+360], ebx
	mov	BYTE PTR [esi+453], 0
	mov	WORD PTR [esi+380], cx
	mov	WORD PTR [esi+382], dx
	mov	WORD PTR [esi+384], ax
	mov	WORD PTR [esi+386], cx
	mov	BYTE PTR [esi+454], al
	mov	BYTE PTR [esi+455], al
	mov	BYTE PTR [esi+456], al
	mov	BYTE PTR [esi+457], al
	mov	BYTE PTR [esi+458], al
	mov	BYTE PTR [esi+459], al
	mov	DWORD PTR [esi+388], ebp
	mov	BYTE PTR [esi+461], al
	mov	BYTE PTR [esi+462], al
	mov	BYTE PTR [esi+4], bl
	mov	BYTE PTR [esi+5], 3
	mov	BYTE PTR [esi+6], bl
	cmp	BYTE PTR [edi+4], bl
	je	SHORT $LN62@reset
	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR $T260860[esp+20]
	push	edx
	lea	eax, DWORD PTR $T260861[esp+28]
	push	eax
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T260860[esp+28], edi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	BYTE PTR [edi+4], bl
$LN62@reset:

; 248  : 	m_eResourceType = NO_RESOURCE;

	mov	BYTE PTR [esi+440], bl

; 249  : 	m_eImprovementType = NO_IMPROVEMENT;

	mov	BYTE PTR [esi+441], bl

; 250  : 	m_eImprovementTypeUnderConstruction = NO_IMPROVEMENT;

	mov	BYTE PTR [esi+442], bl

; 251  : 	m_ePlayerBuiltImprovement = NO_PLAYER;

	mov	BYTE PTR [esi+443], bl

; 252  : 	m_ePlayerResponsibleForImprovement = NO_PLAYER;

	mov	BYTE PTR [esi+444], bl

; 253  : 	m_ePlayerResponsibleForRoute = NO_PLAYER;

	mov	BYTE PTR [esi+445], bl

; 254  : 	m_ePlayerThatClearedBarbCampHere = NO_PLAYER;

	mov	BYTE PTR [esi+446], bl

; 255  : 	m_eRouteType = NO_ROUTE;

	mov	BYTE PTR [esi+447], bl

; 256  : 	m_eWorldAnchor = NO_WORLD_ANCHOR;

	mov	BYTE PTR [esi+448], bl

; 257  : 	m_cWorldAnchorData = NO_WORLD_ANCHOR;

	mov	BYTE PTR [esi+449], bl

; 258  : 	m_eRiverEFlowDirection = NO_FLOWDIRECTION;

	mov	BYTE PTR [esi+450], bl

; 259  : 	m_eRiverSEFlowDirection = NO_FLOWDIRECTION;

	mov	BYTE PTR [esi+451], bl

; 260  : 	m_eRiverSWFlowDirection = NO_FLOWDIRECTION;

	mov	BYTE PTR [esi+452], bl

; 261  : 	m_cRiverCrossing = 0;

	mov	BYTE PTR [esi+460], 0

; 262  : 
; 263  : 	m_cBuilderAIScratchPadPlayer = 0;

	mov	BYTE PTR [esi+368], 0

; 264  : 	m_sBuilderAIScratchPadTurn = 0;
; 265  : 	m_sBuilderAIScratchPadValue = 0;
; 266  : 	m_eBuilderAIScratchPadRoute = NO_ROUTE;

	mov	DWORD PTR [esi+376], ebx
	xor	ecx, ecx
	mov	WORD PTR [esi+370], cx
	xor	edx, edx
	mov	WORD PTR [esi+372], dx

; 267  : 
; 268  : 	m_plotCity.reset();

	mov	DWORD PTR [esi+104], ebx
	mov	DWORD PTR [esi+108], ebx

; 269  : 	m_workingCity.reset();

	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+116], ebx

; 270  : 	m_workingCityOverride.reset();

	mov	DWORD PTR [esi+120], ebx
	mov	DWORD PTR [esi+124], ebx

; 271  : 	m_ResourceLinkedCity.reset();

	mov	DWORD PTR [esi+128], ebx
	mov	DWORD PTR [esi+132], ebx

; 272  : 	m_purchaseCity.reset();

	mov	DWORD PTR [esi+136], ebx
	mov	DWORD PTR [esi+140], ebx

; 273  : 	
; 274  : 	if(!bConstructorCall)

	cmp	BYTE PTR _bConstructorCall$[esp+20], dl
	jne	$LN7@reset

; 275  : 	{
; 276  : 		for(int iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	xor	eax, eax
	npad	9
$LL36@reset:

; 277  : 		{
; 278  : 			m_aiYield[iI] = 0;

	mov	ecx, DWORD PTR [esi+144]
	xor	edx, edx
	mov	WORD PTR [eax+ecx], dx
	add	eax, 2
	cmp	eax, 12					; 0000000cH
	jl	SHORT $LL36@reset

; 279  : 		}
; 280  : 		for(int iI = 0; iI < REALLY_MAX_PLAYERS; ++iI)

	xor	eax, eax
	npad	10
$LL33@reset:

; 281  : 		{
; 282  : 			m_aiFoundValue[iI] = -1;

	mov	ecx, DWORD PTR [esi+148]
	mov	DWORD PTR [eax+ecx], ebx
	add	eax, 4
	cmp	eax, 320				; 00000140H
	jl	SHORT $LL33@reset

; 283  : 		}
; 284  : 		for(int iI = 0; iI < REALLY_MAX_PLAYERS; ++iI)

	xor	eax, eax
$LL30@reset:

; 285  : 		{
; 286  : 			m_aiPlayerCityRadiusCount[iI] = 0;

	mov	edx, DWORD PTR [esi+152]
	mov	BYTE PTR [eax+edx], 0
	inc	eax
	cmp	eax, 80					; 00000050H
	jl	SHORT $LL30@reset

; 287  : 		}
; 288  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	xor	eax, eax
	npad	9
$LL27@reset:

; 289  : 		{
; 290  : 			m_aiVisibilityCount[iI] = 0;

	mov	ecx, DWORD PTR [esi+156]
	xor	edx, edx
	mov	WORD PTR [eax+ecx], dx
	add	eax, 2
	cmp	eax, 160				; 000000a0H
	jl	SHORT $LL27@reset

; 291  : 		}
; 292  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	xor	eax, eax
	npad	8
$LL24@reset:

; 293  : 		{
; 294  : 			m_aiRevealedOwner[iI] = -1;

	mov	ecx, DWORD PTR [esi+160]
	mov	BYTE PTR [eax+ecx], bl
	inc	eax
	cmp	eax, 80					; 00000050H
	jl	SHORT $LL24@reset

; 295  : 		}
; 296  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)
; 297  : 		{
; 298  : 			//m_abRevealed[iI] = false;
; 299  : 		}
; 300  : 		m_bfRevealed.ClearAll();

	xor	eax, eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	npad	3
$LL18@reset:

; 301  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)
; 302  : 		{
; 303  : 			m_abResourceForceReveal[iI] = false;

	mov	edx, DWORD PTR [esi+176]
	mov	BYTE PTR [eax+edx], 0
	inc	eax
	cmp	eax, 80					; 00000050H
	jl	SHORT $LL18@reset

; 304  : 		}
; 305  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	xor	eax, eax
$LL15@reset:

; 306  : 		{
; 307  : 			m_aeRevealedImprovementType[iI] = NO_IMPROVEMENT;

	mov	ecx, DWORD PTR [esi+164]
	mov	edx, ebx
	mov	WORD PTR [eax+ecx], dx
	add	eax, 2
	cmp	eax, 160				; 000000a0H
	jl	SHORT $LL15@reset

; 308  : 		}
; 309  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	xor	eax, eax
	npad	6
$LL12@reset:

; 310  : 		{
; 311  : 			m_aeRevealedRouteType[iI] = NO_ROUTE;

	mov	ecx, DWORD PTR [esi+168]
	mov	edx, ebx
	mov	WORD PTR [eax+ecx], dx
	add	eax, 2
	cmp	eax, 160				; 000000a0H
	jl	SHORT $LL12@reset

; 312  : 		}
; 313  : 		for(int iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	xor	eax, eax
	npad	8
$LL9@reset:

; 314  : 		{
; 315  : 			m_abNoSettling[iI] = false;

	mov	ecx, DWORD PTR [esi+172]
	mov	BYTE PTR [eax+ecx], 0
	inc	eax
	cmp	eax, 22					; 00000016H
	jl	SHORT $LL9@reset
$LN7@reset:

; 316  : 		}
; 317  : 	}
; 318  : 	for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)
; 319  : 	{
; 320  : 		for(int iJ = 0; iJ < NUM_INVISIBLE_TYPES; ++iJ)
; 321  : 		{
; 322  : 			m_apaiInvisibleVisibilityCount[iI][iJ] = 0;

	xor	eax, eax
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	lea	edi, DWORD PTR [esi+196]
	mov	ecx, 40					; 00000028H
	or	eax, edx
	rep stosd
	pop	edi

; 323  : 		}
; 324  : 	}
; 325  : 
; 326  : 	m_kArchaeologyData.Reset();

	mov	DWORD PTR [esi+464], ebp
	mov	DWORD PTR [esi+468], ebx
	mov	DWORD PTR [esi+472], ebx
	mov	DWORD PTR [esi+476], ebx
	mov	DWORD PTR [esi+480], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 327  : }

	add	esp, 8
	ret	12					; 0000000cH
?reset@CvPlot@@QAEXHH_N@Z ENDP				; CvPlot::reset
_TEXT	ENDS
PUBLIC	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z	; CvPlot::setFeatureType
EXTRN	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z:PROC	; CvArea::ChangeNumNaturalWonders
EXTRN	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z:PROC	; CvMap::ChangeNumNaturalWonders
EXTRN	?IsRough@CvFeatureInfo@@QBE_NXZ:PROC		; CvFeatureInfo::IsRough
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$1
__ehfuncinfo$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
_TEXT	SEGMENT
$T260923 = -32						; size = 4
$T260974 = -28						; size = 4
$T260924 = -28						; size = 4
_pDllPlot$225037 = -24					; size = 4
$T260975 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_bUpdateSight$ = 8					; size = 1
_eNewValue$ = 8						; size = 4
_iVariety$ = 12						; size = 4
?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z PROC	; CvPlot::setFeatureType, COMDAT
; _this$ = ecx

; 5976 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 5977 : 	FeatureTypes eOldFeature;
; 5978 : 	bool bUpdateSight;
; 5979 : 
; 5980 : 	eOldFeature = getFeatureType();
; 5981 : 
; 5982 : #ifndef AUI_WARNING_FIXES
; 5983 : 	iVariety = 0;
; 5984 : #endif
; 5985 : 
; 5986 : 	if((eOldFeature != eNewValue) || (m_iFeatureVariety != iVariety))

	mov	ebx, DWORD PTR _eNewValue$[esp+32]
	push	ebp
	push	esi
	mov	esi, ecx
	movsx	ebp, BYTE PTR [esi+432]
	cmp	ebp, ebx
	jne	SHORT $LN16@setFeature
	cmp	BYTE PTR [esi+453], 0
	je	$LN69@setFeature
$LN16@setFeature:
	push	edi

; 5987 : 	{
; 5988 : 		if((eOldFeature == NO_FEATURE) ||
; 5989 : 		        (eNewValue == NO_FEATURE) ||
; 5990 : 		        (GC.getFeatureInfo(eOldFeature)->getSeeThroughChange() != GC.getFeatureInfo(eNewValue)->getSeeThroughChange()))

	cmp	ebp, -1
	je	SHORT $LN14@setFeature
	cmp	ebx, -1
	je	SHORT $LN14@setFeature
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	cmp	edi, eax
	jne	SHORT $LN14@setFeature

; 5991 : 		{
; 5992 : 			bUpdateSight = true;
; 5993 : 		}
; 5994 : 		else
; 5995 : 		{
; 5996 : 			bUpdateSight = false;

	mov	BYTE PTR _bUpdateSight$[esp+44], 0
	jmp	SHORT $LN12@setFeature
$LN14@setFeature:

; 5997 : 		}
; 5998 : 
; 5999 : 		if(bUpdateSight)
; 6000 : 		{
; 6001 : 			updateSeeFromSight(false);

	push	0
	mov	ecx, esi
	mov	BYTE PTR _bUpdateSight$[esp+48], 1
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN12@setFeature:

; 6002 : 		}
; 6003 : 
; 6004 : 		auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T260924[esp+48], eax
	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[esp+56], ecx
	cmp	eax, ecx
	je	SHORT $LN20@setFeature
	push	esi
	mov	ecx, eax
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	DWORD PTR $T260923[esp+48], eax
	jmp	SHORT $LN21@setFeature
$LN20@setFeature:
	mov	DWORD PTR $T260923[esp+48], ecx
	mov	eax, ecx
$LN21@setFeature:
	mov	DWORD PTR _pDllPlot$225037[esp+48], eax

; 6005 : 		gDLL->GameplayFeatureChanged(pDllPlot.get(), eNewValue);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edx+688]
	mov	DWORD PTR __$EHRec$[esp+64], 1
	call	eax

; 6006 : 
; 6007 : 		m_eFeatureType = eNewValue;

	cmp	bl, BYTE PTR [esi+432]
	lea	edi, DWORD PTR [esi+428]
	je	SHORT $LN37@setFeature
	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR $T260974[esp+48]
	push	ecx
	lea	edx, DWORD PTR $T260975[esp+52]
	push	edx
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T260974[esp+56], edi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	BYTE PTR [edi+4], bl
$LN37@setFeature:

; 6008 : 
; 6009 : 		updateYield();

	mov	ecx, esi
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6010 : 		updateImpassable();

	mov	ecx, esi
	call	?updateImpassable@CvPlot@@IAEXXZ	; CvPlot::updateImpassable

; 6011 : 
; 6012 : 		if(bUpdateSight)

	cmp	BYTE PTR _bUpdateSight$[esp+44], 0
	pop	edi
	je	SHORT $LN73@setFeature

; 6013 : 		{
; 6014 : 			updateSeeFromSight(true);

	push	1
	mov	ecx, esi
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN73@setFeature:

; 6015 : 		}
; 6016 : 		m_iFeatureVariety = iVariety;
; 6017 : 
; 6018 : 		// Rough feature?
; 6019 : 		bool bRough = false;

	xor	al, al
	mov	BYTE PTR [esi+453], 0

; 6020 : 		if(eNewValue != NO_FEATURE)

	cmp	ebx, -1
	je	SHORT $LN74@setFeature

; 6021 : 			bRough = GC.getFeatureInfo(eNewValue)->IsRough();

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsRough@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::IsRough
$LN74@setFeature:

; 6022 : 
; 6023 : 		SetRoughFeature(bRough);

	mov	cl, BYTE PTR [esi+462]
	mov	dl, cl
	shr	dl, 3
	and	dl, 1
	cmp	dl, al
	je	SHORT $LN42@setFeature
	add	al, al
	add	al, al
	add	al, al
	xor	al, cl
	and	al, 8
	xor	al, cl
	mov	BYTE PTR [esi+462], al
$LN42@setFeature:

; 6024 : 
; 6025 : 		if(eNewValue != NO_FEATURE)

	cmp	ebx, -1
	je	SHORT $LN76@setFeature

; 6026 : 		{
; 6027 : 			// Now a Natural Wonder here
; 6028 : 			if((eOldFeature == NO_FEATURE || !GC.getFeatureInfo(eOldFeature)->IsNaturalWonder()) && GC.getFeatureInfo(eNewValue)->IsNaturalWonder())

	cmp	ebp, -1
	je	SHORT $LN75@setFeature
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	jne	SHORT $LN76@setFeature
$LN75@setFeature:
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	SHORT $LN76@setFeature

; 6029 : 			{
; 6030 : 				GC.getMap().ChangeNumNaturalWonders(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	call	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z	; CvMap::ChangeNumNaturalWonders

; 6031 : 				GC.getMap().getArea(getArea())->ChangeNumNaturalWonders(1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	1
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z ; CvArea::ChangeNumNaturalWonders
$LN76@setFeature:

; 6032 : 			}
; 6033 : 		}
; 6034 : 		if(eOldFeature != NO_FEATURE)

	cmp	ebp, -1
	je	SHORT $LN77@setFeature

; 6035 : 		{
; 6036 : 			// Was a Natural Wonder, isn't any more
; 6037 : 			if(GC.getFeatureInfo(eOldFeature)->IsNaturalWonder() && (eNewValue == NO_FEATURE || !GC.getFeatureInfo(eNewValue)->IsNaturalWonder()))

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	je	SHORT $LN77@setFeature
	cmp	ebx, -1
	je	SHORT $LN4@setFeature
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	test	al, al
	jne	SHORT $LN77@setFeature
$LN4@setFeature:

; 6038 : 			{
; 6039 : 				GC.getMap().ChangeNumNaturalWonders(-1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	call	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z	; CvMap::ChangeNumNaturalWonders

; 6040 : 				GC.getMap().getArea(getArea())->ChangeNumNaturalWonders(-1);

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z ; CvArea::ChangeNumNaturalWonders
$LN77@setFeature:

; 6041 : 			}
; 6042 : 		}
; 6043 : 
; 6044 : 		if(getFeatureType() == NO_FEATURE)

	cmp	BYTE PTR [esi+432], -1
	jne	SHORT $LN1@setFeature

; 6045 : 		{
; 6046 : 			if(getImprovementType() != NO_IMPROVEMENT)

	mov	al, BYTE PTR [esi+441]
	cmp	al, -1
	je	SHORT $LN1@setFeature

; 6047 : 			{
; 6048 : 				if(GC.getImprovementInfo(getImprovementType())->IsRequiresFeature())

	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFeature
	test	al, al
	je	SHORT $LN1@setFeature

; 6049 : 				{
; 6050 : 					setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, esi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
$LN1@setFeature:

; 6051 : 				}
; 6052 : 			}
; 6053 : 		}
; 6054 : 	}

	mov	eax, DWORD PTR $T260923[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	eax, eax
	je	SHORT $LN69@setFeature
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN69@setFeature:

; 6055 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$0:
	mov	eax, DWORD PTR $T260924[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$225037[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ENDP	; CvPlot::setFeatureType
PUBLIC	?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z ; CvPlot::changeBuildProgress
EXTRN	?changeFood@CvCity@@QAEXH@Z:PROC		; CvCity::changeFood
EXTRN	?changeFeatureProduction@CvCity@@QAEXH@Z:PROC	; CvCity::changeFeatureProduction
EXTRN	?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z:PROC ; CvPlayerCulture::DoArchaeologyChoice
EXTRN	?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z:PROC ; CvPlayerCulture::GetArchaeologyChoice
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z:PROC ; CvPlayerCulture::AddDigCompletePlot
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?SetNumArchaeologyChoices@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::SetNumArchaeologyChoices
EXTRN	?GetNumArchaeologyChoices@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumArchaeologyChoices
EXTRN	?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsPromptWhenComplete
EXTRN	?IsRemovesResource@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRemovesResource
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_args$226447 = -292					; size = 4
_pCity$ = -292						; size = 4
_kPlayer$ = -292					; size = 4
_bFinished$ = -285					; size = 1
tv1438 = -284						; size = 4
$T261324 = -284						; size = 4
$T261063 = -284						; size = 4
_iProduction$ = -284					; size = 4
_iFood$226432 = -280					; size = 4
$T261058 = -280						; size = 4
_iUnitLoop$226398 = -280				; size = 4
_pkBuildInfo$ = -276					; size = 4
_eImprovement$226360 = -272				; size = 4
_bResult$226448 = -265					; size = 1
$T261065 = -264						; size = 8
$T261062 = -264						; size = 4
$T261061 = -264						; size = 8
$T261059 = -264						; size = 4
_strBuffer$ = -256					; size = 28
$T261064 = -228						; size = 28
$T261060 = -228						; size = 28
$T261057 = -228						; size = 28
_strSummary$226379 = -200				; size = 28
_locSummary$226375 = -172				; size = 80
_locString$226374 = -92					; size = 80
__$EHRec$ = -12						; size = 12
_eBuild$ = 8						; size = 4
_iChange$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z PROC ; CvPlot::changeBuildProgress, COMDAT
; _this$ = ecx

; 9273 : {

	push	-1
	push	__ehhandler$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	edi
	mov	edi, ecx

; 9274 : 	CvCity* pCity;
; 9275 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[esp+300]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9276 : 	int iProduction;
; 9277 : 	bool bFinished = false;
; 9278 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	ebx, DWORD PTR _ePlayer$[esp+296]
	mov	eax, ebx
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 9279 : 
; 9280 : 	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _kPlayer$[esp+300], eax
	mov	eax, DWORD PTR _eBuild$[esp+296]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+312], 0
	mov	BYTE PTR _bFinished$[esp+304], 0
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$[esp+300], eax

; 9281 : 	CvAssert(pkBuildInfo);
; 9282 : 
; 9283 : 	//This shouldn't happen.
; 9284 : 	if(pkBuildInfo == NULL)

	test	eax, eax
	jne	SHORT $LN46@changeBuil

; 9285 : 		return false;

	lea	ecx, DWORD PTR _strBuffer$[esp+300]
	mov	DWORD PTR __$EHRec$[esp+308], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	al, al
	jmp	$LN47@changeBuil
$LN46@changeBuil:
	push	ebp

; 9286 : 
; 9287 : 	if(iChange != 0)

	mov	ebp, DWORD PTR _iChange$[esp+300]
	test	ebp, ebp
	je	$LN1@changeBuil

; 9288 : 	{
; 9289 : 		if(NULL == m_paiBuildProgress)

	cmp	DWORD PTR [edi+184], 0
	push	esi
	jne	SHORT $LN41@changeBuil

; 9290 : 		{
; 9291 : #ifdef AUI_WARNING_FIXES
; 9292 : 			m_paiBuildProgress = FNEW(int[GC.getNumBuildInfos()], c_eCiv5GameplayDLL, 0);
; 9293 : 			for (uint iI = 0; iI < GC.getNumBuildInfos(); ++iI)
; 9294 : #else
; 9295 : 			m_paiBuildProgress = FNEW(short[GC.getNumBuildInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	xor	ecx, ecx
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 9296 : 			for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [edi+184], eax
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN41@changeBuil
	npad	5
$LL43@changeBuil:

; 9297 : #endif
; 9298 : 			{
; 9299 : 				m_paiBuildProgress[iI] = 0;

	mov	eax, DWORD PTR [edi+184]
	xor	ecx, ecx
	mov	WORD PTR [eax+esi*2], cx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL43@changeBuil
$LN41@changeBuil:

; 9300 : 			}
; 9301 : 		}
; 9302 : 
; 9303 : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuildInfo->getImprovement();

	mov	ecx, DWORD PTR _pkBuildInfo$[esp+308]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$226360[esp+308], eax

; 9304 : 		if (eImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN39@changeBuil

; 9305 : 		{
; 9306 : 			if (eImprovement != m_eImprovementTypeUnderConstruction)

	movsx	edx, BYTE PTR [edi+442]
	cmp	eax, edx
	je	SHORT $LN39@changeBuil

; 9307 : 			{
; 9308 : 				SilentlyResetAllBuildProgress();

	mov	ecx, edi
	call	?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ ; CvPlot::SilentlyResetAllBuildProgress

; 9309 : 				m_eImprovementTypeUnderConstruction = eImprovement;

	mov	al, BYTE PTR _eImprovement$226360[esp+308]
	mov	BYTE PTR [edi+442], al
$LN39@changeBuil:

; 9310 : 			}
; 9311 : 		}
; 9312 : 
; 9313 : 		m_paiBuildProgress[eBuild] += iChange;

	mov	edx, DWORD PTR [edi+184]
	mov	ecx, DWORD PTR _eBuild$[esp+304]
	add	WORD PTR [edx+ecx*2], bp
	lea	eax, DWORD PTR [edx+ecx*2]

; 9314 : 		CvAssert(getBuildProgress(eBuild) >= 0);
; 9315 : 
; 9316 : 		if(getBuildProgress(eBuild) >= getBuildTime(eBuild, ePlayer))

	mov	eax, DWORD PTR [edi+184]
	test	eax, eax
	jne	SHORT $LN65@changeBuil
	xor	esi, esi
	jmp	SHORT $LN66@changeBuil
$LN65@changeBuil:
	movsx	esi, WORD PTR [eax+ecx*2]
$LN66@changeBuil:
	push	ebx
	push	ecx
	mov	ecx, edi
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	cmp	esi, eax
	jl	$LN326@changeBuil

; 9317 : 		{
; 9318 : 			m_paiBuildProgress[eBuild] = 0;

	mov	eax, DWORD PTR [edi+184]
	mov	edx, DWORD PTR _eBuild$[esp+304]
	xor	ecx, ecx
	mov	WORD PTR [eax+edx*2], cx

; 9319 : 
; 9320 : 			// Constructed Improvement
; 9321 : 			if (eImprovement != NO_IMPROVEMENT)

	mov	eax, DWORD PTR _eImprovement$226360[esp+308]
	cmp	eax, -1
	je	$LN17@changeBuil

; 9322 : 			{
; 9323 : 				setImprovementType(eImprovement, ePlayer);

	push	ebx
	push	eax
	mov	ecx, edi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 9324 : 
; 9325 : 				// Unowned plot, someone has to foot the bill
; 9326 : 				if(getOwner() == NO_PLAYER)

	cmp	BYTE PTR [edi+4], -1
	jne	SHORT $LN70@changeBuil

; 9327 : 				{
; 9328 : 					if(MustPayMaintenanceHere(ePlayer))

	push	ebx
	mov	ecx, edi
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN35@changeBuil

; 9329 : 					{
; 9330 : 						kPlayer.GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getImprovementInfo(eImprovement)->GetGoldMaintenance());

	mov	eax, DWORD PTR _eImprovement$226360[esp+308]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	mov	ecx, DWORD PTR _kPlayer$[esp+308]
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN35@changeBuil:

; 9331 : 					}
; 9332 : 					SetPlayerResponsibleForImprovement(ePlayer);

	movsx	ecx, BYTE PTR [edi+444]
	cmp	ecx, ebx
	je	SHORT $LN70@changeBuil
	mov	BYTE PTR [edi+444], bl
$LN70@changeBuil:

; 9333 : 				}
; 9334 : 
; 9335 : 				CvImprovementEntry& newImprovementEntry = *GC.getImprovementInfo(eImprovement);

	mov	edx, DWORD PTR _eImprovement$226360[esp+308]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	esi, eax

; 9336 : 
; 9337 : 				// If this improvement removes the underlying resource, do that
; 9338 : 				if (newImprovementEntry.IsRemovesResource())

	mov	ecx, esi
	call	?IsRemovesResource@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRemovesResource
	mov	bl, 3
	test	al, al
	je	$LN314@changeBuil

; 9339 : 				{
; 9340 : 					if (getResourceType() != NO_RESOURCE)

	mov	al, BYTE PTR [edi+440]
	movsx	ecx, al
	cmp	ecx, -1
	je	$LN314@changeBuil

; 9341 : 					{
; 9342 : 						setResourceType(NO_RESOURCE, 0);

	cmp	al, -1
	je	$LN314@changeBuil
	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN97@changeBuil
	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	movsx	ecx, BYTE PTR [edi+440]
	push	-1
	push	ecx
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN97@changeBuil:
	movsx	edx, BYTE PTR [edi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	edx
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources
	cmp	BYTE PTR [edi+5], bl
	je	SHORT $LN96@changeBuil
	movsx	eax, BYTE PTR [edi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	eax
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN96@changeBuil:
	mov	ecx, edi
	mov	BYTE PTR [edi+440], -1
	mov	BYTE PTR [edi+458], 0
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN314@changeBuil
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [edi+462], 1
$LN314@changeBuil:

; 9343 : 					}
; 9344 : 				}
; 9345 : 
; 9346 : 				// If we want to prompt the user about archaeology, let's record that
; 9347 : 				if (newImprovementEntry.IsPromptWhenComplete())

	mov	ecx, esi
	call	?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsPromptWhenComplete
	test	al, al
	je	$LN316@changeBuil

; 9348 : 				{
; 9349 : 					CvAssertMsg (GetArchaeologicalRecord().m_eArtifactType != NO_GREAT_WORK_ARTIFACT_CLASS, "Archaeological dig complete but no archeology data found!");
; 9350 : 
; 9351 : 					kPlayer.SetNumArchaeologyChoices(kPlayer.GetNumArchaeologyChoices() + 1);

	mov	ebp, DWORD PTR _kPlayer$[esp+308]
	mov	ecx, ebp
	call	?GetNumArchaeologyChoices@CvPlayer@@QBEHXZ ; CvPlayer::GetNumArchaeologyChoices
	inc	eax
	push	eax
	mov	ecx, ebp
	call	?SetNumArchaeologyChoices@CvPlayer@@QAEXH@Z ; CvPlayer::SetNumArchaeologyChoices

; 9352 : 					kPlayer.GetCulture()->AddDigCompletePlot(this);

	push	edi
	mov	ecx, ebp
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z ; CvPlayerCulture::AddDigCompletePlot

; 9353 : 
; 9354 : 					if(kPlayer.isHuman())

	mov	ecx, ebp
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN31@changeBuil

; 9355 : 					{
; 9356 : 						CvNotifications* pNotifications;
; 9357 : 						Localization::String locString;

	mov	esi, DWORD PTR __imp_??0String@Localization@@QAE@XZ
	lea	ecx, DWORD PTR _locString$226374[esp+308]
	call	esi

; 9358 : 						Localization::String locSummary;

	lea	ecx, DWORD PTR _locSummary$226375[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 1
	call	esi

; 9359 : 						pNotifications = kPlayer.GetNotifications();

	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+316], 2
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 9360 : 						if(pNotifications)

	test	esi, esi
	je	$LN30@changeBuil

; 9361 : 						{
; 9362 : 							strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_ARCHAEOLOGY");

	lea	ecx, DWORD PTR $T261057[esp+308]
	push	OFFSET $SG226378
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], bl
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T261057[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9363 : 							CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_CHOOSE_ARCHAEOLOGY");

	lea	edx, DWORD PTR _strSummary$226379[esp+308]
	push	OFFSET $SG226381
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8

; 9364 : 							pNotifications->Add(NOTIFICATION_CHOOSE_ARCHAEOLOGY, strBuffer, strSummary, getX(), getY(), kPlayer.GetID());

	movsx	ecx, WORD PTR [edi]
	movsx	ebx, WORD PTR [edi+2]
	mov	eax, ebp
	mov	ebp, DWORD PTR [eax+44]
	mov	DWORD PTR $T261324[esp+308], ecx
	lea	ecx, DWORD PTR _strSummary$226379[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR $T261324[esp+308]
	push	-1
	push	ebp
	push	ebx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+328]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-2068323322				; 84b7e406H
	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 9365 : 							CancelActivePlayerEndTurn();

	call	?CancelActivePlayerEndTurn@@YA_NXZ	; CancelActivePlayerEndTurn

; 9366 : 						}

	lea	ecx, DWORD PTR _strSummary$226379[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebp, DWORD PTR _kPlayer$[esp+308]
$LN30@changeBuil:

; 9367 : 
; 9368 : 						// Raiders of the Lost Ark achievement
; 9369 : 						const char* szCivKey = kPlayer.getCivilizationTypeKey();

	mov	ecx, ebp
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey

; 9370 : 						if(getOwner() != NO_PLAYER && !GC.getGame().isNetworkMultiPlayer() && strcmp(szCivKey, "CIVILIZATION_AMERICA") == 0)

	cmp	BYTE PTR [edi+4], -1
	mov	esi, eax
	je	$LN25@changeBuil
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	jne	$LN25@changeBuil
	mov	ecx, OFFSET $SG226384
	mov	eax, esi
$LL297@changeBuil:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN298@changeBuil
	test	dl, dl
	je	SHORT $LN322@changeBuil
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN298@changeBuil
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL297@changeBuil
$LN322@changeBuil:
	xor	eax, eax
	jmp	SHORT $LN300@changeBuil
$LN298@changeBuil:
	sbb	eax, eax
	sbb	eax, -1
$LN300@changeBuil:
	test	eax, eax
	jne	$LN25@changeBuil

; 9371 : 						{
; 9372 : 							CvPlayer &kPlotOwner = GET_PLAYER(getOwner());

	movsx	ecx, BYTE PTR [edi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 9373 : 							szCivKey = kPlotOwner.getCivilizationTypeKey();

	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey

; 9374 : 							if(strcmp(szCivKey, "CIVILIZATION_EGYPT") == 0)

	mov	ecx, OFFSET $SG226387
	npad	7
$LL301@changeBuil:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN302@changeBuil
	test	dl, dl
	je	SHORT $LN303@changeBuil
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN302@changeBuil
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL301@changeBuil
$LN303@changeBuil:
	xor	eax, eax
	jmp	SHORT $LN304@changeBuil
$LN302@changeBuil:
	sbb	eax, eax
	sbb	eax, -1
$LN304@changeBuil:
	test	eax, eax
	jne	$LN25@changeBuil

; 9375 : 							{
; 9376 : 								for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	xor	esi, esi
	mov	DWORD PTR tv1438[esp+308], esi
$LL323@changeBuil:

; 9377 : 								{
; 9378 : 									CvPlayer &kLoopPlayer = GET_PLAYER((PlayerTypes)i);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 9379 : 									if (kLoopPlayer.GetID() != NO_PLAYER && kLoopPlayer.isAlive())

	cmp	DWORD PTR [esi+eax+44], -1
	lea	ebx, DWORD PTR [esi+eax]
	je	$LN26@changeBuil
	cmp	BYTE PTR [ebx+2256], 0
	je	$LN26@changeBuil

; 9380 : 									{
; 9381 : 										szCivKey = kLoopPlayer.getCivilizationTypeKey();

	mov	ecx, ebx
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey

; 9382 : 										if (strcmp(szCivKey, "CIVILIZATION_GERMANY"))

	mov	ecx, OFFSET $SG226396
	npad	1
$LL305@changeBuil:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN306@changeBuil
	test	dl, dl
	je	SHORT $LN307@changeBuil
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN306@changeBuil
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL305@changeBuil
$LN307@changeBuil:
	xor	eax, eax
	jmp	SHORT $LN308@changeBuil
$LN306@changeBuil:
	sbb	eax, eax
	sbb	eax, -1
$LN308@changeBuil:
	test	eax, eax
	je	$LN26@changeBuil

; 9383 : 										{
; 9384 : 											CvUnit *pLoopUnit;
; 9385 : 											int iUnitLoop;
; 9386 : 											for(pLoopUnit = kLoopPlayer.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kLoopPlayer.nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$226398[esp+312]
	push	ecx
	mov	ecx, ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	ebp, eax
	test	ebp, ebp
	je	$LN26@changeBuil
$LL22@changeBuil:

; 9387 : 											{
; 9388 : 												if(strcmp(pLoopUnit->getUnitInfo().GetType(), "UNIT_ARCHAEOLOGIST") == 0)

	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+176]
	mov	esi, OFFSET $SG226403
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	3
$LL309@changeBuil:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN310@changeBuil
	test	cl, cl
	je	SHORT $LN311@changeBuil
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN310@changeBuil
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL309@changeBuil
$LN311@changeBuil:
	xor	eax, eax
	jmp	SHORT $LN312@changeBuil
$LN310@changeBuil:
	sbb	eax, eax
	sbb	eax, -1
$LN312@changeBuil:
	test	eax, eax
	jne	SHORT $LN21@changeBuil

; 9389 : 												{
; 9390 : 													if (plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), getX(), getY()) <= 2)

	movsx	edx, WORD PTR [edi+2]
	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jg	SHORT $LN21@changeBuil

; 9391 : 													{
; 9392 : 														gDLL->UnlockAchievement(ACHIEVEMENT_XP2_33);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	275					; 00000113H
	call	edx
$LN21@changeBuil:
	push	0
	lea	eax, DWORD PTR _iUnitLoop$226398[esp+312]
	push	eax
	mov	ecx, ebx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	ebp, eax
	test	ebp, ebp
	jne	$LL22@changeBuil

; 9383 : 										{
; 9384 : 											CvUnit *pLoopUnit;
; 9385 : 											int iUnitLoop;
; 9386 : 											for(pLoopUnit = kLoopPlayer.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kLoopPlayer.nextUnit(&iUnitLoop))

	mov	esi, DWORD PTR tv1438[esp+308]
$LN26@changeBuil:

; 9375 : 							{
; 9376 : 								for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	mov	DWORD PTR tv1438[esp+308], esi
	jl	$LL323@changeBuil
$LN25@changeBuil:

; 9393 : 													}
; 9394 : 												}
; 9395 : 											}
; 9396 : 										}
; 9397 : 									}
; 9398 : 								}
; 9399 : 							}
; 9400 : 						}
; 9401 : 					}

	mov	esi, DWORD PTR __imp_??1String@Localization@@UAE@XZ
	lea	ecx, DWORD PTR _locSummary$226375[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 1
	call	esi
	lea	ecx, DWORD PTR _locString$226374[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 0
	call	esi

; 9402 : 					else

	jmp	SHORT $LN316@changeBuil
$LN31@changeBuil:

; 9403 : 					{	
; 9404 : 						ArchaeologyChoiceType eChoice = kPlayer.GetCulture()->GetArchaeologyChoice(this);

	push	edi
	mov	ecx, ebp
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z ; CvPlayerCulture::GetArchaeologyChoice

; 9405 : 						kPlayer.GetCulture()->DoArchaeologyChoice (eChoice);

	push	eax
	mov	ecx, ebp
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z ; CvPlayerCulture::DoArchaeologyChoice
$LN316@changeBuil:

; 9402 : 					else

	mov	ebx, DWORD PTR _ePlayer$[esp+304]
$LN17@changeBuil:

; 9406 : 					}
; 9407 : 				}
; 9408 : 			}
; 9409 : 
; 9410 : 			// Constructed Route
; 9411 : 			if(pkBuildInfo->getRoute() != NO_ROUTE)

	mov	ecx, DWORD PTR _pkBuildInfo$[esp+308]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, -1
	je	SHORT $LN317@changeBuil

; 9412 : 			{
; 9413 : 				const RouteTypes eRoute = (RouteTypes)pkBuildInfo->getRoute();

	mov	ecx, DWORD PTR _pkBuildInfo$[esp+308]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	esi, eax

; 9414 : 				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ebp, eax

; 9415 : 				if(pkRouteInfo)

	test	ebp, ebp
	je	SHORT $LN317@changeBuil

; 9416 : 				{
; 9417 : 					setRouteType(eRoute);

	push	esi
	mov	ecx, edi
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType

; 9418 : 
; 9419 : 					// Unowned plot, someone has to foot the bill
; 9420 : 					if(getOwner() == NO_PLAYER)

	cmp	BYTE PTR [edi+4], -1
	jne	SHORT $LN317@changeBuil

; 9421 : 					{
; 9422 : 						if(MustPayMaintenanceHere(ePlayer))

	push	ebx
	mov	ecx, edi
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	test	al, al
	je	SHORT $LN13@changeBuil

; 9423 : 						{
; 9424 : 							kPlayer.GetTreasury()->ChangeBaseImprovementGoldMaintenance(pkRouteInfo->GetGoldMaintenance());

	mov	ecx, ebp
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	mov	ecx, DWORD PTR _kPlayer$[esp+308]
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN13@changeBuil:

; 9425 : 						}
; 9426 : 						SetPlayerResponsibleForRoute(ePlayer);

	movsx	ecx, BYTE PTR [edi+445]
	cmp	ecx, ebx
	je	SHORT $LN317@changeBuil
	mov	BYTE PTR [edi+445], bl
$LN317@changeBuil:

; 9427 : 					}
; 9428 : 				}
; 9429 : 			}
; 9430 : 
; 9431 : 			// Remove Feature
; 9432 : 			if(getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [edi+432]
	cmp	al, -1
	je	$LN321@changeBuil

; 9433 : 			{
; 9434 : 				if(pkBuildInfo->isFeatureRemove(getFeatureType()))

	mov	ecx, DWORD PTR _pkBuildInfo$[esp+308]
	movsx	edx, al
	push	edx
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	$LN321@changeBuil

; 9435 : 				{
; 9436 : 					CvAssertMsg(ePlayer != NO_PLAYER, "ePlayer should be valid");
; 9437 : 
; 9438 : 					iProduction = getFeatureProduction(eBuild, ePlayer, &pCity);

	mov	ecx, DWORD PTR _eBuild$[esp+304]
	lea	eax, DWORD PTR _pCity$[esp+308]
	push	eax
	push	ebx
	push	ecx
	mov	ecx, edi
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
	mov	DWORD PTR _iProduction$[esp+308], eax

; 9439 : 
; 9440 : 					if(iProduction > 0)

	test	eax, eax
	jle	$LN319@changeBuil

; 9441 : 					{
; 9442 : 						pCity->changeFeatureProduction(iProduction);

	mov	ebp, DWORD PTR _pCity$[esp+308]
	push	eax
	mov	ecx, ebp
	call	?changeFeatureProduction@CvCity@@QAEXH@Z ; CvCity::changeFeatureProduction

; 9443 : 						if(pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ebp+84]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	$LN319@changeBuil

; 9444 : 						{
; 9445 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_CLEARING_FEATURE_RESOURCE", GC.getFeatureInfo(getFeatureType())->GetTextKey(), iProduction, pCity->getNameKey());

	mov	ecx, ebp
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	movsx	edx, BYTE PTR [edi+432]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR $T261058[esp+312], eax
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T261059[esp+308], eax
	lea	eax, DWORD PTR $T261058[esp+308]
	push	eax
	lea	ecx, DWORD PTR _iProduction$[esp+312]
	push	ecx
	lea	edx, DWORD PTR $T261059[esp+316]
	push	edx
	lea	eax, DWORD PTR $T261060[esp+320]
	push	OFFSET $SG226430
	push	eax
	call	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 5
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T261060[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9446 : 							GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	lea	ecx, DWORD PTR _strBuffer$[esp+308]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	ecx, DWORD PTR [ebp+84]
	push	0
	mov	esi, DWORD PTR [ebx]
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	edx
	push	0
	push	ecx
	lea	eax, DWORD PTR $T261061[esp+356]
	push	eax
	mov	ecx, ebp
	add	esi, 172				; 000000acH
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	edx, DWORD PTR [esi]
	push	eax
	push	0
	mov	ecx, ebx
	call	edx
	mov	ebx, DWORD PTR _ePlayer$[esp+304]
$LN319@changeBuil:

; 9447 : 						}
; 9448 : 					}
; 9449 : #ifdef NQ_FOOD_FROM_CHOPS
; 9450 : 					int iFood = getFeatureFood(eBuild, ePlayer, &pCity);

	mov	ecx, DWORD PTR _eBuild$[esp+304]
	lea	eax, DWORD PTR _pCity$[esp+308]
	push	eax
	push	ebx
	push	ecx
	mov	ecx, edi
	call	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureFood
	mov	DWORD PTR _iFood$226432[esp+308], eax

; 9451 : 					if (iFood > 0)

	test	eax, eax
	jle	$LN320@changeBuil

; 9452 : 					{
; 9453 : 						pCity->changeFood(iFood);

	mov	ebp, DWORD PTR _pCity$[esp+308]
	push	eax
	mov	ecx, ebp
	call	?changeFood@CvCity@@QAEXH@Z		; CvCity::changeFood

; 9454 : 						if(pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [ebp+84]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	$LN320@changeBuil

; 9455 : 						{
; 9456 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_CLEARING_FEATURE_FOOD", GC.getFeatureInfo(getFeatureType())->GetTextKey(), iFood, pCity->getNameKey());

	mov	ecx, ebp
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	movsx	edx, BYTE PTR [edi+432]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR $T261062[esp+312], eax
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T261063[esp+308], eax
	lea	eax, DWORD PTR $T261062[esp+308]
	push	eax
	lea	ecx, DWORD PTR _iFood$226432[esp+312]
	push	ecx
	lea	edx, DWORD PTR $T261063[esp+316]
	push	edx
	lea	eax, DWORD PTR $T261064[esp+320]
	push	OFFSET $SG226438
	push	eax
	call	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T261064[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9457 : 							GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	lea	ecx, DWORD PTR _strBuffer$[esp+308]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	ecx, DWORD PTR [ebp+84]
	push	0
	mov	esi, DWORD PTR [ebx]
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	edx
	push	0
	push	ecx
	lea	eax, DWORD PTR $T261065[esp+356]
	push	eax
	mov	ecx, ebp
	add	esi, 172				; 000000acH
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	edx, DWORD PTR [esi]
	push	eax
	push	0
	mov	ecx, ebx
	call	edx
	mov	ebx, DWORD PTR _ePlayer$[esp+304]
$LN320@changeBuil:

; 9458 : 						}
; 9459 : 					}
; 9460 : #endif
; 9461 : 					setFeatureType(NO_FEATURE);

	push	-1
	push	-1
	mov	ecx, edi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType
$LN321@changeBuil:

; 9462 : 				}
; 9463 : 			}
; 9464 : 
; 9465 : 			// Repairing a Pillaged Tile
; 9466 : 			if(pkBuildInfo->isRepair())

	mov	esi, DWORD PTR _pkBuildInfo$[esp+308]
	mov	ecx, esi
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	test	al, al
	je	SHORT $LN324@changeBuil

; 9467 : 			{
; 9468 : 				if(IsImprovementPillaged())

	mov	al, BYTE PTR [edi+461]
	test	al, 1
	je	SHORT $LN5@changeBuil

; 9469 : 				{
; 9470 : 					SetImprovementPillaged(false);

	push	0
	mov	ecx, edi
	call	?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged
	jmp	SHORT $LN324@changeBuil
$LN5@changeBuil:

; 9471 : 				}
; 9472 : 				else if(IsRoutePillaged())

	test	al, 2
	je	SHORT $LN324@changeBuil

; 9473 : 				{
; 9474 : 					SetRoutePillaged(false);

	push	0
	mov	ecx, edi
	call	?SetRoutePillaged@CvPlot@@QAEX_N@Z	; CvPlot::SetRoutePillaged
$LN324@changeBuil:

; 9475 : 				}
; 9476 : 			}
; 9477 : 
; 9478 : 			if(pkBuildInfo->IsRemoveRoute())

	mov	ecx, esi
	call	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ	; CvBuildInfo::IsRemoveRoute
	test	al, al
	je	SHORT $LN2@changeBuil

; 9479 : 			{
; 9480 : 				setRouteType(NO_ROUTE);

	push	-1
	mov	ecx, edi
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType
$LN2@changeBuil:

; 9481 : 			}
; 9482 : 
; 9483 : 			bFinished = true;
; 9484 : 
; 9485 : 			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	mov	BYTE PTR _bFinished$[esp+308], 1
	call	edx
	mov	esi, eax

; 9486 : 			if(pkScriptSystem)

	test	esi, esi
	je	SHORT $LN326@changeBuil

; 9487 : 			{
; 9488 : 				CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226447[esp+308]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 9489 : 				args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$226447[esp+308]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	ebx
	mov	BYTE PTR __$EHRec$[esp+320], 7
	call	edx

; 9490 : 				args->Push(getX());

	mov	ecx, DWORD PTR _args$226447[esp+308]
	movsx	edx, WORD PTR [edi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	call	eax

; 9491 : 				args->Push(getY());

	mov	ecx, DWORD PTR _args$226447[esp+308]
	movsx	eax, WORD PTR [edi+2]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 9492 : 				args->Push(eImprovement);

	mov	ecx, DWORD PTR _args$226447[esp+308]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _eImprovement$226360[esp+308]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	call	eax

; 9493 : 
; 9494 : 				bool bResult;
; 9495 : 				LuaSupport::CallHook(pkScriptSystem, "BuildFinished", args.get(), bResult);

	mov	edx, DWORD PTR _args$226447[esp+308]
	lea	ecx, DWORD PTR _bResult$226448[esp+308]
	push	ecx
	push	edx
	push	OFFSET $SG226449
	push	esi
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 9496 : 			}

	lea	ecx, DWORD PTR _args$226447[esp+308]
	mov	BYTE PTR __$EHRec$[esp+316], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN326@changeBuil:
	pop	esi
$LN1@changeBuil:

; 9497 : 		}
; 9498 : 	}
; 9499 : 
; 9500 : 	return bFinished;

	lea	ecx, DWORD PTR _strBuffer$[esp+304]
	mov	DWORD PTR __$EHRec$[esp+312], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR _bFinished$[esp+304]
	pop	ebp
$LN47@changeBuil:

; 9501 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+300]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 292				; 00000124H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _locString$226374[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _locSummary$226375[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR $T261057[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strSummary$226379[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR $T261060[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T261064[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR _args$226447[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z ENDP ; CvPlot::changeBuildProgress
PUBLIC	?read@CvPlot@@QAEXAAVFDataStream@@@Z		; CvPlot::read
EXTRN	?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z:PROC ; BuildArrayHelpers::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator>>
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4RouteTypes@@@Z:PROC ; operator>>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$?read@CvPlot@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@CvPlot@@QAEXAAVFDataStream@@@Z$0
__ehfuncinfo$?read@CvPlot@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?read@CvPlot@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?read@CvPlot@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_bitPackWorkaround$ = -70				; size = 1
_hasScriptData$ = -69					; size = 1
_uiVersion$ = -68					; size = 4
_uLength$ = -64						; size = 4
_iCount$ = -60						; size = 4
_Data$226912 = -56					; size = 8
$T261780 = -48						; size = 8
$T261745 = -48						; size = 8
_scriptData$226889 = -40				; size = 28
__$EHRec$ = -12						; size = 12
$T261779 = 8						; size = 4
$T261744 = 8						; size = 4
_kStream$ = 8						; size = 4
?read@CvPlot@@QAEXAAVFDataStream@@@Z PROC		; CvPlot::read, COMDAT
; _this$ = ecx

; 10054: {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?read@CvPlot@@QAEXAAVFDataStream@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 10055: 	int iCount;
; 10056: 
; 10057: 	// Init saved data
; 10058: 	reset();

	push	0
	push	0
	push	0
	mov	esi, ecx
	call	?reset@CvPlot@@QAEXHH_N@Z		; CvPlot::reset

; 10059: 
; 10060: 	// Version number to maintain backwards compatibility
; 10061: 	uint uiVersion;
; 10062: 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+84]
	lea	eax, DWORD PTR _uiVersion$[esp+88]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 10063: 	CvAssertMsg(uiVersion <= g_CurrentCvPlotVersion, "Unexpected Version.  This could be caused by serialization errors.");
; 10064: 
; 10065: 	kStream >> m_iX;

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10066: 	kStream >> m_iY;

	lea	ecx, DWORD PTR [esi+2]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10067: 	kStream >> m_iArea;

	lea	edx, DWORD PTR [esi+356]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10068: 	kStream >> m_iFeatureVariety;

	lea	eax, DWORD PTR [esi+453]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10069: 	kStream >> m_iOwnershipDuration;

	lea	ecx, DWORD PTR [esi+380]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10070: 	kStream >> m_iImprovementDuration;

	lea	edx, DWORD PTR [esi+382]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10071: 	kStream >> m_iUpgradeProgress;

	lea	eax, DWORD PTR [esi+384]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10072: 	kStream >> m_iCulture;

	lea	ecx, DWORD PTR [esi+386]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10073: 	kStream >> m_iNumMajorCivsRevealed;

	lea	edx, DWORD PTR [esi+454]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10074: 	kStream >> m_iCityRadiusCount;

	lea	eax, DWORD PTR [esi+455]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10075: 	kStream >> m_iReconCount;

	lea	ecx, DWORD PTR [esi+456]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10076: 	kStream >> m_iRiverCrossingCount;

	lea	edx, DWORD PTR [esi+457]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10077: 	kStream >> m_iResourceNum;

	lea	eax, DWORD PTR [esi+458]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10078: 	kStream >> m_cBuilderAIScratchPadPlayer;

	lea	ecx, DWORD PTR [esi+368]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10079: 	kStream >> m_sBuilderAIScratchPadTurn;

	lea	edx, DWORD PTR [esi+370]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10080: 	kStream >> m_sBuilderAIScratchPadValue;

	lea	eax, DWORD PTR [esi+372]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10081: 	kStream >> m_eBuilderAIScratchPadRoute;

	lea	ecx, DWORD PTR [esi+376]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4RouteTypes@@@Z ; operator>>
	add	esp, 8

; 10082: 	kStream >> m_iLandmass;

	lea	edx, DWORD PTR [esi+360]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10083: 	kStream >> m_uiTradeRouteBitFlags;

	lea	eax, DWORD PTR [esi+388]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 10084: 
; 10085: 	// the following members specify bit packing and do not resolve to
; 10086: 	// any serializable type.
; 10087: 	bool bitPackWorkaround;
; 10088: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[esp+88]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10089: 	m_bStartingPlot = bitPackWorkaround;

	movzx	edx, BYTE PTR _bitPackWorkaround$[esp+88]
	add	dl, dl
	add	dl, dl
	xor	dl, BYTE PTR [esi+461]

; 10090: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[esp+88]
	and	dl, 4
	xor	BYTE PTR [esi+461], dl
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10091: 	m_bHills = bitPackWorkaround;

	movzx	ecx, BYTE PTR _bitPackWorkaround$[esp+88]
	add	cl, cl
	add	cl, cl
	add	cl, cl
	xor	cl, BYTE PTR [esi+461]

; 10092: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[esp+88]
	and	cl, 8
	xor	BYTE PTR [esi+461], cl
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10093: 	m_bNEOfRiver = bitPackWorkaround;

	movzx	eax, BYTE PTR _bitPackWorkaround$[esp+88]
	shl	al, 4
	xor	al, BYTE PTR [esi+461]

; 10094: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[esp+88]
	and	al, 16					; 00000010H
	xor	BYTE PTR [esi+461], al
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10095: 	m_bWOfRiver = bitPackWorkaround;

	movzx	edx, BYTE PTR _bitPackWorkaround$[esp+88]
	shl	dl, 5
	xor	dl, BYTE PTR [esi+461]

; 10096: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[esp+88]
	and	dl, 32					; 00000020H
	xor	BYTE PTR [esi+461], dl
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10097: 	m_bNWOfRiver = bitPackWorkaround;

	movzx	ecx, BYTE PTR _bitPackWorkaround$[esp+88]
	shl	cl, 6
	xor	cl, BYTE PTR [esi+461]

; 10098: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[esp+88]
	and	cl, 64					; 00000040H
	xor	BYTE PTR [esi+461], cl
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10099: 	m_bPotentialCityWork = bitPackWorkaround;

	movzx	eax, BYTE PTR [esi+461]
	movzx	ecx, BYTE PTR _bitPackWorkaround$[esp+88]
	shl	cl, 7
	and	al, 127					; 0000007fH
	or	al, cl

; 10100: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[esp+88]
	push	edx
	mov	ecx, edi
	mov	BYTE PTR [esi+461], al
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10101: 	m_bImprovementPillaged = bitPackWorkaround;

	movzx	eax, BYTE PTR [esi+461]
	xor	al, BYTE PTR _bitPackWorkaround$[esp+88]

; 10102: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[esp+88]
	and	al, 1
	xor	BYTE PTR [esi+461], al
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10103: 	m_bRoutePillaged = bitPackWorkaround;

	movzx	edx, BYTE PTR _bitPackWorkaround$[esp+88]
	add	dl, dl
	xor	dl, BYTE PTR [esi+461]

; 10104: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[esp+88]
	and	dl, 2
	xor	BYTE PTR [esi+461], dl
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10105: 	m_bBarbCampNotConverting = bitPackWorkaround;

	movzx	ecx, BYTE PTR _bitPackWorkaround$[esp+88]
	add	cl, cl
	add	cl, cl
	xor	cl, BYTE PTR [esi+462]

; 10106: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[esp+88]
	and	cl, 4
	xor	BYTE PTR [esi+462], cl
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10107: 	m_bRoughFeature = bitPackWorkaround;

	movzx	eax, BYTE PTR _bitPackWorkaround$[esp+88]
	add	al, al
	add	al, al
	add	al, al
	xor	al, BYTE PTR [esi+462]

; 10108: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[esp+88]
	and	al, 8
	xor	BYTE PTR [esi+462], al
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10109: 	m_bResourceLinkedCityActive = bitPackWorkaround;

	movzx	edx, BYTE PTR _bitPackWorkaround$[esp+88]
	shl	dl, 4
	xor	dl, BYTE PTR [esi+462]

; 10110: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[esp+88]
	and	dl, 16					; 00000010H
	xor	BYTE PTR [esi+462], dl
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10111: 	m_bImprovedByGiftFromMajor = bitPackWorkaround;

	movzx	ecx, BYTE PTR _bitPackWorkaround$[esp+88]
	shl	cl, 5
	xor	cl, BYTE PTR [esi+462]

; 10112: 
; 10113: 	kStream >> m_eOwner;

	lea	edx, DWORD PTR [esi+4]
	and	cl, 32					; 00000020H
	xor	BYTE PTR [esi+462], cl
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10114: 	kStream >> m_ePlotType;

	lea	eax, DWORD PTR [esi+5]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10115: 	kStream >> m_eTerrainType;

	lea	ecx, DWORD PTR [esi+6]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10116: 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[esp+88], 3
	jb	SHORT $LN54@read

; 10117: 		m_eFeatureType = (FeatureTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	bl, al
	lea	ebp, DWORD PTR [esi+428]
	add	esp, 8
	cmp	bl, BYTE PTR [ebp+4]
	je	SHORT $LN267@read
	mov	eax, DWORD PTR [ebp+8]
	lea	edx, DWORD PTR $T261744[esp+84]
	push	edx
	lea	ecx, DWORD PTR $T261745[esp+92]
	push	ecx
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T261744[esp+92], ebp
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	BYTE PTR [ebp+4], bl

; 10118: 	else

	jmp	SHORT $LN267@read
$LN54@read:

; 10119: 	{
; 10120: 		kStream >> m_eFeatureType;

	mov	edx, DWORD PTR [esi+428]
	mov	eax, DWORD PTR [edx+4]
	lea	ebp, DWORD PTR [esi+428]
	push	edi
	mov	ecx, ebp
	call	eax

; 10121: #ifdef AUI_WARNING_FIXES
; 10122: 		if ((uint)m_eFeatureType >= GC.getNumFeatureInfos())
; 10123: #else
; 10124: 		if ((int)m_eFeatureType >= GC.getNumFeatureInfos())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	movsx	ecx, BYTE PTR [esi+432]
	cmp	ecx, eax
	jl	SHORT $LN267@read

; 10125: #endif
; 10126: 			m_eFeatureType = NO_FEATURE;

	cmp	BYTE PTR [ebp+4], -1
	je	SHORT $LN267@read
	mov	eax, DWORD PTR [ebp+8]
	lea	edx, DWORD PTR $T261779[esp+84]
	push	edx
	lea	ecx, DWORD PTR $T261780[esp+92]
	push	ecx
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T261779[esp+92], ebp
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	BYTE PTR [ebp+4], -1
$LN267@read:

; 10127: 	}
; 10128: 	m_eResourceType = (ResourceTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8

; 10129: 
; 10130: 	if(uiVersion >= 5)

	cmp	DWORD PTR _uiVersion$[esp+88], 5
	mov	BYTE PTR [esi+440], al
	jb	SHORT $LN51@read

; 10131: 	{
; 10132: 		m_eImprovementType = (ImprovementTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	BYTE PTR [esi+441], al

; 10133: 	}
; 10134: 	else

	jmp	SHORT $LN48@read
$LN51@read:

; 10135: 	{
; 10136: 		kStream >> m_eImprovementType;

	lea	ebp, DWORD PTR [esi+441]
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10137: 		// Filter out improvements that have been removed
; 10138: 		if (m_eImprovementType != NO_IMPROVEMENT)

	mov	al, BYTE PTR [ebp]
	cmp	al, -1
	je	SHORT $LN48@read

; 10139: 			if (GC.getImprovementInfo((ImprovementTypes)m_eImprovementType) == NULL)

	movsx	edx, al
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	test	eax, eax
	jne	SHORT $LN48@read

; 10140: 				m_eImprovementType = NO_IMPROVEMENT;

	mov	BYTE PTR [ebp], -1
$LN48@read:

; 10141: 	}
; 10142: 
; 10143: 	if (uiVersion >= 7)

	cmp	DWORD PTR _uiVersion$[esp+88], 7
	jb	SHORT $LN47@read

; 10144: 	{
; 10145: 		m_eImprovementTypeUnderConstruction = (ImprovementTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	BYTE PTR [esi+442], al

; 10146: 	}
; 10147: 	else

	jmp	SHORT $LN46@read
$LN47@read:

; 10148: 	{
; 10149: 		m_eImprovementTypeUnderConstruction = NO_IMPROVEMENT;

	mov	BYTE PTR [esi+442], -1
$LN46@read:

; 10150: 	}
; 10151: 
; 10152: 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[esp+88], 2
	jb	SHORT $LN45@read

; 10153: 	{
; 10154: 		kStream >> m_ePlayerBuiltImprovement;

	lea	eax, DWORD PTR [esi+443]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10155: 	}
; 10156: 	else

	jmp	SHORT $LN44@read
$LN45@read:

; 10157: 	{
; 10158: 		m_ePlayerBuiltImprovement = NO_PLAYER;

	mov	BYTE PTR [esi+443], -1
$LN44@read:

; 10159: 	}
; 10160: 	kStream >> m_ePlayerResponsibleForImprovement;

	lea	ecx, DWORD PTR [esi+444]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10161: 	kStream >> m_ePlayerResponsibleForRoute;

	lea	edx, DWORD PTR [esi+445]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10162: 	kStream >> m_ePlayerThatClearedBarbCampHere;

	lea	eax, DWORD PTR [esi+446]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10163: 	kStream >> m_eRouteType;

	lea	ecx, DWORD PTR [esi+447]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10164: 	kStream >> m_eWorldAnchor;

	lea	edx, DWORD PTR [esi+448]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10165: 	kStream >> m_cWorldAnchorData;

	lea	eax, DWORD PTR [esi+449]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10166: 
; 10167: 	kStream >> m_eRiverEFlowDirection;

	lea	ecx, DWORD PTR [esi+450]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10168: 	kStream >> m_eRiverSEFlowDirection;

	lea	edx, DWORD PTR [esi+451]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10169: 	kStream >> m_eRiverSWFlowDirection;

	lea	eax, DWORD PTR [esi+452]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10170: 
; 10171: 	kStream >> m_plotCity.eOwner;

	lea	ecx, DWORD PTR [esi+104]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10172: 	kStream >> m_plotCity.iID;

	lea	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10173: 	kStream >> m_workingCity.eOwner;

	lea	eax, DWORD PTR [esi+112]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10174: 	kStream >> m_workingCity.iID;

	lea	ecx, DWORD PTR [esi+116]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10175: 	kStream >> m_workingCityOverride.eOwner;

	lea	edx, DWORD PTR [esi+120]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10176: 	kStream >> m_workingCityOverride.iID;

	lea	eax, DWORD PTR [esi+124]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10177: 	kStream >> m_ResourceLinkedCity.eOwner;

	lea	ecx, DWORD PTR [esi+128]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10178: 	kStream >> m_ResourceLinkedCity.iID;

	lea	edx, DWORD PTR [esi+132]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10179: 	kStream >> m_purchaseCity.eOwner;

	lea	eax, DWORD PTR [esi+136]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10180: 	kStream >> m_purchaseCity.iID;

	lea	ecx, DWORD PTR [esi+140]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10159: 	}
; 10160: 	kStream >> m_ePlayerResponsibleForImprovement;

	xor	ebp, ebp
$LL43@read:

; 10181: 
; 10182: 	for(uint i = 0; i < NUM_YIELD_TYPES; i++)
; 10183: 		kStream >> m_aiYield[i];

	mov	eax, DWORD PTR [esi+144]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read
	add	ebp, 2
	cmp	ebp, 12					; 0000000cH
	jb	SHORT $LL43@read

; 10184: 
; 10185: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	xor	ebp, ebp
$LL40@read:

; 10186: 		kStream >> m_aiFoundValue[i];

	mov	eax, DWORD PTR [esi+148]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebp, 4
	cmp	ebp, 320				; 00000140H
	jb	SHORT $LL40@read

; 10187: 
; 10188: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	xor	ebp, ebp
	npad	3
$LL37@read:

; 10189: 		kStream >> m_aiPlayerCityRadiusCount[i];

	mov	eax, DWORD PTR [esi+152]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read
	inc	ebp
	cmp	ebp, 80					; 00000050H
	jb	SHORT $LL37@read

; 10190: 
; 10191: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
	npad	8
$LL34@read:

; 10192: 	{
; 10193: 		kStream >> m_aiVisibilityCount[i];

	mov	eax, DWORD PTR [esi+156]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10194: 		if (m_aiVisibilityCount[i] < 0)

	mov	edx, DWORD PTR [esi+156]
	cmp	WORD PTR [edx+ebp], 0
	lea	eax, DWORD PTR [edx+ebp]
	jge	SHORT $LN33@read

; 10195: 			m_aiVisibilityCount[i] = 0;

	xor	ecx, ecx
	mov	WORD PTR [eax], cx
$LN33@read:
	add	ebp, 2
	cmp	ebp, 160				; 000000a0H
	jb	SHORT $LL34@read

; 10196: 	}
; 10197: 
; 10198: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
$LL30@read:

; 10199: 		kStream >> m_aiRevealedOwner[i];

	mov	eax, DWORD PTR [esi+160]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read
	inc	ebp
	cmp	ebp, 80					; 00000050H
	jb	SHORT $LL30@read

; 10200: 
; 10201: 	kStream >> m_cRiverCrossing;

	lea	edx, DWORD PTR [esi+460]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read
	lea	ebp, DWORD PTR [esi+8]
	mov	ebx, 4
	npad	2
$LL27@read:

; 10202: 
; 10203: 	for(uint i = 0; i<PlotBoolField::eCount; ++i)
; 10204: 	{
; 10205: 		kStream >> m_bfRevealed.m_dwBits[i];

	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read
	add	ebp, 4
	sub	ebx, 1
	jne	SHORT $LL27@read

; 10206: 	}
; 10207: 
; 10208: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
$LL24@read:

; 10209: 		kStream >> m_abResourceForceReveal[i];

	mov	eax, DWORD PTR [esi+176]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	ebp
	cmp	ebp, 80					; 00000050H
	jb	SHORT $LL24@read

; 10210: 
; 10211: 	if (uiVersion >= 6)
; 10212: 	{
; 10213: 		for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
	cmp	DWORD PTR _uiVersion$[esp+88], 6
	jb	SHORT $LL16@read
$LL20@read:

; 10214: 			m_aeRevealedImprovementType[i] = (ImprovementTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	ebx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	ecx, DWORD PTR [esi+164]
	mov	WORD PTR [ecx+ebp], ax
	add	ebp, 2
	add	esp, 8
	cmp	ebp, 160				; 000000a0H
	jb	SHORT $LL20@read

; 10215: 	}
; 10216: 	else

	jmp	SHORT $LN14@read
$LL16@read:

; 10217: 	{
; 10218: 		for(uint i = 0; i < REALLY_MAX_TEAMS; i++)
; 10219: 		{
; 10220: 			kStream >> m_aeRevealedImprovementType[i];

	mov	eax, DWORD PTR [esi+164]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10221: 			if (m_aeRevealedImprovementType[i] != NO_IMPROVEMENT)

	mov	edx, DWORD PTR [esi+164]
	movzx	eax, WORD PTR [edx+ebp]
	cmp	ax, -1
	je	SHORT $LN15@read

; 10222: 				if (GC.getImprovementInfo((ImprovementTypes)m_aeRevealedImprovementType[i]) == NULL)

	cwde
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	test	eax, eax
	jne	SHORT $LN15@read

; 10223: 					m_aeRevealedImprovementType[i] = NO_IMPROVEMENT;

	mov	ecx, DWORD PTR [esi+164]
	or	edx, -1
	mov	WORD PTR [ecx+ebp], dx
$LN15@read:
	add	ebp, 2
	cmp	ebp, 160				; 000000a0H
	jb	SHORT $LL16@read
$LN14@read:

; 10224: 		}
; 10225: 	}
; 10226: 
; 10227: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	xor	ebp, ebp
	npad	4
$LL11@read:

; 10228: 		kStream >> m_aeRevealedRouteType[i];

	mov	eax, DWORD PTR [esi+168]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read
	add	ebp, 2
	cmp	ebp, 160				; 000000a0H
	jb	SHORT $LL11@read

; 10229: 
; 10230: 	for(uint i = 0; i < MAX_MAJOR_CIVS; i++)

	xor	ebp, ebp
	npad	3
$LL8@read:

; 10231: 		kStream >> m_abNoSettling[i];

	mov	eax, DWORD PTR [esi+172]
	add	eax, ebp
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	ebp
	cmp	ebp, 22					; 00000016H
	jb	SHORT $LL8@read

; 10232: 
; 10233: 	bool hasScriptData = false;
; 10234: 	kStream >> hasScriptData;

	lea	eax, DWORD PTR _hasScriptData$[esp+88]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR _hasScriptData$[esp+92], 0
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10235: 	if(hasScriptData)

	cmp	BYTE PTR _hasScriptData$[esp+88], 0
	je	SHORT $LN5@read

; 10236: 	{
; 10237: 		std::string scriptData;

	lea	ecx, DWORD PTR _scriptData$226889[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 10238: 		kStream >> scriptData;

	lea	ecx, DWORD PTR _scriptData$226889[esp+88]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+104], ebx
	call	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator>>
	add	esp, 8

; 10239: 		setScriptData(scriptData.c_str());

	lea	ecx, DWORD PTR _scriptData$226889[esp+88]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, eax
	mov	eax, DWORD PTR [esi+180]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	push	ebp
	mov	DWORD PTR [esi+180], ebx
	call	DWORD PTR __imp___strdup
	add	esp, 8

; 10240: 	}

	lea	ecx, DWORD PTR _scriptData$226889[esp+88]
	mov	DWORD PTR [esi+180], eax
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@read:

; 10241: 
; 10242: 	SAFE_DELETE_ARRAY(m_paiBuildProgress);

	mov	edx, DWORD PTR [esi+184]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 10243: 	kStream >> iCount;

	lea	eax, DWORD PTR _iCount$[esp+88]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi+184], ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10244: 	if(iCount > 0)

	cmp	DWORD PTR _iCount$[esp+88], ebx
	jle	SHORT $LN268@read

; 10245: 	{
; 10246: 		const int iNumBuildInfos = GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos

; 10247: #ifdef AUI_WARNING_FIXES
; 10248: 		m_paiBuildProgress = FNEW(int[iNumBuildInfos], c_eCiv5GameplayDLL, 0);
; 10249: #else
; 10250: 		m_paiBuildProgress = FNEW(short[iNumBuildInfos], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	ebp, eax
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 10251: #endif
; 10252: 		ZeroMemory(m_paiBuildProgress, sizeof(short) * iNumBuildInfos);

	lea	ecx, DWORD PTR [ebp+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	DWORD PTR [esi+184], eax
	call	_memset

; 10253: 		
; 10254: 		BuildArrayHelpers::Read(kStream, m_paiBuildProgress);

	mov	edx, DWORD PTR [esi+184]
	push	edx
	push	edi
	call	?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z ; BuildArrayHelpers::Read
	add	esp, 24					; 00000018H
$LN268@read:

; 10255: 	}
; 10256: 
; 10257: 	kStream >> m_apaiInvisibleVisibilityCount;

	lea	ebp, DWORD PTR [esi+196]
	mov	ebx, 80					; 00000050H
$LL212@read:
	push	ebp
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read
	add	ebp, 2
	sub	ebx, 1
	jne	SHORT $LL212@read

; 10258: 
; 10259: 	//m_units.Read(kStream);
; 10260: 	UINT uLength;
; 10261: 	kStream >> uLength;

	lea	eax, DWORD PTR _uLength$[esp+88]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 10262: 	for(UINT uIdx = 0; uIdx < uLength; ++uIdx)

	cmp	DWORD PTR _uLength$[esp+88], ebx
	jbe	SHORT $LN1@read
	lea	ebp, DWORD PTR [esi+24]
$LL3@read:

; 10263: 	{
; 10264: 		IDInfo  Data;
; 10265: 
; 10266: 		kStream >> Data.eOwner;

	lea	ecx, DWORD PTR _Data$226912[esp+88]
	or	eax, -1
	push	ecx
	push	edi
	mov	DWORD PTR _Data$226912[esp+96], eax
	mov	DWORD PTR _Data$226912[esp+100], eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10267: 		kStream >> Data.iID;

	lea	edx, DWORD PTR _Data$226912[esp+92]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10268: 
; 10269: 		m_units.insertAtEnd(&Data);

	mov	eax, DWORD PTR [ebp+8]
	mov	BYTE PTR [ebp+76], 0
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN230@read
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN230@read:
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN233@read
	mov	edx, DWORD PTR _Data$226912[esp+88]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _Data$226912[esp+92]
	mov	DWORD PTR [eax+4], ecx
$LN233@read:
	inc	DWORD PTR [ebp+4]
	inc	ebx
	cmp	ebx, DWORD PTR _uLength$[esp+88]
	jb	SHORT $LL3@read
$LN1@read:

; 10270: 	}
; 10271: 
; 10272: 	kStream >> m_cContinentType;

	lea	edx, DWORD PTR [esi+459]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10273: 	kStream >> m_kArchaeologyData;

	lea	eax, DWORD PTR [esi+464]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z ; operator>>
	add	esp, 8

; 10274: 
; 10275: 	updateImpassable();

	mov	ecx, esi
	call	?updateImpassable@CvPlot@@IAEXXZ	; CvPlot::updateImpassable

; 10276: }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@CvPlot@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _scriptData$226889[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?read@CvPlot@@QAEXAAVFDataStream@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?read@CvPlot@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@CvPlot@@QAEXAAVFDataStream@@@Z ENDP		; CvPlot::read
PUBLIC	?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$262022 = -4					; size = 1
?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN10@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR __Cat$262022[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN10@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T262039 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T262039[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0CvPlot@@QAE@XZ				; CvPlot::CvPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
xdata$x	SEGMENT
__ehfuncinfo$??0CvPlot@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvPlot@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvPlot@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$3
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlot@@QAE@XZ
_TEXT	SEGMENT
$T262158 = -60						; size = 4
$T262103 = -56						; size = 4
_this$ = -52						; size = 4
$T262104 = -48						; size = 8
$T262102 = -40						; size = 28
__$EHRec$ = -12						; size = 12
??0CvPlot@@QAE@XZ PROC					; CvPlot::CvPlot, COMDAT
; _this$ = ecx

; 153  : {

	push	-1
	push	__ehhandler$??0CvPlot@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	lea	eax, DWORD PTR [esi+36]
	push	edi
	mov	DWORD PTR _this$[esp+76], esi
	mov	DWORD PTR [esi+32], 8
	mov	DWORD PTR [esi+24], eax
	xor	eax, eax
	mov	DWORD PTR [esi+28], eax
	or	edi, -1
	mov	DWORD PTR [esi+104], edi
	mov	DWORD PTR [esi+108], edi
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+116], edi
	mov	DWORD PTR [esi+120], edi
	mov	DWORD PTR [esi+124], edi
	mov	DWORD PTR [esi+128], edi
	mov	DWORD PTR [esi+132], edi
	mov	DWORD PTR [esi+136], edi
	mov	DWORD PTR [esi+140], edi
	mov	DWORD PTR __$EHRec$[esp+84], 1
	mov	DWORD PTR [esi+188], eax
	mov	BYTE PTR [esi+192], al
	lea	ebp, DWORD PTR [esi+392]
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+84], 2
	call	??0FAutoArchive@@QAE@XZ			; FAutoArchive::FAutoArchive
	mov	DWORD PTR [ebp], OFFSET ??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@
	mov	DWORD PTR [ebp+32], esi
	push	OFFSET $SG222132
	lea	ecx, DWORD PTR $T262102[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	1
	push	ebp
	lea	eax, DWORD PTR $T262102[esp+84]
	lea	ebx, DWORD PTR [esi+428]
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+96], 4
	call	??0FAutoVariableBase@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVFAutoArchive@@_N@Z ; FAutoVariableBase::FAutoVariableBase
	mov	DWORD PTR [ebx], OFFSET ??_7?$FAutoVariable@DVCvPlot@@@@6B@
	mov	BYTE PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], ebp
	lea	ecx, DWORD PTR $T262102[esp+76]
	mov	BYTE PTR __$EHRec$[esp+84], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 154  : 	FSerialization::plotsToCheck.insert(this);

	lea	ecx, DWORD PTR $T262103[esp+76]
	push	ecx
	lea	edx, DWORD PTR $T262104[esp+80]
	xor	ebx, ebx
	push	edx
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	mov	DWORD PTR [esi+464], ebx
	mov	DWORD PTR [esi+468], edi
	mov	DWORD PTR [esi+472], edi
	mov	DWORD PTR [esi+476], edi
	mov	DWORD PTR [esi+480], edi
	mov	DWORD PTR $T262103[esp+84], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert

; 155  : 	m_paiBuildProgress = NULL;
; 156  : 
; 157  : 	m_szScriptData = NULL;
; 158  : 
; 159  : 	m_cContinentType = 0;
; 160  : 	m_cRiverCrossing = 0;
; 161  : 
; 162  : 	reset(0, 0, true);

	push	1
	push	ebx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR [esi+184], ebx
	mov	DWORD PTR [esi+180], ebx
	mov	BYTE PTR [esi+459], bl
	mov	BYTE PTR [esi+460], bl
	call	?reset@CvPlot@@QAEXHH_N@Z		; CvPlot::reset
	pop	edi

; 163  : }

	mov	eax, esi
	pop	esi
	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlot@@QAE@XZ$5:
	mov	ecx, DWORD PTR $T262158[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
__unwindfunclet$??0CvPlot@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
__unwindfunclet$??0CvPlot@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 188				; 000000bcH
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$??0CvPlot@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ
__unwindfunclet$??0CvPlot@@QAE@XZ$3:
	lea	ecx, DWORD PTR $T262102[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??0CvPlot@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	jmp	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
__ehhandler$??0CvPlot@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPlot@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlot@@QAE@XZ ENDP					; CvPlot::CvPlot
PUBLIC	?init@CvPlot@@QAEXHH@Z				; CvPlot::init
; Function compile flags: /Ogtpy
;	COMDAT ?init@CvPlot@@QAEXHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?init@CvPlot@@QAEXHH@Z PROC				; CvPlot::init, COMDAT
; _this$ = ecx

; 176  : 	//--------------------------------
; 177  : 	// Init saved data
; 178  : 	reset(iX, iY);

	mov	eax, DWORD PTR _iY$[esp-4]
	mov	edx, DWORD PTR _iX$[esp-4]
	push	0
	push	eax
	push	edx
	call	?reset@CvPlot@@QAEXHH_N@Z		; CvPlot::reset

; 179  : 
; 180  : 	//--------------------------------
; 181  : 	// Init non-saved data
; 182  : 
; 183  : 	//--------------------------------
; 184  : 	// Init other game data
; 185  : }

	ret	8
?init@CvPlot@@QAEXHH@Z ENDP				; CvPlot::init
_TEXT	ENDS
PUBLIC	?erase@CvPlot@@QAEX_N@Z				; CvPlot::erase
EXTRN	?kill@CvCity@@QAEXXZ:PROC			; CvCity::kill
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?erase@CvPlot@@QAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$0
__ehfuncinfo$?erase@CvPlot@@QAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@CvPlot@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?erase@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_oldUnits$ = -228					; size = 216
__$EHRec$ = -12						; size = 12
_bEraseUnits$ = 8					; size = 1
?erase@CvPlot@@QAEX_N@Z PROC				; CvPlot::erase, COMDAT
; _this$ = ecx

; 346  : {

	push	-1
	push	__ehhandler$?erase@CvPlot@@QAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	edi
	mov	edi, ecx

; 347  : 	IDInfo* pUnitNode;
; 348  : 	CvCity* pCity;
; 349  : 	CvUnit* pLoopUnit;
; 350  : 	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;

	mov	eax, 25					; 00000019H
	lea	ecx, DWORD PTR _oldUnits$[esp+248]
	mov	DWORD PTR _oldUnits$[esp+244], eax
	mov	DWORD PTR _oldUnits$[esp+236], ecx
	xor	ebx, ebx
	mov	DWORD PTR _oldUnits$[esp+240], ebx
	mov	DWORD PTR __$EHRec$[esp+244], 1

; 351  : 
; 352  : 	// kill units
; 353  : 	if (bEraseUnits)

	cmp	BYTE PTR _bEraseUnits$[esp+232], bl
	je	$LN3@erase@5

; 354  : 	{
; 355  : 		oldUnits.clear();

	xor	ecx, ecx
	push	esi
	mov	DWORD PTR _oldUnits$[esp+244], ecx

; 356  : 
; 357  : 		pUnitNode = headUnitNode();

	cmp	DWORD PTR [edi+28], ebx
	jbe	SHORT $LN35@erase@5
	mov	esi, DWORD PTR [edi+24]
	jmp	SHORT $LN34@erase@5
$LN35@erase@5:
	xor	esi, esi
$LN34@erase@5:

; 358  : 
; 359  : 		while (pUnitNode != NULL)

	cmp	esi, ebx
	je	$LN176@erase@5

; 362  : 			pUnitNode = nextUnitNode(pUnitNode);

	jmp	SHORT $LN6@erase@5
	npad	5
$LL174@erase@5:
	mov	eax, DWORD PTR _oldUnits$[esp+248]
$LN6@erase@5:

; 360  : 		{
; 361  : 			oldUnits.insertAtEnd(pUnitNode);

	mov	BYTE PTR _oldUnits$[esp+452], bl
	cmp	ecx, eax
	jne	SHORT $LN44@erase@5
	push	eax
	lea	ecx, DWORD PTR _oldUnits$[esp+244]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN44@erase@5:
	mov	edx, DWORD PTR _oldUnits$[esp+240]
	mov	eax, DWORD PTR _oldUnits$[esp+244]
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	eax, ebx
	je	SHORT $LN47@erase@5
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
$LN47@erase@5:

; 362  : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR _oldUnits$[esp+244]
	sub	esi, eax
	add	esi, 8
	inc	ecx
	sar	esi, 3
	mov	DWORD PTR _oldUnits$[esp+244], ecx
	cmp	esi, DWORD PTR [edi+28]
	jae	SHORT $LN58@erase@5
	lea	esi, DWORD PTR [eax+esi*8]
	jmp	SHORT $LN57@erase@5
$LN58@erase@5:
	xor	esi, esi
$LN57@erase@5:

; 358  : 
; 359  : 		while (pUnitNode != NULL)

	cmp	esi, ebx
	jne	SHORT $LL174@erase@5

; 363  : 		}
; 364  : 
; 365  : 		pUnitNode = oldUnits.head();

	cmp	ecx, ebx
	jbe	SHORT $LN176@erase@5
	mov	esi, DWORD PTR _oldUnits$[esp+240]

; 366  : 
; 367  : 		while (pUnitNode != NULL)

	cmp	esi, ebx
	je	SHORT $LN176@erase@5
$LL4@erase@5:

; 368  : 		{
; 369  : 			pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	jl	SHORT $LN73@erase@5
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN73@erase@5
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+ecx+4472]
	mov	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+4472]
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	edx
	jmp	SHORT $LN74@erase@5
$LN73@erase@5:
	xor	eax, eax
$LN74@erase@5:

; 370  : 			pUnitNode = oldUnits.next(pUnitNode);

	mov	ecx, DWORD PTR _oldUnits$[esp+240]
	sub	esi, ecx
	add	esi, 8
	sar	esi, 3
	cmp	esi, DWORD PTR _oldUnits$[esp+244]
	jae	SHORT $LN83@erase@5
	lea	esi, DWORD PTR [ecx+esi*8]
	jmp	SHORT $LN82@erase@5
$LN83@erase@5:
	xor	esi, esi
$LN82@erase@5:

; 371  : 
; 372  : 			if (pLoopUnit != NULL)

	cmp	eax, ebx
	je	SHORT $LN2@erase@5

; 373  : 			{
; 374  : 				pLoopUnit->kill(false);

	push	-1
	push	ebx
	mov	ecx, eax
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN2@erase@5:

; 366  : 
; 367  : 		while (pUnitNode != NULL)

	cmp	esi, ebx
	jne	SHORT $LL4@erase@5
$LN176@erase@5:
	pop	esi
$LN3@erase@5:

; 375  : 			}
; 376  : 		}
; 377  : 	}
; 378  : 
; 379  : 	// kill cities
; 380  : 	pCity = getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	cmp	eax, ebx
	jl	SHORT $LN1@erase@5
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@erase@5
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 381  : 	if (pCity != NULL)

	cmp	eax, ebx
	je	SHORT $LN1@erase@5

; 382  : 	{
; 383  : 		pCity->kill();

	mov	ecx, eax
	call	?kill@CvCity@@QAEXXZ			; CvCity::kill
$LN1@erase@5:

; 384  : 	}
; 385  : 
; 386  : 	setResourceType(NO_RESOURCE, 0);

	cmp	BYTE PTR [edi+440], -1
	je	$LN173@erase@5
	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN172@erase@5
	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	movsx	edx, BYTE PTR [edi+440]
	push	-1
	push	edx
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN172@erase@5:
	movsx	eax, BYTE PTR [edi+440]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	-1
	push	eax
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources
	cmp	BYTE PTR [edi+5], 3
	je	SHORT $LN99@erase@5
	movsx	ecx, BYTE PTR [edi+440]
	push	-1
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN99@erase@5:
	mov	ecx, edi
	mov	BYTE PTR [edi+440], -1
	mov	BYTE PTR [edi+458], bl
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN173@erase@5
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [edi+462], 1
$LN173@erase@5:

; 387  : 	setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, edi
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 388  : 	setRouteType(NO_ROUTE);

	push	-1
	mov	ecx, edi
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType

; 389  : 	setFeatureType(NO_FEATURE);

	push	-1
	push	-1
	mov	ecx, edi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 390  : 
; 391  : 	// disable rivers
; 392  : 	setNEOfRiver(false, NO_FLOWDIRECTION);

	push	-1
	push	ebx
	mov	ecx, edi
	call	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver

; 393  : 	setNWOfRiver(false, NO_FLOWDIRECTION);

	push	-1
	push	ebx
	mov	ecx, edi
	call	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver

; 394  : 	setWOfRiver(false, NO_FLOWDIRECTION);

	push	-1
	push	ebx
	mov	ecx, edi
	call	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver

; 395  : }

	mov	eax, DWORD PTR _oldUnits$[esp+236]
	lea	ecx, DWORD PTR _oldUnits$[esp+248]
	pop	edi
	mov	DWORD PTR __$EHRec$[esp+240], -1
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN157@erase@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN157@erase@5:
	mov	ecx, DWORD PTR __$EHRec$[esp+228]
	mov	DWORD PTR fs:0, ecx
	add	esp, 228				; 000000e4H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$1:
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$0:
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	jmp	??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
__ehhandler$?erase@CvPlot@@QAEX_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@CvPlot@@QAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@CvPlot@@QAEX_N@Z ENDP				; CvPlot::erase
PUBLIC	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
PUBLIC	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z	; CvPlot::setPlotType
EXTRN	?init@CvArea@@QAEXH_N@Z:PROC			; CvArea::init
EXTRN	?addArea@CvMap@@QAEPAVCvArea@@XZ:PROC		; CvMap::addArea
EXTRN	?deleteArea@CvMap@@QAEXH@Z:PROC			; CvMap::deleteArea
EXTRN	?recalculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::recalculateAreas
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?changeLandPlots@CvMap@@QAEXH@Z:PROC		; CvMap::changeLandPlots
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?isWater@CvTerrainInfo@@QBE_NXZ:PROC		; CvTerrainInfo::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z
_TEXT	SEGMENT
_bWasWater$ = 8						; size = 1
_eNewValue$ = 8						; size = 4
_bRecalculate$ = 12					; size = 1
_iAreaCount$ = 12					; size = 4
_bRebuildGraphics$ = 16					; size = 1
_bEraseUnitsIfWater$ = 20				; size = 1
?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z PROC	; CvPlot::setPlotType, COMDAT
; _this$ = ecx

; 5696 : {

	push	ebx

; 5697 : 	CvArea* pNewArea;
; 5698 : 	CvArea* pCurrArea;
; 5699 : 	CvArea* pLastArea;
; 5700 : 	CvPlot* pLoopPlot;
; 5701 : 	bool bWasWater;
; 5702 : 	bool bRecalculateAreas;
; 5703 : 	int iAreaCount;
; 5704 : 	int iI;
; 5705 : 
; 5706 : 	if(getPlotType() != eNewValue)

	mov	ebx, DWORD PTR _eNewValue$[esp]
	push	esi
	mov	esi, ecx
	mov	al, BYTE PTR [esi+5]
	movsx	ecx, al
	cmp	ecx, ebx
	je	$LN374@setPlotTyp

; 5707 : 	{
; 5708 : 		if((getPlotType() == PLOT_OCEAN) || (eNewValue == PLOT_OCEAN))

	cmp	al, 3
	je	SHORT $LN60@setPlotTyp
	cmp	ebx, 3
	jne	SHORT $LN61@setPlotTyp
$LN60@setPlotTyp:

; 5709 : 		{
; 5710 : 			erase(bEraseUnitsIfWater);

	mov	edx, DWORD PTR _bEraseUnitsIfWater$[esp+4]
	push	edx
	mov	ecx, esi
	call	?erase@CvPlot@@QAEX_N@Z			; CvPlot::erase
$LN61@setPlotTyp:

; 5711 : 		}
; 5712 : 
; 5713 : 		bWasWater = isWater();

	cmp	BYTE PTR [esi+5], 3

; 5714 : 
; 5715 : 		updateSeeFromSight(false);

	push	0
	mov	ecx, esi
	sete	BYTE PTR _bWasWater$[esp+8]
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight

; 5716 : 
; 5717 : 		m_ePlotType = eNewValue;
; 5718 : 
; 5719 : 		updateYield();

	mov	ecx, esi
	mov	BYTE PTR [esi+5], bl
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 5720 : 
; 5721 : 		updateSeeFromSight(true);

	push	1
	mov	ecx, esi
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight

; 5722 : 
; 5723 : 		if((getTerrainType() == NO_TERRAIN) || (GC.getTerrainInfo(getTerrainType())->isWater() != isWater()))

	mov	al, BYTE PTR [esi+6]
	cmp	al, -1
	je	SHORT $LN396@setPlotTyp
	cmp	BYTE PTR [esi+5], 3
	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	sete	bl
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?isWater@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isWater
	cmp	al, bl
	je	SHORT $LN394@setPlotTyp
$LN396@setPlotTyp:

; 5724 : 		{
; 5725 : 			if(isWater())

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN57@setPlotTyp

; 5726 : 			{
; 5727 : 				if(isAdjacentToLand())

	mov	ecx, esi
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	test	al, al
	je	SHORT $LN56@setPlotTyp

; 5728 : 				{
; 5729 : 					setTerrainType(((TerrainTypes)(GC.getSHALLOW_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	eax, DWORD PTR _bRebuildGraphics$[esp+4]
	mov	ebx, DWORD PTR _bRecalculate$[esp+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5730 : 					m_bIsAdjacentToLand = true;

	or	BYTE PTR [esi+462], 64			; 00000040H

; 5731 : 				}
; 5732 : 				else

	jmp	SHORT $LN54@setPlotTyp
$LN56@setPlotTyp:

; 5733 : 				{
; 5734 : 					setTerrainType(((TerrainTypes)(GC.getDEEP_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	edx, DWORD PTR _bRebuildGraphics$[esp+4]
	mov	eax, DWORD PTR _bRecalculate$[esp+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8392
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5735 : 					m_bIsAdjacentToLand = false;

	and	BYTE PTR [esi+462], 191			; 000000bfH

; 5736 : 				}
; 5737 : 			}
; 5738 : 			else

	jmp	SHORT $LN394@setPlotTyp
$LN57@setPlotTyp:

; 5739 : 			{
; 5740 : 				setTerrainType(((TerrainTypes)(GC.getLAND_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	edx, DWORD PTR _bRebuildGraphics$[esp+4]
	mov	eax, DWORD PTR _bRecalculate$[esp+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8388
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN394@setPlotTyp:

; 5736 : 				}
; 5737 : 			}
; 5738 : 			else

	mov	ebx, DWORD PTR _bRecalculate$[esp+4]
$LN54@setPlotTyp:

; 5741 : 			}
; 5742 : 		}
; 5743 : 
; 5744 : 		GC.getStepFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	BYTE PTR [eax+78], 1

; 5745 : 
; 5746 : 		if(bWasWater != isWater())

	cmp	BYTE PTR [esi+5], 3
	sete	dl
	cmp	BYTE PTR _bWasWater$[esp+4], dl
	je	$LN399@setPlotTyp
	push	ebp
	push	edi

; 5747 : 		{
; 5748 : 			if(bRecalculate)

	test	bl, bl
	je	SHORT $LN49@setPlotTyp

; 5749 : 			{
; 5750 : 				for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebp, ebp
	npad	3
$LL51@setPlotTyp:

; 5751 : 				{
; 5752 : 					pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 5753 : 
; 5754 : 					if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN50@setPlotTyp

; 5755 : 					{
; 5756 : 						if(pLoopPlot->isWater())

	cmp	BYTE PTR [edi+5], 3
	jne	SHORT $LN50@setPlotTyp

; 5757 : 						{
; 5758 : 							if(pLoopPlot->isAdjacentToLand())

	mov	ecx, edi
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	test	al, al
	je	SHORT $LN46@setPlotTyp

; 5759 : 							{
; 5760 : 								pLoopPlot->setTerrainType(((TerrainTypes)(GC.getSHALLOW_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	edx, DWORD PTR _bRebuildGraphics$[esp+12]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	push	edx
	push	ebx
	push	eax
	mov	ecx, edi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5761 : 								m_bIsAdjacentToLand = true;

	or	BYTE PTR [esi+462], 64			; 00000040H

; 5762 : 							}
; 5763 : 							else

	jmp	SHORT $LN50@setPlotTyp
$LN46@setPlotTyp:

; 5764 : 							{
; 5765 : 								pLoopPlot->setTerrainType(((TerrainTypes)(GC.getDEEP_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	ecx, DWORD PTR _bRebuildGraphics$[esp+12]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8392
	push	ecx
	push	ebx
	push	edx
	mov	ecx, edi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5766 : 								m_bIsAdjacentToLand = false;

	and	BYTE PTR [esi+462], 191			; 000000bfH
$LN50@setPlotTyp:
	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL51@setPlotTyp
$LN49@setPlotTyp:

; 5767 : 							}
; 5768 : 						}
; 5769 : 					}
; 5770 : 				}
; 5771 : 			}
; 5772 : 
; 5773 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	edi, edi
$LL44@setPlotTyp:

; 5774 : 			{
; 5775 : 				pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 5776 : 
; 5777 : 				if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN43@setPlotTyp

; 5778 : 				{
; 5779 : 					pLoopPlot->updateYield();

	mov	ecx, eax
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN43@setPlotTyp:
	inc	edi
	cmp	edi, 6
	jl	SHORT $LL44@setPlotTyp

; 5780 : 				}
; 5781 : 			}
; 5782 : 
; 5783 : 			for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	xor	edi, edi
	npad	3
$LL40@setPlotTyp:

; 5784 : 			{
; 5785 : 				pLoopPlot = plotCity(getX(), getY(), iI);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH

; 5786 : 
; 5787 : 				if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN39@setPlotTyp

; 5788 : 				{
; 5789 : 					pLoopPlot->updatePotentialCityWork();

	mov	ecx, eax
	call	?updatePotentialCityWork@CvPlot@@QAEXXZ	; CvPlot::updatePotentialCityWork
$LN39@setPlotTyp:
	inc	edi
	cmp	edi, 37					; 00000025H
	jl	SHORT $LL40@setPlotTyp

; 5790 : 				}
; 5791 : 			}
; 5792 : 
; 5793 : 			GC.getMap().changeLandPlots((isWater()) ? -1 : 1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	xor	edx, edx
	cmp	BYTE PTR [esi+5], 3
	setne	dl
	lea	edx, DWORD PTR [edx+edx-1]
	push	edx
	call	?changeLandPlots@CvMap@@QAEXH@Z		; CvMap::changeLandPlots

; 5794 : 
; 5795 : 			if(getResourceType() != NO_RESOURCE)

	mov	al, BYTE PTR [esi+440]
	cmp	al, -1
	je	SHORT $LN36@setPlotTyp

; 5796 : 			{
; 5797 : 				GC.getMap().changeNumResourcesOnLand(getResourceType(), ((isWater()) ? -1 : 1));

	xor	ecx, ecx
	cmp	BYTE PTR [esi+5], 3
	movsx	edx, al
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN36@setPlotTyp:

; 5798 : 			}
; 5799 : 
; 5800 : 			if(isOwned())

	mov	al, BYTE PTR [esi+4]
	cmp	al, -1
	je	SHORT $LN395@setPlotTyp

; 5801 : 			{
; 5802 : 				GET_PLAYER(getOwner()).changeTotalLand((isWater()) ? -1 : 1);

	xor	ecx, ecx
	cmp	BYTE PTR [esi+5], 3
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx-1]
	push	ecx
	movsx	ecx, al
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeTotalLand@CvPlayer@@QAEXH@Z	; CvPlayer::changeTotalLand

; 5803 : 				GET_TEAM(getTeam()).changeTotalLand((isWater()) ? -1 : 1);

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN267@setPlotTyp
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN274@setPlotTyp
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN266@setPlotTyp
$LN274@setPlotTyp:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN266@setPlotTyp
$LN267@setPlotTyp:
	or	ecx, -1
$LN266@setPlotTyp:
	xor	edx, edx
	cmp	BYTE PTR [esi+5], 3
	setne	dl
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	edx, DWORD PTR [edx+edx-1]
	push	edx
	call	?changeTotalLand@CvTeam@@QAEXH@Z	; CvTeam::changeTotalLand
$LN395@setPlotTyp:

; 5804 : 			}
; 5805 : 
; 5806 : 			if(bRecalculate)

	test	bl, bl
	je	$LN400@setPlotTyp

; 5807 : 			{
; 5808 : 				pNewArea = NULL;

	xor	ebx, ebx

; 5809 : 				bRecalculateAreas = false;
; 5810 : 
; 5811 : 				if(isWater())
; 5812 : 				{
; 5813 : 					for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	xor	ebp, ebp
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LL23@setPlotTyp
$LL32@setPlotTyp:

; 5814 : 					{
; 5815 : 						pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 5816 : 
; 5817 : 						if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN31@setPlotTyp

; 5818 : 						{
; 5819 : 							if(pLoopPlot->area()->isWater())

	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	test	al, al
	je	SHORT $LN31@setPlotTyp

; 5820 : 							{
; 5821 : 								if(pNewArea == NULL)
; 5822 : 								{
; 5823 : 									pNewArea = pLoopPlot->area();

	mov	edi, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	ebx, ebx
	jne	SHORT $LN27@setPlotTyp
	mov	ebx, eax
	jmp	SHORT $LN31@setPlotTyp
$LN27@setPlotTyp:

; 5824 : 								}
; 5825 : 								else if(pNewArea != pLoopPlot->area())

	cmp	ebx, eax
	jne	$LN397@setPlotTyp
$LN31@setPlotTyp:

; 5809 : 				bRecalculateAreas = false;
; 5810 : 
; 5811 : 				if(isWater())
; 5812 : 				{
; 5813 : 					for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL32@setPlotTyp

; 5847 : 								}
; 5848 : 								else if(pNewArea != pLoopPlot->area())

	jmp	SHORT $LN393@setPlotTyp
$LL23@setPlotTyp:

; 5837 : 					{
; 5838 : 						pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	ebp
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 5839 : 
; 5840 : 						if(pLoopPlot != NULL)

	test	edi, edi
	je	SHORT $LN22@setPlotTyp

; 5841 : 						{
; 5842 : 							if(!(pLoopPlot->area()->isWater()))

	mov	eax, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	test	al, al
	jne	SHORT $LN22@setPlotTyp

; 5843 : 							{
; 5844 : 								if(pNewArea == NULL)
; 5845 : 								{
; 5846 : 									pNewArea = pLoopPlot->area();

	mov	edi, DWORD PTR [edi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	ebx, ebx
	jne	SHORT $LN18@setPlotTyp
	mov	ebx, eax
	jmp	SHORT $LN22@setPlotTyp
$LN18@setPlotTyp:

; 5847 : 								}
; 5848 : 								else if(pNewArea != pLoopPlot->area())

	cmp	ebx, eax
	jne	SHORT $LN397@setPlotTyp
$LN22@setPlotTyp:

; 5826 : 								{
; 5827 : 									bRecalculateAreas = true;
; 5828 : 									break;
; 5829 : 								}
; 5830 : 							}
; 5831 : 						}
; 5832 : 					}
; 5833 : 				}
; 5834 : 				else
; 5835 : 				{
; 5836 : 					for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL23@setPlotTyp
$LN393@setPlotTyp:

; 5849 : 								{
; 5850 : 									bRecalculateAreas = true;
; 5851 : 									break;
; 5852 : 								}
; 5853 : 							}
; 5854 : 						}
; 5855 : 					}
; 5856 : 				}
; 5857 : 
; 5858 : 				if(!bRecalculateAreas)
; 5859 : 				{
; 5860 : 					pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)(NUM_DIRECTION_TYPES - 1)));

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	5
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection

; 5861 : 
; 5862 : 					if(pLoopPlot != NULL)

	xor	edi, edi
	add	esp, 12					; 0000000cH
	cmp	eax, edi
	je	SHORT $LN14@setPlotTyp

; 5863 : 					{
; 5864 : 						pLastArea = pLoopPlot->area();

	mov	eax, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ebp, eax

; 5865 : 					}
; 5866 : 					else

	jmp	SHORT $LN13@setPlotTyp
$LN14@setPlotTyp:

; 5867 : 					{
; 5868 : 						pLastArea = NULL;

	xor	ebp, ebp
$LN13@setPlotTyp:

; 5869 : 					}
; 5870 : 
; 5871 : 					iAreaCount = 0;

	mov	DWORD PTR _iAreaCount$[esp+12], edi
$LL12@setPlotTyp:

; 5874 : 					{
; 5875 : 						pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	edi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 5876 : 
; 5877 : 						if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN9@setPlotTyp

; 5878 : 						{
; 5879 : 							pCurrArea = pLoopPlot->area();

	mov	eax, DWORD PTR [eax+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea

; 5880 : 						}
; 5881 : 						else

	jmp	SHORT $LN8@setPlotTyp
$LN9@setPlotTyp:

; 5882 : 						{
; 5883 : 							pCurrArea = NULL;

	xor	eax, eax
$LN8@setPlotTyp:

; 5884 : 						}
; 5885 : 
; 5886 : 						if(pCurrArea != pLastArea)

	cmp	eax, ebp
	je	SHORT $LN398@setPlotTyp

; 5887 : 						{
; 5888 : 							iAreaCount++;

	inc	DWORD PTR _iAreaCount$[esp+12]
$LN398@setPlotTyp:

; 5872 : 
; 5873 : 					for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	inc	edi
	cmp	edi, 6

; 5889 : 						}
; 5890 : 
; 5891 : 						pLastArea = pCurrArea;

	mov	ebp, eax
	jl	SHORT $LL12@setPlotTyp

; 5892 : 					}
; 5893 : 
; 5894 : 					if(iAreaCount > 2)

	cmp	DWORD PTR _iAreaCount$[esp+12], 2
	jle	SHORT $LN5@setPlotTyp
$LN397@setPlotTyp:

; 5895 : 					{
; 5896 : 						bRecalculateAreas = true;
; 5897 : 					}
; 5898 : 				}
; 5899 : 
; 5900 : 				if(bRecalculateAreas)
; 5901 : 				{
; 5902 : 					GC.getMap().recalculateAreas();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas

; 5903 : 				}
; 5904 : 				else

	jmp	$LN400@setPlotTyp
$LN5@setPlotTyp:

; 5905 : 				{
; 5906 : 					setArea(FFreeList::INVALID_INDEX);

	push	-1
	mov	ecx, esi
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea

; 5907 : 
; 5908 : 					if((area() != NULL) && (area()->getNumTiles() == 1))

	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	test	eax, eax
	je	SHORT $LN3@setPlotTyp
	mov	eax, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, 1
	jne	SHORT $LN3@setPlotTyp

; 5909 : 					{
; 5910 : 						GC.getMap().deleteArea(getArea());

	mov	edx, DWORD PTR [esi+356]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edx
	call	?deleteArea@CvMap@@QAEXH@Z		; CvMap::deleteArea
$LN3@setPlotTyp:

; 5911 : 					}
; 5912 : 
; 5913 : 					if(pNewArea == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@setPlotTyp

; 5914 : 					{
; 5915 : 						pNewArea = GC.getMap().addArea();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?addArea@CvMap@@QAEPAVCvArea@@XZ	; CvMap::addArea

; 5916 : 						pNewArea->init(pNewArea->GetID(), isWater());

	cmp	BYTE PTR [esi+5], 3
	mov	ebx, eax
	mov	edx, DWORD PTR [ebx+4]
	sete	al
	movzx	ecx, al
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?init@CvArea@@QAEXH_N@Z			; CvArea::init
$LN2@setPlotTyp:

; 5917 : 					}
; 5918 : 
; 5919 : 					setArea(pNewArea->GetID());

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	mov	ecx, esi
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea
$LN400@setPlotTyp:
	pop	edi
	pop	ebp
$LN399@setPlotTyp:

; 5920 : 				}
; 5921 : 			}
; 5922 : 		}
; 5923 : 
; 5924 : 		if(bRebuildGraphics && GC.IsGraphicsInitialized())

	cmp	BYTE PTR _bRebuildGraphics$[esp+4], 0
	je	SHORT $LN374@setPlotTyp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	test	al, al
	je	SHORT $LN374@setPlotTyp

; 5925 : 		{
; 5926 : 			//Update terrain graphical
; 5927 : 			setLayoutDirty(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	33					; 00000021H
	call	eax
	or	BYTE PTR [esi+462], 1
$LN374@setPlotTyp:
	pop	esi
	pop	ebx

; 5928 : 		}
; 5929 : 	}
; 5930 : }

	ret	16					; 00000010H
?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ENDP	; CvPlot::setPlotType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z
_TEXT	SEGMENT
_bUpdateSight$ = 8					; size = 1
_eNewValue$ = 8						; size = 4
_bRecalculate$ = 12					; size = 1
_bRebuildGraphics$ = 16					; size = 1
?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z PROC	; CvPlot::setTerrainType, COMDAT
; _this$ = ecx

; 5934 : {

	push	ebx

; 5935 : 	bool bUpdateSight;
; 5936 : 
; 5937 : 	if(getTerrainType() != eNewValue)

	mov	ebx, DWORD PTR _eNewValue$[esp]
	push	esi
	mov	esi, ecx
	mov	al, BYTE PTR [esi+6]
	movsx	ecx, al
	cmp	ecx, ebx
	je	$LN1@setTerrain
	push	edi

; 5938 : 	{
; 5939 : 		if((getTerrainType() != NO_TERRAIN) &&
; 5940 : 		        (eNewValue != NO_TERRAIN) &&
; 5941 : 		        ((GC.getTerrainInfo(getTerrainType())->getSeeFromLevel() != GC.getTerrainInfo(eNewValue)->getSeeFromLevel()) ||
; 5942 : 		         (GC.getTerrainInfo(getTerrainType())->getSeeThroughLevel() != GC.getTerrainInfo(eNewValue)->getSeeThroughLevel())))

	cmp	al, -1
	je	$LN6@setTerrain
	cmp	ebx, -1
	je	$LN6@setTerrain
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getSeeFromLevel
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getSeeFromLevel
	cmp	edi, eax
	jne	SHORT $LN5@setTerrain
	movsx	eax, BYTE PTR [esi+6]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getSeeThroughLevel
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getSeeThroughLevel
	cmp	edi, eax
	je	SHORT $LN6@setTerrain
$LN5@setTerrain:

; 5952 : 		{
; 5953 : 			updateSeeFromSight(false);

	push	0
	mov	ecx, esi
	mov	BYTE PTR _bUpdateSight$[esp+12], 1
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN3@setTerrain:

; 5954 : 		}
; 5955 : 
; 5956 : 		m_eTerrainType = eNewValue;
; 5957 : 
; 5958 : 		updateYield();

	mov	ecx, esi
	mov	BYTE PTR [esi+6], bl
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 5959 : 		updateImpassable();

	mov	ecx, esi
	call	?updateImpassable@CvPlot@@IAEXXZ	; CvPlot::updateImpassable

; 5960 : 
; 5961 : 		if(bUpdateSight)

	cmp	BYTE PTR _bUpdateSight$[esp+8], 0
	pop	edi
	je	SHORT $LN23@setTerrain

; 5962 : 		{
; 5963 : 			updateSeeFromSight(true);

	push	1
	mov	ecx, esi
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN23@setTerrain:

; 5964 : 		}
; 5965 : 
; 5966 : 		const bool bTypeIsWater = GC.getTerrainInfo(getTerrainType())->isWater();

	movsx	eax, BYTE PTR [esi+6]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?isWater@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isWater

; 5967 : 		if(bTypeIsWater != isWater())

	cmp	BYTE PTR [esi+5], 3
	sete	cl
	cmp	al, cl
	je	SHORT $LN1@setTerrain

; 5968 : 		{
; 5969 : 			setPlotType((bTypeIsWater)? PLOT_OCEAN : PLOT_LAND, bRecalculate, bRebuildGraphics);

	mov	edx, DWORD PTR _bRebuildGraphics$[esp+4]
	mov	ecx, DWORD PTR _bRecalculate$[esp+4]
	push	1
	push	edx
	xor	edx, edx
	test	al, al
	setne	dl
	push	ecx
	mov	ecx, esi
	add	edx, 2
	push	edx
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType
$LN1@setTerrain:
	pop	esi
	pop	ebx

; 5970 : 		}
; 5971 : 	}
; 5972 : }

	ret	12					; 0000000cH
$LN6@setTerrain:

; 5943 : 		{
; 5944 : 			bUpdateSight = true;
; 5945 : 		}
; 5946 : 		else
; 5947 : 		{
; 5948 : 			bUpdateSight = false;

	mov	BYTE PTR _bUpdateSight$[esp+8], 0

; 5949 : 		}
; 5950 : 
; 5951 : 		if(bUpdateSight)

	jmp	SHORT $LN3@setTerrain
?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ENDP	; CvPlot::setTerrainType
_TEXT	ENDS
PUBLIC	??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$263324 = -4					; size = 1
??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN12@vector
	mov	ecx, DWORD PTR __Cat$263324[esp+8]
	mov	edx, DWORD PTR [esi+8]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN12@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	pop	ecx
	ret	0
??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T263404 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T263404[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?SyncPlots@FSerialization@@YAXXZ		; FSerialization::SyncPlots
EXTRN	??1FMemoryStream@@UAE@XZ:PROC			; FMemoryStream::~FMemoryStream
EXTRN	?saveDelta@FAutoArchive@@QBEXAAVFDataStream@@AAV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@@Z:PROC ; FAutoArchive::saveDelta
EXTRN	??0FMemoryStream@@QAE@XZ:PROC			; FMemoryStream::FMemoryStream
EXTRN	?hasDeltas@FAutoArchive@@QBE_NXZ:PROC		; FAutoArchive::hasDeltas
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?SyncPlots@FSerialization@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$1
__ehfuncinfo$?SyncPlots@FSerialization@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SyncPlots@FSerialization@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?SyncPlots@FSerialization@@YAXXZ
_TEXT	SEGMENT
__Cat$263825 = -80					; size = 1
_authoritativePlayer$221651 = -80			; size = 4
_callStacks$222066 = -76				; size = 16
_memoryStream$221764 = -60				; size = 48
__$EHRec$ = -12						; size = 12
?SyncPlots@FSerialization@@YAXXZ PROC			; FSerialization::SyncPlots, COMDAT

; 60   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SyncPlots@FSerialization@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 61   : 	if(GC.getGame().isNetworkMultiPlayer())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sub	esp, 68					; 00000044H
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	test	al, al
	je	$LN3@SyncPlots

; 62   : 	{
; 63   : 		PlayerTypes authoritativePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _authoritativePlayer$221651[esp+84], eax

; 64   : 		std::set<CvPlot*>::const_iterator i;
; 65   : 		for(i = plotsToCheck.begin(); i != plotsToCheck.end(); ++i)

	mov	eax, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	edi, DWORD PTR [eax]
	cmp	edi, eax
	je	$LN141@SyncPlots
	push	ebx
	push	ebp
	push	esi
	xor	ebx, ebx
	npad	1
$LL31@SyncPlots:

; 66   : 		{
; 67   : 			const CvPlot* plot = *i;

	mov	esi, DWORD PTR [edi+12]

; 68   : 
; 69   : 			if(plot)

	cmp	esi, ebx
	je	$LN4@SyncPlots

; 70   : 			{
; 71   : 				const FAutoArchive& archive = plot->getSyncArchive();

	lea	ebp, DWORD PTR [esi+392]

; 72   : 				if(archive.hasDeltas())

	mov	ecx, ebp
	call	?hasDeltas@FAutoArchive@@QBE_NXZ	; FAutoArchive::hasDeltas
	test	al, al
	je	$LN4@SyncPlots

; 73   : 				{
; 74   : 					FMemoryStream memoryStream;

	lea	ecx, DWORD PTR _memoryStream$221764[esp+96]
	call	??0FMemoryStream@@QAE@XZ		; FMemoryStream::FMemoryStream
	mov	DWORD PTR __$EHRec$[esp+104], ebx

; 75   : 					std::vector<std::pair<std::string, std::string> > callStacks;

	mov	DWORD PTR _callStacks$222066[esp+100], ebx
	mov	DWORD PTR _callStacks$222066[esp+104], ebx
	mov	DWORD PTR _callStacks$222066[esp+108], ebx

; 76   : 					archive.saveDelta(memoryStream, callStacks);

	lea	eax, DWORD PTR _callStacks$222066[esp+96]
	push	eax
	lea	ecx, DWORD PTR _memoryStream$221764[esp+100]
	push	ecx
	mov	ecx, ebp
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	?saveDelta@FAutoArchive@@QBEXAAVFDataStream@@AAV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@@Z ; FAutoArchive::saveDelta

; 77   : #ifdef AUI_WARNING_FIXES
; 78   : 					gDLL->sendPlotSyncCheck(authoritativePlayer, short(plot->getX()), short(plot->getY()), memoryStream, callStacks);
; 79   : #else
; 80   : 					gDLL->sendPlotSyncCheck(authoritativePlayer, plot->getX(), plot->getY(), memoryStream, callStacks);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+340]
	lea	eax, DWORD PTR _callStacks$222066[esp+96]
	push	eax
	lea	eax, DWORD PTR _memoryStream$221764[esp+100]
	push	eax
	movzx	eax, WORD PTR [esi+2]
	push	eax
	movzx	eax, WORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR _authoritativePlayer$221651[esp+112]
	push	eax
	call	edx

; 81   : #endif
; 82   : 				}

	mov	eax, DWORD PTR _callStacks$222066[esp+100]
	mov	BYTE PTR __$EHRec$[esp+104], bl
	cmp	eax, ebx
	je	SHORT $LN131@SyncPlots
	mov	ecx, DWORD PTR __Cat$263825[esp+96]
	push	ecx
	mov	ecx, DWORD PTR _callStacks$222066[esp+108]
	lea	edx, DWORD PTR _callStacks$222066[esp+100]
	push	edx
	push	ecx
	push	eax
	call	??$_Destroy_range@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@0AAV?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	mov	edx, DWORD PTR _callStacks$222066[esp+116]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 20					; 00000014H
$LN131@SyncPlots:
	lea	ecx, DWORD PTR _memoryStream$221764[esp+96]
	mov	DWORD PTR _callStacks$222066[esp+100], ebx
	mov	DWORD PTR _callStacks$222066[esp+104], ebx
	mov	DWORD PTR _callStacks$222066[esp+108], ebx
	mov	DWORD PTR __$EHRec$[esp+104], -1
	call	??1FMemoryStream@@UAE@XZ		; FMemoryStream::~FMemoryStream
$LN4@SyncPlots:

; 64   : 		std::set<CvPlot*>::const_iterator i;
; 65   : 		for(i = plotsToCheck.begin(); i != plotsToCheck.end(); ++i)

	cmp	BYTE PTR [edi+17], bl
	jne	SHORT $LN138@SyncPlots
	mov	ecx, DWORD PTR [edi+8]
	cmp	BYTE PTR [ecx+17], bl
	jne	SHORT $LN135@SyncPlots
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], bl
	jne	SHORT $LN45@SyncPlots
$LL46@SyncPlots:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], bl
	je	SHORT $LL46@SyncPlots
$LN45@SyncPlots:
	mov	edi, ecx
	jmp	SHORT $LN138@SyncPlots
$LN135@SyncPlots:
	mov	eax, DWORD PTR [edi+4]
	cmp	BYTE PTR [eax+17], bl
	jne	SHORT $LN29@SyncPlots
	npad	5
$LL30@SyncPlots:
	cmp	edi, DWORD PTR [eax+8]
	jne	SHORT $LN29@SyncPlots
	mov	edi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], bl
	je	SHORT $LL30@SyncPlots
$LN29@SyncPlots:
	mov	edi, eax
$LN138@SyncPlots:
	cmp	edi, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	jne	$LL31@SyncPlots
	pop	esi
	pop	ebp
	pop	ebx
$LN141@SyncPlots:
	pop	edi
$LN3@SyncPlots:

; 83   : 			}
; 84   : 		}
; 85   : 	}
; 86   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$0:
	lea	ecx, DWORD PTR _memoryStream$221764[ebp]
	jmp	??1FMemoryStream@@UAE@XZ		; FMemoryStream::~FMemoryStream
__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$1:
	lea	ecx, DWORD PTR _callStacks$222066[ebp]
	jmp	??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
__ehhandler$?SyncPlots@FSerialization@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?SyncPlots@FSerialization@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SyncPlots@FSerialization@@YAXXZ ENDP			; FSerialization::SyncPlots
PUBLIC	??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T263955 = -4						; size = 4
??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T263955[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??0?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+45], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names
PUBLIC	??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51 ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`local static guard'
PUBLIC	?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ; FAutoArchiveClassContainer<CvPlot>::getNames
EXTRN	_atexit:PROC
;	COMDAT ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_BSS	SEGMENT
?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A DB 0cH DUP (?) ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names
_BSS	ENDS
;	COMDAT ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51
_BSS	SEGMENT
??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51 DD 01H DUP (?) ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`local static guard'
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ$0
__ehfuncinfo$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchiveclasscontainer.h
xdata$x	ENDS
;	COMDAT ?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ PROC ; FAutoArchiveClassContainer<CvPlot>::getNames, COMDAT
; _this$ = ecx

; 98   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 99   : 	static std::map<size_t, std::string> names;

	test	BYTE PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51, 1
	jne	SHORT $LN54@getNames
	or	DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51, 1
	mov	ecx, OFFSET ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names
	mov	DWORD PTR __$EHRec$[esp+20], 0
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
	mov	DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+4, eax
	mov	BYTE PTR [eax+45], 1
	mov	eax, DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+4
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+4
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+4
	mov	DWORD PTR [eax+8], eax
	push	OFFSET ??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`dynamic atexit destructor for 'names''
	mov	DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+8, 0
	call	_atexit
	add	esp, 4
$LN54@getNames:

; 100  : 	return names;
; 101  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	eax, OFFSET ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ$0:
	mov	eax, DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51, eax
	ret	0
__ehhandler$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ENDP ; FAutoArchiveClassContainer<CvPlot>::getNames
; Function compile flags: /Ogtpy
;	COMDAT ?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T264493 = -4						; size = 4
_key$ = 8						; size = 4
_var$ = 8						; size = 4
?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::getVariableName, COMDAT
; _this$ = ecx

; 48   : 	{

	push	ecx

; 49   : 		const std::string * result = 0;
; 50   : 
; 51   : 		size_t key = std::distance(m_contents.begin(), std::find(m_contents.begin(), m_contents.end(), &var));

	mov	edx, DWORD PTR [ecx+8]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+12]
	xor	ebx, ebx
	mov	eax, edx
	cmp	edx, esi
	je	SHORT $LN57@getVariabl
	push	edi
	mov	edi, DWORD PTR _var$[esp+12]
$LL20@getVariabl:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN60@getVariabl
	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL20@getVariabl
$LN60@getVariabl:
	pop	edi
$LN57@getVariabl:
	sub	eax, edx
	sar	eax, 2
	mov	DWORD PTR _key$[esp+8], eax

; 52   : 		std::map<size_t, std::string> & names = getNames();

	call	?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ; FAutoArchiveClassContainer<CvPlot>::getNames
	mov	esi, eax

; 53   : 		std::map<size_t, std::string>::const_iterator f = names.find(key);

	lea	eax, DWORD PTR _key$[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T264493[esp+16]
	push	ecx
	mov	ecx, esi
	call	?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
	mov	eax, DWORD PTR [eax]

; 54   : 		
; 55   : 		if(f != names.end())

	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN59@getVariabl
	pop	esi

; 56   : 		{
; 57   : 			result = &f->second;

	add	eax, 16					; 00000010H
	pop	ebx

; 60   : 	}

	pop	ecx
	ret	4
$LN59@getVariabl:
	pop	esi

; 58   : 		}
; 59   : 		return result;

	mov	eax, ebx
	pop	ebx

; 60   : 	}

	pop	ecx
	ret	4
?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::getVariableName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T264653 = -4						; size = 4
_offset$ = 8						; size = 4
_var$ = 8						; size = 4
_name$ = 12						; size = 4
?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::setVariableName, COMDAT
; _this$ = ecx

; 63   : 	{

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 64   : 		std::map<size_t, std::string> & names = getNames();

	call	?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ; FAutoArchiveClassContainer<CvPlot>::getNames

; 65   : 
; 66   : 		size_t offset = std::distance(m_contents.begin(), std::find(m_contents.begin(), m_contents.end(), &var));

	mov	ecx, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+12]
	mov	edi, eax
	mov	eax, ecx
	cmp	ecx, esi
	je	SHORT $LN49@setVariabl
	mov	edx, DWORD PTR _var$[esp+8]
	npad	4
$LL20@setVariabl:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN49@setVariabl
	add	eax, 4
	cmp	eax, esi
	jne	SHORT $LL20@setVariabl
$LN49@setVariabl:
	sub	eax, ecx
	sar	eax, 2
	mov	DWORD PTR _offset$[esp+8], eax

; 67   : 		std::map<size_t, std::string>::const_iterator f = names.find(offset);

	lea	eax, DWORD PTR _offset$[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T264653[esp+16]
	push	ecx
	mov	ecx, edi
	call	?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
	mov	eax, DWORD PTR [eax]

; 68   : 		if(f == names.end())

	cmp	eax, DWORD PTR [edi+4]
	jne	SHORT $LN1@setVariabl

; 69   : 		{
; 70   : 			names[offset] = name;

	mov	edx, DWORD PTR _name$[esp+8]
	push	edx
	lea	eax, DWORD PTR _offset$[esp+12]
	push	eax
	mov	ecx, edi
	call	??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN1@setVariabl:
	pop	edi
	pop	esi

; 71   : 		}
; 72   : 	}

	pop	ecx
	ret	8
?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::setVariableName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
_TEXT	ENDS
;	COMDAT ??__EplotsToCheck@FSerialization@@YAXXZ
text$yc	SEGMENT
??__EplotsToCheck@FSerialization@@YAXXZ PROC		; FSerialization::`dynamic initializer for 'plotsToCheck'', COMDAT

; 58   : std::set<CvPlot*> plotsToCheck;

	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
	mov	DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4, eax
	mov	BYTE PTR [eax+17], 1
	mov	eax, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	DWORD PTR [eax+8], eax
	push	OFFSET ??__FplotsToCheck@FSerialization@@YAXXZ ; FSerialization::`dynamic atexit destructor for 'plotsToCheck''
	mov	DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+8, 0
	call	_atexit
	pop	ecx
	ret	0
??__EplotsToCheck@FSerialization@@YAXXZ ENDP		; FSerialization::`dynamic initializer for 'plotsToCheck''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__FplotsToCheck@FSerialization@@YAXXZ
text$yd	SEGMENT
$T265205 = -4						; size = 4
??__FplotsToCheck@FSerialization@@YAXXZ PROC		; FSerialization::`dynamic atexit destructor for 'plotsToCheck'', COMDAT
	push	ecx
	mov	eax, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T265205[esp+12]
	push	eax
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
	mov	ecx, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	mov	DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4, eax
	mov	DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+8, eax
	add	esp, 8
	ret	0
??__FplotsToCheck@FSerialization@@YAXXZ ENDP		; FSerialization::`dynamic atexit destructor for 'plotsToCheck''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ
text$yd	SEGMENT
$T265372 = -4						; size = 4
??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ PROC ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`dynamic atexit destructor for 'names'', COMDAT
	push	ecx
	mov	eax, DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+4
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T265372[esp+12]
	push	eax
	mov	ecx, OFFSET ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
	mov	ecx, DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+4
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	mov	DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+4, eax
	mov	DWORD PTR ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A+8, eax
	add	esp, 8
	ret	0
??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ ENDP ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`dynamic atexit destructor for 'names''
text$yd	ENDS
PUBLIC	?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
_BSS	SEGMENT
?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A DB 0cH DUP (?) ; FSerialization::plotsToCheck
_BSS	ENDS
CRT$XCU	SEGMENT
_plotsToCheck$initializer$ DD FLAT:??__EplotsToCheck@FSerialization@@YAXXZ
CRT$XCU	ENDS
END
