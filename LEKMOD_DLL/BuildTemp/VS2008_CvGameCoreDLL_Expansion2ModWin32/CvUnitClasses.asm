; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\Github\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvUnitClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217994 DB	'Cost', 00H
	ORG $+3
$SG217995 DB	'FinalProductionCostModifier', 00H
$SG217996 DB	'FaithCost', 00H
	ORG $+2
$SG217997 DB	'RequiresFaithPurchaseEnabled', 00H
	ORG $+3
$SG217998 DB	'PurchaseOnly', 00H
	ORG $+3
$SG217999 DB	'MoveAfterPurchase', 00H
	ORG $+2
$SG218000 DB	'HurryCostModifier', 00H
	ORG $+2
$SG218001 DB	'AdvancedStartCost', 00H
	ORG $+2
$SG218002 DB	'MinAreaSize', 00H
$SG218003 DB	'Moves', 00H
	ORG $+2
$SG218004 DB	'Immobile', 00H
	ORG $+3
$SG218005 DB	'BaseSightRange', 00H
	ORG $+1
$SG218006 DB	'Range', 00H
	ORG $+2
$SG218007 DB	'AirInterceptRange', 00H
	ORG $+2
$SG218008 DB	'AirUnitCap', 00H
	ORG $+1
$SG218009 DB	'NukeDamageLevel', 00H
$SG218010 DB	'WorkRate', 00H
	ORG $+3
$SG218011 DB	'NumFreeTechs', 00H
	ORG $+3
$SG218012 DB	'BaseBeakersTurnsToCount', 00H
$SG218013 DB	'BaseCultureTurnsToCount', 00H
$SG218014 DB	'BaseHurry', 00H
	ORG $+2
$SG218015 DB	'HurryMultiplier', 00H
$SG218016 DB	'RushBuilding', 00H
	ORG $+3
$SG218017 DB	'BaseGold', 00H
	ORG $+3
$SG218018 DB	'NumGoldPerEra', 00H
	ORG $+2
$SG218019 DB	'SpreadReligion', 00H
	ORG $+1
$SG218020 DB	'RemoveHeresy', 00H
	ORG $+3
$SG218021 DB	'ReligionSpreads', 00H
$SG218022 DB	'ReligiousStrength', 00H
	ORG $+2
$SG218023 DB	'FoundReligion', 00H
	ORG $+2
$SG218024 DB	'RequiresEnhancedReligion', 00H
	ORG $+3
$SG218025 DB	'ProhibitsSpread', 00H
$SG218026 DB	'CanBuyCityState', 00H
$SG218027 DB	'Combat', 00H
	ORG $+1
$SG218028 DB	'CombatLimit', 00H
$SG218029 DB	'RangedCombat', 00H
	ORG $+3
$SG218030 DB	'RangedCombatLimit', 00H
	ORG $+2
$SG218031 DB	'XPValueAttack', 00H
	ORG $+2
$SG218032 DB	'XPValueDefense', 00H
	ORG $+1
$SG218033 DB	'Conscription', 00H
	ORG $+3
$SG218034 DB	'ExtraMaintenanceCost', 00H
	ORG $+3
$SG218035 DB	'NoMaintenance', 00H
	ORG $+2
$SG218036 DB	'Unhappiness', 00H
$SG218037 DB	'UnitFlagIconOffset', 00H
	ORG $+1
$SG218038 DB	'PortraitIndex', 00H
	ORG $+2
$SG218039 DB	'LeaderExperience', 00H
	ORG $+3
$SG218040 DB	'Food', 00H
	ORG $+3
$SG218041 DB	'NoBadGoodies', 00H
	ORG $+3
$SG218042 DB	'RivalTerritory', 00H
	ORG $+1
$SG218043 DB	'MilitarySupport', 00H
$SG218044 DB	'MilitaryProduction', 00H
	ORG $+1
$SG218045 DB	'Pillage', 00H
$SG218046 DB	'Found', 00H
	ORG $+2
$SG218047 DB	'FoundAbroad', 00H
$SG218048 DB	'CultureBombRadius', 00H
	ORG $+2
$SG218049 DB	'GoldenAgeTurns', 00H
	ORG $+1
$SG218050 DB	'FreePolicies', 00H
	ORG $+3
$SG218051 DB	'OneShotTourism', 00H
	ORG $+1
$SG218052 DB	'OneShotTourismPercentOthers', 00H
$SG218053 DB	'IgnoreBuildingDefense', 00H
	ORG $+2
$SG218054 DB	'PrereqResources', 00H
$SG218055 DB	'Mechanized', 00H
	ORG $+1
$SG218056 DB	'Suicide', 00H
$SG218057 DB	'CaptureWhileEmbarked', 00H
	ORG $+3
$SG218058 DB	'RangeAttackOnlyInDomain', 00H
$SG218059 DB	'Trade', 00H
	ORG $+2
$SG218060 DB	'NumExoticGoods', 00H
	ORG $+1
$SG218061 DB	'UnitArtInfo', 00H
$SG218062 DB	'UnitArtInfoCulturalVariation', 00H
	ORG $+3
$SG218063 DB	'UnitArtInfoEraVariation', 00H
$SG218065 DB	'Class', 00H
	ORG $+2
$SG218066 DB	'Special', 00H
$SG218067 DB	'Capture', 00H
$SG218068 DB	'CombatClass', 00H
$SG218069 DB	'Domain', 00H
	ORG $+1
$SG218070 DB	'CivilianAttackPriority', 00H
	ORG $+1
$SG218071 DB	'DefaultUnitAI', 00H
	ORG $+2
$SG218072 DB	'PillagePrereqTech', 00H
	ORG $+2
$SG218073 DB	'PrereqTech', 00H
	ORG $+1
$SG218074 DB	'ObsoleteTech', 00H
	ORG $+3
$SG218075 DB	'PolicyType', 00H
	ORG $+1
$SG218076 DB	'GoodyHutUpgradeUnitClass', 00H
	ORG $+3
$SG218077 DB	'SpecialCargo', 00H
	ORG $+3
$SG218078 DB	'DomainCargo', 00H
$SG218079 DB	'ProjectPrereq', 00H
	ORG $+2
$SG218080 DB	'SpaceshipProject', 00H
	ORG $+3
$SG218081 DB	'LeaderPromotion', 00H
$SG218083 DB	'UnitType', 00H
	ORG $+3
$SG218084 DB	'Unit_Flavors', 00H
	ORG $+3
$SG218085 DB	'Trait', 00H
	ORG $+2
$SG218086 DB	'UnitType', 00H
	ORG $+3
$SG218087 DB	'TraitType', 00H
	ORG $+2
$SG218088 DB	'Unit_ProductionTraits', 00H
	ORG $+2
$SG218089 DB	'Traits', 00H
	ORG $+1
$SG218090 DB	'Cost', 00H
	ORG $+3
$SG218091 DB	'UnitType', 00H
	ORG $+3
$SG218092 DB	'ResourceType', 00H
	ORG $+3
$SG218093 DB	'Unit_ResourceQuantityRequirements', 00H
	ORG $+2
$SG218094 DB	'Resources', 00H
	ORG $+2
$SG218095 DB	'ProductionModifier', 00H
	ORG $+1
$SG218096 DB	'UnitType', 00H
	ORG $+3
$SG218097 DB	'BuildingType', 00H
	ORG $+3
$SG218098 DB	'Unit_ProductionModifierBuildings', 00H
	ORG $+3
$SG218099 DB	'Buildings', 00H
	ORG $+2
$SG218100 DB	'Yield', 00H
	ORG $+2
$SG218101 DB	'UnitType', 00H
	ORG $+3
$SG218102 DB	'YieldType', 00H
	ORG $+2
$SG218103 DB	'Unit_YieldFromKills', 00H
$SG218104 DB	'Yields', 00H
	ORG $+1
$SG218105 DB	'UnitType', 00H
	ORG $+3
$SG218106 DB	'PromotionType', 00H
	ORG $+2
$SG218107 DB	'Unit_FreePromotions', 00H
$SG218108 DB	'UnitPromotions', 00H
	ORG $+1
$SG218109 DB	'UnitType', 00H
	ORG $+3
$SG218110 DB	'UnitClassType', 00H
	ORG $+2
$SG218111 DB	'Unit_ClassUpgrades', 00H
	ORG $+1
$SG218112 DB	'UnitClasses', 00H
$SG218113 DB	'UnitType', 00H
	ORG $+3
$SG218114 DB	'UnitAIType', 00H
	ORG $+1
$SG218115 DB	'Unit_AITypes', 00H
	ORG $+3
$SG218116 DB	'UnitAIInfos', 00H
$SG218117 DB	'UnitType', 00H
	ORG $+3
$SG218118 DB	'UnitAIType', 00H
	ORG $+1
$SG218119 DB	'Unit_NotAITypes', 00H
$SG218120 DB	'UnitAIInfos', 00H
$SG218121 DB	'UnitType', 00H
	ORG $+3
$SG218122 DB	'BuildType', 00H
	ORG $+2
$SG218123 DB	'Unit_Builds', 00H
$SG218124 DB	'Builds', 00H
	ORG $+1
$SG218125 DB	'UnitType', 00H
	ORG $+3
$SG218126 DB	'GreatPersonType', 00H
$SG218127 DB	'Unit_GreatPersons', 00H
	ORG $+2
$SG218128 DB	'Specialists', 00H
$SG218129 DB	'UnitType', 00H
	ORG $+3
$SG218130 DB	'BuildingType', 00H
	ORG $+3
$SG218131 DB	'Unit_Buildings', 00H
	ORG $+1
$SG218132 DB	'Buildings', 00H
	ORG $+2
$SG218133 DB	'UnitType', 00H
	ORG $+3
$SG218134 DB	'BuildingClassType', 00H
	ORG $+2
$SG218135 DB	'Unit_BuildingClassRequireds', 00H
$SG218136 DB	'BuildingClasses', 00H
$SG218143 DB	'Technologies', 00H
	ORG $+3
$SG218145 DB	'Units - TechTypes', 00H
	ORG $+2
$SG218148 DB	'select Technologies.ID from Unit_TechTypes inner join Te'
	DB	'chnologies on TechType = Technologies.Type where UnitType = ?'
	DB	00H
	ORG $+2
$SG218154 DB	'Units - UniqueNameCount', 00H
$SG218157 DB	'select count(*) from Unit_UniqueNames where UnitType = ?'
	DB	00H
	ORG $+3
$SG218169 DB	'Units - UniqueNames', 00H
$SG218172 DB	'select UniqueName, GreatWorkType from Unit_UniqueNames w'
	DB	'here UnitType = ? ORDER BY rowid', 00H
	ORG $+3
$SG218182 DB	'Units - MovementRates', 00H
	ORG $+2
$SG218185 DB	'SELECT * FROM MovementRates where Type = ? ORDER BY NumH'
	DB	'exes', 00H
	ORG $+3
$SG218187 DB	'MoveRate', 00H
	ORG $+3
$SG218192 DB	'NumHexes', 00H
	ORG $+3
$SG218194 DB	'TotalTime', 00H
	ORG $+2
$SG218196 DB	'EaseIn', 00H
	ORG $+1
$SG218198 DB	'EaseOut', 00H
$SG218200 DB	'IndividualOffset', 00H
	ORG $+3
$SG218202 DB	'RowOffset', 00H
	ORG $+2
$SG218204 DB	'CurveRoll', 00H
	ORG $+2
$SG218206 DB	'PathSubdivision', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	edi
	mov	edi, DWORD PTR ___n$[esp]
	sub	edi, 1
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+8]
	push	esi
	mov	esi, DWORD PTR ___t$[esp+12]
	npad	7
$LL2@vector:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	sub	edi, 1
	jns	SHORT $LL2@vector
	pop	esi
	pop	ebp
	pop	ebx
$LN1@vector:
	pop	edi
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File s:\msvs2008\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetProductionCost@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetProductionCost
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ?GetProductionCost@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProductionCost@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetProductionCost, COMDAT
; _this$ = ecx

; 445  : 	return m_iProductionCost;

	mov	eax, DWORD PTR [ecx+260]

; 446  : }

	ret	0
?GetProductionCost@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetProductionCost
_TEXT	ENDS
PUBLIC	?GetFinalProductionCostModifier@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetFinalProductionCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetFinalProductionCostModifier@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFinalProductionCostModifier@CvUnitEntry@@QBEHXZ PROC ; CvUnitEntry::GetFinalProductionCostModifier, COMDAT
; _this$ = ecx

; 452  : 	return m_iFinalProductionCostModifier;

	mov	eax, DWORD PTR [ecx+264]

; 453  : }

	ret	0
?GetFinalProductionCostModifier@CvUnitEntry@@QBEHXZ ENDP ; CvUnitEntry::GetFinalProductionCostModifier
_TEXT	ENDS
PUBLIC	?GetFaithCost@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetFaithCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetFaithCost@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFaithCost@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetFaithCost, COMDAT
; _this$ = ecx

; 460  : 	return m_iFaithCost;

	mov	eax, DWORD PTR [ecx+268]

; 461  : }

	ret	0
?GetFaithCost@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetFaithCost
_TEXT	ENDS
PUBLIC	?IsRequiresFaithPurchaseEnabled@CvUnitEntry@@QBE_NXZ ; CvUnitEntry::IsRequiresFaithPurchaseEnabled
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresFaithPurchaseEnabled@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresFaithPurchaseEnabled@CvUnitEntry@@QBE_NXZ PROC ; CvUnitEntry::IsRequiresFaithPurchaseEnabled, COMDAT
; _this$ = ecx

; 466  : 	return m_bRequiresFaithPurchaseEnabled;

	mov	al, BYTE PTR [ecx+272]

; 467  : }

	ret	0
?IsRequiresFaithPurchaseEnabled@CvUnitEntry@@QBE_NXZ ENDP ; CvUnitEntry::IsRequiresFaithPurchaseEnabled
_TEXT	ENDS
PUBLIC	?IsPurchaseOnly@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsPurchaseOnly
; Function compile flags: /Ogtpy
;	COMDAT ?IsPurchaseOnly@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPurchaseOnly@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsPurchaseOnly, COMDAT
; _this$ = ecx

; 472  : 	return m_bPurchaseOnly;

	mov	al, BYTE PTR [ecx+273]

; 473  : }

	ret	0
?IsPurchaseOnly@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsPurchaseOnly
_TEXT	ENDS
PUBLIC	?CanMoveAfterPurchase@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::CanMoveAfterPurchase
; Function compile flags: /Ogtpy
;	COMDAT ?CanMoveAfterPurchase@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?CanMoveAfterPurchase@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::CanMoveAfterPurchase, COMDAT
; _this$ = ecx

; 478  : 	return m_bMoveAfterPurchase;

	mov	al, BYTE PTR [ecx+274]

; 479  : }

	ret	0
?CanMoveAfterPurchase@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::CanMoveAfterPurchase
_TEXT	ENDS
PUBLIC	?GetHurryCostModifier@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetHurryCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetHurryCostModifier@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHurryCostModifier@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetHurryCostModifier, COMDAT
; _this$ = ecx

; 484  : 	return m_iHurryCostModifier;

	mov	eax, DWORD PTR [ecx+276]

; 485  : }

	ret	0
?GetHurryCostModifier@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetHurryCostModifier
_TEXT	ENDS
PUBLIC	?GetAdvancedStartCost@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetAdvancedStartCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvancedStartCost@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAdvancedStartCost@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetAdvancedStartCost, COMDAT
; _this$ = ecx

; 490  : 	return m_iAdvancedStartCost;

	mov	eax, DWORD PTR [ecx+280]

; 491  : }

	ret	0
?GetAdvancedStartCost@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetAdvancedStartCost
_TEXT	ENDS
PUBLIC	?GetMinAreaSize@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMinAreaSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinAreaSize@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinAreaSize@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetMinAreaSize, COMDAT
; _this$ = ecx

; 496  : 	return m_iMinAreaSize;

	mov	eax, DWORD PTR [ecx+284]

; 497  : }

	ret	0
?GetMinAreaSize@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetMinAreaSize
_TEXT	ENDS
PUBLIC	?GetMoves@CvUnitEntry@@QBEHXZ			; CvUnitEntry::GetMoves
; Function compile flags: /Ogtpy
;	COMDAT ?GetMoves@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMoves@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetMoves, COMDAT
; _this$ = ecx

; 502  : 	return m_iMoves;

	mov	eax, DWORD PTR [ecx+288]

; 503  : }

	ret	0
?GetMoves@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetMoves
_TEXT	ENDS
PUBLIC	?IsImmobile@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsImmobile
; Function compile flags: /Ogtpy
;	COMDAT ?IsImmobile@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsImmobile@CvUnitEntry@@QBE_NXZ PROC			; CvUnitEntry::IsImmobile, COMDAT
; _this$ = ecx

; 508  : 	return m_bMoves;

	mov	al, BYTE PTR [ecx+292]

; 509  : }

	ret	0
?IsImmobile@CvUnitEntry@@QBE_NXZ ENDP			; CvUnitEntry::IsImmobile
_TEXT	ENDS
PUBLIC	?GetBaseSightRange@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetBaseSightRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseSightRange@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBaseSightRange@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetBaseSightRange, COMDAT
; _this$ = ecx

; 514  : 	return m_iBaseSightRange;

	mov	eax, DWORD PTR [ecx+296]

; 515  : }

	ret	0
?GetBaseSightRange@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetBaseSightRange
_TEXT	ENDS
PUBLIC	?GetRange@CvUnitEntry@@QBEHXZ			; CvUnitEntry::GetRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetRange@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRange@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetRange, COMDAT
; _this$ = ecx

; 520  : 	return m_iRange;

	mov	eax, DWORD PTR [ecx+300]

; 521  : }

	ret	0
?GetRange@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetRange
_TEXT	ENDS
PUBLIC	?GetAirInterceptRange@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetAirInterceptRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetAirInterceptRange@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAirInterceptRange@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetAirInterceptRange, COMDAT
; _this$ = ecx

; 526  : 	return m_iAirInterceptRange;

	mov	eax, DWORD PTR [ecx+304]

; 527  : }

	ret	0
?GetAirInterceptRange@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetAirInterceptRange
_TEXT	ENDS
PUBLIC	?GetAirUnitCap@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetAirUnitCap
; Function compile flags: /Ogtpy
;	COMDAT ?GetAirUnitCap@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAirUnitCap@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetAirUnitCap, COMDAT
; _this$ = ecx

; 532  : 	return m_iAirUnitCap;

	mov	eax, DWORD PTR [ecx+308]

; 533  : }

	ret	0
?GetAirUnitCap@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetAirUnitCap
_TEXT	ENDS
PUBLIC	?GetNukeDamageLevel@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetNukeDamageLevel
; Function compile flags: /Ogtpy
;	COMDAT ?GetNukeDamageLevel@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNukeDamageLevel@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetNukeDamageLevel, COMDAT
; _this$ = ecx

; 538  : 	return m_iNukeDamageLevel;

	mov	eax, DWORD PTR [ecx+312]

; 539  : }

	ret	0
?GetNukeDamageLevel@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetNukeDamageLevel
_TEXT	ENDS
PUBLIC	?GetWorkRate@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetWorkRate
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorkRate@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWorkRate@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetWorkRate, COMDAT
; _this$ = ecx

; 544  : 	return m_iWorkRate;

	mov	eax, DWORD PTR [ecx+316]

; 545  : }

	ret	0
?GetWorkRate@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetWorkRate
_TEXT	ENDS
PUBLIC	?GetNumFreeTechs@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetNumFreeTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumFreeTechs@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumFreeTechs@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetNumFreeTechs, COMDAT
; _this$ = ecx

; 550  : 	return m_iNumFreeTechs;

	mov	eax, DWORD PTR [ecx+320]

; 551  : }

	ret	0
?GetNumFreeTechs@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetNumFreeTechs
_TEXT	ENDS
PUBLIC	?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetBaseBeakersTurnsToCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ PROC	; CvUnitEntry::GetBaseBeakersTurnsToCount, COMDAT
; _this$ = ecx

; 556  : 	return m_iBaseBeakersTurnsToCount;

	mov	eax, DWORD PTR [ecx+324]

; 557  : }

	ret	0
?GetBaseBeakersTurnsToCount@CvUnitEntry@@QBEHXZ ENDP	; CvUnitEntry::GetBaseBeakersTurnsToCount
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?GetBaseCultureTurnsToCount@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetBaseCultureTurnsToCount
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ?GetBaseCultureTurnsToCount@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBaseCultureTurnsToCount@CvUnitEntry@@QBEHXZ PROC	; CvUnitEntry::GetBaseCultureTurnsToCount, COMDAT
; _this$ = ecx

; 562  : 	return m_iBaseCultureTurnsToCount;

	mov	eax, DWORD PTR [ecx+328]

; 563  : }

	ret	0
?GetBaseCultureTurnsToCount@CvUnitEntry@@QBEHXZ ENDP	; CvUnitEntry::GetBaseCultureTurnsToCount
_TEXT	ENDS
PUBLIC	?GetBaseHurry@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetBaseHurry
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseHurry@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBaseHurry@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetBaseHurry, COMDAT
; _this$ = ecx

; 568  : 	return m_iBaseHurry;

	mov	eax, DWORD PTR [ecx+332]

; 569  : }

	ret	0
?GetBaseHurry@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetBaseHurry
_TEXT	ENDS
PUBLIC	?GetHurryMultiplier@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetHurryMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?GetHurryMultiplier@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHurryMultiplier@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetHurryMultiplier, COMDAT
; _this$ = ecx

; 574  : 	return m_iHurryMultiplier;

	mov	eax, DWORD PTR [ecx+336]

; 575  : }

	ret	0
?GetHurryMultiplier@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetHurryMultiplier
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
PUBLIC	?IsRushBuilding@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsRushBuilding
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ?IsRushBuilding@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRushBuilding@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsRushBuilding, COMDAT
; _this$ = ecx

; 580  : 	return m_bRushBuilding;

	mov	al, BYTE PTR [ecx+340]

; 581  : }

	ret	0
?IsRushBuilding@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsRushBuilding
_TEXT	ENDS
PUBLIC	?GetBaseGold@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetBaseGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseGold@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetBaseGold@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetBaseGold, COMDAT
; _this$ = ecx

; 586  : 	return m_iBaseGold;

	mov	eax, DWORD PTR [ecx+344]

; 587  : }

	ret	0
?GetBaseGold@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetBaseGold
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetNumGoldPerEra@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetNumGoldPerEra
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ?GetNumGoldPerEra@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumGoldPerEra@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetNumGoldPerEra, COMDAT
; _this$ = ecx

; 592  : 	return m_iNumGoldPerEra;

	mov	eax, DWORD PTR [ecx+348]

; 593  : }

	ret	0
?GetNumGoldPerEra@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetNumGoldPerEra
_TEXT	ENDS
PUBLIC	?IsSpreadReligion@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsSpreadReligion
; Function compile flags: /Ogtpy
;	COMDAT ?IsSpreadReligion@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsSpreadReligion@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsSpreadReligion, COMDAT
; _this$ = ecx

; 598  : 	return m_bSpreadReligion;

	mov	al, BYTE PTR [ecx+352]

; 599  : }

	ret	0
?IsSpreadReligion@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsSpreadReligion
_TEXT	ENDS
PUBLIC	?IsRemoveHeresy@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsRemoveHeresy
; Function compile flags: /Ogtpy
;	COMDAT ?IsRemoveHeresy@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRemoveHeresy@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsRemoveHeresy, COMDAT
; _this$ = ecx

; 604  : 	return m_bRemoveHeresy;

	mov	al, BYTE PTR [ecx+367]

; 605  : }

	ret	0
?IsRemoveHeresy@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsRemoveHeresy
_TEXT	ENDS
PUBLIC	?GetReligionSpreads@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetReligionSpreads
; Function compile flags: /Ogtpy
;	COMDAT ?GetReligionSpreads@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetReligionSpreads@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetReligionSpreads, COMDAT
; _this$ = ecx

; 610  : 	return m_iReligionSpreads;

	mov	eax, DWORD PTR [ecx+356]

; 611  : }

	ret	0
?GetReligionSpreads@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetReligionSpreads
_TEXT	ENDS
PUBLIC	?GetReligiousStrength@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetReligiousStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetReligiousStrength@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetReligiousStrength@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetReligiousStrength, COMDAT
; _this$ = ecx

; 616  : 	return m_iReligiousStrength;

	mov	eax, DWORD PTR [ecx+360]

; 617  : }

	ret	0
?GetReligiousStrength@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetReligiousStrength
_TEXT	ENDS
PUBLIC	?IsFoundReligion@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsFoundReligion
; Function compile flags: /Ogtpy
;	COMDAT ?IsFoundReligion@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFoundReligion@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsFoundReligion, COMDAT
; _this$ = ecx

; 622  : 	return m_bFoundReligion;

	mov	al, BYTE PTR [ecx+364]

; 623  : }

	ret	0
?IsFoundReligion@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsFoundReligion
_TEXT	ENDS
PUBLIC	?IsRequiresEnhancedReligion@CvUnitEntry@@QBE_NXZ ; CvUnitEntry::IsRequiresEnhancedReligion
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresEnhancedReligion@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresEnhancedReligion@CvUnitEntry@@QBE_NXZ PROC	; CvUnitEntry::IsRequiresEnhancedReligion, COMDAT
; _this$ = ecx

; 628  : 	return m_bRequiresEnhancedReligion;

	mov	al, BYTE PTR [ecx+365]

; 629  : }

	ret	0
?IsRequiresEnhancedReligion@CvUnitEntry@@QBE_NXZ ENDP	; CvUnitEntry::IsRequiresEnhancedReligion
_TEXT	ENDS
PUBLIC	?IsProhibitsSpread@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsProhibitsSpread
; Function compile flags: /Ogtpy
;	COMDAT ?IsProhibitsSpread@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsProhibitsSpread@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsProhibitsSpread, COMDAT
; _this$ = ecx

; 634  : 	return m_bProhibitsSpread;

	mov	al, BYTE PTR [ecx+366]

; 635  : }

	ret	0
?IsProhibitsSpread@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsProhibitsSpread
_TEXT	ENDS
PUBLIC	?IsCanBuyCityState@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsCanBuyCityState
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanBuyCityState@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCanBuyCityState@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsCanBuyCityState, COMDAT
; _this$ = ecx

; 640  : 	return m_bCanBuyCityState;

	mov	al, BYTE PTR [ecx+368]

; 641  : }

	ret	0
?IsCanBuyCityState@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsCanBuyCityState
_TEXT	ENDS
PUBLIC	?GetCombat@CvUnitEntry@@QBEHXZ			; CvUnitEntry::GetCombat
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombat@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombat@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetCombat, COMDAT
; _this$ = ecx

; 646  : 	return m_iCombat;

	mov	eax, DWORD PTR [ecx+372]

; 647  : }

	ret	0
?GetCombat@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetCombat
_TEXT	ENDS
PUBLIC	?SetCombat@CvUnitEntry@@QAEXH@Z			; CvUnitEntry::SetCombat
; Function compile flags: /Ogtpy
;	COMDAT ?SetCombat@CvUnitEntry@@QAEXH@Z
_TEXT	SEGMENT
_iNum$ = 8						; size = 4
?SetCombat@CvUnitEntry@@QAEXH@Z PROC			; CvUnitEntry::SetCombat, COMDAT
; _this$ = ecx

; 652  : 	m_iCombat = iNum;

	mov	eax, DWORD PTR _iNum$[esp-4]
	mov	DWORD PTR [ecx+372], eax

; 653  : }

	ret	4
?SetCombat@CvUnitEntry@@QAEXH@Z ENDP			; CvUnitEntry::SetCombat
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?GetCombatLimit@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCombatLimit
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ?GetCombatLimit@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatLimit@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetCombatLimit, COMDAT
; _this$ = ecx

; 658  : 	return m_iCombatLimit;

	mov	eax, DWORD PTR [ecx+376]

; 659  : }

	ret	0
?GetCombatLimit@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetCombatLimit
_TEXT	ENDS
PUBLIC	?GetRangedCombat@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetRangedCombat
; Function compile flags: /Ogtpy
;	COMDAT ?GetRangedCombat@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRangedCombat@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetRangedCombat, COMDAT
; _this$ = ecx

; 664  : 	return m_iRangedCombat;

	mov	eax, DWORD PTR [ecx+380]

; 665  : }

	ret	0
?GetRangedCombat@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetRangedCombat
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	?GetRangedCombatLimit@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetRangedCombatLimit
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ?GetRangedCombatLimit@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRangedCombatLimit@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetRangedCombatLimit, COMDAT
; _this$ = ecx

; 670  : 	return m_iRangedCombatLimit;

	mov	eax, DWORD PTR [ecx+384]

; 671  : }

	ret	0
?GetRangedCombatLimit@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetRangedCombatLimit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetXPValueAttack@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetXPValueAttack
; Function compile flags: /Ogtpy
;	COMDAT ?GetXPValueAttack@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetXPValueAttack@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetXPValueAttack, COMDAT
; _this$ = ecx

; 676  : 	return m_iXPValueAttack;

	mov	eax, DWORD PTR [ecx+388]

; 677  : }

	ret	0
?GetXPValueAttack@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetXPValueAttack
_TEXT	ENDS
PUBLIC	?GetXPValueDefense@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetXPValueDefense
; Function compile flags: /Ogtpy
;	COMDAT ?GetXPValueDefense@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetXPValueDefense@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetXPValueDefense, COMDAT
; _this$ = ecx

; 682  : 	return m_iXPValueDefense;

	mov	eax, DWORD PTR [ecx+392]

; 683  : }

	ret	0
?GetXPValueDefense@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetXPValueDefense
_TEXT	ENDS
PUBLIC	?GetSpecialCargo@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetSpecialCargo
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialCargo@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpecialCargo@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetSpecialCargo, COMDAT
; _this$ = ecx

; 688  : 	return m_iSpecialCargo;

	mov	eax, DWORD PTR [ecx+396]

; 689  : }

	ret	0
?GetSpecialCargo@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetSpecialCargo
_TEXT	ENDS
PUBLIC	?GetDomainCargo@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetDomainCargo
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainCargo@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDomainCargo@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetDomainCargo, COMDAT
; _this$ = ecx

; 694  : 	return m_iDomainCargo;

	mov	eax, DWORD PTR [ecx+400]

; 695  : }

	ret	0
?GetDomainCargo@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetDomainCargo
_TEXT	ENDS
PUBLIC	?GetConscriptionValue@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetConscriptionValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetConscriptionValue@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetConscriptionValue@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetConscriptionValue, COMDAT
; _this$ = ecx

; 700  : 	return m_iConscriptionValue;

	mov	eax, DWORD PTR [ecx+404]

; 701  : }

	ret	0
?GetConscriptionValue@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetConscriptionValue
_TEXT	ENDS
PUBLIC	?GetExtraMaintenanceCost@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetExtraMaintenanceCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraMaintenanceCost@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraMaintenanceCost@CvUnitEntry@@QBEHXZ PROC	; CvUnitEntry::GetExtraMaintenanceCost, COMDAT
; _this$ = ecx

; 706  : 	return m_iExtraMaintenanceCost;

	mov	eax, DWORD PTR [ecx+408]

; 707  : }

	ret	0
?GetExtraMaintenanceCost@CvUnitEntry@@QBEHXZ ENDP	; CvUnitEntry::GetExtraMaintenanceCost
_TEXT	ENDS
PUBLIC	?IsNoMaintenance@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsNoMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoMaintenance@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoMaintenance@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsNoMaintenance, COMDAT
; _this$ = ecx

; 712  : 	return m_bNoMaintenance;

	mov	al, BYTE PTR [ecx+412]

; 713  : }

	ret	0
?IsNoMaintenance@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsNoMaintenance
_TEXT	ENDS
PUBLIC	?GetUnhappiness@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetUnhappiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnhappiness@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnhappiness@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetUnhappiness, COMDAT
; _this$ = ecx

; 718  : 	return m_iUnhappiness;

	mov	eax, DWORD PTR [ecx+416]

; 719  : }

	ret	0
?GetUnhappiness@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetUnhappiness
_TEXT	ENDS
PUBLIC	?GetUnitClassType@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetUnitClassType
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitClassType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitClassType@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetUnitClassType, COMDAT
; _this$ = ecx

; 724  : 	return m_iUnitClassType;

	mov	eax, DWORD PTR [ecx+420]

; 725  : }

	ret	0
?GetUnitClassType@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetUnitClassType
_TEXT	ENDS
PUBLIC	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetSpecialUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpecialUnitType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpecialUnitType@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetSpecialUnitType, COMDAT
; _this$ = ecx

; 730  : 	return m_iSpecialUnitType;

	mov	eax, DWORD PTR [ecx+424]

; 731  : }

	ret	0
?GetSpecialUnitType@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetSpecialUnitType
_TEXT	ENDS
PUBLIC	?GetUnitCaptureClassType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitCaptureClassType
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCaptureClassType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitCaptureClassType@CvUnitEntry@@QBEHXZ PROC	; CvUnitEntry::GetUnitCaptureClassType, COMDAT
; _this$ = ecx

; 736  : 	return m_iUnitCaptureClassType;

	mov	eax, DWORD PTR [ecx+428]

; 737  : }

	ret	0
?GetUnitCaptureClassType@CvUnitEntry@@QBEHXZ ENDP	; CvUnitEntry::GetUnitCaptureClassType
_TEXT	ENDS
PUBLIC	?GetUnitCombatType@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetUnitCombatType
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCombatType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitCombatType@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetUnitCombatType, COMDAT
; _this$ = ecx

; 742  : 	return m_iUnitCombatType;

	mov	eax, DWORD PTR [ecx+432]

; 743  : }

	ret	0
?GetUnitCombatType@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetUnitCombatType
_TEXT	ENDS
PUBLIC	?GetDomainType@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetDomainType
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDomainType@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetDomainType, COMDAT
; _this$ = ecx

; 748  : 	return m_iDomainType;

	mov	eax, DWORD PTR [ecx+436]

; 749  : }

	ret	0
?GetDomainType@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetDomainType
_TEXT	ENDS
PUBLIC	?GetCivilianAttackPriority@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetCivilianAttackPriority
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivilianAttackPriority@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCivilianAttackPriority@CvUnitEntry@@QBEHXZ PROC	; CvUnitEntry::GetCivilianAttackPriority, COMDAT
; _this$ = ecx

; 754  : 	return m_iCivilianAttackPriority;

	mov	eax, DWORD PTR [ecx+440]

; 755  : }

	ret	0
?GetCivilianAttackPriority@CvUnitEntry@@QBEHXZ ENDP	; CvUnitEntry::GetCivilianAttackPriority
_TEXT	ENDS
PUBLIC	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDefaultUnitAIType
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetDefaultUnitAIType, COMDAT
; _this$ = ecx

; 760  : 	return m_iDefaultUnitAIType;

	mov	eax, DWORD PTR [ecx+444]

; 761  : }

	ret	0
?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetDefaultUnitAIType
_TEXT	ENDS
PUBLIC	?GetPrereqPillageTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqPillageTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqPillageTech@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqPillageTech@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetPrereqPillageTech, COMDAT
; _this$ = ecx

; 766  : 	return m_iPrereqPillageTech;

	mov	eax, DWORD PTR [ecx+448]

; 767  : }

	ret	0
?GetPrereqPillageTech@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetPrereqPillageTech
_TEXT	ENDS
PUBLIC	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPrereqAndTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqAndTech@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqAndTech@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetPrereqAndTech, COMDAT
; _this$ = ecx

; 772  : 	return m_iPrereqAndTech;

	mov	eax, DWORD PTR [ecx+452]

; 773  : }

	ret	0
?GetPrereqAndTech@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetPrereqAndTech
_TEXT	ENDS
PUBLIC	?GetObsoleteTech@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetObsoleteTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetObsoleteTech@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetObsoleteTech@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetObsoleteTech, COMDAT
; _this$ = ecx

; 778  : 	return m_iObsoleteTech;

	mov	eax, DWORD PTR [ecx+456]

; 779  : }

	ret	0
?GetObsoleteTech@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetObsoleteTech
_TEXT	ENDS
PUBLIC	?GetEra@CvUnitEntry@@QBEHXZ			; CvUnitEntry::GetEra
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetEra@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEra@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetEra, COMDAT
; _this$ = ecx

; 784  : 	TechTypes eTech = (TechTypes)GetPrereqAndTech();

	mov	eax, DWORD PTR [ecx+452]

; 785  : 	if (eTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN1@GetEra

; 786  : 	{
; 787  : 		CvTechEntry* pTech = GC.getTechInfo((TechTypes)GetPrereqAndTech());

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 788  : 		return pTech->GetEra();

	mov	ecx, eax
	jmp	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
$LN1@GetEra:

; 789  : 	}
; 790  : 
; 791  : 	return -1;

	or	eax, -1

; 792  : }

	ret	0
?GetEra@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetEra
_TEXT	ENDS
PUBLIC	?GetPolicyType@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPolicyType
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPolicyType@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetPolicyType, COMDAT
; _this$ = ecx

; 797  : 	return m_iPolicyType;

	mov	eax, DWORD PTR [ecx+460]

; 798  : }

	ret	0
?GetPolicyType@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetPolicyType
_TEXT	ENDS
PUBLIC	?GetGoodyHutUpgradeUnitClass@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetGoodyHutUpgradeUnitClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoodyHutUpgradeUnitClass@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoodyHutUpgradeUnitClass@CvUnitEntry@@QBEHXZ PROC	; CvUnitEntry::GetGoodyHutUpgradeUnitClass, COMDAT
; _this$ = ecx

; 803  : 	return m_iGoodyHutUpgradeUnitClass;

	mov	eax, DWORD PTR [ecx+464]

; 804  : }

	ret	0
?GetGoodyHutUpgradeUnitClass@CvUnitEntry@@QBEHXZ ENDP	; CvUnitEntry::GetGoodyHutUpgradeUnitClass
_TEXT	ENDS
PUBLIC	?GetGroupSize@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetGroupSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetGroupSize@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGroupSize@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetGroupSize, COMDAT
; _this$ = ecx

; 809  : 	return m_iGroupSize;

	mov	eax, DWORD PTR [ecx+468]

; 810  : }

	ret	0
?GetGroupSize@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetGroupSize
_TEXT	ENDS
PUBLIC	?GetGroupDefinitions@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetGroupDefinitions
; Function compile flags: /Ogtpy
;	COMDAT ?GetGroupDefinitions@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGroupDefinitions@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetGroupDefinitions, COMDAT
; _this$ = ecx

; 815  : 	return m_iGroupDefinitions;

	mov	eax, DWORD PTR [ecx+472]

; 816  : }

	ret	0
?GetGroupDefinitions@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetGroupDefinitions
_TEXT	ENDS
PUBLIC	?GetMeleeWaveSize@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMeleeWaveSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetMeleeWaveSize@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMeleeWaveSize@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetMeleeWaveSize, COMDAT
; _this$ = ecx

; 821  : 	return m_iUnitMeleeWaveSize;

	mov	eax, DWORD PTR [ecx+476]

; 822  : }

	ret	0
?GetMeleeWaveSize@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetMeleeWaveSize
_TEXT	ENDS
PUBLIC	?GetRangedWaveSize@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetRangedWaveSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetRangedWaveSize@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRangedWaveSize@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetRangedWaveSize, COMDAT
; _this$ = ecx

; 827  : 	return m_iUnitRangedWaveSize;

	mov	eax, DWORD PTR [ecx+480]

; 828  : }

	ret	0
?GetRangedWaveSize@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetRangedWaveSize
_TEXT	ENDS
PUBLIC	?GetNumUnitNames@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetNumUnitNames
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumUnitNames@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumUnitNames@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetNumUnitNames, COMDAT
; _this$ = ecx

; 833  : 	return m_iNumUnitNames;

	mov	eax, DWORD PTR [ecx+484]

; 834  : }

	ret	0
?GetNumUnitNames@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetNumUnitNames
_TEXT	ENDS
PUBLIC	?IsFoodProduction@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsFoodProduction
; Function compile flags: /Ogtpy
;	COMDAT ?IsFoodProduction@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFoodProduction@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsFoodProduction, COMDAT
; _this$ = ecx

; 839  : 	return m_bFoodProduction;

	mov	al, BYTE PTR [ecx+496]

; 840  : }

	ret	0
?IsFoodProduction@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsFoodProduction
_TEXT	ENDS
PUBLIC	?IsNoBadGoodies@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsNoBadGoodies
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoBadGoodies@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoBadGoodies@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsNoBadGoodies, COMDAT
; _this$ = ecx

; 845  : 	return m_bNoBadGoodies;

	mov	al, BYTE PTR [ecx+497]

; 846  : }

	ret	0
?IsNoBadGoodies@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsNoBadGoodies
_TEXT	ENDS
PUBLIC	?IsRivalTerritory@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsRivalTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IsRivalTerritory@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRivalTerritory@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsRivalTerritory, COMDAT
; _this$ = ecx

; 851  : 	return m_bRivalTerritory;

	mov	al, BYTE PTR [ecx+498]

; 852  : }

	ret	0
?IsRivalTerritory@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsRivalTerritory
_TEXT	ENDS
PUBLIC	?IsMilitarySupport@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsMilitarySupport
; Function compile flags: /Ogtpy
;	COMDAT ?IsMilitarySupport@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMilitarySupport@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsMilitarySupport, COMDAT
; _this$ = ecx

; 857  : 	return m_bMilitarySupport;

	mov	al, BYTE PTR [ecx+499]

; 858  : }

	ret	0
?IsMilitarySupport@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsMilitarySupport
_TEXT	ENDS
PUBLIC	?IsMilitaryProduction@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsMilitaryProduction
; Function compile flags: /Ogtpy
;	COMDAT ?IsMilitaryProduction@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMilitaryProduction@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsMilitaryProduction, COMDAT
; _this$ = ecx

; 863  : 	return m_bMilitaryProduction;

	mov	al, BYTE PTR [ecx+500]

; 864  : }

	ret	0
?IsMilitaryProduction@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsMilitaryProduction
_TEXT	ENDS
PUBLIC	?IsPillage@CvUnitEntry@@QBE_NXZ			; CvUnitEntry::IsPillage
; Function compile flags: /Ogtpy
;	COMDAT ?IsPillage@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPillage@CvUnitEntry@@QBE_NXZ PROC			; CvUnitEntry::IsPillage, COMDAT
; _this$ = ecx

; 869  : 	return m_bPillage;

	mov	al, BYTE PTR [ecx+501]

; 870  : }

	ret	0
?IsPillage@CvUnitEntry@@QBE_NXZ ENDP			; CvUnitEntry::IsPillage
_TEXT	ENDS
PUBLIC	?IsFound@CvUnitEntry@@QBE_NXZ			; CvUnitEntry::IsFound
; Function compile flags: /Ogtpy
;	COMDAT ?IsFound@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFound@CvUnitEntry@@QBE_NXZ PROC			; CvUnitEntry::IsFound, COMDAT
; _this$ = ecx

; 875  : 	return m_bFound;

	mov	al, BYTE PTR [ecx+502]

; 876  : }

	ret	0
?IsFound@CvUnitEntry@@QBE_NXZ ENDP			; CvUnitEntry::IsFound
_TEXT	ENDS
PUBLIC	?IsFoundAbroad@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsFoundAbroad
; Function compile flags: /Ogtpy
;	COMDAT ?IsFoundAbroad@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFoundAbroad@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsFoundAbroad, COMDAT
; _this$ = ecx

; 881  : 	return m_bFoundAbroad;

	mov	al, BYTE PTR [ecx+503]

; 882  : }

	ret	0
?IsFoundAbroad@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsFoundAbroad
_TEXT	ENDS
PUBLIC	?GetCultureBombRadius@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetCultureBombRadius
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureBombRadius@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureBombRadius@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetCultureBombRadius, COMDAT
; _this$ = ecx

; 887  : 	return m_iCultureBombRadius;

	mov	eax, DWORD PTR [ecx+504]

; 888  : }

	ret	0
?GetCultureBombRadius@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetCultureBombRadius
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTurns@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetGoldenAgeTurns
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeTurns@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeTurns@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetGoldenAgeTurns, COMDAT
; _this$ = ecx

; 893  : 	return m_iGoldenAgeTurns;

	mov	eax, DWORD PTR [ecx+512]

; 894  : }

	ret	0
?GetGoldenAgeTurns@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetGoldenAgeTurns
_TEXT	ENDS
PUBLIC	?GetFreePolicies@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetFreePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreePolicies@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreePolicies@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetFreePolicies, COMDAT
; _this$ = ecx

; 899  : 	return m_iFreePolicies;

	mov	eax, DWORD PTR [ecx+516]

; 900  : }

	ret	0
?GetFreePolicies@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetFreePolicies
_TEXT	ENDS
PUBLIC	?GetOneShotTourism@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetOneShotTourism
; Function compile flags: /Ogtpy
;	COMDAT ?GetOneShotTourism@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOneShotTourism@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetOneShotTourism, COMDAT
; _this$ = ecx

; 905  : 	return m_iOneShotTourism;

	mov	eax, DWORD PTR [ecx+520]

; 906  : }

	ret	0
?GetOneShotTourism@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetOneShotTourism
_TEXT	ENDS
PUBLIC	?GetOneShotTourismPercentOthers@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetOneShotTourismPercentOthers
; Function compile flags: /Ogtpy
;	COMDAT ?GetOneShotTourismPercentOthers@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOneShotTourismPercentOthers@CvUnitEntry@@QBEHXZ PROC ; CvUnitEntry::GetOneShotTourismPercentOthers, COMDAT
; _this$ = ecx

; 911  : 	return m_iOneShotTourismPercentOthers;

	mov	eax, DWORD PTR [ecx+524]

; 912  : }

	ret	0
?GetOneShotTourismPercentOthers@CvUnitEntry@@QBEHXZ ENDP ; CvUnitEntry::GetOneShotTourismPercentOthers
_TEXT	ENDS
PUBLIC	?IsIgnoreBuildingDefense@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsIgnoreBuildingDefense
; Function compile flags: /Ogtpy
;	COMDAT ?IsIgnoreBuildingDefense@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsIgnoreBuildingDefense@CvUnitEntry@@QBE_NXZ PROC	; CvUnitEntry::IsIgnoreBuildingDefense, COMDAT
; _this$ = ecx

; 917  : 	return m_bIgnoreBuildingDefense;

	mov	al, BYTE PTR [ecx+528]

; 918  : }

	ret	0
?IsIgnoreBuildingDefense@CvUnitEntry@@QBE_NXZ ENDP	; CvUnitEntry::IsIgnoreBuildingDefense
_TEXT	ENDS
PUBLIC	?IsPrereqResources@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsPrereqResources
; Function compile flags: /Ogtpy
;	COMDAT ?IsPrereqResources@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPrereqResources@CvUnitEntry@@QBE_NXZ PROC		; CvUnitEntry::IsPrereqResources, COMDAT
; _this$ = ecx

; 923  : 	return m_bPrereqResources;

	mov	al, BYTE PTR [ecx+529]

; 924  : }

	ret	0
?IsPrereqResources@CvUnitEntry@@QBE_NXZ ENDP		; CvUnitEntry::IsPrereqResources
_TEXT	ENDS
PUBLIC	?IsMechUnit@CvUnitEntry@@QBE_NXZ		; CvUnitEntry::IsMechUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsMechUnit@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMechUnit@CvUnitEntry@@QBE_NXZ PROC			; CvUnitEntry::IsMechUnit, COMDAT
; _this$ = ecx

; 929  : 	return m_bMechanized;

	mov	al, BYTE PTR [ecx+530]

; 930  : }

	ret	0
?IsMechUnit@CvUnitEntry@@QBE_NXZ ENDP			; CvUnitEntry::IsMechUnit
_TEXT	ENDS
PUBLIC	?IsSuicide@CvUnitEntry@@QBE_NXZ			; CvUnitEntry::IsSuicide
; Function compile flags: /Ogtpy
;	COMDAT ?IsSuicide@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsSuicide@CvUnitEntry@@QBE_NXZ PROC			; CvUnitEntry::IsSuicide, COMDAT
; _this$ = ecx

; 935  : 	return m_bSuicide;

	mov	al, BYTE PTR [ecx+531]

; 936  : }

	ret	0
?IsSuicide@CvUnitEntry@@QBE_NXZ ENDP			; CvUnitEntry::IsSuicide
_TEXT	ENDS
PUBLIC	?IsCaptureWhileEmbarked@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsCaptureWhileEmbarked
; Function compile flags: /Ogtpy
;	COMDAT ?IsCaptureWhileEmbarked@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCaptureWhileEmbarked@CvUnitEntry@@QBE_NXZ PROC	; CvUnitEntry::IsCaptureWhileEmbarked, COMDAT
; _this$ = ecx

; 941  : 	return m_bCaptureWhileEmbarked;

	mov	al, BYTE PTR [ecx+532]

; 942  : }

	ret	0
?IsCaptureWhileEmbarked@CvUnitEntry@@QBE_NXZ ENDP	; CvUnitEntry::IsCaptureWhileEmbarked
_TEXT	ENDS
PUBLIC	?IsRangeAttackOnlyInDomain@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsRangeAttackOnlyInDomain
; Function compile flags: /Ogtpy
;	COMDAT ?IsRangeAttackOnlyInDomain@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRangeAttackOnlyInDomain@CvUnitEntry@@QBE_NXZ PROC	; CvUnitEntry::IsRangeAttackOnlyInDomain, COMDAT
; _this$ = ecx

; 947  : 	return m_bRangeAttackOnlyInDomain;

	mov	al, BYTE PTR [ecx+533]

; 948  : }

	ret	0
?IsRangeAttackOnlyInDomain@CvUnitEntry@@QBE_NXZ ENDP	; CvUnitEntry::IsRangeAttackOnlyInDomain
_TEXT	ENDS
PUBLIC	?IsTrade@CvUnitEntry@@QBE_NXZ			; CvUnitEntry::IsTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsTrade@CvUnitEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTrade@CvUnitEntry@@QBE_NXZ PROC			; CvUnitEntry::IsTrade, COMDAT
; _this$ = ecx

; 953  : 	return m_bTrade;

	mov	al, BYTE PTR [ecx+548]

; 954  : }

	ret	0
?IsTrade@CvUnitEntry@@QBE_NXZ ENDP			; CvUnitEntry::IsTrade
_TEXT	ENDS
PUBLIC	?GetNumExoticGoods@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetNumExoticGoods
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumExoticGoods@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumExoticGoods@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetNumExoticGoods, COMDAT
; _this$ = ecx

; 959  : 	return m_iNumExoticGoods;

	mov	eax, DWORD PTR [ecx+552]

; 960  : }

	ret	0
?GetNumExoticGoods@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetNumExoticGoods
_TEXT	ENDS
PUBLIC	?GetCommandType@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCommandType
; Function compile flags: /Ogtpy
;	COMDAT ?GetCommandType@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCommandType@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetCommandType, COMDAT
; _this$ = ecx

; 965  : 	return m_iCommandType;

	mov	eax, DWORD PTR [ecx+488]

; 966  : }

	ret	0
?GetCommandType@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetCommandType
_TEXT	ENDS
PUBLIC	?SetCommandType@CvUnitEntry@@QAEXH@Z		; CvUnitEntry::SetCommandType
; Function compile flags: /Ogtpy
;	COMDAT ?SetCommandType@CvUnitEntry@@QAEXH@Z
_TEXT	SEGMENT
_iNewType$ = 8						; size = 4
?SetCommandType@CvUnitEntry@@QAEXH@Z PROC		; CvUnitEntry::SetCommandType, COMDAT
; _this$ = ecx

; 971  : 	m_iCommandType = iNewType;

	mov	eax, DWORD PTR _iNewType$[esp-4]
	mov	DWORD PTR [ecx+488], eax

; 972  : }

	ret	4
?SetCommandType@CvUnitEntry@@QAEXH@Z ENDP		; CvUnitEntry::SetCommandType
_TEXT	ENDS
PUBLIC	?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z		; CvUnitEntry::GetPrereqAndTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z PROC		; CvUnitEntry::GetPrereqAndTechs, COMDAT
; _this$ = ecx

; 979  : 	CvAssertMsg(i < GC.getNUM_UNIT_AND_TECH_PREREQS(), "Index out of bounds");
; 980  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 981  : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	mov	eax, DWORD PTR [ecx+936]
	test	eax, eax
	je	SHORT $LN3@GetPrereqA
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 982  : }

	ret	4
$LN3@GetPrereqA:

; 979  : 	CvAssertMsg(i < GC.getNUM_UNIT_AND_TECH_PREREQS(), "Index out of bounds");
; 980  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 981  : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	or	eax, -1

; 982  : }

	ret	4
?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z ENDP		; CvUnitEntry::GetPrereqAndTechs
_TEXT	ENDS
PUBLIC	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ; CvUnitEntry::GetResourceQuantityRequirement
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z PROC ; CvUnitEntry::GetResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 987  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 988  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 989  : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	mov	eax, DWORD PTR [ecx+940]
	test	eax, eax
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 990  : }

	ret	4
$LN3@GetResourc:

; 987  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 988  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 989  : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	or	eax, -1

; 990  : }

	ret	4
?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ENDP ; CvUnitEntry::GetResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?GetBuildingProductionModifier@CvUnitEntry@@QBEHW4BuildingTypes@@@Z ; CvUnitEntry::GetBuildingProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingProductionModifier@CvUnitEntry@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_eBuilding$ = 8						; size = 4
?GetBuildingProductionModifier@CvUnitEntry@@QBEHW4BuildingTypes@@@Z PROC ; CvUnitEntry::GetBuildingProductionModifier, COMDAT
; _this$ = ecx

; 995  : 	CvAssertMsg((int)eBuilding < GC.getNumBuildingInfos(), "Building type out of bounds");
; 996  : 	CvAssertMsg((int)eBuilding > -1, "Index out of bounds");
; 997  : 	return m_piProductionModifierBuildings[(int)eBuilding];

	mov	eax, DWORD PTR [ecx+956]
	mov	ecx, DWORD PTR _eBuilding$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 998  : }

	ret	4
?GetBuildingProductionModifier@CvUnitEntry@@QBEHW4BuildingTypes@@@Z ENDP ; CvUnitEntry::GetBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetYieldFromKills@CvUnitEntry@@QBEHW4YieldTypes@@@Z ; CvUnitEntry::GetYieldFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldFromKills@CvUnitEntry@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetYieldFromKills@CvUnitEntry@@QBEHW4YieldTypes@@@Z PROC ; CvUnitEntry::GetYieldFromKills, COMDAT
; _this$ = ecx

; 1003 : 	CvAssertMsg((int)eYield < NUM_YIELD_TYPES, "Yield type out of bounds");
; 1004 : 	CvAssertMsg((int)eYield > -1, "Index out of bounds");
; 1005 : 	return m_piYieldFromKills[(int)eYield];

	mov	eax, DWORD PTR [ecx+960]
	mov	ecx, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1006 : }

	ret	4
?GetYieldFromKills@CvUnitEntry@@QBEHW4YieldTypes@@@Z ENDP ; CvUnitEntry::GetYieldFromKills
_TEXT	ENDS
PUBLIC	?GetProductionTraits@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetProductionTraits
; Function compile flags: /Ogtpy
;	COMDAT ?GetProductionTraits@CvUnitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetProductionTraits@CvUnitEntry@@QBEHH@Z PROC		; CvUnitEntry::GetProductionTraits, COMDAT
; _this$ = ecx

; 1011 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 1012 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1013 : 	return m_piProductionTraits ? m_piProductionTraits[i] : -1;

	mov	eax, DWORD PTR [ecx+944]
	test	eax, eax
	je	SHORT $LN3@GetProduct
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1014 : }

	ret	4
$LN3@GetProduct:

; 1011 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 1012 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1013 : 	return m_piProductionTraits ? m_piProductionTraits[i] : -1;

	or	eax, -1

; 1014 : }

	ret	4
?GetProductionTraits@CvUnitEntry@@QBEHH@Z ENDP		; CvUnitEntry::GetProductionTraits
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvUnitEntry@@QBEHH@Z		; CvUnitEntry::GetFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorValue@CvUnitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvUnitEntry@@QBEHH@Z PROC		; CvUnitEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 1019 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 1020 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1021 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR [ecx+948]
	test	eax, eax
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1022 : }

	ret	4
$LN3@GetFlavorV:

; 1019 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 1020 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1021 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	xor	eax, eax

; 1022 : }

	ret	4
?GetFlavorValue@CvUnitEntry@@QBEHH@Z ENDP		; CvUnitEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetUnitGroupRequired@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetUnitGroupRequired
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitGroupRequired@CvUnitEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitGroupRequired@CvUnitEntry@@QBEHH@Z PROC		; CvUnitEntry::GetUnitGroupRequired, COMDAT
; _this$ = ecx

; 1026 : 	CvAssertMsg(i < GetGroupDefinitions(), "Index out of bounds");
; 1027 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1028 : 	return m_piUnitGroupRequired ? m_piUnitGroupRequired[i] : NULL;

	mov	eax, DWORD PTR [ecx+952]
	test	eax, eax
	je	SHORT $LN3@GetUnitGro
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1029 : }

	ret	4
$LN3@GetUnitGro:

; 1026 : 	CvAssertMsg(i < GetGroupDefinitions(), "Index out of bounds");
; 1027 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1028 : 	return m_piUnitGroupRequired ? m_piUnitGroupRequired[i] : NULL;

	xor	eax, eax

; 1029 : }

	ret	4
?GetUnitGroupRequired@CvUnitEntry@@QBEHH@Z ENDP		; CvUnitEntry::GetUnitGroupRequired
_TEXT	ENDS
PUBLIC	?GetUpgradeUnitClass@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUpgradeUnitClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetUpgradeUnitClass@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUpgradeUnitClass@CvUnitEntry@@QBE_NH@Z PROC		; CvUnitEntry::GetUpgradeUnitClass, COMDAT
; _this$ = ecx

; 1034 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 1035 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1036 : 	return m_pbUpgradeUnitClass ? m_pbUpgradeUnitClass[i] : false;

	mov	eax, DWORD PTR [ecx+964]
	test	eax, eax
	je	SHORT $LN3@GetUpgrade
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1037 : }

	ret	4
$LN3@GetUpgrade:

; 1034 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 1035 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1036 : 	return m_pbUpgradeUnitClass ? m_pbUpgradeUnitClass[i] : false;

	xor	al, al

; 1037 : }

	ret	4
?GetUpgradeUnitClass@CvUnitEntry@@QBE_NH@Z ENDP		; CvUnitEntry::GetUpgradeUnitClass
_TEXT	ENDS
PUBLIC	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z		; CvUnitEntry::GetUnitAIType
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitAIType@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitAIType@CvUnitEntry@@QBE_NH@Z PROC		; CvUnitEntry::GetUnitAIType, COMDAT
; _this$ = ecx

; 1042 : 	CvAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
; 1043 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1044 : 	return m_pbUnitAIType ? m_pbUnitAIType[i] : false;

	mov	eax, DWORD PTR [ecx+968]
	test	eax, eax
	je	SHORT $LN3@GetUnitAIT
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1045 : }

	ret	4
$LN3@GetUnitAIT:

; 1042 : 	CvAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
; 1043 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1044 : 	return m_pbUnitAIType ? m_pbUnitAIType[i] : false;

	xor	al, al

; 1045 : }

	ret	4
?GetUnitAIType@CvUnitEntry@@QBE_NH@Z ENDP		; CvUnitEntry::GetUnitAIType
_TEXT	ENDS
PUBLIC	?GetNotUnitAIType@CvUnitEntry@@QBE_NH@Z		; CvUnitEntry::GetNotUnitAIType
; Function compile flags: /Ogtpy
;	COMDAT ?GetNotUnitAIType@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetNotUnitAIType@CvUnitEntry@@QBE_NH@Z PROC		; CvUnitEntry::GetNotUnitAIType, COMDAT
; _this$ = ecx

; 1050 : 	CvAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
; 1051 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1052 : 	return m_pbNotUnitAIType ? m_pbNotUnitAIType[i] : false;

	mov	eax, DWORD PTR [ecx+972]
	test	eax, eax
	je	SHORT $LN3@GetNotUnit
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1053 : }

	ret	4
$LN3@GetNotUnit:

; 1050 : 	CvAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
; 1051 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1052 : 	return m_pbNotUnitAIType ? m_pbNotUnitAIType[i] : false;

	xor	al, al

; 1053 : }

	ret	4
?GetNotUnitAIType@CvUnitEntry@@QBE_NH@Z ENDP		; CvUnitEntry::GetNotUnitAIType
_TEXT	ENDS
PUBLIC	?GetBuilds@CvUnitEntry@@QBE_NH@Z		; CvUnitEntry::GetBuilds
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuilds@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuilds@CvUnitEntry@@QBE_NH@Z PROC			; CvUnitEntry::GetBuilds, COMDAT
; _this$ = ecx

; 1058 : 	CvAssertMsg(i < GC.getNumBuildInfos(), "Index out of bounds");
; 1059 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1060 : 	return m_pbBuilds ? m_pbBuilds[i] : false;

	mov	eax, DWORD PTR [ecx+976]
	test	eax, eax
	je	SHORT $LN3@GetBuilds
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1061 : }

	ret	4
$LN3@GetBuilds:

; 1058 : 	CvAssertMsg(i < GC.getNumBuildInfos(), "Index out of bounds");
; 1059 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1060 : 	return m_pbBuilds ? m_pbBuilds[i] : false;

	xor	al, al

; 1061 : }

	ret	4
?GetBuilds@CvUnitEntry@@QBE_NH@Z ENDP			; CvUnitEntry::GetBuilds
_TEXT	ENDS
PUBLIC	?GetGreatPeoples@CvUnitEntry@@QBE_NH@Z		; CvUnitEntry::GetGreatPeoples
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatPeoples@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetGreatPeoples@CvUnitEntry@@QBE_NH@Z PROC		; CvUnitEntry::GetGreatPeoples, COMDAT
; _this$ = ecx

; 1066 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 1067 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1068 : 	return m_pbGreatPeoples ? m_pbGreatPeoples[i] : false;

	mov	eax, DWORD PTR [ecx+980]
	test	eax, eax
	je	SHORT $LN3@GetGreatPe
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1069 : }

	ret	4
$LN3@GetGreatPe:

; 1066 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 1067 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1068 : 	return m_pbGreatPeoples ? m_pbGreatPeoples[i] : false;

	xor	al, al

; 1069 : }

	ret	4
?GetGreatPeoples@CvUnitEntry@@QBE_NH@Z ENDP		; CvUnitEntry::GetGreatPeoples
_TEXT	ENDS
PUBLIC	?GetBuildings@CvUnitEntry@@QBE_NH@Z		; CvUnitEntry::GetBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildings@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildings@CvUnitEntry@@QBE_NH@Z PROC		; CvUnitEntry::GetBuildings, COMDAT
; _this$ = ecx

; 1074 : 	CvAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
; 1075 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1076 : 	return m_pbBuildings ? m_pbBuildings[i] : false;

	mov	eax, DWORD PTR [ecx+984]
	test	eax, eax
	je	SHORT $LN3@GetBuildin
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1077 : }

	ret	4
$LN3@GetBuildin:

; 1074 : 	CvAssertMsg(i < GC.getNumBuildingInfos(), "Index out of bounds");
; 1075 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1076 : 	return m_pbBuildings ? m_pbBuildings[i] : false;

	xor	al, al

; 1077 : }

	ret	4
?GetBuildings@CvUnitEntry@@QBE_NH@Z ENDP		; CvUnitEntry::GetBuildings
_TEXT	ENDS
PUBLIC	?GetBuildingClassRequireds@CvUnitEntry@@QBE_NH@Z ; CvUnitEntry::GetBuildingClassRequireds
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingClassRequireds@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetBuildingClassRequireds@CvUnitEntry@@QBE_NH@Z PROC	; CvUnitEntry::GetBuildingClassRequireds, COMDAT
; _this$ = ecx

; 1082 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 1083 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1084 : 	return m_pbBuildingClassRequireds ? m_pbBuildingClassRequireds[i] : false;

	mov	eax, DWORD PTR [ecx+988]
	test	eax, eax
	je	SHORT $LN3@GetBuildin@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1085 : }

	ret	4
$LN3@GetBuildin@2:

; 1082 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 1083 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1084 : 	return m_pbBuildingClassRequireds ? m_pbBuildingClassRequireds[i] : false;

	xor	al, al

; 1085 : }

	ret	4
?GetBuildingClassRequireds@CvUnitEntry@@QBE_NH@Z ENDP	; CvUnitEntry::GetBuildingClassRequireds
_TEXT	ENDS
PUBLIC	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetFreePromotions
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreePromotions@CvUnitEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFreePromotions@CvUnitEntry@@QBE_NH@Z PROC		; CvUnitEntry::GetFreePromotions, COMDAT
; _this$ = ecx

; 1090 : 	CvAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
; 1091 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1092 : 	return m_pbFreePromotions ? m_pbFreePromotions[i] : false;

	mov	eax, DWORD PTR [ecx+992]
	test	eax, eax
	je	SHORT $LN3@GetFreePro
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1093 : }

	ret	4
$LN3@GetFreePro:

; 1090 : 	CvAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
; 1091 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1092 : 	return m_pbFreePromotions ? m_pbFreePromotions[i] : false;

	xor	al, al

; 1093 : }

	ret	4
?GetFreePromotions@CvUnitEntry@@QBE_NH@Z ENDP		; CvUnitEntry::GetFreePromotions
_TEXT	ENDS
PUBLIC	?GetProjectPrereq@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetProjectPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetProjectPrereq@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetProjectPrereq@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetProjectPrereq, COMDAT
; _this$ = ecx

; 1098 : 	return m_iProjectPrereq;

	mov	eax, DWORD PTR [ecx+536]

; 1099 : }

	ret	0
?GetProjectPrereq@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetProjectPrereq
_TEXT	ENDS
PUBLIC	?GetSpaceshipProject@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetSpaceshipProject
; Function compile flags: /Ogtpy
;	COMDAT ?GetSpaceshipProject@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSpaceshipProject@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetSpaceshipProject, COMDAT
; _this$ = ecx

; 1104 : 	return m_iSpaceshipProject;

	mov	eax, DWORD PTR [ecx+540]

; 1105 : }

	ret	0
?GetSpaceshipProject@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetSpaceshipProject
_TEXT	ENDS
PUBLIC	?GetLeaderPromotion@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetLeaderPromotion
; Function compile flags: /Ogtpy
;	COMDAT ?GetLeaderPromotion@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLeaderPromotion@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetLeaderPromotion, COMDAT
; _this$ = ecx

; 1110 : 	return m_iLeaderPromotion;

	mov	eax, DWORD PTR [ecx+544]

; 1111 : }

	ret	0
?GetLeaderPromotion@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetLeaderPromotion
_TEXT	ENDS
PUBLIC	?GetLeaderExperience@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetLeaderExperience
; Function compile flags: /Ogtpy
;	COMDAT ?GetLeaderExperience@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLeaderExperience@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetLeaderExperience, COMDAT
; _this$ = ecx

; 1116 : 	return m_iLeaderExperience;

	mov	eax, DWORD PTR [ecx+492]

; 1117 : }

	ret	0
?GetLeaderExperience@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetLeaderExperience
_TEXT	ENDS
PUBLIC	?GetUnitArtInfoCulturalVariation@CvUnitEntry@@QBE?B_NXZ ; CvUnitEntry::GetUnitArtInfoCulturalVariation
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitArtInfoCulturalVariation@CvUnitEntry@@QBE?B_NXZ
_TEXT	SEGMENT
?GetUnitArtInfoCulturalVariation@CvUnitEntry@@QBE?B_NXZ PROC ; CvUnitEntry::GetUnitArtInfoCulturalVariation, COMDAT
; _this$ = ecx

; 1128 : 	return m_bUnitArtInfoCulturalVariation;

	mov	al, BYTE PTR [ecx+596]

; 1129 : }

	ret	0
?GetUnitArtInfoCulturalVariation@CvUnitEntry@@QBE?B_NXZ ENDP ; CvUnitEntry::GetUnitArtInfoCulturalVariation
_TEXT	ENDS
PUBLIC	?GetUnitArtInfoEraVariation@CvUnitEntry@@QBE?B_NXZ ; CvUnitEntry::GetUnitArtInfoEraVariation
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitArtInfoEraVariation@CvUnitEntry@@QBE?B_NXZ
_TEXT	SEGMENT
?GetUnitArtInfoEraVariation@CvUnitEntry@@QBE?B_NXZ PROC	; CvUnitEntry::GetUnitArtInfoEraVariation, COMDAT
; _this$ = ecx

; 1135 : 	return m_bUnitArtInfoEraVariation;

	mov	al, BYTE PTR [ecx+597]

; 1136 : }

	ret	0
?GetUnitArtInfoEraVariation@CvUnitEntry@@QBE?B_NXZ ENDP	; CvUnitEntry::GetUnitArtInfoEraVariation
_TEXT	ENDS
PUBLIC	?GetGreatWorks@CvUnitEntry@@QBE?AW4GreatWorkType@@H@Z ; CvUnitEntry::GetGreatWorks
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatWorks@CvUnitEntry@@QBE?AW4GreatWorkType@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetGreatWorks@CvUnitEntry@@QBE?AW4GreatWorkType@@H@Z PROC ; CvUnitEntry::GetGreatWorks, COMDAT
; _this$ = ecx

; 1150 : 	CvAssertMsg(i < GetNumUnitNames(), "Index out of bounds");
; 1151 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1152 : 	return (m_paeGreatWorks) ? m_paeGreatWorks[i] : NO_GREAT_WORK;

	mov	eax, DWORD PTR [ecx+1012]
	test	eax, eax
	je	SHORT $LN3@GetGreatWo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1153 : }

	ret	4
$LN3@GetGreatWo:

; 1150 : 	CvAssertMsg(i < GetNumUnitNames(), "Index out of bounds");
; 1151 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1152 : 	return (m_paeGreatWorks) ? m_paeGreatWorks[i] : NO_GREAT_WORK;

	or	eax, -1

; 1153 : }

	ret	4
?GetGreatWorks@CvUnitEntry@@QBE?AW4GreatWorkType@@H@Z ENDP ; CvUnitEntry::GetGreatWorks
_TEXT	ENDS
PUBLIC	?GetUnitFlagIconOffset@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitFlagIconOffset
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitFlagIconOffset@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitFlagIconOffset@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetUnitFlagIconOffset, COMDAT
; _this$ = ecx

; 1158 : 	return m_iUnitFlagIconOffset;

	mov	eax, DWORD PTR [ecx+560]

; 1159 : }

	ret	0
?GetUnitFlagIconOffset@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetUnitFlagIconOffset
_TEXT	ENDS
PUBLIC	?GetUnitPortraitOffset@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitPortraitOffset
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitPortraitOffset@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitPortraitOffset@CvUnitEntry@@QBEHXZ PROC		; CvUnitEntry::GetUnitPortraitOffset, COMDAT
; _this$ = ecx

; 1165 : 	return m_iUnitPortraitOffset;

	mov	eax, DWORD PTR [ecx+564]

; 1166 : }

	ret	0
?GetUnitPortraitOffset@CvUnitEntry@@QBEHXZ ENDP		; CvUnitEntry::GetUnitPortraitOffset
_TEXT	ENDS
PUBLIC	?GetCargoSpace@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCargoSpace
EXTRN	?GetCargoChange@CvPromotionEntry@@QBEHXZ:PROC	; CvPromotionEntry::GetCargoChange
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetCargoSpace@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCargoSpace@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetCargoSpace, COMDAT
; _this$ = ecx

; 1173 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1174 : 	int rtnValue = 0;
; 1175 : 
; 1176 : #ifdef AUI_WARNING_FIXES
; 1177 : 	for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 1178 : #else
; 1179 : 	for(int iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	xor	esi, esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	test	eax, eax
	jle	SHORT $LN14@GetCargoSp
	npad	9
$LL5@GetCargoSp:

; 1180 : #endif
; 1181 : 	{
; 1182 : 		const PromotionTypes ePromotion = static_cast<PromotionTypes>(iLoop);
; 1183 : 		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo

; 1184 : 		if(pkPromotionInfo)

	test	eax, eax
	je	SHORT $LN4@GetCargoSp

; 1185 : 		{
; 1186 : 			if(GetFreePromotions(iLoop))

	mov	edx, DWORD PTR [edi+992]
	test	edx, edx
	je	SHORT $LN4@GetCargoSp
	cmp	BYTE PTR [edx+esi], 0
	je	SHORT $LN4@GetCargoSp

; 1187 : 			{
; 1188 : 				const int iVal = pkPromotionInfo->GetCargoChange();

	mov	ecx, eax
	call	?GetCargoChange@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCargoChange

; 1189 : 				rtnValue += iVal;

	add	ebx, eax
$LN4@GetCargoSp:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jl	SHORT $LL5@GetCargoSp
$LN14@GetCargoSp:
	pop	edi
	pop	esi

; 1190 : 			}
; 1191 : 		}
; 1192 : 	}
; 1193 : 
; 1194 : 	return rtnValue;

	mov	eax, ebx
	pop	ebx

; 1195 : }

	ret	0
?GetCargoSpace@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetCargoSpace
_TEXT	ENDS
PUBLIC	?GetPower@CvUnitEntry@@QBEHXZ			; CvUnitEntry::GetPower
; Function compile flags: /Ogtpy
;	COMDAT ?GetPower@CvUnitEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPower@CvUnitEntry@@QBEHXZ PROC			; CvUnitEntry::GetPower, COMDAT
; _this$ = ecx

; 1200 : 	return m_iCachedPower;

	mov	eax, DWORD PTR [ecx+556]

; 1201 : }

	ret	0
?GetPower@CvUnitEntry@@QBEHXZ ENDP			; CvUnitEntry::GetPower
_TEXT	ENDS
PUBLIC	?GetMoveRate@CvUnitEntry@@QBE?AUUnitMoveRate@@H@Z ; CvUnitEntry::GetMoveRate
; Function compile flags: /Ogtpy
;	COMDAT ?GetMoveRate@CvUnitEntry@@QBE?AUUnitMoveRate@@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_numHexes$ = 12						; size = 4
?GetMoveRate@CvUnitEntry@@QBE?AUUnitMoveRate@@H@Z PROC	; CvUnitEntry::GetMoveRate, COMDAT
; _this$ = ecx

; 1422 : 	if(numHexes < 0)

	mov	eax, DWORD PTR _numHexes$[esp-4]
	test	eax, eax
	jge	SHORT $LN2@GetMoveRat

; 1423 : 		numHexes = 0;

	xor	eax, eax

; 1424 : 	if(numHexes > 11)

	jmp	SHORT $LN1@GetMoveRat
$LN2@GetMoveRat:
	cmp	eax, 11					; 0000000bH
	jle	SHORT $LN1@GetMoveRat

; 1425 : 		numHexes = 11;

	mov	eax, 11					; 0000000bH
$LN1@GetMoveRat:
	push	esi

; 1426 : 	return m_unitMoveRate[numHexes];

	lea	edx, DWORD PTR [eax*8]
	push	edi
	sub	edx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	lea	esi, DWORD PTR [ecx+edx*4+600]
	mov	ecx, 7
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi

; 1427 : }

	ret	8
?GetMoveRate@CvUnitEntry@@QBE?AUUnitMoveRate@@H@Z ENDP	; CvUnitEntry::GetMoveRate
_TEXT	ENDS
PUBLIC	?GetUnitEntries@CvUnitXMLEntries@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ ; CvUnitXMLEntries::GetUnitEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitEntries@CvUnitXMLEntries@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetUnitEntries@CvUnitXMLEntries@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ PROC ; CvUnitXMLEntries::GetUnitEntries, COMDAT
; _this$ = ecx

; 1446 : {

	mov	eax, ecx

; 1447 : 	return m_paUnitEntries;
; 1448 : }

	ret	0
?GetUnitEntries@CvUnitXMLEntries@@QAEAAV?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@XZ ENDP ; CvUnitXMLEntries::GetUnitEntries
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAPAVCvUnitEntry@@I@Z ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvUnitEntry@@@std@@QAE@XZ	; std::allocator<CvUnitEntry *>::allocator<CvUnitEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvUnitEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvUnitEntry@@@std@@QAE@XZ PROC	; std::allocator<CvUnitEntry *>::allocator<CvUnitEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvUnitEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvUnitEntry *>::allocator<CvUnitEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEABQAVCvUnitEntry@@XZ ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEABQAVCvUnitEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEABQAVCvUnitEntry@@XZ PROC ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEABQAVCvUnitEntry@@XZ ENDP ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220032 = -80						; size = 28
$T220031 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220032[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T220031[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T220032[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T220031[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T220031[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220031[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T220031[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220032[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220031[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvUnitEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvUnitEntry *>::allocator<CvUnitEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvUnitEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvUnitEntry@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvUnitEntry *>::allocator<CvUnitEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvUnitEntry@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvUnitEntry *>::allocator<CvUnitEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvUnitEntry@@@std@@QAEXPAPAVCvUnitEntry@@I@Z ; std::allocator<CvUnitEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvUnitEntry@@@std@@QAEXPAPAVCvUnitEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvUnitEntry@@@std@@QAEXPAPAVCvUnitEntry@@I@Z PROC ; std::allocator<CvUnitEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvUnitEntry@@@std@@QAEXPAPAVCvUnitEntry@@I@Z ENDP ; std::allocator<CvUnitEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z PROC ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z ENDP ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvUnitEntry@@@std@@QBEIXZ ; std::allocator<CvUnitEntry *>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvUnitEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvUnitEntry@@@std@@QBEIXZ PROC	; std::allocator<CvUnitEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvUnitEntry@@@std@@QBEIXZ ENDP	; std::allocator<CvUnitEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@W4GreatWorkType@@@@YAXAAPAW4GreatWorkType@@@Z ; SAFE_DELETE_ARRAY<enum GreatWorkType>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@W4GreatWorkType@@@@YAXAAPAW4GreatWorkType@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@W4GreatWorkType@@@@YAXAAPAW4GreatWorkType@@@Z PROC ; SAFE_DELETE_ARRAY<enum GreatWorkType>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@W4GreatWorkType@@@@YAXAAPAW4GreatWorkType@@@Z ENDP ; SAFE_DELETE_ARRAY<enum GreatWorkType>
_TEXT	ENDS
PUBLIC	??$min@N@std@@YAABNABN0@Z			; std::min<double>
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$min@N@std@@YAABNABN0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@N@std@@YAABNABN0@Z PROC				; std::min<double>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR __Right$[esp-4]
	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	mov	eax, edx
	je	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@N@std@@YAABNABN0@Z ENDP				; std::min<double>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvUnitEntry@@@std@@YAPAPAVCvUnitEntry@@IPAPAV1@@Z ; std::_Allocate<CvUnitEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvUnitEntry@@@std@@YAPAPAVCvUnitEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T220093 = -12						; size = 12
$T220097 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvUnitEntry@@@std@@YAPAPAVCvUnitEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvUnitEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T220097[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T220093[esp+16]
	mov	DWORD PTR $T220097[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220093[esp+16]
	push	ecx
	mov	DWORD PTR $T220093[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvUnitEntry@@@std@@YAPAPAVCvUnitEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvUnitEntry *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitEntry@@0@Z ; std::_Iter_random<CvUnitEntry * *,CvUnitEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitEntry@@0@Z PROC ; std::_Iter_random<CvUnitEntry * *,CvUnitEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvUnitEntry@@0@Z ENDP ; std::_Iter_random<CvUnitEntry * *,CvUnitEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitEntry@@0@Z ; std::_Ptr_cat<CvUnitEntry * *,CvUnitEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitEntry@@0@Z PROC ; std::_Ptr_cat<CvUnitEntry * *,CvUnitEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvUnitEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvUnitEntry@@0@Z ENDP ; std::_Ptr_cat<CvUnitEntry * *,CvUnitEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvUnitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvUnitEntry * *,CvUnitEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvUnitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvUnitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvUnitEntry * *,CvUnitEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvUnitEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvUnitEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvUnitEntry * *,CvUnitEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvUnitEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvUnitEntry *> >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@H@Z				; CvString::CvString
EXTRN	__imp_?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvString@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvString@@QAE@H@Z$0
__ehfuncinfo$??0CvString@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvString@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0CvString@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iLen$ = 8						; size = 4
??0CvString@@QAE@H@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 24   : 	CvString(int iLen) { reserve(iLen); }

	push	-1
	push	__ehhandler$??0CvString@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _iLen$[esp+16]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	DWORD PTR __imp_?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvString@@QAE@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0CvString@@QAE@H@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvString@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvString@@QAE@H@Z ENDP				; CvString::CvString
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??0UnitMoveRate@@QAE@XZ				; UnitMoveRate::UnitMoveRate
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0UnitMoveRate@@QAE@XZ
_TEXT	SEGMENT
??0UnitMoveRate@@QAE@XZ PROC				; UnitMoveRate::UnitMoveRate, COMDAT
; _this$ = ecx

; 206  : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], 1

; 207  : 	}

	ret	0
??0UnitMoveRate@@QAE@XZ ENDP				; UnitMoveRate::UnitMoveRate
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_ECvString@@QAEPAXI@Z				; CvString::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvString@@QAEPAXI@Z PROC				; CvString::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector@2
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	28					; 0000001cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector@2
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector@2:
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, 1
	je	SHORT $LN1@vector@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvString@@QAEPAXI@Z ENDP				; CvString::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?GetUnitArtInfoTag@CvUnitEntry@@QBEPBDXZ	; CvUnitEntry::GetUnitArtInfoTag
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ?GetUnitArtInfoTag@CvUnitEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetUnitArtInfoTag@CvUnitEntry@@QBEPBDXZ PROC		; CvUnitEntry::GetUnitArtInfoTag, COMDAT
; _this$ = ecx

; 1122 : 	return m_strUnitArtInfoTag;

	add	ecx, 568				; 00000238H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetUnitArtInfoTag@CvUnitEntry@@QBEPBDXZ ENDP		; CvUnitEntry::GetUnitArtInfoTag
_TEXT	ENDS
PUBLIC	?GetUnitNames@CvUnitEntry@@QBEPBDH@Z		; CvUnitEntry::GetUnitNames
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z$0
__ehfuncinfo$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetUnitNames@CvUnitEntry@@QBEPBDH@Z
_TEXT	SEGMENT
$T220269 = -44						; size = 4
$T220266 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_i$ = 8							; size = 4
?GetUnitNames@CvUnitEntry@@QBEPBDH@Z PROC		; CvUnitEntry::GetUnitNames, COMDAT
; _this$ = ecx

; 1141 : {

	push	-1
	push	__ehhandler$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	xor	ebx, ebx

; 1142 : 	CvAssertMsg(i < GetNumUnitNames(), "Index out of bounds");
; 1143 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1144 : 	return (m_paszUnitNames) ? m_paszUnitNames[i] : NULL;

	mov	DWORD PTR $T220269[esp+48], ebx
	mov	eax, DWORD PTR [ecx+1008]
	push	esi
	cmp	eax, ebx
	je	SHORT $LN3@GetUnitNam
	mov	ecx, DWORD PTR _i$[esp+48]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN4@GetUnitNam
$LN3@GetUnitNam:
	push	ebx
	lea	ecx, DWORD PTR $T220266[esp+56]
	call	??0CvString@@QAE@H@Z			; CvString::CvString
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	mov	ebx, 1
	mov	DWORD PTR $T220269[esp+52], ebx
$LN4@GetUnitNam:
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, eax
	mov	DWORD PTR __$EHRec$[esp+60], -1
	test	bl, 1
	je	SHORT $LN13@GetUnitNam
	lea	ecx, DWORD PTR $T220266[esp+52]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN13@GetUnitNam:

; 1145 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z$0:
	mov	eax, DWORD PTR $T220269[ebp]
	and	eax, 1
	je	$LN6@GetUnitNam
	and	DWORD PTR $T220269[ebp], -2		; fffffffeH
	lea	ecx, DWORD PTR $T220266[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetUnitNam:
	ret	0
__ehhandler$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetUnitNames@CvUnitEntry@@QBEPBDH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetUnitNames@CvUnitEntry@@QBEPBDH@Z ENDP		; CvUnitEntry::GetUnitNames
PUBLIC	__real@3ff0000000000000
PUBLIC	?DoUpdatePower@CvUnitEntry@@QAEXXZ		; CvUnitEntry::DoUpdatePower
EXTRN	?GetDomainModifierPercent@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetDomainModifierPercent
EXTRN	?GetUnitClassDefenseModifier@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetUnitClassDefenseModifier
EXTRN	?GetUnitClassAttackModifier@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetUnitClassAttackModifier
EXTRN	?GetUnitClassModifierPercent@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetUnitClassModifierPercent
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?GetUnitCombatModifierPercent@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetUnitCombatModifierPercent
EXTRN	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumUnitCombatClassInfos
EXTRN	?GetFeatureDefensePercent@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetFeatureDefensePercent
EXTRN	?GetFeatureAttackPercent@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetFeatureAttackPercent
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
EXTRN	?GetTerrainDefensePercent@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetTerrainDefensePercent
EXTRN	?GetTerrainAttackPercent@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetTerrainAttackPercent
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
EXTRN	?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ:PROC	; CvPromotionEntry::IsOnlyDefensive
EXTRN	?IsMustSetUpToRangedAttack@CvPromotionEntry@@QBE_NXZ:PROC ; CvPromotionEntry::IsMustSetUpToRangedAttack
EXTRN	?IsBlitz@CvPromotionEntry@@QBE_NXZ:PROC		; CvPromotionEntry::IsBlitz
EXTRN	?GetDropRange@CvPromotionEntry@@QBEHXZ:PROC	; CvPromotionEntry::GetDropRange
EXTRN	?GetDefenseMod@CvPromotionEntry@@QBEHXZ:PROC	; CvPromotionEntry::GetDefenseMod
EXTRN	?GetAttackMod@CvPromotionEntry@@QBEHXZ:PROC	; CvPromotionEntry::GetAttackMod
EXTRN	?GetCityAttackPercent@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetCityAttackPercent
EXTRN	_pow:PROC
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DoUpdatePower@CvUnitEntry@@QAEXXZ
_TEXT	SEGMENT
$T220295 = -20						; size = 4
_iPromotionLoop$218622 = -20				; size = 4
_iPower$ = -20						; size = 4
$T220299 = -16						; size = 4
$T220290 = -16						; size = 8
$T220291 = -8						; size = 8
?DoUpdatePower@CvUnitEntry@@QAEXXZ PROC			; CvUnitEntry::DoUpdatePower, COMDAT
; _this$ = ecx

; 1205 : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 1206 : 	int iPower;
; 1207 : 
; 1208 : // ***************
; 1209 : // Main Factors - Strength & Moves
; 1210 : // ***************
; 1211 : 
; 1212 : 	// We want a Unit that has twice the strength to be roughly worth 3x as much with regards to Power
; 1213 : 	iPower = int(pow((double) GetCombat(), 1.5));

	mov	eax, DWORD PTR [ebp+372]
	mov	DWORD PTR $T220295[esp+64], eax
	fild	DWORD PTR $T220295[esp+64]
	sub	esp, 8
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	sub	esp, 8
	mov	DWORD PTR [eax+4], 1073217536		; 3ff80000H
	fstp	QWORD PTR [esp]
	call	_pow
	call	__ftol2_sse_excpt

; 1214 : 
; 1215 : 	// Ranged Strength
; 1216 : 	int iRangedStrength = int(pow((double) GetRangedCombat(), 1.45));

	mov	ecx, DWORD PTR [ebp+380]
	mov	esi, eax
	add	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T220299[esp+72], ecx
	fild	DWORD PTR $T220299[esp+72]
	mov	DWORD PTR [eax], 858993459		; 33333333H
	sub	esp, 8
	mov	DWORD PTR [eax+4], 1073165107		; 3ff73333H
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _iPower$[esp+80], esi
	call	_pow
	add	esp, 16					; 00000010H
	call	__ftol2_sse_excpt

; 1217 : 
; 1218 : 	// Naval ranged attacks are less useful
; 1219 : 	if(GetDomainType() == DOMAIN_SEA)

	cmp	DWORD PTR [ebp+436], ebx
	jne	SHORT $LN40@DoUpdatePo

; 1220 : 	{
; 1221 : 		iRangedStrength *= 3;

	lea	eax, DWORD PTR [eax+eax*2]

; 1222 : 		iRangedStrength /= 4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
$LN40@DoUpdatePo:

; 1223 : 	}
; 1224 : 
; 1225 : 	if(iRangedStrength > iPower)

	cmp	eax, esi
	jle	SHORT $LN39@DoUpdatePo

; 1226 : 	{
; 1227 : 		iPower = iRangedStrength;

	mov	DWORD PTR _iPower$[esp+64], eax
$LN39@DoUpdatePo:

; 1228 : 	}
; 1229 : 
; 1230 : 	// We want Movement rate to be important, but not a dominating factor; a Unit with double the moves of a similarly-strengthed Unit should be ~1.5x as Powerful
; 1231 : 	iPower = int((float) iPower * pow(min(1.0,(double) GetMoves()), 0.3));

	fild	DWORD PTR [ebp+288]
	mov	DWORD PTR $T220291[esp+64], ebx
	mov	DWORD PTR $T220291[esp+68], 1072693248	; 3ff00000H
	lea	ecx, DWORD PTR $T220290[esp+64]
	fstp	QWORD PTR $T220290[esp+64]
	fld1
	fcomp	QWORD PTR $T220290[esp+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN54@DoUpdatePo
	lea	ecx, DWORD PTR $T220291[esp+64]
$LN54@DoUpdatePo:
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], 858993459		; 33333333H
	mov	DWORD PTR [eax+4], 1070805811		; 3fd33333H
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	call	_pow
	fimul	DWORD PTR _iPower$[esp+80]
	add	esp, 16					; 00000010H
	call	__ftol2_sse_excpt
	mov	esi, eax

; 1232 : 
; 1233 : // ***************
; 1234 : // Other modifiers
; 1235 : // ***************
; 1236 : 
; 1237 : 	// Suicide Units are obviously less useful
; 1238 : 	if(IsSuicide())

	cmp	BYTE PTR [ebp+531], bl
	je	SHORT $LN38@DoUpdatePo

; 1239 : 	{
; 1240 : 		iPower /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
$LN38@DoUpdatePo:

; 1241 : 	}
; 1242 : 
; 1243 : 	// Nukes are cool
; 1244 : 	if(GetNukeDamageLevel() > 0)

	cmp	DWORD PTR [ebp+312], ebx
	jle	SHORT $LN37@DoUpdatePo

; 1245 : 	{
; 1246 : 		iPower += 4000;

	add	esi, 4000				; 00000fa0H
$LN37@DoUpdatePo:

; 1247 : 	}
; 1248 : 
; 1249 : // ***************
; 1250 : // Promotion modifiers
; 1251 : // ***************
; 1252 : 
; 1253 : 	int iTemp;
; 1254 : #ifdef AUI_WARNING_FIXES
; 1255 : 	uint iLoop;
; 1256 : 
; 1257 : 	for (uint iPromotionLoop = 0; iPromotionLoop < GC.getNumPromotionInfos(); iPromotionLoop++)
; 1258 : #else
; 1259 : 	int iLoop;
; 1260 : 
; 1261 : 	for(int iPromotionLoop = 0; iPromotionLoop < GC.getNumPromotionInfos(); iPromotionLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iPromotionLoop$218622[esp+64], ebx
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	test	eax, eax
	jle	$LN77@DoUpdatePo
$LN36@DoUpdatePo:

; 1262 : #endif
; 1263 : 	{
; 1264 : 		CvPromotionEntry* kPromotion = GC.getPromotionInfo((PromotionTypes)iPromotionLoop);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	edi, eax

; 1265 : 		if(kPromotion == NULL)

	test	edi, edi
	je	$LN35@DoUpdatePo

; 1266 : 			continue;
; 1267 : 
; 1268 : 		if(GetFreePromotions(iPromotionLoop))

	mov	eax, DWORD PTR [ebp+992]
	test	eax, eax
	je	$LN35@DoUpdatePo
	cmp	BYTE PTR [eax+ebx], 0
	je	$LN35@DoUpdatePo

; 1269 : 		{
; 1270 : 			// City Attack - add half of the bonus
; 1271 : 			if(kPromotion->GetCityAttackPercent() > 0)

	mov	ecx, edi
	call	?GetCityAttackPercent@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCityAttackPercent
	test	eax, eax
	jle	SHORT $LN31@DoUpdatePo

; 1272 : 			{
; 1273 : 				iTemp = (iPower * kPromotion->GetCityAttackPercent() / 2);

	mov	ecx, edi
	call	?GetCityAttackPercent@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCityAttackPercent
	imul	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1

; 1274 : 				iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1275 : 				iPower += iTemp;

	add	esi, eax
$LN31@DoUpdatePo:

; 1276 : 			}
; 1277 : 
; 1278 : 			// Attack - add half of the bonus
; 1279 : 			if(kPromotion->GetAttackMod() > 0)

	mov	ecx, edi
	call	?GetAttackMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetAttackMod
	test	eax, eax
	jle	SHORT $LN30@DoUpdatePo

; 1280 : 			{
; 1281 : 				iTemp = (iPower * kPromotion->GetAttackMod() / 2);

	mov	ecx, edi
	call	?GetAttackMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetAttackMod
	imul	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1

; 1282 : 				iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1283 : 				iPower += iTemp;

	add	esi, ecx
$LN30@DoUpdatePo:

; 1284 : 			}
; 1285 : 
; 1286 : 			// Defense - add half of the bonus
; 1287 : 			if(kPromotion->GetDefenseMod() > 0)

	mov	ecx, edi
	call	?GetDefenseMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetDefenseMod
	test	eax, eax
	jle	SHORT $LN29@DoUpdatePo

; 1288 : 			{
; 1289 : 				iTemp = (iPower * kPromotion->GetDefenseMod() / 2);

	mov	ecx, edi
	call	?GetDefenseMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetDefenseMod
	imul	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1

; 1290 : 				iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1291 : 				iPower += iTemp;

	add	esi, eax
$LN29@DoUpdatePo:

; 1292 : 			}
; 1293 : 
; 1294 : 			// Paradrop - add 25%
; 1295 : 			if(kPromotion->GetDropRange() > 0)

	mov	ecx, edi
	call	?GetDropRange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetDropRange
	test	eax, eax
	jle	SHORT $LN28@DoUpdatePo

; 1296 : 			{
; 1297 : 				iTemp = iPower;
; 1298 : 				iTemp /= 4;

	mov	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2

; 1299 : 				iPower += iTemp;

	add	esi, eax
$LN28@DoUpdatePo:

; 1300 : 			}
; 1301 : 
; 1302 : 			// Blitz - add 20%
; 1303 : 			if(kPromotion->IsBlitz())

	mov	ecx, edi
	call	?IsBlitz@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsBlitz
	test	al, al
	je	SHORT $LN27@DoUpdatePo

; 1304 : 			{
; 1305 : 				iTemp = iPower;
; 1306 : 				iTemp /= 5;

	mov	eax, 1717986919				; 66666667H
	imul	esi
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1307 : 				iPower += iTemp;

	add	esi, ecx
$LN27@DoUpdatePo:

; 1308 : 			}
; 1309 : 
; 1310 : 			// Set Up For Ranged Attack - reduce by 20%
; 1311 : 			if(kPromotion->IsMustSetUpToRangedAttack())

	mov	ecx, edi
	call	?IsMustSetUpToRangedAttack@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsMustSetUpToRangedAttack
	test	al, al
	je	SHORT $LN26@DoUpdatePo

; 1312 : 			{
; 1313 : 				iTemp = iPower;
; 1314 : 				iTemp /= 5;

	mov	eax, -1717986919			; 99999999H
	imul	esi
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1315 : 				iPower -= iTemp;

	add	esi, eax
$LN26@DoUpdatePo:

; 1316 : 			}
; 1317 : 
; 1318 : 			// Only Defensive - reduce  by 25%, but only if the Unit has no ranged capability
; 1319 : 			if(kPromotion->IsOnlyDefensive() && GetRangedCombat() == 0)

	mov	ecx, edi
	call	?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsOnlyDefensive
	test	al, al
	je	SHORT $LN25@DoUpdatePo
	cmp	DWORD PTR [ebp+380], 0
	jne	SHORT $LN25@DoUpdatePo

; 1320 : 			{
; 1321 : 				iTemp = iPower;
; 1322 : 				iTemp /= 4;

	mov	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	neg	eax

; 1323 : 				iPower -= iTemp;

	add	esi, eax
$LN25@DoUpdatePo:

; 1324 : 			}
; 1325 : 
; 1326 : 			for(iLoop = 0; iLoop < GC.getNumTerrainInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	test	eax, eax
	jle	SHORT $LN22@DoUpdatePo
$LL24@DoUpdatePo:

; 1327 : 			{
; 1328 : 				// Terrain Attack - add one quarter of the bonus
; 1329 : 				if(kPromotion->GetTerrainAttackPercent(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetTerrainAttackPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainAttackPercent
	test	eax, eax
	jle	SHORT $LN21@DoUpdatePo

; 1330 : 				{
; 1331 : 					iTemp = (iPower * kPromotion->GetTerrainAttackPercent(iLoop) / 4);

	push	ebx
	mov	ecx, edi
	call	?GetTerrainAttackPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainAttackPercent
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2

; 1332 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1333 : 					iPower += iTemp;

	add	esi, ecx
$LN21@DoUpdatePo:

; 1334 : 				}
; 1335 : 				// Terrain Defense - add one quarter of the bonus
; 1336 : 				if(kPromotion->GetTerrainDefensePercent(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetTerrainDefensePercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainDefensePercent
	test	eax, eax
	jle	SHORT $LN23@DoUpdatePo

; 1337 : 				{
; 1338 : 					iTemp = (iPower * kPromotion->GetTerrainDefensePercent(iLoop) / 4);

	push	ebx
	mov	ecx, edi
	call	?GetTerrainDefensePercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainDefensePercent
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2

; 1339 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1340 : 					iPower += iTemp;

	add	esi, eax
$LN23@DoUpdatePo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	ebx, eax
	jl	SHORT $LL24@DoUpdatePo
$LN22@DoUpdatePo:

; 1341 : 				}
; 1342 : 			}
; 1343 : 
; 1344 : 			for(iLoop = 0; iLoop < GC.getNumFeatureInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	test	eax, eax
	jle	SHORT $LN17@DoUpdatePo
	npad	4
$LL19@DoUpdatePo:

; 1345 : 			{
; 1346 : 				// Feature Attack - add one quarter of the bonus
; 1347 : 				if(kPromotion->GetFeatureAttackPercent(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetFeatureAttackPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetFeatureAttackPercent
	test	eax, eax
	jle	SHORT $LN16@DoUpdatePo

; 1348 : 				{
; 1349 : 					iTemp = (iPower * kPromotion->GetFeatureAttackPercent(iLoop) / 4);

	push	ebx
	mov	ecx, edi
	call	?GetFeatureAttackPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetFeatureAttackPercent
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2

; 1350 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1351 : 					iPower += iTemp;

	add	esi, ecx
$LN16@DoUpdatePo:

; 1352 : 				}
; 1353 : 				// Feature Defense - add one quarter of the bonus
; 1354 : 				if(kPromotion->GetFeatureDefensePercent(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetFeatureDefensePercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetFeatureDefensePercent
	test	eax, eax
	jle	SHORT $LN18@DoUpdatePo

; 1355 : 				{
; 1356 : 					iTemp = (iPower * kPromotion->GetFeatureDefensePercent(iLoop) / 4);

	push	ebx
	mov	ecx, edi
	call	?GetFeatureDefensePercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetFeatureDefensePercent
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2

; 1357 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1358 : 					iPower += iTemp;

	add	esi, eax
$LN18@DoUpdatePo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	ebx, eax
	jl	SHORT $LL19@DoUpdatePo
$LN17@DoUpdatePo:

; 1359 : 				}
; 1360 : 			}
; 1361 : 
; 1362 : 			for(iLoop = 0; iLoop < GC.getNumUnitCombatClassInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	test	eax, eax
	jle	SHORT $LN12@DoUpdatePo
	npad	7
$LL14@DoUpdatePo:

; 1363 : 			{
; 1364 : 				// Unit Combat Class (e.g. Pikemen) - add one quarter of the bonus
; 1365 : 				if(kPromotion->GetUnitCombatModifierPercent(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetUnitCombatModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitCombatModifierPercent
	test	eax, eax
	jle	SHORT $LN13@DoUpdatePo

; 1366 : 				{
; 1367 : 					iTemp = (iPower * kPromotion->GetUnitCombatModifierPercent(iLoop) / 4);

	push	ebx
	mov	ecx, edi
	call	?GetUnitCombatModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitCombatModifierPercent
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2

; 1368 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1369 : 					iPower += iTemp;

	add	esi, ecx
$LN13@DoUpdatePo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	cmp	ebx, eax
	jl	SHORT $LL14@DoUpdatePo
$LN12@DoUpdatePo:

; 1370 : 				}
; 1371 : 			}
; 1372 : 
; 1373 : 			for(iLoop = 0; iLoop < GC.getNumUnitClassInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	test	eax, eax
	jle	$LN8@DoUpdatePo
$LL10@DoUpdatePo:

; 1374 : 			{
; 1375 : 				// Unit Class (e.g. bonus ONLY against Galleys) - add one eighth of the bonus
; 1376 : 				// We're assuming here that the bonus against the other Unit is at least going to be somewhat useful - trust the XML! :o
; 1377 : 				if(kPromotion->GetUnitClassModifierPercent(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetUnitClassModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassModifierPercent
	test	eax, eax
	jle	SHORT $LN7@DoUpdatePo

; 1378 : 				{
; 1379 : 					iTemp = (iPower * kPromotion->GetUnitClassModifierPercent(iLoop) / 8);

	push	ebx
	mov	ecx, edi
	call	?GetUnitClassModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassModifierPercent
	imul	eax, esi
	cdq
	and	edx, 7
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 3

; 1380 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1381 : 					iPower += iTemp;

	add	esi, eax
$LN7@DoUpdatePo:

; 1382 : 				}
; 1383 : 				// Unit Class Attack - one tenth of the bonus
; 1384 : 				if(kPromotion->GetUnitClassAttackModifier(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetUnitClassAttackModifier@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassAttackModifier
	test	eax, eax
	jle	SHORT $LN6@DoUpdatePo

; 1385 : 				{
; 1386 : 					iTemp = (iPower * kPromotion->GetUnitClassAttackModifier(iLoop) / 10);

	push	ebx
	mov	ecx, edi
	call	?GetUnitClassAttackModifier@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassAttackModifier
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1387 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1388 : 					iPower += iTemp;

	add	esi, ecx
$LN6@DoUpdatePo:

; 1389 : 				}
; 1390 : 				// Unit Class Defense - one tenth of the bonus
; 1391 : 				if(kPromotion->GetUnitClassDefenseModifier(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetUnitClassDefenseModifier@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassDefenseModifier
	test	eax, eax
	jle	SHORT $LN9@DoUpdatePo

; 1392 : 				{
; 1393 : 					iTemp = (iPower * kPromotion->GetUnitClassDefenseModifier(iLoop) / 10);

	push	ebx
	mov	ecx, edi
	call	?GetUnitClassDefenseModifier@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassDefenseModifier
	mov	ecx, eax
	imul	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1394 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1395 : 					iPower += iTemp;

	add	esi, eax
$LN9@DoUpdatePo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	ebx, eax
	jl	$LL10@DoUpdatePo
$LN8@DoUpdatePo:

; 1396 : 				}
; 1397 : 			}
; 1398 : 
; 1399 : 			for(iLoop = 0; iLoop < NUM_DOMAIN_TYPES; iLoop++)

	xor	ebx, ebx
	npad	4
$LL4@DoUpdatePo:

; 1400 : 			{
; 1401 : 				// Domain - add one quarter of the bonus
; 1402 : 				if(kPromotion->GetDomainModifierPercent(iLoop) > 0)

	push	ebx
	mov	ecx, edi
	call	?GetDomainModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetDomainModifierPercent
	test	eax, eax
	jle	SHORT $LN3@DoUpdatePo

; 1403 : 				{
; 1404 : 					iTemp = (iPower * kPromotion->GetDomainModifierPercent(iLoop) / 4);

	push	ebx
	mov	ecx, edi
	call	?GetDomainModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetDomainModifierPercent
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2

; 1405 : 					iTemp /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1406 : 					iPower += iTemp;

	add	esi, ecx
$LN3@DoUpdatePo:
	inc	ebx
	cmp	ebx, 5
	jl	SHORT $LL4@DoUpdatePo

; 1396 : 				}
; 1397 : 			}
; 1398 : 
; 1399 : 			for(iLoop = 0; iLoop < NUM_DOMAIN_TYPES; iLoop++)

	mov	ebx, DWORD PTR _iPromotionLoop$218622[esp+64]
$LN35@DoUpdatePo:

; 1247 : 	}
; 1248 : 
; 1249 : // ***************
; 1250 : // Promotion modifiers
; 1251 : // ***************
; 1252 : 
; 1253 : 	int iTemp;
; 1254 : #ifdef AUI_WARNING_FIXES
; 1255 : 	uint iLoop;
; 1256 : 
; 1257 : 	for (uint iPromotionLoop = 0; iPromotionLoop < GC.getNumPromotionInfos(); iPromotionLoop++)
; 1258 : #else
; 1259 : 	int iLoop;
; 1260 : 
; 1261 : 	for(int iPromotionLoop = 0; iPromotionLoop < GC.getNumPromotionInfos(); iPromotionLoop++)

	inc	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iPromotionLoop$218622[esp+64], ebx
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	ebx, eax
	jl	$LN36@DoUpdatePo
$LN77@DoUpdatePo:

; 1407 : 				}
; 1408 : 			}
; 1409 : 		}
; 1410 : 	}
; 1411 : 
; 1412 : 	// Debug output
; 1413 : 	//char temp[256];
; 1414 : 	//sprintf(temp, "%s: %i\n", GetDescription(), iPower);
; 1415 : 	//OutputDebugString(temp);
; 1416 : 
; 1417 : 	m_iCachedPower = iPower;
; 1418 : }

	pop	edi
	mov	DWORD PTR [ebp+556], esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoUpdatePower@CvUnitEntry@@QAEXXZ ENDP			; CvUnitEntry::DoUpdatePower
_TEXT	ENDS
PUBLIC	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ		; CvUnitXMLEntries::GetNumUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumUnits@CvUnitXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumUnits@CvUnitXMLEntries@@QAEHXZ PROC		; CvUnitXMLEntries::GetNumUnits, COMDAT
; _this$ = ecx

; 1457 : 	return m_paUnitEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1458 : }

	ret	0
?GetNumUnits@CvUnitXMLEntries@@QAEHXZ ENDP		; CvUnitXMLEntries::GetNumUnits
_TEXT	ENDS
PUBLIC	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z PROC	; CvUnitXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 1479 : 	return m_paUnitEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1480 : }

	ret	4
?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ENDP	; CvUnitXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEAAPAVCvUnitEntry@@XZ ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEAAPAVCvUnitEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEAAPAVCvUnitEntry@@XZ PROC ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEAAPAVCvUnitEntry@@XZ ENDP ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >::~_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >::~_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >::~_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z ; std::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z PROC ; std::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE@V?$allocator@PAVCvUnitEntry@@@1@@Z ENDP ; std::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_val<CvUnitEntry *,std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z PROC ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@PAPAVCvUnitEntry@@@Z ENDP ; std::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Vector_iterator<CvUnitEntry *,std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@@Z ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@@Z PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@@Z ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvUnitEntry@@@std@@QAEPAPAVCvUnitEntry@@I@Z ; std::allocator<CvUnitEntry *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvUnitEntry@@@std@@QAEPAPAVCvUnitEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvUnitEntry@@@std@@QAEPAPAVCvUnitEntry@@I@Z PROC ; std::allocator<CvUnitEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvUnitEntry@@@std@@YAPAPAVCvUnitEntry@@IPAPAV1@@Z ; std::_Allocate<CvUnitEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvUnitEntry@@@std@@QAEPAPAVCvUnitEntry@@I@Z ENDP ; std::allocator<CvUnitEntry *>::allocate
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z ; SAFE_DELETE_ARRAY<CvString>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z PROC ; SAFE_DELETE_ARRAY<CvString>, COMDAT

; 311  : {

	push	edi

; 312  : 	delete[] pkInstanceArray;

	mov	edi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN13@SAFE_DELET
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	ecx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN13@SAFE_DELET:

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvString@@@@YAXAAPAVCvString@@@Z ENDP ; SAFE_DELETE_ARRAY<CvString>
_TEXT	ENDS
PUBLIC	??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ; CvDatabaseUtility::InitializeArray<int>
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_szTableName$ = 12					; size = 4
_default$ = 16						; size = 4
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z PROC ; CvDatabaseUtility::InitializeArray<int>, COMDAT
; _this$ = ecx

; 180  : 	size_t count = MaxRows(szTableName);

	mov	eax, DWORD PTR _szTableName$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 181  : 
; 182  : 	//This is a bit of a hack to support empty tables.
; 183  : 	//For example, the "Automates" table will be empty during a tutorial.
; 184  : 	//We cannot simply NULL out the array because WAY too much code blindly assumes SOMETHING will be there..
; 185  : 	//Instead we allocate room for 1 element and just roll with it.
; 186  : 
; 187  : 	//CvAssertMsg(count > 0, DB.ErrorMessage());
; 188  : 	if(count == 0)

	test	eax, eax
	jne	SHORT $LN1@Initialize@2

; 189  : 		count = 1;

	mov	eax, 1
$LN1@Initialize@2:

; 190  : 
; 191  : 	InitializeArray(pArray, count, default);

	mov	ecx, DWORD PTR _default$[esp]
	mov	edx, DWORD PTR _pArray$[esp]
	push	ecx
	push	eax
	push	edx
	mov	ecx, esi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
	pop	esi

; 192  : }

	ret	12					; 0000000cH
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ENDP ; CvDatabaseUtility::InitializeArray<int>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$219028 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$219031 = -8					; size = 4
_tValue$219036 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$219028[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$219031[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$219031[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$219028[esp+32], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$219036[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4UnitTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum UnitTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4UnitTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4UnitTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4UnitTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum UnitTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4UnitTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	edi
$LN2@WriteHashe:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4UnitTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum UnitTypes,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvUnitEntry@@PAPAV1@@stdext@@YAPAPAVCvUnitEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvUnitEntry * *,CvUnitEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvUnitEntry@@PAPAV1@@stdext@@YAPAPAVCvUnitEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvUnitEntry@@PAPAV1@@stdext@@YAPAPAVCvUnitEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvUnitEntry * *,CvUnitEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvUnitEntry@@PAPAV1@@stdext@@YAPAPAVCvUnitEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvUnitEntry * *,CvUnitEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvUnitEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvUnitEntry@@@std@@@std@@YAXPAPAVCvUnitEntry@@0AAV?$allocator@PAVCvUnitEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	??_7CvUnitEntry@@6B@				; CvUnitEntry::`vftable'
PUBLIC	??0CvUnitEntry@@QAE@XZ				; CvUnitEntry::CvUnitEntry
PUBLIC	??_R4CvUnitEntry@@6B@				; CvUnitEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvUnitEntry@@@8				; CvUnitEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvUnitEntry@@8				; CvUnitEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvUnitEntry@@8				; CvUnitEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvUnitEntry@@8			; CvUnitEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvUnitEntry::CacheResults
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvUnitEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvUnitEntry@@8 DD FLAT:??_R0?AVCvUnitEntry@@@8 ; CvUnitEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvUnitEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvUnitEntry@@8
rdata$r	SEGMENT
??_R2CvUnitEntry@@8 DD FLAT:??_R1A@?0A@EA@CvUnitEntry@@8 ; CvUnitEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvUnitEntry@@8
rdata$r	SEGMENT
??_R3CvUnitEntry@@8 DD 00H				; CvUnitEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvUnitEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvUnitEntry@@@8
_DATA	SEGMENT
??_R0?AVCvUnitEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvUnitEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvUnitEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvUnitEntry@@6B@
rdata$r	SEGMENT
??_R4CvUnitEntry@@6B@ DD 00H				; CvUnitEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvUnitEntry@@@8
	DD	FLAT:??_R3CvUnitEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvUnitEntry@@6B@
CONST	SEGMENT
??_7CvUnitEntry@@6B@ DD FLAT:??_R4CvUnitEntry@@6B@	; CvUnitEntry::`vftable'
	DD	FLAT:?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvUnitEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvUnitEntry@@QAE@XZ$0
__ehfuncinfo$??0CvUnitEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvUnitEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvUnitEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvUnitEntry@@QAE@XZ PROC				; CvUnitEntry::CvUnitEntry, COMDAT
; _this$ = ecx

; 133  : {

	push	-1
	push	__ehhandler$??0CvUnitEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvUnitEntry@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	BYTE PTR [esi+272], bl
	mov	BYTE PTR [esi+273], bl
	mov	BYTE PTR [esi+274], bl
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	DWORD PTR [esi+288], ebx
	mov	BYTE PTR [esi+292], bl
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], ebx
	mov	BYTE PTR [esi+340], bl
	mov	DWORD PTR [esi+344], ebx
	mov	DWORD PTR [esi+348], ebx
	mov	BYTE PTR [esi+352], bl
	mov	DWORD PTR [esi+356], ebx
	mov	DWORD PTR [esi+360], ebx
	mov	BYTE PTR [esi+364], bl
	mov	BYTE PTR [esi+365], bl
	mov	BYTE PTR [esi+366], bl
	mov	BYTE PTR [esi+367], bl
	mov	BYTE PTR [esi+368], bl
	mov	DWORD PTR [esi+372], ebx
	mov	DWORD PTR [esi+376], ebx
	mov	DWORD PTR [esi+380], ebx
	mov	DWORD PTR [esi+384], ebx
	mov	DWORD PTR [esi+388], ebx
	mov	DWORD PTR [esi+392], ebx
	mov	DWORD PTR [esi+396], ebx
	mov	DWORD PTR [esi+400], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	BYTE PTR [esi+412], bl
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+420], eax
	mov	DWORD PTR [esi+424], eax
	mov	DWORD PTR [esi+428], eax
	mov	DWORD PTR [esi+432], eax
	mov	DWORD PTR [esi+436], eax
	mov	DWORD PTR [esi+440], eax
	mov	DWORD PTR [esi+444], eax
	mov	DWORD PTR [esi+448], eax
	mov	DWORD PTR [esi+452], eax
	mov	DWORD PTR [esi+456], eax
	mov	DWORD PTR [esi+460], eax
	mov	DWORD PTR [esi+464], eax
	mov	DWORD PTR [esi+468], ebx
	mov	DWORD PTR [esi+472], ebx
	mov	DWORD PTR [esi+476], ebx
	mov	DWORD PTR [esi+480], ebx
	mov	DWORD PTR [esi+484], ebx
	mov	DWORD PTR [esi+488], eax
	mov	BYTE PTR [esi+496], bl
	mov	BYTE PTR [esi+497], bl
	mov	BYTE PTR [esi+498], bl
	mov	BYTE PTR [esi+499], bl
	mov	BYTE PTR [esi+500], bl
	mov	BYTE PTR [esi+501], bl
	mov	BYTE PTR [esi+502], bl
	mov	BYTE PTR [esi+503], bl
	lea	ecx, DWORD PTR [esi+568]
	mov	DWORD PTR [esi+504], ebx
	mov	DWORD PTR [esi+512], ebx
	mov	DWORD PTR [esi+516], ebx
	mov	DWORD PTR [esi+520], ebx
	mov	DWORD PTR [esi+524], ebx
	mov	BYTE PTR [esi+528], bl
	mov	BYTE PTR [esi+529], bl
	mov	BYTE PTR [esi+530], bl
	mov	BYTE PTR [esi+531], bl
	mov	BYTE PTR [esi+532], bl
	mov	BYTE PTR [esi+533], bl
	mov	BYTE PTR [esi+548], bl
	mov	DWORD PTR [esi+552], ebx
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR [esi+596], bl
	mov	BYTE PTR [esi+597], bl
	lea	eax, DWORD PTR [esi+600]
	lea	ecx, DWORD PTR [ebx+11]
	lea	edx, DWORD PTR [ebx+1]
	npad	6
$LL9@CvUnitEntr:
	mov	DWORD PTR [eax], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], edx
	add	eax, 28					; 0000001cH
	sub	ecx, edx
	jns	SHORT $LL9@CvUnitEntr

; 134  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+936], ebx
	mov	DWORD PTR [esi+940], ebx
	mov	DWORD PTR [esi+944], ebx
	mov	DWORD PTR [esi+948], ebx
	mov	DWORD PTR [esi+952], ebx
	mov	DWORD PTR [esi+964], ebx
	mov	DWORD PTR [esi+968], ebx
	mov	DWORD PTR [esi+972], ebx
	mov	DWORD PTR [esi+976], ebx
	mov	DWORD PTR [esi+980], ebx
	mov	DWORD PTR [esi+984], ebx
	mov	DWORD PTR [esi+988], ebx
	mov	DWORD PTR [esi+992], ebx
	mov	DWORD PTR [esi+996], ebx
	mov	DWORD PTR [esi+1000], ebx
	mov	DWORD PTR [esi+1004], ebx
	mov	DWORD PTR [esi+1008], ebx
	mov	DWORD PTR [esi+1012], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvUnitEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvUnitEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvUnitEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvUnitEntry@@QAE@XZ ENDP				; CvUnitEntry::CvUnitEntry
PUBLIC	??1CvUnitEntry@@QAE@XZ				; CvUnitEntry::~CvUnitEntry
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvUnitEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvUnitEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvUnitEntry@@QAE@XZ$1
__ehfuncinfo$??1CvUnitEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvUnitEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvUnitEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvUnitEntry@@QAE@XZ PROC				; CvUnitEntry::~CvUnitEntry, COMDAT
; _this$ = ecx

; 138  : {

	push	-1
	push	__ehhandler$??1CvUnitEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvUnitEntry@@6B@

; 139  : 	SAFE_DELETE_ARRAY(m_pbUpgradeUnitClass);

	mov	eax, DWORD PTR [esi+964]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], 1
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+964], ebx

; 140  : 	SAFE_DELETE_ARRAY(m_pbUnitAIType);

	mov	eax, DWORD PTR [esi+968]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+968], ebx

; 141  : 	SAFE_DELETE_ARRAY(m_pbNotUnitAIType);

	mov	eax, DWORD PTR [esi+972]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+972], ebx

; 142  : 	SAFE_DELETE_ARRAY(m_pbBuilds);

	mov	eax, DWORD PTR [esi+976]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+976], ebx

; 143  : 	SAFE_DELETE_ARRAY(m_pbGreatPeoples);

	mov	eax, DWORD PTR [esi+980]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+980], ebx

; 144  : 	SAFE_DELETE_ARRAY(m_pbBuildings);

	mov	eax, DWORD PTR [esi+984]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+984], ebx

; 145  : 	SAFE_DELETE_ARRAY(m_pbBuildingClassRequireds);

	mov	eax, DWORD PTR [esi+988]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+988], ebx

; 146  : 	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);

	mov	eax, DWORD PTR [esi+936]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+936], ebx

; 147  : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	eax, DWORD PTR [esi+940]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+940], ebx

; 148  : 	SAFE_DELETE_ARRAY(m_piProductionTraits);

	mov	eax, DWORD PTR [esi+944]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+944], ebx

; 149  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+948]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+948], ebx

; 150  : 	SAFE_DELETE_ARRAY(m_piUnitGroupRequired);

	mov	eax, DWORD PTR [esi+952]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+952], ebx

; 151  : 	SAFE_DELETE_ARRAY(m_pbFreePromotions);

	mov	eax, DWORD PTR [esi+992]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+992], ebx

; 152  : 	SAFE_DELETE_ARRAY(m_paszEarlyArtDefineTags);

	mov	eax, DWORD PTR [esi+996]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN33@CvUnitEntr@2
	mov	ecx, DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	ecx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN33@CvUnitEntr@2:
	mov	DWORD PTR [esi+996], ebx

; 153  : 	SAFE_DELETE_ARRAY(m_paszLateArtDefineTags);

	mov	eax, DWORD PTR [esi+1000]
	cmp	eax, ebx
	je	SHORT $LN45@CvUnitEntr@2
	mov	edx, DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	edx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN45@CvUnitEntr@2:
	mov	DWORD PTR [esi+1000], ebx

; 154  : 	SAFE_DELETE_ARRAY(m_paszMiddleArtDefineTags);

	mov	eax, DWORD PTR [esi+1004]
	cmp	eax, ebx
	je	SHORT $LN57@CvUnitEntr@2
	mov	ecx, DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	ecx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN57@CvUnitEntr@2:
	mov	DWORD PTR [esi+1004], ebx

; 155  : 	SAFE_DELETE_ARRAY(m_paszUnitNames);

	mov	eax, DWORD PTR [esi+1008]
	cmp	eax, ebx
	je	SHORT $LN69@CvUnitEntr@2
	mov	edx, DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	edx
	push	28					; 0000001cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN69@CvUnitEntr@2:
	mov	DWORD PTR [esi+1008], ebx

; 156  : 	SAFE_DELETE_ARRAY(m_paeGreatWorks);

	mov	eax, DWORD PTR [esi+1012]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 	SAFE_DELETE_ARRAY(m_piProductionModifierBuildings);
; 159  : 	SAFE_DELETE_ARRAY(m_piYieldFromKills);
; 160  : #endif
; 161  : }

	lea	ecx, DWORD PTR [esi+568]
	mov	DWORD PTR [esi+1012], ebx
	mov	BYTE PTR __$EHRec$[esp+36], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvUnitEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvUnitEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 568				; 00000238H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvUnitEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvUnitEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvUnitEntry@@QAE@XZ ENDP				; CvUnitEntry::~CvUnitEntry
EXTRN	__imp_?GetFloat@Results@Database@@QAEMPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDH@Z:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv1619 = -84						; size = 4
tv1606 = -84						; size = 4
_f3$218197 = -84					; size = 4
_f4$218199 = -80					; size = 4
_f5$218201 = -76					; size = 4
_f6$218203 = -72					; size = 4
$T220788 = -72						; size = 4
_strKey$218168 = -68					; size = 28
_strKey$218153 = -68					; size = 28
_strKey$218144 = -68					; size = 28
_strKey$218181 = -40					; size = 28
__$EHRec$ = -12						; size = 12
tv1617 = 8						; size = 4
tv1369 = 8						; size = 4
tv1365 = 8						; size = 4
_count$220830 = 8					; size = 4
_f2$218195 = 8						; size = 4
_pResults$218170 = 8					; size = 4
_pUnitNameCount$218155 = 8				; size = 4
_pResults$218146 = 8					; size = 4
_kResults$ = 8						; size = 4
_f1$218193 = 12						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvUnitEntry::CacheResults, COMDAT
; _this$ = ecx

; 164  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 165  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+88]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN15@CacheResul
	pop	edi
	pop	esi

; 438  : 
; 439  : 	return true;
; 440  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN15@CacheResul:
	push	ebx
	push	ebp

; 166  : 		return false;
; 167  : 
; 168  : 	//Basic Properties
; 169  : 	m_iProductionCost = kResults.GetInt("Cost");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG217994
	mov	ecx, edi
	call	ebp

; 170  : #ifdef NQ_UNIT_FINAL_PRODUCTION_COST_MODIFIER
; 171  : 	m_iFinalProductionCostModifier = kResults.GetInt("FinalProductionCostModifier");

	push	OFFSET $SG217995
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebp

; 172  : #endif
; 173  : 	m_iFaithCost = kResults.GetInt("FaithCost");

	push	OFFSET $SG217996
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebp

; 174  : 	m_bRequiresFaithPurchaseEnabled = kResults.GetBool("RequiresFaithPurchaseEnabled");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG217997
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 175  : 	m_bPurchaseOnly = kResults.GetBool("PurchaseOnly");

	push	OFFSET $SG217998
	mov	ecx, edi
	mov	BYTE PTR [esi+272], al
	call	ebx

; 176  : 	m_bMoveAfterPurchase = kResults.GetBool("MoveAfterPurchase");

	push	OFFSET $SG217999
	mov	ecx, edi
	mov	BYTE PTR [esi+273], al
	call	ebx

; 177  : 	m_iHurryCostModifier = kResults.GetInt("HurryCostModifier");

	push	OFFSET $SG218000
	mov	ecx, edi
	mov	BYTE PTR [esi+274], al
	call	ebp

; 178  : 	m_iAdvancedStartCost = kResults.GetInt("AdvancedStartCost");

	push	OFFSET $SG218001
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebp

; 179  : 	m_iMinAreaSize = kResults.GetInt("MinAreaSize");

	push	OFFSET $SG218002
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebp

; 180  : 	m_iMoves = kResults.GetInt("Moves");

	push	OFFSET $SG218003
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebp

; 181  : 	m_bMoves = kResults.GetInt("Immobile");

	push	OFFSET $SG218004
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebp
	test	eax, eax
	setne	cl
	mov	BYTE PTR [esi+292], cl

; 182  : 	m_iBaseSightRange = kResults.GetInt("BaseSightRange");

	push	OFFSET $SG218005
	mov	ecx, edi
	call	ebp

; 183  : 	m_iRange = kResults.GetInt("Range");

	push	OFFSET $SG218006
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebp

; 184  : 	m_iAirInterceptRange = kResults.GetInt("AirInterceptRange");

	push	OFFSET $SG218007
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebp

; 185  : 	m_iAirUnitCap = kResults.GetInt("AirUnitCap");

	push	OFFSET $SG218008
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebp

; 186  : 	m_iNukeDamageLevel = kResults.GetInt("NukeDamageLevel");

	push	OFFSET $SG218009
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebp

; 187  : 	m_iWorkRate = kResults.GetInt("WorkRate");

	push	OFFSET $SG218010
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebp

; 188  : 	m_iNumFreeTechs = kResults.GetInt("NumFreeTechs");

	push	OFFSET $SG218011
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebp

; 189  : 	m_iBaseBeakersTurnsToCount = kResults.GetInt("BaseBeakersTurnsToCount");

	push	OFFSET $SG218012
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebp

; 190  : 	m_iBaseCultureTurnsToCount = kResults.GetInt("BaseCultureTurnsToCount");

	push	OFFSET $SG218013
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebp

; 191  : 	m_iBaseHurry = kResults.GetInt("BaseHurry");

	push	OFFSET $SG218014
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebp

; 192  : 	m_iHurryMultiplier = kResults.GetInt("HurryMultiplier");

	push	OFFSET $SG218015
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	ebp

; 193  : 	m_bRushBuilding= kResults.GetInt("RushBuilding");

	push	OFFSET $SG218016
	mov	ecx, edi
	mov	DWORD PTR [esi+336], eax
	call	ebp
	test	eax, eax
	setne	dl

; 194  : 	m_iBaseGold = kResults.GetInt("BaseGold");

	push	OFFSET $SG218017
	mov	ecx, edi
	mov	BYTE PTR [esi+340], dl
	call	ebp

; 195  : 	m_iNumGoldPerEra = kResults.GetInt("NumGoldPerEra");

	push	OFFSET $SG218018
	mov	ecx, edi
	mov	DWORD PTR [esi+344], eax
	call	ebp

; 196  : 	m_bSpreadReligion = kResults.GetBool("SpreadReligion");

	push	OFFSET $SG218019
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	ebx

; 197  : 	m_bRemoveHeresy = kResults.GetBool("RemoveHeresy");

	push	OFFSET $SG218020
	mov	ecx, edi
	mov	BYTE PTR [esi+352], al
	call	ebx

; 198  : 	m_iReligionSpreads = kResults.GetInt("ReligionSpreads");

	push	OFFSET $SG218021
	mov	ecx, edi
	mov	BYTE PTR [esi+367], al
	call	ebp

; 199  : 	m_iReligiousStrength = kResults.GetInt("ReligiousStrength");

	push	OFFSET $SG218022
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	ebp

; 200  : 	m_bFoundReligion = kResults.GetBool("FoundReligion");

	push	OFFSET $SG218023
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	ebx

; 201  : 	m_bRequiresEnhancedReligion = kResults.GetBool("RequiresEnhancedReligion");

	push	OFFSET $SG218024
	mov	ecx, edi
	mov	BYTE PTR [esi+364], al
	call	ebx

; 202  : 	m_bProhibitsSpread = kResults.GetBool("ProhibitsSpread");

	push	OFFSET $SG218025
	mov	ecx, edi
	mov	BYTE PTR [esi+365], al
	call	ebx

; 203  : 	m_bCanBuyCityState = kResults.GetBool("CanBuyCityState");

	push	OFFSET $SG218026
	mov	ecx, edi
	mov	BYTE PTR [esi+366], al
	call	ebx

; 204  : 	m_iCombat = kResults.GetInt("Combat");

	push	OFFSET $SG218027
	mov	ecx, edi
	mov	BYTE PTR [esi+368], al
	call	ebp

; 205  : 	m_iCombatLimit = kResults.GetInt("CombatLimit");

	push	OFFSET $SG218028
	mov	ecx, edi
	mov	DWORD PTR [esi+372], eax
	call	ebp

; 206  : 	m_iRangedCombat = kResults.GetInt("RangedCombat");

	push	OFFSET $SG218029
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	ebp

; 207  : 	m_iRangedCombatLimit = kResults.GetInt("RangedCombatLimit");

	push	OFFSET $SG218030
	mov	ecx, edi
	mov	DWORD PTR [esi+380], eax
	call	ebp

; 208  : 	m_iXPValueAttack = kResults.GetInt("XPValueAttack");

	push	OFFSET $SG218031
	mov	ecx, edi
	mov	DWORD PTR [esi+384], eax
	call	ebp
	mov	DWORD PTR [esi+388], eax

; 209  : 	m_iXPValueDefense = kResults.GetInt("XPValueDefense");

	push	OFFSET $SG218032
	mov	ecx, edi
	call	ebp

; 210  : 	m_iConscriptionValue = kResults.GetInt("Conscription");

	push	OFFSET $SG218033
	mov	ecx, edi
	mov	DWORD PTR [esi+392], eax
	call	ebp

; 211  : 	m_iExtraMaintenanceCost = kResults.GetInt("ExtraMaintenanceCost");

	push	OFFSET $SG218034
	mov	ecx, edi
	mov	DWORD PTR [esi+404], eax
	call	ebp

; 212  : 	m_bNoMaintenance = kResults.GetBool("NoMaintenance");

	push	OFFSET $SG218035
	mov	ecx, edi
	mov	DWORD PTR [esi+408], eax
	call	ebx

; 213  : 	m_iUnhappiness = kResults.GetInt("Unhappiness");

	push	OFFSET $SG218036
	mov	ecx, edi
	mov	BYTE PTR [esi+412], al
	call	ebp

; 214  : 	m_iUnitFlagIconOffset = kResults.GetInt("UnitFlagIconOffset");

	push	OFFSET $SG218037
	mov	ecx, edi
	mov	DWORD PTR [esi+416], eax
	call	ebp

; 215  : 	m_iUnitPortraitOffset = kResults.GetInt("PortraitIndex");

	push	OFFSET $SG218038
	mov	ecx, edi
	mov	DWORD PTR [esi+560], eax
	call	ebp

; 216  : 	m_iLeaderExperience = kResults.GetInt("LeaderExperience");

	push	OFFSET $SG218039
	mov	ecx, edi
	mov	DWORD PTR [esi+564], eax
	call	ebp

; 217  : 	m_bFoodProduction = kResults.GetBool("Food");

	push	OFFSET $SG218040
	mov	ecx, edi
	mov	DWORD PTR [esi+492], eax
	call	ebx

; 218  : 	m_bNoBadGoodies = kResults.GetBool("NoBadGoodies");

	push	OFFSET $SG218041
	mov	ecx, edi
	mov	BYTE PTR [esi+496], al
	call	ebx

; 219  : 	m_bRivalTerritory = kResults.GetBool("RivalTerritory");

	push	OFFSET $SG218042
	mov	ecx, edi
	mov	BYTE PTR [esi+497], al
	call	ebx

; 220  : 	m_bMilitarySupport = kResults.GetBool("MilitarySupport");

	push	OFFSET $SG218043
	mov	ecx, edi
	mov	BYTE PTR [esi+498], al
	call	ebx

; 221  : 	m_bMilitaryProduction = kResults.GetBool("MilitaryProduction");

	push	OFFSET $SG218044
	mov	ecx, edi
	mov	BYTE PTR [esi+499], al
	call	ebx

; 222  : 	m_bPillage = kResults.GetBool("Pillage");

	push	OFFSET $SG218045
	mov	ecx, edi
	mov	BYTE PTR [esi+500], al
	call	ebx

; 223  : 	m_bFound = kResults.GetBool("Found");

	push	OFFSET $SG218046
	mov	ecx, edi
	mov	BYTE PTR [esi+501], al
	call	ebx

; 224  : 	m_bFoundAbroad = kResults.GetBool("FoundAbroad");

	push	OFFSET $SG218047
	mov	ecx, edi
	mov	BYTE PTR [esi+502], al
	call	ebx

; 225  : 	m_iCultureBombRadius = kResults.GetInt("CultureBombRadius");

	push	OFFSET $SG218048
	mov	ecx, edi
	mov	BYTE PTR [esi+503], al
	call	ebp

; 226  : 	m_iGoldenAgeTurns = kResults.GetInt("GoldenAgeTurns");

	push	OFFSET $SG218049
	mov	ecx, edi
	mov	DWORD PTR [esi+504], eax
	call	ebp

; 227  : 	m_iFreePolicies = kResults.GetInt("FreePolicies");

	push	OFFSET $SG218050
	mov	ecx, edi
	mov	DWORD PTR [esi+512], eax
	call	ebp

; 228  : 	m_iOneShotTourism = kResults.GetInt("OneShotTourism");

	push	OFFSET $SG218051
	mov	ecx, edi
	mov	DWORD PTR [esi+516], eax
	call	ebp

; 229  : 	m_iOneShotTourismPercentOthers = kResults.GetInt("OneShotTourismPercentOthers");

	push	OFFSET $SG218052
	mov	ecx, edi
	mov	DWORD PTR [esi+520], eax
	call	ebp

; 230  : 	m_bIgnoreBuildingDefense = kResults.GetBool("IgnoreBuildingDefense");

	push	OFFSET $SG218053
	mov	ecx, edi
	mov	DWORD PTR [esi+524], eax
	call	ebx

; 231  : 	m_bPrereqResources = kResults.GetBool("PrereqResources");

	push	OFFSET $SG218054
	mov	ecx, edi
	mov	BYTE PTR [esi+528], al
	call	ebx

; 232  : 	m_bMechanized = kResults.GetBool("Mechanized");

	push	OFFSET $SG218055
	mov	ecx, edi
	mov	BYTE PTR [esi+529], al
	call	ebx

; 233  : 	m_bSuicide = kResults.GetBool("Suicide");

	push	OFFSET $SG218056
	mov	ecx, edi
	mov	BYTE PTR [esi+530], al
	call	ebx

; 234  : 	m_bCaptureWhileEmbarked = kResults.GetBool("CaptureWhileEmbarked");

	push	OFFSET $SG218057
	mov	ecx, edi
	mov	BYTE PTR [esi+531], al
	call	ebx

; 235  : 	m_bRangeAttackOnlyInDomain = kResults.GetBool("RangeAttackOnlyInDomain");

	push	OFFSET $SG218058
	mov	ecx, edi
	mov	BYTE PTR [esi+532], al
	call	ebx

; 236  : 	m_bTrade = kResults.GetBool("Trade");

	push	OFFSET $SG218059
	mov	ecx, edi
	mov	BYTE PTR [esi+533], al
	call	ebx

; 237  : 	m_iNumExoticGoods = kResults.GetInt("NumExoticGoods");

	push	OFFSET $SG218060
	mov	ecx, edi
	mov	BYTE PTR [esi+548], al
	call	ebp

; 238  : 
; 239  : 	m_strUnitArtInfoTag = kResults.GetText("UnitArtInfo");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG218061
	mov	ecx, edi
	mov	DWORD PTR [esi+552], eax
	call	ebp
	lea	ecx, DWORD PTR [esi+568]
	test	eax, eax
	je	SHORT $LN26@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@CacheResul
$LN26@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@CacheResul:

; 240  : 	m_bUnitArtInfoCulturalVariation = kResults.GetBool("UnitArtInfoCulturalVariation");

	push	OFFSET $SG218062
	mov	ecx, edi
	call	ebx

; 241  : 	m_bUnitArtInfoEraVariation = kResults.GetBool("UnitArtInfoEraVariation");

	push	OFFSET $SG218063
	mov	ecx, edi
	mov	BYTE PTR [esi+596], al
	call	ebx

; 242  : 
; 243  : 	//References
; 244  : 	const char* szTextVal = NULL;
; 245  : 	szTextVal = kResults.GetText("Class");

	push	OFFSET $SG218065
	mov	ecx, edi
	mov	BYTE PTR [esi+597], al
	call	ebp

; 246  : 	m_iUnitClassType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 247  : 
; 248  : 	szTextVal = kResults.GetText("Special");

	push	OFFSET $SG218066
	mov	ecx, edi
	mov	DWORD PTR [esi+420], eax
	call	ebp

; 249  : 	m_iSpecialUnitType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 250  : 
; 251  : 	szTextVal = kResults.GetText("Capture");

	push	OFFSET $SG218067
	mov	ecx, edi
	mov	DWORD PTR [esi+424], eax
	call	ebp

; 252  : 	m_iUnitCaptureClassType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 253  : 
; 254  : 	szTextVal = kResults.GetText("CombatClass");

	push	OFFSET $SG218068
	mov	ecx, edi
	mov	DWORD PTR [esi+428], eax
	call	ebp

; 255  : 	m_iUnitCombatType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 256  : 
; 257  : 	szTextVal = kResults.GetText("Domain");

	push	OFFSET $SG218069
	mov	ecx, edi
	mov	DWORD PTR [esi+432], eax
	call	ebp

; 258  : 	m_iDomainType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 259  : 
; 260  : 	szTextVal = kResults.GetText("CivilianAttackPriority");

	push	OFFSET $SG218070
	mov	ecx, edi
	mov	DWORD PTR [esi+436], eax
	call	ebp

; 261  : 	m_iCivilianAttackPriority = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 262  : 
; 263  : 	szTextVal = kResults.GetText("DefaultUnitAI");

	push	OFFSET $SG218071
	mov	ecx, edi
	mov	DWORD PTR [esi+440], eax
	call	ebp

; 264  : 	m_iDefaultUnitAIType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 265  : 
; 266  : 	szTextVal = kResults.GetText("PillagePrereqTech");

	push	OFFSET $SG218072
	mov	ecx, edi
	mov	DWORD PTR [esi+444], eax
	call	ebp

; 267  : 	m_iPrereqPillageTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 268  : 	
; 269  : 	szTextVal = kResults.GetText("PrereqTech");

	push	OFFSET $SG218073
	mov	ecx, edi
	mov	DWORD PTR [esi+448], eax
	call	ebp

; 270  : 	m_iPrereqAndTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+452], eax

; 271  : 
; 272  : 	szTextVal = kResults.GetText("ObsoleteTech");

	push	OFFSET $SG218074
	mov	ecx, edi
	call	ebp

; 273  : 	m_iObsoleteTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 274  : 
; 275  : 	szTextVal = kResults.GetText("PolicyType");

	push	OFFSET $SG218075
	mov	ecx, edi
	mov	DWORD PTR [esi+456], eax
	call	ebp

; 276  : 	m_iPolicyType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 277  : 
; 278  : 	szTextVal = kResults.GetText("GoodyHutUpgradeUnitClass");

	push	OFFSET $SG218076
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebp

; 279  : 	m_iGoodyHutUpgradeUnitClass = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 280  : 
; 281  : 	szTextVal = kResults.GetText("SpecialCargo");

	push	OFFSET $SG218077
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebp

; 282  : 	m_iSpecialCargo = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 283  : 
; 284  : 	szTextVal = kResults.GetText("DomainCargo");

	push	OFFSET $SG218078
	mov	ecx, edi
	mov	DWORD PTR [esi+396], eax
	call	ebp

; 285  : 	m_iDomainCargo = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 286  : 
; 287  : 	szTextVal = kResults.GetText("ProjectPrereq");

	push	OFFSET $SG218079
	mov	ecx, edi
	mov	DWORD PTR [esi+400], eax
	call	ebp

; 288  : 	m_iProjectPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 289  : 
; 290  : 	szTextVal = kResults.GetText("SpaceshipProject");

	push	OFFSET $SG218080
	mov	ecx, edi
	mov	DWORD PTR [esi+536], eax
	call	ebp

; 291  : 	m_iSpaceshipProject = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 292  : 
; 293  : 	szTextVal = kResults.GetText("LeaderPromotion");

	push	OFFSET $SG218081
	mov	ecx, edi
	mov	DWORD PTR [esi+540], eax
	call	ebp

; 294  : 	m_iLeaderPromotion = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 295  : 
; 296  : 	//Arrays
; 297  : 	const char* szUnitType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+544], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 298  : 
; 299  : 	kUtility.SetFlavors(m_piFlavorValue, "Unit_Flavors", "UnitType", szUnitType);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	0
	mov	ebx, eax
	push	ebx
	push	OFFSET $SG218083
	push	OFFSET $SG218084
	lea	eax, DWORD PTR [esi+948]
	push	eax
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 300  : 
; 301  : 	kUtility.PopulateArrayByValue(m_piProductionTraits, "Traits", "Unit_ProductionTraits", "TraitType", "UnitType", szUnitType, "Trait");

	push	0
	push	0
	push	OFFSET $SG218085
	push	ebx
	push	OFFSET $SG218086
	push	OFFSET $SG218087
	push	OFFSET $SG218088
	push	OFFSET $SG218089
	lea	ecx, DWORD PTR [esi+944]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+132]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 302  : 
; 303  : 	kUtility.PopulateArrayByValue(m_piResourceQuantityRequirements, "Resources", "Unit_ResourceQuantityRequirements", "ResourceType", "UnitType", szUnitType, "Cost");

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	0
	push	0
	push	OFFSET $SG218090
	push	ebx
	push	OFFSET $SG218091
	push	OFFSET $SG218092
	push	OFFSET $SG218093
	push	OFFSET $SG218094
	lea	edx, DWORD PTR [esi+940]
	push	edx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 304  : 	kUtility.PopulateArrayByValue(m_piProductionModifierBuildings, "Buildings", "Unit_ProductionModifierBuildings", "BuildingType", "UnitType", szUnitType, "ProductionModifier");

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	0
	push	0
	push	OFFSET $SG218095
	push	ebx
	push	OFFSET $SG218096
	push	OFFSET $SG218097
	push	OFFSET $SG218098
	push	OFFSET $SG218099
	lea	eax, DWORD PTR [esi+956]
	push	eax
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 305  : 	kUtility.PopulateArrayByValue(m_piYieldFromKills, "Yields", "Unit_YieldFromKills", "YieldType", "UnitType", szUnitType, "Yield");

	push	0
	push	0
	push	OFFSET $SG218100
	push	ebx
	push	OFFSET $SG218101
	push	OFFSET $SG218102
	push	OFFSET $SG218103
	push	OFFSET $SG218104
	lea	ecx, DWORD PTR [esi+960]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+132]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 306  : 	kUtility.PopulateArrayByExistence(m_pbFreePromotions, "UnitPromotions", "Unit_FreePromotions", "PromotionType", "UnitType", szUnitType);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	ebx
	push	OFFSET $SG218105
	push	OFFSET $SG218106
	push	OFFSET $SG218107
	push	OFFSET $SG218108
	lea	edx, DWORD PTR [esi+992]
	push	edx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 307  : 
; 308  : 	kUtility.PopulateArrayByExistence(m_pbUpgradeUnitClass, "UnitClasses", "Unit_ClassUpgrades", "UnitClassType", "UnitType", szUnitType);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	ebx
	push	OFFSET $SG218109
	push	OFFSET $SG218110
	push	OFFSET $SG218111
	push	OFFSET $SG218112
	lea	eax, DWORD PTR [esi+964]
	push	eax
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 309  : 
; 310  : 	kUtility.PopulateArrayByExistence(m_pbUnitAIType, "UnitAIInfos", "Unit_AITypes", "UnitAIType", "UnitType", szUnitType);

	push	ebx
	push	OFFSET $SG218113
	push	OFFSET $SG218114
	push	OFFSET $SG218115
	push	OFFSET $SG218116
	lea	ecx, DWORD PTR [esi+968]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+120]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 311  : 	kUtility.PopulateArrayByExistence(m_pbNotUnitAIType, "UnitAIInfos", "Unit_NotAITypes", "UnitAIType", "UnitType", szUnitType);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	ebx
	push	OFFSET $SG218117
	push	OFFSET $SG218118
	push	OFFSET $SG218119
	push	OFFSET $SG218120
	lea	edx, DWORD PTR [esi+972]
	push	edx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 312  : 
; 313  : 	kUtility.PopulateArrayByExistence(m_pbBuilds, "Builds", "Unit_Builds", "BuildType", "UnitType", szUnitType);

	push	ebx
	push	OFFSET $SG218121
	push	OFFSET $SG218122
	push	OFFSET $SG218123
	mov	ecx, DWORD PTR _kUtility$[esp+112]
	push	OFFSET $SG218124
	lea	eax, DWORD PTR [esi+976]
	push	eax
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 314  : 	kUtility.PopulateArrayByExistence(m_pbGreatPeoples, "Specialists", "Unit_GreatPersons", "GreatPersonType", "UnitType", szUnitType);

	push	ebx
	push	OFFSET $SG218125
	push	OFFSET $SG218126
	push	OFFSET $SG218127
	push	OFFSET $SG218128
	lea	ecx, DWORD PTR [esi+980]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+120]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 315  : 	kUtility.PopulateArrayByExistence(m_pbBuildings, "Buildings", "Unit_Buildings", "BuildingType", "UnitType", szUnitType);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	ebx
	push	OFFSET $SG218129
	push	OFFSET $SG218130
	push	OFFSET $SG218131
	push	OFFSET $SG218132
	lea	edx, DWORD PTR [esi+984]
	push	edx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 316  : 	kUtility.PopulateArrayByExistence(m_pbBuildingClassRequireds, "BuildingClasses", "Unit_BuildingClassRequireds", "BuildingClassType", "UnitType", szUnitType);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	ebx
	push	OFFSET $SG218133
	push	OFFSET $SG218134
	push	OFFSET $SG218135
	push	OFFSET $SG218136
	lea	eax, DWORD PTR [esi+988]
	push	eax
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 317  : 
; 318  : 	//TechTypes
; 319  : 	{
; 320  : 		//Initialize array to NO_TECH
; 321  : 		kUtility.InitializeArray(m_piPrereqAndTechs, "Technologies", (int)NO_TECH);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	push	OFFSET $SG218143
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _count$220830[esp+96], eax
	test	eax, eax
	jne	SHORT $LN31@CacheResul
	mov	DWORD PTR _count$220830[esp+96], 1
	mov	eax, DWORD PTR _count$220830[esp+96]
$LN31@CacheResul:
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _count$220830[esp+100]
	mov	DWORD PTR [esi+936], eax
	add	esp, 4
	xor	eax, eax
	test	ecx, ecx
	jbe	SHORT $LN34@CacheResul
	npad	5
$LL36@CacheResul:
	mov	edx, DWORD PTR [esi+936]
	mov	DWORD PTR [edx+eax*4], -1
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL36@CacheResul
$LN34@CacheResul:

; 322  : 
; 323  : 		std::string strKey = "Units - TechTypes";

	push	OFFSET $SG218145
	lea	ecx, DWORD PTR _strKey$218144[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 324  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	lea	eax, DWORD PTR _strKey$218144[esp+100]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+112], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218146[esp+96], eax

; 325  : 		if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN14@CacheResul

; 326  : 		{
; 327  : 			pResults = kUtility.PrepareResults(strKey, "select Technologies.ID from Unit_TechTypes inner join Technologies on TechType = Technologies.Type where UnitType = ?");

	push	OFFSET $SG218148
	lea	ecx, DWORD PTR _strKey$218144[esp+104]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+104]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218146[esp+96], eax
$LN14@CacheResul:

; 328  : 		}
; 329  : 
; 330  : 		pResults->Bind(1, szUnitType, -1, false);

	push	0
	push	-1
	push	ebx
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 331  : 
; 332  : 		int i = 0;
; 333  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218146[esp+96]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN12@CacheResul

; 328  : 		}
; 329  : 
; 330  : 		pResults->Bind(1, szUnitType, -1, false);

	mov	DWORD PTR tv1606[esp+100], 0
	npad	5
$LL13@CacheResul:

; 334  : 		{
; 335  : 			m_piPrereqAndTechs[i++] = pResults->GetInt(0);

	mov	ecx, DWORD PTR _pResults$218146[esp+96]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR tv1606[esp+100]
	mov	edx, DWORD PTR [esi+936]
	mov	DWORD PTR [ecx+edx], eax
	add	ecx, 4
	mov	DWORD PTR tv1606[esp+100], ecx
	mov	ecx, DWORD PTR _pResults$218146[esp+96]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL13@CacheResul
$LN12@CacheResul:

; 336  : 		}
; 337  : 
; 338  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$218146[esp+96]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 339  : 	}

	lea	ecx, DWORD PTR _strKey$218144[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 340  : 
; 341  : 	//Unit Unique Names Count
; 342  : 	{
; 343  : 		std::string strKey = "Units - UniqueNameCount";

	push	OFFSET $SG218154
	lea	ecx, DWORD PTR _strKey$218153[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 344  : 		Database::Results* pUnitNameCount = kUtility.GetResults(strKey);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	lea	eax, DWORD PTR _strKey$218153[esp+100]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pUnitNameCount$218155[esp+96], eax

; 345  : 		if(pUnitNameCount == NULL)

	test	eax, eax
	jne	SHORT $LN11@CacheResul

; 346  : 		{
; 347  : 			pUnitNameCount = kUtility.PrepareResults(strKey, "select count(*) from Unit_UniqueNames where UnitType = ?");

	push	OFFSET $SG218157
	lea	ecx, DWORD PTR _strKey$218153[esp+104]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+104]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pUnitNameCount$218155[esp+96], eax
$LN11@CacheResul:

; 348  : 		}
; 349  : 
; 350  : 		pUnitNameCount->Bind(1, szUnitType, -1, false);

	push	0
	push	-1
	push	ebx
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 351  : 
; 352  : 		pUnitNameCount->Step();

	mov	ecx, DWORD PTR _pUnitNameCount$218155[esp+96]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ

; 353  : 		m_iNumUnitNames = pUnitNameCount->GetInt(0);

	mov	ecx, DWORD PTR _pUnitNameCount$218155[esp+96]
	push	0
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 354  : 
; 355  : 		pUnitNameCount->Reset();

	mov	ecx, DWORD PTR _pUnitNameCount$218155[esp+96]
	mov	DWORD PTR [esi+484], eax
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 356  : 	}

	lea	ecx, DWORD PTR _strKey$218153[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 357  : 
; 358  : 	//Unit Unique Names
; 359  : 	{
; 360  : 		if(m_iNumUnitNames > 0)

	mov	eax, DWORD PTR [esi+484]
	mov	DWORD PTR tv1365[esp+96], eax
	test	eax, eax
	jle	$LN53@CacheResul

; 361  : 		{
; 362  : #ifdef AUI_WARNING_FIXES
; 363  : 			SAFE_DELETE_ARRAY(m_paszUnitNames);
; 364  : 			SAFE_DELETE_ARRAY(m_paeGreatWorks);
; 365  : #endif
; 366  : 			m_paszUnitNames = FNEW(CvString[m_iNumUnitNames], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	edx, 28					; 0000001cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220788[esp+100], eax
	mov	DWORD PTR __$EHRec$[esp+108], 2
	test	eax, eax
	je	SHORT $LN18@CacheResul
	mov	ecx, DWORD PTR tv1365[esp+96]
	push	OFFSET ??1CvString@@QAE@XZ		; CvString::~CvString
	push	OFFSET ??0CvString@@QAE@XZ		; CvString::CvString
	push	ecx
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	push	28					; 0000001cH
	push	eax
	mov	DWORD PTR tv1369[esp+116], eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, DWORD PTR tv1369[esp+96]
	jmp	SHORT $LN19@CacheResul
$LN18@CacheResul:
	xor	eax, eax
$LN19@CacheResul:
	mov	DWORD PTR [esi+1008], eax

; 367  : 			m_paeGreatWorks = FNEW(GreatWorkType[m_iNumUnitNames], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [esi+484]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	mov	DWORD PTR __$EHRec$[esp+108], -1
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 368  : 
; 369  : 			std::string strKey = "Units - UniqueNames";

	push	OFFSET $SG218169
	lea	ecx, DWORD PTR _strKey$218168[esp+104]
	mov	DWORD PTR [esi+1012], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 370  : 			Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	lea	eax, DWORD PTR _strKey$218168[esp+100]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+112], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218170[esp+96], eax

; 371  : 			if(pResults == NULL)

	test	eax, eax
	jne	SHORT $LN9@CacheResul

; 372  : 			{
; 373  : 				pResults = kUtility.PrepareResults(strKey, "select UniqueName, GreatWorkType from Unit_UniqueNames where UnitType = ? ORDER BY rowid");

	push	OFFSET $SG218172
	lea	ecx, DWORD PTR _strKey$218168[esp+104]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+104]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218170[esp+96], eax
$LN9@CacheResul:

; 374  : 			}
; 375  : 
; 376  : 			pResults->Bind(1, szUnitType, -1, false);

	push	0
	push	-1
	push	ebx
	push	1
	mov	ecx, eax
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 377  : 
; 378  : 			int i = 0;
; 379  : 			while(pResults->Step())

	mov	ebx, DWORD PTR _pResults$218170[esp+96]
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN7@CacheResul
	xor	eax, eax
	mov	DWORD PTR tv1617[esp+96], eax
	mov	DWORD PTR tv1619[esp+100], eax
	npad	8
$LL8@CacheResul:

; 380  : 			{
; 381  : 				m_paszUnitNames[i] = pResults->GetText(0);

	push	0
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	mov	ecx, DWORD PTR [esi+1008]
	add	ecx, DWORD PTR tv1619[esp+100]
	test	eax, eax
	je	SHORT $LN42@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN41@CacheResul
$LN42@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN41@CacheResul:

; 382  : 			
; 383  : 				const char* szGreatWorkType = pResults->GetText(1);

	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z

; 384  : 				if(szGreatWorkType == NULL)

	test	eax, eax
	jne	SHORT $LN6@CacheResul

; 385  : 				{
; 386  : 					m_paeGreatWorks[i] = NO_GREAT_WORK;

	mov	edx, DWORD PTR [esi+1012]
	mov	eax, DWORD PTR tv1617[esp+96]
	mov	DWORD PTR [eax+edx], -1

; 387  : 				}
; 388  : 				else

	jmp	SHORT $LN5@CacheResul
$LN6@CacheResul:

; 389  : 				{
; 390  : 					m_paeGreatWorks[i] = static_cast<GreatWorkType>(GC.getInfoTypeForString(szGreatWorkType, true));

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [esi+1012]
	mov	edx, DWORD PTR tv1617[esp+96]
	mov	DWORD PTR [edx+ecx], eax
$LN5@CacheResul:

; 391  : 				}
; 392  : 
; 393  : 				i++;

	add	DWORD PTR tv1619[esp+100], 28		; 0000001cH
	add	DWORD PTR tv1617[esp+96], 4
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL8@CacheResul
$LN7@CacheResul:

; 394  : 			}
; 395  : 
; 396  : 			pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 397  : 		}

	lea	ecx, DWORD PTR _strKey$218168[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN53@CacheResul:

; 398  : 	}
; 399  : 
; 400  : 	//MovementRates
; 401  : 	{
; 402  : 		std::string strKey = "Units - MovementRates";

	push	OFFSET $SG218182
	lea	ecx, DWORD PTR _strKey$218181[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 403  : 		Database::Results* pMovementRates = kUtility.GetResults(strKey);

	mov	ecx, DWORD PTR _kUtility$[esp+96]
	lea	eax, DWORD PTR _strKey$218181[esp+100]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+112], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 404  : 		if(pMovementRates == NULL)

	test	ebx, ebx
	jne	SHORT $LN4@CacheResul

; 405  : 		{
; 406  : 			pMovementRates = kUtility.PrepareResults(strKey, "SELECT * FROM MovementRates where Type = ? ORDER BY NumHexes");

	push	OFFSET $SG218185
	lea	ecx, DWORD PTR _strKey$218181[esp+104]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+104]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN4@CacheResul:

; 407  : 		}
; 408  : 
; 409  : 		const char* szMovementRate = kResults.GetText("MoveRate");

	push	OFFSET $SG218187
	mov	ecx, edi
	call	ebp

; 410  : 		pMovementRates->Bind(1, szMovementRate, -1, false);

	push	0
	push	-1
	push	eax
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 411  : 		while(pMovementRates->Step())

	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN2@CacheResul
	npad	6
$LL3@CacheResul:

; 412  : 		{
; 413  : 			int f0 = pMovementRates->GetInt("NumHexes") - 1;

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG218192
	mov	ecx, ebx
	call	ebp
	mov	edi, eax

; 414  : 			float f1 = pMovementRates->GetFloat("TotalTime");

	push	OFFSET $SG218194
	mov	ecx, ebx
	dec	edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR _f1$218193[esp+96]

; 415  : 			float f2 = pMovementRates->GetFloat("EaseIn");

	push	OFFSET $SG218196
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR _f2$218195[esp+96]

; 416  : 			float f3 = pMovementRates->GetFloat("EaseOut");

	push	OFFSET $SG218198
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR _f3$218197[esp+100]

; 417  : 			float f4 = pMovementRates->GetFloat("IndividualOffset");

	push	OFFSET $SG218200
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR _f4$218199[esp+100]

; 418  : 			float f5 = pMovementRates->GetFloat("RowOffset");

	push	OFFSET $SG218202
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR _f5$218201[esp+100]

; 419  : 			float f6 = pMovementRates->GetFloat("CurveRoll");

	push	OFFSET $SG218204
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR _f6$218203[esp+100]

; 420  : 			int   iPathSubdivision = pMovementRates->GetInt("PathSubdivision");

	push	OFFSET $SG218206
	mov	ecx, ebx
	call	ebp

; 421  : 			if(f0 >= 0 && f0 <= 11)

	cmp	edi, 11					; 0000000bH
	ja	SHORT $LN1@CacheResul

; 422  : 			{
; 423  : 				m_unitMoveRate[f0].m_fTotalMoveRate    = f1;

	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	lea	ecx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _f1$218193[esp+96]
	mov	DWORD PTR [ecx+600], edx

; 424  : 				m_unitMoveRate[f0].m_fEaseIn           = f2;

	mov	edx, DWORD PTR _f2$218195[esp+96]
	mov	DWORD PTR [ecx+604], edx

; 425  : 				m_unitMoveRate[f0].m_fEaseOut          = f3;

	mov	edx, DWORD PTR _f3$218197[esp+100]
	mov	DWORD PTR [ecx+608], edx

; 426  : 				m_unitMoveRate[f0].m_fIndividualOffset = f4;

	mov	edx, DWORD PTR _f4$218199[esp+100]
	mov	DWORD PTR [ecx+612], edx

; 427  : 				m_unitMoveRate[f0].m_fRowOffset        = f5;

	lea	edx, DWORD PTR [edi+22]
	lea	edi, DWORD PTR [edx*8]
	sub	edi, edx
	mov	edx, DWORD PTR _f5$218201[esp+100]
	mov	DWORD PTR [esi+edi*4], edx

; 428  : 				m_unitMoveRate[f0].m_fCurveRoll        = f6;

	mov	edx, DWORD PTR _f6$218203[esp+100]
	mov	DWORD PTR [ecx+620], edx

; 429  : 				m_unitMoveRate[f0].m_iPathSubdivision  = iPathSubdivision;

	mov	DWORD PTR [ecx+624], eax
$LN1@CacheResul:
	mov	ecx, ebx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	$LL3@CacheResul
$LN2@CacheResul:

; 430  : 			}
; 431  : 		}
; 432  : 		pMovementRates->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 433  : 
; 434  : 	}

	lea	ecx, DWORD PTR _strKey$218181[esp+100]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 435  : 
; 436  : 	// Calculate military Power and cache it
; 437  : 	DoUpdatePower();

	mov	ecx, esi
	call	?DoUpdatePower@CvUnitEntry@@QAEXXZ	; CvUnitEntry::DoUpdatePower

; 438  : 
; 439  : 	return true;
; 440  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$218144[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$218153[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	mov	eax, DWORD PTR $T220788[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$218168[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _strKey$218181[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvUnitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvUnitEntry::CacheResults
PUBLIC	?Read@UnitArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; UnitArrayHelpers::Read
EXTRN	?getNumUnitInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumUnitInfos
; Function compile flags: /Ogtpy
;	COMDAT ?Read@UnitArrayHelpers@@YAXAAVFDataStream@@PAH@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paiUnitArray$ = 12					; size = 4
?Read@UnitArrayHelpers@@YAXAAVFDataStream@@PAH@Z PROC	; UnitArrayHelpers::Read, COMDAT

; 1485 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, paiUnitArray, GC.getNumUnitInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	mov	ecx, DWORD PTR _kStream$[esp-4]
	push	eax
	mov	eax, DWORD PTR _paiUnitArray$[esp]
	push	eax
	push	ecx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 1486 : }

	ret	0
?Read@UnitArrayHelpers@@YAXAAVFDataStream@@PAH@Z ENDP	; UnitArrayHelpers::Read
_TEXT	ENDS
PUBLIC	?Write@UnitArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; UnitArrayHelpers::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@UnitArrayHelpers@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paiUnitArray$ = 12					; size = 4
_iArraySize$ = 16					; size = 4
?Write@UnitArrayHelpers@@YAXAAVFDataStream@@PAHH@Z PROC	; UnitArrayHelpers::Write, COMDAT

; 1491 : 	CvInfosSerializationHelper::WriteHashedDataArray<UnitTypes, int>(kStream, paiUnitArray, iArraySize);

	jmp	??$WriteHashedDataArray@W4UnitTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum UnitTypes,int>
?Write@UnitArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ENDP	; UnitArrayHelpers::Write
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@XZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@KAXXZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvUnitEntry@@@std@@YAPAPAVCvUnitEntry@@IPAPAV1@@Z ; std::_Allocate<CvUnitEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXPAPAVCvUnitEntry@@0@Z ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXPAPAVCvUnitEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXPAPAVCvUnitEntry@@0@Z PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXPAPAVCvUnitEntry@@0@Z ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??_GCvUnitEntry@@QAEPAXI@Z			; CvUnitEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvUnitEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvUnitEntry@@QAEPAXI@Z PROC				; CvUnitEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvUnitEntry@@QAE@XZ			; CvUnitEntry::~CvUnitEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvUnitEntry@@QAEPAXI@Z ENDP				; CvUnitEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@0@Z ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@0@Z PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@2@0@Z ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXXZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvUnitEntry@@@@YAXAAPAVCvUnitEntry@@@Z ; SAFE_DELETE<CvUnitEntry>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvUnitEntry@@@@YAXAAPAVCvUnitEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvUnitEntry@@@@YAXAAPAVCvUnitEntry@@@Z PROC ; SAFE_DELETE<CvUnitEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@2
	mov	ecx, esi
	call	??1CvUnitEntry@@QAE@XZ			; CvUnitEntry::~CvUnitEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@2:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvUnitEntry@@@@YAXAAPAVCvUnitEntry@@@Z ENDP ; SAFE_DELETE<CvUnitEntry>
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::~vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::~vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::~vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEXXZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::clear
_TEXT	ENDS
PUBLIC	??0CvUnitXMLEntries@@QAE@XZ			; CvUnitXMLEntries::CvUnitXMLEntries
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
;	COMDAT ??0CvUnitXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvUnitXMLEntries@@QAE@XZ PROC			; CvUnitXMLEntries::CvUnitXMLEntries, COMDAT
; _this$ = ecx

; 1434 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 1435 : 
; 1436 : }

	ret	0
??0CvUnitXMLEntries@@QAE@XZ ENDP			; CvUnitXMLEntries::CvUnitXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvUnitXMLEntries@@QAEXXZ		; CvUnitXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvUnitXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvUnitXMLEntries@@QAEXXZ PROC		; CvUnitXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 1463 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 1464 : 	for(std::vector<CvUnitEntry*>::iterator it = m_paUnitEntries.begin(); it != m_paUnitEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 1465 : 	{
; 1466 : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvUnitEntry@@QAE@XZ			; CvUnitEntry::~CvUnitEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 1467 : 	}
; 1468 : 
; 1469 : 	m_paUnitEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 1470 : }

	ret	0
?DeleteArray@CvUnitXMLEntries@@QAEXXZ ENDP		; CvUnitXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??1CvUnitXMLEntries@@QAE@XZ			; CvUnitXMLEntries::~CvUnitXMLEntries
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvUnitXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvUnitXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvUnitXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvUnitXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvUnitXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvUnitXMLEntries@@QAE@XZ PROC			; CvUnitXMLEntries::~CvUnitXMLEntries, COMDAT
; _this$ = ecx

; 1440 : {

	push	-1
	push	__ehhandler$??1CvUnitXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 1441 : 	DeleteArray();

	call	?DeleteArray@CvUnitXMLEntries@@QAEXXZ	; CvUnitXMLEntries::DeleteArray

; 1442 : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvUnitXMLE
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvUnitXMLE:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvUnitXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvUnitEntry@@V?$allocator@PAVCvUnitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >::~vector<CvUnitEntry *,std::allocator<CvUnitEntry *> >
__ehhandler$??1CvUnitXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvUnitXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvUnitXMLEntries@@QAE@XZ ENDP			; CvUnitXMLEntries::~CvUnitXMLEntries
END
