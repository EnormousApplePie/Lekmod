; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Cleanup (v1)\Lekmod Files\Lekmod DLL versions\v30\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTechAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218248 DB	'Choosing tech from Top Choices', 00H
	ORG $+1
$SG218829 DB	'%03d, ', 00H
	ORG $+1
$SG218831 DB	', ', 00H
	ORG $+1
$SG218841 DB	'Unknown Tech', 00H
	ORG $+3
$SG218842 DB	'%s, %d', 00H
	ORG $+1
$SG218856 DB	'%03d, ', 00H
	ORG $+1
$SG218858 DB	', ', 00H
	ORG $+1
$SG218861 DB	'Unknown Tech', 00H
	ORG $+3
$SG218862 DB	'CHOSEN, %s', 00H
	ORG $+1
$SG218873 DB	'.csv', 00H
	ORG $+3
$SG218874 DB	'TechAILog_', 00H
	ORG $+1
$SG218876 DB	'TechAILog.csv', 00H
CONST	ENDS
PUBLIC	??RLeaderWithNumTechsEval@@QBE_NABULeaderWithNumTechs@@0@Z ; LeaderWithNumTechsEval::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
;	COMDAT ??RLeaderWithNumTechsEval@@QBE_NABULeaderWithNumTechs@@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??RLeaderWithNumTechsEval@@QBE_NABULeaderWithNumTechs@@0@Z PROC ; LeaderWithNumTechsEval::operator(), COMDAT
; _this$ = ecx

; 289  : 		return a.m_iNumTechs > b.m_iNumTechs;

	mov	eax, DWORD PTR _a$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _b$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx+4]
	setg	al

; 290  : 	}

	ret	8
??RLeaderWithNumTechsEval@@QBE_NABULeaderWithNumTechs@@0@Z ENDP ; LeaderWithNumTechsEval::operator()
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAULeaderWithNumTechs@@I@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAULeaderWithNumTechs@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAULeaderWithNumTechs@@I@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 786  : 		}

	ret	4
??A?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAULeaderWithNumTechs@@I@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator[]
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@XZ ; CvWeightedVector<int,80,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@XZ PROC ; CvWeightedVector<int,80,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@XZ ENDP ; CvWeightedVector<int,80,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@ABU01@@Z ; CvWeightedVector<int,80,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
;	COMDAT ??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<int,80,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@H$0FA@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<int,80,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?capacity@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::capacity
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >::~_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >::~_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >::~_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::allocator<LeaderWithNumTechs>::allocator<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@XZ PROC	; std::allocator<LeaderWithNumTechs>::allocator<LeaderWithNumTechs>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@XZ ENDP	; std::allocator<LeaderWithNumTechs>::allocator<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??_C@_0IJ@DONJGAGH@c?3?2users?2enormousapplepie?2deskto@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0IJ@DONJGAGH@c?3?2users?2enormousapplepie?2deskto@
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0IJ@DONJGAGH@c?3?2users?2enormousapplepie?2deskto@ DB 'c:\users\eno'
	DB	'rmousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll ve'
	DB	'rsions\v30\lekmod_dll\fireplace\include\fireworks\FFastVector'
	DB	'.h', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 80					; 00000050H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0IJ@DONJGAGH@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 80			; 00000050H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ
_TEXT	SEGMENT
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis, COMDAT
; _this$ = ecx

; 701  : 	inline GenericClass *GetClosureThis() const { return m_pthis; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetClosureThis@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEPAVGenericClass@23@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureThis
_TEXT	ENDS
PUBLIC	?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ
_TEXT	SEGMENT
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr, COMDAT
; _this$ = ecx

; 702  : 	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetClosureMemPtr@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QBEP8GenericClass@23@AEHHPBD@ZXZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::GetClosureMemPtr
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221979 = -80						; size = 28
$T221978 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221979[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T221978[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T221979[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T221978[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T221978[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221978[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T221978[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221979[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221978[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >::_Container_base_aux_alloc_empty<std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z ; std::allocator<LeaderWithNumTechs>::allocator<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z PROC ; std::allocator<LeaderWithNumTechs>::allocator<LeaderWithNumTechs>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<LeaderWithNumTechs>::allocator<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@I@Z ; std::allocator<LeaderWithNumTechs>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@I@Z PROC ; std::allocator<LeaderWithNumTechs>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@I@Z ENDP ; std::allocator<LeaderWithNumTechs>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@ULeaderWithNumTechs@@@std@@QBEIXZ ; std::allocator<LeaderWithNumTechs>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@ULeaderWithNumTechs@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@ULeaderWithNumTechs@@@std@@QBEIXZ PROC ; std::allocator<LeaderWithNumTechs>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@ULeaderWithNumTechs@@@std@@QBEIXZ ENDP ; std::allocator<LeaderWithNumTechs>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+=
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ; std::_Allocate<LeaderWithNumTechs>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z
_TEXT	SEGMENT
$T222027 = -12						; size = 12
$T222031 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z PROC ; std::_Allocate<LeaderWithNumTechs>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T222031[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T222027[esp+16]
	mov	DWORD PTR $T222031[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T222027[esp+16]
	push	ecx
	mov	DWORD PTR $T222027[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ENDP ; std::_Allocate<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator==
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAPAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAULeaderWithNumTechs@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@0@Z ; std::_Ptr_cat<LeaderWithNumTechs *,LeaderWithNumTechs *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAULeaderWithNumTechs@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAULeaderWithNumTechs@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@0@Z PROC ; std::_Ptr_cat<LeaderWithNumTechs *,LeaderWithNumTechs *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAULeaderWithNumTechs@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@0@Z ENDP ; std::_Ptr_cat<LeaderWithNumTechs *,LeaderWithNumTechs *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z ; std::_Fill<LeaderWithNumTechs *,LeaderWithNumTechs>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z PROC ; std::_Fill<LeaderWithNumTechs *,LeaderWithNumTechs>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z ENDP ; std::_Fill<LeaderWithNumTechs *,LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAULeaderWithNumTechs@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0@Z ; std::_Iter_random<LeaderWithNumTechs *,LeaderWithNumTechs *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAULeaderWithNumTechs@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAULeaderWithNumTechs@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0@Z PROC ; std::_Iter_random<LeaderWithNumTechs *,LeaderWithNumTechs *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAULeaderWithNumTechs@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0@Z ENDP ; std::_Iter_random<LeaderWithNumTechs *,LeaderWithNumTechs *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAULeaderWithNumTechs@@@std@@YA?AU_Undefined_move_tag@0@ABQAULeaderWithNumTechs@@@Z ; std::_Move_cat<LeaderWithNumTechs *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAULeaderWithNumTechs@@@std@@YA?AU_Undefined_move_tag@0@ABQAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAULeaderWithNumTechs@@@std@@YA?AU_Undefined_move_tag@0@ABQAULeaderWithNumTechs@@@Z PROC ; std::_Move_cat<LeaderWithNumTechs *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAULeaderWithNumTechs@@@std@@YA?AU_Undefined_move_tag@0@ABQAULeaderWithNumTechs@@@Z ENDP ; std::_Move_cat<LeaderWithNumTechs *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@H@Z ; std::_Temp_iterator<LeaderWithNumTechs>::_Temp_iterator<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<LeaderWithNumTechs>::_Temp_iterator<LeaderWithNumTechs>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::_Temp_iterator<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z PROC ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>, COMDAT

; 153  : 	return input;

	mov	eax, DWORD PTR _input$[esp-4]

; 154  : }

	ret	0
??$implicit_cast@PAVCvGame@@PAV1@@detail@fastdelegate@@YAPAVCvGame@@PAV2@@Z ENDP ; fastdelegate::detail::implicit_cast<CvGame *,CvGame *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<LeaderWithNumTechs *,LeaderWithNumTechs *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<LeaderWithNumTechs *,LeaderWithNumTechs *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<LeaderWithNumTechs *,LeaderWithNumTechs *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@ULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@ABU1@@Z ; std::_Construct<LeaderWithNumTechs,LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@ULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@ULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@ABU1@@Z PROC ; std::_Construct<LeaderWithNumTechs,LeaderWithNumTechs>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@ULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@ABU1@@Z ENDP ; std::_Construct<LeaderWithNumTechs,LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$_Destroy@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z ; std::_Destroy<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z PROC ; std::_Destroy<LeaderWithNumTechs>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z ENDP ; std::_Destroy<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z ; std::return_temporary_buffer<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z PROC ; std::return_temporary_buffer<LeaderWithNumTechs>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@ULeaderWithNumTechs@@@std@@YAXPAULeaderWithNumTechs@@@Z ENDP ; std::return_temporary_buffer<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@H$0FA@$00@@QBE_NABU01@@Z ; CvWeightedVector<int,80,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@H$0FA@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@H$0FA@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<int,80,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@H$0FA@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<int,80,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::pair<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>::pair<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::pair<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>::pair<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::pair<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>::pair<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
_bound_func$ = 16					; size = 4
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z PROC ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>, COMDAT

; 306  : 			GenericMemFuncType &bound_func) {
; 307  : #if defined __DMC__  
; 308  : 		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
; 309  : 		// even though the standard says you can. The 32-bit compiler lets you
; 310  : 		// static_cast through an int, but the DOS compiler doesn't.
; 311  : 		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
; 312  : #else 
; 313  :         bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);

	mov	eax, DWORD PTR _bound_func$[esp-4]
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax], ecx

; 314  : #endif
; 315  :         return reinterpret_cast<GenericClass *>(pthis);

	mov	eax, DWORD PTR _pthis$[esp-4]

; 316  : 	}

	ret	0
??$Convert@VCvGame@@P81@AEHHPBD@ZP8GenericClass@detail@fastdelegate@@AEXXZ@?$SimplifyMemFunc@$03@detail@fastdelegate@@SAPAVGenericClass@12@PAVCvGame@@P84@AEHHPBD@ZAAP8312@AEXXZ@Z ENDP ; fastdelegate::detail::SimplifyMemFunc<4>::Convert<CvGame,int (__thiscall CvGame::*)(int,char const *),void (__thiscall fastdelegate::detail::GenericClass::*)(void)>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ; std::_Dist_type<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@1@@Z ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@1@@Z PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 399  : 		}

	ret	4
??G?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEHABV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@1@@Z ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator-
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QBEPAULeaderWithNumTechs@@XZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAULeaderWithNumTechs@@H@std@@QAE@ABQAULeaderWithNumTechs@@ABH@Z ; std::pair<LeaderWithNumTechs *,int>::pair<LeaderWithNumTechs *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAULeaderWithNumTechs@@H@std@@QAE@ABQAULeaderWithNumTechs@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAULeaderWithNumTechs@@H@std@@QAE@ABQAULeaderWithNumTechs@@ABH@Z PROC ; std::pair<LeaderWithNumTechs *,int>::pair<LeaderWithNumTechs *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAULeaderWithNumTechs@@H@std@@QAE@ABQAULeaderWithNumTechs@@ABH@Z ENDP ; std::pair<LeaderWithNumTechs *,int>::pair<LeaderWithNumTechs *,int>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEABULeaderWithNumTechs@@XZ ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEABULeaderWithNumTechs@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEABULeaderWithNumTechs@@XZ PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEABULeaderWithNumTechs@@XZ ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<LeaderWithNumTechs>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::swap<CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::swap<CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::swap<CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 8

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -8			; fffffff8H

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator--
_TEXT	ENDS
PUBLIC	??$swap@ULeaderWithNumTechs@@@std@@YAXAAULeaderWithNumTechs@@0@Z ; std::swap<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@ULeaderWithNumTechs@@@std@@YAXAAULeaderWithNumTechs@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@ULeaderWithNumTechs@@@std@@YAXAAULeaderWithNumTechs@@0@Z PROC ; std::swap<LeaderWithNumTechs>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@ULeaderWithNumTechs@@@std@@YAXAAULeaderWithNumTechs@@0@Z ENDP ; std::swap<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@AAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ; std::_Ptr_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@AAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@AAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@AAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@1@Z ; std::_Iter_random<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@1@Z PROC ; std::_Iter_random<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@1@Z ENDP ; std::_Iter_random<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Iter_random<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z PROC ; std::_Temp_iterator<LeaderWithNumTechs>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
$LN7@operator:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ; std::_Iter_random<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z PROC ; std::_Iter_random<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ENDP ; std::_Iter_random<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ; std::_Ptr_cat<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z PROC ; std::_Ptr_cat<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAULeaderWithNumTechs@@AAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ENDP ; std::_Ptr_cat<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ABV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAULeaderWithNumTechs@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@@Z ; std::_Iter_cat<LeaderWithNumTechs *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAULeaderWithNumTechs@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAULeaderWithNumTechs@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@@Z PROC ; std::_Iter_cat<LeaderWithNumTechs *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAULeaderWithNumTechs@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@@Z ENDP ; std::_Iter_cat<LeaderWithNumTechs *>
_TEXT	ENDS
PUBLIC	??$_Advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<LeaderWithNumTechs *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<LeaderWithNumTechs *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<LeaderWithNumTechs *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ; std::_Iter_random<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z PROC ; std::_Iter_random<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAULeaderWithNumTechs@@0ABV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@@Z ENDP ; std::_Iter_random<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getTECH_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ ; CvGlobals::getTECH_WEIGHT_PROPAGATION_LEVELS
; Function compile flags: /Ogtpy
;	COMDAT ?getTECH_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTECH_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTECH_WEIGHT_PROPAGATION_LEVELS, COMDAT
; _this$ = ecx

; 905  : 		return m_iTECH_WEIGHT_PROPAGATION_LEVELS;

	mov	eax, DWORD PTR [ecx+1840]

; 906  : 	}

	ret	0
?getTECH_WEIGHT_PROPAGATION_LEVELS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTECH_WEIGHT_PROPAGATION_LEVELS
_TEXT	ENDS
PUBLIC	?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_OR_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUM_OR_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5344 : 		return m_iNUM_OR_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6268]

; 5345 : 	}

	ret	0
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUM_OR_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ ; CvGlobals::getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT, COMDAT
; _this$ = ecx

; 7020 : 		return m_fAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT;

	fld	DWORD PTR [ecx+8008]

; 7021 : 	}

	ret	0
?getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT
_TEXT	ENDS
PUBLIC	?getAI_RESEARCH_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ ; CvGlobals::getAI_RESEARCH_WEIGHT_BASE_MOD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_RESEARCH_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_RESEARCH_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ PROC	; CvGlobals::getAI_RESEARCH_WEIGHT_BASE_MOD, COMDAT
; _this$ = ecx

; 7024 : 		return m_fAI_RESEARCH_WEIGHT_BASE_MOD;

	fld	DWORD PTR [ecx+8012]

; 7025 : 	}

	ret	0
?getAI_RESEARCH_WEIGHT_BASE_MOD@CvGlobals@@QAEMXZ ENDP	; CvGlobals::getAI_RESEARCH_WEIGHT_BASE_MOD
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??0DelegateMemento@fastdelegate@@QAE@XZ		; fastdelegate::DelegateMemento::DelegateMemento
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0DelegateMemento@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0DelegateMemento@fastdelegate@@QAE@XZ PROC		; fastdelegate::DelegateMemento::DelegateMemento, COMDAT
; _this$ = ecx

; 579  : 	DelegateMemento() : m_pthis(0), m_pFunction(0) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0DelegateMemento@fastdelegate@@QAE@XZ ENDP		; fastdelegate::DelegateMemento::DelegateMemento
_TEXT	ENDS
PUBLIC	?clear@DelegateMemento@fastdelegate@@QAEXXZ	; fastdelegate::DelegateMemento::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@DelegateMemento@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@DelegateMemento@fastdelegate@@QAEXXZ PROC	; fastdelegate::DelegateMemento::clear, COMDAT
; _this$ = ecx

; 580  : 	void clear() {	m_pthis=0; m_pFunction=0;	}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@DelegateMemento@fastdelegate@@QAEXXZ ENDP	; fastdelegate::DelegateMemento::clear
_TEXT	ENDS
PUBLIC	?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ; fastdelegate::DelegateMemento::SetMementoFrom
; Function compile flags: /Ogtpy
;	COMDAT ?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z
_TEXT	SEGMENT
_right$ = 8						; size = 4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z PROC ; fastdelegate::DelegateMemento::SetMementoFrom, COMDAT
; _this$ = ecx

; 637  : 		m_pFunction = right.m_pFunction;

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 638  : 		m_pthis = right.m_pthis;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 639  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 640  : 		m_pStaticFunction = right.m_pStaticFunction;
; 641  : #endif
; 642  : 	}

	ret	4
?SetMementoFrom@DelegateMemento@fastdelegate@@IAEXABV12@@Z ENDP ; fastdelegate::DelegateMemento::SetMementoFrom
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ; CvTechAI::GetLogFileName
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
$T222354 = -72						; size = 4
$T222352 = -68						; size = 28
$T222351 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z PROC	; CvTechAI::GetLogFileName, COMDAT
; _this$ = ecx

; 507  : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T222354[esp+80], ebx

; 508  : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 518  : 	}
; 519  : 
; 520  : 	return strLogName;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	DWORD PTR $T222354[esp+80], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN2@GetLogFile
	mov	eax, DWORD PTR _playerName$[esp+76]
	push	eax
	lea	ecx, DWORD PTR $T222351[esp+84]
	push	OFFSET $SG218874
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG218873
	push	eax
	lea	edx, DWORD PTR $T222352[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+88], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T222352[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T222351[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	pop	ebx

; 521  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
$LN2@GetLogFile:

; 509  : 
; 510  : 	// Open the log file
; 511  : 	if(GC.getPlayerAndCityAILogSplit())
; 512  : 	{
; 513  : 		strLogName = "TechAILog_" + playerName + ".csv";
; 514  : 	}
; 515  : 	else
; 516  : 	{
; 517  : 		strLogName = "TechAILog.csv";

	push	OFFSET $SG218876
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 521  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$0:
	mov	eax, DWORD PTR $T222354[ebp]
	and	eax, 1
	je	$LN6@GetLogFile
	and	DWORD PTR $T222354[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T222351[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T222352[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ENDP	; CvTechAI::GetLogFileName
PUBLIC	?GetElement@?$CvWeightedVector@H$0FA@$00@@QBEABHI@Z ; CvWeightedVector<int,80,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@H$0FA@$00@@QBEABHI@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@H$0FA@$00@@QBEABHI@Z PROC ; CvWeightedVector<int,80,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@H$0FA@$00@@QBEABHI@Z ENDP ; CvWeightedVector<int,80,1>::GetElement
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@H$0FA@$00@@QBEHI@Z ; CvWeightedVector<int,80,1>::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@?$CvWeightedVector@H$0FA@$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@H$0FA@$00@@QBEHI@Z PROC	; CvWeightedVector<int,80,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 8

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[esp+8], edx

; 75   : 	}

	add	esp, 8
	ret	4
?GetWeight@?$CvWeightedVector@H$0FA@$00@@QBEHI@Z ENDP	; CvWeightedVector<int,80,1>::GetWeight
_TEXT	ENDS
PUBLIC	?IncreaseWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z ; CvWeightedVector<int,80,1>::IncreaseWeight
; Function compile flags: /Ogtpy
;	COMDAT ?IncreaseWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?IncreaseWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z PROC ; CvWeightedVector<int,80,1>::IncreaseWeight, COMDAT
; _this$ = ecx

; 78   : 		m_pItems[iIndex].m_iWeight += iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	mov	edx, DWORD PTR _iWeight$[esp-4]
	add	DWORD PTR [eax+ecx*8+4], edx
	lea	eax, DWORD PTR [eax+ecx*8+4]

; 79   : 		CvAssertMsg(m_pItems[iIndex].m_iWeight >= 0, "Weight should not be negative.");
; 80   : 	}

	ret	8
?IncreaseWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z ENDP ; CvWeightedVector<int,80,1>::IncreaseWeight
_TEXT	ENDS
PUBLIC	?SetWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z ; CvWeightedVector<int,80,1>::SetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?SetWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?SetWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z PROC	; CvWeightedVector<int,80,1>::SetWeight, COMDAT
; _this$ = ecx

; 83   : 		m_pItems[iIndex].m_iWeight = iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iWeight$[esp-4]
	mov	edx, DWORD PTR _iIndex$[esp-4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 84   : 		CvAssertMsg(m_pItems[iIndex].m_iWeight >= 0, "Weight should not be negative.");
; 85   : 	}

	ret	8
?SetWeight@?$CvWeightedVector@H$0FA@$00@@QAEXIH@Z ENDP	; CvWeightedVector<int,80,1>::SetWeight
_TEXT	ENDS
PUBLIC	?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ ; CvWeightedVector<int,80,1>::GetTotalWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ
_TEXT	SEGMENT
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ PROC ; CvWeightedVector<int,80,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR [ecx+4]
	push	ebp
	push	esi
	push	edi

; 90   : 		int rtnValue = 0;

	xor	edx, edx
	xor	esi, esi
	xor	edi, edi

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	xor	ebp, ebp
	cmp	ebx, 2
	mov	DWORD PTR _rtnValue$[esp+20], edx
	jl	SHORT $LC15@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ebx-2]
	shr	edx, 1
	add	eax, 12					; 0000000cH
	inc	edx
	lea	ebp, DWORD PTR [edx+edx]
$LL16@GetTotalWe:
	add	esi, DWORD PTR [eax-8]
	add	edi, DWORD PTR [eax]
	add	eax, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL16@GetTotalWe
	mov	edx, DWORD PTR _rtnValue$[esp+20]
$LC15@GetTotalWe:

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	cmp	ebp, ebx
	jae	SHORT $LN14@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];
; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+ebp*8+4]
$LN14@GetTotalWe:
	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	pop	ebp

; 96   : 		}
; 97   : 
; 98   : 		return rtnValue;

	add	eax, edx
	pop	ebx

; 99   : 	};

	pop	ecx
	ret	0
?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ ENDP ; CvWeightedVector<int,80,1>::GetTotalWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@H$0FA@$00@@QAEHXZ	; CvWeightedVector<int,80,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@H$0FA@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@H$0FA@$00@@QAEHXZ PROC		; CvWeightedVector<int,80,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@H$0FA@$00@@QAEHXZ ENDP		; CvWeightedVector<int,80,1>::size
_TEXT	ENDS
PUBLIC	??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAE@XZ ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 80			; 00000050H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z PROC	; fastdelegate::FastDelegate2<int,char const *,int>::operator(), COMDAT
; _this$ = ecx

; 1080 : 	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	eax
??R?$FastDelegate2@HPBDH@fastdelegate@@QBEHHPBD@Z ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::operator()
_TEXT	ENDS
PUBLIC	?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ; fastdelegate::FastDelegate2<int,char const *,int>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ
_TEXT	SEGMENT
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::clear, COMDAT
; _this$ = ecx

; 1101 : 	void clear() { m_Closure.clear();}

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
?clear@?$FastDelegate2@HPBDH@fastdelegate@@QAEXXZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::clear
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z PROC ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE@V?$allocator@ULeaderWithNumTechs@@@1@@Z ENDP ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@PAULeaderWithNumTechs@@@Z ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?max_size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEIXZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEPAULeaderWithNumTechs@@I@Z ; std::allocator<LeaderWithNumTechs>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEPAULeaderWithNumTechs@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEPAULeaderWithNumTechs@@I@Z PROC ; std::allocator<LeaderWithNumTechs>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ; std::_Allocate<LeaderWithNumTechs>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@ULeaderWithNumTechs@@@std@@QAEPAULeaderWithNumTechs@@I@Z ENDP ; std::allocator<LeaderWithNumTechs>::allocate
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+=
_TEXT	ENDS
PUBLIC	??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z
_TEXT	SEGMENT
_pParent$ = 8						; size = 4
_right$ = 12						; size = 4
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >, COMDAT
; _this$ = ecx

; 763  : #endif
; 764  : 		SetMementoFrom(right);

	mov	eax, DWORD PTR _right$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 765  : 	}

	ret	8
??$CopyFrom@V?$FastDelegate2@HPBDH@fastdelegate@@@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAV?$FastDelegate2@HPBDH@2@ABVDelegateMemento@2@@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::CopyFrom<fastdelegate::FastDelegate2<int,char const *,int> >
_TEXT	ENDS
PUBLIC	??$fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z ; std::fill<LeaderWithNumTechs *,LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z PROC ; std::fill<LeaderWithNumTechs *,LeaderWithNumTechs>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z ENDP ; std::fill<LeaderWithNumTechs *,LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator!=
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<LeaderWithNumTechs *,LeaderWithNumTechs *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<LeaderWithNumTechs *,LeaderWithNumTechs *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAULeaderWithNumTechs@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<LeaderWithNumTechs *,LeaderWithNumTechs *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@ABU3@@Z ; std::allocator<LeaderWithNumTechs>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@ABU3@@Z PROC ; std::allocator<LeaderWithNumTechs>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@ABU3@@Z ENDP ; std::allocator<LeaderWithNumTechs>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@@Z ; std::allocator<LeaderWithNumTechs>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@@Z PROC ; std::allocator<LeaderWithNumTechs>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@ULeaderWithNumTechs@@@std@@QAEXPAULeaderWithNumTechs@@@Z ENDP ; std::allocator<LeaderWithNumTechs>::destroy
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z PROC ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>, COMDAT
; _this$ = ecx

; 673  : 		m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
; 674  : 			::Convert(pthis, function_to_bind, m_pFunction);

	mov	eax, DWORD PTR _function_to_bind$[esp-4]
	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx

; 675  : #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
; 676  : 		m_pStaticFunction = 0;
; 677  : #endif
; 678  : 	}

	ret	8
??$bindmemfunc@VCvGame@@P81@AEHHPBD@Z@?$ClosurePtr@P8GenericClass@detail@fastdelegate@@AEHHPBD@ZP6AHH0@ZP6AHH0@Z@detail@fastdelegate@@QAEXPAVCvGame@@P83@AEHHPBD@Z@Z ENDP ; fastdelegate::detail::ClosurePtr<int (__thiscall fastdelegate::detail::GenericClass::*)(int,char const *),int (__cdecl*)(int,char const *),int (__cdecl*)(int,char const *)>::bindmemfunc<CvGame,int (__thiscall CvGame::*)(int,char const *)>
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::iter_swap<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z ; std::get_temporary_buffer<LeaderWithNumTechs>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z
_TEXT	SEGMENT
$T222655 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T222659 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z PROC ; std::get_temporary_buffer<LeaderWithNumTechs>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
	npad	12
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi*8]
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 8
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T222659[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T222655[esp+20]
	mov	DWORD PTR $T222659[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T222655[esp+20]
	push	ecx
	mov	DWORD PTR $T222655[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z ENDP ; std::get_temporary_buffer<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEAAULeaderWithNumTechs@@XZ ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEAAULeaderWithNumTechs@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEAAULeaderWithNumTechs@@XZ PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBEAAULeaderWithNumTechs@@XZ ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<LeaderWithNumTechs>::_Temp_iterator<LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<LeaderWithNumTechs>::_Temp_iterator<LeaderWithNumTechs>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::_Temp_iterator<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$_Advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR __Left$[esp-4]
	push	esi
	mov	edx, ecx
	mov	esi, eax
	cmp	eax, ecx
	je	SHORT $LN11@iter_swap@2
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], ebx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [edx], edi
	pop	edi
	mov	DWORD PTR [edx+4], eax
	pop	ebx
$LN11@iter_swap@2:
	pop	esi

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_
	push	esi
$LL8@unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_
	pop	esi
$LN7@unchecked_:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 8

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -8			; fffffff8H

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator--
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T222890 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T222890[esp+12], edi
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN1@Copy_opt
	lea	esi, DWORD PTR [edi+8]
$LL13@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+24]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN26@Copy_opt
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+24]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt
$LN26@Copy_opt:
	cmp	eax, edi
	je	SHORT $LN31@Copy_opt
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+24]
$LN31@Copy_opt:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt:
	mov	ecx, DWORD PTR __First$[esp+8]
	add	ecx, esi
	mov	DWORD PTR __First$[esp+8], ecx
	cmp	ecx, DWORD PTR __Last$[esp+8]
	jne	SHORT $LL13@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	cmp	eax, edi
	je	SHORT $LN53@Copy_opt
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Copy_opt:
	pop	edi
	mov	eax, esi
	pop	esi

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@3
	npad	6
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last$[esp-4], eax
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@3

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@3:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@H@Z ; std::advance<LeaderWithNumTechs *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@H@Z PROC ; std::advance<LeaderWithNumTechs *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAULeaderWithNumTechs@@H@std@@YAXAAPAULeaderWithNumTechs@@H@Z ENDP ; std::advance<LeaderWithNumTechs *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	cmp	eax, DWORD PTR __Last$[esp-4]
	je	SHORT $LN28@Copy_opt@2
	mov	ecx, 8
	push	esi
$LL12@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR __First$[esp]
	add	DWORD PTR __Dest$[esp], ecx
	add	eax, ecx
	mov	DWORD PTR __First$[esp], eax
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LL12@Copy_opt@2

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN28@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	edx, eax
	je	SHORT $LN15@Copy_backw@4
	push	esi
	npad	3
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	esi, DWORD PTR [eax-8]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Dest$[esp], ecx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], ecx
	cmp	eax, edx
	jne	SHORT $LL2@Copy_backw@4

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], edx
	pop	esi

; 2678 : 	}

	ret	0
$LN15@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN16@Copy_opt@3
	push	esi
	mov	edx, 8
	push	edi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], esi
	add	DWORD PTR __Dest$[esp+4], edx
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LL3@Copy_opt@3

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN16@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?Write@CvTechAI@@QBEXAAVFDataStream@@@Z		; CvTechAI::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?GetNumTechs@CvTechXMLEntries@@QAEHXZ:PROC	; CvTechXMLEntries::GetNumTechs
EXTRN	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ:PROC ; CvPlayerTechs::GetTechs
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
;	COMDAT ?Write@CvTechAI@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -16					; size = 4
$T223179 = -12						; size = 4
_elem$223194 = -8					; size = 8
_uiCount$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvTechAI@@QBEXAAVFDataStream@@@Z PROC		; CvTechAI::Write, COMDAT
; _this$ = ecx

; 83   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi

; 84   : 	// Current version number
; 85   : 	uint uiVersion = 1;
; 86   : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+24]
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	ebx, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+32], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 87   : 
; 88   : 	CvAssertMsg(m_pCurrentTechs->GetTechs() != NULL, "Tech AI serialization failure: no tech data");
; 89   : 	CvAssertMsg(m_pCurrentTechs->GetTechs()->GetNumTechs() > 0, "Tech AI serialization failure: number of techs not greater than 0");
; 90   : 
; 91   : 	uint uiCount = m_pCurrentTechs->GetTechs()->GetNumTechs();

	mov	ecx, DWORD PTR [ebx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs

; 92   : 	kStream << uiCount;

	lea	ecx, DWORD PTR _uiCount$[esp+24]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _uiCount$[esp+28], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 93   : 
; 94   : 	// Loop through writing each entry
; 95   : 	for(uint i = 0; i < uiCount; i++)

	xor	esi, esi
	cmp	DWORD PTR _uiCount$[esp+24], esi
	jbe	SHORT $LN1@Write
$LL3@Write:

; 96   : 	{
; 97   : 		CvInfosSerializationHelper::WriteHashed(kStream, (TechTypes)i);	// Write out the hash ID first

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed

; 98   : 		kStream << m_TechAIWeights.GetWeight(i);

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [eax+esi*8+4]
	mov	DWORD PTR $T223179[esp+36], eax
	add	esp, 8
	lea	eax, DWORD PTR $T223179[esp+28]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _elem$223194[esp+32], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	esi
	cmp	esi, DWORD PTR _uiCount$[esp+24]
	jb	SHORT $LL3@Write
$LN1@Write:
	pop	edi
	pop	esi
	pop	ebx

; 99   : 	}
; 100  : }

	add	esp, 16					; 00000010H
	ret	4
?Write@CvTechAI@@QBEXAAVFDataStream@@@Z ENDP		; CvTechAI::Write
_TEXT	ENDS
PUBLIC	?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z	; CvTechAI::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z
_TEXT	SEGMENT
_elem$223216 = -8					; size = 8
_eTech$ = 8						; size = 4
?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z PROC		; CvTechAI::GetWeight, COMDAT
; _this$ = ecx

; 275  : {

	sub	esp, 8

; 276  : 	return m_TechAIWeights.GetWeight(eTech);

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _eTech$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$223216[esp+8], edx

; 277  : }

	add	esp, 8
	ret	4
?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z ENDP		; CvTechAI::GetWeight
_TEXT	ENDS
PUBLIC	?PropagateWeights@CvTechAI@@AAEXHHHH@Z		; CvTechAI::PropagateWeights
EXTRN	?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetPrereqAndTechs
EXTRN	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z:PROC ; CvTechXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?PropagateWeights@CvTechAI@@AAEXHHHH@Z
_TEXT	SEGMENT
_pkTechInfo$ = 8					; size = 4
_iTech$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
_iPropagationLevel$ = 20				; size = 4
?PropagateWeights@CvTechAI@@AAEXHHHH@Z PROC		; CvTechAI::PropagateWeights, COMDAT
; _this$ = ecx

; 364  : 	CvTechEntry* pkTechInfo = m_pCurrentTechs->GetTechs()->GetEntry(iTech);

	mov	eax, DWORD PTR _iTech$[esp-4]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
	mov	DWORD PTR _pkTechInfo$[esp], eax

; 365  : 	if(pkTechInfo)

	test	eax, eax
	je	SHORT $LN3@PropagateW
	push	ebp

; 366  : 	{
; 367  : 		if(iPropagationLevel < GC.getTECH_WEIGHT_PROPAGATION_LEVELS())

	mov	ebp, DWORD PTR _iPropagationLevel$[esp+4]
	cmp	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1840
	jge	SHORT $LN22@PropagateW

; 368  : 		{
; 369  : 			int iPropagatedWeight = iWeight * iPropagationPercent / 100;

	mov	ecx, DWORD PTR _iWeight$[esp+4]
	imul	ecx, DWORD PTR _iPropagationPercent$[esp+4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	push	ebx
	sar	edx, 5
	push	esi
	mov	esi, edx
	shr	esi, 31					; 0000001fH

; 370  : 
; 371  : 			// Loop through all prerequisites
; 372  : 			for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	xor	ebx, ebx
	add	esi, edx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268, ebx
	jle	SHORT $LN23@PropagateW
$LL6@PropagateW:

; 373  : 			{
; 374  : 				// Did we find a prereq?
; 375  : 				int iPrereq = pkTechInfo->GetPrereqAndTechs(iI);

	mov	ecx, DWORD PTR _pkTechInfo$[esp+12]
	push	ebx
	call	?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetPrereqAndTechs

; 376  : 				if(iPrereq != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN23@PropagateW

; 377  : 				{
; 378  : 					// Apply reduced weight here.  Note that we apply these to the master weight array, not
; 379  : 					// the temporary one.  The temporary one is just used to hold the newly weighted techs
; 380  : 					// (from which this weight propagation must originate).
; 381  : 					m_TechAIWeights.IncreaseWeight(iPrereq, iPropagatedWeight);

	mov	ecx, DWORD PTR [edi+4]
	add	DWORD PTR [ecx+eax*8+4], esi
	lea	ecx, DWORD PTR [ecx+eax*8+4]

; 382  : 
; 383  : 					// Recurse to its prereqs (assuming we have any weight left)
; 384  : 					if(iPropagatedWeight > 0)

	test	esi, esi
	jle	SHORT $LN5@PropagateW

; 385  : 					{
; 386  : 						PropagateWeights(iPrereq, iPropagatedWeight, iPropagationPercent, iPropagationLevel++);

	mov	edx, DWORD PTR _iPropagationPercent$[esp+12]
	push	ebp
	push	edx
	push	esi
	push	eax
	mov	ecx, edi
	call	?PropagateWeights@CvTechAI@@AAEXHHHH@Z	; CvTechAI::PropagateWeights
	inc	ebp
$LN5@PropagateW:
	inc	ebx
	cmp	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	jl	SHORT $LL6@PropagateW
$LN23@PropagateW:
	pop	esi
	pop	ebx
$LN22@PropagateW:
	pop	ebp
$LN3@PropagateW:
	pop	edi

; 387  : 					}
; 388  : 				}
; 389  : 				else
; 390  : 				{
; 391  : 					break;
; 392  : 				}
; 393  : 
; 394  : 			}
; 395  : 		}
; 396  : 	}
; 397  : }

	ret	16					; 00000010H
?PropagateWeights@CvTechAI@@AAEXHHHH@Z ENDP		; CvTechAI::PropagateWeights
_TEXT	ENDS
PUBLIC	?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z	; CvTechAI::ReweightByCost
EXTRN	_pow:PROC
EXTRN	?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::GetResearchTurnsLeft
EXTRN	?getOverflowResearchTimes100@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getOverflowResearchTimes100
EXTRN	?GetScienceTimes100@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetScienceTimes100
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_bNeedExpensiveTechs$ = -29				; size = 1
_iTurnsLeft$218810 = -28				; size = 4
_fWeightDivisor$218811 = -24				; size = 8
_fTotalCostFactor$218813 = -24				; size = 8
_fAdditionalTurnCostFactor$218812 = -24			; size = 8
_elem$223288 = -16					; size = 8
_elem$223302 = -8					; size = 8
_pPlayer$ = 8						; size = 4
?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z PROC	; CvTechAI::ReweightByCost, COMDAT
; _this$ = ecx

; 401  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H
	push	ebx

; 402  : 	TechTypes eTech;
; 403  : 
; 404  : 	// April 2014 Balance Patch: if lots of science overflow, want to pick an expensive tech
; 405  : 	bool bNeedExpensiveTechs = pPlayer->getOverflowResearchTimes100() > (pPlayer->GetScienceTimes100() * 2);

	mov	ebx, DWORD PTR _pPlayer$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, ebx
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	mov	edi, eax
	mov	ecx, ebx
	add	edi, edi
	call	?getOverflowResearchTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getOverflowResearchTimes100
	cmp	eax, edi
	setg	BYTE PTR _bNeedExpensiveTechs$[esp+64]

; 406  : 
; 407  : 	for(int iI = 0; iI < m_ResearchableTechs.size(); iI++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+664], ebx
	jle	$LN3@ReweightBy
	npad	8
$LL5@ReweightBy:

; 408  : 	{
; 409  : 		eTech = (TechTypes) m_ResearchableTechs.GetElement(iI);

	mov	eax, DWORD PTR [esi+660]
	mov	eax, DWORD PTR [eax+ebx*8]

; 410  : 		int iTurnsLeft = 0;
; 411  : 
; 412  : 		iTurnsLeft = m_pCurrentTechs->GetResearchTurnsLeft(eTech, true);

	mov	ecx, DWORD PTR [esi]
	push	1
	push	eax
	call	?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeft
	mov	DWORD PTR _iTurnsLeft$218810[esp+64], eax

; 413  : 
; 414  : 		double fWeightDivisor;
; 415  : 
; 416  : 		// 10 turns will add 0.02; 80 turns will add 0.16
; 417  : 		double fAdditionalTurnCostFactor = GC.getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT() * iTurnsLeft;	// 0.015

	fild	DWORD PTR _iTurnsLeft$218810[esp+64]

; 418  : 		double fTotalCostFactor = GC.getAI_RESEARCH_WEIGHT_BASE_MOD() + fAdditionalTurnCostFactor;	// 0.15
; 419  : 
; 420  : 		fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);

	sub	esp, 8
	mov	eax, esp
	sub	esp, 8
	fmul	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8008
	fstp	QWORD PTR _fAdditionalTurnCostFactor$218812[esp+80]
	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8012
	fadd	QWORD PTR _fAdditionalTurnCostFactor$218812[esp+80]
	fstp	QWORD PTR _fTotalCostFactor$218813[esp+80]
	mov	ecx, DWORD PTR _fTotalCostFactor$218813[esp+80]
	fild	DWORD PTR _iTurnsLeft$218810[esp+80]
	mov	edx, DWORD PTR _fTotalCostFactor$218813[esp+84]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	fstp	QWORD PTR [esp]
	call	_pow
	fstp	QWORD PTR _fWeightDivisor$218811[esp+80]
	mov	eax, DWORD PTR [esi+660]

; 421  : 
; 422  : 		int iNewWeight;
; 423  : 		if (bNeedExpensiveTechs)
; 424  : 		{
; 425  : 			iNewWeight = int(double(m_ResearchableTechs.GetWeight(iI)) * fWeightDivisor);

	mov	ecx, DWORD PTR [eax+ebx*8]
	mov	edx, DWORD PTR [eax+ebx*8+4]
	lea	edi, DWORD PTR [eax+ebx*8]
	add	esp, 16					; 00000010H
	cmp	BYTE PTR _bNeedExpensiveTechs$[esp+64], 0
	je	SHORT $LN2@ReweightBy
	mov	DWORD PTR _elem$223288[esp+68], edx
	fild	DWORD PTR _elem$223288[esp+68]
	mov	DWORD PTR _elem$223288[esp+64], ecx
	fmul	QWORD PTR _fWeightDivisor$218811[esp+64]

; 426  : 		}
; 427  : 		else

	jmp	SHORT $LN38@ReweightBy
$LN2@ReweightBy:

; 428  : 		{
; 429  : 			iNewWeight = int(double(m_ResearchableTechs.GetWeight(iI)) / fWeightDivisor);

	mov	DWORD PTR _elem$223302[esp+68], edx
	fild	DWORD PTR _elem$223302[esp+68]
	mov	DWORD PTR _elem$223302[esp+64], ecx
	fdiv	QWORD PTR _fWeightDivisor$218811[esp+64]
$LN38@ReweightBy:
	call	__ftol2_sse_excpt
	inc	ebx

; 430  : 		}
; 431  : 
; 432  : 		// Now actually change the weight
; 433  : 		m_ResearchableTechs.SetWeight(iI, iNewWeight);

	mov	DWORD PTR [edi+4], eax
	cmp	ebx, DWORD PTR [esi+664]
	jl	$LL5@ReweightBy
$LN3@ReweightBy:

; 434  : 	}
; 435  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z ENDP	; CvTechAI::ReweightByCost
_TEXT	ENDS
PUBLIC	?LogPossibleResearch@CvTechAI@@AAEXXZ		; CvTechAI::LogPossibleResearch
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ:PROC ; CvPlayerTechs::GetPlayer
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogPossibleResearch@CvTechAI@@AAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPossibleResearch@CvTechAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossibleResearch@CvTechAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossibleResearch@CvTechAI@@AAEXXZ
_TEXT	SEGMENT
_playerName$218825 = -216				; size = 28
_strBaseString$218823 = -188				; size = 28
_strTemp$218824 = -160					; size = 28
_strOutBuf$218822 = -132				; size = 28
$T223321 = -104						; size = 28
$T223318 = -104						; size = 28
_elem$223399 = -76					; size = 8
$T223317 = -68						; size = 28
_strDesc$218826 = -40					; size = 28
__$EHRec$ = -12						; size = 12
?LogPossibleResearch@CvTechAI@@AAEXXZ PROC		; CvTechAI::LogPossibleResearch, COMDAT
; _this$ = ecx

; 439  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPossibleResearch@CvTechAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 204				; 000000ccH
	push	edi
	mov	edi, ecx

; 440  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN4@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN4@LogPossibl

; 441  : 	{
; 442  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$218822[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 443  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$218823[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 444  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218824[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 445  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$218825[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 446  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$218826[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 447  : 
; 448  : 		// Find the name of this civ
; 449  : 		playerName = m_pCurrentTechs->GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+228], 4
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$218825[esp+220]
	test	eax, eax
	je	SHORT $LN33@LogPossibl
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN32@LogPossibl
$LN33@LogPossibl:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN32@LogPossibl:
	push	ebp
	push	esi

; 450  : 
; 451  : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _playerName$218825[esp+228]
	push	eax
	lea	ecx, DWORD PTR $T223317[esp+232]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ; CvTechAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+236], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T223317[esp+228]
	mov	ebp, eax
	mov	BYTE PTR __$EHRec$[esp+236], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 452  : 
; 453  : 		// Get the leading info for this line
; 454  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$218823[esp+232]
	push	OFFSET $SG218829
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 455  : 		strBaseString += playerName + ", ";

	push	OFFSET $SG218831
	lea	edx, DWORD PTR _playerName$218825[esp+244]
	push	edx
	lea	eax, DWORD PTR $T223318[esp+248]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$218823[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T223318[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 456  : 
; 457  : 		// Dump out the weight of each Researchable Tech
; 458  : 		for(int iI = 0; iI < m_ResearchableTechs.size(); iI++)

	xor	esi, esi
	cmp	DWORD PTR [edi+664], esi
	jle	$LN1@LogPossibl
	push	ebx
$LL3@LogPossibl:
	mov	ecx, DWORD PTR [edi+660]

; 459  : 		{
; 460  : 			TechTypes eTech = (TechTypes) m_ResearchableTechs.GetElement(iI);
; 461  : 			int iWeight = m_ResearchableTechs.GetWeight(iI);

	mov	ebx, DWORD PTR [ecx+esi*8+4]
	lea	eax, DWORD PTR [ecx+esi*8]
	mov	ecx, DWORD PTR [eax]
	mov	edx, ecx

; 462  : 
; 463  : 			CvTechEntry* pTechEntry = GC.getTechInfo(eTech);

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _elem$223399[esp+236], edx
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 464  : 			const char* szTechType = (pTechEntry != NULL)? pTechEntry->GetType() : "Unknown Tech";

	test	eax, eax
	je	SHORT $LN7@LogPossibl
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN8@LogPossibl
$LN7@LogPossibl:
	mov	eax, OFFSET $SG218841
$LN8@LogPossibl:

; 465  : 
; 466  : 			strTemp.Format("%s, %d", szTechType, iWeight);

	push	ebx
	push	eax
	lea	eax, DWORD PTR _strTemp$218824[esp+240]
	push	OFFSET $SG218842
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 467  : 
; 468  : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$218824[esp+248]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$218823[esp+252]
	push	edx
	lea	eax, DWORD PTR $T223321[esp+256]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+240], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$218822[esp+236]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T223321[esp+232]
	mov	BYTE PTR __$EHRec$[esp+240], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 469  : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$218822[esp+232]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	inc	esi
	add	esp, 8
	cmp	esi, DWORD PTR [edi+664]
	jl	$LL3@LogPossibl
	pop	ebx
$LN1@LogPossibl:

; 470  : 		}
; 471  : 	}

	lea	ecx, DWORD PTR _strDesc$218826[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$218825[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$218824[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$218823[esp+228]
	mov	BYTE PTR __$EHRec$[esp+236], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$218822[esp+228]
	mov	DWORD PTR __$EHRec$[esp+236], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebp
$LN4@LogPossibl:

; 472  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+220]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 216				; 000000d8H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$218822[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$218823[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$218824[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$218825[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strDesc$218826[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T223317[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T223318[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T223321[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPossibleResearch@CvTechAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogPossibleResearch@CvTechAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossibleResearch@CvTechAI@@AAEXXZ ENDP		; CvTechAI::LogPossibleResearch
PUBLIC	?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ; CvTechAI::LogResearchChoice
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
_TEXT	SEGMENT
_playerName$218849 = -208				; size = 28
_strBaseString$218851 = -180				; size = 28
_strOutBuf$218850 = -152				; size = 28
$T223446 = -124						; size = 28
$T223443 = -124						; size = 28
_strTemp$218852 = -96					; size = 28
$T223442 = -68						; size = 28
_strDesc$218853 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eTech$ = 8						; size = 4
?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z PROC	; CvTechAI::LogResearchChoice, COMDAT
; _this$ = ecx

; 476  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	edi
	mov	edi, ecx

; 477  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogResearc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogResearc
	push	ebx
	push	esi

; 478  : 	{
; 479  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$218849[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 480  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$218850[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 481  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$218851[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 482  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218852[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 483  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$218853[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 484  : 
; 485  : 		// Find the name of this civ
; 486  : 		playerName = m_pCurrentTechs->GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$218849[esp+220]
	test	eax, eax
	je	SHORT $LN30@LogResearc
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogResearc
$LN30@LogResearc:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogResearc:

; 487  : 
; 488  : 		FILogFile* pLog;
; 489  : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _playerName$218849[esp+220]
	push	eax
	lea	ecx, DWORD PTR $T223442[esp+224]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ; CvTechAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T223442[esp+220]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 490  : 
; 491  : 		// Get the leading info for this line
; 492  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$218851[esp+224]
	push	OFFSET $SG218856
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 493  : 		strBaseString += playerName + ", ";

	push	OFFSET $SG218858
	lea	edx, DWORD PTR _playerName$218849[esp+236]
	push	edx
	lea	eax, DWORD PTR $T223443[esp+240]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$218851[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T223443[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 494  : 
; 495  : 		CvTechEntry* pTechEntry = GC.getTechInfo(eTech);

	mov	ecx, DWORD PTR _eTech$[esp+216]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 496  : 		const char* szTechType = (pTechEntry != NULL)? pTechEntry->GetType() : "Unknown Tech";

	test	eax, eax
	je	SHORT $LN4@LogResearc
	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN5@LogResearc
$LN4@LogResearc:
	mov	eax, OFFSET $SG218861
$LN5@LogResearc:

; 497  : 
; 498  : 		strTemp.Format("CHOSEN, %s", szTechType);

	push	eax
	lea	edx, DWORD PTR _strTemp$218852[esp+224]
	push	OFFSET $SG218862
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 499  : 
; 500  : 		strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$218852[esp+232]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$218851[esp+236]
	push	ecx
	lea	edx, DWORD PTR $T223446[esp+240]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$218850[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T223446[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 501  : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$218850[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 502  : 	}

	lea	ecx, DWORD PTR _strDesc$218853[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$218852[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$218851[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$218850[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$218849[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogResearc:

; 503  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$0:
	lea	ecx, DWORD PTR _playerName$218849[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$218850[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$2:
	lea	ecx, DWORD PTR _strBaseString$218851[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$3:
	lea	ecx, DWORD PTR _strTemp$218852[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$218853[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$5:
	lea	ecx, DWORD PTR $T223442[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$6:
	lea	ecx, DWORD PTR $T223443[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$7:
	lea	ecx, DWORD PTR $T223446[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ENDP	; CvTechAI::LogResearchChoice
PUBLIC	?clear@?$CvWeightedVector@H$0FA@$00@@QAEXXZ	; CvWeightedVector<int,80,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@H$0FA@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@H$0FA@$00@@QAEXXZ PROC	; CvWeightedVector<int,80,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@H$0FA@$00@@QAEXXZ ENDP	; CvWeightedVector<int,80,1>::clear
_TEXT	ENDS
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,80,1>::ChooseFromTopChoices
; Function compile flags: /Ogtpy
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_iNumChoices$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<int,80,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebx
	push	esi
	mov	ebx, ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR [ebx+4]
	push	edi
	mov	edi, DWORD PTR _iNumChoices$[esp+8]
	cmp	edi, eax
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	edi, eax
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	xor	esi, esi

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	xor	ecx, ecx

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	test	edi, edi
	jle	SHORT $LN5@ChooseFrom
	mov	eax, DWORD PTR [ebx]
	mov	edx, edi
	npad	2
$LL7@ChooseFrom:

; 237  : 		{
; 238  : 			elem = m_pItems[i];
; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	add	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax]
	add	eax, 8
	sub	edx, 1
	jne	SHORT $LL7@ChooseFrom
$LN5@ChooseFrom:

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	eax, DWORD PTR _szRollName$[esp+8]
	push	eax
	mov	eax, DWORD PTR _rndFcn$[esp+12]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	edx

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN2@ChooseFrom

; 240  : 		}
; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	ecx, DWORD PTR [ebx]
$LL4@ChooseFrom:

; 247  : 		{
; 248  : 			elem = m_pItems[i];
; 249  : 			iChoice -= elem.m_iWeight;

	sub	eax, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]

; 250  : 			if (iChoice < 0)

	js	SHORT $LN2@ChooseFrom
	inc	edx
	add	ecx, 8
	cmp	edx, edi
	jl	SHORT $LL4@ChooseFrom
$LN2@ChooseFrom:
	pop	edi

; 251  : 			{
; 252  : 				return elem.m_Element;
; 253  : 			}
; 254  : 		}
; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, esi
	pop	esi
	pop	ebx

; 260  : 	};

	ret	12					; 0000000cH
?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<int,80,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ
_TEXT	SEGMENT
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ PROC	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>, COMDAT
; _this$ = ecx

; 1041 : 	FastDelegate2() { clear(); }

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$FastDelegate2@HPBDH@fastdelegate@@QAE@XZ ENDP	; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int>
_TEXT	ENDS
PUBLIC	??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::operator=, COMDAT
; _this$ = ecx

; 1045 : 		m_Closure.CopyFrom(this, x.m_Closure); }

	mov	eax, DWORD PTR _x$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	ret	4
??4?$FastDelegate2@HPBDH@fastdelegate@@QAEXABV01@@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::operator=
_TEXT	ENDS
PUBLIC	?begin@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@XZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::end
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ; std::_Allocate<LeaderWithNumTechs>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN34@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 80					; 00000050H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0IJ@DONJGAGH@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize
$LN16@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 80			; 00000050H
$LN15@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+652], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAULeaderWithNumTechs@@PAU1@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00@Z ; stdext::_Unchecked_move_backward<LeaderWithNumTechs *,LeaderWithNumTechs *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAULeaderWithNumTechs@@PAU1@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAULeaderWithNumTechs@@PAU1@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<LeaderWithNumTechs *,LeaderWithNumTechs *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAULeaderWithNumTechs@@PAU1@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<LeaderWithNumTechs *,LeaderWithNumTechs *>
_TEXT	ENDS
PUBLIC	??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
_pthis$ = 8						; size = 4
_function_to_bind$ = 12					; size = 4
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>, COMDAT
; _this$ = ecx

; 1057 : 		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }

	mov	edx, DWORD PTR _pthis$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _function_to_bind$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	ret	8
??$?0VCvGame@@V0@@?$FastDelegate2@HPBDH@fastdelegate@@QAE@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::FastDelegate2<int,char const *,int>::FastDelegate2<int,char const *,int><CvGame,CvGame>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<LeaderWithNumTechs> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Distance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAH@Z ; std::_Distance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAH@Z PROC ; std::_Distance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0AAH@Z ENDP ; std::_Distance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$219981 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$219981[esp+16]
	push	eax
	call	??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z ; std::get_temporary_buffer<LeaderWithNumTechs>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$219981[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$219981[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
_TEXT	ENDS
PUBLIC	??$advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@H@Z ; std::advance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@H@Z PROC ; std::advance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@H@Z ENDP ; std::advance<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z
_TEXT	SEGMENT
$T223999 = -4						; size = 1
__Cat$224003 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T223999[esp+4], 0
	mov	eax, DWORD PTR $T223999[esp+4]
	mov	ecx, DWORD PTR __Cat$224003[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
$T224008 = -4						; size = 1
$T224015 = -4						; size = 4
$T224011 = -4						; size = 4
__Cat$224019 = 8					; size = 1
$T224010 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T224015[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$224019[esp+4]
	mov	edx, DWORD PTR $T224010[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T224008[esp+12], bl
	mov	eax, DWORD PTR $T224008[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T224011[esp+44], esp
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@2:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T224059 = -4						; size = 1
__Cat$224065 = 8					; size = 1
$T224061 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$224065[esp]
	mov	edx, DWORD PTR $T224061[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T224059[esp+8], 0
	mov	eax, DWORD PTR $T224059[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Lower_boun:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);
; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	cmp	DWORD PTR [esi+eax*8+4], edi
	jle	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN38@Lower_boun:

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2306 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Upper_boun:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);
; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	cmp	edi, DWORD PTR [esi+eax*8+4]
	jg	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	lea	esi, DWORD PTR [esi+eax*8+8]
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN38@Upper_boun:

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2377 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T224259 = -4						; size = 1
__Cat$224265 = 8					; size = 1
$T224261 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$224265[esp]
	mov	edx, DWORD PTR $T224261[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T224259[esp+8], 0
	mov	eax, DWORD PTR $T224259[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z ; stdext::unchecked_copy_backward<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z
_TEXT	SEGMENT
$T224273 = -4						; size = 1
__Cat$224279 = 8					; size = 1
$T224275 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z PROC ; stdext::unchecked_copy_backward<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$224279[esp]
	mov	edx, DWORD PTR $T224275[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T224273[esp+8], 0
	mov	eax, DWORD PTR $T224273[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z ENDP ; stdext::unchecked_copy_backward<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z ; stdext::unchecked_copy<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z
_TEXT	SEGMENT
$T224287 = -4						; size = 1
__Cat$224293 = 8					; size = 1
$T224289 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z PROC ; stdext::unchecked_copy<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$224293[esp]
	mov	edx, DWORD PTR $T224289[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T224287[esp+8], 0
	mov	eax, DWORD PTR $T224287[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@@Z ENDP ; stdext::unchecked_copy<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T224333 = -24						; size = 4
$T224327 = -24						; size = 4
$T224325 = -24						; size = 4
$T224326 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	sub	esp, 24					; 00000018H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp+20]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T224333[esp+32], edi
	cmp	eax, DWORD PTR __Last1$[esp+28]
	je	$LN3@Merge
	mov	ecx, DWORD PTR __First2$[esp+28]
	lea	esi, DWORD PTR [edi+8]
$LL4@Merge:
	cmp	ecx, DWORD PTR __Last2$[esp+28]
	je	$LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+44]
	jle	SHORT $LN2@Merge
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN41@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

$LN41@Merge:
	cmp	eax, edi
	je	SHORT $LN46@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN46@Merge:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2600 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, esi
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN72@Merge
$LN2@Merge:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN61@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR __Dest$[esp+44]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN60@Merge
$LN61@Merge:
	cmp	eax, edi
	je	SHORT $LN66@Merge
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Dest$[esp+44]
$LN66@Merge:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+44]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN60@Merge:
	mov	eax, DWORD PTR __First1$[esp+28]
	mov	ecx, DWORD PTR __First2$[esp+28]
	add	eax, esi
	mov	DWORD PTR __First1$[esp+28], eax
$LN72@Merge:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+28]
	jne	$LL4@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+48]
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR $T224325[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T224326[esp+60]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T224326[esp+64]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+44], edx
	cmp	eax, edi
	je	SHORT $LN88@Merge
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN88@Merge:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+48]
	mov	eax, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR $T224327[esp+52], esp
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN109@Merge
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN109@Merge:

; 2605 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	eax, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	ecx, esi
	je	SHORT $LN28@Merge@2
	npad	5
$LL10@Merge@2:
	cmp	eax, edi
	je	SHORT $LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [eax+4]
	add	eax, 8

; 2600 : 		else

	jmp	SHORT $LN68@Merge@2
$LN2@Merge@2:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	edx, DWORD PTR [ecx+4]
	add	ecx, 8
$LN68@Merge@2:
	mov	ebx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [ebx+4], edx
	mov	edx, DWORD PTR __Dest$[esp+8]
	add	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	cmp	ecx, esi
	jne	SHORT $LL10@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	ecx, esi
	je	SHORT $LN28@Merge@2
	npad	4
$LL30@Merge@2:
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	add	ecx, 8
	add	edx, 8
	cmp	ecx, esi
	jne	SHORT $LL30@Merge@2
$LN28@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	cmp	eax, edi
	je	SHORT $LN66@Merge@2
$LL49@Merge@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
	add	edx, 8
	cmp	eax, edi
	jne	SHORT $LL49@Merge@2
$LN66@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
$T224727 = -24						; size = 4
__Shift$ = -20						; size = 4
$T224731 = -16						; size = 4
$T224732 = -12						; size = 4
__Holeval$221400 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z PROC ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 24					; 00000018H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;
; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Mid$[esp+24]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+32]
	sub	ebx, edi
	sar	ebx, 3
	sub	ecx, edi
	sar	ecx, 3
	mov	DWORD PTR __Shift$[esp+36], ebx
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate
	add	ebx, ebx
	add	ebx, ebx
	push	ebp
	add	ebx, ebx
	jmp	SHORT $LN5@Rotate
	npad	4
$LL93@Rotate:
	mov	edi, DWORD PTR __First$[esp+36]
$LN5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [edi+eax*8+4]
	mov	ebp, DWORD PTR [edi+eax*8]
	lea	esi, DWORD PTR [edi+eax*8]
	mov	DWORD PTR __Holeval$221400[esp+44], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [ebx+esi]
	mov	edi, esi
	cmp	ecx, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN11@Rotate
	lea	ecx, DWORD PTR __First$[esp+36]
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	DWORD PTR $T224727[esp+40], ecx
	lea	ecx, DWORD PTR $T224727[esp+40]
$LN12@Rotate:
	mov	ecx, DWORD PTR [ecx]

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, esi
	je	SHORT $LN1@Rotate
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edi], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+4], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+36]
	sub	edx, ecx
	sar	edx, 3
	cmp	DWORD PTR __Shift$[esp+40], edx
	mov	edi, ecx
	jge	SHORT $LN13@Rotate
	add	ecx, ebx
	mov	DWORD PTR $T224731[esp+40], ecx
	lea	ecx, DWORD PTR $T224731[esp+40]
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	ecx, ebx
	sub	ecx, edx
	add	ecx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR $T224732[esp+40], ecx
	lea	ecx, DWORD PTR $T224732[esp+40]
$LN14@Rotate:
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, esi
	jne	SHORT $LL2@Rotate
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	edx, DWORD PTR __Holeval$221400[esp+44]
	dec	eax
	mov	DWORD PTR [edi], ebp
	mov	DWORD PTR [edi+4], edx
	test	eax, eax
	jg	$LL93@Rotate
	pop	ebp
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	?WeightPrereqs@CvTechAI@@AAEXPAHH@Z		; CvTechAI::WeightPrereqs
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
;	COMDAT ?WeightPrereqs@CvTechAI@@AAEXPAHH@Z
_TEXT	SEGMENT
_paiTempWeights$ = 8					; size = 4
_iPropagationPercent$ = 12				; size = 4
?WeightPrereqs@CvTechAI@@AAEXPAHH@Z PROC		; CvTechAI::WeightPrereqs, COMDAT
; _this$ = ecx

; 346  : {

	push	esi
	push	edi
	mov	edi, ecx

; 347  : 	int iTechLoop;
; 348  : #endif
; 349  : 
; 350  : 	// Loop through techs looking for ones that are just getting some new weight
; 351  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, DWORD PTR [edi]
	xor	esi, esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN2@WeightPrer
	push	ebx
	mov	ebx, DWORD PTR _iPropagationPercent$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _paiTempWeights$[esp+12]
$LL4@WeightPrer:

; 352  : 	{
; 353  : 		// If found one, call our recursive routine to weight everything to the left in the tree
; 354  : 		if(paiTempWeights[iTechLoop] > 0)

	mov	eax, DWORD PTR [ebp+esi*4]
	test	eax, eax
	jle	SHORT $LN3@WeightPrer

; 355  : 		{
; 356  : 			PropagateWeights(iTechLoop, paiTempWeights[iTechLoop], iPropagationPercent, 0);

	push	0
	push	ebx
	push	eax
	push	esi
	mov	ecx, edi
	call	?PropagateWeights@CvTechAI@@AAEXHHHH@Z	; CvTechAI::PropagateWeights
$LN3@WeightPrer:
	mov	ecx, DWORD PTR [edi]
	inc	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	esi, eax
	jl	SHORT $LL4@WeightPrer
	pop	ebp
	pop	ebx
$LN2@WeightPrer:
	pop	edi
	pop	esi

; 357  : 		}
; 358  : 	}
; 359  : }

	ret	8
?WeightPrereqs@CvTechAI@@AAEXPAHH@Z ENDP		; CvTechAI::WeightPrereqs
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@H$0FA@$00@@QAE@XZ		; CvWeightedVector<int,80,1>::CvWeightedVector<int,80,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@H$0FA@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@H$0FA@$00@@QAE@XZ PROC		; CvWeightedVector<int,80,1>::CvWeightedVector<int,80,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 80			; 00000050H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@H$0FA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,80,1>::CvWeightedVector<int,80,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ		; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ PROC		; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
_TEXT	ENDS
PUBLIC	??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::resize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN4@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::resize
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+652], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR _func$[esp-4]
	mov	edx, DWORD PTR _x$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx

; 2032 : }

	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z
_TEXT	SEGMENT
$T225138 = -4						; size = 1
__Cat$225142 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T225138[esp+4], 0
	mov	eax, DWORD PTR $T225138[esp+4]
	mov	ecx, DWORD PTR __Cat$225142[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@@Z ; std::_Destroy_range<std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@@Z PROC ; std::_Destroy_range<std::allocator<LeaderWithNumTechs> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@0AAV?$allocator@ULeaderWithNumTechs@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__Tmp$225259 = -24					; size = 8
__Tmp$225188 = -16					; size = 8
__Tmp$225214 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225188[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$225188[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225214[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$225214[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$225259[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$225259[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$225259[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$225259[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::make_heap<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T225372 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$225376 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$225376[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T225372[esp+4], 0
	mov	eax, DWORD PTR $T225372[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@U_Undefined_move_tag@3@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
$T225447 = -8						; size = 1
$T225382 = -4						; size = 4
__Cat$225452 = 8					; size = 1
$T225449 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 8
	cmp	edx, eax
	je	SHORT $LN6@Insertion_@2
	push	esi

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	je	SHORT $LN73@Insertion_@2
	push	ebx
	mov	ebx, DWORD PTR $T225449[esp+12]
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_@2
$LL72@Insertion_@2:
	mov	edx, DWORD PTR __First$[esp+20]
$LN7@Insertion_@2:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi+4]

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	cmp	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [esi]
	mov	ecx, esi
	jle	SHORT $LN5@Insertion_@2

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T225447[esp+24], 0
	mov	ecx, DWORD PTR $T225447[esp+24]
	push	ecx
	mov	ecx, DWORD PTR __Cat$225452[esp+24]
	push	ecx
	push	ebx
	lea	eax, DWORD PTR [esi+8]
	push	eax
	push	esi
	push	edx
	lea	edx, DWORD PTR $T225382[esp+48]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[esp+48]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR __First$[esp+48]
	add	esp, 28					; 0000001cH

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN75@Insertion_@2
$LN5@Insertion_@2:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-4]
	lea	eax, DWORD PTR [esi-8]
	jle	SHORT $LN1@Insertion_@2
$LL3@Insertion_@2:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, eax
	sub	eax, 8
	cmp	edi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@2
$LN1@Insertion_@2:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebp
$LN75@Insertion_@2:

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	esi, 8

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx+4], edi
	cmp	esi, DWORD PTR __Last$[esp+20]
	jne	SHORT $LL72@Insertion_@2
	pop	edi
	pop	ebp
	pop	ebx
$LN73@Insertion_@2:
	pop	esi
$LN6@Insertion_@2:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	add	esp, 8
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ; std::lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T225521 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z PROC ; std::lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 2313 : 	{	// find first element not before _Val, using _Pred

	push	ecx

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T225521[esp+24]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2317 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ; std::upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T225528 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z PROC ; std::upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 2384 : 	{	// find first element that _Val is before, using _Pred

	push	ecx

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR __Last$[esp]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+8]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T225528[esp+24]
	push	ecx
	call	??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax], edx

; 2388 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::pop_heap<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T225720 = 12						; size = 1
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$225725 = 28					; size = 1
$T225722 = 28						; size = 1
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>, COMDAT

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	cmp	eax, esi
	je	SHORT $LN44@Merge@3
$LL10@Merge@3:
	mov	edx, DWORD PTR __First2$[esp+4]
	cmp	edx, DWORD PTR __Last2$[esp+4]
	je	SHORT $LN68@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ebx, DWORD PTR [edx+4]
	cmp	ebx, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	DWORD PTR __First2$[esp+4], 8

; 2600 : 		else

	jmp	SHORT $LN4@Merge@3
$LN2@Merge@3:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+4], ecx
	add	eax, 8
$LN4@Merge@3:
	mov	ecx, DWORD PTR __Dest$[esp+4]
	add	ecx, 8
	mov	DWORD PTR __Dest$[esp+4], ecx
	cmp	eax, esi
	jne	SHORT $LL10@Merge@3
$LN68@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN44@Merge@3
	npad	3
$LL46@Merge@3:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	add	eax, 8
	add	ecx, 8
	cmp	eax, esi
	jne	SHORT $LL46@Merge@3
$LN44@Merge@3:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR __Dest$[esp+4], ecx
	mov	edx, DWORD PTR __Cat$225725[esp+4]
	mov	BYTE PTR $T225720[esp+4], 0
	mov	eax, DWORD PTR $T225720[esp+4]
	push	eax
	mov	eax, DWORD PTR $T225722[esp+8]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+20]
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi
	pop	ebx

; 2605 : 	}

	ret	0
??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T225784 = -4						; size = 1
$T225759 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$225789 = 16					; size = 1
$T225786 = 16						; size = 1
__Cat$225763 = 16					; size = 1
$T225761 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ecx

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __First1$[esp]
	mov	ecx, DWORD PTR __Last1$[esp]
	mov	eax, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+4]
	push	edi
	cmp	edx, ecx
	je	SHORT $LN61@Merge_back
$LL8@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	cmp	esi, eax
	je	$LN62@Merge_back

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	edx, DWORD PTR [eax-4]
	sub	eax, 8
	sub	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge_back

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[esp+8]
	sub	edx, 8
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx

; 2847 : 		else

	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	eax, 8
	jmp	SHORT $LN57@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	ecx, 8
	mov	DWORD PTR __Last1$[esp+8], ecx
$LN57@Merge_back:
	mov	edx, DWORD PTR __First1$[esp+8]
	cmp	edx, ecx
	jne	SHORT $LL8@Merge_back
$LN61@Merge_back:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$225763[esp+8]
	mov	BYTE PTR $T225759[esp+12], 0
	mov	ecx, DWORD PTR $T225759[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T225761[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	push	esi
	call	??$_Copy_backward_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
$LN62@Merge_back:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T225784[esp+12], 0
	mov	eax, DWORD PTR $T225784[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$225789[esp+12]
	push	eax
	mov	eax, DWORD PTR $T225786[esp+16]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2849 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T225874 = -4						; size = 1
$T225880 = -4						; size = 4
$T225876 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T225875 = 48						; size = 1
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx
	push	ebx
	push	esi
	xor	ebx, ebx
	mov	DWORD PTR $T225880[esp+12], ebx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T225875[esp+8]
	mov	edx, DWORD PTR __Pred$[esp+8]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T225874[esp+12], bl
	mov	eax, DWORD PTR $T225874[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+40]
	mov	eax, DWORD PTR __First2$[esp+40]
	mov	ecx, DWORD PTR __Last1$[esp+40]
	mov	DWORD PTR $T225876[esp+44], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+44]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@3:
	mov	eax, esi

; 5160 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T225920 = -4						; size = 1
$T225921 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z PROC ; stdext::unchecked_merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T225921[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T225920[esp+8], 0
	mov	eax, DWORD PTR $T225920[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z ENDP ; stdext::unchecked_merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z		; CvTechAI::CvTechAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z$0
__ehfuncinfo$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_currentTechs$ = 8					; size = 4
??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z PROC		; CvTechAI::CvTechAI, COMDAT
; _this$ = ecx

; 19   : {

	push	-1
	push	__ehhandler$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	mov	ecx, DWORD PTR _currentTechs$[esp+12]
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [eax+16]
	mov	edx, 80					; 00000050H
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+4], ecx
	lea	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR [eax+660], ecx

; 20   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR [eax+664], 0
	mov	DWORD PTR [eax+668], edx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ	; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
__ehhandler$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z ENDP		; CvTechAI::CvTechAI
PUBLIC	??1CvTechAI@@QAE@XZ				; CvTechAI::~CvTechAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvTechAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTechAI@@QAE@XZ$0
__ehfuncinfo$??1CvTechAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTechAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ??1CvTechAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTechAI@@QAE@XZ PROC				; CvTechAI::~CvTechAI, COMDAT
; _this$ = ecx

; 24   : {

	push	-1
	push	__ehhandler$??1CvTechAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi

; 25   : }

	mov	eax, DWORD PTR [esi+660]
	lea	ecx, DWORD PTR [esi+672]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	cmp	eax, ecx
	je	SHORT $LN10@CvTechAI
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN10@CvTechAI:
	mov	eax, DWORD PTR [esi+4]
	add	esi, 16					; 00000010H
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	esi
	je	SHORT $LN27@CvTechAI
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN27@CvTechAI:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTechAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ	; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
__ehhandler$??1CvTechAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTechAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTechAI@@QAE@XZ ENDP				; CvTechAI::~CvTechAI
PUBLIC	?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z ; CvTechAI::AddFlavorWeights
EXTRN	?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z:PROC ; CvPlayerTechs::GetLocaleTechPriority
EXTRN	?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z:PROC ; CvPlayerTechs::GetCivTechPriority
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?GetFlavorValue@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetFlavorValue
EXTRN	__alloca_probe_16:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z
_TEXT	SEGMENT
_eFlavor$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z PROC ; CvTechAI::AddFlavorWeights, COMDAT
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 105  : #ifdef AUI_WARNING_FIXES
; 106  : 	FFastVector<int, true> paiTempWeights;
; 107  : 	paiTempWeights.reserve(m_pCurrentTechs->GetTechs()->GetNumTechs());
; 108  : #else
; 109  : 	int* paiTempWeights;
; 110  : 
; 111  : 	// Create a temporary array of weights
; 112  : 	paiTempWeights = (int*)_alloca(sizeof(int) * m_pCurrentTechs->GetTechs()->GetNumTechs());

	mov	ecx, DWORD PTR [edi]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	add	eax, eax
	add	eax, eax
	call	__alloca_probe_16

; 113  : #endif
; 114  : 
; 115  : 	// Loop through all our techs
; 116  : #ifdef AUI_WARNING_FIXES
; 117  : 	for (uint iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)
; 118  : #else
; 119  : 	for(int iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)

	mov	ecx, DWORD PTR [edi]
	mov	ebx, esp
	xor	esi, esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN6@AddFlavorW
$LL8@AddFlavorW:

; 120  : #endif
; 121  : 	{
; 122  : 		const TechTypes eTech = static_cast<TechTypes>(iTech);
; 123  : 		CvTechEntry* entry = m_pCurrentTechs->GetTechs()->GetEntry(iTech);

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry

; 124  : 		if (entry)

	test	eax, eax
	je	SHORT $LN7@AddFlavorW

; 125  : 		{
; 126  : #ifdef AUI_WARNING_FIXES
; 127  : 			// Set its weight by looking at tech's weight for this flavor and using iWeight multiplier passed in
; 128  : 			int iLoopWeight = entry->GetFlavorValue(eFlavor) * iWeight;
; 129  : 
; 130  : 			// Multiply the weight by any special player-specific weighting (i.e. to prioritize civ unique bonuses)
; 131  : 			iLoopWeight *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetCivTechPriority(eTech);
; 132  : 
; 133  : 			// Multiply the weight by any locale-specific weighting (i.e. to prioritize unlocking resources)
; 134  : 			iLoopWeight *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetLocaleTechPriority(eTech);
; 135  : 
; 136  : 			paiTempWeights.push_back(iLoopWeight);
; 137  : 		}
; 138  : 		else
; 139  : 			paiTempWeights.push_back(0);
; 140  : #else
; 141  : 			// Set its weight by looking at tech's weight for this flavor and using iWeight multiplier passed in
; 142  : 			paiTempWeights[iTech] = entry->GetFlavorValue(eFlavor) * iWeight;

	mov	ecx, DWORD PTR _eFlavor$[ebp]
	push	ecx
	mov	ecx, eax
	call	?GetFlavorValue@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetFlavorValue
	imul	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR [ebx+esi*4], eax

; 143  : 
; 144  : 			// Multiply the weight by any special player-specific weighting (i.e. to prioritize civ unique bonuses)
; 145  : 			paiTempWeights[iTech] *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetCivTechPriority(eTech);

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetCivTechPriority
	imul	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebx+esi*4], eax

; 146  : 
; 147  : 			// Multiply the weight by any locale-specific weighting (i.e. to prioritize unlocking resources)
; 148  : 			paiTempWeights[iTech] *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetLocaleTechPriority(eTech);

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetLocaleTechPriority
	imul	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebx+esi*4], eax
$LN7@AddFlavorW:
	mov	ecx, DWORD PTR [edi]
	inc	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	esi, eax
	jl	SHORT $LL8@AddFlavorW
$LN6@AddFlavorW:

; 149  : 		}
; 150  : #endif
; 151  : 	}
; 152  : 
; 153  : 	// Propagate these values left in the tree so prereqs get bought
; 154  : 	WeightPrereqs(paiTempWeights, iPropagationPercent);

	mov	edx, DWORD PTR _iPropagationPercent$[ebp]
	push	edx
	push	ebx
	mov	ecx, edi
	call	?WeightPrereqs@CvTechAI@@AAEXPAHH@Z	; CvTechAI::WeightPrereqs

; 155  : 
; 156  : 	// Add these weights over previous ones
; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 	for (uint iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)
; 159  : #else
; 160  : 	for(int iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)

	mov	ecx, DWORD PTR [edi]
	xor	esi, esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN2@AddFlavorW
$LL4@AddFlavorW:

; 161  : #endif
; 162  : 	{
; 163  : 		CvTechEntry* entry = m_pCurrentTechs->GetTechs()->GetEntry(iTech);

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry

; 164  : 		if(entry)

	test	eax, eax
	je	SHORT $LN3@AddFlavorW

; 165  : 		{
; 166  : 			m_TechAIWeights.IncreaseWeight(iTech, paiTempWeights[iTech]);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ebx+esi*4]
	add	DWORD PTR [eax+esi*8+4], ecx
	lea	eax, DWORD PTR [eax+esi*8+4]
$LN3@AddFlavorW:
	mov	ecx, DWORD PTR [edi]
	inc	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	esi, eax
	jl	SHORT $LL4@AddFlavorW
$LN2@AddFlavorW:

; 167  : 		}
; 168  : 	}
; 169  : }

	lea	esp, DWORD PTR [ebp-12]
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	12					; 0000000cH
?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z ENDP ; CvTechAI::AddFlavorWeights
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@H$0FA@$00@@QAEIABHH@Z ; CvWeightedVector<int,80,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@H$0FA@$00@@QAEIABHH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@H$0FA@$00@@QAEIABHH@Z PROC ; CvWeightedVector<int,80,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+652], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@2
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN5@push_back@2:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@2
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@2:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@H$0FA@$00@@QAEIABHH@Z ENDP ; CvWeightedVector<int,80,1>::push_back
_TEXT	ENDS
PUBLIC	?resize@?$CvWeightedVector@H$0FA@$00@@QAEXI@Z	; CvWeightedVector<int,80,1>::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$CvWeightedVector@H$0FA@$00@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$CvWeightedVector@H$0FA@$00@@QAEXI@Z PROC	; CvWeightedVector<int,80,1>::resize, COMDAT
; _this$ = ecx

; 121  : 	{

	push	esi
	push	edi

; 122  : 		m_pItems.resize(uiNewSize);

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize@2
	push	edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN6@resize@2:
	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 123  : 	};

	ret	4
?resize@?$CvWeightedVector@H$0FA@$00@@QAEXI@Z ENDP	; CvWeightedVector<int,80,1>::resize
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU3@IABU3@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T226212 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$226215 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU3@IABU3@@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$226215[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T226212[esp+12], 0
	mov	eax, DWORD PTR $T226212[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU3@IABU3@@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXPAULeaderWithNumTechs@@0@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXPAULeaderWithNumTechs@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXPAULeaderWithNumTechs@@0@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXPAULeaderWithNumTechs@@0@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z
_TEXT	SEGMENT
$T226251 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$226254 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$226254[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T226251[esp+4], 0
	mov	eax, DWORD PTR $T226251[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z ; std::_Insertion_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@11ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@11ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T226329 = -4						; size = 1
$T226330 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@11ULeaderWithNumTechsEval@@@Z PROC ; stdext::unchecked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T226330[esp]
	mov	edx, DWORD PTR __Pred$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T226329[esp+8], 0
	mov	eax, DWORD PTR $T226329[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+16]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi

; 5160 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@11ULeaderWithNumTechsEval@@@Z ENDP ; stdext::unchecked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T226338 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Unchecked_merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T226338[esp+8], 0
	mov	eax, DWORD PTR $T226338[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5229 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T226347 = -20						; size = 20
$T226345 = -20						; size = 20
$T226343 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T226342 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T226346 = 40						; size = 4
$T226344 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __First$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	ebp, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	ebp, DWORD PTR __Count$[esp+32]
	jg	SHORT $LN3@Chunked_me
	npad	6
$LL5@Chunked_me:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [esi+edi*8]
	mov	DWORD PTR $T226342[esp+56], esp
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+76]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+68]
	push	eax
	lea	ecx, DWORD PTR $T226343[esp+76]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T226343[esp+80]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+48], edx
	cmp	eax, ebx
	je	SHORT $LN49@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Chunked_me:
	mov	eax, DWORD PTR __Count$[esp+32]
	sub	eax, ebp
	cmp	eax, ebp

; 3443 : 		_First = _Mid2;

	mov	DWORD PTR __First$[esp+32], esi
	mov	DWORD PTR __Count$[esp+32], eax
	jge	SHORT $LL5@Chunked_me
$LN3@Chunked_me:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	DWORD PTR __Count$[esp+32], edi
	jg	SHORT $LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+52]
	mov	eax, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T226344[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T226345[esp+64]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H

; 3448 : 	else

	jmp	SHORT $LN111@Chunked_me
$LN2@Chunked_me:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+32]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	DWORD PTR $T226346[esp+56], esp
	push	eax
	lea	ecx, DWORD PTR [esi+edi*8]
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+68]
	push	ecx
	lea	edx, DWORD PTR $T226347[esp+76]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
	add	esp, 44					; 0000002cH
$LN111@Chunked_me:
	mov	eax, DWORD PTR $T226347[esp+36]
	cmp	eax, ebx
	je	SHORT $LN87@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Chunked_me:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN97@Chunked_me
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T226577 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T226623 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T226731 = 24						; size = 1
$T226732 = 24						; size = 1
$T226624 = 24						; size = 1
$T226579 = 24						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ecx

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	eax, DWORD PTR __First$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+12]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, ecx
	jg	SHORT $LN3@Chunked_me@2
	push	ebx
	npad	4
$LL58@Chunked_me@2:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T226623[esp+16], 0
	mov	ebx, DWORD PTR $T226623[esp+16]
	push	ebx
	mov	ebx, DWORD PTR $T226624[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+24]
	push	ebx
	lea	ecx, DWORD PTR [eax+edi*8]
	push	edx
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	push	ecx
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T226577[esp+52]
	push	eax
	call	??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
	mov	ecx, DWORD PTR __Count$[esp+52]
	mov	edx, DWORD PTR $T226577[esp+56]
	sub	ecx, ebp
	add	esp, 36					; 00000024H
	cmp	ecx, ebp
	mov	DWORD PTR __Dest$[esp+16], edx

; 3443 : 		_First = _Mid2;

	mov	eax, esi
	mov	DWORD PTR __Count$[esp+16], ecx
	jge	SHORT $LL58@Chunked_me@2
	pop	ebx
$LN3@Chunked_me@2:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	ecx, edi
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+12]
	cmp	eax, ecx
	je	SHORT $LN49@Chunked_me@2
$LL32@Chunked_me@2:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], esi
	add	eax, 8
	add	edx, 8
	cmp	eax, ecx
	jne	SHORT $LL32@Chunked_me@2
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@2:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	BYTE PTR $T226731[esp+12], 0
	mov	ecx, DWORD PTR $T226731[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T226732[esp+16]
	push	ecx
	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	lea	edi, DWORD PTR [eax+edi*8]
	push	edi
	push	edi
	push	eax
	lea	eax, DWORD PTR $T226579[esp+44]
	push	eax
	call	??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
$LN49@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00@Z ; std::rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00@Z PROC ; std::rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN14@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN14@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
	add	esp, 20					; 00000014H
$LN14@rotate:

; 1721 : 	}

	ret	0
??$rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00@Z ENDP ; std::rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> > >
_TEXT	ENDS
PUBLIC	?Reset@CvTechAI@@QAEXXZ				; CvTechAI::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
;	COMDAT ?Reset@CvTechAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvTechAI@@QAEXXZ PROC				; CvTechAI::Reset, COMDAT
; _this$ = ecx

; 29   : {

	push	ebx
	push	ebp
	mov	ebp, ecx

; 30   : 	CvAssertMsg(m_pCurrentTechs != NULL, "Tech AI init failure: player tech data is NULL");
; 31   : 	if(m_pCurrentTechs != NULL)

	xor	ebx, ebx
	cmp	DWORD PTR [ebp], ebx
	je	SHORT $LN1@Reset

; 32   : 	{
; 33   : 		CvAssertMsg(m_pCurrentTechs->GetTechs() != NULL, "Tech AI init failure: no tech data");
; 34   : 
; 35   : 		m_TechAIWeights.clear();

	mov	DWORD PTR [ebp+8], ebx

; 36   : 
; 37   : 		// Loop through reading each one and add an entry with 0 weight to our vector
; 38   : #ifdef AUI_WARNING_FIXES
; 39   : 		for (uint i = 0; i < m_pCurrentTechs->GetTechs()->GetNumTechs(); i++)
; 40   : #else
; 41   : 		for(int i = 0; i < m_pCurrentTechs->GetTechs()->GetNumTechs(); i++)

	mov	ecx, DWORD PTR [ebp]
	push	edi
	xor	edi, edi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN33@Reset
	push	esi
	lea	esi, DWORD PTR [ebp+4]
	npad	8
$LL3@Reset:

; 42   : #endif
; 43   : 		{
; 44   : 			m_TechAIWeights.push_back(i, 0);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+652], bl
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN21@Reset
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN21@Reset:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	cmp	eax, ebx
	je	SHORT $LN24@Reset
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN24@Reset:
	inc	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ebp]
	inc	edi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	edi, eax
	jl	SHORT $LL3@Reset
	pop	esi
$LN33@Reset:
	pop	edi
$LN1@Reset:
	pop	ebp
	pop	ebx

; 45   : 		}
; 46   : 	}
; 47   : }

	ret	0
?Reset@CvTechAI@@QAEXXZ ENDP				; CvTechAI::Reset
_TEXT	ENDS
PUBLIC	?Read@CvTechAI@@QAEXAAVFDataStream@@@Z		; CvTechAI::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvTechAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iWeight$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_iCount$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvTechAI@@QAEXAAVFDataStream@@@Z PROC		; CvTechAI::Read, COMDAT
; _this$ = ecx

; 52   : {

	sub	esp, 8
	push	ebx
	push	ebp

; 53   : 	// Version number to maintain backwards compatibility
; 54   : 	uint uiVersion;
; 55   : 	kStream >> uiVersion;

	mov	ebp, DWORD PTR _kStream$[esp+12]
	push	esi
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+24]
	mov	edi, ecx
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 56   : 
; 57   : 	int iWeight;
; 58   : 
; 59   : 	CvAssertMsg(m_pCurrentTechs->GetTechs() != NULL, "Tech AI serialization failure: no tech data");
; 60   : 	CvAssertMsg(m_pCurrentTechs->GetTechs()->GetNumTechs() > 0, "Tech AI serialization failure: number of techs not greater than 0");
; 61   : 
; 62   : 	// Reset vector
; 63   : 	m_TechAIWeights.clear();

	xor	ebx, ebx
	mov	DWORD PTR [edi+8], ebx

; 64   : 	int iTechCount = m_pCurrentTechs->GetTechs()->GetNumTechs();

	mov	ecx, DWORD PTR [edi]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	esi, eax

; 65   : 	m_TechAIWeights.resize(iTechCount);

	add	edi, 4
	cmp	DWORD PTR [edi+8], esi
	jae	SHORT $LN24@Read
	push	esi
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN24@Read:

; 66   : 	for(int i = 0; i < iTechCount; ++i)

	xor	eax, eax
	cmp	esi, ebx
	mov	DWORD PTR [edi+4], esi
	jle	SHORT $LN5@Read
$LL7@Read:

; 67   : 		m_TechAIWeights.SetWeight(i, 0);

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax*8+4], ebx
	inc	eax
	cmp	eax, esi
	jl	SHORT $LL7@Read
$LN5@Read:

; 68   : 
; 69   : 	int iCount;
; 70   : 	kStream >> iCount;

	lea	edx, DWORD PTR _iCount$[esp+20]
	push	edx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 71   : 
; 72   : 	for(int i = 0; i < iCount; i++)

	cmp	DWORD PTR _iCount$[esp+20], ebx
	jle	SHORT $LN2@Read
$LL44@Read:

; 73   : 	{
; 74   : 		int iIndex = CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	push	ebp
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 75   : 		kStream >> iWeight;

	lea	eax, DWORD PTR _iWeight$[esp+24]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 76   : 		if(iIndex >= 0 && iIndex < iCount)

	test	esi, esi
	jl	SHORT $LN3@Read
	cmp	esi, DWORD PTR _iCount$[esp+20]
	jge	SHORT $LN3@Read

; 77   : 			m_TechAIWeights.SetWeight(iIndex, iWeight);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _iWeight$[esp+24]
	mov	DWORD PTR [ecx+esi*8+4], edx
$LN3@Read:
	inc	ebx
	cmp	ebx, DWORD PTR _iCount$[esp+20]
	jl	SHORT $LL44@Read
$LN2@Read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 78   : 	}
; 79   : }

	add	esp, 8
	ret	4
?Read@CvTechAI@@QAEXAAVFDataStream@@@Z ENDP		; CvTechAI::Read
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Umove@PAULeaderWithNumTechs@@@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU2@00@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Umove<LeaderWithNumTechs *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAULeaderWithNumTechs@@@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU2@00@Z
_TEXT	SEGMENT
$T227002 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$227005 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAULeaderWithNumTechs@@@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU2@00@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Umove<LeaderWithNumTechs *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$227005[esp]
	mov	BYTE PTR $T227002[esp+4], 0
	mov	eax, DWORD PTR $T227002[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAULeaderWithNumTechs@@@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU2@00@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Umove<LeaderWithNumTechs *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T227016 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T227017 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T227016[esp+8], bl
	mov	eax, DWORD PTR $T227016[esp+8]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+8]
	push	ecx
	push	edx
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T227017[esp+40], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>

; 5287 : 	}

	mov	eax, DWORD PTR __Dest$[esp+48]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@2:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@stdext@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HHULeaderWithNumTechsEval@@@Z ; stdext::_Unchecked_chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@stdext@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HHULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T227053 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Unchecked_chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@stdext@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HHULeaderWithNumTechsEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T227053[esp+4], 0
	mov	eax, DWORD PTR $T227053[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@stdext@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HHULeaderWithNumTechsEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z
_TEXT	SEGMENT
$T227061 = -20						; size = 20
$T227058 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
$T227233 = 24						; size = 1
__Cat$227238 = 24					; size = 1
$T227235 = 24						; size = 1
$T227201 = 24						; size = 1
__Cat$227206 = 24					; size = 1
$T227203 = 24						; size = 1
$T227144 = 24						; size = 1
__Cat$227148 = 24					; size = 1
$T227146 = 24						; size = 1
$T227111 = 24						; size = 1
__Cat$227116 = 24					; size = 1
$T227113 = 24						; size = 1
$T227062 = 24						; size = 4
$T227060 = 24						; size = 4
$T227059 = 24						; size = 4
$T227057 = 24						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Count2$[esp+24]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebp
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+52]
	mov	ecx, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T227057[esp+52], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T227058[esp+64]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	mov	eax, DWORD PTR $T227058[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T227111[esp+32], bl
	mov	eax, DWORD PTR $T227111[esp+32]
	mov	ecx, DWORD PTR __Cat$227116[esp+32]
	mov	edx, DWORD PTR $T227113[esp+32]
	push	eax
	mov	eax, DWORD PTR __First$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+40]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+44]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T227059[esp+56]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T227144[esp+60], bl
	mov	ecx, DWORD PTR $T227144[esp+60]
	mov	edx, DWORD PTR __Cat$227148[esp+60]
	mov	eax, DWORD PTR $T227146[esp+60]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+64]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	ebp, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+52]
	mov	ecx, DWORD PTR __Mid$[esp+52]
	mov	DWORD PTR $T227060[esp+52], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T227061[esp+64]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	mov	eax, DWORD PTR $T227061[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T227201[esp+32], bl
	mov	eax, DWORD PTR $T227201[esp+32]
	mov	ecx, DWORD PTR __Cat$227206[esp+32]
	mov	edx, DWORD PTR $T227203[esp+32]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+40]
	push	edx
	mov	edx, DWORD PTR __First$[esp+44]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T227062[esp+56]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T227233[esp+60], bl
	mov	ecx, DWORD PTR $T227233[esp+60]
	mov	edx, DWORD PTR __Cat$227238[esp+60]
	mov	eax, DWORD PTR $T227235[esp+60]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+64]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __First$[esp+32]
	mov	ecx, DWORD PTR __Mid$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r
	mov	edx, DWORD PTR __Last$[esp+32]
	cmp	ecx, edx
	je	SHORT $LN88@Buffered_r
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
	mov	eax, DWORD PTR __First$[esp+52]
	add	esp, 20					; 00000014H
$LN88@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);
; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	ecx, DWORD PTR [eax+ebp*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$2
__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$0
__unwindtable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
__Tmp$219151 = -24					; size = 8
__Tmp$219141 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$227565 = 8					; size = 1
__Cat$227493 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$219126 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T227561 = 16						; size = 1
$T227489 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ; std::_Allocate<LeaderWithNumTechs>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$219126[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU3@IABU3@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$227493[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T227489[ebp], 0
	mov	ecx, DWORD PTR $T227489[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$219126[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T227561[ebp], 0
	mov	edx, DWORD PTR $T227561[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$227565[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$219126[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$219126[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$219141[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$219141[ebp], edx
	call	??$_Umove@PAULeaderWithNumTechs@@@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU2@00@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Umove<LeaderWithNumTechs *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$219141[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU3@IABU3@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$219141[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z ; std::fill<LeaderWithNumTechs *,LeaderWithNumTechs>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$219151[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$219151[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAULeaderWithNumTechs@@@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEPAULeaderWithNumTechs@@PAU2@00@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Umove<LeaderWithNumTechs *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAULeaderWithNumTechs@@PAU1@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00@Z ; stdext::_Unchecked_move_backward<LeaderWithNumTechs *,LeaderWithNumTechs *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$219151[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAULeaderWithNumTechs@@U1@@std@@YAXPAULeaderWithNumTechs@@0ABU1@@Z ; std::fill<LeaderWithNumTechs *,LeaderWithNumTechs>
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z
_TEXT	SEGMENT
__Mid$219584 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$219584[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$219584[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$219584[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$219584[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T227756 = -8						; size = 1
$T227727 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T227726 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+20]
	push	ebx
	push	ecx
	lea	esi, DWORD PTR [eax+256]
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m
$LN4@Buffered_m:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
	npad	2
$LL3@Buffered_m:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T227726[esp+20], bl
	mov	eax, DWORD PTR $T227726[esp+20]
	push	eax
	push	edx
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T227727[esp+60], esp
	push	eax
	push	ecx
	call	??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	eax, DWORD PTR [ebp+16]
	mov	BYTE PTR $T227756[esp+68], bl
	mov	edx, DWORD PTR $T227756[esp+68]
	push	edx
	mov	edx, DWORD PTR __First$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
	add	esi, esi
	add	esp, 72					; 00000048H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m
$LN1@Buffered_m:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
tv518 = -24						; size = 4
$T228078 = -24						; size = 4
$T227988 = -24						; size = 4
$T227770 = -20						; size = 20
$T227767 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T227919 = 20						; size = 1
__Midn$220162 = 20					; size = 4
$T227771 = 20						; size = 4
$T227769 = 20						; size = 4
$T227768 = 20						; size = 4
$T227766 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+4]
	jle	$LN3@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	edx, ecx
	cmp	ecx, eax
	je	$LN3@Buffered_m@2
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ecx

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m@2:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m@2
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m@2

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T227766[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T227767[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	mov	eax, DWORD PTR $T227767[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN53@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN53@Buffered_m@2:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+36]
	mov	ecx, DWORD PTR __First$[esp+36]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	push	eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T227768[esp+60]
	push	eax
	call	??$unchecked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@0V12@11ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
	add	esp, 28					; 0000001cH

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m@2:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m@2

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T227769[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T227770[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	mov	eax, DWORD PTR $T227770[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN73@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN73@Buffered_m@2:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	BYTE PTR $T227919[esp+36], bl
	mov	eax, DWORD PTR $T227919[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+48]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T227771[esp+64]
	push	ecx
	call	??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
	add	esp, 32					; 00000020H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m@2:

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	push	0
	jge	SHORT $LN2@Buffered_m@2
	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	edi, eax
	mov	eax, DWORD PTR __Pred$[esp+40]
	push	eax
	sar	edi, 1
	lea	ebp, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR __Mid$[esp+44]
	push	ebp
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T227988[esp+60]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
	mov	ebx, DWORD PTR [eax]

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+60]
	add	esp, 24					; 00000018H
	sar	esi, 3

; 2918 : 			}
; 2919 : 		else

	jmp	SHORT $LN139@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+40]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	push	ecx
	sar	esi, 1
	lea	ebx, DWORD PTR [eax+esi*8]
	push	ebx
	push	eax
	push	edx
	lea	eax, DWORD PTR $T228078[esp+60]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
	mov	ebp, DWORD PTR [eax]

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+60]
	add	esp, 24					; 00000018H
	sar	edi, 3
$LN139@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	mov	DWORD PTR tv518[esp+60], eax
	lea	eax, DWORD PTR __Midn$220162[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[esp+64]
	mov	edx, DWORD PTR __Tempbuf$[esp+64]
	mov	eax, DWORD PTR __First$[esp+64]
	push	ecx
	push	edx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Midn$220162[esp+80]
	push	edi
	push	ebp
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+92]
	mov	edx, DWORD PTR __Tempbuf$[esp+92]
	mov	eax, DWORD PTR __Count2$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+96]
	push	edx
	sub	eax, esi
	push	eax
	mov	eax, DWORD PTR tv518[esp+108]
	push	eax
	push	ecx
	push	ebx
	push	edi
	call	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 84					; 00000054H
$LN3@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::insert
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::sort<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::sort<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::sort<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	edi

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
	add	esp, 16					; 00000010H
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+esi*8]
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	ebx
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN21@Stable_sor
$LN2@Stable_sor:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+12]
	mov	eax, DWORD PTR __First$[esp+12]
	push	edx
	push	ebp
	push	esi
	push	ebx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+32]
	mov	edx, DWORD PTR __Last$[esp+32]
	push	ecx
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
$LN21@Stable_sor:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	eax, DWORD PTR __Pred$[esp+52]
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	eax
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 28					; 0000001cH
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@H$0FA@$00@@QAEXXZ	; CvWeightedVector<int,80,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@H$0FA@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@H$0FA@$00@@QAEXXZ PROC	; CvWeightedVector<int,80,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@H$0FA@$00@@QAEXXZ ENDP	; CvWeightedVector<int,80,1>::SortItems
_TEXT	ENDS
PUBLIC	?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
$T228284 = -4						; size = 1
__Cat$228287 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$228287[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T228284[esp+12], 0
	mov	eax, DWORD PTR $T228284[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::push_back
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+40]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>

; 3565 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+64]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN24@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
PUBLIC	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ; CvTechAI::ChooseNextTech
EXTRN	?GetTechNumOptions@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::GetTechNumOptions
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z:PROC ; CvPlayerTechs::CanResearchForFree
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
;	COMDAT ?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
_fcn$ = -16						; size = 8
_elem$228668 = -8					; size = 8
_pPlayer$ = 8						; size = 4
_rtnValue$228756 = 12					; size = 4
_bFreeTech$ = 12					; size = 1
?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z PROC ; CvTechAI::ChooseNextTech, COMDAT
; _this$ = ecx

; 174  : {

	sub	esp, 16					; 00000010H

; 175  : 	RandomNumberDelegate fcn;
; 176  : 	TechTypes rtnValue = NO_TECH;
; 177  : #ifdef AUI_WARNING_FIXES
; 178  : 	uint iTechLoop;
; 179  : #else
; 180  : 	int iTechLoop;
; 181  : #endif
; 182  : 
; 183  : 	// Use the synchronous random number generate
; 184  : 	// Asynchronous one would be:
; 185  : 	//	fcn = MakeDelegate (&GC.getGame(), &CvGame::getAsyncRandNum);
; 186  : 	fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 187  : 
; 188  : 	// Create a new vector holding only techs we can currently research
; 189  : 	m_ResearchableTechs.clear();

	xor	esi, esi
	mov	DWORD PTR [edi+664], esi

; 190  : 
; 191  : 	// Loop through adding the researchable techs
; 192  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR _fcn$[esp+36], OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	DWORD PTR _fcn$[esp+32], eax
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN7@ChooseNext
$LL124@ChooseNext:

; 193  : 	{
; 194  : 		if(m_pCurrentTechs->CanResearch((TechTypes)iTechLoop))

	mov	ecx, DWORD PTR [edi]
	push	0
	push	esi
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN8@ChooseNext

; 195  : 		{
; 196  : 			// For free techs, need an additional check
; 197  : 			if(bFreeTech)

	cmp	BYTE PTR _bFreeTech$[esp+28], 0
	je	SHORT $LN5@ChooseNext

; 198  : 			{
; 199  : 				if(m_pCurrentTechs->CanResearchForFree((TechTypes)iTechLoop))

	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanResearchForFree
	test	al, al
	je	SHORT $LN8@ChooseNext
$LN5@ChooseNext:

; 200  : 				{
; 201  : 					m_ResearchableTechs.push_back(iTechLoop, m_TechAIWeights.GetWeight(iTechLoop));
; 202  : 				}
; 203  : 			}
; 204  : 			else
; 205  : 			{
; 206  : 				m_ResearchableTechs.push_back(iTechLoop, m_TechAIWeights.GetWeight(iTechLoop));

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax+esi*8]
	mov	ebx, DWORD PTR [eax+esi*8+4]
	mov	eax, DWORD PTR [edi+668]
	cmp	DWORD PTR [edi+664], eax
	lea	ebp, DWORD PTR [edi+660]
	mov	BYTE PTR [ebp+652], 0
	mov	DWORD PTR _elem$228668[esp+32], ecx
	jne	SHORT $LN84@ChooseNext
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN84@ChooseNext:
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [ebp]
	lea	eax, DWORD PTR [eax+edx*8]
	test	eax, eax
	je	SHORT $LN87@ChooseNext
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
$LN87@ChooseNext:
	inc	DWORD PTR [ebp+4]
$LN8@ChooseNext:

; 190  : 
; 191  : 	// Loop through adding the researchable techs
; 192  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, DWORD PTR [edi]
	inc	esi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	esi, eax
	jl	SHORT $LL124@ChooseNext
$LN7@ChooseNext:

; 207  : 			}
; 208  : 		}
; 209  : 	}
; 210  : 
; 211  : 	// Reweight our possible choices by their cost, but only if cost is actually a factor!
; 212  : 	if(!bFreeTech)

	cmp	BYTE PTR _bFreeTech$[esp+28], 0
	jne	SHORT $LN2@ChooseNext

; 213  : 		ReweightByCost(pPlayer);

	mov	ecx, DWORD PTR _pPlayer$[esp+28]
	push	ecx
	mov	ecx, edi
	call	?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z ; CvTechAI::ReweightByCost
$LN2@ChooseNext:

; 214  : 
; 215  : 	m_ResearchableTechs.SortItems();

	mov	eax, DWORD PTR [edi+660]
	mov	edx, DWORD PTR [edi+664]
	lea	esi, DWORD PTR [edi+660]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	xor	ebp, ebp
	xor	ebx, ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 216  : 	LogPossibleResearch();

	mov	ecx, edi
	call	?LogPossibleResearch@CvTechAI@@AAEXXZ	; CvTechAI::LogPossibleResearch
	mov	ecx, DWORD PTR [esi+4]

; 217  : 
; 218  : 	// If total weight is above 0, choose one above a threshold
; 219  : 	if(m_ResearchableTechs.GetTotalWeight() > 0)

	xor	eax, eax
	xor	edx, edx
	cmp	ecx, 2
	mov	DWORD PTR _rtnValue$228756[esp+28], eax
	jl	SHORT $LC120@ChooseNext
	mov	eax, DWORD PTR [esi]
	add	ecx, -2					; fffffffeH
	shr	ecx, 1
	add	eax, 12					; 0000000cH
	inc	ecx
	lea	edx, DWORD PTR [ecx+ecx]
$LL121@ChooseNext:
	add	ebp, DWORD PTR [eax-8]
	add	ebx, DWORD PTR [eax]
	add	eax, 16					; 00000010H
	sub	ecx, 1
	jne	SHORT $LL121@ChooseNext
	mov	eax, DWORD PTR _rtnValue$228756[esp+28]
$LC120@ChooseNext:
	cmp	edx, DWORD PTR [esi+4]
	jae	SHORT $LN119@ChooseNext
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+edx*8+4]
$LN119@ChooseNext:
	add	ebp, ebx
	add	ebp, eax
	test	ebp, ebp
	jle	SHORT $LN122@ChooseNext

; 220  : 	{
; 221  : 		int iNumChoices =GC.getGame().getHandicapInfo().GetTechNumOptions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?GetTechNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetTechNumOptions

; 222  : 		rtnValue = (TechTypes) m_ResearchableTechs.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing tech from Top Choices");

	push	OFFSET $SG218248
	lea	ecx, DWORD PTR _fcn$[esp+36]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,80,1>::ChooseFromTopChoices
	mov	esi, eax

; 223  : 		LogResearchChoice(rtnValue);

	push	esi
	mov	ecx, edi
	call	?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ; CvTechAI::LogResearchChoice
	pop	edi

; 224  : 	}
; 225  : 
; 226  : 	return rtnValue;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 227  : }

	add	esp, 16					; 00000010H
	ret	8
$LN122@ChooseNext:
	pop	edi
	pop	esi
	pop	ebp

; 224  : 	}
; 225  : 
; 226  : 	return rtnValue;

	or	eax, -1
	pop	ebx

; 227  : }

	add	esp, 16					; 00000010H
	ret	8
?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ENDP ; CvTechAI::ChooseNextTech
_TEXT	ENDS
PUBLIC	?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z ; CvTechAI::RecommendNextTech
; Function compile flags: /Ogtpy
;	COMDAT ?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z
_TEXT	SEGMENT
_elem$228831 = -8					; size = 8
_pPlayer$ = 8						; size = 4
_rtnValue$228919 = 12					; size = 4
_eIgnoreTech$ = 12					; size = 4
?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z PROC ; CvTechAI::RecommendNextTech, COMDAT
; _this$ = ecx

; 231  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 232  : 	TechTypes rtnValue = NO_TECH;
; 233  : #ifdef AUI_WARNING_FIXES
; 234  : 	uint iTechLoop;
; 235  : #else
; 236  : 	int iTechLoop;
; 237  : #endif
; 238  : 
; 239  : 	// Create a new vector holding only techs we can currently research
; 240  : 	m_ResearchableTechs.clear();

	xor	ebp, ebp
	mov	DWORD PTR [esi+664], ebp

; 241  : 
; 242  : 	// Loop through adding the researchable techs
; 243  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	test	eax, eax
	jle	SHORT $LN3@RecommendN
$LL70@RecommendN:

; 244  : 	{
; 245  : 		//if (m_pCurrentTechs->CanResearch((TechTypes) iTechLoop) &&
; 246  : 		//	iTechLoop != eIgnoreTech &&
; 247  : 		//	m_pCurrentTechs->GetTechs()->GetEntry(iTechLoop)->GetAdvisorType() != eIgnoreAdvisor)
; 248  : #ifdef AUI_WARNING_FIXES
; 249  : 		if (m_pCurrentTechs->CanResearch((TechTypes)iTechLoop) && (TechTypes)iTechLoop != eIgnoreTech)
; 250  : #else
; 251  : 		if(m_pCurrentTechs->CanResearch((TechTypes) iTechLoop) && iTechLoop != eIgnoreTech)

	mov	ecx, DWORD PTR [esi]
	push	0
	push	ebp
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN4@RecommendN
	cmp	ebp, DWORD PTR _eIgnoreTech$[esp+20]
	je	SHORT $LN4@RecommendN

; 252  : #endif
; 253  : 		{
; 254  : 			m_ResearchableTechs.push_back(iTechLoop, m_TechAIWeights.GetWeight(iTechLoop));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+ebp*8]
	mov	ebx, DWORD PTR [eax+ebp*8+4]
	mov	eax, DWORD PTR [esi+668]
	lea	edi, DWORD PTR [esi+660]
	mov	DWORD PTR _elem$228831[esp+24], ecx
	mov	BYTE PTR [edi+652], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN28@RecommendN
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN28@RecommendN:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*8]
	test	eax, eax
	je	SHORT $LN31@RecommendN
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebx
$LN31@RecommendN:
	inc	DWORD PTR [edi+4]
$LN4@RecommendN:

; 241  : 
; 242  : 	// Loop through adding the researchable techs
; 243  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	ecx, DWORD PTR [esi]
	inc	ebp
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	ebp, eax
	jl	SHORT $LL70@RecommendN
$LN3@RecommendN:

; 255  : 		}
; 256  : 	}
; 257  : 
; 258  : 	ReweightByCost(pPlayer);

	mov	ecx, DWORD PTR _pPlayer$[esp+20]
	push	ecx
	mov	ecx, esi
	xor	edi, edi
	xor	ebp, ebp
	call	?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z ; CvTechAI::ReweightByCost

; 259  : 	m_ResearchableTechs.SortItems();

	mov	eax, DWORD PTR [esi+660]
	mov	edx, DWORD PTR [esi+664]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 260  : 	LogPossibleResearch();

	mov	ecx, esi
	call	?LogPossibleResearch@CvTechAI@@AAEXXZ	; CvTechAI::LogPossibleResearch
	mov	edx, DWORD PTR [esi+664]

; 261  : 
; 262  : 	// If total weight is above 0, choose top choice as recommendation
; 263  : 	if(m_ResearchableTechs.GetTotalWeight() > 0)

	xor	eax, eax
	xor	ebx, ebx
	cmp	edx, 2
	mov	DWORD PTR _rtnValue$228919[esp+20], eax
	jl	SHORT $LC66@RecommendN
	mov	eax, DWORD PTR [esi+660]
	lea	ecx, DWORD PTR [edx-2]
	shr	ecx, 1
	add	eax, 12					; 0000000cH
	inc	ecx
	lea	ebx, DWORD PTR [ecx+ecx]
	npad	7
$LL67@RecommendN:
	add	edi, DWORD PTR [eax-8]
	add	ebp, DWORD PTR [eax]
	add	eax, 16					; 00000010H
	sub	ecx, 1
	jne	SHORT $LL67@RecommendN
	mov	eax, DWORD PTR _rtnValue$228919[esp+20]
$LC66@RecommendN:
	cmp	ebx, edx
	jae	SHORT $LN65@RecommendN
	mov	eax, DWORD PTR [esi+660]
	mov	eax, DWORD PTR [eax+ebx*8+4]
$LN65@RecommendN:
	add	edi, ebp
	add	edi, eax
	test	edi, edi
	jle	SHORT $LN68@RecommendN

; 264  : 	{
; 265  : 
; 266  : 		rtnValue = (TechTypes) m_ResearchableTechs.GetElement(0);

	mov	ecx, DWORD PTR [esi+660]
	mov	edi, DWORD PTR [ecx]

; 267  : 		LogResearchChoice(rtnValue);

	push	edi
	mov	ecx, esi
	call	?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ; CvTechAI::LogResearchChoice

; 268  : 	}
; 269  : 
; 270  : 	return rtnValue;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 271  : }

	add	esp, 8
	ret	8
$LN68@RecommendN:
	pop	edi
	pop	esi
	pop	ebp

; 268  : 	}
; 269  : 
; 270  : 	return rtnValue;

	or	eax, -1
	pop	ebx

; 271  : }

	add	esp, 8
	ret	8
?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z ENDP ; CvTechAI::RecommendNextTech
_TEXT	ENDS
PUBLIC	??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z ; std::stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z PROC ; std::stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H
$LN1@stable_sor:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	?GetTechRatio@CvTechAI@@QAEMXZ			; CvTechAI::GetTechRatio
EXTRN	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ:PROC	; CvTeamTechs::GetNumTechsKnown
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GetTechRatio@CvTechAI@@QAEMXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTechRatio@CvTechAI@@QAEMXZ$0
__ehfuncinfo$?GetTechRatio@CvTechAI@@QAEMXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTechRatio@CvTechAI@@QAEMXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\cleanup (v1)\lekmod files\lekmod dll versions\v30\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?GetTechRatio@CvTechAI@@QAEMXZ
_TEXT	SEGMENT
_fTechPositionRatio$ = -48				; size = 4
_this$ = -48						; size = 4
tv683 = -44						; size = 4
$T228967 = -44						; size = 1
$T229313 = -44						; size = 1
__Cat$229316 = -44					; size = 1
_iPlayerIndexInList$ = -44				; size = 4
_kEvalChunk$218600 = -40				; size = 8
_aLeaderWithNumTechs$ = -32				; size = 16
__$EHRec$ = -12						; size = 12
?GetTechRatio@CvTechAI@@QAEMXZ PROC			; CvTechAI::GetTechRatio, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?GetTechRatio@CvTechAI@@QAEMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi

; 295  : 	// create list of all civs with the number of techs they control
; 296  : 	std::vector<LeaderWithNumTechs> aLeaderWithNumTechs;

	xor	esi, esi
	xor	ebp, ebp
	push	edi
	mov	DWORD PTR _this$[esp+64], ecx
	mov	DWORD PTR _aLeaderWithNumTechs$[esp+68], ebp
	mov	DWORD PTR _aLeaderWithNumTechs$[esp+72], esi
	mov	DWORD PTR _aLeaderWithNumTechs$[esp+76], esi

; 297  : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+72], esi
	xor	edi, edi
	npad	2
$LL9@GetTechRat:

; 298  : 	{
; 299  : 		PlayerTypes ePlayer = (PlayerTypes)ui;
; 300  : 		if(!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [edi+eax+2256], 0
	je	$LN8@GetTechRat

; 301  : 		{
; 302  : 			continue;
; 303  : 		}
; 304  : 
; 305  : 		LeaderWithNumTechs kEvalChunk;
; 306  : 		kEvalChunk.m_iLeader = ui;
; 307  : 		kEvalChunk.m_iNumTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	eax, DWORD PTR [edi+eax+44]
	mov	DWORD PTR _kEvalChunk$218600[esp+64], ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN62@GetTechRat
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN63@GetTechRat
$LN62@GetTechRat:
	or	eax, -1
$LN63@GetTechRat:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	mov	DWORD PTR _kEvalChunk$218600[esp+68], eax

; 308  : 		aLeaderWithNumTechs.push_back(kEvalChunk);

	test	ebp, ebp
	jne	SHORT $LN77@GetTechRat
	xor	eax, eax
	jmp	SHORT $LN78@GetTechRat
$LN77@GetTechRat:
	mov	eax, DWORD PTR _aLeaderWithNumTechs$[esp+76]
	sub	eax, ebp
	sar	eax, 3
$LN78@GetTechRat:
	mov	ecx, esi
	sub	ecx, ebp
	sar	ecx, 3
	cmp	ecx, eax
	lea	ecx, DWORD PTR _aLeaderWithNumTechs$[esp+64]
	jae	SHORT $LN70@GetTechRat
	mov	BYTE PTR $T229313[esp+64], 0
	mov	edx, DWORD PTR $T229313[esp+64]
	mov	eax, DWORD PTR __Cat$229316[esp+64]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _kEvalChunk$218600[esp+76]
	push	edx
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H
	add	esi, 8
	mov	DWORD PTR _aLeaderWithNumTechs$[esp+72], esi
	jmp	SHORT $LN8@GetTechRat
$LN70@GetTechRat:
	lea	eax, DWORD PTR _kEvalChunk$218600[esp+64]
	push	eax
	push	1
	push	esi
	call	?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n
	mov	esi, DWORD PTR _aLeaderWithNumTechs$[esp+72]
	mov	ebp, DWORD PTR _aLeaderWithNumTechs$[esp+68]
$LN8@GetTechRat:
	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 1391192				; 00153a58H
	jb	$LL9@GetTechRat

; 309  : 	}
; 310  : 
; 311  : 	std::stable_sort(aLeaderWithNumTechs.begin(), aLeaderWithNumTechs.end(), LeaderWithNumTechsEval());

	mov	BYTE PTR $T228967[esp+64], 0
	cmp	ebp, esi
	je	SHORT $LN129@GetTechRat
	mov	ecx, DWORD PTR $T228967[esp+64]
	push	ecx
	push	0
	push	0
	push	esi
	push	ebp
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H
$LN129@GetTechRat:

; 312  : 
; 313  : 	int iPlayerIndexInList = -1;
; 314  : 	for(uint ui = 0; ui < aLeaderWithNumTechs.size(); ui++)

	sub	esi, ebp
	sar	esi, 3
	xor	edi, edi
	mov	DWORD PTR _iPlayerIndexInList$[esp+64], -1
	test	esi, esi
	jbe	SHORT $LN3@GetTechRat
$LN5@GetTechRat:

; 315  : 	{
; 316  : 		if(aLeaderWithNumTechs[ui].m_iLeader == m_pCurrentTechs->GetPlayer()->GetID())

	mov	edx, DWORD PTR _this$[esp+64]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, DWORD PTR [ebp+edi*8]
	cmp	ecx, DWORD PTR [eax+44]
	je	SHORT $LN161@GetTechRat
	inc	edi
	cmp	edi, esi
	jb	SHORT $LN5@GetTechRat
	jmp	SHORT $LN3@GetTechRat
$LN161@GetTechRat:

; 317  : 		{
; 318  : 			iPlayerIndexInList = ui;

	mov	DWORD PTR _iPlayerIndexInList$[esp+64], edi
$LN3@GetTechRat:

; 319  : 			break;
; 320  : 		}
; 321  : 	}
; 322  : 
; 323  : 	CvAssertMsg(iPlayerIndexInList != -1, "Could not find player in list");
; 324  : 	CvAssertMsg(aLeaderWithNumTechs.size() >= 2, "Only one player in the game? Huh?");
; 325  : 	float fTechPositionRatio = 0.0f;

	mov	DWORD PTR _fTechPositionRatio$[esp+64], 0

; 326  : 	if(aLeaderWithNumTechs.size() >= 2)

	cmp	esi, 2
	jb	SHORT $LN1@GetTechRat

; 327  : 	{
; 328  : 		int iNumerator = iPlayerIndexInList;
; 329  : 		int iDenominator = aLeaderWithNumTechs.size() - 1;
; 330  : 		fTechPositionRatio = iNumerator / (float)iDenominator;

	fild	DWORD PTR _iPlayerIndexInList$[esp+64]
	dec	esi
	mov	DWORD PTR tv683[esp+64], esi
	fidiv	DWORD PTR tv683[esp+64]
	fstp	DWORD PTR _fTechPositionRatio$[esp+64]
$LN1@GetTechRat:

; 331  : 	}
; 332  : 
; 333  : 	return fTechPositionRatio;

	test	ebp, ebp
	je	SHORT $LN164@GetTechRat
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN164@GetTechRat:

; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	fld	DWORD PTR _fTechPositionRatio$[esp+64]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTechRatio@CvTechAI@@QAEMXZ$0:
	lea	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp]
	jmp	??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
__ehhandler$?GetTechRatio@CvTechAI@@QAEMXZ:
	mov	eax, OFFSET __ehfuncinfo$?GetTechRatio@CvTechAI@@QAEMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTechRatio@CvTechAI@@QAEMXZ ENDP			; CvTechAI::GetTechRatio
END
